import {
  de as ChartType,
  d8 as lodash,
  dE as FormatType,
  dh as createFormatter,
  dF as percentFormatter,
  dG as PrecisionType,
  dc as getFieldFormat,
  dH as getMinMaxFromDomain,
  dI as getDomainFromDataset,
  d9 as chroma,
  dJ as getColorItems,
  dK as Origin,
  dL as getColorsFromScheme,
  df as Role,
  dM as LabelColor,
  dN as LabelPos,
  dO as LabelSmartInverseColor,
  dP as LegendPos,
  di as INVALID_VALUE_MAP$5,
  dd as SpecialValueType$1,
  dQ as LegendAlign,
  dg as Location,
  dq as createFieldFormatter,
  dR as AnimationType,
  dS as LineStyleType,
  dT as AxisRatioType,
  da as intl,
  dU as AxisDomainType,
  dV as CombinationLayout,
  dW as GaugeType,
  dX as MeasureParamType,
  dY as ProgressType,
  du as getFields,
  dC as isRenderField,
  dZ as DisplayMode,
  d_ as RenderInvalid,
  d$ as INVALID_TYPE_MAP,
  e0 as LineSymbol,
  e1 as defaultLineStyle,
  e2 as CombinationChartType,
  e3 as DualAxisChartType,
  e4 as FunnelOrient,
  e5 as PillSourceType,
  e6 as DataSourceType,
  e7 as FieldRoleType,
  e8 as mapDataFormat,
  dr as generateHash,
  e9 as SectionValueType,
  ds as getCellByMark,
  ea as LabelContent,
  dw as getOriginalFields,
  eb as LabelType,
  ec as LabelShowRule,
  ed as EffectiveRange,
  ee as LabelShowRuleMode,
  ef as LabelMode,
  eg as PieCenterValueType,
  eh as PieCenterValueFormatType,
  ei as FONTSIZE_AUTO,
  ej as DialMeasureDisplayType,
  ek as LiquidShapeType,
  el as ReferenceLineStyle,
  em as ReferenceLineLabelAlign,
  en as SankeyShape,
  dp as converStringToNumber,
  eo as HistogramShowType,
  ep as WaterfallColorsDictKey,
  eq as defaultConfig,
  dB as isNumberType,
  er as hooks,
  es as Order,
  et as ContentType,
  eu as CombinedElementType,
  dm as calcCombinedLabel,
  ev as DrillType,
  ew as PillDrillStatus,
  dx as getOriginalMeasures,
  ex as measureCardDefaultConfig,
} from "../entry/index.7886b0f6.js";
import {
  g as getColorScheme,
  e as getChartColorsFromScheme,
  i as isGradientsColor,
  f as getColorFromGradients,
  t as transformLinerColorStr,
  c as LINES_MAP,
  b as LEGEND_TYPE,
  a as LEGEND_ID,
  L as LEGEND_ALIGN_MAP,
  d as conditionalConfigToLegendConfig,
  h as getDataItemsColorMap,
} from "./conditionalColorLegend.ce7d939d.js";
import vizSchema, {
  TableIconType,
  OKRTableColumnPeriodType,
} from "./index.59d0ed8e.js";
import {
  t as tau$1,
  h as halfPi$2,
  A as AABBBounds$1,
  d as degreeToRadian$2,
  P as Point$1,
  a as PointService$1,
  b as abs$1,
  c as atan2$1,
  m as max$1,
  e as min$1,
  f as epsilon$1,
  M as Matrix$1,
  p as pi2$1,
  L as Logger$1,
  E as EventEmitter,
  i as isBoolean$2,
  g as isObject$2,
  j as isFunction$2,
  k as isArray$2,
  l as cos$1,
  s as sin$1,
  n as pi$1,
  o as pointAt$1,
  q as isString$2,
  C as Color$1,
  r as isNumber$2,
  O as OBBBounds,
  u as isNil$2,
  v as has$2,
  w as normalTransform$1,
  x as isValidUrl$2,
  y as isBase64$2,
  z as getContextFont$2,
  B as rotatePoint,
  D as transformBoundsWithMatrix$1,
} from "./Color.875e3a23.js";
function n(e) {
  for (
    var T = arguments.length, C = Array(T > 1 ? T - 1 : 0), $ = 1;
    $ < T;
    $++
  )
    C[$ - 1] = arguments[$];
  throw Error(
    "[Immer] minified error nr: " +
      e +
      (C.length
        ? " " +
          C.map(function (e) {
            return "'" + e + "'";
          }).join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function r(e) {
  return !!e && !!e[Q];
}
function t(e) {
  var T;
  return (
    !!e &&
    ((function (e) {
      if (!e || "object" != typeof e) return !1;
      var T = Object.getPrototypeOf(e);
      if (null === T) return !0;
      var C = Object.hasOwnProperty.call(T, "constructor") && T.constructor;
      return (
        C === Object ||
        ("function" == typeof C && Function.toString.call(C) === Z)
      );
    })(e) ||
      Array.isArray(e) ||
      !!e[L] ||
      !!(null === (T = e.constructor) || void 0 === T ? void 0 : T[L]) ||
      s$1(e) ||
      v(e))
  );
}
function i(e, T, C) {
  void 0 === C && (C = !1),
    0 === o(e)
      ? (C ? Object.keys : nn)(e).forEach(function ($) {
          (C && "symbol" == typeof $) || T($, e[$], e);
        })
      : e.forEach(function (C, $) {
          return T($, C, e);
        });
}
function o(e) {
  var T = e[Q];
  return T
    ? T.i > 3
      ? T.i - 4
      : T.i
    : Array.isArray(e)
    ? 1
    : s$1(e)
    ? 2
    : v(e)
    ? 3
    : 0;
}
function u(e, T) {
  return 2 === o(e) ? e.has(T) : Object.prototype.hasOwnProperty.call(e, T);
}
function a(e, T) {
  return 2 === o(e) ? e.get(T) : e[T];
}
function f(e, T, C) {
  var $ = o(e);
  2 === $ ? e.set(T, C) : 3 === $ ? e.add(C) : (e[T] = C);
}
function c$1(e, T) {
  return e === T ? 0 !== e || 1 / e == 1 / T : e != e && T != T;
}
function s$1(e) {
  return X && e instanceof Map;
}
function v(e) {
  return q && e instanceof Set;
}
function p(e) {
  return e.o || e.t;
}
function l(e) {
  if (Array.isArray(e)) return Array.prototype.slice.call(e);
  var T = rn(e);
  delete T[Q];
  for (var C = nn(T), $ = 0; $ < C.length; $++) {
    var F = C[$],
      V = T[F];
    !1 === V.writable && ((V.writable = !0), (V.configurable = !0)),
      (V.get || V.set) &&
        (T[F] = {
          configurable: !0,
          writable: !0,
          enumerable: V.enumerable,
          value: e[F],
        });
  }
  return Object.create(Object.getPrototypeOf(e), T);
}
function d(e, T) {
  return (
    void 0 === T && (T = !1),
    y(e) ||
      r(e) ||
      !t(e) ||
      (o(e) > 1 && (e.set = e.add = e.clear = e.delete = h),
      Object.freeze(e),
      T &&
        i(
          e,
          function (e, T) {
            return d(T, !0);
          },
          !0
        )),
    e
  );
}
function h() {
  n(2);
}
function y(e) {
  return null == e || "object" != typeof e || Object.isFrozen(e);
}
function b(e) {
  var T = tn[e];
  return T || n(18, e), T;
}
function _() {
  return U;
}
function j(e, T) {
  T && (b("Patches"), (e.u = []), (e.s = []), (e.v = T));
}
function g(e) {
  O(e), e.p.forEach(S), (e.p = null);
}
function O(e) {
  e === U && (U = e.l);
}
function w(e) {
  return (U = {
    p: [],
    l: U,
    h: e,
    m: !0,
    _: 0,
  });
}
function S(e) {
  var T = e[Q];
  0 === T.i || 1 === T.i ? T.j() : (T.g = !0);
}
function P(e, T) {
  T._ = T.p.length;
  var C = T.p[0],
    $ = void 0 !== e && e !== C;
  return (
    T.h.O || b("ES5").S(T, e, $),
    $
      ? (C[Q].P && (g(T), n(4)),
        t(e) && ((e = M(T, e)), T.l || x(T, e)),
        T.u && b("Patches").M(C[Q].t, e, T.u, T.s))
      : (e = M(T, C, [])),
    g(T),
    T.u && T.v(T.u, T.s),
    e !== H ? e : void 0
  );
}
function M(e, T, C) {
  if (y(T)) return T;
  var $ = T[Q];
  if (!$)
    return (
      i(
        T,
        function (F, V) {
          return A(e, $, T, F, V, C);
        },
        !0
      ),
      T
    );
  if ($.A !== e) return T;
  if (!$.P) return x(e, $.t, !0), $.t;
  if (!$.I) {
    ($.I = !0), $.A._--;
    var F = 4 === $.i || 5 === $.i ? ($.o = l($.k)) : $.o,
      V = F,
      Y = !1;
    3 === $.i && ((V = new Set(F)), F.clear(), (Y = !0)),
      i(V, function (T, V) {
        return A(e, $, F, T, V, C, Y);
      }),
      x(e, F, !1),
      C && e.u && b("Patches").N($, C, e.u, e.s);
  }
  return $.o;
}
function A(e, T, C, $, F, V, Y) {
  if (r(F)) {
    var K = M(e, F, V && T && 3 !== T.i && !u(T.R, $) ? V.concat($) : void 0);
    if ((f(C, $, K), !r(K))) return;
    e.m = !1;
  } else Y && C.add(F);
  if (t(F) && !y(F)) {
    if (!e.h.D && e._ < 1) return;
    M(e, F), (T && T.A.l) || x(e, F);
  }
}
function x(e, T, C) {
  void 0 === C && (C = !1), !e.l && e.h.D && e.m && d(T, C);
}
function z(e, T) {
  var C = e[Q];
  return (C ? p(C) : e)[T];
}
function I(e, T) {
  if (T in e)
    for (var C = Object.getPrototypeOf(e); C; ) {
      var $ = Object.getOwnPropertyDescriptor(C, T);
      if ($) return $;
      C = Object.getPrototypeOf(C);
    }
}
function k$1(e) {
  e.P || ((e.P = !0), e.l && k$1(e.l));
}
function E(e) {
  e.o || (e.o = l(e.t));
}
function N(e, T, C) {
  var $ = s$1(T)
    ? b("MapSet").F(T, C)
    : v(T)
    ? b("MapSet").T(T, C)
    : e.O
    ? (function (e, T) {
        var C = Array.isArray(e),
          $ = {
            i: C ? 1 : 0,
            A: T ? T.A : _(),
            P: !1,
            I: !1,
            R: {},
            l: T,
            t: e,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          F = $,
          V = en;
        C && ((F = [$]), (V = on));
        var Y = Proxy.revocable(F, V),
          K = Y.revoke,
          J = Y.proxy;
        return ($.k = J), ($.j = K), J;
      })(T, C)
    : b("ES5").J(T, C);
  return (C ? C.A : _()).p.push($), $;
}
function R(e) {
  return (
    r(e) || n(22, e),
    (function e(T) {
      if (!t(T)) return T;
      var C,
        $ = T[Q],
        F = o(T);
      if ($) {
        if (!$.P && ($.i < 4 || !b("ES5").K($))) return $.t;
        ($.I = !0), (C = D(T, F)), ($.I = !1);
      } else C = D(T, F);
      return (
        i(C, function (T, F) {
          ($ && a($.t, T) === F) || f(C, T, e(F));
        }),
        3 === F ? new Set(C) : C
      );
    })(e)
  );
}
function D(e, T) {
  switch (T) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e);
  }
  return l(e);
}
var G,
  U,
  W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
  X = "undefined" != typeof Map,
  q = "undefined" != typeof Set,
  B =
    "undefined" != typeof Proxy &&
    void 0 !== Proxy.revocable &&
    "undefined" != typeof Reflect,
  H = W ? Symbol.for("immer-nothing") : (((G = {})["immer-nothing"] = !0), G),
  L = W ? Symbol.for("immer-draftable") : "__$immer_draftable",
  Q = W ? Symbol.for("immer-state") : "__$immer_state",
  Z = "" + Object.prototype.constructor,
  nn =
    "undefined" != typeof Reflect && Reflect.ownKeys
      ? Reflect.ownKeys
      : void 0 !== Object.getOwnPropertySymbols
      ? function (e) {
          return Object.getOwnPropertyNames(e).concat(
            Object.getOwnPropertySymbols(e)
          );
        }
      : Object.getOwnPropertyNames,
  rn =
    Object.getOwnPropertyDescriptors ||
    function (e) {
      var T = {};
      return (
        nn(e).forEach(function (C) {
          T[C] = Object.getOwnPropertyDescriptor(e, C);
        }),
        T
      );
    },
  tn = {},
  en = {
    get: function (e, T) {
      if (T === Q) return e;
      var C,
        $,
        F,
        V = p(e);
      if (!u(V, T))
        return (
          (C = e),
          (F = I(V, T))
            ? "value" in F
              ? F.value
              : null === ($ = F.get) || void 0 === $
              ? void 0
              : $.call(C.k)
            : void 0
        );
      var Y = V[T];
      return e.I || !t(Y)
        ? Y
        : Y === z(e.t, T)
        ? (E(e), (e.o[T] = N(e.A.h, Y, e)))
        : Y;
    },
    has: function (e, T) {
      return T in p(e);
    },
    ownKeys: function (e) {
      return Reflect.ownKeys(p(e));
    },
    set: function (e, T, C) {
      var $ = I(p(e), T);
      if (null == $ ? void 0 : $.set) return $.set.call(e.k, C), !0;
      if (!e.P) {
        var F = z(p(e), T),
          V = null == F ? void 0 : F[Q];
        if (V && V.t === C) return (e.o[T] = C), (e.R[T] = !1), !0;
        if (c$1(C, F) && (void 0 !== C || u(e.t, T))) return !0;
        E(e), k$1(e);
      }
      return (
        (e.o[T] === C && (void 0 !== C || T in e.o)) ||
          (Number.isNaN(C) && Number.isNaN(e.o[T])) ||
          ((e.o[T] = C), (e.R[T] = !0)),
        !0
      );
    },
    deleteProperty: function (e, T) {
      return (
        void 0 !== z(e.t, T) || T in e.t
          ? ((e.R[T] = !1), E(e), k$1(e))
          : delete e.R[T],
        e.o && delete e.o[T],
        !0
      );
    },
    getOwnPropertyDescriptor: function (e, T) {
      var C = p(e),
        $ = Reflect.getOwnPropertyDescriptor(C, T);
      return $
        ? {
            writable: !0,
            configurable: 1 !== e.i || "length" !== T,
            enumerable: $.enumerable,
            value: C[T],
          }
        : $;
    },
    defineProperty: function () {
      n(11);
    },
    getPrototypeOf: function (e) {
      return Object.getPrototypeOf(e.t);
    },
    setPrototypeOf: function () {
      n(12);
    },
  },
  on = {};
i(en, function (e, T) {
  on[e] = function () {
    return (arguments[0] = arguments[0][0]), T.apply(this, arguments);
  };
}),
  (on.deleteProperty = function (e, T) {
    return on.set.call(this, e, T, void 0);
  }),
  (on.set = function (e, T, C) {
    return en.set.call(this, e[0], T, C, e[0]);
  });
var un = (function () {
    function e(e) {
      var T = this;
      (this.O = B),
        (this.D = !0),
        (this.produce = function (e, C, $) {
          if ("function" == typeof e && "function" != typeof C) {
            var F = C;
            C = e;
            var V = T;
            return function (e) {
              var T = this;
              void 0 === e && (e = F);
              for (
                var $ = arguments.length, Y = Array($ > 1 ? $ - 1 : 0), K = 1;
                K < $;
                K++
              )
                Y[K - 1] = arguments[K];
              return V.produce(e, function (e) {
                var $;
                return ($ = C).call.apply($, [T, e].concat(Y));
              });
            };
          }
          var Y;
          if (
            ("function" != typeof C && n(6),
            void 0 !== $ && "function" != typeof $ && n(7),
            t(e))
          ) {
            var K = w(T),
              J = N(T, e, void 0),
              ee = !0;
            try {
              (Y = C(J)), (ee = !1);
            } finally {
              ee ? g(K) : O(K);
            }
            return "undefined" != typeof Promise && Y instanceof Promise
              ? Y.then(
                  function (e) {
                    return j(K, $), P(e, K);
                  },
                  function (e) {
                    throw (g(K), e);
                  }
                )
              : (j(K, $), P(Y, K));
          }
          if (!e || "object" != typeof e) {
            if (
              (void 0 === (Y = C(e)) && (Y = e),
              Y === H && (Y = void 0),
              T.D && d(Y, !0),
              $)
            ) {
              var te = [],
                ie = [];
              b("Patches").M(e, Y, te, ie), $(te, ie);
            }
            return Y;
          }
          n(21, e);
        }),
        (this.produceWithPatches = function (e, C) {
          if ("function" == typeof e)
            return function (C) {
              for (
                var $ = arguments.length, F = Array($ > 1 ? $ - 1 : 0), V = 1;
                V < $;
                V++
              )
                F[V - 1] = arguments[V];
              return T.produceWithPatches(C, function (T) {
                return e.apply(void 0, [T].concat(F));
              });
            };
          var $,
            F,
            V = T.produce(e, C, function (e, T) {
              ($ = e), (F = T);
            });
          return "undefined" != typeof Promise && V instanceof Promise
            ? V.then(function (e) {
                return [e, $, F];
              })
            : [V, $, F];
        }),
        "boolean" == typeof (null == e ? void 0 : e.useProxies) &&
          this.setUseProxies(e.useProxies),
        "boolean" == typeof (null == e ? void 0 : e.autoFreeze) &&
          this.setAutoFreeze(e.autoFreeze);
    }
    var T = e.prototype;
    return (
      (T.createDraft = function (e) {
        t(e) || n(8), r(e) && (e = R(e));
        var T = w(this),
          C = N(this, e, void 0);
        return (C[Q].C = !0), O(T), C;
      }),
      (T.finishDraft = function (e, T) {
        var C = (e && e[Q]).A;
        return j(C, T), P(void 0, C);
      }),
      (T.setAutoFreeze = function (e) {
        this.D = e;
      }),
      (T.setUseProxies = function (e) {
        e && !B && n(20), (this.O = e);
      }),
      (T.applyPatches = function (e, T) {
        var C;
        for (C = T.length - 1; C >= 0; C--) {
          var $ = T[C];
          if (0 === $.path.length && "replace" === $.op) {
            e = $.value;
            break;
          }
        }
        C > -1 && (T = T.slice(C + 1));
        var F = b("Patches").$;
        return r(e)
          ? F(e, T)
          : this.produce(e, function (e) {
              return F(e, T);
            });
      }),
      e
    );
  })(),
  an = new un(),
  fn = an.produce;
an.produceWithPatches.bind(an),
  an.setAutoFreeze.bind(an),
  an.setUseProxies.bind(an),
  an.applyPatches.bind(an),
  an.createDraft.bind(an),
  an.finishDraft.bind(an);
const produce = fn,
  isMobile = () => {
    let e = !1;
    if (
      "undefined" == typeof window ||
      !(null == window ? void 0 : window.navigator)
    )
      return !1;
    const T = navigator.userAgent || navigator.vendor || window.opera;
    return (
      (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
        T
      ) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
          T.substr(0, 4)
        )) &&
        (e = !0),
      e
    );
  },
  isRadarChart = (e) => {
    const { chartType: T } = e;
    return T === ChartType.RADAR;
  },
  isCombination = (e) => {
    const { chartType: T } = e;
    return T === ChartType.COMBINATION;
  },
  isFunnelChart = (e) => {
    const { chartType: T } = e;
    return ChartType.FUNNEL === T;
  },
  isBilateral = (e) => {
    const { chartType: T } = e;
    return ChartType.BILATERAL === T;
  },
  isSankey = (e) => {
    const { chartType: T } = e;
    return ChartType.SANKEY === T;
  },
  isGauge = (e) => {
    const { chartType: T } = e;
    return ChartType.GAUGE === T;
  },
  isDualAxis = (e) => {
    const { chartType: T } = e;
    return ChartType.DUAL_AXIS === T;
  },
  isLine = (e) => {
    const { chartType: T } = e;
    return ChartType.LINE === T;
  },
  isArea = (e) => {
    const { chartType: T } = e;
    return ChartType.AREA === T;
  },
  isAreaPercent = (e) => {
    const { chartType: T } = e;
    return ChartType.AREA_PERCENT === T;
  },
  isScatter = (e) => {
    const { chartType: T } = e;
    return ChartType.SCATTER === T;
  },
  isCircleViews = (e) => {
    const { chartType: T } = e;
    return ChartType.CIRCLE_VIEWS === T;
  },
  isRawTable = (e) => {
    const { chartType: T } = e;
    return ChartType.RAW_TABLE === T;
  },
  isTable = (e) => {
    const { chartType: T } = e;
    return ChartType.TABLE === T;
  },
  isPivotTable = (e) => {
    const { chartType: T } = e;
    return ChartType.PIVOT_TABLE === T;
  },
  isOKRTable = (e) => {
    const { chartType: T } = e;
    return ChartType.OKR_TABLE === T;
  },
  isTrendTable = (e) => {
    const { chartType: T } = e;
    return ChartType.TREND_TABLE === T;
  },
  isCartesianChart = (e) =>
    !![
      ChartType.COLUMN,
      ChartType.COLUMN_PERCENT,
      ChartType.COLUMN_PARALLEL,
    ].includes(e) ||
    !![ChartType.BAR, ChartType.BAR_PERCENT, ChartType.BAR_PARALLEL].includes(
      e
    ) ||
    !![ChartType.LINE, ChartType.AREA, ChartType.AREA_PERCENT].includes(e) ||
    !![ChartType.DUAL_AXIS, ChartType.COMBINATION].includes(e) ||
    !![ChartType.SCATTER, ChartType.CIRCLE_VIEWS].includes(e) ||
    !![ChartType.WATERFALL, ChartType.WATERFALL_CHANGE].includes(e) ||
    !![ChartType.BILATERAL, ChartType.HISTOGRAM].includes(e),
  isPolarChart = (e) =>
    [ChartType.PIE, ChartType.ANNULAR, ChartType.ROSE].includes(e),
  isBarLikeChart = (e) =>
    !![
      ChartType.COLUMN,
      ChartType.COLUMN_PERCENT,
      ChartType.COLUMN_PARALLEL,
    ].includes(e) ||
    !![ChartType.BAR, ChartType.BAR_PERCENT, ChartType.BAR_PARALLEL].includes(
      e
    ) ||
    !![ChartType.DUAL_AXIS, ChartType.COMBINATION].includes(e) ||
    ChartType.BILATERAL === e ||
    !![ChartType.WATERFALL, ChartType.WATERFALL_CHANGE].includes(e),
  isSymbolLikeChart = (e) =>
    !![ChartType.LINE, ChartType.AREA, ChartType.AREA_PERCENT].includes(e) ||
    !![ChartType.DUAL_AXIS, ChartType.COMBINATION].includes(e) ||
    !![
      ChartType.SCATTER,
      ChartType.CIRCLE_VIEWS,
      ChartType.SCATTER_MAP,
    ].includes(e) ||
    !![ChartType.RADAR].includes(e),
  isLineLikeChart = (e) =>
    !![ChartType.LINE, ChartType.AREA, ChartType.AREA_PERCENT].includes(e) ||
    !![ChartType.DUAL_AXIS, ChartType.COMBINATION].includes(e) ||
    ChartType.RADAR === e ||
    void 0,
  isAreaLikeChart = (e) =>
    !![ChartType.AREA, ChartType.AREA_PERCENT].includes(e) ||
    !![ChartType.DUAL_AXIS, ChartType.COMBINATION].includes(e),
  XYChartTypes = [
    ChartType.COLUMN,
    ChartType.COLUMN_PERCENT,
    ChartType.COLUMN_PARALLEL,
    ChartType.BAR,
    ChartType.BAR_PERCENT,
    ChartType.BAR_PARALLEL,
    ChartType.LINE,
    ChartType.AREA,
    ChartType.AREA_PERCENT,
    ChartType.CIRCLE_VIEWS,
    ChartType.DUAL_AXIS,
    ChartType.HISTOGRAM,
  ],
  isXYChart = (e) => {
    const { chartType: T } = e;
    return XYChartTypes.includes(T) || isCombination(e);
  },
  isMapChart = (e) => {
    const { chartType: T } = e;
    return T === ChartType.MAP || T === ChartType.SCATTER_MAP;
  },
  isTableChart = (e) => isPivot(e) || isCombination(e),
  isPivot = (e) =>
    !lodash.exports.isNil(e.rowPivotTree) ||
    !lodash.exports.isNil(e.colPivotTree),
  isPivotLikeTable = (e) => isPivotTable(e) || isOKRTable(e) || isTrendTable(e),
  isNonPivotTable = (e) => isTable(e) || isRawTable(e),
  isHorizontalBar = (e) => {
    const { chartType: T } = e;
    return [
      ChartType.BAR,
      ChartType.BAR_PERCENT,
      ChartType.BAR_PARALLEL,
      ChartType.BILATERAL,
    ].includes(T);
  },
  isPivotableTotalChart = (e) => {
    const { chartType: T } = e;
    return [
      ChartType.COLUMN,
      ChartType.COLUMN_PERCENT,
      ChartType.COLUMN_PARALLEL,
      ChartType.BAR,
      ChartType.BAR_PERCENT,
      ChartType.BAR_PARALLEL,
      ChartType.LINE,
      ChartType.AREA,
      ChartType.AREA_PERCENT,
      ChartType.RADAR,
      ChartType.COMBINATION,
      ChartType.DUAL_AXIS,
    ].includes(T);
  },
  isSingleDimensionChart = (e) => {
    const { chartType: T } = e;
    return [
      ChartType.FUNNEL,
      ChartType.MEASURE_CARD,
      ChartType.WORD_CLOUD,
      ChartType.COMPARATIVE_MEASURE_CARD,
      ChartType.BILATERAL,
    ].includes(T);
  },
  isCombined = (e) => {
    if (
      lodash.exports.isNil(e) ||
      lodash.exports.isNil(null == e ? void 0 : e.combined)
    )
      return !1;
    const { combined: T } = e;
    return (
      1 === (null == e ? void 0 : e.isTotal) || !0 === T || !!isPivotCombined(T)
    );
  },
  isPivotCombined = (e) =>
    !(
      "object" != typeof e ||
      !lodash.exports.isArray(null == e ? void 0 : e.row) ||
      !lodash.exports.isArray(null == e ? void 0 : e.col)
    ) &&
    (Boolean(null == e ? void 0 : e.row.length) ||
      Boolean(null == e ? void 0 : e.col.length)),
  FONT_FAMILY =
    '-apple-system,"Helvetica Neue","PingFang SC","Microsoft YaHei","Hiragino Sans GB",Helvetica,Arial,sans-serif,"apple color emoji","segoe ui emoji","segoe ui","segoe ui symbol"',
  GAUGE_FONT_FAMILY = `Byte Number,${FONT_FAMILY}`,
  PROGRESS_FONT_FAMILY = `Byte Number,${FONT_FAMILY}`,
  LIQUID_FONT_FAMILY = `Byte Number,${FONT_FAMILY}`,
  LINE_NUMBER_COL_NAME = "0#LINE_NUMBER_DIM_ID_STR",
  LINE_NUMBER_ICON = "0#LINE_NUMBER_ICON",
  LINE_NUMBER_WIDTH_PERCENT = 12,
  EMPTY_LINE_TAG = "0#EMPTY_LINE_TAG",
  getType$1 = (e) => {
    var T;
    const C = [
        FormatType.PERMIL,
        FormatType.PERCENT,
        FormatType.DIGIT,
        FormatType.NONE,
      ],
      $ = new Set(e.map((e) => (null == e ? void 0 : e.type)));
    return null != (T = C.find((e) => $.has(e))) ? T : FormatType.DIGIT;
  },
  getPrecisionType = (e) => {
    var T;
    const C = [
        PrecisionType.SIGNIFICANT_DECIMAL,
        PrecisionType.DECIMAL_DIGITS,
        PrecisionType.SIGNIFICANT_FIGURES,
      ],
      $ = new Set(e.map((e) => (null == e ? void 0 : e.precisionType)));
    return null != (T = C.find((e) => $.has(e)))
      ? T
      : PrecisionType.DECIMAL_DIGITS;
  },
  getKiloSep = (e) =>
    !e.some((e) =>
      [FormatType.NONE, FormatType.PERCENT, FormatType.PERMIL].includes(
        null == e ? void 0 : e.type
      )
    ) && e.some((e) => !0 === (null == e ? void 0 : e.kSep)),
  getUnit = (e) => {
    if (e.every((e) => "auto" === (null == e ? void 0 : e.unit))) return "auto";
    const T = new Set(
        e.map((e) => {
          var T;
          return (
            "auto" !== (null == e ? void 0 : e.unit) &&
            (null == (T = null == e ? void 0 : e.unit) ? void 0 : T.symbol)
          );
        })
      ),
      C = new Set(
        e.map((e) => {
          var T;
          return (
            "auto" !== (null == e ? void 0 : e.unit) &&
            (null == (T = null == e ? void 0 : e.unit) ? void 0 : T.ratio)
          );
        })
      );
    if (1 === T.size && 1 === C.size) {
      const e = Array.from(T)[0],
        $ = Array.from(C)[0];
      if (void 0 === e || void 0 === $) return;
      return {
        symbol: e,
        ratio: $,
      };
    }
  },
  getPrefix = (e) => {
    const T = new Set(e.map((e) => (null == e ? void 0 : e.prefix)));
    if (1 === T.size) return Array.from(T)[0];
  },
  getSuffix = (e) => {
    const T = new Set(e.map((e) => (null == e ? void 0 : e.suffix)));
    if (1 === T.size) return Array.from(T)[0];
  },
  getDataFormatUnit = (e) => {
    const T = new Set(e.map((e) => (null == e ? void 0 : e.dataFormatUnit)));
    if (1 === T.size) return Array.from(T)[0];
  },
  getVisibleMeasure = (e, T) => {
    var C, $;
    const { locationMap: F } = e;
    return T
      ? T.filter((T) => {
          var C;
          return !0 === (null == (C = e.fieldMap[T]) ? void 0 : C.visible);
        }).map((T) => getFieldFormat(T, e))
      : [
          ...(null != (C = F.measure) ? C : []),
          ...(null != ($ = F.subMeasure) ? $ : []),
        ]
          .filter((T) => {
            var C;
            return !0 === (null == (C = e.fieldMap[T]) ? void 0 : C.visible);
          })
          .map((T) => getFieldFormat(T, e));
  },
  getTotalValueFormatter = (e, T, C) => {
    var $, F;
    const V = getVisibleMeasure(e, C),
      Y = getType$1(V),
      K = getPrecisionType(V),
      J = V.every((e) => !0 === (null == e ? void 0 : e.auto)),
      ee = getKiloSep(V),
      te =
        null !=
        (F =
          null ==
          ($ = lodash.exports.maxBy(
            V.filter((e) => (null == e ? void 0 : e.type) !== FormatType.NONE),
            (e) => (null == e ? void 0 : e.precision)
          ))
            ? void 0
            : $.precision)
          ? F
          : 0,
      ie = getUnit(V),
      ne = getPrefix(V),
      re = getSuffix(V),
      ae = getDataFormatUnit(V);
    return createFormatter(
      {
        type: Y,
        precisionType: K,
        auto: J,
        kSep: ee,
        precision: te,
        unit: ie,
        prefix: ne,
        suffix: re,
        dataFormatUnit: ae,
      },
      T
    );
  },
  getTotalPercentFormatter = () => (e, T) => percentFormatter(e, 2, T),
  calcColorLevel = (e, T, C, $, F, V = 0) => {
    if (null === C || $[0] === $[1])
      return {
        colors: gradientColor(e, T, F),
        domain: $,
      };
    const Y = [...$],
      K = $[0] - V,
      J = $[1] - V;
    let ee,
      te,
      ie = 1 / 0,
      ne = 1 / 0;
    const re = F % 2 == 1,
      ae = (K * F + (re ? 0.5 * (J - K) : 0)) / (K - J),
      oe = Math.floor(ae),
      se = Math.ceil(ae);
    (oe >= 1 || (oe >= 0 && re)) && (ie = -K / (oe + (re ? 0.5 : 0))),
      (se >= 1 || (se >= 0 && re)) &&
        ((ne = J / (F - se - (re ? 0.5 : 0))), isNaN(ne) && (ne = 1 / 0));
    const le = Math.min(ie, ne);
    ie <= ne
      ? ((ee = Math.floor(Math.abs(K) / le)),
        (te = F - ee - (re ? 1 : 0)),
        le < 1 / 0 && (Y[1] = +($[0] + F * le)))
      : ((te = Math.floor(Math.abs(J) / le)),
        (ee = F - te - (re ? 1 : 0)),
        le < 1 / 0 && (Y[0] = +($[1] - F * le)));
    const de = gradientColor(e, C, ee + 1),
      ce = gradientColor(T, C, te + 1);
    de.pop(), ce.pop(), ce.reverse(), re && de.push(C);
    return {
      colors: de.concat(ce),
      domain: Y,
    };
  },
  gradientColor = (e, T, C) => {
    if (C <= 1) return [e];
    const $ = [],
      F = (T[0] - e[0]) / (C - 1),
      V = (T[1] - e[1]) / (C - 1),
      Y = (T[2] - e[2]) / (C - 1),
      K = (T[3] - e[3]) / (C - 1);
    for (let J = 0; J < C; ++J) {
      const T = [
        Math.floor(e[0] + J * F),
        Math.floor(e[1] + J * V),
        Math.floor(e[2] + J * Y),
        Math.floor(e[3] + J * K),
      ];
      $.push(T);
    }
    return $;
  },
  applyToStyle = (e, T) => {
    var C, $;
    const { vizData: F } = T;
    [ChartType.PIE, ChartType.ROSE, ChartType.ANNULAR].includes(F.chartType)
      ? (e.pie = {
          ...e.pie,
          style: {
            ...(null == (C = e.pie) ? void 0 : C.style),
            fill: {
              scale: "color",
              field: e.color.field,
            },
          },
        })
      : [ChartType.PIE, ChartType.ROSE, ChartType.ANNULAR].includes(
          F.chartType
        ) &&
        (e.word = {
          ...e.word,
          style: {
            ...(null == ($ = e.word) ? void 0 : $.style),
            fill: {
              scale: "color",
              field: e.color.field,
            },
          },
        });
  },
  linear = (e, T) => {
    var C, $, F, V, Y, K, J, ee;
    const { vizData: te } = T,
      ie = te.cells[0],
      ne = te.displayConf,
      re =
        null == (C = null == ne ? void 0 : ne.color) ? void 0 : C.colorsLinear;
    if (
      ((e.color = {
        field: null == ($ = ie.color) ? void 0 : $[0],
        type: "linear",
      }),
      !re || !(null == (F = ie.color) ? void 0 : F[0]))
    )
      return (
        (e.color.range = ["#000", "#000"]),
        void (e.color.domain = [
          {
            dataId: "data",
            fields: [null == (V = ie.color) ? void 0 : V[0]],
          },
        ])
      );
    if ("string" == typeof re[0])
      (e.color.range = re),
        (e.color.domain = [
          {
            dataId: "data",
            fields: [null == (Y = ie.color) ? void 0 : Y[0]],
          },
        ]);
    else if ("object" == typeof re[0]) {
      const C =
        null !=
        (ee = te.fieldMap[null == (K = ie.color) ? void 0 : K[0]].domain)
          ? ee
          : getMinMaxFromDomain(
              getDomainFromDataset(
                te.datasets.flat(3),
                null == (J = ie.color) ? void 0 : J[0]
              )
            );
      let $ = [],
        F = [];
      const V = re.map((e) =>
        "min" === e.value
          ? {
              color: e.color,
              value: C[0],
            }
          : "mid" === e.value
          ? {
              color: e.color,
              value: (C[0] + C[1]) / 2,
            }
          : "max" === e.value
          ? {
              color: e.color,
              value: C[1],
            }
          : e
      );
      V[0].value > C[0] && ($.push(V[0].color), F.push(C[0])),
        V.forEach(({ color: e, value: T }) => {
          $.push(e), F.push(T);
        });
      const Y = V.length - 1;
      V[Y].value < C[1] && ($.push(V[Y].color), F.push(C[1]));
      const { colorLevel: ae } = ne.color;
      if (ae) {
        const e = $.slice(0, 3).map((e) => chroma(e).rgba()),
          T = F.slice(0, 3);
        if (2 === e.length || 3 === e.length) {
          const C =
              2 === e.length
                ? calcColorLevel(e[0], e[1], null, [T[0], T[1]], ae)
                : calcColorLevel(e[0], e[2], e[1], [T[0], T[2]], ae, T[1]),
            { colors: V, domain: Y } = C;
          ($ = []), (F = []);
          const K = (Y[1] - Y[0]) / ae;
          V.map((e) => `rgba(${e.join(",")})`).forEach((e, T) => {
            $.push(e),
              $.push(e),
              F.push(Y[0] + T * K),
              F.push(Y[0] + (T + 1) * K);
          });
        }
      }
      (e.color.range = $), (e.color.domain = F), applyToStyle(e, T);
    }
  },
  ordinal = (e, { vizData: T }) => {
    var C, $, F, V, Y, K, J, ee, te;
    const ie = {
        ...e,
      },
      { displayConf: ne } = T,
      re = T.fieldMap;
    if (!ne.color) return;
    const { cells: ae } = T,
      oe = getColorItems(T),
      se = getColorScheme(T.origin === Origin.VSCREEN),
      le = oe,
      de = getChartColorsFromScheme(ne.color, le, se),
      ce = null == ($ = null == (C = ae[0]) ? void 0 : C.color) ? void 0 : $[0],
      ue =
        !!(null == (F = null == de ? void 0 : de.range)
          ? void 0
          : F.find(isGradientsColor)) ||
        !!(null == (V = Object.values(null == de ? void 0 : de.specified))
          ? void 0
          : V.find(isGradientsColor)),
      he = (e, T) => {
        return isGradientsColor(e)
          ? ((C = Number(transformLinerColorStr(e)[0].replace("deg", ""))),
            C <= 45
              ? [1, 1 - Math.tan((C * Math.PI) / 180)]
              : 90 === C
              ? [1e-5, 0]
              : [Math.tan(((90 - C) * Math.PI) / 180), 0])[T]
          : 1;
        var C;
      },
      pe = (e, T) => (isGradientsColor(e) ? transformLinerColorStr(e)[T] : e),
      ge = null == (Y = re[ce]) ? void 0 : Y.domain;
    if (ue) {
      ie.color = {
        field: ce,
        type: "ordinal",
        range: null == (J = de.range) ? void 0 : J.map(getColorFromGradients),
        specified: lodash.exports.mapValues(
          null == de ? void 0 : de.specified,
          getColorFromGradients
        ),
      };
      const e = (
          null == (ee = Object.keys(null == de ? void 0 : de.specified))
            ? void 0
            : ee.length
        )
          ? null == de
            ? void 0
            : de.specified
          : null == de
          ? void 0
          : de.range,
        T = (
          null == (te = Object.keys(null == de ? void 0 : de.specified))
            ? void 0
            : te.length
        )
          ? {
              domain: Object.keys(de.specified),
            }
          : {};
      ie.colorGradient = {
        type: "linear",
        x0: {
          field: ce,
          type: "ordinal",
          range: Object.values(e).map(() => 0),
          ...T,
        },
        y0: {
          field: ce,
          type: "ordinal",
          range: Object.values(e).map(() => 1),
          ...T,
        },
        x1: {
          field: ce,
          type: "ordinal",
          range: Object.values(e).map((e) => he(e, 0)),
          ...T,
        },
        y1: {
          field: ce,
          type: "ordinal",
          range: Object.values(e).map((e) => he(e, 1)),
          ...T,
        },
        stops: [
          {
            offset: 0,
            color: {
              field: ce,
              type: "ordinal",
              range: Object.values(e).map((e) => pe(e, 1)),
              ...T,
            },
          },
          {
            offset: 1,
            color: {
              field: ce,
              type: "ordinal",
              range: Object.values(e).map((e) => pe(e, 2)),
              ...T,
            },
          },
        ],
      };
    } else
      ie.color = {
        field: ce,
        type: "ordinal",
        ...de,
        range: (
          null == (K = Object.keys(null == de ? void 0 : de.specified))
            ? void 0
            : K.length
        )
          ? oe.map((e, T) => {
              var C;
              return null != (C = de.specified[e]) ? C : de.range[T];
            })
          : de.range,
        domain: ge,
      };
    return ie;
  },
  isOnlyGroup = (e) => {
    var T, C;
    return (
      (null != (T = e.group) ? T : []).length > 0 &&
      0 === (null != (C = e.color) ? C : []).length
    );
  },
  color = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { cells: V, fieldMap: Y } = F,
      { displayConf: K } = F,
      J = V[0];
    if (isOnlyGroup(J)) {
      const T = getColorScheme(F.origin === Origin.VSCREEN),
        C = [getColorFromGradients(getColorsFromScheme(K.color, [], T)[0])];
      return {
        ...e,
        color: {
          field: null,
          type: "ordinal",
          range: C,
        },
      };
    }
    const ee =
        J.color &&
        (null == (C = Y[J.color[0]]) ? void 0 : C.role) === Role.MEASURE,
      te = null == ($ = J.color) ? void 0 : $[0],
      ie = {
        ...e,
        seriesField: te,
      };
    if (ee)
      return (
        linear(ie, T),
        {
          ...ie,
        }
      );
    {
      const e = ordinal(ie, T);
      return (
        e && ((ie.color = e.color), (ie.colorGradient = e.colorGradient)),
        {
          ...ie,
        }
      );
    }
  },
  generateBaseColorConf = (e, T) => {
    const C = {
      color: null,
      strokeOpacity: 1,
    };
    return e === LabelColor.DEFAULT
      ? (T === LabelPos.INNER
          ? ((C.stroke = null),
            (C.strokeWidth = 2),
            (C.color = "#ffffff"),
            (C.smartInverse = !1))
          : (T !== LabelPos.OUTER && T !== LabelPos.AUTO) ||
            (C.strokeWidth = 0),
        C)
      : (e === LabelColor.AUTO
          ? T === LabelPos.INNER
            ? ((C.smartInverse = {
                fillStrategy: "invertBase",
                strokeStrategy: "similarBase",
                outsideEnable: !0,
                mode: "lightness",
              }),
              (C.strokeWidth = 2),
              (C.color = LabelSmartInverseColor.DARK))
            : (T !== LabelPos.OUTER && T !== LabelPos.AUTO) ||
              ((C.color = LabelSmartInverseColor.DARK),
              (C.stroke = "rgba(255, 255, 255, 0.8)"),
              (C.strokeWidth = 2))
          : ((C.color = e), (C.strokeOpacity = 0)),
        C);
  },
  getLegendSymbolType = (e) => {
    const { chartType: T } = e,
      { lineStyle: C } = e.displayConf,
      $ = {
        lineWidth: 0,
        symbolType: "square",
        size: 10,
        fillOpacity: 1,
      };
    return [
      ChartType.LINE,
      ChartType.AREA,
      ChartType.AREA_PERCENT,
      ChartType.RADAR,
    ].includes(T)
      ? C.symbol && Array.isArray(C.symbol)
        ? (e, T, F) => {
            const V = C.symbol.find(
              (T) => T.title === (null == e ? void 0 : e.id)
            );
            return V ? lineStyleSymbolToShapeType(V.value) : $;
          }
        : lineStyleSymbolToShapeType(C.symbol)
      : $;
  },
  lineStyleSymbolToShapeType = (e) =>
    "none" === e
      ? {
          lineWidth: 0,
          symbolType: "roundLine",
          fillOpacity: 1,
          size: 10,
        }
      : "emptyCircle" === e
      ? {
          symbolType: "circle",
          fill: "transparent",
          lineWidth: 2,
          fillOpacity: 1,
          size: 10,
        }
      : "circle" === e
      ? {
          lineWidth: 0,
          symbolType: "circle",
          fillOpacity: 1,
          size: 10,
        }
      : "rect" === e
      ? {
          lineWidth: 0,
          symbolType: "square",
          fillOpacity: 1,
          size: 10,
        }
      : "diamond" === e
      ? {
          lineWidth: 0,
          symbolType: "diamond",
          fillOpacity: 1,
          size: 10,
        }
      : {
          lineWidth: 0,
          symbolType: "square",
          fillOpacity: 1,
          size: 10,
        },
  formatLines = (e, T) => ({
    [LINES_MAP[e]]: T,
  }),
  setContinuousLegendMaxLength = (e, T) => {
    const { vizData: C, containerWidth: $ } = e,
      F = C.displayConf,
      { legendPos: V } = F.legend;
    if ([LegendPos.TOP, LegendPos.BOTTOM].includes(V)) {
      const e = null != $ ? $ : 0;
      e &&
        (T.rail = {
          width: e < 226 ? e - 26 : 200,
        });
    } else
      T.rail = {
        height: 100,
      };
  },
  setContinuousLegendMargin = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      { legendPos: F } = $.legend;
    F === LegendPos.LEFT
      ? (T.padding = {
          top: 0,
          bottom: 12,
          left: 0,
          right: 16,
        })
      : F === LegendPos.RIGHT
      ? (T.padding = {
          top: 0,
          bottom: 12,
          left: 16,
          right: 0,
        })
      : F === LegendPos.TOP
      ? (T.padding = {
          top: 0,
          bottom: 16,
          left: 0,
          right: 0,
        })
      : F === LegendPos.BOTTOM &&
        (T.padding = {
          top: 16,
          bottom: 0,
          left: 0,
          right: 0,
        });
  },
  setDiscreteLegendMargin = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      { legendPos: F } = $.legend,
      V =
        T.find((e) => e.type === LEGEND_TYPE.COLOR) ||
        T.find((e) => e.type === LEGEND_TYPE.SIZE),
      Y = T.find((e) => e.type === LEGEND_TYPE.DISCRETE);
    F === LegendPos.LEFT
      ? (Y.padding = {
          top: 0,
          bottom: V ? 12 : 0,
          left: 0,
          right: 16,
        })
      : F === LegendPos.RIGHT
      ? (Y.padding = {
          top: 0,
          bottom: V ? 12 : 0,
          left: 16,
          right: 0,
        })
      : F === LegendPos.TOP
      ? (Y.padding = {
          top: 0,
          bottom: 16,
          left: 0,
          right: 0,
        })
      : F === LegendPos.BOTTOM &&
        (Y.padding = {
          top: 16,
          bottom: 0,
          left: 0,
          right: 0,
        });
  },
  legendsCustomer = (e, T, C) => {
    const { vizData: $ } = e,
      { displayConf: F } = $,
      { legendPos: V, legendAlign: Y } = F.legend;
    if (!C)
      return void T.legends.forEach((e) => {
        e.visible = !1;
      });
    const K = Boolean(T.legends.find((e) => e.type === LEGEND_TYPE.DISCRETE));
    T.legends.forEach((e) => {
      (e.visible = !0),
        (e.id = `${LEGEND_ID}-${e.type}`),
        (e.orient = V),
        (e.position = LEGEND_ALIGN_MAP[Y]),
        (e.layoutType =
          1 === T.legends.length ||
          ([LegendPos.TOP, LegendPos.BOTTOM].includes(V) && K)
            ? "normal"
            : "normal-inline");
    });
  },
  discreteLegendCustomer$2 = (e, T, C) => {
    var $, F, V, Y, K, J, ee, te, ie;
    const { vizData: ne, containerWidth: re } = e,
      { displayConf: ae } = ne,
      { cells: oe, fieldMap: se } = ne,
      {
        legendPos: le,
        lines: de,
        labelStyle: ce = {},
        legendPager: ue,
      } = ae.legend;
    let he = 400;
    if ([LegendPos.LEFT, LegendPos.RIGHT].includes(le)) {
      const e = null != re ? re : 0,
        T = Math.ceil(e / 2 - 4 - 4 - 22 - 12 - 12);
      he = T > 0 ? T : 0;
    }
    const pe = T.legends.find((e) => e.type === LEGEND_TYPE.DISCRETE);
    if (pe && C) {
      const C = {
        ...pe,
        visible: !0,
        ...formatLines(le, null != de ? de : 0),
        title: {
          ...pe.title,
          textStyle: {
            fontSize: ce.fontSize,
            fill: ce.color,
          },
        },
        layoutLevel: [LegendPos.LEFT, LegendPos.RIGHT].includes(le)
          ? 60
          : LegendPos.BOTTOM === le
          ? 30
          : 70,
        item: {
          ...(null != ($ = null == pe ? void 0 : pe.item) ? $ : {}),
          focus: !0,
          focusIconStyle: {
            size: 14,
          },
          maxWidth: he,
          spaceRow: 0,
          spaceCol: 0,
          padding: [LegendPos.LEFT, LegendPos.RIGHT].includes(le)
            ? {
                top: 1,
                bottom: 2,
                left: 3,
                right: 2,
              }
            : {
                top: 1,
                bottom: 1,
                left: 1,
                right: 1,
              },
          background: {
            visible: !1,
            style: {
              fillOpacity: 0.001,
            },
          },
          label: {
            ...(null !=
            (V = null == (F = null == pe ? void 0 : pe.item) ? void 0 : F.label)
              ? V
              : {}),
            style: {
              fontSize: ce.fontSize,
              fill: ce.color,
            },
          },
          shape: {
            style: getLegendSymbolType(ne),
          },
        },
        pager: {
          layout: "horizontal",
          padding: [LegendPos.LEFT, LegendPos.RIGHT].includes(le)
            ? {
                left: -18,
              }
            : 0,
          textStyle: {
            fill: null == ue ? void 0 : ue.color,
          },
          space: 0,
          handler: {
            preShape: "triangleLeft",
            nextShape: "triangleRight",
            style: {
              fill:
                null ==
                (K =
                  null == (Y = null == ue ? void 0 : ue.buttonPre)
                    ? void 0
                    : Y.color)
                  ? void 0
                  : K.default,
            },
            state: {
              disable: {
                fill:
                  null ==
                  (ee =
                    null == (J = null == ue ? void 0 : ue.buttonPre)
                      ? void 0
                      : J.color)
                    ? void 0
                    : ee.disable,
              },
            },
          },
        },
        alignSelf: [LegendPos.TOP, LegendPos.RIGHT].includes(le)
          ? "end"
          : "start",
      };
      if (
        oe[0].color &&
        (null == (te = se[oe[0].color[0]]) ? void 0 : te.format) &&
        !lodash.exports.isFunction(se[oe[0].color[0]].format)
      ) {
        const { format: e } = se[oe[0].color[0]],
          T = null == (ie = ae.specialValue) ? void 0 : ie.dimensions,
          $ = INVALID_VALUE_MAP$5[null != T ? T : SpecialValueType$1.NULL];
        C.item.label.formatMethod = createFormatter(e, $);
      }
      Object.assign(pe, C), setDiscreteLegendMargin(e, T.legends);
    }
  },
  colorLegendCustomer = (e, T, C) => {
    var $, F, V, Y, K, J;
    const { vizData: ee } = e,
      { displayConf: te } = ee,
      { legendPos: ie, labelStyle: ne = {} } = te.legend,
      re = T.legends.find((e) => e.type === LEGEND_TYPE.COLOR),
      ae = ee.cells[0].color;
    if (re && C) {
      const C = {
        ...re,
        visible: !0,
        orient: ie,
        field: ae,
        layoutLevel: [LegendPos.LEFT, LegendPos.RIGHT].includes(ie) ? 60 : 50,
        maxHeight: 130,
        title: {
          ...(null != ($ = re.title) ? $ : {}),
          textStyle: {
            ...(null != (V = null == (F = re.title) ? void 0 : F.style)
              ? V
              : {}),
            fontSize: ne.fontSize,
            fill: ne.color,
          },
          space: 0,
        },
        rail: {
          width: 200,
          height: 4,
          style: {
            fill: "rgba(0,0,0,0.04)",
          },
        },
        handler: {
          style: {
            shadowBlur: 0,
            shadowColor: !1,
            stroke: "#fff",
            lineWidth: 3,
            size: 9,
            outerBorder: {
              distance: 1.5,
              lineWidth: 0.5,
              stroke: "#cccccc",
            },
          },
        },
        align: "left",
        alignSelf: [LegendPos.TOP, LegendPos.RIGHT].includes(ie)
          ? "end"
          : "start",
        handlerText: {
          ...(null != (Y = re.handlerText) ? Y : {}),
          style: {
            ...(null != (J = null == (K = re.handlerText) ? void 0 : K.style)
              ? J
              : {}),
            maxLineWidth: [LegendPos.TOP, LegendPos.BOTTOM].includes(ie)
              ? 200
              : 50,
            fontSize: ne.fontSize,
            fill: ne.color,
            textAlign: [LegendPos.TOP, LegendPos.BOTTOM].includes(ie)
              ? "center"
              : "start",
            dx: [LegendPos.TOP, LegendPos.BOTTOM].includes(ie) ? 0 : 30,
          },
        },
        startText: {
          visible: !1,
        },
        endText: {
          visible: !1,
        },
      };
      setContinuousLegendMargin(e, C), setContinuousLegendMaxLength(e, C);
      Boolean(T.legends.find((e) => e.type === LEGEND_TYPE.SIZE)) &&
        [LegendPos.TOP, LegendPos.BOTTOM].includes(ie) &&
        (C.padding.right = 25),
        Object.assign(re, C);
    }
  },
  sizeLegendCustomer = (e, T, C) => {
    var $, F, V, Y;
    const { vizData: K } = e,
      { displayConf: J } = K,
      { legendPos: ee, labelStyle: te = {}, legendAlign: ie } = J.legend,
      ne = T.legends.find((e) => e.type === LEGEND_TYPE.SIZE),
      re = K.cells[0].size;
    if (ne && C) {
      const T = {
        ...ne,
        visible: !0,
        orient: ee,
        field: re,
        layoutLevel: [LegendPos.LEFT, LegendPos.RIGHT].includes(ee)
          ? ie === LegendAlign.TAIL
            ? 70
            : 50
          : ie === LegendAlign.TAIL
          ? 60
          : 40,
        maxHeight: 130,
        title: {
          ...(null != ($ = ne.title) ? $ : {}),
          textStyle: {
            fontSize: te.fontSize,
            fill: te.color,
          },
          space: 0,
        },
        track: {
          style: {
            fill: "rgba(20,20,20,0.1)",
          },
        },
        rail: {
          width: 200,
          height: 4,
          style: {
            fill: "rgba(0,0,0,0.04)",
          },
        },
        handler: {
          style: {
            symbolType: sizeHandlerPathMap[ee],
            size: 8,
            shadowBlur: 0,
            shadowColor: !1,
            outerBorder: {
              stroke: "#AEB8C6",
              lineWidth: 1,
              strokeOpacity: 0.5,
            },
          },
        },
        align: "left",
        alignSelf: [LegendPos.TOP, LegendPos.RIGHT].includes(ee)
          ? "end"
          : "start",
        handlerText: {
          ...(null != (F = ne.handlerText) ? F : {}),
          style: {
            ...(null != (Y = null == (V = ne.handlerText) ? void 0 : V.style)
              ? Y
              : {}),
            maxLineWidth: [LegendPos.TOP, LegendPos.BOTTOM].includes(ee)
              ? 200
              : 50,
            fontSize: te.fontSize,
            fill: te.color,
            textAlign: [LegendPos.TOP, LegendPos.BOTTOM].includes(ee)
              ? "center"
              : "start",
            dx: [LegendPos.TOP, LegendPos.BOTTOM].includes(ee) ? 0 : 30,
          },
        },
        startText: {
          visible: !1,
        },
        endText: {
          visible: !1,
        },
      };
      setContinuousLegendMargin(e, T),
        setContinuousLegendMaxLength(e, T),
        Object.assign(ne, T);
    }
  },
  sizeHandlerPathMap = {
    [LegendPos.LEFT]: "M-5,0L-2.5,-3.5\n    h5\n    v7\n    h-5\n    Z",
    [LegendPos.RIGHT]: "M-5,0L-2.5,-3.5\n    h5\n    v7\n    h-5\n    Z",
    [LegendPos.TOP]: "M0,6L-3.5,2.5\n    v-5\n    h7\n    v5\n    Z",
    [LegendPos.BOTTOM]: "M0,6L-3.5,2.5\n    v-5\n    h7\n    v5\n    Z",
  },
  absoluteLayoutCustomer = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      { legendPos: F } = $.legend;
    return (
      T.legends.forEach((e) => {
        (e.layoutType = "absolute"),
          F === LegendPos.BOTTOM
            ? (e.bottom = 0)
            : F === LegendPos.TOP
            ? (e.top = 0)
            : F === LegendPos.LEFT
            ? (e.left = 0)
            : F === LegendPos.RIGHT && (e.right = 0);
      }),
      T
    );
  },
  partialSplit = (e, T, C) => {
    const $ = [String(e)];
    let F = 1;
    for (; F < C; ) {
      const e = $[$.length - 1],
        C = null == e ? void 0 : e.indexOf(T);
      if (C < 0) break;
      $.splice($.length - 1, 1, e.slice(0, C), e.slice(C + T.length)), F++;
    }
    return $;
  },
  buildLegend =
    (e, T = []) =>
    (C, $) => {
      var F, V;
      const { vizData: Y } = $,
        K = Y.displayConf,
        J = {
          ...C,
          legends: [],
        };
      for (const T of e) {
        const { isEnabled: e, customer: C } = T;
        e($) &&
          C(
            $,
            J,
            null == (F = null == K ? void 0 : K.legend) ? void 0 : F.visible
          );
      }
      const ee = [
        legendsCustomer,
        discreteLegendCustomer$2,
        colorLegendCustomer,
        sizeLegendCustomer,
        ...T,
      ];
      for (const e of ee)
        e(
          $,
          J,
          null == (V = null == K ? void 0 : K.legend) ? void 0 : V.visible
        );
      return lodash.exports.isEmpty(J.legends) && delete J.legends, J;
    },
  discreteLegendCustomer$1 = (e, T) => {
    T.legends.discreteLegend = {};
  },
  sizeLegend$2 = {
    isEnabled: (e) => {
      var T, C;
      return !!(null == (C = null == (T = e.vizData.cells) ? void 0 : T[0].size)
        ? void 0
        : C[0]);
    },
    customer: (e, T) => {
      var C;
      const {
          vizData: { fieldMap: $, cells: F },
        } = e,
        V = F[0].size[0];
      T.legends.sizeLegend = {
        slidable: !0,
        title: null == (C = $[V]) ? void 0 : C.alias,
        margin: {
          left: 8,
          right: 8,
        },
      };
    },
  },
  discreteLegend$5 = {
    isEnabled: (e) => {
      var T, C, $;
      const { vizData: F } = e;
      return !!(null ==
      ($ =
        null == (C = null == (T = null == F ? void 0 : F.cells) ? void 0 : T[0])
          ? void 0
          : C.color)
        ? void 0
        : $[0]);
    },
    customer: discreteLegendCustomer$1,
  };
var gisLegend = buildLegend([discreteLegend$5, sizeLegend$2]);
function rgbToHex(e, T, C) {
  const $ = ((e << 16) | (T << 8) | C).toString(16);
  return `#${new Array(Math.abs($.length - 7)).join("0")}${$}`;
}
function linspace(e, T, C, $ = !0) {
  if (0 === C) return [];
  const F = $ ? C - 1 : C,
    V = 0 === F ? 1 : (T - e) / F;
  return Array.from(
    {
      length: C,
    },
    (T, C) => e + V * C
  ).map((e) => +e.toFixed(2));
}
function gradientObj(e, T, C) {
  const [$, F] = null != C ? C : [0, 1];
  return {
    type: "linear",
    linear: {
      range: linspace($, F, e.length).map((T, C) => e[C]),
      clamp: !1,
    },
    default: null != T ? T : "#3073F2",
  };
}
const getHeatmapGradient = (e, T) => {
  const [C, $] = null != T ? T : [0, 1];
  return Object.fromEntries(linspace(C, $, e.length).map((T, C) => [T, e[C]]));
};
function hexToRgb(e) {
  const T = [];
  for (let C = 1; C < 7; C += 2) T.push(parseInt(`0x${e.slice(C, C + 2)}`, 16));
  return T;
}
function gradient(e, T) {
  function C(e, T, C) {
    const $ = hexToRgb(e),
      F = hexToRgb(T),
      V = (F[0] - $[0]) / C,
      Y = (F[1] - $[1]) / C,
      K = (F[2] - $[2]) / C,
      J = [];
    for (let ee = 0; ee < C; ee++)
      J.push(
        rgbToHex(
          parseInt((V * ee + $[0]).toString()),
          parseInt((Y * ee + $[1]).toString()),
          parseInt((K * ee + $[2]).toString())
        )
      );
    return J;
  }
  const $ = [];
  if (e.length === T) return e;
  for (let F = 1; F < e.length; F++) {
    const V = e[F - 1],
      Y = e[F];
    $.push(...C(V, Y, Math.ceil(T / (e.length - 1))));
  }
  return $;
}
var GeoScope = ((e) => (
  (e.None = "none"),
  (e.WorldContinent = "WORLD-CONTINENT"),
  (e.WorldCountry = "WORLD-COUNTRY"),
  (e.CHNProvince = "CHN-PROVINCE"),
  (e.CHNCity = "CHN-CITY"),
  (e.CHNHainan = "CHN-HAINAN"),
  (e.Lat = "LAT"),
  (e.Lng = "LNG"),
  (e.LngLat = "LNG-LAT"),
  e
))(GeoScope || {});
function arrayToMap(e, T) {
  return e.reduce((e, C) => e.set(T(C), C), new Map());
}
const init = () => ({}),
  LngRegex =
    /^(\+|-)?(?:180(?:(?:\.0{1,6})?)|(?:[0-9]|[1-9][0-9]|1[0-7][0-9])(?:(?:\.[0-9]{1,6})?))$/,
  LatRegex =
    /^(\+|-)?(?:90(?:(?:\.0{1,6})?)|(?:[0-9]|[1-8][0-9])(?:(?:\.[0-9]{1,6})?))$/;
function cast(e) {
  return e;
}
function bound(e) {
  return produce(e, (e) => {
    const T = e.geoPoints,
      C = T.map((e) => e.coordinates),
      $ = T.map((e) => e.value);
    if (0 === C.length) return;
    let F = Number.MAX_SAFE_INTEGER,
      V = Number.MIN_SAFE_INTEGER,
      Y = Number.MAX_SAFE_INTEGER,
      K = Number.MIN_SAFE_INTEGER;
    C.forEach(([e, T]) => {
      (F = Math.min(F, e)),
        (V = Math.max(V, e)),
        (Y = Math.min(Y, T)),
        (K = Math.max(K, T));
    }),
      (e.bounds = [
        [Y, V],
        [K, F],
      ]),
      (e.dataRange = [Math.min(...$), Math.max(...$)]);
  });
}
function lnglat(e, T) {
  return produce(e, (e) => {
    const { vizData: C } = T,
      { datasets: $, fieldMap: F, cells: V } = C,
      Y = Object.keys(C.fieldMap)
        .filter((e) => C.fieldMap[e].location === Location.DIMENSION)
        .filter((e) => {
          var T, C;
          return [GeoScope.Lat, GeoScope.Lng, GeoScope.LngLat].includes(
            null == (C = null == (T = F[e]) ? void 0 : T.geoInfo)
              ? void 0
              : C.geoScope
          );
        })
        .map((e) => {
          var T;
          return {
            scope: null == (T = F[e].geoInfo) ? void 0 : T.geoScope,
            uniqueId: e,
            field: F[e],
          };
        }),
      K = arrayToMap(Y, (e) => e.uniqueId),
      J = Y.map((e) => e.uniqueId),
      ee = J.filter((e) => {
        var T;
        return (null == (T = K.get(e)) ? void 0 : T.scope) === GeoScope.Lat;
      }),
      te = J.filter((e) => {
        var T;
        return (null == (T = K.get(e)) ? void 0 : T.scope) === GeoScope.Lng;
      }),
      ie = J.filter((e) => {
        var T;
        return (null == (T = K.get(e)) ? void 0 : T.scope) === GeoScope.LngLat;
      });
    let ne = [];
    ne.push(...ie),
      ne.push(...lodash.exports.zip(ee, te)),
      (ne = lodash.exports.sortBy(ne, (e) => {
        const T = Array.isArray(e) ? e[0] : e;
        return lodash.exports.findIndex(J, (e) => e === T);
      }));
    const re = new Map();
    null == Y ||
      Y.forEach(({ field: e, uniqueId: T }) => {
        var C, $, F;
        if (
          (null == (C = e.geoInfo) ? void 0 : C.geoScope) === GeoScope.LngLat
        ) {
          const C = new Map();
          null == (F = null == ($ = e.geoInfo) ? void 0 : $.geoMapList) ||
            F.forEach((e) => {
              if (e.geoValue) {
                const { geoId: T } = e;
                if (T && 2 === T.split(",").length) {
                  const $ = cast(T.split(",").map(Number.parseFloat));
                  lodash.exports.isNumber($[0]) &&
                    lodash.exports.isNumber($[1]) &&
                    C.set(e.geoValue, $);
                }
              }
            }),
            re.set(T, C);
        }
      });
    const ae = V[0],
      oe = $[0][0][0],
      se = new Map(),
      le = oe
        .map((e) => {
          var T, C, $, F, V, Y, K;
          const J =
              null == (T = ae.group) ? void 0 : T.map((T) => e[T]).join("-"),
            ee = ne.find((T) =>
              Array.isArray(T)
                ? T.every((T) => !lodash.exports.isNil(e[T]))
                : !lodash.exports.isNil(e[T])
            ),
            te = ee
              ? (function (e, T) {
                  if (!Array.isArray(T)) {
                    const C = T,
                      $ = re.get(C.toString()),
                      F = e[C];
                    return null == $ ? void 0 : $.get(F);
                  }
                  {
                    const C = T[0],
                      $ = T[1],
                      F = e[C],
                      V = e[$];
                    if (LngRegex.test(F) && LatRegex.test(V))
                      return [parseFloat(F), parseFloat(V)];
                  }
                })(e, ee)
              : null;
          if (te) {
            const T = {
                ...lodash.exports.pick(e, null != (C = ae.group) ? C : []),
                ...lodash.exports.pick(e, null != ($ = ae.detail) ? $ : []),
                ...lodash.exports.pick(e, null != (F = ae.color) ? F : []),
                ...lodash.exports.pick(e, null != (V = ae.value) ? V : []),
                ...lodash.exports.pick(e, null != (Y = ae.x) ? Y : []),
                valueKey: ae.value[0],
                lnglatFieldPair: "string" == typeof ee ? [ee] : ee,
              },
              ie = {
                type: "Point",
                coordinates: te,
                value: null != (K = e[ae.value[0]]) ? K : 0,
                name: "string" == typeof ee ? e[ee] : "",
                properties: T,
                color: e[ae.color[0]],
                id: e[ae.group[0]],
              };
            return se.set(J, ie), ie;
          }
          return null;
        })
        .filter(Boolean);
    let de = [];
    if (2 === V.length) {
      const e = V[1];
      (de = $[0][0][1]
        .map((T) => {
          var C, $;
          const F = se.get(T[null == (C = e.link) ? void 0 : C.from]),
            V = se.get(T[null == ($ = e.link) ? void 0 : $.to]);
          if (F && V) {
            const e = {
              fromNode: F,
              toNode: V,
              valueKey: F.properties.valueKey,
            };
            return {
              type: "LineString",
              coordinates: [
                null == F ? void 0 : F.coordinates,
                null == V ? void 0 : V.coordinates,
              ],
              value: lodash.exports.toNumber(T.value),
              properties: e,
            };
          }
          return null;
        })
        .filter(Boolean)),
        le.forEach((e) => {
          e.properties.isWaypoint = !0;
        });
    }
    (e.geoLines = de), (e.geoPoints = le);
  });
}
function colorPipe(e, T) {
  return produce(e, (e) => {
    var C, $;
    const { vizData: F } = T,
      V = F.displayConf,
      Y = F.cells[0],
      { fieldMap: K } = F;
    if (!Object.keys(K).find((e) => K[e].location === Location.COLOR))
      return void (e.color = {
        field: Y.color[0],
        type: "linear",
        range: [
          ...(null != ($ = null == (C = V.color) ? void 0 : C.colorsLinear)
            ? $
            : []),
        ],
      });
    const { color: J } = color(e, T);
    e.color = {
      ...J,
      range: [...J.range],
    };
  });
}
function label$1(e, T) {
  var C;
  const { chartInstance: $, vizData: F } = T,
    V = F.displayConf,
    Y = F.cells[0];
  if (!V.label) return e;
  const K = (e) => createFieldFormatter(e, F, "tooltip"),
    {
      labelColor: J,
      labelPos: ee,
      allowSqueeze: te,
      labelFont: ie,
      labelSize: ne,
      allowOverlap: re,
      labelContent: ae,
      visible: oe,
    } = V.label;
  $.registerFunction("bubble/mark/text/value", (e) =>
    K(e.properties.valueKey)(e.value)
  );
  const se = generateBaseColorConf(J, LabelPos.INNER);
  return (
    (e.label = {
      fontColor: null != (C = se.color) ? C : se.brightColor,
      clampForce: te,
      textCollision: !re,
      textAnchor: "inner" === ee ? "center" : "top",
      fontFamily: ie,
      fontWeight: "normal",
      fontSize: ne,
      enabled: oe,
      textBackgroundColor: "transparent",
      textFormat: (e) => {
        var T;
        const C = [];
        return (
          ae.includes("dimension") && C.push(e.name),
          ae.includes("measure") &&
            (null != (T = Y.value) ? T : []).length > 0 &&
            C.push(K(e.properties.valueKey)(e.value)),
          C.join(" ")
        );
      },
    }),
    e
  );
}
const isDataTypeNumber = (e) => /^(big)?int$|^float$|^decimal|^double$/.test(e);
function bubbleColor(e, T) {
  var C, $, F, V, Y, K, J, ee, te, ie;
  const { vizData: ne } = T,
    { displayConf: re, fieldMap: ae } = ne;
  if (
    [
      ChartType.GIS_MARK_MAP,
      ChartType.GIS_BAR_MAP,
      ChartType.GIS_TRACE_MAP,
    ].includes(ne.chartType)
  )
    if (
      e.color.field &&
      isDataTypeNumber(ae[e.color.field].type) &&
      ae[e.color.field].role === Role.MEASURE &&
      ne.chartType !== ChartType.GIS_BAR_MAP &&
      (null == (C = re.color) ? void 0 : C.colorsLinear)
    )
      e.bubbleColor = gradientObj(
        null != ($ = re.color.colorsLinear) ? $ : [],
        null ==
          (V =
            null == (F = null == re ? void 0 : re.color)
              ? void 0
              : F.colorsLinear)
          ? void 0
          : V[0]
      );
    else if (null == (Y = e.color) ? void 0 : Y.field) {
      const T = getColorItems(ne);
      if (e.color.specified && Object.keys(e.color.specified).length > 0) {
        const C = T.map((T) => e.color.specified[T]),
          $ = {
            type: "ordinal",
            constant: "red",
            ordinal: {
              domain: T,
              range: C,
              clamp: !1,
            },
            default: "red",
          };
        e.bubbleColor = $;
      } else {
        const C = {
          type: "ordinal",
          constant: "red",
          ordinal: {
            domain: T,
            range: e.color.range,
            clamp: !1,
          },
          default: "red",
        };
        e.bubbleColor = C;
      }
    } else
      e.bubbleColor = gradientObj(
        null != (J = null == (K = e.color) ? void 0 : K.range) ? J : [],
        null ==
          (te =
            null == (ee = null == re ? void 0 : re.color)
              ? void 0
              : ee.colorsLinear)
          ? void 0
          : te[0]
      );
  else
    ne.chartType === ChartType.GIS_PULSE_MAP &&
      (e.bubbleColor = {
        type: "linear",
        constant: "rgba(48, 96, 216, 0.5)",
        linear: {
          range: ["rgba(48, 96, 216, 0.5)", "rgba(48, 96, 216, 0.5)"],
          clamp: !1,
        },
        default: "rgba(48, 96, 216, 0.5)",
      });
  return (
    (e.interactiveStyle = {
      ...e.interactiveStyle,
      borderColor:
        null == (ie = null == re ? void 0 : re.interactiveStyle)
          ? void 0
          : ie.strokeColor,
    }),
    e
  );
}
function heatmap(e, T) {
  var C;
  const { vizData: $ } = T;
  if ($.chartType === ChartType.GIS_HEAT_MAP) {
    const T = $.displayConf;
    (e.heatBlur = T.heatmapBlur),
      (e.heatRadius = T.heatmapRadius),
      (e.heatOpacity = null != (C = T.heatmapOpacity) ? C : 50);
    const F = getColorItems($),
      { color: V } = e,
      Y =
        F.length > 0
          ? gradient(V.range, F.length)
          : gradient(V.range, V.range.length);
    e.heatGradient = getHeatmapGradient([...Y], [0.4, 1]);
  }
  return e;
}
function lineSegment(e, T) {
  var C;
  const { vizData: $ } = T,
    { cells: F } = $;
  if (0 === (null == (C = F[0].detail) ? void 0 : C.length))
    return (e.lineSegment = []), e;
  if ($.chartType !== ChartType.GIS_TRACE_MAP) return e;
  const { geoPoints: V } = e,
    Y = {};
  V.forEach((e) => {
    const { id: T } = e;
    Y.hasOwnProperty(T) || (Y[T] = []), Y[T].push(e);
  });
  const K = [];
  return (
    Object.keys(Y).forEach((e) => {
      const T = Y[e];
      T.reduce(
        (e, C, $) => (
          $ > 0 &&
            K.push({
              id: C.id,
              name: `${C.id}-${$}`,
              color: C.color,
              isStart: 1 === $,
              isTerminal: $ === T.length - 1,
              coordinates: [[e.coordinates, C.coordinates]],
            }),
          C
        )
      );
    }),
    (e.lineSegment = K),
    e
  );
}
const gis = {
    initial: {},
    pipes: [
      init,
      lnglat,
      bound,
      colorPipe,
      gisLegend,
      label$1,
      bubbleColor,
      heatmap,
      lineSegment,
    ],
  },
  checkEnabled = (e) => {
    const { animation: T = !1 } = e.displayConf;
    return !0 === T || (T && T.enable, !1);
  },
  annular = (e) => {
    const { type: T = {} } = e,
      { normal: C } = T,
      $ = {
        arc: {
          change: {
            ease: "linear",
            time: 500,
            delay: 0,
          },
        },
      };
    return (
      (null == C ? void 0 : C.enable) &&
        C.ease.includes(AnimationType.NormalRepeat) &&
        ($.compose = {
          normal: {
            rotaTime: 1e3,
            beforeRotaDelay: 0,
            afterRotaDelay: 0,
            showTime: 2e3,
            baseRotation: 1e3,
            roundDelay: 1e3 * C.step,
          },
        }),
      $
    );
  },
  area$1 = (e) => {
    const { type: T = {} } = e,
      { normal: C } = T,
      $ = {
        point: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
        line: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
        area: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
      },
      F = {
        animations: [
          {
            type: "fadeIn",
            delay: 0,
            time: 1e3,
          },
        ],
        oneByOne: !0,
        oneByOneDelay: 0,
      },
      V = {
        animations: [
          {
            type: "clipRange",
            ease: "linear",
            delay: 0,
            time: 2e3,
          },
        ],
        delay: 0,
      },
      Y = {
        animations: [
          {
            type: "clipRange",
            ease: "linear",
            delay: 0,
            time: 2e3,
          },
        ],
        delay: 0,
      };
    return (
      ($.point.add = F),
      ($.line.add = V),
      ($.area.add = Y),
      ($.point.del = F),
      ($.line.del = V),
      ($.area.del = Y),
      (null == C ? void 0 : C.enable) &&
        C.ease.includes(AnimationType.NormalRepeat) &&
        (($.line = {
          ...$.line,
          normal: {
            animations: [
              {
                attribute: "clipRange",
                steps: [
                  {
                    to: 0,
                    time: 10,
                    delay: 0,
                  },
                  {
                    to: 1,
                    time: 2e3,
                    delay: 0,
                  },
                ],
              },
            ],
            delay: 0,
            delayAfter: 1e3 * C.step,
            oneByOne: !1,
            oneByOneDelay: 0,
            repeat: !0,
          },
        }),
        ($.area = {
          ...$.area,
          normal: {
            animations: [
              {
                attribute: "clipRange",
                steps: [
                  {
                    to: 0,
                    time: 10,
                    delay: 0,
                  },
                  {
                    to: 1,
                    time: 2e3,
                    delay: 0,
                  },
                ],
              },
            ],
            delay: 0,
            delayAfter: 1e3 * C.step,
            oneByOne: !1,
            oneByOneDelay: 0,
            repeat: !0,
          },
        }),
        ($.point = {
          ...$.point,
          normal: {
            animations: [
              {
                attribute: "fillOpacity",
                steps: [
                  {
                    to: 0.2,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    to: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
              {
                attribute: "scaleX",
                steps: [
                  {
                    multiple: 0.5,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    multiple: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
              {
                attribute: "scaleY",
                steps: [
                  {
                    multiple: 0.5,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    multiple: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
            ],
            delay: 0,
            delayAfter: 1e3 * C.step,
            oneByOne: !1,
            oneByOneDelay: 0,
            repeat: !0,
          },
        })),
      $
    );
  },
  bar$3 = (e, T) => {
    const { type: C = {} } = e,
      { normal: $ } = C,
      F = {
        bar: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
      };
    let V = {};
    return (
      (V =
        T === ChartType.BAR
          ? {
              animations: [
                {
                  type: "growWidth",
                  delay: 0,
                  time: 1e3,
                },
              ],
              oneByOne: !0,
            }
          : {
              animations: [
                {
                  type: "growHeight",
                  delay: 0,
                  time: 1e3,
                },
              ],
              oneByOne: !0,
            }),
      (F.bar.add = V),
      (F.bar.del = V),
      (null == $ ? void 0 : $.enable) &&
        ($.ease.includes(AnimationType.HighLight)
          ? (F.bar = {
              ...F.bar,
              normal: {
                animations: [
                  {
                    attribute: "fillOpacity",
                    steps: [
                      {
                        to: 1,
                        time: 1e3,
                        delay: 0,
                      },
                      {
                        to: 0.4,
                        time: 1e3,
                        delay: 0,
                      },
                    ],
                  },
                  {
                    attribute: "strokeOpacity",
                    steps: [
                      {
                        to: 1,
                        time: 1e3,
                        delay: 0,
                      },
                      {
                        to: 0.4,
                        time: 1e3,
                        delay: 0,
                      },
                    ],
                  },
                ],
                delay: 0,
                delayAfter: 1e3 * $.step,
                oneByOne: "true",
                oneByOneDelay: 1e3,
                repeat: !0,
              },
            })
          : $.ease.includes(AnimationType.GrowthUp)
          ? (F.bar = {
              normal: {
                animations: [
                  {
                    attribute: "y",
                    steps: [
                      {
                        multiple: 1,
                        add: "height",
                        time: 0,
                      },
                      {
                        multiple: 1,
                        add: 0,
                        time: 2e3,
                      },
                    ],
                  },
                  {
                    attribute: "height",
                    steps: [
                      {
                        multiple: 0,
                        time: 0,
                      },
                      {
                        multiple: 1,
                        time: 2e3,
                      },
                    ],
                  },
                ],
                delay: 0,
                delayAfter: 1e3 * $.step,
                oneByOne: "false",
                oneByOneDelay: 0,
                repeat: !0,
              },
            })
          : $.ease.includes(AnimationType.GrowthRight) &&
            (F.bar = {
              normal: {
                animations: [
                  {
                    attribute: "width",
                    steps: [
                      {
                        multiple: 0,
                        time: 0,
                      },
                      {
                        multiple: 1,
                        time: 2e3,
                      },
                    ],
                  },
                ],
                delay: 0,
                delayAfter: 1e3 * $.step,
                oneByOne: "false",
                oneByOneDelay: 0,
                repeat: !0,
              },
            })),
      F
    );
  },
  line$1 = (e) => {
    const { type: T = {} } = e,
      { normal: C } = T,
      $ = {
        point: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
        line: {
          change: {
            delay: 0,
            ease: "linear",
            time: 2e3,
          },
        },
      },
      F = {
        animations: [
          {
            type: "fadeIn",
            delay: 0,
            time: 1e3,
          },
        ],
        oneByOne: !0,
        oneByOneDelay: 0,
      },
      V = {
        animations: [
          {
            type: "clipRange",
            ease: "linear",
            delay: 0,
            time: 2e3,
          },
        ],
        delay: 0,
      };
    return (
      ($.point.add = F),
      ($.line.add = V),
      ($.point.del = F),
      ($.line.del = V),
      (null == C ? void 0 : C.enable) &&
        C.ease.includes(AnimationType.NormalRepeat) &&
        (($.line = {
          ...$.line,
          normal: {
            animations: [
              {
                attribute: "clipRange",
                steps: [
                  {
                    to: 0,
                    time: 10,
                    delay: 0,
                  },
                  {
                    to: 1,
                    time: 2e3,
                    delay: 0,
                  },
                ],
              },
            ],
            delay: 0,
            delayAfter: 1e3 * C.step,
            oneByOne: !1,
            oneByOneDelay: 0,
            repeat: !0,
          },
        }),
        ($.point = {
          ...$.point,
          normal: {
            animations: [
              {
                attribute: "fillOpacity",
                steps: [
                  {
                    to: 0.2,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    to: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
              {
                attribute: "scaleX",
                steps: [
                  {
                    multiple: 0.5,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    multiple: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
              {
                attribute: "scaleY",
                steps: [
                  {
                    multiple: 0.5,
                    time: 1e3,
                    delay: 0,
                  },
                  {
                    multiple: 1,
                    time: 1e3,
                    delay: 0,
                  },
                ],
              },
            ],
            delay: 0,
            delayAfter: 1e3 * C.step,
            oneByOne: !1,
            oneByOneDelay: 0,
            repeat: !0,
          },
        })),
      $
    );
  },
  pie$1 = (e) => {
    const { type: T = {} } = e,
      { normal: C } = T,
      $ = {
        arc: {
          change: {
            ease: "linear",
            time: 500,
            delay: 0,
          },
        },
      };
    return (
      (null == C ? void 0 : C.enable) &&
        C.ease.includes(AnimationType.Spread) &&
        ($.arc = {
          normal: {
            repeat: !0,
            delay: 0,
            oneByOne: "false",
            oneByOneDelay: 0,
            delayAfter: 1e3 * C.step,
            animations: [
              {
                attribute: "endAngle",
                steps: [
                  {
                    to: 0,
                    time: 0,
                    delay: 0,
                  },
                  {
                    multiple: 1,
                    time: 2e3,
                    delay: 0,
                  },
                ],
              },
            ],
          },
        }),
      $
    );
  },
  animation = (e, { vizData: T }) => {
    var C;
    if (!checkEnabled(T))
      return isGauge(T)
        ? {
            ...e,
            gauge: {
              ...(null != (C = e.gauge) ? C : {}),
              animation: !1,
            },
            animation: !1,
          }
        : {
            ...e,
            animation: !1,
          };
    const $ = T.chartType,
      F = {
        ...e,
      },
      { displayConf: V } = T,
      { animation: Y = !1 } = V;
    if ((!0 === Y && (F.animation = !0), T.origin === Origin.VSCREEN)) {
      let e = {};
      return (
        $ === ChartType.ANNULAR
          ? ((e = annular(Y)), F.appearAnimation)
          : $ === ChartType.BAR || $ === ChartType.COLUMN_PARALLEL
          ? (e = bar$3(Y, $))
          : $ === ChartType.LINE
          ? (e = line$1(Y))
          : $ === ChartType.DUAL_AXIS
          ? (e = {
              ...line$1(Y),
              ...bar$3(Y, $),
            })
          : $ === ChartType.PROGRESS
          ? (e = pie$1(Y))
          : $ === ChartType.AREA && (e = area$1(Y)),
        (F.oldAnimation = e),
        F
      );
    }
    return F;
  },
  CHART_DATA_ID = "data",
  CHART_MAIN_SERIES_DATA_ID = "mainSeriesData",
  CHART_SUB_SERIES_DATA_ID = "subSeriesData",
  MAIN_REGION_ID = "mainRegion",
  SUB_REGION_ID = "subRegion",
  DATA_ZOOM_REGION_ID = "dataZoomRegion",
  DIMENSION_AXIS_ID = "dimensionAxis",
  MEASURE_AXIS_LEFT_ID = "measureAxisLeft",
  MEASURE_AXIS_RIGHT_ID = "measureAxisRight",
  MAIN_SERIES_ID = "mainSeries",
  SUB_SERIES_ID = "subSeries",
  VCHART_FUNNEL_REACH_RATIO = "__VCHART_FUNNEL_REACH_RATIO",
  SCATTER_MAP_POINT_COLOR_SCALE_ID = "scatterMapPointColorScale",
  SCATTER_MAP_SCATTER_SERIES_ID = "scatterMapScatterSeries",
  chartSpaceSizeToVChartSize = (e) => Math.sqrt(Math.PI) * e,
  getScatterSizeRange = (e) => {
    var T, C;
    return null != (C = null == (T = e.displayConf.size) ? void 0 : T.range)
      ? C
      : [4, 16];
  },
  enableMeasureParallelList = [
    ChartType.COLUMN,
    ChartType.COLUMN_PERCENT,
    ChartType.BAR,
    ChartType.BAR_PERCENT,
    ChartType.DUAL_AXIS,
    ChartType.COMBINATION,
  ],
  stack = (e, { vizData: T }, C) => {
    var $, F, V, Y, K, J, ee, te;
    const ie = T.cells[0],
      ne = T.displayConf,
      re = {
        ...e,
      },
      ae = null != C ? C : T.chartType;
    return (
      enableMeasureParallelList.includes(ae) &&
        ne.measureParallel &&
        (null == ($ = null == ie ? void 0 : ie.foldInfo) ? void 0 : $.key) &&
        ("horizontal" === re.direction
          ? (re.yField = [null == (F = ie.x) ? void 0 : F[0], ie.foldInfo.key])
          : (re.xField = [
              null == (V = ie.x) ? void 0 : V[0],
              ie.foldInfo.key,
            ])),
      [ChartType.BAR_PARALLEL, ChartType.COLUMN_PARALLEL].includes(ae) &&
        ("horizontal" === re.direction
          ? (re.yField = [
              null == (Y = ie.x) ? void 0 : Y[0],
              null == (K = null == ie ? void 0 : ie.color) ? void 0 : K[0],
            ])
          : (re.xField = [
              null == (J = ie.x) ? void 0 : J[0],
              null == (ee = null == ie ? void 0 : ie.color) ? void 0 : ee[0],
            ])),
      ae === ChartType.AREA &&
        ((re.stack = null == (te = ne.stack) || te),
        ne.measureParallel && (re.stack = !ne.measureParallel)),
      (re.stackInverse = !0),
      re
    );
  },
  multiSeriesStack = (e, T) => {
    const { vizData: C } = T,
      $ = C.displayConf,
      { dualAxis: F } = $,
      V = e.series.find((e) => e.id === MAIN_SERIES_ID),
      Y = e.series.find((e) => e.id === SUB_SERIES_ID);
    if (C.chartType === ChartType.BILATERAL)
      return {
        ...e,
        series: [
          {
            ...V,
            stack: !1,
          },
          {
            ...Y,
            stack: !1,
          },
        ],
      };
    const K = stack(V, T, null == F ? void 0 : F.main),
      J = Y ? stack(Y, T, null == F ? void 0 : F.sub) : void 0,
      ee = !!isDualAxis(C);
    return {
      ...e,
      stackInverse: ee,
      series: [K, J].filter(Boolean),
    };
  },
  combinationStack = (e, T) => {
    const { vizData: C } = T,
      { payload: $ } = T,
      { dualAxis: F } = $,
      V = e.series.find((e) => e.id === MAIN_SERIES_ID),
      Y = e.series.find((e) => e.id === SUB_SERIES_ID),
      K = stack(V, T, null == F ? void 0 : F.main),
      J = Y ? stack(Y, T, null == F ? void 0 : F.sub) : void 0,
      ee = !!isDualAxis(C);
    return {
      ...e,
      stackInverse: ee,
      series: [K, J].filter(Boolean),
    };
  },
  dataZoomSize = 28,
  dataZoomPadding = 15,
  getDataZoomPaddingAndSize = (e) =>
    "left" === e
      ? {
          padding: {
            right: dataZoomPadding,
          },
          width: dataZoomSize,
        }
      : "right" === e
      ? {
          padding: {
            left: dataZoomPadding,
          },
          width: dataZoomSize,
        }
      : "top" === e
      ? {
          padding: {
            bottom: dataZoomPadding,
          },
          height: dataZoomSize,
        }
      : "bottom" === e
      ? {
          padding: {
            top: dataZoomPadding,
          },
          height: dataZoomSize,
        }
      : void 0,
  isGroupedBandAxis = (e, T) => {
    var C;
    const { displayConf: $, chartType: F } = e;
    return (
      !!(
        enableMeasureParallelList.includes(F) &&
        $.measureParallel &&
        (null == (C = null == T ? void 0 : T.foldInfo) ? void 0 : C.key)
      ) || !![ChartType.BAR_PARALLEL, ChartType.COLUMN_PARALLEL].includes(F)
    );
  },
  checkIsOverlap = (e, T) => {
    const { AABBBounds: C } = e,
      { AABBBounds: $ } = T,
      F = C.x1,
      V = C.x2,
      Y = $.x1,
      K = $.x2;
    return !(V < Y || F > K);
  },
  calculateInnerOffset = (e, T = !1, C = ["top"]) => {
    const { chartType: $ } = e,
      F = chartSpaceSizeToVChartSize(getSymbolSize(e)) / 2;
    if (
      T ||
      [
        ChartType.LINE,
        ChartType.AREA,
        ChartType.AREA_PERCENT,
        ChartType.CIRCLE_VIEWS,
      ].includes($)
    )
      return C.reduce((e, T) => ((e[T] = F), e), {});
  },
  getSymbolSize = (e) => {
    const { displayConf: T } = e;
    if (isScatter(e) || isCircleViews(e)) {
      return 1 + getScatterSizeRange(e)[1];
    }
    const { lineStyle: C = {} } = T,
      { symbolSize: $ = 3 } = C;
    return Array.isArray($)
      ? 1 + Math.max(...$.map((e) => (e.value ? e.value : 3)))
      : 1 + $;
  },
  lineStyleConfigMap$1 = {
    [LineStyleType.SOLID]: [],
    [LineStyleType.DASHED]: [4, 2],
    [LineStyleType.DOTTED]: [1, 1],
  },
  logScaleMap = {
    [AxisRatioType.LOG_2]: 2,
    [AxisRatioType.LOG_10]: 10,
    [AxisRatioType.LOG_32]: 32,
    [AxisRatioType.LOG_1024]: 1024,
  },
  getPadding = (e, T) => 1 - ((1 - e) / (1 + 2 * T)) * (1 - T),
  axisDimension = (e, T, C, $) => {
    const {
        visible: F,
        titleEnable: V,
        titleText: Y,
        titleDeafult: K,
        titleSize: J,
        titleColor: ee,
        labelSize: te,
        labelColor: ie,
        labelRotate: ne,
        labelVerticalArrangement: re,
        lineColor: ae,
        domain: oe,
        grid: se,
        gridColor: le,
        gridWidth: de = 1,
        gridLineStyle: ce = LineStyleType.DASHED,
        labelVisible: ue = !0,
        lineWidth: he = 1,
        titleWeight: pe = "normal",
        titleFont: ge,
        labelFont: fe,
        labelWeight: me = "normal",
        dataZoom: ye,
        dataZoomBackgroundChartColor: be,
        dataZoomBackgroundColor: ve,
        dataZoomFilterColor: Te,
        dataZoomHandleColor: _e,
      } = e,
      Ce =
        INVALID_VALUE_MAP$5[
          (null == C ? void 0 : C.dimensions) || SpecialValueType$1.NULL
        ],
      {
        id: Ae,
        spec: xe,
        format: Se,
        labelCustomOverlap: Re,
        hasGroup: Me,
      } = null != $ ? $ : {},
      Pe = {
        id: Ae,
        type: "band",
        tick: {
          visible: !1,
        },
        grid: {
          visible: se,
          style: {
            zIndex: 150,
            stroke: le,
            lineWidth: de,
            lineDash: lineStyleConfigMap$1[ce].map((e) => e * de),
          },
        },
        orient: T,
        visible: F,
        domainLine: {
          visible: oe,
          style: {
            lineWidth: he,
            stroke: ae,
          },
        },
        title: {
          visible: V,
          space: 5,
          text: Y || K || "",
          style: {
            fontSize: J,
            fill: ee,
            fontFamily: "inherit" === ge ? "" : ge,
            fontWeight: pe,
          },
        },
        maxHeight: null,
        autoIndent: !1,
        sampling: !1,
        zIndex: 200,
        label: {
          visible: ue,
          space: "left" === T || "right" === T ? 8 : 4,
          style: {
            fontSize: te,
            fill: ie,
            angle: re ? 0 : ne,
            fontFamily: "inherit" === fe ? "" : fe,
            fontWeight: me,
            direction: re ? "vertical" : "horizontal",
            maxLineWidth: 174,
          },
          formatMethod: createFormatter(Se, Ce),
          autoHide: !0,
          autoHideMethod: "greedy",
          flush: 0 === ne,
          lastVisible: !0,
          layoutFunc: Re || void 0,
        },
        hover: !0,
        background: {
          visible: !0,
          state: {
            hover: {
              fillOpacity: 0.08,
              fill: "#141414",
            },
            hover_reverse: {
              fillOpacity: 0.08,
              fill: "#141414",
            },
          },
        },
      };
    return (
      Me
        ? ((Pe.paddingInner = [0.15, 0.1]), (Pe.paddingOuter = [0.075, 0.1]))
        : ((Pe.paddingInner = getPadding(0.15, 0.1)),
          (Pe.paddingOuter = 0.175)),
      ye &&
        F &&
        xe &&
        ((xe.dataZoom = xe.dataZoom || []),
        xe.dataZoom.push({
          axisId: Ae,
          filterMode: "axis",
          showDetail: !1,
          orient: T,
          ...getDataZoomPaddingAndSize(T),
          backgroundColor: {
            style: {
              fill: ve,
            },
          },
          backgroundChart: {
            area: {
              style: {
                fill: be,
              },
            },
          },
          selectedBackground: {
            style: {
              fill: Te,
            },
          },
          startText: {
            visible: !1,
            style: {
              text: "",
            },
          },
          endText: {
            visible: !1,
            style: {
              text: "",
            },
          },
          startHandler: {
            style: {
              size: 22,
              fill: _e,
            },
          },
          endHandler: {
            style: {
              size: 22,
              fill: _e,
            },
          },
          middleHandler: {
            visible: !1,
          },
        })),
      Pe
    );
  },
  axisMeasure = (
    e,
    T,
    C = {
      hover: !0,
    }
  ) => {
    const {
        visible: $,
        titleEnable: F,
        titleText: V,
        titleDeafult: Y,
        titleSize: K,
        titleColor: J,
        labelSize: ee,
        labelColor: te,
        labelRotate: ie,
        labelVerticalArrangement: ne,
        lineColor: re,
        domain: ae = !0,
        domainType: oe,
        domainMin: se,
        domainMax: le,
        numFormat: de,
        ratioType: ce,
        grid: ue = !0,
        gridColor: he,
        gridWidth: pe = 1,
        gridLineStyle: ge = LineStyleType.DASHED,
        labelVisible: fe = !0,
        titleWeight: me = "normal",
        titleFont: ye,
        labelFont: be,
        labelWeight: ve = "normal",
        lineWidth: Te = 1,
        reverse: _e,
        dataZoom: Ce,
        dataZoomBackgroundChartColor: Ae,
        dataZoomBackgroundColor: xe,
        dataZoomFilterColor: Se,
        dataZoomHandleColor: Re,
      } = e,
      {
        sync: Me,
        spec: Pe,
        id: Be,
        expandMax: Ee,
        hover: Le,
        tickMode: we,
        yField: De,
        index: Ie,
        innerOffset: Oe,
      } = C;
    let $e;
    if (de) {
      const { dataFormatUnit: e } = de,
        T = lodash.exports.isNil(e) || "auto" === e ? intl.getLocale() : e;
      if ("auto" in de && !0 === de.auto) {
        const e = (e) => {
          const T = Math.abs(e);
          return T > 0 ? Math.log10(T) : 0;
        };
        $e = (C, $) => {
          const F = e(C);
          let V = null;
          "zh_CN" === T
            ? F >= 8
              ? (V = {
                  ratio: 1e8,
                  symbol: "",
                })
              : F >= 4 &&
                (V = {
                  ratio: 1e4,
                  symbol: "",
                })
            : "en_US" === T &&
              (F >= 9
                ? (V = {
                    ratio: 1e9,
                    symbol: "B",
                  })
                : F >= 6
                ? (V = {
                    ratio: 1e6,
                    symbol: "M",
                  })
                : F >= 3 &&
                  (V = {
                    ratio: 1e3,
                    symbol: "K",
                  }));
          const Y = Object.assign({}, de, {
            unit: V,
          });
          return createFormatter(Y)(C);
        };
      } else $e = createFormatter(de);
    }
    const ke = {
      id: Be,
      type: "linear",
      tick: {
        visible: !1,
        tickMode: we || "d3",
        tickCount: (e) => {
          var T;
          const {
              axisLength: C,
              rangeSize: $,
              labelStyle: F,
            } = null != e ? e : {},
            V = C || $,
            Y = Math.ceil(
              (V /
                (1.5 *
                  (null != (T = null == F ? void 0 : F.fontSize) ? T : 12))) *
                0.2
            );
          return Y < 2 ? 2 : Y;
        },
        style: {
          stroke: re,
        },
      },
      niceType: "accurateFirst",
      zIndex: 200,
      grid: {
        visible: ue,
        style: {
          zIndex: 150,
          stroke: he,
          lineWidth: pe,
          lineDash: lineStyleConfigMap$1[ge].map((e) => e * pe),
        },
      },
      orient: T,
      visible: $,
      domainLine: {
        visible: ae,
        style: {
          lineWidth: Te,
          stroke: re,
        },
      },
      title: {
        visible: F,
        text: V || Y || "",
        space: 8,
        style: {
          fontSize: K,
          fill: J,
          fontFamily: "inherit" === ye ? "" : ye,
          fontWeight: me,
        },
      },
      autoIndent: !1,
      sampling: !1,
      label: {
        visible: fe,
        space: "left" === T || "right" === T ? 6 : 4,
        flush: 0 === ie,
        padding: 0,
        style: {
          fontSize: ee,
          maxLineWidth: 174,
          fill: te,
          angle: ne ? 0 : ie,
          fontFamily: "inherit" === be ? "" : be,
          fontWeight: ve,
          dy: 0,
          direction: ne ? "vertical" : "horizontal",
        },
        formatMethod: $e,
        autoHide: !0,
        autoHideMethod: "greedy",
      },
      hover: Le,
      background: {
        visible: !0,
        state: {
          hover: {
            fillOpacity: 0.08,
            fill: "#141414",
          },
          hover_reverse: {
            fillOpacity: 0.08,
            fill: "#141414",
          },
        },
      },
      innerOffset: Oe,
    };
    switch (oe) {
      case AxisDomainType.NICE:
        ke.zero = !0;
        break;
      case AxisDomainType.AUTO_MIN:
        ke.zero = !1;
        break;
      case AxisDomainType.CUSTOM:
        (ke.min = se), (ke.max = le), (ke.zero = !0);
    }
    if (
      (_e && (ke.inverse = !0),
      Me
        ? Me &&
          (ke.sync = {
            ...Me,
          })
        : (ke.nice = !0),
      oe === AxisDomainType.CUSTOM && (ke.nice = !1),
      ce && ce !== AxisRatioType.LINEAR)
    ) {
      const e =
          !lodash.exports.isNil(Ie) &&
          lodash.exports.isArray(Pe.data[0].values[0])
            ? Pe.data[0].values[null != Ie ? Ie : 0]
            : Pe.data[0].values,
        T =
          !De ||
          !e ||
          e.flat(3).some((e) => {
            const T = lodash.exports.toNumber(e[De]);
            return !!(lodash.exports.isNumber(T) && T < 0);
          });
      (ke.zero = !1),
        (ke.type = T ? "symlog" : "log"),
        "symlog" === ke.type
          ? (ke.constant = logScaleMap[ce])
          : (ke.base = logScaleMap[ce]);
    }
    return (
      Ce &&
        $ &&
        Pe &&
        ((Pe.dataZoom = Pe.dataZoom || []),
        Pe.dataZoom.push({
          filterMode: "axis",
          orient: T,
          showDetail: !1,
          ...getDataZoomPaddingAndSize(T),
          backgroundColor: {
            style: {
              fill: xe,
            },
          },
          backgroundChart: {
            area: {
              style: {
                fill: Ae,
              },
            },
          },
          selectedBackground: {
            style: {
              fill: Se,
            },
          },
          startText: {
            visible: !1,
            style: {
              text: "",
            },
          },
          endText: {
            visible: !1,
            style: {
              text: "",
            },
          },
          startHandler: {
            style: {
              size: 22,
              fill: Re,
            },
          },
          endHandler: {
            style: {
              size: 22,
              fill: Re,
            },
          },
          middleHandler: {
            visible: !1,
          },
        })),
      Ee &&
        (ke.expand = {
          max: Ee,
        }),
      ke
    );
  },
  yxAxes = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      Y = V.displayConf,
      K = null == (C = V.cells[0].x) ? void 0 : C[0],
      J = null == ($ = V.cells[0].y) ? void 0 : $[0],
      ee = axisDimension(Y.axisDimension[0], "left", Y.specialValue, {
        spec: e,
        format:
          null == (F = V.fieldMap[null != K ? K : ""]) ? void 0 : F.format,
        hasGroup: isGroupedBandAxis(V, V.cells[0]),
      }),
      te = axisMeasure(Y.axisMeasure[0], "bottom", {
        spec: e,
        yField: J,
        innerOffset: calculateInnerOffset(V),
      });
    return {
      ...e,
      axes: [ee, te],
    };
  },
  xyAxes$1 = (e, T) => {
    var C, $, F, V;
    const { vizData: Y } = T,
      K = Y.displayConf,
      J = null != ($ = null == (C = Y.cells[0].x) ? void 0 : C[0]) ? $ : "",
      ee = null == (F = Y.cells[0].y) ? void 0 : F[0],
      te = axisDimension(K.axisDimension[0], "bottom", K.specialValue, {
        spec: e,
        format: null == (V = Y.fieldMap[J]) ? void 0 : V.format,
        hasGroup: isGroupedBandAxis(Y, Y.cells[0]),
      }),
      ie = axisMeasure(K.axisMeasure[0], "left", {
        spec: e,
        innerOffset: calculateInnerOffset(Y),
        yField: ee,
      });
    return {
      ...e,
      axes: [te, ie],
    };
  },
  yyAxes = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      Y = V.displayConf,
      K = null == (C = V.cells[0].x) ? void 0 : C[0],
      J = null == ($ = V.cells[0].y) ? void 0 : $[0];
    return (
      (F.axes = [
        axisMeasure(Y.axisMeasure[1], "left", {
          spec: F,
          innerOffset: calculateInnerOffset(V, !0, ["top", "right"]),
          yField: J,
        }),
        axisMeasure(Y.axisMeasure[0], "bottom", {
          spec: F,
          innerOffset: calculateInnerOffset(V, !0, ["top", "right"]),
          yField: K,
        }),
      ]),
      F
    );
  },
  yxxAxes = (e, T) => {
    var C, $, F;
    const V = {
        ...e,
      },
      { vizData: Y } = T,
      K = Y.displayConf,
      J = null == (C = Y.cells[0].x) ? void 0 : C[0],
      ee = axisDimension(K.axisDimension[0], "left", K.specialValue, {
        spec: V,
        format: Y.fieldMap[J].format,
        id: DIMENSION_AXIS_ID,
        hasGroup: isGroupedBandAxis(Y, Y.cells[0]),
      });
    if (
      ((ee.label = {
        ...ee.label,
        space: 0,
        containerAlign: "center",
      }),
      V.dataZoom)
    ) {
      const e = V.dataZoom.find((e) => e.axisId === DIMENSION_AXIS_ID);
      e &&
        ((e.regionId = DATA_ZOOM_REGION_ID),
        (V.layout.col += 1),
        V.layout.elements.forEach((e) => {
          e.col += 1;
        }),
        V.layout.elements.push({
          modelId: DATA_ZOOM_REGION_ID,
          col: 0,
          row: 0,
        }),
        V.region.push({
          id: DATA_ZOOM_REGION_ID,
        }));
    }
    (ee.maxWidth = 190),
      (ee.domainLine = {
        visible: !1,
      }),
      (ee.inverse = !0),
      (ee.offsetX = 8),
      (ee.label = {
        ...ee.label,
        space: 16,
      }),
      (ee.regionId = [MAIN_REGION_ID, SUB_REGION_ID]),
      (ee.seriesId = [MAIN_SERIES_ID, SUB_SERIES_ID]);
    const te = axisMeasure(K.axisMeasure[0], "bottom", {
      spec: V,
      id: MEASURE_AXIS_LEFT_ID,
      yField: null == ($ = Y.cells[0].y) ? void 0 : $[0],
      innerOffset: calculateInnerOffset(Y),
    });
    (te.regionId = MAIN_REGION_ID),
      (te.seriesId = MAIN_SERIES_ID),
      (te.inverse = !K.axisMeasure[0].reverse);
    const ie = axisMeasure(K.axisMeasure[1], "bottom", {
      spec: V,
      id: MEASURE_AXIS_RIGHT_ID,
      yField: null == (F = Y.cells[0].y) ? void 0 : F[1],
      innerOffset: calculateInnerOffset(Y),
    });
    return (
      (ie.regionId = SUB_REGION_ID),
      (ie.seriesId = SUB_SERIES_ID),
      (V.axes = [ee, te, ie]),
      V
    );
  },
  xyyAxes = (e, T) => {
    var C, $, F, V, Y;
    const K = {
        ...e,
      },
      { vizData: J } = T,
      ee = J.displayConf,
      { chartType: te } = J,
      ie = J.cells[0],
      ne = null == (C = J.cells[0].x) ? void 0 : C[0],
      re = axisDimension(ee.axisDimension[0], "bottom", ee.specialValue, {
        spec: K,
        format: J.fieldMap[ne].format,
        id: DIMENSION_AXIS_ID,
        hasGroup: isGroupedBandAxis(J, J.cells[0]),
      }),
      ae = axisMeasure(ee.axisMeasure[0], "left", {
        spec: K,
        id: MEASURE_AXIS_LEFT_ID,
        yField: null == ($ = J.cells[0].y) ? void 0 : $[0],
        innerOffset: calculateInnerOffset(J),
      }),
      { domainDoubleAxisSync: oe } = ee.axisMeasure[0];
    ae.seriesId = oe ? [MAIN_SERIES_ID, SUB_SERIES_ID] : MAIN_SERIES_ID;
    const se = !(
        te === ChartType.DUAL_AXIS &&
        void 0 === (null == (F = ie.y) ? void 0 : F[1])
      ),
      le = axisMeasure(ee.axisMeasure[1], "right", {
        spec: K,
        id: MEASURE_AXIS_RIGHT_ID,
        innerOffset: calculateInnerOffset(J),
        yField: null == (V = J.cells[0].y) ? void 0 : V[1],
      });
    return (
      (le.seriesId = oe ? [MAIN_SERIES_ID, SUB_SERIES_ID] : SUB_SERIES_ID),
      (le.grid = {
        ...le.grid,
        visible: !1,
      }),
      (le.sync = {
        ...le.sync,
        axisId: MEASURE_AXIS_LEFT_ID,
        zeroAlign: (null != (Y = ee.axisMeasure) ? Y : [])
          .map(
            (e) =>
              e.domainType !== AxisDomainType.AUTO_MIN &&
              e.ratioType === AxisRatioType.LINEAR
          )
          .reduce((e, T) => e && T, !0),
      }),
      oe &&
        ((le.inverse = ae.inverse),
        (le.type = ae.type),
        (le.constant = ae.constant)),
      (K.axes = [re, ae, se ? le : void 0].filter(Boolean)),
      K
    );
  },
  xAxes = (e, T) => {
    var C, $, F;
    const V = {
        ...e,
      },
      { vizData: Y } = T,
      { displayConf: K } = Y,
      J =
        (null == (C = null == K ? void 0 : K.combination)
          ? void 0
          : C.layout) === CombinationLayout.COLUMN
          ? "left"
          : "bottom",
      ee =
        null == (F = null == ($ = Y.cells[0]) ? void 0 : $.x) ? void 0 : F[0];
    return (
      (V.axes = [
        axisDimension(K.axisDimension[0], J, K.specialValue, {
          spec: V,
          format: Y.fieldMap[ee].format,
          hasGroup: isGroupedBandAxis(Y, Y.cells[0]),
        }),
      ]),
      V
    );
  },
  yAxes = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      Y = V.displayConf,
      K = null == (C = V.cells[0].x) ? void 0 : C[0],
      { format: J } = V.fieldMap[K],
      ee = axisMeasure(
        {
          ...Y.axisMeasure[0],
          numFormat: null != ($ = Y.axisMeasure[0].numFormat) ? $ : J,
        },
        "bottom",
        {
          spec: F,
          tickMode: "average",
          innerOffset: calculateInnerOffset(V),
        }
      );
    return (F.axes = [ee]), F;
  },
  INVALID_VALUE_MAP$4 = {
    [SpecialValueType$1.BRACKET_TXT]: " ",
    [SpecialValueType$1.NULL]: "NULL",
    [SpecialValueType$1.ZERO]: "0",
    [SpecialValueType$1.DASH]: "--",
  },
  getFormatMethod$1 = (e, T, C) => ($, F) => {
    const V = getFieldFormat,
      Y = createFormatter;
    if (null !== F && isNaN(Number(F))) return F;
    if (void 0 === e) return F;
    return Y(V(e, T, "field"), INVALID_VALUE_MAP$4[C])(F);
  },
  getFormatMethodWithValue$2 = (e, T, C, $, F) => () => {
    const $ = getFieldFormat,
      V = createFormatter;
    if (null !== F && isNaN(Number(F))) return F;
    if (void 0 === e) return F;
    return V($(e, T, "field"), INVALID_VALUE_MAP$4[C])(F);
  },
  gaugeAxis = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $,
      {
        showDegreeMarks: V,
        tickStyle: Y = {},
        type: K,
        showSections: J,
        outerRadius: ee,
      } = F,
      {
        tickSize: te = J ? 4 : 8,
        tickWidth: ie = J ? 1 : 2,
        tickColor: ne = "rgba(255, 255, 255, 0.3)",
        labelColor: re = "rgba(255, 255, 255, 0.3)",
        labelFamily: ae = GAUGE_FONT_FAMILY,
        labelWeight: oe = "normal",
        labelSize: se = 12,
      } = Y,
      { min: le, max: de } = T.payload,
      ce = null != ee ? ee : K === GaugeType.DEGREE_MARKS ? 0.58 : 0.5075;
    T.payload.labelLayoutRadius = ce;
    return {
      ...e,
      axes: [
        {
          visible: V,
          type: "linear",
          orient: "angle",
          inside: !0,
          min: le,
          max: de,
          innerRadius: ce,
          interactive: !1,
          label: {
            visible: !J,
            inside: !0,
            space: 8,
            style: {
              fill: re,
              fontSize: se,
              fontFamily: ae,
              fontWeight: oe,
            },
          },
          tick: {
            visible: !0,
            tickSize: te,
            style: {
              stroke: ne,
              lineWidth: ie,
            },
          },
          subTick: {
            visible: !1,
            tickSize: 4,
            tickCount: 6,
            style: {
              stroke:
                null != (C = null == Y ? void 0 : Y.minorTickColor)
                  ? C
                  : null == Y
                  ? void 0
                  : Y.tickColor,
            },
          },
          grid: {
            visible: !1,
          },
          subGrid: {
            visible: !1,
          },
        },
      ],
    };
  },
  createGaugeLabelFormatMethod = (e) => {
    const { vizData: T } = e,
      { displayConf: C } = T,
      { tickStyle: $, params: F, specialValue: V } = C,
      { min: Y, max: K } = e.payload,
      { numFormat: J } = null != $ ? $ : {};
    return (e) => {
      var C, $, ee, te, ie, ne;
      if (J && !J.auto) return createFormatter(J)(e);
      if (
        F.minType === MeasureParamType.STATIC &&
        null !== F.minValue &&
        F.maxType === MeasureParamType.STATIC &&
        null !== F.maxValue
      ) {
        const Y =
            null != (C = null == V ? void 0 : V.measures)
              ? C
              : SpecialValueType$1.BRACKET_TXT,
          K =
            F.goalType === MeasureParamType.DYNAMIC
              ? null != (ee = F.goalPillUid)
                ? ee
                : null == ($ = T.cells[0].value)
                ? void 0
                : $[0]
              : null == (te = T.cells[0].value)
              ? void 0
              : te[0];
        return getFormatMethod$1(String(K), T, Y)("", e);
      }
      if (
        F.minType === MeasureParamType.STATIC &&
        F.maxType === MeasureParamType.STATIC
      ) {
        const C = null == (ie = T.cells[0].value) ? void 0 : ie[0];
        return getFormatMethod$1(
          String(C),
          T,
          SpecialValueType$1.BRACKET_TXT
        )("", e);
      }
      const re =
          null != (ne = null == V ? void 0 : V.measures)
            ? ne
            : SpecialValueType$1.BRACKET_TXT,
        ae = getFormatMethod$1(String(F.minPillUid), T, re)("", 1e4),
        oe = getFormatMethod$1(String(F.maxPillUid), T, re)("", 1e4);
      if (
        F.minType === MeasureParamType.DYNAMIC &&
        F.maxType === MeasureParamType.DYNAMIC &&
        ae === oe
      )
        return getFormatMethod$1(String(F.minPillUid), T, re)("", e);
      if (
        F.minType === MeasureParamType.DYNAMIC &&
        F.minPillUid &&
        (F.maxType === MeasureParamType.STATIC || !F.maxPillUid)
      )
        return getFormatMethod$1(String(F.minPillUid), T, re)("", e);
      if (
        F.maxType === MeasureParamType.DYNAMIC &&
        F.maxPillUid &&
        (F.minType === MeasureParamType.STATIC || !F.minPillUid)
      )
        return getFormatMethod$1(String(F.maxPillUid), T, re)("", e);
      let se = (K - Y) / 10,
        le = 1;
      for (; se && Math.abs(se) < 1; ) (le *= 10), (se *= 10);
      return Math.floor(e * le) / le;
    };
  },
  progressAxis = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      { type: F } = $;
    if (F === ProgressType.BAR) return e;
    const {
        payload: { min: V, max: Y },
      } = T,
      K = [
        {
          type: "linear",
          orient: "angle",
          min: V,
          max: Y,
          grid: {
            visible: !1,
          },
          label: {
            visible: !1,
          },
        },
      ];
    return {
      ...e,
      axes: K,
    };
  },
  radarAxis = (e, T) => {
    const { vizData: C } = T,
      $ = yAxes(e, T),
      F = getFields(C, Location.DIMENSION, isRenderField)[0],
      V = getFieldFormat(F, C),
      {
        tick: Y,
        zero: K,
        min: J,
        max: ee,
        nice: te,
        label: ie,
        grid: ne,
        domainLine: re,
        sampling: ae,
      } = $.axes[0];
    return (
      ($.axes = [
        {
          orient: "radius",
          zero: K,
          nice: te,
          min: J,
          max: ee,
          sampling: ae,
          tick: {
            ...Y,
            tickCount: void 0,
          },
          domainLine: {
            visible: !1,
          },
          grid: {
            ...re,
            smooth: !1,
          },
          label: {
            visible: !1,
          },
        },
        {
          orient: "angle",
          sampling: ae,
          tick: {
            ...Y,
            tickCount: void 0,
          },
          domainLine: {
            visible: !1,
          },
          grid: {
            ...ne,
            smooth: !1,
          },
          label: {
            ...ie,
            formatMethod: (e) => (V ? createFormatter(V)(e) : e),
          },
        },
      ]),
      ($.sortDataByAxis = !0),
      $
    );
  },
  roseAxis = (e) => ({
    ...e,
    axes: [
      {
        orient: "radius",
        zero: !0,
        nice: !1,
      },
    ],
  }),
  updateBarStyle = (e, T) => {
    var C;
    let $ = e;
    return (
      (null == T ? void 0 : T.barWidth) &&
        "auto" !== T.barWidth &&
        ($ = {
          ...$,
          barWidth: T.barWidth,
        }),
      (null == T ? void 0 : T.cornerRadius) &&
        ($ = {
          ...$,
          bar: {
            ...(null == $ ? void 0 : $.bar),
            style: {
              ...(null == (C = null == $ ? void 0 : $.bar) ? void 0 : C.style),
              cornerRadius: T.cornerRadius,
            },
          },
        }),
      $
    );
  },
  updateAxesPadding = (e) => {
    var T;
    return {
      ...e,
      axes:
        null == (T = e.axes)
          ? void 0
          : T.map((e) => {
              if ("band" === e.type) {
                const { paddingInner: T, paddingOuter: C } = e;
                return {
                  ...e,
                  paddingInner: Array.isArray(T) ? [0.15, 0] : 0.1,
                  paddingOuter: Array.isArray(C) ? [0.075, 0] : 0.075,
                };
              }
              return e;
            }),
    };
  },
  barStyle = (e, { vizData: T }) => {
    var C, $;
    const { displayConf: F, chartType: V } = T,
      { barStyle: Y } = F;
    let K = e,
      J = !1;
    return (
      V === ChartType.COMBINATION
        ? (K = {
            ...K,
            indicators:
              null == (C = K.indicators)
                ? void 0
                : C.map((e) => {
                    var T, C, $;
                    return "bar" ===
                      (null == (T = e.chartSpec) ? void 0 : T.type)
                      ? ((J = !0),
                        {
                          ...e,
                          chartSpec: updateBarStyle(e.chartSpec, Y),
                        })
                      : "common" ===
                        (null == (C = e.chartSpec) ? void 0 : C.type)
                      ? {
                          ...e,
                          chartSpec: {
                            ...e.chartSpec,
                            series:
                              null == ($ = e.chartSpec.series)
                                ? void 0
                                : $.map((e) =>
                                    "bar" === e.type
                                      ? ((J = !0), updateBarStyle(e, Y))
                                      : e
                                  ),
                          },
                        }
                      : e;
                  }),
          })
        : [ChartType.DUAL_AXIS, ChartType.BILATERAL].includes(V)
        ? (K = {
            ...K,
            series:
              null == ($ = K.series)
                ? void 0
                : $.map((e) =>
                    "bar" === e.type ? ((J = !0), updateBarStyle(e, Y)) : e
                  ),
          })
        : ((J = !0), (K = updateBarStyle(K, Y))),
      J &&
        (null == Y ? void 0 : Y.barWidth) &&
        "auto" !== Y.barWidth &&
        (K = updateAxesPadding(K)),
      K
    );
  },
  seriesPipelineWrapper = (e) => (T, C) =>
    lodash.exports.isNil(T.series)
      ? T
      : {
          ...T,
          series: T.series.map((T) => e(T, C)),
        },
  crosshair = (e, T) => {
    var C;
    const { vizData: $ } = T;
    if (isCombination($)) {
      const { displayConf: T } = $,
        F =
          (null == (C = T.combination) ? void 0 : C.layout) ===
          CombinationLayout.COLUMN
            ? "horizontal"
            : "vertical";
      return {
        ...e,
        crosshair: {
          ...e.crosshair,
          ["horizontal" === F ? "yField" : "xField"]: {
            visible: !0,
            line: {
              type: "rect",
              width: ({ width: e, height: T }, C) =>
                ("horizontal" === F ? T : e) / C.getScale().domain().length,
              style: {
                fillOpacity: 0.2,
                fill: "#b2bacf",
              },
            },
          },
          gridZIndex: 100,
        },
      };
    }
    return {
      ...e,
      crosshair: {
        ...e.crosshair,
        [isHorizontalBar($) ? "yField" : "xField"]: {
          visible: !0,
          line: {
            type: "rect",
            width: ({ width: e, height: T }, C) =>
              (isHorizontalBar($) ? T : e) / C.getScale().domain().length,
            style: {
              fillOpacity: 0.2,
              fill: "#b2bacf",
            },
          },
        },
        gridZIndex: 100,
      },
    };
  },
  calcBands = (e) => {
    const T = Object.keys(e.fieldMap).find(
        (T) => e.fieldMap[T].location === Location.DIMENSION
      ),
      C = e.datasets;
    return C[0]
      .map(
        (e, $) =>
          new Set(C.map((e) => e[$].flat(2).map((e) => e[T])).flat()).size
      )
      .reduce((e, T) => e + T, 0);
  },
  displayMode = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $, containerWidth: F, containerHeight: V } = T,
      { displayConf: Y } = $,
      { displayMode: K = DisplayMode.ADAPTIVE } = Y;
    if (K === DisplayMode.ADAPTIVE) return C;
    const J = [
        {
          orient: "bottom",
          start: 0,
          auto: !0,
          roamScroll: !0,
          filterMode: "axis",
        },
      ],
      ee = [
        {
          orient: "right",
          start: 0,
          auto: !0,
          roamScroll: !0,
          filterMode: "axis",
        },
      ],
      { chartType: te } = $,
      ie = () =>
        20 *
        (V ? lodash.exports.clamp(Math.floor(V / calcBands($) / 20), 1, 3) : 2),
      ne = () =>
        20 *
        (F ? lodash.exports.clamp(Math.floor(F / calcBands($) / 20), 1, 3) : 2);
    if (
      [ChartType.BAR, ChartType.BAR_PARALLEL, ChartType.BAR_PERCENT].includes(
        te
      )
    ) {
      const e = C.axes.filter((e) => "left" === e.orient)[0];
      (e.autoRegionSize = !0),
        K === DisplayMode.STANDARD || K === DisplayMode.FIT_WIDTH
          ? ((e.bandSize = ie()),
            isGroupedBandAxis($, $.cells[0])
              ? ((e.paddingInner = [0, 0.1]), (e.paddingOuter = [0, 0.25]))
              : ((e.paddingInner = 0.1), (e.paddingOuter = 0.25)),
            (C.scrollBar = ee),
            (C.dataZoom = []))
          : DisplayMode.FIT_HEIGHT;
    } else if (
      [
        ChartType.COLUMN,
        ChartType.COLUMN_PARALLEL,
        ChartType.COLUMN_PERCENT,
        ChartType.LINE,
        ChartType.AREA,
        ChartType.AREA_PERCENT,
        ChartType.DUAL_AXIS,
      ].includes(te)
    ) {
      const e = C.axes.filter((e) => "bottom" === e.orient)[0];
      (e.autoRegionSize = !0),
        K === DisplayMode.STANDARD
          ? ((e.bandSize = ne()),
            isGroupedBandAxis($, $.cells[0])
              ? ((e.paddingInner = [0, 0.1]), (e.paddingOuter = [0, 0.25]))
              : ((e.paddingInner = 0.1), (e.paddingOuter = 0.25)),
            (C.scrollBar = J),
            (C.dataZoom = []))
          : K === DisplayMode.FIT_WIDTH ||
            (K === DisplayMode.FIT_HEIGHT &&
              ((e.bandSize = ne()),
              isGroupedBandAxis($, $.cells[0])
                ? ((e.paddingInner = [0, 0.1]), (e.paddingOuter = [0, 0.25]))
                : ((e.paddingInner = 0.1), (e.paddingOuter = 0.25)),
              (C.scrollBar = J),
              (C.dataZoom = [])));
    }
    return C;
  },
  tableChartDisplayMode = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $ } = T,
      { displayConf: F } = $,
      { displayMode: V = DisplayMode.ADAPTIVE } = F;
    if (!isTableChart($)) return C;
    if (V === DisplayMode.ADAPTIVE) return C;
    return (
      V === DisplayMode.STANDARD
        ? ((C.widthMode = "standard"),
          (C.heightMode = "standard"),
          (C.defaultRowHeight = 200),
          (C.defaultColWidth = 200),
          (C.defaultHeaderRowHeight = ["auto"]))
        : V === DisplayMode.FIT_WIDTH
        ? ((C.widthMode = "adaptive"),
          (C.heightMode = "standard"),
          (C.defaultRowHeight = 200),
          (C.defaultHeaderRowHeight = ["auto"]))
        : V === DisplayMode.FIT_HEIGHT
        ? ((C.heightMode = "adaptive"),
          (C.widthMode = "standard"),
          (C.defaultColWidth = 200))
        : V === DisplayMode.ADAPTIVE &&
          ((C.heightMode = "adaptive"), (C.widthMode = "adaptive")),
      C
    );
  },
  buildInteractive = (e) => (T, C) => e.reduce((e, T) => T(e, C), T),
  common = (e) => ({
    ...e,
    hover: {
      enable: !0,
    },
    select: {
      enable: !0,
    },
  }),
  buildHover = (e) => {
    var T, C, $;
    const F = {
      cursor: "pointer",
    };
    return e
      ? {
          ...F,
          fillOpacity: null != (T = e.fillOpacity) ? T : 0.8,
          stroke: null != (C = e.strokeColor) ? C : "#58595B",
          lineWidth: null != ($ = e.strokeWidth) ? $ : 1,
          zIndex: 500,
        }
      : {
          ...F,
          fillOpacity: 0.8,
          stroke: "#58595B",
          lineWidth: 1,
          zIndex: 500,
        };
  },
  buildSelected = (e) => {
    const T = {
      cursor: "pointer",
    };
    return e
      ? {
          ...T,
          fillOpacity: 1,
          stroke: e.strokeColor,
          lineWidth: e.strokeWidth,
        }
      : {
          ...T,
          fillOpacity: 1,
          stroke: "#58595B",
          lineWidth: 1,
        };
  },
  buildSelectedReverse = () => ({
    fillOpacity: 0.3,
    lineWidth: 0.3,
  }),
  bar$2 = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      { interactiveStyle: F } = $,
      V = buildHover(F),
      Y = buildSelected(F),
      K = buildSelectedReverse();
    return {
      ...e,
      bar: {
        ...C.bar,
        state: {
          hover: {
            ...V,
          },
          selected: {
            ...Y,
          },
          selected_reverse: {
            ...K,
          },
        },
      },
    };
  },
  barInteractive = buildInteractive([common, bar$2]),
  brush = (e, T) => {
    const { vizData: C } = T;
    return isTableChart(C)
      ? e
      : isLineLikeChart(C.chartType)
      ? {
          ...e,
          brush: {
            inBrush: {
              fillOpacity: 1,
              strokeOpacity: 1,
              colorAlpha: 1,
            },
            outOfBrush: {
              colorAlpha: 0.2,
              fillOpacity: 0.3,
            },
          },
        }
      : {
          ...e,
          brush: {
            inBrush: {
              fillOpacity: 1,
              stroke: "#58595B",
              lineWidth: 1,
              strokeOpacity: 1,
              colorAlpha: 1,
            },
            outOfBrush: {
              colorAlpha: 0.2,
              fillOpacity: 0.3,
              lineWidth: 0.3,
            },
          },
        };
  },
  columnInteractive = buildInteractive([common, bar$2]),
  point$8 = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      { interactiveStyle: F } = $,
      V = buildHover(F),
      Y = buildSelected(F),
      K = buildSelectedReverse();
    return {
      ...e,
      point: {
        ...C.point,
        state: {
          hover: {
            ...V,
          },
          selected: {
            ...Y,
          },
          selected_reverse: {
            ...K,
          },
        },
      },
    };
  },
  pointInteractive = buildInteractive([common, point$8]),
  histogramInteractive = (e, T) => {
    let C = e.series.find((e) => e.id === MAIN_SERIES_ID);
    C && (C = barInteractive(C, T));
    let $ = e.series.find((e) => e.id === SUB_SERIES_ID);
    return (
      $ && ($ = pointInteractive($, T)),
      {
        ...e,
        series: [C, $].filter(Boolean),
      }
    );
  },
  map$1 = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      { interactiveStyle: F } = $,
      V = buildHover(),
      Y = buildSelected(F),
      K = buildSelectedReverse();
    return {
      ...e,
      area: {
        ...C.area,
        state: {
          hover: {
            ...V,
          },
          selected: {
            ...Y,
          },
          selected_reverse: {
            ...K,
          },
        },
      },
    };
  },
  mapInteractive = buildInteractive([common, map$1]),
  polar$1 = (e, { vizData: T }) => {
    var C, $;
    const F = {
        ...e,
      },
      { displayConf: V, chartType: Y } = T,
      { interactiveStyle: K } = V,
      J = buildHover(K),
      ee = buildSelected(K),
      te = buildSelectedReverse();
    return Y === ChartType.ROSE
      ? {
          ...e,
          label: {
            ...(null != (C = e.label) ? C : {}),
            interactive: !1,
          },
          rose: {
            ...F.pie,
            state: {
              hover: {
                ...J,
              },
              selected: {
                ...ee,
              },
              selected_reverse: {
                ...te,
              },
            },
          },
        }
      : {
          ...e,
          label: {
            ...(null != ($ = e.label) ? $ : {}),
            interactive: !1,
          },
          pie: {
            ...F.pie,
            state: {
              hover: {
                ...J,
                outerRadius: Math.min(1, e.outerRadius + 0.05),
              },
              selected: {
                ...ee,
                outerRadius: Math.min(1, e.outerRadius + 0.05),
              },
              selected_reverse: {
                ...te,
              },
            },
          },
        };
  },
  polarInteractive = buildInteractive([common, polar$1]),
  sankey$1 = (e, { vizData: T }) => {
    var C, $;
    const { displayConf: F } = T,
      { interactiveStyle: V } = F,
      Y = buildHover(V),
      K = buildSelected(V);
    return {
      ...e,
      emphasis: {
        enable: !0,
        effect: "related",
      },
      link: {
        ...(null != (C = e.link) ? C : {}),
        state: {
          hover: {
            ...Y,
            lineWidth: 0,
          },
          selected: {
            ...K,
          },
          blur: {
            fillOpacity: 0.025,
          },
        },
      },
      node: {
        ...(null != ($ = e.node) ? $ : {}),
        state: {
          hover: {
            ...Y,
          },
          selected: {
            ...K,
          },
          blur: {
            fillOpacity: 0.1,
          },
        },
      },
    };
  },
  sankeyInteractive = buildInteractive([common, sankey$1]),
  scatter$1 = (e, { vizData: T }) => {
    var C;
    const $ = {
        ...e,
      },
      { displayConf: F } = T,
      { interactiveStyle: V } = F,
      Y = buildHover(V);
    return {
      ...e,
      point: {
        ...$.point,
        state: {
          ...(null != (C = $.point.state) ? C : {}),
          hover: {
            ...Y,
          },
        },
      },
    };
  },
  scatterInteractive = buildInteractive([common, scatter$1]),
  interactiveMap = {
    scatter: scatterInteractive,
    map: mapInteractive,
  },
  multipleInteractive = (e, T) => {
    const C = {
      ...e,
    };
    if (C.series) {
      const e = C.series.map((e) => interactiveMap[e.type](e, T));
      return {
        ...C,
        series: e,
      };
    }
    return C;
  },
  invalidType = (e, { vizData: T }) => {
    var C;
    const { specialValue: $ } = T.displayConf,
      F =
        null != (C = null == $ ? void 0 : $.renderInvalid)
          ? C
          : RenderInvalid.BREAK;
    return {
      ...e,
      invalidType: INVALID_TYPE_MAP[F],
    };
  },
  symbolConfigMap = {
    [LineSymbol.NONE]: null,
    [LineSymbol.EMPTYCIRCLE]: {
      pointShape: "circle",
      hollowPoint: !0,
    },
    [LineSymbol.CIRCLE]: {
      pointShape: "circle",
      hollowPoint: !1,
    },
    [LineSymbol.RECT]: {
      pointShape: "square",
      hollowPoint: !1,
    },
    [LineSymbol.DIAMOND]: {
      pointShape: "diamond",
      hollowPoint: !1,
    },
  },
  lineStyleConfigMap = {
    [LineStyleType.SOLID]: null,
    [LineStyleType.DASHED]: {
      lineStrokeDash: [4, 2],
    },
    [LineStyleType.DOTTED]: {
      lineStrokeDash: [1, 1],
    },
  },
  createVisual = (e, T, C) => {
    var $, F, V;
    const { cells: Y, fieldMap: K } = e,
      J = null == (F = null == ($ = Y[0]) ? void 0 : $.color) ? void 0 : F[0];
    if (!Array.isArray(T)) {
      const e = null == (V = K[J]) ? void 0 : V.domain;
      return {
        type: "ordinal",
        field: J,
        range: [C(T)],
        domain: e,
      };
    }
    const ee = [],
      te = [];
    return (
      T.forEach((e) => {
        ee.push(e.title), te.push(C(e.value, e.title));
      }),
      {
        type: "ordinal",
        field: J,
        range: te,
        domain: ee,
      }
    );
  },
  createCurveTypeScale = (e, T, C) =>
    isRadarChart(e)
      ? createVisual(e, T, () => "linear")
      : createVisual(e, T, (e) =>
          e ? ("horizontal" === C ? "monotoneY" : "monotoneX") : "linear"
        ),
  createLineWidthScale = (e, T) => createVisual(e, T, (e) => e),
  createLineDashScale = (e, T, C) =>
    createVisual(e, T, (e, T) => {
      const $ = lineStyleConfigMap[e];
      return $
        ? $.lineStrokeDash.map((e) => {
            return (
              e *
              (null == ($ = null == (T = C) ? void 0 : T.range) ? void 0 : $[0])
            );
            var T, $;
          })
        : [0, 0];
    }),
  createFillScale = (e, T, C) => {
    var $, F, V, Y, K, J, ee, te;
    if (!Array.isArray(C))
      return null === symbolConfigMap[C] ||
        !0 === (null == ($ = symbolConfigMap[C]) ? void 0 : $.hollowPoint)
        ? "white"
        : e.color;
    const { cells: ie, fieldMap: ne } = T,
      re = null == (V = null == (F = ie[0]) ? void 0 : F.color) ? void 0 : V[0],
      ae = null == (Y = ne[re]) ? void 0 : Y.domain,
      oe = null != (J = null == (K = e.color) ? void 0 : K.range) ? J : [],
      se =
        null != (te = null == (ee = e.color) ? void 0 : ee.specified) ? te : {},
      le = C.reduce((e, T, C) => {
        const $ = ae[C];
        return se[$] ? (e[C] = se[$]) : (e[C] = oe[C]), e;
      }, {}),
      de = C.reduce((e, T, C) => {
        const $ = ae[C],
          F = symbolConfigMap[T.value];
        return (
          (e[$] =
            null === F || !0 === (null == F ? void 0 : F.hollowPoint)
              ? "white"
              : le[C]),
          e
        );
      }, {});
    return {
      type: "ordinal",
      field: re,
      range: oe,
      domain: ae,
      specified: de,
    };
  },
  lineStyle = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae;
    const oe = {
        ...e,
      },
      { vizData: se } = T,
      { displayConf: le } = se,
      { direction: de = "vertical" } = e;
    if (lodash.exports.isNil(le.lineStyle)) return oe;
    const {
        smooth: ce,
        lineWidth: ue,
        lineStyle: he,
        symbol: pe,
        symbolSize: ge,
      } = le.lineStyle,
      fe = (e, T) =>
        Array.isArray(e)
          ? getColorItems(se).map((C) => {
              var $;
              const F = e.find((e) => e.title === C);
              return {
                title: C,
                value:
                  null != ($ = null == F ? void 0 : F.value)
                    ? $
                    : defaultLineStyle[T],
              };
            }) || []
          : e,
      me = fe(ce, "smooth"),
      ye = fe(ue, "lineWidth"),
      be = fe(he, "lineStyle"),
      ve = fe(pe, "symbol"),
      Te = fe(ge, "symbolSize"),
      _e = createCurveTypeScale(se, me, de),
      Ce = createLineWidthScale(se, ye),
      Ae = createLineDashScale(se, be, Ce);
    (oe.line = {
      ...(null != (C = oe.line) ? C : {}),
      style: {
        ...(null != (F = null == ($ = oe.line) ? void 0 : $.style) ? F : {}),
        curveType: _e,
        lineWidth: Ce,
        lineDash: Ae,
      },
    }),
      (oe.area = {
        ...(null != (V = oe.area) ? V : {}),
        style: {
          ...(null != (K = null == (Y = oe.area) ? void 0 : Y.style) ? K : {}),
          curveType: _e,
        },
      });
    const xe = createVisual(se, ve, (e) => {
        const T = symbolConfigMap[e];
        return (null == T ? void 0 : T.pointShape) || "circle";
      }),
      Se = createVisual(se, Te, (e) => chartSpaceSizeToVChartSize(e)),
      Re = createVisual(se, ve, (e) => (symbolConfigMap[e] ? 1 : 0)),
      Me = createVisual(se, ve, (e) => (symbolConfigMap[e] ? 1 : 0)),
      Pe = createFillScale(oe, se, ve);
    return (
      (oe.point = {
        ...(null != (J = oe.point) ? J : {}),
        style: {
          ...(null != (te = null == (ee = oe.point) ? void 0 : ee.style)
            ? te
            : {}),
          shape: xe,
          size: Se,
          fill: Pe,
          stroke: null != (ie = le.lineStyle.symbolStrokeColor) ? ie : oe.color,
          strokeOpacity: Re,
          fillOpacity: Me,
        },
        state: {
          hover: {
            ...(null !=
            (ae =
              null == (re = null == (ne = oe.symbol) ? void 0 : ne.state)
                ? void 0
                : re.hover)
              ? ae
              : {}),
            lineWidth: 2,
            fillOpacity: 1,
            strokeOpacity: 1,
            scaleX: 1.5,
            scaleY: 1.5,
          },
        },
      }),
      oe
    );
  },
  multipleLineStyle = (e, T) => {
    const C = e.series.map((C) => {
      const $ = lineStyle(C, T);
      return ($.point.style.stroke = e.color), $;
    });
    return {
      ...e,
      series: C,
    };
  },
  backgroundColor = (e) => ({
    ...e,
    background: "rgba(255, 255, 255, 0)",
  }),
  regionClip = (e, T) => {
    if (isSankey(T.vizData)) return e;
    if (e.region) {
      const T = [...e.region];
      return (
        (T[0] = {
          clip: !0,
          ...T[0],
        }),
        {
          ...e,
          region: T,
        }
      );
    }
    return {
      ...e,
      region: [
        {
          clip: !0,
        },
      ],
    };
  },
  tooltip = (e) => ({
    ...e,
    tooltip: {
      handler: {},
    },
  }),
  combinationChartTypeMap = {
    [CombinationChartType.COLUMN]: "bar",
    [CombinationChartType.COLUMN_PERCENT]: "bar",
    [CombinationChartType.COLUMN_PARALLEL]: "bar",
    [CombinationChartType.LINE]: "line",
    [CombinationChartType.AREA]: "area",
    [CombinationChartType.AREA_PERCENT]: "area",
    [CombinationChartType.DUAL_AXIS]: "dualAxis",
  },
  dualAxisChartTypeMap$1 = {
    [DualAxisChartType.COLUMN]: "bar",
    [DualAxisChartType.LINE]: "line",
    [DualAxisChartType.AREA]: "area",
    [DualAxisChartType.COLUMN_PARALLEL]: "bar",
  },
  genIndicatorKey = (e) => `INDICATOR_KEY_${e}`,
  combinationIndicators = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { cells: V, fieldMap: Y } = F,
      { displayConf: K } = F,
      J =
        (null == (C = K.combination) ? void 0 : C.layout) ===
        CombinationLayout.COLUMN
          ? "horizontal"
          : "vertical";
    return {
      ...e,
      axes: [...(null != ($ = e.axes) ? $ : [])],
      indicatorsAsCol: "vertical" !== J,
      indicators: V.map((C, $) => ({
        indicatorKey: genIndicatorKey($),
        width: "auto",
        title: "",
        cellType: "chart",
        chartModule: "vchart",
        chartSpec: createChartSpec(e, T, C, $, K, Y),
      })),
    };
  },
  createChartSpec = (e, T, C, $, F, V) => {
    const Y = F.combination.list[$],
      { chartType: K } = Y;
    return {
      ...(K === CombinationChartType.DUAL_AXIS
        ? createDualAxisChartSpec(e, T, C, $, F, V)
        : createCommonChartSpec(e, T, C, $, F, V)),
    };
  },
  createDualAxisChartSpec = (e, T, C, $, F, V) => {
    var Y, K, J, ee, te, ie, ne, re, ae, oe, se, le, de;
    const { data: ce } = e,
      ue = F.combination.list[$],
      { dualAxis: he, axisMeasure: pe = [] } = ue,
      ge =
        (null == (Y = F.combination) ? void 0 : Y.layout) ===
        CombinationLayout.COLUMN
          ? "horizontal"
          : "vertical",
      fe = null == (K = null == C ? void 0 : C.color) ? void 0 : K[0],
      me = {
        ...ce[0].fields,
      };
    me[
      null != (ee = null == (J = C.x) ? void 0 : J[0]) ? ee : ""
    ].sortIndex = 0;
    const ye = e.data[0].id,
      be = [null == (te = C.x) ? void 0 : te[0]],
      ve = [null == (ie = C.x) ? void 0 : ie[0]],
      Te = {
        type: dualAxisChartTypeMap$1[he.main],
        yField:
          "vertical" === ge
            ? null == (ne = null == C ? void 0 : C.y)
              ? void 0
              : ne[0]
            : be,
        xField:
          "vertical" === ge
            ? be
            : null == (re = null == C ? void 0 : C.y)
            ? void 0
            : re[0],
        seriesField: fe,
        direction: ge,
        id: MAIN_SERIES_ID,
        data: {
          id: `main-${ye}`,
          fields: me,
        },
        markOverlap: !0,
      },
      _e = {
        type: dualAxisChartTypeMap$1[he.sub],
        yField:
          "vertical" === ge
            ? null == (ae = null == C ? void 0 : C.y)
              ? void 0
              : ae[1]
            : ve,
        xField:
          "vertical" === ge
            ? ve
            : null == (oe = null == C ? void 0 : C.y)
            ? void 0
            : oe[1],
        seriesField: fe,
        direction: ge,
        id: SUB_SERIES_ID,
        data: {
          sortIndex: $,
          id: `sub-${ye}`,
          fields: me,
        },
        markOverlap: !0,
      },
      Ce = (null != pe ? pe : [])
        .map(
          (e) =>
            e.domainType !== AxisDomainType.AUTO_MIN &&
            e.ratioType === AxisRatioType.LINEAR
        )
        .reduce((e, T) => e && T, !0),
      Ae =
        "column" === F.combination.layout
          ? ["bottom", "top"]
          : ["left", "right"],
      xe = `main-${$}`,
      Se = `sub-${$}`,
      Re = [
        axisMeasure(pe[0], Ae[0], {
          spec: e,
          id: xe,
          sync: Ce
            ? {
                axisId: Se,
                zeroAlign: Ce,
                tickAlign: !1,
              }
            : void 0,
          hover: !1,
          yField: null == (se = null == C ? void 0 : C.y) ? void 0 : se[0],
          index: $,
          innerOffset: calculateInnerOffset(
            T.vizData,
            [DualAxisChartType.AREA, DualAxisChartType.LINE].includes(he.main),
            "horizontal" === ge ? ["right"] : ["top"]
          ),
        }),
        axisMeasure(
          {
            ...pe[1],
            grid: !1,
          },
          Ae[1],
          {
            spec: e,
            id: Se,
            hover: !1,
            yField: null == (le = null == C ? void 0 : C.y) ? void 0 : le[1],
            index: $,
            innerOffset: calculateInnerOffset(
              T.vizData,
              [DualAxisChartType.AREA, DualAxisChartType.LINE].includes(he.sub),
              "horizontal" === ge ? ["right"] : ["top"]
            ),
          }
        ),
      ];
    Re.forEach((e, T) => {
      var C, $;
      const F =
        null != (C = null == ue ? void 0 : ue[1 !== T ? "main" : "sub"])
          ? C
          : [];
      if (
        "" === (null == ($ = null == e ? void 0 : e.title) ? void 0 : $.text) &&
        (null == F ? void 0 : F.length) > 0
      ) {
        const T = F.map((e) => V[`${e}`].alias).join(" & ");
        e.title.text = T;
      }
    });
    const Me = {
      type: "common",
      axes: Re,
      direction: ge,
      stackInverse: "horizontal" !== ge,
      series: (null == (de = null == C ? void 0 : C.y) ? void 0 : de[1])
        ? [Te, _e]
        : [Te],
    };
    return [
      tooltip,
      color,
      crosshair,
      backgroundColor,
      regionClip,
      combinationStack,
      seriesPipelineWrapper(displayMode),
      seriesPipelineWrapper(lineStyle),
      seriesPipelineWrapper(invalidType),
      seriesPipelineWrapper(barInteractive),
      seriesPipelineWrapper(animation),
    ].reduce(
      (e, C) =>
        C(e, {
          ...T,
          payload: {
            dualAxis: he,
          },
        }),
      Me
    );
  },
  createCommonChartSpec = (e, T, C, $, F, V) => {
    var Y, K, J, ee, te, ie, ne;
    const { data: re } = e,
      ae =
        (null == (Y = F.combination) ? void 0 : Y.layout) ===
        CombinationLayout.COLUMN
          ? "horizontal"
          : "vertical",
      oe = null == (K = null == C ? void 0 : C.color) ? void 0 : K[0],
      se = F.combination.list[$],
      { chartType: le, axisMeasure: de = [] } = se,
      ce = combinationChartTypeMap[le],
      ue = {
        ...re[0].fields,
      };
    ue[
      null != (ee = null == (J = C.x) ? void 0 : J[0]) ? ee : ""
    ].sortIndex = 0;
    const he = e.data[0].id,
      pe = [null == (te = C.x) ? void 0 : te[0]],
      ge = [null == (ie = null == C ? void 0 : C.y) ? void 0 : ie[0]],
      fe = "column" === F.combination.layout ? "bottom" : "left",
      me = [
        axisMeasure(de[0], fe, {
          spec: e,
          id: String($),
          hover: !1,
          yField: null == (ne = null == C ? void 0 : C.y) ? void 0 : ne[0],
          index: $,
          innerOffset: calculateInnerOffset(
            T.vizData,
            [
              CombinationChartType.AREA,
              CombinationChartType.AREA_PERCENT,
              CombinationChartType.LINE,
            ].includes(le),
            "horizontal" === ae ? ["right"] : ["top"]
          ),
        }),
      ];
    me.forEach((e, T) => {
      var C, $;
      const F =
        null != (C = null == se ? void 0 : se[1 !== T ? "main" : "sub"])
          ? C
          : [];
      if (
        "" === (null == ($ = null == e ? void 0 : e.title) ? void 0 : $.text) &&
        (null == F ? void 0 : F.length) > 0
      ) {
        const T = F.map((e) => V[`${e}`].alias).join(" & ");
        e.title.text = T;
      }
    });
    const ye = {
      type: ce,
      xField: "vertical" === ae ? pe : ge,
      yField: "vertical" === ae ? ge : pe,
      direction: ae,
      seriesField: oe,
      axes: me,
      data: {
        id: he,
        fields: ue,
      },
      markOverlap: !0,
      percent: [
        CombinationChartType.COLUMN_PERCENT,
        CombinationChartType.AREA_PERCENT,
      ].includes(le),
    };
    return [
      (e, T) => stack(e, T, le),
      displayMode,
      backgroundColor,
      regionClip,
      color,
      tooltip,
      crosshair,
      lineStyle,
      invalidType,
      barInteractive,
      animation,
    ].reduce((e, C) => C(e, T), ye);
  },
  combinationRecords = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { datasets: $ } = T;
    return {
      ...C,
      records: $.flat(1).reduce(
        (e, T) => (
          T.forEach((T, C) => {
            const $ = genIndicatorKey(C);
            e[$] || (e[$] = []), e[$].push(...T);
          }),
          e
        ),
        {}
      ),
    };
  },
  cartesian = (e, { vizData: T }) => {
    var C, $;
    const F = T.cells[0],
      V = {
        ...e,
        xField: F.x,
        yField: [null == (C = null == F ? void 0 : F.y) ? void 0 : C[0]],
        direction: "vertical",
        sortDataByAxis: !0,
      };
    return (
      (null == ($ = F.color) ? void 0 : $[0]) && (V.seriesField = F.color[0]), V
    );
  },
  buildDefaultHeaderColWidth = (e, T) => {
    const { vizData: C } = T;
    return {
      ...e,
      defaultHeaderColWidth: getWidth(C),
    };
  },
  getWidth = (e) => {
    const { fieldMap: T } = e,
      C = Object.values(T).filter((e) => e.location === Location.ROW).length;
    if (!lodash.exports.isNil(e.rowPivotTree)) {
      return [...new Array(C).fill(80), "auto"];
    }
    return ["auto"];
  },
  buildDimensions = (e, T) => {
    var C;
    return (null != (C = e.locationMap[T]) ? C : []).map((T) => ({
      dimensionKey: T,
      title: e.fieldMap[T].alias,
    }));
  },
  buildIndicators = (e) => {
    const { axes: T, data: C } = e;
    if (e.indicators) return e.indicators;
    return [
      {
        indicatorKey: "10002",
        title: "",
        width: "auto",
        cellType: "chart",
        chartModule: "vchart",
        style: {
          padding: [1, 1, 0, 1],
        },
        chartSpec: {
          ...e,
          legends: void 0,
          axes: T.map((e) => ({
            ...e,
            hover: !1,
          })),
          data: {
            id: C[0].id,
            fields: C[0].fields,
          },
        },
      },
    ];
  },
  buildColTitle = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $,
      { pivot: V } = F,
      { colTitleEnable: Y } = V;
    if (Y) {
      const T = {
        text:
          null == (C = e.columns) ? void 0 : C.map((e) => e.title).join("/"),
        align: "center",
        orient: "top",
        padding: [0, 0, 0, 0],
        textStyle: {
          fontSize: F.pivot.titleSize,
          fill: F.pivot.titleColor,
          fontWeight: "bold",
        },
      };
      return {
        ...e,
        title: T,
      };
    }
    return e;
  },
  buildRowTitle = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $,
      { pivot: V } = F,
      { rowTitleEnable: Y } = V,
      K = Y ? "row" : "none";
    return {
      ...e,
      corner: {
        ...(null != (C = e.corner) ? C : {}),
        titleOnDimension: K,
      },
    };
  },
  initCombination = (e, T) => {
    const C = {
      ...e,
      widthMode: "adaptive",
      heightMode: "adaptive",
      rowTree: [],
      columnTree: [],
      rows: [],
      columns: [],
      defaultHeaderRowHeight: "auto",
      indicatorTitle: " ",
      autoWrapText: !0,
      eventOptions: {
        preventDefaultContextMenu: !1,
      },
    };
    return [buildRowTitle, buildColTitle, buildDefaultHeaderColWidth].reduce(
      (e, C) => C(e, T),
      C
    );
  },
  initFunnel = (e, { vizData: T }) => {
    const C = T.displayConf,
      { funnel: $ } = C,
      F = T.cells[0];
    if (!F.size || !F.color) return;
    const V = String(F.size[0]);
    return {
      ...e,
      padding: 0,
      shape: "rect",
      categoryField: String(F.color[0]),
      valueField: V,
      funnelOrient: $.orient === FunnelOrient.Vertical ? "top" : "left",
      maxSize: "68%",
    };
  },
  initHistogram = (e, { vizData: T }) => {
    const C = {
        ...e,
        region: [
          {
            clip: !0,
          },
        ],
      },
      $ = T.displayConf,
      F = Object.keys(T.fieldMap).find(
        (e) => T.fieldMap[e].location === Location.DIMENSION
      ),
      V = {
        id: MAIN_SERIES_ID,
        type: "bar",
        xField: `${F}_interval_0`,
        x2Field: `${F}_interval_1`,
        yField: `${F}_value`,
      },
      Y = {
        id: SUB_SERIES_ID,
        type: "line",
        xField: `${F}_interval`,
        yField: `${F}_ratio`,
      };
    return "value" === $.histogram.showType
      ? {
          ...C,
          series: [V],
        }
      : "ratio" === $.histogram.showType
      ? {
          ...C,
          series: [Y],
        }
      : {
          ...C,
          series: [V, Y],
        };
  },
  getGeoJsonUrl = (e, T, C) => {
    if (e.other && e.other.geoUrl) {
      let $ = `&scope=${T}`;
      return C && T && ($ += `&filter=${C}`), `${e.other.geoUrl}${$}`;
    }
  },
  transformNameMap = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      V = Object.keys(F.fieldMap).find(
        (e) => F.fieldMap[e].location === Location.DIMENSION
      ),
      Y = F.fieldMap[V],
      K = (
        null !=
        ($ =
          null == (C = null == Y ? void 0 : Y.geoInfo) ? void 0 : C.geoMapList)
          ? $
          : []
      ).reduce((e, { geoId: T, geoValue: C }) => (e.set(C, T), e), new Map()),
      J = new Map(),
      ee = F.datasets.flat(3);
    for (let te = ee.length - 1; te >= 0; te--) {
      const e = ee[te][V],
        T = K.get(e);
      J.has(T) || lodash.exports.isNil(T) || J.set(T, e);
    }
    return Object.fromEntries(J);
  },
  initMap = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae;
    const { vizData: oe } = T,
      se = {
        ...e,
      },
      le = oe.cells[0],
      de = Object.keys(oe.fieldMap).find(
        (e) => oe.fieldMap[e].location === Location.DIMENSION
      ),
      ce = oe.fieldMap[de],
      ue =
        null !=
        ($ =
          null == (C = null == ce ? void 0 : ce.geoInfo)
            ? void 0
            : C.geoMapList)
          ? $
          : [],
      he =
        null !=
        (V =
          null == (F = null == ce ? void 0 : ce.geoInfo) ? void 0 : F.geoScope)
          ? V
          : GeoScope.None,
      pe =
        null == (Y = null == ce ? void 0 : ce.geoInfo) ? void 0 : Y.geoFilter;
    (se.padding = 0),
      (se.nameField = null == (K = le.group) ? void 0 : K[0]),
      (se.valueField = null == (J = le.value) ? void 0 : J[0]),
      (se.nameProperty = "id"),
      (se.centroidProperty = "centroid"),
      (se.url = getGeoJsonUrl(oe, he, pe)),
      (se.map = se.url),
      (se.area = {
        ...(null != (ee = se.area) ? ee : {}),
        style: {
          ...(null != (ie = null == (te = se.area) ? void 0 : te.style)
            ? ie
            : {}),
          strokeOpacity: 0.8,
          stroke: "#58595B",
          lineWidth: 1,
        },
      }),
      (se.mapOption = pe
        ? {
            type: "geojson",
          }
        : {
            type: "topojson",
            object: "object",
          });
    const ge =
      null !=
      (ne = Object.keys(oe.fieldMap).filter(
        (e) => oe.fieldMap[e].location === Location.COLOR
      ))
        ? ne
        : [];
    return (
      ge.length > 0 &&
        (null == (re = oe.fieldMap[ge[0]]) ? void 0 : re.role) ===
          Role.DIMENSION &&
        (se.seriesField = null == (ae = le.color) ? void 0 : ae[0]),
      lodash.exports.isEmpty(ue) || (se.nameMap = transformNameMap(e, T)),
      se
    );
  },
  initScatterMap = (e, T) => {
    var C, $, F, V;
    const Y = {
        ...e,
      },
      { vizData: K } = T,
      J = K.cells[0],
      ee = initMap(
        {
          type: "map",
          area: {
            style: {
              fill: "#f3f3f3",
            },
          },
        },
        T
      ),
      te = {
        type: "scatter",
        padding: 0,
        id: SCATTER_MAP_SCATTER_SERIES_ID,
        xField: null == (C = J.group) ? void 0 : C[0],
        yField: null == ($ = J.size) ? void 0 : $[0],
        seriesField: null == (F = J.color) ? void 0 : F[0],
        sizeField: null == (V = J.size) ? void 0 : V[0],
      };
    return (
      (Y.padding = 0),
      (Y.series = [ee, te]),
      (Y.map = ee.map),
      (Y.url = ee.url),
      (Y.mapOption = ee.mapOption),
      Y
    );
  },
  initMultiSeriesChart = (e, { vizData: T }) => {
    var C, $, F, V, Y, K, J, ee, te, ie;
    const { chartType: ne } = T,
      re = T.cells[0],
      ae = !(
        ne === ChartType.DUAL_AXIS &&
        void 0 === (null == (C = re.y) ? void 0 : C[1])
      ),
      oe = {
        ...e,
        type: "common",
        region: [
          {
            clip: !0,
          },
        ],
        series: [
          {
            id: MAIN_SERIES_ID,
            type: "bar",
          },
          ae
            ? {
                id: SUB_SERIES_ID,
                type: "bar",
              }
            : void 0,
        ].filter(Boolean),
      },
      se = T.displayConf,
      le = oe.series.find((e) => e.id === MAIN_SERIES_ID),
      de = oe.series.find((e) => e.id === SUB_SERIES_ID);
    if (ne === ChartType.DUAL_AXIS) {
      const e = se.dualAxis;
      (le.type = dualAxisChartTypeMap[e.main]),
        (le.xField = null == ($ = re.x) ? void 0 : $[0]),
        (le.yField = null == (F = re.y) ? void 0 : F[0]),
        (le.zIndex = 200),
        de &&
          ((de.type = dualAxisChartTypeMap[e.sub]),
          (de.xField = null == (V = re.x) ? void 0 : V[0]),
          (de.yField = null == (Y = re.y) ? void 0 : Y[1]),
          (de.zIndex = 300));
    } else
      ne === ChartType.BILATERAL &&
        ((le.type = "bar"),
        (le.yField = null == (K = re.x) ? void 0 : K[0]),
        (le.xField = null == (J = re.y) ? void 0 : J[0]),
        de &&
          ((de.type = "bar"),
          (de.yField = null == (ee = re.x) ? void 0 : ee[0]),
          (de.xField = null == (te = re.y) ? void 0 : te[1])));
    return (
      (null == (ie = re.color) ? void 0 : ie[0]) &&
        oe.series.forEach((e) => {
          var T;
          e.seriesField = null == (T = re.color) ? void 0 : T[0];
        }),
      {
        ...oe,
      }
    );
  },
  dualAxisChartTypeMap = {
    [DualAxisChartType.COLUMN]: "bar",
    [DualAxisChartType.LINE]: "line",
    [DualAxisChartType.AREA]: "area",
    [DualAxisChartType.COLUMN_PARALLEL]: "bar",
  },
  polar = (e, { vizData: T }) => {
    var C, $, F;
    const { chartType: V } = T,
      Y = T.cells[0],
      K = String(
        null != (F = null == (C = Y.angle) ? void 0 : C[0])
          ? F
          : null == ($ = Y.radius)
          ? void 0
          : $[0]
      ),
      J = generateCategoryField(T);
    return {
      ...e,
      type: V === ChartType.ROSE ? "rose" : "pie",
      categoryField: J,
      valueField: K,
      seriesField: V === ChartType.ROSE ? J : void 0,
      padding: 0,
    };
  },
  generateCategoryField = (e) => {
    var T, C, $, F, V;
    const { fieldMap: Y } = e,
      K = e.cells[0];
    return K.color &&
      (null == (T = Y[K.color[0]]) ? void 0 : T.role) === Role.DIMENSION &&
      K.color[0] !== (null == (C = K.group) ? void 0 : C[0])
      ? K.color[0]
      : String(
          null != (V = null == ($ = K.group) ? void 0 : $[0])
            ? V
            : null == (F = K.color)
            ? void 0
            : F[0]
        );
  },
  initRadar = (e, { vizData: T }) => {
    var C, $;
    const F = T.cells[0];
    return {
      ...e,
      outerRadius: 0.8,
      padding: 0,
      categoryField: String(
        void 0 !== F.x ? F.x[0] : null == (C = F.color) ? void 0 : C[0]
      ),
      valueField: String(
        void 0 !== F.y
          ? F.y[0]
          : null == ($ = null == F ? void 0 : F.angle)
          ? void 0
          : $[0]
      ),
      seriesField: getSeriesField(T),
    };
  },
  getSeriesField = (e) => {
    var T;
    const C = e.cells[0];
    let $;
    return (
      (null == (T = C.color) ? void 0 : T[0]) && ($ = C.color[0]),
      void 0 === C.x && ($ = void 0),
      $
    );
  },
  initScatter = (e, { vizData: T }) => {
    var C, $;
    const F = T.cells[0];
    return {
      ...e,
      type: "scatter",
      xField: null == (C = F.x) ? void 0 : C[0],
      yField: null == ($ = null == F ? void 0 : F.y) ? void 0 : $[0],
      invalidType: "ignore",
      region: [
        {
          clip: !0,
        },
      ],
    };
  },
  initWordCloud = (e, { vizData: T }) => {
    var C, $;
    const F = T.displayConf,
      V = T.cells[0],
      Y = {
        ...e,
        nameField: null == (C = null == V ? void 0 : V.group) ? void 0 : C[0],
        valueField: null == ($ = null == V ? void 0 : V.size) ? void 0 : $[0],
        fontSizeRange: [10, 50],
        fontWeightRange: [400, 400],
        random: !1,
        wordCloudConfig: {
          zoomToFit: {
            shrink: !0,
            enlarge: !0,
            fontSizeLimitMin: 5,
          },
        },
        word: {
          padding: 0,
        },
        padding: 0,
      };
    F.shape && (Y.maskShape = F.shape);
    const K = getFields(T, Location.DIMENSION, isRenderField)[0],
      J = getFieldFormat(K, T),
      ee = createFormatter(J);
    return (
      J &&
        (Y.word = {
          ...Y.word,
          formatMethod: (e) => {
            var T, C;
            const $ =
              e[
                null !=
                (C = null == (T = null == V ? void 0 : V.color) ? void 0 : T[0])
                  ? C
                  : ""
              ];
            return ee($);
          },
        }),
      Y
    );
  },
  datasets = (e, { vizData: T }) => {
    var C, $;
    const { fieldMap: F, datasets: V, chartType: Y, displayConf: K } = T,
      J = T.cells[0],
      { color: ee } = J,
      te = {};
    F &&
      (Object.keys(F).forEach((e) => {
        te[e] = {
          alias: F[e].alias,
        };
      }),
      Object.keys(F).forEach((e) => {
        var C, $, V, Y, ie;
        "string" ==
          typeof (null == ($ = null == (C = F[e]) ? void 0 : C.domain)
            ? void 0
            : $[0]) &&
          (e === (null == ee ? void 0 : ee[0]) &&
          (null == (V = K.legend) ? void 0 : V.domain)
            ? (te[e].domain = K.legend.domain)
            : (te[e].domain = F[e].domain),
          (((null == (Y = null == J ? void 0 : J.x) ? void 0 : Y[0]) &&
            e === (null == (ie = null == J ? void 0 : J.x) ? void 0 : ie[0])) ||
            generateCategoryField(T) === e) &&
            ((te[e].sortIndex = 0),
            (isXYChart(T) || isRadarChart(T)) &&
              (te[e].lockStatisticsByDomain = !0)));
      }));
    const ie = CHART_DATA_ID,
      ne = getChartData(V, Y, isPivot(T));
    if (e.series && e.series.length > 1) {
      const F = {
          ...e,
        },
        V = T.cells[0],
        Y = null == (C = V.y) ? void 0 : C[0],
        K = null == ($ = V.y) ? void 0 : $[1],
        J = F.series.find((e) => e.id === MAIN_SERIES_ID);
      J &&
        (J.data = {
          id: CHART_MAIN_SERIES_DATA_ID,
          values: ne.filter((e) => Object.keys(e).includes(Y)),
          fields: te,
        });
      const ee = F.series.find((e) => e.id === SUB_SERIES_ID);
      return (
        ee &&
          (ee.data = {
            id: CHART_SUB_SERIES_DATA_ID,
            values: ne.filter((e) => Object.keys(e).includes(K)),
            fields: te,
          }),
        {
          ...F,
          data: [
            {
              id: ie,
              values: ne,
              fields: te,
            },
          ],
        }
      );
    }
    return {
      ...e,
      data: [
        {
          id: ie,
          values: ne,
          fields: te,
        },
      ],
    };
  },
  getChartData = (e, T, C) =>
    C &&
    [
      ChartType.COLUMN,
      ChartType.COLUMN_PARALLEL,
      ChartType.COLUMN_PERCENT,
      ChartType.BAR,
      ChartType.BAR_PARALLEL,
      ChartType.BAR_PERCENT,
      ChartType.LINE,
      ChartType.AREA,
      ChartType.AREA_PERCENT,
      ChartType.DUAL_AXIS,
      ChartType.COMBINATION,
    ].includes(T)
      ? e.slice()
      : T !== ChartType.COMBINATION
      ? e[0][0][0].slice()
      : e[0][0].slice(),
  forecast = (e, T) => {
    var C, $;
    const { vizData: F } = T;
    if (!F.forecast) return e;
    e.data[0].values = completeForeCastDataset(e, T);
    const V = getLineSeries(e),
      Y = getRangeAreaSeries(e),
      K = {
        ...e.point,
        style: {
          ...(null != (C = e.point.style) ? C : {}),
          fillOpacity: 0,
        },
        state: {
          ...(null != ($ = e.point.state) ? $ : {}),
          dimension_hover: {
            fillOpacity: 0.5,
            lineWidth: 2,
          },
        },
      },
      J = ["seriesField", "direction", "xField", "seriesMark"].reduce(
        (T, C) => ((T[C] = e[C]), T),
        {
          type: "scatter",
          yField: ["yMin"],
          seriesField: "yMinName",
          point: K,
        }
      ),
      ee = ["seriesField", "direction", "xField", "seriesMark"].reduce(
        (T, C) => ((T[C] = e[C]), T),
        {
          type: "scatter",
          yField: ["yMax"],
          seriesField: "yMaxName",
          point: K,
        }
      );
    return {
      ...e,
      type: "common",
      series: [V, Y, J, ee],
    };
  },
  getLineSeries = (e) => {
    var T, C;
    const $ = [
      "point",
      "area",
      "line",
      "label",
      "xField",
      "yField",
      "direction",
      "sortDataByAxis",
      "seriesField",
      "invalidType",
      "seriesMark",
    ].reduce((T, C) => ((T[C] = e[C]), T), {
      type: "line",
    });
    return (
      ($.line = {
        ...$.line,
        style: {
          ...(null != (T = $.line.style) ? T : {}),
          lineDash: {
            type: "ordinal",
            field: "isPredict",
            range: [
              [1, 0],
              [4, 4],
            ],
          },
        },
      }),
      ($.point = {
        ...$.point,
        style: {
          ...(null != (C = $.point.style) ? C : {}),
          lineWidth: 2,
        },
      }),
      $
    );
  },
  getRangeAreaSeries = (e) =>
    ["direction", "xField", "seriesField", "seriesMark"].reduce(
      (T, C) => ((T[C] = e[C]), T),
      {
        type: "rangeArea",
        yField: ["yMin", "yMax"],
        point: {
          style: {
            fill: "red",
          },
        },
        area: {
          style: {
            fillOpacity: 0.2,
            zIndex: -1,
          },
        },
      }
    ),
  completeForeCastDataset = (e, T) => {
    var C;
    const $ = e.data[0].values,
      { vizData: F } = T,
      { fieldMap: V } = F,
      Y = (
        null !=
        (C = Object.keys(F.fieldMap).filter(
          (e) => F.fieldMap[e].location === Location.DIMENSION
        ))
          ? C
          : []
      ).find((e) => {
        var T;
        return (
          (null == (T = V[e]) ? void 0 : T.sourceType) ===
          PillSourceType.FORECAST
        );
      });
    if (!Y) return e;
    const K = $.filter((e) => isForecastPredUpper(e[Y])),
      J = $.filter((e) => isForecastPredLower(e[Y])),
      ee = lodash.exports.cloneDeep(
        $.filter((e) => !isForecastPredRange(e[Y]))
      ),
      {
        x: [te],
        y: [ie],
        color: [ne],
      } = F.cells[0];
    return (
      ee.forEach((e) => {
        var T, C;
        if (isForecastPred(e[Y])) {
          const $ = e[te],
            F = e[ie],
            V = e[ne],
            Y = V.replace(" (Pred)", " (Pred Upper)"),
            ee = V.replace(" (Pred)", " (Pred Lower)");
          (e[ie] = F),
            (e.yPredict = F),
            (e.yMax =
              null == (T = K.find((e) => e[ne] === Y && e[te] === $))
                ? void 0
                : T[ie]),
            (e.yMaxName = Y),
            (e.yMin =
              null == (C = J.find((e) => e[ne] === ee && e[te] === $))
                ? void 0
                : C[ie]),
            (e.yMinName = ee),
            (e.isPredict = !0);
        }
      }),
      ee
    );
  },
  isForecastPred = (e) => e.includes(" (Pred)"),
  isForecastPredUpper = (e) => e.includes(" (Pred Upper)"),
  isForecastPredLower = (e) => e.includes(" (Pred Lower)"),
  isForecastPredRange = (e) => isForecastPredUpper(e) || isForecastPredLower(e),
  count$1 = (e) => e.length,
  avg$1 = (e) => count$1(e) / lodash.exports.sum(e),
  first$1 = (e) => e[0],
  aggregateTypeMap$1 = {
    count: count$1,
    sum: lodash.exports.sum,
    average: avg$1,
    max: lodash.exports.max,
    min: lodash.exports.min,
    none: first$1,
    count_distinct: count$1,
  },
  getFinalValue$1 = (e, T, C, $) => {
    var F;
    if (0 !== e.length && T && ($ || C)) {
      if (1 === e.length) return e[0][T];
      if (C.role === FieldRoleType.Dimension) return 1;
      {
        const $ = null != (F = C.aggregation.type) ? F : "none";
        return aggregateTypeMap$1[$](e.map((e) => Number(e[T])));
      }
    }
    return NaN;
  },
  gaugeData = (e, T) => {
    var C, $, F, V, Y, K;
    const { vizData: J } = T,
      ee = {
        ...e,
      },
      { displayConf: te } = J,
      { analytic: ie, fieldMap: ne } = J,
      { params: re, measure: ae } = te,
      oe = J.datasets[0][0][0],
      se = J.cells[0],
      le = Object.keys(ne).filter((e) => ne[e].location === Location.DETAIL),
      {
        minPillUid: de,
        maxPillUid: ce,
        goalPillUid: ue,
        minPillInfo: he,
        maxPillInfo: pe,
        goalPillInfo: ge,
      } = re,
      fe =
        J.analytic.source.dataSourceId === DataSourceType.Report ||
        J.analytic.source.dataSourceId === DataSourceType.VizQuery,
      me =
        re.minType === MeasureParamType.STATIC
          ? null === re.minValue
            ? void 0
            : re.minValue
          : null === de ||
            !(null == le ? void 0 : le.some((e) => e === `${de}`)) ||
            isNaN(getFinalValue$1(oe, de, he, fe))
          ? void 0
          : Number(getFinalValue$1(oe, de, he, fe)),
      ye =
        re.maxType === MeasureParamType.STATIC
          ? null === re.maxValue
            ? void 0
            : re.maxValue
          : null === ce ||
            !(null == le ? void 0 : le.some((e) => e === `${ce}`)) ||
            isNaN(getFinalValue$1(oe, ce, pe, fe))
          ? void 0
          : Number(getFinalValue$1(oe, ce, pe, fe)),
      be =
        re.goalType === MeasureParamType.STATIC
          ? null === re.goalValue
            ? void 0
            : re.goalValue
          : null === ue ||
            !(null == le ? void 0 : le.some((e) => e === `${ue}`)) ||
            isNaN(getFinalValue$1(oe, ue, ge, fe))
          ? void 0
          : Number(getFinalValue$1(oe, ue, ge, fe)),
      ve = null == (C = null == se ? void 0 : se.value) ? void 0 : C[0],
      Te =
        ae.showMeasure && ae.showName && null != ($ = ae.name)
          ? $
          : ne[ve].alias,
      _e = isNaN(
        getFinalValue$1(
          oe,
          ve,
          null == (F = ie.vizFieldBlock.measure) ? void 0 : F[0],
          fe
        )
      )
        ? oe[0][ve]
        : Number(
            getFinalValue$1(
              oe,
              ve,
              null == (V = ie.vizFieldBlock.measure) ? void 0 : V[0],
              fe
            )
          ),
      Ce = void 0 === me ? 0 : me,
      Ae = void 0 === ye ? 1 : ye,
      xe = be > Math.max(Ce, Ae) || be < Math.min(Ce, Ae) ? void 0 : be,
      Se =
        null !=
        (K =
          null == (Y = null == te ? void 0 : te.specialValue)
            ? void 0
            : Y.measures)
          ? K
          : SpecialValueType.BRACKET_TXT,
      Re = createFormatter(ae.percentFormat, Se),
      Me = calcPercent$2({
        originGoalValue: be,
        minValue: Ce,
        measureValue: _e,
        labelFormatMethod: Re,
      }),
      Pe = calcGaugeMeasure({
        minValue: Ce,
        maxValue: Ae,
        measureValue: _e,
      }),
      Be = calcGaugeGoal({
        maxValue: Ae,
        minValue: Ce,
        goalValue: xe,
      }),
      Ee = {
        current: [intl.i18n``, _e],
        goal: [intl.i18n``, xe],
        max: [intl.i18n``, null != Ae ? Ae : ye],
      },
      Le = new Set(ae.labelParams),
      we = Object.keys(Ee)
        .map((e) => (Le.has(e) ? `${Ee[e][1]}` : ""))
        .filter((e) => !!e)
        .join(" / "),
      De = [
        {
          id: "data",
          values: [
            {
              current: _e,
              name: Te,
              emptyName: "",
              percent: Me,
              measurePercent: Pe,
              measureValue: _e,
            },
          ],
        },
      ];
    return (
      (T.payload = {
        min: Ce,
        max: Ae,
        goal: xe,
        originGoalValue: be,
        originMaxValue: ye,
        originMinValue: me,
        current: _e,
        name: Te,
        percent: Me,
        goalPercent: Be,
        measurePercent: Pe,
        detail: we,
      }),
      (ee.data = De),
      ee
    );
  },
  calcGaugeMeasure = ({ maxValue: e, minValue: T, measureValue: C }) => {
    if (!C || 0 === C || T === e) return 0;
    const $ = Math.max(T, e),
      F = Math.min(T, e);
    return Math.max(0, Math.min((C - F) / ($ - F), 1));
  },
  calcGaugeGoal = ({ maxValue: e, minValue: T, goalValue: C }) => {
    if (lodash.exports.isUndefined(C) || T === e) return;
    const $ = Math.max(T, e),
      F = Math.min(T, e);
    return (C - F) / ($ - F);
  },
  calcPercent$2 = ({
    originGoalValue: e,
    minValue: T,
    measureValue: C,
    labelFormatMethod: $,
  }) => (void 0 === e || e - T == 0 ? "-" : `${$((C - T) / (e - T))}`),
  getLineSymbolSize = (e, T = 6) => {
    const C = T + (T / 2) * (e - 1);
    return lodash.exports.max([C, 0]);
  },
  labelLineSpace = 2,
  labelSpace = 15,
  DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
  DEFAULT_RELATIVE_TOLERATE = 1e-10,
  degreeToRadian$1 = (e) => (e / 180) * Math.PI,
  radianToDegree$1 = (e) => (e / Math.PI) * 180,
  getAngle = (e, T, C, $, F) =>
    degreeToRadian$1(((e - T) / (C - T)) * (F - $) + $),
  isNumberClose = (
    e,
    T,
    C = DEFAULT_RELATIVE_TOLERATE,
    $ = DEFAULT_ABSOLUTE_TOLERATE
  ) => {
    const F = $,
      V = C * Math.max(e, T);
    return Math.abs(e - T) <= Math.max(F, V);
  },
  getLayoutRadius = (e) => {
    const T = e.getChart().getRegionsInIndex(0)[0],
      { width: C, height: $ } = T.getLayoutRect();
    return Math.min(C / 2, $ / 2);
  },
  getTickPoint = (
    e,
    T,
    {
      innerRadius: C,
      offsetRadius: $,
      offsetLayoutRadius: F,
      minValue: V,
      maxValue: Y,
      startAngle: K,
      endAngle: J,
    }
  ) => {
    if (!T) return [0, 0];
    const { vchart: ee } = T,
      te = getLayoutRadius(ee),
      ie = T.vchart.getChart().getAllSeries()[0].angleAxisHelper.center(),
      ne = getAngle(e, V, Y, K, J),
      re = (C + F) * te + $;
    return [ie.x + re * Math.cos(ne), ie.y + re * Math.sin(ne), ne];
  },
  getTextAlign = (e) => {
    let T = "center";
    return (
      isNumberClose(e[0], 0)
        ? isNumberClose(e[1], 0)
          ? Object.is(e[1], -0)
            ? (T = "left")
            : Object.is(e[0], -0) && (T = "right")
          : (T = "center")
        : e[0] > 0
        ? (T = "left")
        : e[0] < 0 && (T = "right"),
      T
    );
  },
  getTextBaseline = (e) => {
    let T = "middle";
    return (
      isNumberClose(e[1], 0)
        ? (T = "middle")
        : e[1] > 0 && e[1] > Math.abs(e[0])
        ? (T = "top")
        : e[1] < 0 && Math.abs(e[1]) > Math.abs(e[0]) && (T = "bottom"),
      T
    );
  },
  getTickVector = (
    e,
    T,
    {
      innerRadius: C,
      offsetRadius: $,
      offsetLayoutRadius: F,
      minValue: V,
      maxValue: Y,
      startAngle: K,
      endAngle: J,
    }
  ) => {
    const ee = getTickPoint(e, T, {
        offsetRadius: 0,
        offsetLayoutRadius: 0,
        innerRadius: C,
        minValue: V,
        maxValue: Y,
        startAngle: K,
        endAngle: J,
      }),
      te = getTickPoint(e, T, {
        offsetRadius: $,
        offsetLayoutRadius: F,
        innerRadius: C,
        minValue: V,
        maxValue: Y,
        startAngle: K,
        endAngle: J,
      });
    return [te[0] - ee[0], te[1] - ee[1]];
  },
  getSimpleTick = ({
    getValue: e,
    style: T,
    dataIndex: C,
    innerRadius: $,
    minValue: F,
    maxValue: V,
    startAngle: Y,
    endAngle: K,
    outerRadius: J,
    innerOffsetRadius: ee = -labelLineSpace,
    outerOffsetRadius: te = labelLineSpace,
  }) => ({
    type: "rule",
    visible: !0,
    dataIndex: C,
    style: {
      x: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: ee,
          offsetLayoutRadius: 0,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[0],
      y: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: ee,
          offsetLayoutRadius: 0,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[1],
      x1: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: te,
          offsetLayoutRadius: J - $,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[0],
      y1: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: te,
          offsetLayoutRadius: J - $,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[1],
      ...T,
    },
  }),
  getSimpleTickStart = ({
    getValue: e,
    style: T,
    dataIndex: C,
    innerRadius: $,
    minValue: F,
    maxValue: V,
    startAngle: Y,
    endAngle: K,
    outerRadius: J,
    offsetRadius: ee = -labelLineSpace,
  }) => {
    var te;
    return {
      type: "symbol",
      visible: !0,
      dataIndex: C,
      style: {
        symbolType: "triangle",
        size: getLineSymbolSize(
          null != (te = null == T ? void 0 : T.lineWidth) ? te : 1
        ),
        angle: (T, C) =>
          radianToDegree$1(
            getTickPoint(e(T), C, {
              offsetRadius: ee,
              offsetLayoutRadius: 0,
              innerRadius: $,
              minValue: F,
              maxValue: V,
              startAngle: Y,
              endAngle: K,
            })[2] +
              Math.PI / 2
          ),
        x: (T, C) =>
          getTickPoint(e(T), C, {
            offsetRadius: ee,
            offsetLayoutRadius: 0,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })[0],
        y: (T, C) =>
          getTickPoint(e(T), C, {
            offsetRadius: ee,
            offsetLayoutRadius: 0,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })[1],
        ...T,
      },
    };
  },
  getSimpleTickEnd = ({
    getValue: e,
    style: T,
    dataIndex: C,
    innerRadius: $,
    minValue: F,
    maxValue: V,
    startAngle: Y,
    endAngle: K,
    outerRadius: J,
    offsetRadius: ee = labelLineSpace,
  }) => {
    var te;
    return {
      type: "symbol",
      visible: !0,
      dataIndex: C,
      style: {
        symbolType: "triangle",
        size: getLineSymbolSize(
          null != (te = null == T ? void 0 : T.lineWidth) ? te : 1
        ),
        angle: (T, C) =>
          radianToDegree$1(
            getTickPoint(e(T), C, {
              offsetRadius: ee,
              offsetLayoutRadius: 0,
              innerRadius: $,
              minValue: F,
              maxValue: V,
              startAngle: Y,
              endAngle: K,
            })[2] +
              (3 * Math.PI) / 2
          ),
        x: (T, C) =>
          getTickPoint(e(T), C, {
            offsetRadius: ee,
            offsetLayoutRadius: J - $,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })[0],
        y: (T, C) =>
          getTickPoint(e(T), C, {
            offsetRadius: ee,
            offsetLayoutRadius: J - $,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })[1],
        ...T,
      },
    };
  },
  getSimpleLabel = ({
    getValue: e,
    style: T,
    dataIndex: C,
    innerRadius: $,
    minValue: F,
    maxValue: V,
    startAngle: Y,
    endAngle: K,
    outerRadius: J,
    labelFormatMethod: ee,
  }) => ({
    type: "text",
    visible: !0,
    dataIndex: C,
    style: {
      x: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: -(labelLineSpace + labelSpace),
          offsetLayoutRadius: 0,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[0],
      y: (T, C) =>
        getTickPoint(e(T), C, {
          offsetRadius: -(labelLineSpace + labelSpace),
          offsetLayoutRadius: 0,
          innerRadius: $,
          minValue: F,
          maxValue: V,
          startAngle: Y,
          endAngle: K,
        })[1],
      text: (T) => ee(e(T)),
      textAlign: (T, C) =>
        getTextAlign(
          getTickVector(e(T), C, {
            offsetRadius: -(labelLineSpace + labelSpace),
            offsetLayoutRadius: 0,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })
        ),
      textBaseline: (T, C) =>
        getTextBaseline(
          getTickVector(e(T), C, {
            offsetRadius: -(labelLineSpace + labelSpace),
            offsetLayoutRadius: 0,
            innerRadius: $,
            minValue: F,
            maxValue: V,
            startAngle: Y,
            endAngle: K,
          })
        ),
      ...T,
    },
  }),
  buildSectionTick = (e, T) => {
    const { tickStyle: C } = T.vizData.displayConf,
      $ = e.startAngle,
      F = e.endAngle,
      { min: V, max: Y, labelLayoutRadius: K, outerRadius: J } = T.payload,
      ee = e.valueField;
    return (
      (te = {
        stroke: null == C ? void 0 : C.tickColor,
        lineWidth: 2,
        lineCap: "round",
      }),
      [
        getSimpleTick({
          getValue: () => V,
          dataIndex: void 0,
          style: te,
          startAngle: $,
          minValue: V,
          maxValue: Y,
          endAngle: F,
          innerRadius: K,
          outerRadius: J,
        }),
        getSimpleTick({
          getValue: (e) => e[ee],
          style: te,
          dataIndex: 1,
          startAngle: $,
          minValue: V,
          maxValue: Y,
          endAngle: F,
          innerRadius: K,
          outerRadius: J,
        }),
      ]
    );
    var te;
  },
  buildSectionTickLabel = (e, T) => {
    const { tickStyle: C } = T.vizData.displayConf,
      { min: $, max: F } = T.payload,
      V = e.valueField,
      { innerRadius: Y, startAngle: K, endAngle: J, outerRadius: ee } = e,
      te = createGaugeLabelFormatMethod(T);
    return (
      (ie = {
        fill: null == C ? void 0 : C.labelColor,
        fontSize: null == C ? void 0 : C.labelSize,
      }),
      [
        getSimpleLabel({
          getValue: () => $,
          style: ie,
          dataIndex: void 0,
          innerRadius: Y,
          minValue: $,
          maxValue: F,
          startAngle: K,
          endAngle: J,
          outerRadius: ee,
          labelFormatMethod: te,
        }),
        getSimpleLabel({
          getValue: (e) => e[V],
          style: ie,
          dataIndex: 1,
          innerRadius: Y,
          minValue: $,
          maxValue: F,
          startAngle: K,
          endAngle: J,
          outerRadius: ee,
          labelFormatMethod: te,
        }),
      ]
    );
    var ie;
  },
  exchangeRange = (e, T) => [T, e],
  gaugeReverse = (e, T) => {
    const { vizData: C, payload: $ } = T,
      { min: F, max: V } = $,
      { startAngle: Y, endAngle: K } = e,
      { displayConf: J } = C;
    let ee = Y,
      te = K;
    if (J.reverse) {
      if (
        (($.min = exchangeRange(F, V)[0]),
        ($.max = exchangeRange(F, V)[1]),
        (ee = K),
        (te = Y),
        ee < te)
      )
        for (; ee < te; ) ee += radianToDegree$1(2 * Math.PI);
    } else if (ee > te) for (; ee > te; ) ee -= radianToDegree$1(2 * Math.PI);
    return {
      ...e,
      startAngle: ee,
      endAngle: te,
    };
  },
  createGoalFormatMethod = (e) => {
    var T;
    const { vizData: C } = e,
      { params: $ } = C.displayConf,
      F = (null == (T = $.goalPillInfo) ? void 0 : T.dataFormat)
        ? mapDataFormat({
            dataFormat: $.goalPillInfo.dataFormat,
          })
        : null;
    return createFormatter(F);
  },
  buildSectionGoal = (e, T) => {
    const { vizData: C, measureText: $ } = T,
      { startAngle: F, endAngle: V, innerRadius: Y, outerRadius: K } = e,
      { min: J, max: ee, detail: te, goal: ie } = T.payload,
      ne = [4, 2],
      { displayConf: re } = C,
      { measure: ae } = re,
      {
        labelLineColor: oe = "#963824",
        labelLineWidth: se = 0.5,
        labelVisible: le = !0,
        labelFont: de = "D-DIN",
        labelWeight: ce = "normal",
        labelColor: ue = "#963824",
        labelBackColor: he = "#963824",
        labelSize: pe = 12,
        labelOffsetX: ge = 0,
        labelOffsetY: fe = 0,
      } = ae,
      me = ({
        getValue: e,
        style: T,
        textStyle: C,
        dataIndex: F,
        maxValue: V,
        minValue: Y,
        startAngle: J,
        endAngle: ee,
        innerRadius: te,
        labelFormatMethod: ie,
      }) => {
        const re = getSimpleLabel({
            getValue: e,
            style: C,
            dataIndex: void 0,
            maxValue: V,
            minValue: Y,
            startAngle: J,
            endAngle: ee,
            innerRadius: te,
            outerRadius: K,
            labelFormatMethod: ie,
          }),
          { style: ae } = re,
          {
            x: oe,
            y: se,
            text: le,
            textAlign: de,
            textBaseline: ce,
            dx: ue,
            dy: he,
            fontSize: pe,
          } = ae,
          ge = (e, T) => {
            const C = le(e, T),
              F = $(C, ae);
            return {
              width: F.width + 2 * ne[0] + ((C + "").includes("") ? pe : 0),
              height: F.height + 2 * ne[1],
            };
          };
        return {
          type: "rect",
          visible: !0,
          dataIndex: F,
          style: {
            x: (e, T) => {
              const { width: C } = ge(e, T),
                $ = de(e, T);
              return "right" === $
                ? oe(e, T) - C + ne[0]
                : "center" === $
                ? oe(e, T) - C / 2
                : oe(e, T) - ne[0];
            },
            y: (e, T) => {
              const { height: C } = ge(e, T),
                $ = ce(e, T);
              return "bottom" === $
                ? se(e, T) - C + ne[1]
                : "middle" === $
                ? se(e, T) - C / 2
                : se(e, T) - ne[1];
            },
            width: (e, T) => ge(e, T).width,
            height: (e, T) => ge(e, T).height,
            dx: ue,
            dy: he,
            ...T,
          },
        };
      };
    return (
      (ye = ie),
      (be = {
        stroke: oe,
        fill: oe,
        lineWidth: se,
        lineCap: "round",
        hash: generateHash({
          goalValue: ie,
          detail: te,
        }),
      }),
      (ve = {
        fill: ue,
        fontSize: pe,
        fontFamily: de,
        fontWeight: ce,
        visible: le,
        dx: ge,
        dy: -fe,
        hash: generateHash({
          goalValue: ie,
          detail: te,
        }),
      }),
      (Te = {
        fill: he,
        cornerRadius: 3,
        visible: le,
        hash: generateHash({
          goalValue: ie,
          detail: te,
        }),
      }),
      [
        me({
          getValue: () => ye,
          style: Te,
          textStyle: ve,
          dataIndex: void 0,
          maxValue: ee,
          minValue: J,
          startAngle: F,
          endAngle: V,
          innerRadius: Y,
          labelFormatMethod: createGoalFormatMethod(T),
        }),
        getSimpleTick({
          getValue: () => ye,
          style: be,
          dataIndex: void 0,
          maxValue: ee,
          minValue: J,
          startAngle: F,
          endAngle: V,
          innerRadius: Y,
          outerRadius: K,
        }),
        getSimpleTickStart({
          getValue: () => ye,
          style: be,
          dataIndex: void 0,
          maxValue: ee,
          minValue: J,
          startAngle: F,
          endAngle: V,
          innerRadius: Y,
          outerRadius: K,
        }),
        getSimpleTickEnd({
          getValue: () => ye,
          style: be,
          dataIndex: void 0,
          maxValue: ee,
          minValue: J,
          startAngle: F,
          endAngle: V,
          innerRadius: Y,
          outerRadius: K,
        }),
        getSimpleLabel({
          getValue: () => ye,
          style: ve,
          dataIndex: void 0,
          maxValue: ee,
          minValue: J,
          startAngle: F,
          endAngle: V,
          innerRadius: Y,
          outerRadius: K,
          labelFormatMethod: createGoalFormatMethod(T),
        }),
      ]
    );
    var ye, be, ve, Te;
  },
  INVALID_VALUE_MAP$3 = {
    [SpecialValueType$1.BRACKET_TXT]: " ",
    [SpecialValueType$1.NULL]: "NULL",
    [SpecialValueType$1.ZERO]: "0",
    [SpecialValueType$1.DASH]: "--",
  },
  getFormatMethod = (e, T, C) => ($, F) => {
    const V = getFieldFormat,
      Y = createFormatter;
    if (null !== F && isNaN(Number(F))) return F;
    if (void 0 === e) return F;
    return Y(V(e, T, "field"), INVALID_VALUE_MAP$3[C])(F);
  },
  getFormatMethodWithValue$1 = (e, T, C, $, F) => () => {
    const $ = getFieldFormat,
      V = createFormatter;
    if (null !== F && isNaN(Number(F))) return F;
    if (void 0 === e) return F;
    return V($(e, T, "field"), INVALID_VALUE_MAP$3[C])(F);
  },
  gaugeExtensionMark = (e, T) => {
    const C = [],
      { showSections: $, showDegreeMarks: F } = T.vizData.displayConf,
      { goal: V } = T.payload;
    return (
      $ &&
        F &&
        (C.push(...buildSectionTick(e, T)),
        C.push(...buildSectionTickLabel(e, T))),
      lodash.exports.isNil(V) || C.push(...buildSectionGoal(e, T)),
      {
        ...e,
        extensionMark: C,
      }
    );
  },
  gaugeIndicator = (e, T) => {
    var C;
    const $ = {
        ...e,
      },
      { vizData: F, payload: V, containerSize: Y } = T,
      { displayConf: K } = F,
      { measure: J, specialValue: ee } = K,
      { current: te, percent: ie, name: ne } = V,
      {
        showName: re,
        nameSize: ae,
        nameColor: oe,
        nameWeight: se = 400,
        nameFont: le = GAUGE_FONT_FAMILY,
        showValue: de,
        valueSize: ce,
        valueColor: ue,
        valueWeight: he = 400,
        valueFont: pe = GAUGE_FONT_FAMILY,
        percentVisible: ge,
        percentSize: fe,
        percentColor: me,
        percentWeight: ye = 400,
        percentFont: be = GAUGE_FONT_FAMILY,
      } = J,
      ve = getFields(F, Location.MEASURE, isRenderField)[0],
      Te =
        null != (C = null == ee ? void 0 : ee.measures)
          ? C
          : SpecialValueType$1.BRACKET_TXT,
      _e = getFormatMethodWithValue$1(ve, F, Te, "", te),
      Ce = "bottom" === J.namePosition || "top" === J.namePosition,
      Ae = {
        visible: de,
        text: de ? _e() : "",
        fontSize: ce,
        fill: ue,
        fontWeight: he,
        fontFamily: pe,
        textAlign: "center",
        textBaseline: "middle",
      },
      xe = {
        visible: re,
        text: re ? ne : "",
        fontSize: ae,
        fill: oe,
        fontWeight: se,
        fontFamily: le,
        textAlign: "center",
        textBaseline: "middle",
      },
      Se = {
        visible: ge,
        text: (ge ? ie : "") + "\n",
        fontSize: fe,
        fill: me,
        fontWeight: ye,
        fontFamily: be,
        textAlign: "center",
        textBaseline: "middle",
      },
      Re =
        "bottom" === J.namePosition || "right" === J.namePosition
          ? [Ae, xe]
          : [xe, Ae],
      Me = [
        Re[0],
        {
          text: Ce ? "\n" : de && re ? "   " : "",
          fontSize: 8,
        },
        Re[1],
      ],
      Pe = 4e4;
    return (
      ($.markPoint = [
        {
          position: {
            x: Y.width / 2 - 2e4 - 10,
            y: 2e4 + Y.height / 2 + 65,
          },
          itemLine: {
            visible: !1,
          },
          itemContent: {
            type: "richText",
            autoRotate: !1,
            richText: {
              style: {
                width: Pe,
                height: Pe,
                textAlign: "left",
                textBaseline: "top",
                type: "rich",
                textConfig: [Se, ...Me],
              },
            },
          },
        },
      ]),
      $
    );
  },
  GAUGE_COLOR_KEY = "gaugeColorKey",
  gaugeSection = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      { showSections: F } = $;
    if (F) {
      const C = calcSectionData(e, T),
        $ = C.map((e) => e.color),
        F = C.map((e, T) => T);
      return {
        ...e,
        color: {
          type: "ordinal",
          range: $,
          domain: F,
          field: GAUGE_COLOR_KEY,
        },
        data: [
          ...e.data,
          {
            id: "sections",
            values: C,
          },
        ],
      };
    }
    return {
      ...e,
    };
  },
  calcSectionData = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      { sections: F } = $,
      { min: V, max: Y } = T.payload,
      K = [];
    let J = V - 1;
    return (
      F.forEach((e) => {
        let { startValue: T } = e;
        e.valueType === SectionValueType.PERCENTAGE &&
          (T = V + ((Y - V) * e.startValue) / 100),
          T > J &&
            (K.push({
              startValue: T,
              color: e.color,
              valueType: SectionValueType.TRUE_VALUE,
              name: e.name,
            }),
            (J = T));
      }),
      K.map((e, T) => ({
        [GAUGE_COLOR_KEY]: T,
        current: T === K.length - 1 ? Y : K[T + 1].startValue,
        name: e.name,
        color: e.color,
      }))
    );
  },
  gaugeStyle = (e, T) => {
    var C, $, F;
    const V = {
        ...e,
      },
      { vizData: Y } = T,
      { displayConf: K } = Y,
      { showSections: J, type: ee, trailStyle: te, segmentStyle: ie } = K;
    return (
      J
        ? (V.gauge = {
            type: "gauge",
            seriesField: GAUGE_COLOR_KEY,
            categoryField: GAUGE_COLOR_KEY,
            valueField: "current",
            dataIndex: 1,
            label: {
              visible: !0,
              position: "inside-outer",
              offsetRadius: 10,
              style: {
                text: (e) => e.name,
              },
            },
          })
        : ((V.radiusField = "name"),
          (V.gauge = {
            type: "circularProgress",
            progress: {
              style: {
                cornerRadius:
                  null != (C = null == ie ? void 0 : ie.cornerRadius) ? C : 0,
              },
            },
            track: {
              style: {
                fill:
                  null != ($ = null == te ? void 0 : te.fill) ? $ : "#d5d6de",
              },
            },
          })),
      ee === GaugeType.DEGREE_MARKS &&
        (V.gauge = {
          ...(null != (F = V.gauge) ? F : {}),
          tickMask: {
            visible: !0,
            angle: 2,
            offsetAngle: 0,
            forceAlign: !0,
            style: {
              cornerRadius: 5,
            },
          },
        }),
      {
        ...V,
        ...pointStyle(e, T),
      }
    );
  },
  pointStyle = (e, T) => {
    var C, $, F, V;
    const { vizData: Y } = T,
      { displayConf: K } = Y,
      { needleStyle: J, anchorStyle: ee } = K,
      te = {
        visible: !0,
        interactive: !1,
        zIndex: 9999,
        style: {
          fill: null != (C = null == J ? void 0 : J.fill) ? C : "#59595e",
        },
      },
      ie = null != ($ = null == ee ? void 0 : ee.ratio) ? $ : 1,
      ne = {
        visible: !0,
        width: 0.08 * ie,
        height: 0.08 * ie,
        style: {
          fill: null != (F = null == ee ? void 0 : ee.fill) ? F : "#d5d6de",
        },
      };
    return {
      pointer: te,
      pin: {
        visible: !1,
        interactive: !1,
        width: 0.025 * ie,
        height: 0.025 * ie,
        style: {
          fill: null != (V = null == ee ? void 0 : ee.fill) ? V : "#d5d6de",
        },
      },
      pinBackground: ne,
    };
  },
  DELTA_ANGLE = 0.1,
  initGauge = (e, { vizData: T }) => {
    const { displayConf: C } = T,
      {
        type: $,
        startAngle: F = -225,
        endAngle: V = 45,
        innerRadius: Y = 0.75,
        outerRadius: K = $ === GaugeType.DEGREE_MARKS ? 0.6 : 0.525,
      } = C;
    let J = F,
      ee = V;
    return (
      (F - V) % (Math.PI / 2) == 0 &&
        (ee -= (ee - J > 0 ? 1 : -1) * DELTA_ANGLE),
      {
        ...e,
        padding: 0,
        type: "gauge",
        categoryField: "name",
        valueField: "measureValue",
        startAngle: J,
        endAngle: ee,
        outerRadius: K,
        innerRadius: Y,
      }
    );
  },
  isVisActorInstance = (e) =>
    isVChartInstance(e) || isVTableChartInstance(e) || isVTableInstance(e),
  isVChartInstance = (e) => "_compiler" in e,
  isVTableChartInstance = (e) => {
    var T;
    return null == (T = null == e ? void 0 : e.isPivotChart)
      ? void 0
      : T.call(e);
  },
  isVTableInstance = (e) =>
    (null == e ? void 0 : e.id) &&
    String(e.id).toLocaleLowerCase().includes("vtable"),
  getLegendSelectedData = (e) =>
    isVChartInstance(e)
      ? e.getLegendSelectedDataByIndex(0)
      : isVTableChartInstance(e)
      ? e.getLegendSelected()
      : [],
  labelContentTotalFormatter =
    (e, T, C) =>
    ($, F, { series: V }) => {
      var Y, K, J;
      const { cells: ee } = e,
        te = ee[0],
        ie = isTableChart(e);
      if ($ < 0) return "";
      const ne = Object.values(e.fieldMap).filter(
          ({ role: e }) => e === Role.MEASURE
        ),
        re = ie ? C() : getLegendSelectedData(V.getOption().globalInstance),
        ae = lodash.exports.uniq(
          re.map((e) => {
            const T = e.split("-");
            return T[T.length - 1];
          })
        ),
        oe = !!(null == (Y = null == e ? void 0 : e.displayConf)
          ? void 0
          : Y.measureParallel),
        se =
          F[null != (J = null == (K = te.foldInfo) ? void 0 : K.id) ? J : ""],
        le = ne
          .map((e) => {
            const { alias: T, id: C } = e;
            if (ae.includes(T)) return C;
          })
          .filter(Boolean);
      return getTotalValueFormatter(e, T, oe ? [se] : le)($);
    },
  calculateXYPercent = (e, T, C) => {
    var $, F;
    const V =
        null == ($ = C.values)
          ? void 0
          : $.reduce((T, C) => {
              const $ = parseFloat(C[e]);
              return lodash.exports.isNaN($) ? T : T + ($ < 0 ? 0 : $);
            }, 0),
      Y =
        null == (F = C.values)
          ? void 0
          : F.reduce((T, C) => {
              const $ = parseFloat(C[e]);
              return lodash.exports.isNaN($) ? T : T + ($ > 0 ? 0 : $);
            }, 0);
    return T > 0 ? (0 === V ? NaN : T / V) : 0 === Y ? NaN : T / Y;
  },
  getStackData = (e, T) => {
    var C;
    const $ = null != (C = e.series.getStackGroupFields()) ? C : [];
    return null == $
      ? void 0
      : $.reduce((e, C) => {
          if (null == e ? void 0 : e.nodes) {
            const $ = T[C];
            return e.nodes[$];
          }
        }, e.series.getStackData());
  },
  calculatePolarPercent = (e, T, C) => {
    const $ = Number(C);
    return T[e] / $;
  },
  labelContentValueFormatter = (e, T, C, $, F, V) => (Y, K, J) => {
    const ee = getCellByMark(K, T),
      { color: te, y: ie } = ee,
      ne = [];
    if (e.includes(LabelContent.DIMENSION) && (null == te ? void 0 : te[0])) {
      const e = te[0],
        $ = getFieldFormat(e, T, "label"),
        F = createFormatter($, INVALID_VALUE_MAP$5[C]);
      ne.push(F(K[e]));
    }
    if (e.includes(LabelContent.MEASURE)) {
      const e = null != V ? V : null == ie ? void 0 : ie[0],
        $ = getOriginalFields(e, K, ee)[0],
        F = getFieldFormat($, T, "label"),
        Y = createFormatter(F, INVALID_VALUE_MAP$5[C]);
      ne.push(Y(K[e]));
    }
    const re = getStackData(J, K);
    if (e.includes(LabelContent.PERCENT) && re) {
      const T = calculateXYPercent(
        null != V ? V : null == ie ? void 0 : ie[0],
        parseFloat(Y),
        re
      );
      if (!isNaN(T)) {
        let $ = percentFormatter;
        F && ($ = createFormatter(F, INVALID_VALUE_MAP$5[C])),
          e.includes(LabelContent.MEASURE)
            ? ne.push(`(${$(T, 2, INVALID_VALUE_MAP$5[C])})`)
            : ne.push(`${$(T, 2, INVALID_VALUE_MAP$5[C])}`);
      }
    }
    return $ ? ne.join(" ") : ne;
  },
  labelContentPieValueFormatter = (e, T, C, $, F, V) => (Y, K) => {
    var J, ee, te, ie, ne, re;
    const ae = getOriginalFields,
      oe = getFieldFormat,
      se = V ? createFormatter(V, INVALID_VALUE_MAP$5[C]) : percentFormatter,
      le = createFormatter,
      de = getCellByMark(K, T),
      { group: ce, color: ue, angle: he, radius: pe } = de;
    let ge = "",
      fe = "",
      me = "";
    if (e.includes(LabelContent.DIMENSION)) {
      const e =
        null !=
        (ee =
          null != (J = null == ce ? void 0 : ce[0])
            ? J
            : null == ue
            ? void 0
            : ue[0])
          ? ee
          : "";
      ge = le(oe(e, T, "label"), INVALID_VALUE_MAP$5[C])(K[e]);
    }
    if (e.includes(LabelContent.MEASURE)) {
      const e =
        null !=
        (ie =
          null != (te = null == he ? void 0 : he[0])
            ? te
            : null == pe
            ? void 0
            : pe[0])
          ? ie
          : "";
      fe = le(oe(ae(e, K, de)[0], T, "label"), INVALID_VALUE_MAP$5[C])(K[e]);
    }
    const ye =
        null !=
        (re =
          null != (ne = null == he ? void 0 : he[0])
            ? ne
            : null == pe
            ? void 0
            : pe[0])
          ? re
          : "",
      be = calculatePolarPercent(ye, K, F);
    e.includes(LabelContent.PERCENT) &&
      !isNaN(be) &&
      (me = e.includes(LabelContent.MEASURE)
        ? `(${se(be, 2, INVALID_VALUE_MAP$5[C])})`
        : `${se(be, 2, INVALID_VALUE_MAP$5[C])}`);
    const ve = [ge, fe, me].filter((e) => "" !== e);
    return $ ? ve.join(" ") : ve;
  },
  labelContentMapValueFormatter = (e, T, C, $) => (e, F) => {
    var V, Y, K, J, ee;
    const te = getOriginalFields,
      ie = getFieldFormat,
      ne = createFormatter,
      re = getCellByMark(F, T),
      { group: ae } = re,
      oe = [],
      se =
        null !=
        (K =
          null == (Y = null == (V = T.displayConf) ? void 0 : V.label)
            ? void 0
            : Y.labelContent)
          ? K
          : [];
    if (
      (se.includes(LabelContent.DIMENSION) &&
        oe.push(
          `${F[null != (J = null == ae ? void 0 : ae[0]) ? J : ""] ? e : ""}`
        ),
      se.includes(LabelContent.MEASURE))
    ) {
      const { value: e, size: $ } = re,
        V =
          null != (ee = null == e ? void 0 : e[0])
            ? ee
            : null == $
            ? void 0
            : $[0],
        Y = ne(ie(te(V, F, re)[0], T, "label"), INVALID_VALUE_MAP$5[C]);
      oe.push(Y(F[V]));
    }
    return $ ? oe.join(" ") : oe;
  },
  labelContentSankeyValueFormatter = (e, T, C, $) => (F, V) => {
    var Y;
    const K = getFieldFormat,
      J = createFormatter,
      ee = [];
    if (e.includes(LabelContent.DIMENSION)) {
      const { group: e, color: $ } = V,
        F = J(K(e, T, "label"), INVALID_VALUE_MAP$5[C]);
      ee.push(F($));
    }
    if (e.includes(LabelContent.NUMBER)) {
      const e = null == (Y = T.cells[0].value) ? void 0 : Y[0],
        $ = J(K(e, T, "label"), INVALID_VALUE_MAP$5[C]);
      ee.push($(V[e]));
    }
    return $ ? ee.join(" ") : ee;
  },
  funnelLayerFormatter = (e, T, C, $, F) => (V, Y) => {
    var K;
    const J = [],
      ee = getOriginalFields(F, Y, null == (K = T.cells) ? void 0 : K[0])[0];
    if (e.includes(LabelContent.NUMBER)) {
      const e = getFieldFormat(ee, T, "label"),
        $ = createFormatter(e, INVALID_VALUE_MAP$5[C]);
      J.push($(Y[F]));
    }
    return (
      e.includes(LabelContent.BASE_TRANSFER) &&
        J.push(
          `(${percentFormatter(Y.baseTransfer, 2, INVALID_VALUE_MAP$5[C])})`
        ),
      $ ? J.join(" ") : J
    );
  },
  funnelAuxiliaryLabelsFormatter = (e, T, C) => ($, F) => {
    var V, Y, K;
    const J =
      null !=
      (K =
        null == (Y = null == (V = T.cells) ? void 0 : V[0].color)
          ? void 0
          : Y[0])
        ? K
        : "";
    if (!e) return F[J];
    const ee = getFieldFormat(J, T, "label");
    return createFormatter(ee, INVALID_VALUE_MAP$5[C])(F[J]);
  },
  buildLabel = (e) => (T, C) => {
    const { vizData: $ } = C,
      { displayConf: F } = $;
    if (!(null == F ? void 0 : F.label)) return T;
    const {
        visible: V,
        allowOverlap: Y,
        labelSize: K,
        labelFont: J,
        labelWeight: ee,
        allowOverlapPadding: te,
      } = F.label,
      ie = {
        ...T,
      };
    ie.label = {
      visible: V,
      offset: 3,
      overlap: {
        hideOnHit: !Y,
        overlapPadding: te ? 10 : void 0,
        avoidBaseMark: !1,
        strategy: [
          {
            type: "position",
            position: isBarLikeChart($.chartType) ? [] : ["top", "bottom"],
          },
        ],
      },
      style: {
        fontSize: K,
        fontFamily: J,
        fontWeight: ee,
        zIndex: 400,
        lineHeight: "100%",
      },
    };
    for (const ne of e) ne(C, ie);
    return ie;
  },
  POSITION_MAP_AUTO_INSIDE_MIDDLE = {
    [LabelPos.AUTO]: "inside-middle",
    [LabelPos.OUTER]: "outside",
    [LabelPos.INNER]: "inside-middle",
  },
  POSITION_MAP_AUTO_INSIDE = {
    [LabelPos.AUTO]: "inside",
    [LabelPos.OUTER]: "outside",
    [LabelPos.INNER]: "inside",
  },
  POSITION_MAP_SYMBOL = {
    [LabelPos.AUTO]: "top",
    [LabelPos.OUTER]: "top",
    [LabelPos.INNER]: "center",
  };
LabelType.ALL,
  LabelShowRule.ALL,
  LabelType.MIN,
  LabelShowRule.MIN,
  LabelType.MAX,
  LabelShowRule.MAX,
  LabelType.EXTREMUM,
  LabelShowRule.MIN_AND_MAX,
  LabelType.ENDPOINT,
  LabelShowRule.HEAD_AND_TAIL,
  EffectiveRange.TABLE,
  LabelShowRuleMode.GLOBAL,
  EffectiveRange.BlOCK,
  LabelShowRuleMode.META,
  EffectiveRange.TABLE,
  LabelShowRuleMode.GLOBAL_GROUP,
  EffectiveRange.BlOCK,
  LabelShowRuleMode.META_GROUP;
const getMinLabel = (e, T) => {
    const C = lodash.exports.minBy(e, (e) => {
      const C = T.find((T) => Boolean(e[T]));
      return Number(e[C]);
    });
    return e.filter((e) => {
      const $ = T.find((T) => Boolean(e[T]));
      return C[$] === e[$];
    });
  },
  getMaxLabel = (e, T) => {
    const C = lodash.exports.maxBy(e, (e) => {
      const C = T.find((T) => Boolean(e[T]));
      return Number(e[C]);
    });
    return e.filter((e) => {
      const $ = T.find((T) => Boolean(e[T]));
      return C[$] === e[$];
    });
  },
  LABEL_TYPES_FILTER_MAP = {
    [LabelType.MIN]: (e, T) => getMinLabel(e, T),
    [LabelType.MAX]: (e, T) => getMaxLabel(e, T),
    [LabelType.EXTREMUM]: (e, T) => [
      ...getMinLabel(e, T),
      ...getMaxLabel(e, T),
    ],
    [LabelType.ENDPOINT]: (e, T) => [e[0], e[e.length - 1]],
  },
  LABEL_TOTAL_MODE_ENABLED_CHARTS = [
    ChartType.COLUMN,
    ChartType.COLUMN_PERCENT,
    ChartType.BAR,
    ChartType.BAR_PERCENT,
    ChartType.AREA,
    ChartType.AREA_PERCENT,
  ],
  isLabelTotalMode = (e, T) =>
    e === LabelMode.TOTAL && LABEL_TOTAL_MODE_ENABLED_CHARTS.includes(T),
  formatterCustomer$5 = (e, T) => {
    var C, $;
    const { vizData: F, getTableChartLegendData: V } = e,
      Y = F.displayConf,
      {
        labelContent: K,
        allowWrappedDisplay: J,
        labelMode: ee = LabelMode.SINGLE,
        percentFormat: te,
      } = Y.label,
      ie =
        null != ($ = null == (C = Y.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT;
    let ne;
    isLabelTotalMode(ee, F.chartType)
      ? ((ne = labelContentTotalFormatter(F, ie, V)),
        (T.totalLabel = {
          ...T.label,
          formatMethod: ne,
        }),
        (T.label.visible = !1))
      : ((ne = labelContentValueFormatter(K, F, ie, !J, te)),
        (T.label = {
          ...T.label,
          formatMethod: ne,
        }));
  },
  labelCustomer$1 = (e, T) => {
    var C;
    const { vizData: $ } = e,
      { chartType: F, displayConf: V } = $,
      {
        label: {
          labelColor: Y,
          labelPos: K = LabelPos.AUTO,
          labelFont: J,
          labelWeight: ee,
        },
      } = V,
      te = K === LabelPos.AUTO ? getAutoPos(F) : K,
      ie = generateBaseColorConf(Y, te);
    T.label = {
      ...T.label,
      style: {
        ...T.label.style,
        boundsPadding: [1, 0, 0, 0],
        fill: ie.color,
        stroke: ie.stroke,
        lineWidth: ie.strokeWidth,
        strokeOpacity: ie.strokeOpacity,
        fontFamily: "inherit" === J ? "" : J,
        fontWeight: ee,
      },
      overlap: {
        ...T.label.overlap,
        clampForce: !0,
      },
      position: isSymbolLikeChart(F)
        ? POSITION_MAP_SYMBOL[K]
        : POSITION_MAP_AUTO_INSIDE[K],
      smartInvert: null != (C = null == ie ? void 0 : ie.smartInverse) && C,
    };
  },
  calculateDisplayedLabels = (e, T, C) => {
    const $ = e.displayConf,
      F = e.cells[0],
      { color: V } = F,
      {
        label: { labelType: Y, maxMinByLegend: K },
      } = $;
    if (Y === LabelType.ALL) return T;
    if (
      V &&
      V[0] &&
      !isPolarChart(e.chartType) &&
      (K || Y === LabelType.ENDPOINT)
    ) {
      const e = {};
      T.filter((e) => C.some((T) => Boolean(e[T]))).forEach((T) => {
        const C = T[V[0]];
        e[C] || (e[C] = []), e[C].push(T);
      });
      return Object.keys(e)
        .reduce((T, $) => {
          const F = e[$],
            V = LABEL_TYPES_FILTER_MAP[Y](F, C);
          return T.concat(V);
        }, [])
        .filter(Boolean);
    }
    return LABEL_TYPES_FILTER_MAP[Y](
      T.filter((e) => C.some((T) => Boolean(e[T]))),
      C
    ).filter(Boolean);
  },
  buildDataFilterFunc = (e, T, C, $, F, V) => (Y) => {
    if (1 === Y.length) return Y;
    const { fieldMap: K } = e,
      J = e.displayConf,
      {
        label: { labelType: ee, effectiveRange: te },
      } = J,
      ie = isPivot(e),
      ne = Object.keys(K);
    if (ee === LabelType.ALL) return Y;
    const re = isTableChart(e);
    let ae = [];
    if (ee === LabelType.ENDPOINT) ae = Y.map((e) => e.data);
    else if (te === EffectiveRange.TABLE && (ie || (C && !ie)))
      ae = e.datasets.flat(4);
    else if (te !== EffectiveRange.BlOCK || ie || !C || re)
      if (te === EffectiveRange.BlOCK && re && $ && F) {
        const { col: e, row: T } = F(Y[0].data);
        ae = $(e, T);
      } else ae = Y.map((e) => e.data);
    else ae = e.datasets.flat(4);
    const oe = (V ? V(e, ae, T) : calculateDisplayedLabels(e, ae, T)).map((e) =>
        lodash.exports.pick(e, ne)
      ),
      se = new Map();
    Y.forEach((e) => {
      const { data: T } = e,
        C = lodash.exports.pick(T, ne),
        $ = generateHash(C);
      se.set($, e);
    });
    return oe
      .map((e) => {
        const T = lodash.exports.pick(e, ne),
          C = generateHash(T);
        return se.get(C);
      })
      .filter(Boolean);
  },
  labelDataFilterCustomer = (e, T, C, $) => {
    const { vizData: F } = e,
      V = F.displayConf,
      {
        label: { labelType: Y },
      } = V;
    Y &&
      (T.label = {
        ...T.label,
        dataFilter: buildDataFilterFunc(
          F,
          C,
          $,
          e.getCellValue,
          e.getCellAddressByRecord,
          e.customCalculateDisplayedLabels
        ),
      });
  },
  getAutoPos = (e) => (isSymbolLikeChart(e) ? LabelPos.OUTER : LabelPos.INNER),
  dataFilterCustomer$2 = (e, T) => {
    const { vizData: C } = e,
      $ = C.cells[0],
      { y: F } = $;
    labelDataFilterCustomer(e, T, F);
  },
  label = buildLabel([
    labelCustomer$1,
    dataFilterCustomer$2,
    formatterCustomer$5,
  ]),
  PIE_POSITION_MAP = {
    [LabelPos.AUTO]: "inside",
    [LabelPos.OUTER]: "outside",
    [LabelPos.INNER]: "inside",
  },
  formatterCustomer$4 = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te, ie;
    const { vizData: ne, payload: re } = e,
      { displayConf: ae } = ne,
      oe = ne.cells[0],
      {
        labelContent: se,
        allowWrappedDisplay: le,
        labelFont: de,
        percentFormat: ce,
      } = ae.label,
      ue =
        "inherit" === de
          ? window.getComputedStyle(document.getElementById("root"), null)[
              "font-family"
            ]
          : de,
      he =
        null != ($ = null == (C = ae.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT,
      pe =
        ne.chartType === ChartType.ROSE
          ? null != (V = null == (F = oe.radius) ? void 0 : F[0])
            ? V
            : ""
          : null != (K = null == (Y = oe.angle) ? void 0 : Y[0])
          ? K
          : "",
      ge = labelContentPieValueFormatter(
        se,
        ne,
        he,
        !le,
        null != (J = null == re ? void 0 : re.total)
          ? J
          : ne.datasets.flat(3).reduce((e, T) => e + +T[pe], 0),
        ce
      );
    T.label = {
      ...(null != (ee = T.label) ? ee : {}),
      formatMethod: ge,
      style: {
        ...(null != (ie = null == (te = T.label) ? void 0 : te.style)
          ? ie
          : {}),
        fontFamily: ue,
      },
    };
  },
  customer$5 = (e, T) => {
    var C, $, F, V;
    const { vizData: Y } = e,
      {
        displayConf: { label: K },
      } = Y,
      { labelPos: J = LabelPos.AUTO, labelColor: ee } = K,
      te = generateBaseColorConf(ee, J);
    T.label = {
      ...(null != (C = T.label) ? C : {}),
      position: PIE_POSITION_MAP[J],
      smartInvert: null != ($ = null == te ? void 0 : te.smartInverse) && $,
      style: {
        ...(null != (V = null == (F = T.label) ? void 0 : F.style) ? V : {}),
        fill: te.color,
        stroke: te.stroke,
        lineWidth: 0,
        strokeOpacity: 1,
        angle: 0,
        lineHeight: "130%",
      },
      line: {
        style: {
          stroke: te.color,
          lineWidth: 1,
          strokeOpacity: 1,
        },
      },
    };
  },
  polarDataFilterCustomer = (e, T) => {
    const { vizData: C } = e,
      $ = C.cells[0],
      { angle: F, radius: V } = $;
    labelDataFilterCustomer(e, T, 0 === F.length ? V : F);
  },
  polarLabel = buildLabel([
    formatterCustomer$4,
    polarDataFilterCustomer,
    customer$5,
  ]),
  formatterCustomer$3 = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      { displayConf: V } = F,
      { specialValue: Y, label: K } = V,
      { labelContent: J, allowWrappedDisplay: ee } = K,
      te =
        null != (C = null == Y ? void 0 : Y.measures)
          ? C
          : SpecialValueType$1.BRACKET_TXT,
      ie = labelContentValueFormatter(J, F, te, !ee);
    T.label = {
      ...(null != ($ = T.label) ? $ : {}),
      formatMethod: ie,
    };
  },
  customer$4 = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V = F.displayConf,
      {
        label: { labelColor: Y },
      } = V,
      K = generateBaseColorConf(Y, LabelPos.OUTER);
    T.label = {
      ...T.label,
      smartInvert: null == K ? void 0 : K.smartInverse,
      style: {
        ...(null != ($ = null == (C = T.label) ? void 0 : C.style) ? $ : {}),
        fill: K.color,
        stroke: K.stroke,
        strokeOpacity: K.strokeOpacity,
        lineWidth: K.strokeWidth,
        lineHeight: "130%",
      },
    };
  },
  radarLabel = buildLabel([formatterCustomer$3, customer$4]),
  circleViewsFormatterCustomer = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V = F.displayConf,
      { labelContent: Y, allowWrappedDisplay: K } = V.label,
      J =
        null != ($ = null == (C = V.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT,
      ee = !K;
    T.label = {
      ...T.label,
      formatMethod: (e, T) => {
        const C = getCellByMark(T, F),
          { group: $, y: V } = C,
          K = [];
        if (Y.includes(LabelContent.DIMENSION) && $ && $[0]) {
          const e = getFieldFormat($[0], F),
            C = createFormatter(e);
          K.push(`${C(T[$[0]])}`);
        }
        if (Y.includes(LabelContent.MEASURE)) {
          const e = V ? V[0] : "",
            $ = getOriginalFields(e, T, C)[0],
            Y = getFieldFormat($, F, "label"),
            ee = createFormatter(Y, INVALID_VALUE_MAP$5[J]);
          K.push(ee(T[e]));
        }
        return ee ? K.join(" ") : K;
      },
    };
  },
  scatterFormatterCustomer = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V = F.displayConf,
      { labelContent: Y, allowWrappedDisplay: K } = V.label,
      J =
        null != ($ = null == (C = V.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT;
    T.label = {
      ...T.label,
      formatMethod: (e, T) => {
        const C = getCellByMark(T, F),
          { group: $ } = C,
          V = !K,
          ee = [];
        if (Y.includes(LabelContent.DIMENSION) && $ && $[0]) {
          const e = getFieldFormat($[0], F),
            C = createFormatter(e);
          ee.push(`${C(T[$[0]])}`);
        }
        if (Y.includes(LabelContent.MEASURE)) {
          const e = (e) => {
            const $ = getOriginalFields(e, T, C)[0],
              V = getFieldFormat($, F, "label");
            return createFormatter(V, INVALID_VALUE_MAP$5[J])(T[e]);
          };
          ee.push(`${e(C.x[0])}, ${e(C.y[0])}`);
        }
        return V ? ee.join(" ") : ee;
      },
    };
  },
  customer$3 = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      {
        label: { labelPos: F, labelColor: V },
      } = $,
      Y = generateBaseColorConf(V, F);
    T.label = {
      ...T.label,
      offset: 6,
      style: {
        ...T.label.style,
        fill: Y.color,
        stroke: Y.stroke,
        lineWidth: Y.strokeWidth,
        strokeOpacity: Y.strokeOpacity,
      },
      overlap: {
        ...T.label.overlap,
        clampForce: !0,
      },
      position: POSITION_MAP_SYMBOL[F],
    };
  },
  scatterLabelDataFilterCustomer = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      F = C.cells[0],
      {
        label: { labelType: V },
      } = $;
    V === LabelType.ENDPOINT
      ? labelDataFilterCustomer(
          {
            ...e,
            vizData: {
              ...C,
              displayConf: {
                ...$,
                label: {
                  ...$.label,
                  labelType: LabelType.EXTREMUM,
                },
              },
            },
          },
          T,
          F.x
        )
      : dataFilterCustomer$2(e, T);
  },
  scatterLabel = buildLabel([
    scatterFormatterCustomer,
    customer$3,
    scatterLabelDataFilterCustomer,
  ]),
  circleViewsLabel = buildLabel([circleViewsFormatterCustomer, customer$3]),
  formatterCustomer$2 = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V = F.displayConf,
      { labelContent: Y, allowWrappedDisplay: K } = V.label,
      J =
        null != ($ = null == (C = V.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT,
      ee = labelContentSankeyValueFormatter(Y, F, J, !K);
    T.label = {
      ...T.label,
      limit: 200,
      interactive: !1,
      formatMethod: ee,
    };
  },
  customer$2 = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V = F.displayConf,
      {
        label: { labelColor: Y },
      } = V,
      K = generateBaseColorConf(Y, LabelPos.OUTER);
    T.label = {
      ...T.label,
      style: {
        ...(null != ($ = null == (C = T.label) ? void 0 : C.style) ? $ : {}),
        fill: K.color,
        stroke: K.stroke,
        strokeOpacity: K.strokeOpacity,
        lineWidth: K.strokeWidth,
      },
    };
  },
  sankeyLabel = buildLabel([formatterCustomer$2, customer$2]),
  dataFilterCustomer$1 = (e) => (T, C) => {
    labelDataFilterCustomer(T, C, e, !0);
  },
  createFormatterCustomer = (e) => (T, C) => {
    var $, F;
    const { vizData: V } = T,
      Y = V.displayConf,
      { labelContent: K, allowWrappedDisplay: J, percentFormat: ee } = Y.label,
      te =
        null != (F = null == ($ = Y.specialValue) ? void 0 : $.measures)
          ? F
          : SpecialValueType$1.BRACKET_TXT,
      ie = labelContentValueFormatter(K, V, te, !J, ee, e);
    C.label = {
      ...C.label,
      formatMethod: ie,
    };
  },
  multiSeriesLabel = (e, T) => {
    var C, $, F, V, Y, K;
    const { vizData: J } = T,
      { chartType: ee } = J,
      te = J.cells[0],
      ie = e.series.find((e) => e.id === MAIN_SERIES_ID),
      ne =
        null != ($ = null == (C = J.displayConf.dualAxis) ? void 0 : C.main)
          ? $
          : ee,
      re = buildLabel([
        createFormatterCustomer(null == (F = te.y) ? void 0 : F[0]),
        labelCustomer$1,
        dataFilterCustomer$1(te.y),
      ])(
        ie,
        ee === ChartType.DUAL_AXIS
          ? {
              ...T,
              vizData: {
                ...J,
                chartType: ne,
              },
            }
          : T
      ),
      ae = e.series.find((e) => e.id === SUB_SERIES_ID),
      oe =
        null != (Y = null == (V = J.displayConf.dualAxis) ? void 0 : V.sub)
          ? Y
          : ee,
      se = ae
        ? buildLabel([
            createFormatterCustomer(null == (K = te.y) ? void 0 : K[1]),
            labelCustomer$1,
            dataFilterCustomer$1(te.y),
          ])(
            ae,
            ee === ChartType.DUAL_AXIS
              ? {
                  ...T,
                  vizData: {
                    ...J,
                    chartType: oe,
                  },
                }
              : T
          )
        : void 0;
    return {
      ...e,
      series: [re, se].filter(Boolean),
    };
  },
  dataFilterCustomer = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $;
    null == (C = e.indicators) ||
      C.forEach((e, C) => {
        const { chartSpec: V } = e,
          Y = F.combination.list[C],
          { chartType: K } = Y,
          J = $.cells.map((e) => e.y).flat();
        K === CombinationChartType.DUAL_AXIS
          ? V.series.forEach((e, C) => {
              labelDataFilterCustomer(T, e, J, !0);
            })
          : labelDataFilterCustomer(T, V, $.cells.map((e) => e.y).flat(), !0);
      });
  },
  labelCustomer = (e) => (T, C) => {
    var $;
    const { vizData: F } = T,
      V = F.displayConf,
      {
        label: {
          labelColor: Y,
          labelPos: K = LabelPos.AUTO,
          labelFont: J,
          labelWeight: ee,
        },
      } = V,
      te = K === LabelPos.AUTO ? getAutoPos(e) : K,
      ie = generateBaseColorConf(Y, te);
    C.label = {
      ...C.label,
      style: {
        ...C.label.style,
        boundsPadding: [1, 0, 0, 0],
        fill: ie.color,
        stroke: ie.stroke,
        lineWidth: ie.strokeWidth,
        strokeOpacity: ie.strokeOpacity,
        fontFamily: "inherit" === J ? "" : J,
        fontWeight: ee,
      },
      overlap: {
        ...C.label.overlap,
        clampForce: !0,
      },
      position: isSymbolLikeChart(e)
        ? POSITION_MAP_SYMBOL[K]
        : POSITION_MAP_AUTO_INSIDE[K],
      smartInvert: null != ($ = null == ie ? void 0 : ie.smartInverse) && $,
    };
  },
  combinationLabel = (e, T) => {
    const C = {
      ...e,
    };
    return (
      (C.indicators = e.indicators.map((e, C) => {
        var $, F;
        const { vizData: V, getTableChartLegendData: Y } = T,
          { displayConf: K } = V,
          {
            labelContent: J,
            allowWrappedDisplay: ee,
            labelMode: te = LabelMode.SINGLE,
            percentFormat: ie,
          } = K.label,
          ne =
            null != (F = null == ($ = K.specialValue) ? void 0 : $.measures)
              ? F
              : SpecialValueType$1.BRACKET_TXT,
          re = isLabelTotalMode(te, V.chartType),
          { chartSpec: ae } = e,
          oe = K.combination.list[C],
          { chartType: se } = oe;
        if (se === CombinationChartType.DUAL_AXIS) {
          const $ = ae.series.map((e, $) => {
            var F;
            const K = buildLabel([labelCustomer(e.type)]),
              { label: te } = K(e, T),
              ae = V.cells[C],
              oe = null == (F = null == ae ? void 0 : ae.y) ? void 0 : F[$],
              se = re
                ? labelContentTotalFormatter(V, ne, Y)
                : labelContentValueFormatter(J, V, ne, !ee, ie, oe);
            return {
              ...e,
              label: {
                ...te,
                formatMethod: se,
              },
            };
          });
          return {
            ...e,
            chartSpec: {
              ...ae,
              series: [...$],
            },
          };
        }
        {
          const C = buildLabel([labelCustomer(se)]),
            { label: $ } = C(ae, T),
            F = re
              ? labelContentTotalFormatter(V, ne, Y)
              : labelContentValueFormatter(J, V, ne, !ee, ie);
          return {
            ...e,
            chartSpec: {
              ...ae,
              label: {
                ...$,
                formatMethod: F,
              },
            },
          };
        }
      })),
      dataFilterCustomer(C, T),
      C
    );
  },
  formatterCustomer$1 = (e) => (T, C) => {
    var $, F;
    const { vizData: V } = T,
      Y = V.displayConf,
      { funnel: K } = Y,
      { labelContent: J, allowWrappedDisplay: ee } = Y.label,
      te =
        null != (F = null == ($ = Y.specialValue) ? void 0 : $.measures)
          ? F
          : SpecialValueType$1.BRACKET_TXT,
      ie = funnelLayerFormatter(J, V, te, !ee, e);
    C.label.formatMethod = ie;
    const ne = funnelAuxiliaryLabelsFormatter(K.layerVisible, V, te);
    (C.outerLabel.formatMethod = ne),
      (C.transformLabel.formatMethod = (e, T) =>
        (100 * T[VCHART_FUNNEL_REACH_RATIO]).toFixed(2) + "%");
  },
  customer$1 = (e, T) => {
    var C;
    const { vizData: $ } = e,
      F = $.displayConf,
      {
        label: { labelContent: V, labelColor: Y, visible: K },
      } = F,
      J = generateBaseColorConf(Y, LabelPos.INNER);
    T.label = {
      ...T.label,
      visible:
        K &&
        (V.includes(LabelContent.NUMBER) ||
          V.includes(LabelContent.BASE_TRANSFER)),
      style: {
        ...T.label.style,
        fill: J.color,
        stroke: J.stroke,
        lineWidth: J.strokeWidth,
        strokeOpacity: J.strokeOpacity,
      },
      overlap: {
        ...T.label.overlap,
        clampForce: !0,
      },
      smartInvert: null != (C = null == J ? void 0 : J.smartInverse) && C,
    };
  },
  outerLabelCustomer = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      { funnel: F } = $;
    T.outerLabel = {
      ...T.outerLabel,
      visible: F.layerVisible,
      style: {
        fontSize: F.layerSize,
        fill: F.layerColor,
      },
      line: {
        style: {
          stroke: "#9ca0b1",
        },
      },
    };
  },
  funnelLabel = (e, T) => {
    var C;
    const { vizData: $ } = T,
      F = $.cells[0],
      V = String(null == (C = F.size) ? void 0 : C[0]);
    return buildLabel([customer$1, outerLabelCustomer, formatterCustomer$1(V)])(
      e,
      T
    );
  },
  formatterCustomer = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      { displayConf: V } = F,
      {
        label: { labelContent: Y, allowWrappedDisplay: K },
      } = V,
      J =
        null != ($ = null == (C = V.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT,
      ee = labelContentMapValueFormatter(Y, F, J, !K);
    T.label = {
      ...T.label,
      formatMethod: ee,
    };
  },
  customer = (e, T) => {
    var C, $, F, V, Y, K;
    const { vizData: J } = e,
      ee = J.displayConf,
      {
        label: {
          labelColor: te,
          labelPos: ie = LabelPos.INNER,
          labelFont: ne,
          labelWeight: re,
        },
      } = ee,
      ae = generateBaseColorConf(te, ie);
    T.label = {
      ...T.label,
      clampForce: !0,
      limit: "",
      position: POSITION_MAP_AUTO_INSIDE_MIDDLE[ie],
      smartInvert: null != (C = null == ae ? void 0 : ae.smartInverse) && C,
      style: {
        ...(null != (F = null == ($ = T.label) ? void 0 : $.style) ? F : {}),
        fontFamily: ne,
        fontWeight: re,
        fill: null != (V = ae.color) ? V : "#fff",
        stroke: null != (Y = ae.stroke) ? Y : null,
        strokeOpacity: ae.strokeOpacity,
        lineWidth: null != (K = ae.strokeWidth) ? K : 1,
      },
    };
  },
  mapLabel = buildLabel([formatterCustomer, customer]),
  scatterMapLabel = (e, T) => {
    const C = e.series.find((e) => "map" === e.type),
      $ = e.series.find((e) => "scatter" === e.type),
      F = buildLabel([formatterCustomer, customer])(C, T);
    return {
      ...e,
      series: [F, $],
    };
  },
  bilateralLayout = (e, { vizData: T }) => {
    const C = T.displayConf,
      { legendPos: $, visible: F } = C.legend,
      V = {
        type: "grid",
        row: 0,
        col: 0,
        elements: [],
      };
    $ === LegendPos.TOP
      ? ((V.row = F ? 3 : 2),
        (V.col = 3),
        (V.elements = [
          {
            modelId: `${LEGEND_ID}-discrete`,
            col: 0,
            colSpan: 3,
            row: 0,
          },
          {
            modelId: MAIN_REGION_ID,
            col: 0,
            row: F ? 1 : 0,
          },
          {
            modelId: DIMENSION_AXIS_ID,
            col: 1,
            row: F ? 1 : 0,
          },
          {
            modelId: SUB_REGION_ID,
            col: 2,
            row: F ? 1 : 0,
          },
          {
            modelId: MEASURE_AXIS_LEFT_ID,
            col: 0,
            row: F ? 2 : 1,
          },
          {
            modelId: MEASURE_AXIS_RIGHT_ID,
            col: 2,
            row: F ? 2 : 1,
          },
        ]))
      : $ === LegendPos.BOTTOM
      ? ((V.row = F ? 3 : 2),
        (V.col = 3),
        (V.elements = [
          {
            modelId: MAIN_REGION_ID,
            col: 0,
            row: 0,
          },
          {
            modelId: DIMENSION_AXIS_ID,
            col: 1,
            row: 0,
          },
          {
            modelId: SUB_REGION_ID,
            col: 2,
            row: 0,
          },
          {
            modelId: MEASURE_AXIS_LEFT_ID,
            col: 0,
            row: 1,
          },
          {
            modelId: MEASURE_AXIS_RIGHT_ID,
            col: 2,
            row: 1,
          },
          {
            modelId: `${LEGEND_ID}-discrete`,
            col: 0,
            colSpan: 3,
            row: 2,
          },
        ]))
      : $ === LegendPos.LEFT
      ? ((V.row = 2),
        (V.col = F ? 4 : 3),
        (V.elements = [
          {
            modelId: `${LEGEND_ID}-discrete`,
            col: 0,
            row: 0,
            rowSpan: 2,
          },
          {
            modelId: MAIN_REGION_ID,
            col: F ? 1 : 0,
            row: 0,
          },
          {
            modelId: DIMENSION_AXIS_ID,
            col: F ? 2 : 1,
            row: 0,
          },
          {
            modelId: SUB_REGION_ID,
            col: F ? 3 : 2,
            row: 0,
          },
          {
            modelId: MEASURE_AXIS_LEFT_ID,
            col: F ? 1 : 0,
            row: 1,
          },
          {
            modelId: MEASURE_AXIS_RIGHT_ID,
            col: F ? 3 : 2,
            row: 1,
          },
        ]))
      : $ === LegendPos.RIGHT &&
        ((V.row = 2),
        (V.col = F ? 4 : 3),
        (V.elements = [
          {
            modelId: MAIN_REGION_ID,
            col: 0,
            row: 0,
          },
          {
            modelId: DIMENSION_AXIS_ID,
            col: 1,
            row: 0,
          },
          {
            modelId: SUB_REGION_ID,
            col: 2,
            row: 0,
          },
          {
            modelId: `${LEGEND_ID}-discrete`,
            col: 3,
            row: 0,
            rowSpan: 2,
          },
          {
            modelId: MEASURE_AXIS_LEFT_ID,
            col: 0,
            row: 1,
          },
          {
            modelId: MEASURE_AXIS_RIGHT_ID,
            col: 2,
            row: 1,
          },
        ]));
    const Y = e.series.find((e) => e.id === MAIN_SERIES_ID);
    Y && ((Y.direction = "horizontal"), (Y.regionId = MAIN_REGION_ID));
    const K = e.series.find((e) => e.id === SUB_SERIES_ID);
    return (
      K && ((K.direction = "horizontal"), (K.regionId = SUB_REGION_ID)),
      {
        ...e,
        region: [
          {
            id: MAIN_REGION_ID,
          },
          {
            id: SUB_REGION_ID,
          },
        ],
        layout: V,
      }
    );
  },
  commonLayout = (e) => ({
    ...e,
    padding: 0,
    labelLayout: "region",
  }),
  discreteLegendCustomer = (e, T, C) => {
    var $, F;
    const { vizData: V } = e,
      { displayConf: Y } = V;
    (
      null ==
      (F =
        null == ($ = null == Y ? void 0 : Y.color)
          ? void 0
          : $.conditionalConfig)
        ? void 0
        : F.length
    )
      ? (T.legends = [
          ...T.legends,
          {
            type: LEGEND_TYPE.DISCRETE,
            visible: C,
            data: () =>
              conditionalConfigToLegendConfig(
                Y.color.conditionalConfig,
                Y.color.vizField.displayName
              ),
            select: !1,
            hover: !1,
          },
        ])
      : (T.legends = [
          ...T.legends,
          {
            type: LEGEND_TYPE.DISCRETE,
            visible: C,
          },
        ]);
  },
  discreteLegend$4 = {
    isEnabled: (e) => {
      var T, C, $, F, V, Y;
      const {
          vizData: { cells: K, fieldMap: J, displayConf: ee, chartType: te },
        } = e,
        ie = K[0],
        ne = null == (T = ie.color) ? void 0 : T[0];
      if (
        (null ==
        ($ =
          null == (C = null == ee ? void 0 : ee.color)
            ? void 0
            : C.conditionalConfig)
          ? void 0
          : $.length) &&
        ne &&
        te !== ChartType.SANKEY
      )
        return !0;
      const re =
        (null ==
        (Y = J[null != (V = null == (F = ie.color) ? void 0 : F[0]) ? V : ""])
          ? void 0
          : Y.role) === Role.MEASURE;
      return !!ne && !re;
    },
    customer: discreteLegendCustomer,
  },
  colorLegend$3 = {
    isEnabled: (e) => {
      var T, C, $, F, V, Y;
      const {
        vizData: { cells: K, fieldMap: J, displayConf: ee },
      } = e;
      if (
        null ==
        (C =
          null == (T = null == ee ? void 0 : ee.color)
            ? void 0
            : T.conditionalConfig)
          ? void 0
          : C.length
      )
        return !1;
      const te = K[0],
        ie = null == ($ = te.color) ? void 0 : $[0],
        ne =
          (null ==
          (Y = J[null != (V = null == (F = te.color) ? void 0 : F[0]) ? V : ""])
            ? void 0
            : Y.role) === Role.MEASURE;
      return !!ie && ne;
    },
    customer: (e, T, C) => {
      var $, F;
      const {
          vizData: { fieldMap: V, cells: Y, displayConf: K },
        } = e,
        J = null != (F = null == ($ = Y[0].color) ? void 0 : $[0]) ? F : "",
        ee = {
          type: LEGEND_TYPE.COLOR,
          visible: C,
          slidable: !0,
          title: V[J].alias,
        };
      if (K.color.colorsLinear[0]) {
        const e = K.color.colorsLinear.map((e) => e.value);
        lodash.exports.isNumber(e[0]) && (ee.min = e[0]),
          lodash.exports.isNumber(e[e.length - 1]) &&
            (ee.max = e[e.length - 1]);
      }
      T.legends = [...T.legends, ee];
    },
  },
  discreteLegendMaxHeight = (e, T) => {
    const C = T.legends.find((e) => e.type === LEGEND_TYPE.DISCRETE),
      $ = T.legends.find((e) => e.type === LEGEND_TYPE.SIZE),
      F = T.legends.find((e) => e.type === LEGEND_TYPE.COLOR);
    ($ || F) &&
      C &&
      (C.maxHeight = ({ height: e }) => {
        var T, V;
        if (e > 200) {
          return Math.max(
            0,
            e -
              C.padding.top -
              C.padding.bottom -
              ($ && $.padding
                ? $.padding.bottom +
                  $.padding.top +
                  (null != (T = $.maxHeight) ? T : 0)
                : 0) -
              (F && F.padding
                ? F.padding.bottom +
                  F.padding.top +
                  (null != (V = F.maxHeight) ? V : 0)
                : 0)
          );
        }
      });
  },
  legend = buildLegend(
    [discreteLegend$4, colorLegend$3],
    [discreteLegendMaxHeight]
  ),
  discreteLegend$3 = {
    isEnabled: (e) => {
      var T, C;
      const { vizData: $ } = e,
        { fieldMap: F, displayConf: V } = $,
        Y = Object.keys(F).find((e) => F[e].location === Location.COLOR);
      return (
        !(
          !(null ==
          (C =
            null == (T = null == V ? void 0 : V.color)
              ? void 0
              : T.conditionalConfig)
            ? void 0
            : C.length) || !Y
        ) ||
        (!!Y && F[Y].role === Role.DIMENSION)
      );
    },
    customer: (e, T) => {
      var C, $;
      const { vizData: F } = e,
        { fieldMap: V, displayConf: Y } = F,
        K = Object.keys(V).find((e) => V[e].location === Location.COLOR),
        J = {
          type: LEGEND_TYPE.DISCRETE,
        };
      (null ==
      ($ =
        null == (C = null == Y ? void 0 : Y.color)
          ? void 0
          : C.conditionalConfig)
        ? void 0
        : $.length) &&
        K &&
        ((J.data = () =>
          conditionalConfigToLegendConfig(
            Y.color.conditionalConfig,
            Y.color.vizField.displayName
          )),
        (J.select = !1),
        (J.hover = !1)),
        T.legends.push(J);
    },
  },
  colorLegend$2 = {
    isEnabled: (e) => {
      var T, C;
      const { vizData: $ } = e,
        { fieldMap: F, displayConf: V } = $,
        Y = Object.keys(F).find((e) => F[e].location === Location.COLOR);
      return (
        !(null ==
        (C =
          null == (T = null == V ? void 0 : V.color)
            ? void 0
            : T.conditionalConfig)
          ? void 0
          : C.length) &&
        (!Y || F[Y].role === Role.MEASURE)
      );
    },
    customer: (e, T) => {
      var C, $, F, V, Y, K;
      const { vizData: J } = e,
        ee = J.displayConf,
        { fieldMap: te, cells: ie } = J,
        ne = ie[0],
        { legendPos: re, lines: ae } = ee.legend,
        oe =
          null !=
          (C = Object.keys(te).find((e) => te[e].location === Location.MEASURE))
            ? C
            : "",
        se = getFieldFormat(oe, J, "field"),
        { specialValue: le } = ee,
        de =
          INVALID_VALUE_MAP$5[
            null != ($ = null == le ? void 0 : le.dimensions)
              ? $
              : SpecialValueType$1.BRACKET_TXT
          ],
        ce = se ? createFormatter(se, de) : void 0,
        ue = {
          type: LEGEND_TYPE.COLOR,
          interactive: !0,
          margin: {
            left: 8,
            right: 8,
          },
          title: {
            visible: !0,
            space: 0,
            style: {
              text:
                null !=
                (K =
                  null ==
                  (Y =
                    te[
                      null != (V = null == (F = ne.value) ? void 0 : F[0])
                        ? V
                        : ""
                    ])
                    ? void 0
                    : Y.alias)
                  ? K
                  : void 0,
            },
          },
          handlerText: {
            formatter: ce,
          },
          ...formatLines(re, null != ae ? ae : 0),
        };
      T.legends.push(ue);
    },
  },
  mapCustomer = (e, T) => {
    const { vizData: C } = e,
      $ = C.displayConf,
      { background: F } = $.legend;
    T.legends.forEach((e) => {
      e.background = {
        visible: !0,
        style: {
          fill: null == F ? void 0 : F.color,
          fillOpacity: null == F ? void 0 : F.opacity,
          padding: {
            top: 6,
            bottom: 4,
          },
        },
      };
    });
  },
  mapLegend = buildLegend(
    [discreteLegend$3, colorLegend$2],
    [mapCustomer, absoluteLayoutCustomer]
  ),
  discreteLegend$2 = {
    isEnabled: () => !0,
    customer: (e, T) => {
      const { vizData: C } = e;
      T.legends = [
        ...T.legends,
        {
          type: LEGEND_TYPE.DISCRETE,
          item: {
            label: {
              formatMethod: (e) => {
                var T;
                const $ = partialSplit(e, "-", 2);
                return createFormatter(
                  null == (T = C.fieldMap[$[0]]) ? void 0 : T.format
                )(partialSplit(e, "-", 2)[1]);
              },
            },
          },
        },
      ];
    },
  },
  sankeyLegend = buildLegend([discreteLegend$2]),
  INVALID_VALUE_MAP$2 = {
    [SpecialValueType$1.BRACKET_TXT]: " ",
    [SpecialValueType$1.NULL]: "NULL",
    [SpecialValueType$1.ZERO]: "0",
    [SpecialValueType$1.DASH]: "--",
    [SpecialValueType$1.TrueNull]: "aeolus-null",
  },
  legendContentValueFormat = (e, T, C) => ($) => {
    const F = getFieldFormat(e, T, "field"),
      V = createFormatter(F, INVALID_VALUE_MAP$2[C]);
    return Number.isNaN(+$) ? NaN : V(+$);
  },
  discreteLegend$1 = {
    isEnabled: (e) => {
      var T, C, $, F, V;
      const {
        vizData: { cells: Y, fieldMap: K, displayConf: J },
      } = e;
      if (
        null ==
        (C =
          null == (T = null == J ? void 0 : J.color)
            ? void 0
            : T.conditionalConfig)
          ? void 0
          : C.length
      )
        return !0;
      const ee = Y[0],
        te = null == ($ = ee.color) ? void 0 : $[0],
        ie =
          (null == (V = K[null == (F = ee.color) ? void 0 : F[0]])
            ? void 0
            : V.role) === Role.MEASURE;
      return !!te && !ie;
    },
    customer: discreteLegendCustomer,
  },
  colorLegend$1 = {
    isEnabled: (e) => {
      var T, C, $, F, V;
      const {
        vizData: { cells: Y, fieldMap: K, displayConf: J },
      } = e;
      if (
        null ==
        (C =
          null == (T = null == J ? void 0 : J.color)
            ? void 0
            : T.conditionalConfig)
          ? void 0
          : C.length
      )
        return !1;
      const ee = Y[0],
        te = null == ($ = ee.color) ? void 0 : $[0],
        ie =
          (null == (V = K[null == (F = ee.color) ? void 0 : F[0]])
            ? void 0
            : V.role) === Role.MEASURE;
      return !!te && ie;
    },
    customer: (e, T) => {
      var C;
      const {
          vizData: { fieldMap: $, cells: F },
        } = e,
        V = null == (C = F[0].color) ? void 0 : C[0],
        Y = {
          type: LEGEND_TYPE.COLOR,
          slidable: !0,
          title: {
            visible: !0,
            text: $[V].alias,
          },
        };
      T.legends = [...T.legends, Y];
    },
  },
  sizeLegend$1 = {
    isEnabled: (e) => {
      var T;
      const {
        vizData: { cells: C, displayConf: $ },
      } = e;
      if ($.color.conditionalConfig) return !1;
      return !!(null == (T = C[0].size) ? void 0 : T[0]);
    },
    customer: (e, T, C) => {
      var $;
      const {
          vizData: { fieldMap: F, cells: V },
        } = e,
        Y = null == ($ = V[0].size) ? void 0 : $[0],
        K = {
          type: LEGEND_TYPE.SIZE,
          slidable: !0,
          visible: C,
          title: {
            visible: !0,
            text: F[Y].alias,
          },
          handlerText: {},
        };
      T.legends = [...T.legends, K];
    },
  },
  labelStyleCustomer = (e, T) => {
    var C, $;
    const { vizData: F } = e,
      V =
        null !=
        ($ = null == (C = F.displayConf.specialValue) ? void 0 : C.measures)
          ? $
          : SpecialValueType$1.BRACKET_TXT,
      Y = T.legends.find((e) => e.type === LEGEND_TYPE.COLOR);
    if (Y) {
      const { fieldMap: e } = F,
        T = Object.keys(e).find((T) => e[T].location === Location.COLOR),
        C = legendContentValueFormat(T, F, V);
      Y.handlerText = {
        ...Y.handlerText,
        formatter: C,
      };
    }
    const K = T.legends.find((e) => e.type === LEGEND_TYPE.SIZE);
    if (K) {
      const { fieldMap: e } = F,
        T = Object.keys(e).find((T) => e[T].location === Location.SIZE),
        C = legendContentValueFormat(T, F, V);
      K.handlerText = {
        ...K.handlerText,
        formatter: C,
      };
    }
  },
  scatterLegend = buildLegend(
    [discreteLegend$1, colorLegend$1, sizeLegend$1],
    [labelStyleCustomer, discreteLegendMaxHeight]
  ),
  discreteLegend = {
    isEnabled: (e) => {
      const {
          vizData: { fieldMap: T },
        } = e,
        C = Object.keys(T).find((e) => T[e].location === Location.COLOR);
      return !!C && T[C].role === Role.DIMENSION;
    },
    customer: (e, T) => {
      T.legends.push({
        seriesId: SCATTER_MAP_SCATTER_SERIES_ID,
        scale: SCATTER_MAP_POINT_COLOR_SCALE_ID,
        type: LEGEND_TYPE.DISCRETE,
      });
    },
  },
  colorLegend = {
    isEnabled: (e) => {
      const {
          vizData: { fieldMap: T },
        } = e,
        C = Object.keys(T).find((e) => T[e].location === Location.COLOR);
      return !C || T[C].role === Role.MEASURE;
    },
    customer: (e, T) => {
      var C, $, F;
      const { vizData: V } = e,
        Y = V.displayConf,
        { cells: K, fieldMap: J } = V,
        { legendPos: ee, lines: te } = Y.legend,
        ie = K[0],
        ne = Object.keys(J).find((e) => J[e].location === Location.COLOR),
        re = Object.keys(J).find((e) => J[e].location === Location.MEASURE),
        ae = getFieldFormat(null != re ? re : "", V, "field"),
        oe = ae ? createFormatter(ae) : void 0;
      T.legends.push({
        type: LEGEND_TYPE.COLOR,
        ...formatLines(ee, null != te ? te : 0),
        title: {
          visible: !0,
          text:
            ne && J[ne].role === Role.MEASURE
              ? null ==
                (F =
                  J[
                    null != ($ = null == (C = ie.color) ? void 0 : C[0])
                      ? $
                      : ""
                  ])
                ? void 0
                : F.alias
              : void 0,
        },
        seriesId: SCATTER_MAP_SCATTER_SERIES_ID,
        scale: SCATTER_MAP_POINT_COLOR_SCALE_ID,
        handlerText: {
          formatter: oe,
        },
      });
    },
  },
  sizeLegend = {
    isEnabled: () => !0,
    customer: (e, T) => {
      var C, $;
      const { vizData: F } = e,
        { fieldMap: V, cells: Y } = F,
        K = Y[0],
        J = Object.keys(V).find((e) => V[e].location === Location.MEASURE),
        ee = getFieldFormat(null != J ? J : "", F, "field"),
        te = ee ? createFormatter(ee) : void 0;
      T.legends.push({
        type: LEGEND_TYPE.SIZE,
        title: {
          visible: !0,
          text: V[null != ($ = null == (C = K.size) ? void 0 : C[0]) ? $ : ""]
            .alias,
        },
        handlerText: {
          formatter: te,
        },
      });
    },
  },
  scatterMapLegend = buildLegend(
    [colorLegend, sizeLegend, discreteLegend],
    [mapCustomer]
  ),
  tableChartLegend = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { displayConf: V } = F,
      { legend: Y } = V,
      { legendPos: K, visible: J } = Y;
    if (!J || !isTableChart(F)) return e;
    const ee = getDataItemsColorMap(V.color, getColorItems(F)),
      te = {
        ...(null != ($ = null == (C = e.legends) ? void 0 : C[0]) ? $ : {}),
        data: Array.from(ee).map(([e, T]) => ({
          label: e,
          shape: {
            fill: T,
            stroke: T,
            symbolType: "square",
          },
        })),
        padding: getLegendsPadding(K),
      };
    return {
      ...e,
      legends: te,
    };
  },
  getLegendsPadding = (e) =>
    e === LegendPos.BOTTOM
      ? [16, 0, 0, 0]
      : e === LegendPos.TOP
      ? [0, 0, 16, 0]
      : e === LegendPos.LEFT
      ? [0, 16, 0, 0]
      : e === LegendPos.RIGHT
      ? [0, 0, 16, 16]
      : [0, 0, 0, 0],
  location = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      {
        location: { isFixed: F, zoom: V, coordinate: Y },
      } = $;
    return {
      ...C,
      region: [
        {
          coordinate: "geo",
          roam: !F,
          zoomLimit: {
            min: 0,
            max: 100,
          },
          projection: {
            zoom: V,
            center: Y,
          },
        },
      ],
    };
  },
  scatterMapColor = (e, T) => {
    var C, $, F;
    const V = {
        ...e,
      },
      Y = V.series.find((e) => "scatter" === e.type),
      K = V.series.find((e) => "map" === e.type),
      J = generatePointColor(Y, T),
      ee = [
        K,
        {
          ...Y,
          point: {
            ...(null != (C = null == Y ? void 0 : Y.point) ? C : {}),
            style: {
              ...(null !=
              (F =
                null == ($ = null == Y ? void 0 : Y.point) ? void 0 : $.style)
                ? F
                : {}),
              fill: {
                scale: SCATTER_MAP_POINT_COLOR_SCALE_ID,
                field: J.field,
              },
              fillOpacity: 0.9,
              lineWidth: 0,
            },
          },
        },
      ];
    return {
      ...V,
      series: ee,
      scales: [J],
    };
  },
  generatePointColor = (e, T) => {
    var C, $, F, V, Y, K;
    const { vizData: J } = T,
      { fieldMap: ee } = J,
      { displayConf: te } = J,
      ie = J.cells[0],
      ne = Object.keys(ee).find((e) => ee[e].location === Location.COLOR),
      re = [
        {
          dataId: CHART_DATA_ID,
          fields: [
            null == (C = null == ie ? void 0 : ie.color) ? void 0 : C[0],
          ],
        },
      ];
    if (!ne || ee[ne].role === Role.MEASURE)
      return {
        id: SCATTER_MAP_POINT_COLOR_SCALE_ID,
        domain: re,
        type: "linear",
        field: null == ($ = null == ie ? void 0 : ie.color) ? void 0 : $[0],
        range: [
          ...(null != (V = null == (F = te.color) ? void 0 : F.colorsLinear)
            ? V
            : []),
        ],
      };
    const ae = null == (Y = color(e, T)) ? void 0 : Y.color;
    return {
      id: SCATTER_MAP_POINT_COLOR_SCALE_ID,
      domain: re,
      type: "ordinal",
      field: null == (K = null == ie ? void 0 : ie.color) ? void 0 : K[0],
      range: lodash.exports.isString(ae) ? [ae] : ae.range,
      specified: null == ae ? void 0 : ae.specified,
    };
  },
  scatterMapSize = (e, { vizData: T }) => {
    var C, $, F;
    const V = {
        ...e,
      },
      { displayConf: Y } = T,
      K = T.cells[0],
      J = null != ($ = null == (C = Y.size) ? void 0 : C.range) ? $ : [2, 32],
      ee = {
        ...V.series.find((e) => "scatter" === e.type),
        sizeField: null == (F = null == K ? void 0 : K.size) ? void 0 : F[0],
        size: {
          type: "linear",
          range: J.map(chartSpaceSizeToVChartSize),
        },
      },
      te = V.series.find((e) => "map" === e.type);
    return {
      ...V,
      series: [te, ee],
    };
  },
  percent = (e, { vizData: T }) => {
    const { chartType: C } = T;
    return [
      ChartType.COLUMN_PERCENT,
      ChartType.BAR_PERCENT,
      ChartType.AREA_PERCENT,
    ].includes(C)
      ? {
          ...e,
          percent: !0,
        }
      : e;
  },
  buildIndicatorAsCol = (e, T) => {
    var C;
    const { vizData: $ } = T,
      F = !!(null != (C = null == e ? void 0 : e.indicatorsAsCol)
        ? C
        : isHorizontalBar($));
    return {
      ...e,
      indicatorsAsCol: F,
    };
  },
  buildHeader = (e, T, C, $ = 0, F) => {
    if (lodash.exports.isNil(e) || lodash.exports.isEmpty(e)) return [];
    const { cells: V } = T,
      { foldInfo: Y } = V[0],
      K = null == Y ? void 0 : Y.foldMap,
      J = [],
      ee = (e) => {
        F.count < F.limit && (J.push(e), F.count++);
      };
    return (
      null == e ||
        e.values.forEach(({ field: V, value: J, child: te }) => {
          const ie = buildHeader(te, T, C, $ + 1, F);
          if (
            (null == e ? void 0 : e.field.toString()) ===
            (null == Y ? void 0 : Y.key)
          ) {
            const e = {
              indicatorKey: null != V ? V : lodash.exports.findKey(K, J),
              value: J,
              children: ie.length > 0 ? lodash.exports.cloneDeep(ie) : void 0,
            };
            ee(e);
          } else {
            const T = {
              dimensionKey: null == e ? void 0 : e.field.toString(),
              value: J,
              children: ie.length > 0 ? lodash.exports.cloneDeep(ie) : void 0,
            };
            ee(T);
          }
        }),
      J
    );
  },
  genPivotChartTree = (e) => {
    const { colPivotTree: T, rowPivotTree: C } = e,
      { column: $ = [], row: F = [] } = e.cells[0],
      V = {
        limit: 1e4,
        count: 0,
      },
      Y = buildHeader(T, e, null != $ ? $ : [], 0, V),
      K = buildHeader(C, e, null != F ? F : [], 0, V);
    return {
      columns: Y.length > 0 ? Y : [],
      rows: K.length > 0 ? K : [],
    };
  },
  pivot = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { displayConf: V } = F;
    if (!isPivot(F)) return e;
    if (!V.pivot) return e;
    const { columns: Y, rows: K } = genPivotChartTree(F),
      J = {
        widthMode: "adaptive",
        heightMode: "adaptive",
        columnTree: Y,
        rowTree: K,
        columns: buildDimensions(F, "column"),
        rows: buildDimensions(F, "row"),
        axes: null != (C = null == e ? void 0 : e.axes) ? C : [],
        indicators: buildIndicators(e),
        indicatorsAsCol: e.indicatorsAsCol,
        records: null != ($ = e.records) ? $ : F.datasets.flat(3),
        indicatorTitle: "",
        autoWrapText: !0,
        legends: e.legends,
        tooltip: {
          isShowOverflowTextTooltip: !0,
        },
        eventOptions: {
          preventDefaultContextMenu: !1,
        },
      };
    return [
      buildIndicatorAsCol,
      buildRowTitle,
      buildColTitle,
      buildDefaultHeaderColWidth,
    ].reduce((e, C) => C(e, T), J);
  },
  centerValue = (e, T) => {
    var C, $, F, V, Y, K, J, ee;
    const { vizData: te, measureText: ie } = T,
      { containerHeight: ne = 370, containerWidth: re = 370 } = T,
      ae = {
        ...e,
      };
    if (!canEnable(te)) return ae;
    const { cells: oe, fieldMap: se } = te,
      { displayConf: le } = te,
      { centerValue: de } = le,
      { default: ce, totalText: ue, type: he, valueFormatType: pe } = de,
      ge = (null == (C = e.data[0]) ? void 0 : C.values) || [],
      { valueField: fe, categoryField: me } = e,
      ye =
        null != (F = null == ($ = le.specialValue) ? void 0 : $.measures)
          ? F
          : SpecialValueType$1.BRACKET_TXT,
      be = getFields(te, Location.MEASURE, isRenderField)[0],
      ve = getFieldFormat(be, te, "label"),
      Te = null == (Y = null == (V = oe[0]) ? void 0 : V.color) ? void 0 : Y[0],
      _e = Te
        ? null == (K = null == se ? void 0 : se[Te])
          ? void 0
          : K.format
        : null,
      Ce = {
        displayTitle: "",
        displayValue: "",
      },
      Ae = ge.map((e) => e[fe]);
    if (Ae.every((e) => lodash.exports.isNil(e) || 0 === Number(e))) return ae;
    const xe = Ae.reduce(
      (e, T) => e + (T && !isNaN(Number(T)) ? Number(T) : 0),
      0
    );
    if (he === PieCenterValueType.TOTAL)
      (Ce.displayTitle = null != ue ? ue : ""),
        (Ce.displayValue = String(xe)),
        pe === PieCenterValueFormatType.PERCENT && (Ce.displayValue = "100%");
    else {
      Ce.displayTitle = null != ce ? ce : "";
      const e = ge.find((e) => e[me] === ce);
      if (e) {
        const T = e[fe];
        pe === PieCenterValueFormatType.NUMBER
          ? lodash.exports.isNil(T) || isNaN(Number(T))
            ? (Ce.displayValue = "")
            : (Ce.displayValue = String(T))
          : pe === PieCenterValueFormatType.PERCENT &&
            (!xe || lodash.exports.isNil(T) || isNaN(Number(T))
              ? (Ce.displayValue = "")
              : (Ce.displayValue = `${((Number(T) / xe) * 100).toFixed(2)}%`));
      }
      (lodash.exports.isNil(Ce.displayValue) ||
        lodash.exports.isEmpty(Ce.displayValue)) &&
        (Ce.displayValue = "--");
    }
    const Se = createFormatter(_e)(Ce.displayTitle),
      Re = createFormatter(ve, INVALID_VALUE_MAP$5[ye])(Ce.displayValue),
      { titleFontSize: Me, valueFontSize: Pe } = autoFontSize(
        (Math.min(ne, re) / 2) * ae.innerRadius,
        Se,
        Re,
        "number" == typeof de.titleSize ? de.titleSize : null,
        "number" == typeof de.valueSize ? de.valueSize : null,
        ie
      );
    return (
      (ae.indicator = {
        visible: !0,
        fixed: !0,
        title: {
          visible: !0,
          space: 8,
          style: {
            text: Se,
            fill: de.titleColor,
            fontSize: de.titleSize !== FONTSIZE_AUTO ? de.titleSize : Me,
            fontWight: null != (J = de.titleWeight) ? J : 700,
            fontFamily: de.titleFamily
              ? "inherit" === de.titleFamily
                ? ""
                : de.titleFamily
              : "system-ui",
          },
        },
        content: [
          {
            visible: !0,
            style: {
              text: Re,
              fill: de.valueColor,
              fontSize: de.valueSize !== FONTSIZE_AUTO ? de.valueSize : Pe,
              fontWight: null != (ee = de.valueWeight) ? ee : 700,
              fontFamily: de.valueFamily
                ? "inherit" === de.valueFamily
                  ? ""
                  : de.valueFamily
                : `Byte Number,${FONT_FAMILY}`,
            },
          },
        ],
      }),
      ae
    );
  },
  autoFontSize = (e = 370, T = "", C = "", $, F, V) => {
    const Y = $ || calcFontSizeUseBinarySearch(C, 20, 72, 2 * e * 0.5, V),
      K = F || calcFontSizeUseBinarySearch(T, 12, 56, 2 * e * 0.5, V),
      J = {
        titleFontSize: 0,
        valueFontSize: 0,
      },
      ee = K < Y;
    return (
      $ || F
        ? $
          ? F || (J.titleFontSize = Y)
          : (J.titleFontSize = K)
        : ee
        ? ((J.titleFontSize = K), (J.valueFontSize = K / 0.6))
        : ((J.valueFontSize = Y), (J.titleFontSize = 0.6 * Y)),
      (J.valueFontSize = Math.min(72, Math.max(20, J.valueFontSize))),
      (J.titleFontSize = Math.min(56, Math.max(12, J.titleFontSize))),
      J
    );
  },
  calcFontSizeUseBinarySearch = (e, T, C, $, F) => {
    let V = Math.floor((T + C) / 2);
    for (; T <= C; ) {
      const { width: Y } = F(e, {
        fontSize: V,
        fontWeight: 700,
      });
      if (V <= T || V >= C) break;
      Y <= $ ? (T = V + 1) : (C = V - 1), (V = Math.floor((T + C) / 2));
    }
    return V;
  },
  canEnable = (e) => {
    const { displayConf: T, chartType: C } = e;
    return (
      C === ChartType.ANNULAR && !!T.centerValue && !!T.centerValue.visible
    );
  },
  orderBy = (e, T, C) => {
    const $ = e.slice(),
      F = T.length;
    return (
      $.sort(
        (e, $) =>
          ((e) => {
            const C = T.indexOf(e);
            return -1 !== C ? C : C + F;
          })(e[C]) - T.indexOf($[C])
      ),
      $
    );
  },
  polarMerge = (e, T) => {
    const C = {
        ...e,
      },
      $ = e.categoryField,
      { domain: F } = T.vizData.fieldMap[$];
    if (C.data[0]) {
      const { dataset: e, domain: V } = merge($, T);
      (C.data[0].values = e),
        F &&
          ((C.data[0].fields[$].domain = V),
          C.color.field === $ && (C.color.domain = V));
    }
    return C;
  },
  merge = (e, T) => {
    var C, $, F, V, Y, K, J, ee;
    const { vizData: te } = T,
      { pieMerge: ie } = te.displayConf,
      ne = te.datasets[0][0][0],
      re = te.cells[0],
      { domain: ae } = te.fieldMap[e];
    if (ae && ne.length > ie && ie > 1) {
      const oe =
          te.chartType === ChartType.ROSE
            ? null != ($ = null == (C = re.radius) ? void 0 : C[0])
              ? $
              : ""
            : null != (V = null == (F = re.angle) ? void 0 : F[0])
            ? V
            : "",
        se = lodash.exports.isNil(null == (Y = te.other) ? void 0 : Y.total)
          ? ne.reduce((e, T) => e + +T[oe], 0)
          : +(null != (J = null == (K = te.other) ? void 0 : K.total) ? J : 0);
      T.payload = {
        total: se,
      };
      const le = `(${intl.i18n``})`,
        de = ae ? orderBy(ne, ae, e) : ne,
        ce = [...ae.slice(0, ie - 1), le],
        ue = de.slice(0, ie - 1),
        he = {
          [e]: le,
        },
        pe =
          se -
          ue
            .map((e) => e[oe])
            .reduce((e, T) => {
              const C = e + +T;
              return isNaN(C) ? 0 : C;
            }, 0);
      if (
        ((he[oe] = String(pe)),
        re.color &&
          (null == (ee = te.fieldMap[re.color[0]]) ? void 0 : ee.role) ===
            Role.MEASURE)
      ) {
        const e = re.color[0],
          T =
            ne.reduce((T, C) => T + +C[e], 0) -
            ue
              .map((T) => T[e])
              .reduce((e, T) => {
                const C = e + +T;
                return isNaN(C) ? 0 : C;
              }, 0);
        he[e] = String(T);
      }
      return {
        dataset: ue.concat([he]),
        domain: ce,
      };
    }
    return {
      dataset: ne,
      domain: ae,
    };
  },
  polarRadius = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { chartType: $ } = T,
      F = T.displayConf,
      { radius: V } = F,
      Y = 1 === V ? 0.96 : V;
    if (isMobile())
      return (
        $ === ChartType.PIE && (C.outerRadius = 0.5),
        $ === ChartType.ANNULAR &&
          ((C.outerRadius = 0.65), (C.innerRadius = 0.6)),
        $ === ChartType.ROSE && (C.outerRadius = 0.5),
        C
      );
    if ("number" == typeof Y)
      return (
        (C.outerRadius = Y),
        $ === ChartType.ANNULAR && (C.innerRadius = 0.75 * Y),
        C
      );
    if (
      ($ === ChartType.PIE &&
        (F.label.labelPos === LabelPos.OUTER
          ? (C.outerRadius = 0.75)
          : (C.outerRadius = 0.9)),
      $ === ChartType.ANNULAR &&
        (F.label.labelPos === LabelPos.OUTER
          ? ((C.outerRadius = 0.75), (C.innerRadius = 0.55))
          : ((C.outerRadius = 0.9), (C.innerRadius = 0.65))),
      $ === ChartType.ROSE)
    ) {
      F.label.labelPos === LabelPos.OUTER
        ? (C.outerRadius = 0.8)
        : (C.outerRadius = 0.95);
      const { valueField: $ } = e;
      T.datasets.flat(3).find((e) => e[$] < 0) && (C.innerRadius = 0.05);
    }
    return C;
  },
  initProgress = (e, { vizData: T }) => {
    var C;
    const $ = {
        ...e,
      },
      { type: F, trailStyle: V } = T.displayConf;
    return (
      F === ProgressType.BAR
        ? (($.type = "linearProgress"),
          ($.direction = "horizontal"),
          ($.yField = "name"),
          ($.xField = "progress"),
          ($.cornerRadius = 15),
          ($.bandWidth = 15),
          ($.padding = {
            top: 0,
            bottom: 0,
            left: "5%",
            right: "5%",
          }))
        : (($.type = "circularProgress"),
          ($.valueField = "current"),
          ($.radiusField = "current"),
          ($.padding = 0),
          ($.outerRadius = 0.7),
          ($.innerRadius = 0.6),
          ($.cornerRadius = 20)),
      ($.track = {
        style: {
          fill: null != (C = null == V ? void 0 : V.fill) ? C : "#d5d6de",
        },
      }),
      $
    );
  },
  progressData = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      V = {
        ...e,
      },
      { displayConf: Y } = F,
      { params: K, measure: J } = Y,
      ee = F.datasets[0][0][0][0],
      te = F.cells[0],
      { fieldMap: ie } = F,
      ne = Object.keys(ie).filter((e) => ie[e].location === Location.DETAIL),
      { minPillUid: re, maxPillUid: ae, goalPillUid: oe } = K,
      se =
        K.minType === MeasureParamType.STATIC
          ? null === K.minValue
            ? void 0
            : K.minValue
          : null === re ||
            !(null == ne ? void 0 : ne.some((e) => e === `${re}`)) ||
            isNaN(ee[re])
          ? void 0
          : Number(ee[re]),
      le =
        K.maxType === MeasureParamType.STATIC
          ? null === K.maxValue
            ? void 0
            : K.maxValue
          : null === ae ||
            !(null == ne ? void 0 : ne.some((e) => e === `${ae}`)) ||
            isNaN(ee[ae])
          ? void 0
          : Number(ee[ae]),
      de =
        K.goalType === MeasureParamType.STATIC
          ? null === K.goalValue
            ? void 0
            : K.goalValue
          : null === oe ||
            !(null == ne ? void 0 : ne.some((e) => e === `${oe}`)) ||
            isNaN(ee[oe])
          ? void 0
          : Number(ee[oe]),
      ce =
        J.showMeasure && J.showName && null != (C = J.name)
          ? C
          : ie[te.value[0]].alias,
      ue = Number(ee[te.value[0]]),
      he = void 0 === se ? 0 : se,
      pe = void 0 === le ? (de ? Math.max(de, ue) : Math.max(ue, 0)) : le,
      ge = de > pe || de < he ? void 0 : de,
      fe = calcPercent$1({
        originGoalValue: de,
        minValue: he,
        measureValue: ue,
        decimalDigits: null != ($ = J.decimalDigits) ? $ : 0,
      }),
      me = calcProgress({
        measureValue: ue,
        maxValue: pe,
        minValue: he,
      }),
      ye = {
        ...{},
        ...(() => {
          var e, T;
          if ("circularProgress" === V.type || "linearProgress" === V.type) {
            const C = getFields(F, Location.MEASURE, isRenderField)[0],
              $ =
                null !=
                (T =
                  null == (e = null == Y ? void 0 : Y.specialValue)
                    ? void 0
                    : e.measures)
                  ? T
                  : SpecialValueType$1.BRACKET_TXT,
              V = getFormatMethod$1(C, F, $),
              K = {
                current: [intl.i18n``, ue],
                goal: [intl.i18n``, null != ge ? ge : de],
                max: [intl.i18n``, null != pe ? pe : le],
              },
              ee = new Set(J.labelParams),
              te = (e) => (ee.has(e) ? `${K[e][0]} ${V("", K[e][1])}` : "");
            return {
              detail: Object.keys(K)
                .map(te)
                .filter((e) => !!e)
                .join(" / "),
              goalProgress:
                void 0 === ge || pe - he == 0 ? 1 : (ge - he) / (pe - he),
            };
          }
          return {};
        })(),
      },
      be = [
        {
          id: "data",
          values: [
            {
              current: ue,
              name: ce,
              emptyName: "",
              percent: fe,
              progress: me,
              ...ye,
            },
          ],
        },
      ];
    return (
      (V.categoryField = "name"),
      (V.roundCap = 1 === me),
      (V.data = be),
      (T.payload = {
        min: he,
        max: pe,
        goal: ge,
        originGoalValue: de,
        originMaxValue: le,
        originMinValue: se,
        current: ue,
        name: ce,
        percent: fe,
        progress: me,
        emptyName: "",
        ...ye,
      }),
      V
    );
  },
  calcProgress = ({ maxValue: e, minValue: T, measureValue: C }) =>
    0 === C ? 0 : e - T != 0 ? Math.min((C - T) / (e - T), 1) : 1,
  calcPercent$1 = ({
    originGoalValue: e,
    minValue: T,
    measureValue: C,
    decimalDigits: $,
  }) => {
    if (void 0 !== e)
      return 0 === e
        ? "-"
        : void 0 === e || e - T == 0
        ? void 0
        : `${(((C - T) / (e - T)) * 100).toFixed(null != $ ? $ : 0)}%`;
  },
  progressGoal = (e, T) => {
    var C, $;
    const { payload: F, vizData: V } = T,
      { goalProgress: Y, goal: K } = F,
      { displayConf: J } = V,
      { type: ee } = J;
    if (lodash.exports.isNil(Y) || lodash.exports.isNil(K))
      return {
        ...e,
      };
    if (ee === ProgressType.BAR) {
      const T = [
        ...(null != (C = e.extensionMark) ? C : []),
        {
          type: "rule",
          dataId: "data",
          visible: !0,
          style: {
            x: (e, T) => T.valueToX([e.goalProgress]),
            y: (e, T) => T.valueToY([e.name]) - 7.5,
            x1: (e, T) => T.valueToX([e.goalProgress]),
            y1: (e, T) => T.valueToY([e.name]) + 7.5,
            stroke: "red",
            lineWidth: 1,
          },
        },
      ];
      return {
        ...e,
        extensionMark: T,
      };
    }
    if (ee === ProgressType.RING) {
      const T = ((360 * Y - 90) * Math.PI) / 180,
        C = [
          ...(null != ($ = e.extensionMark) ? $ : []),
          {
            type: "rule",
            dataId: "data",
            visible: !0,
            style: {
              x: (C, $) => {
                const F =
                  e.innerRadius *
                  Math.min(
                    $.getRegion().getLayoutRect().width,
                    $.getRegion().getLayoutRect().height
                  ) *
                  0.5;
                return $.getCenter().x + F * Math.cos(T);
              },
              y: (C, $) => {
                const F =
                  e.innerRadius *
                  Math.min(
                    $.getRegion().getLayoutRect().width,
                    $.getRegion().getLayoutRect().height
                  ) *
                  0.5;
                return $.getCenter().y + F * Math.sin(T);
              },
              x1: (C, $) => {
                const F =
                  e.outerRadius *
                  Math.min(
                    $.getRegion().getLayoutRect().width,
                    $.getRegion().getLayoutRect().height
                  ) *
                  0.5;
                return $.getCenter().x + F * Math.cos(T);
              },
              y1: (C, $) => {
                const F =
                  e.outerRadius *
                  Math.min(
                    $.getRegion().getLayoutRect().width,
                    $.getRegion().getLayoutRect().height
                  ) *
                  0.5;
                return $.getCenter().y + F * Math.sin(T);
              },
              stroke: "red",
              lineWidth: 1,
            },
          },
        ];
      return {
        ...e,
        extensionMark: C,
      };
    }
    return {
      ...e,
    };
  },
  progressIndicator = (e, T) => {
    var C, $, F, V, Y, K;
    const { vizData: J, payload: ee } = T,
      { displayConf: te } = J,
      { measure: ie, type: ne, specialValue: re } = te,
      ae = getFields(J, Location.MEASURE, isRenderField)[0],
      oe =
        null != (C = null == re ? void 0 : re.measures)
          ? C
          : SpecialValueType$1.BRACKET_TXT,
      { percent: se, current: le } = ee,
      de = getFormatMethodWithValue$2(ae, J, oe, "", le),
      ce = () => se;
    if (ne === ProgressType.BAR)
      return {
        ...e,
        axes: [
          {
            visible: ie.showMeasure,
            orient: "right",
            type: "band",
            domainLine: {
              visible: !1,
            },
            tick: {
              visible: !1,
            },
            label: {
              formatMethod:
                ie.displayType === DialMeasureDisplayType.ONLY_VALUE ? de : ce,
              style: {
                visible: ie.showMeasure,
                fontSize: ie.valueSize,
                fontFamily: PROGRESS_FONT_FAMILY,
                fill: ie.valueColor,
                fontWeight: 400,
              },
            },
            maxWidth: "60%",
          },
        ],
      };
    if (ne === ProgressType.RING) {
      const { name: T } = ee;
      return {
        ...e,
        indicator: {
          ...(null != ($ = e.indicator) ? $ : {}),
          visible: !0,
          title: {
            visible: ie.showName && ie.showMeasure,
            autoLimit: !0,
            space: 10,
            style: {
              text: T,
              fontSize: ie.nameSize,
              fill: ie.nameColor,
              fontWeight: null != (F = ie.nameWeight) ? F : 400,
              fontFamily: null != (V = ie.nameFont) ? V : PROGRESS_FONT_FAMILY,
            },
          },
          content: {
            visible: ie.showMeasure,
            autoLimit: !0,
            style: {
              text:
                ie.displayType === DialMeasureDisplayType.ONLY_VALUE
                  ? de()
                  : ce(),
              fontSize: ie.valueSize,
              fill: ie.valueColor,
              fontWeight: null != (Y = ie.valueWeight) ? Y : 400,
              fontFamily: null != (K = ie.valueFont) ? K : PROGRESS_FONT_FAMILY,
            },
          },
        },
      };
    }
    return {
      ...e,
    };
  },
  progressSection = (e, T) => {
    var C, $, F, V, Y, K, J, ee;
    const { vizData: te, measureText: ie } = T,
      ne = {
        ...e,
      },
      { displayConf: re } = te,
      { sections: ae, showSections: oe, type: se } = re,
      { min: le, max: de, progress: ce } = T.payload;
    if (!oe) return ne;
    const ue = [];
    let he = 0;
    ae.forEach((e) => {
      let { startValue: T } = e;
      e.valueType === SectionValueType.PERCENTAGE
        ? (T = e.startValue / 100)
        : e.valueType === SectionValueType.TRUE_VALUE &&
          (T = (e.startValue - le) / (de - le)),
        T >= he &&
          (ue.push({
            startValue: T,
            color: e.color,
            valueType: SectionValueType.TRUE_VALUE,
            name: e.name,
          }),
          (he = T));
    });
    let pe = -1;
    for (const me of ue) {
      if (ce < me.startValue) break;
      pe++;
    }
    pe < 0 && (pe = 0);
    const ge = ue[pe],
      fe = chroma(ge.color).rgb();
    if (
      ((ne.progress = {
        ...(null != (C = ne.progress) ? C : {}),
        style: {
          ...(null != (F = null == ($ = ne.progress) ? void 0 : $.style)
            ? F
            : {}),
          fill: ge.color,
        },
      }),
      (ne.track = {
        ...(null != (V = ne.track) ? V : {}),
        style: {
          ...(null != (K = null == (Y = ne.track) ? void 0 : Y.style) ? K : {}),
          fill: `rgba(${fe[0]}, ${fe[1]}, ${fe[2]}, ${
            se === ProgressType.BAR ? 0.1 : 0.5
          })`,
        },
      }),
      se === ProgressType.BAR &&
        (ne.extensionMark = [
          ...(null != (J = ne.extensionMark) ? J : []),
          {
            type: "text",
            dataId: "data",
            visible: !0,
            style: {
              text: ge.name,
              fontSize: 12,
              fontWeight: 500,
              fill: "white",
              stroke: ge.color,
              lineWidth: 1,
              textAlign: "center",
              textBaseline: "middle",
              maxLineWidth: (e, T) => T.valueToX([e.progress]) - 4,
              x: (e, T) => T.valueToX([e.progress]) / 2,
              y: (e, T) => T.valueToY([e.name]),
              x1: (e, T) => T.valueToX([e.progress]),
              y1: (e, T) => T.valueToY([e.name]),
            },
          },
        ]),
      se === ProgressType.RING)
    ) {
      const { width: T, height: C } = ie(ge.name, {
          fontSize: 12,
          fontWeight: 500,
          textAlign: "center",
          background: "red",
          textBaseline: "middle",
        }),
        $ = {
          top: 5,
          bottom: 0,
          left: 12,
          right: 12,
        };
      ne.extensionMark = [
        ...(null != (ee = ne.extensionMark) ? ee : []),
        {
          type: "rect",
          dataId: "data",
          visible: !!ge.name,
          style: {
            fill: ge.color,
            cornerRadius: 20,
            x: (e, C) => C.getCenter().x - T / 2 - $.left,
            y: (T, F) => {
              const V =
                0.5 *
                (0.5 *
                  Math.min(
                    F.getRegion().getLayoutRect().width,
                    F.getRegion().getLayoutRect().height
                  ) *
                  e.innerRadius);
              return F.getCenter().y + V - C / 2 - $.top;
            },
            x1: (e, C) => C.getCenter().x + T / 2 + $.right,
            y1: (T, F) => {
              const V =
                0.5 *
                (0.5 *
                  Math.min(
                    F.getRegion().getLayoutRect().width,
                    F.getRegion().getLayoutRect().height
                  ) *
                  e.innerRadius);
              return F.getCenter().y + V + C + $.bottom;
            },
          },
        },
        {
          type: "text",
          dataId: "data",
          visible: !!ge.name,
          style: {
            text: ge.name,
            fontSize: 12,
            fontWeight: 500,
            fill: "white",
            textAlign: "center",
            background: "red",
            textBaseline: "middle",
            x: (e, T) => T.getCenter().x,
            y: (T, C) => {
              const $ =
                0.5 *
                (0.5 *
                  Math.min(
                    C.getRegion().getLayoutRect().width,
                    C.getRegion().getLayoutRect().height
                  ) *
                  e.innerRadius);
              return C.getCenter().y + $;
            },
          },
        },
      ];
    }
    return ne;
  },
  progressStyle = (e, { vizData: T, payload: C }) => {
    var $, F, V, Y;
    const K = {
        ...e,
      },
      { color: J, showSections: ee } = T.displayConf,
      { progress: te } = C;
    if (!ee && J.colorsLinear) {
      const e = 1 - te,
        T = 1;
      K.progress = {
        ...(null != ($ = K.progress) ? $ : {}),
        style: {
          ...(null !=
          (V = null == (F = null == K ? void 0 : K.progress) ? void 0 : F.style)
            ? V
            : {}),
          fill: {
            gradient: "linear",
            x0: e,
            x1: T,
            y0: 0.5,
            y1: 0.5,
            stops:
              null == (Y = null == J ? void 0 : J.colorsLinear)
                ? void 0
                : Y.map((e, T) => ({
                    offset:
                      T *
                      (1 / ((null == J ? void 0 : J.colorsLinear).length - 1)),
                    color: e,
                  })),
          },
        },
      };
    }
    return K;
  },
  progressText = (e, T) => {
    var C, $;
    const { payload: F, vizData: V } = T,
      { displayConf: Y } = V,
      { name: K, detail: J } = F,
      { measure: ee, type: te } = Y;
    if (te === ProgressType.BAR) {
      const T = [
        ...(null != (C = e.extensionMark) ? C : []),
        {
          type: "text",
          dataId: "data",
          visible: ee.showName && ee.showMeasure,
          style: {
            text: K,
            textAlign: "start",
            textBaseline: "bottom",
            fontSize: ee.nameSize,
            fill: ee.nameColor,
            fontWeight: 500,
            dy: 0,
            x: (e, T) => T.valueToX([0]),
            y: (e, T) => T.valueToY([e.name]) - 19,
          },
        },
        {
          type: "text",
          dataId: "data",
          visible: ee.showMeasure && !!ee.labelParams.length,
          style: {
            text: J,
            fontWeight: 500,
            fontSize: ee.labelSize,
            fill: ee.labelColor,
            textAlign: "start",
            textBaseline: "top",
            dy: 0,
            x: (e, T) => T.valueToX([0]),
            y: (e, T) => T.valueToY([e.name]) + 15,
            maxLineWidth: (e, T) => T.valueToX([1]) - T.valueToX([0]),
          },
        },
      ];
      return {
        ...e,
        extensionMark: T,
      };
    }
    if (te === ProgressType.RING) {
      const T = [
        ...(null != ($ = e.extensionMark) ? $ : []),
        {
          type: "text",
          dataId: "data",
          visible: ee.showMeasure && !!ee.labelParams.length,
          style: {
            text: J,
            fontWeight: 500,
            fontSize: ee.labelSize,
            fill: ee.labelColor,
            textAlign: "center",
            textBaseline: "top",
            x: (e, T) => T.getCenter().x,
            y: (T, C) =>
              0.5 *
                Math.min(
                  C.getRegion().getLayoutRect().width,
                  C.getRegion().getLayoutRect().height
                ) *
                e.outerRadius +
              C.getCenter().y,
            dy: 12,
            maxLineWidth: (e, T) => T.getRegion().getLayoutRect().width,
          },
        },
      ];
      return {
        ...e,
        extensionMark: T,
      };
    }
    return {
      ...e,
    };
  },
  initLiquid = (e, { vizData: T }) => {
    const C = {
      ...e,
    };
    return (C.type = "liquid"), (C.valueField = "measurePercent"), C;
  },
  count = (e) => e.length,
  avg = (e) => count(e) / lodash.exports.sum(e),
  first = (e) => e[0],
  aggregateTypeMap = {
    count: count,
    sum: lodash.exports.sum,
    average: avg,
    max: lodash.exports.max,
    min: lodash.exports.min,
    none: first,
    count_distinct: count,
  },
  getFinalValue = (e, T, C) => {
    var $;
    if (0 !== e.length && T && C) {
      if (1 === e.length) return e[0][T];
      if (C.role === FieldRoleType.Dimension) return 1;
      {
        const F = null != ($ = C.aggregation.type) ? $ : "none";
        return aggregateTypeMap[F](e.map((e) => Number(e[T])));
      }
    }
    return NaN;
  },
  liquidData = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      Y = {
        ...e,
      },
      { displayConf: K } = V,
      { analytic: J, fieldMap: ee } = V,
      { params: te, measure: ie } = K,
      ne = V.datasets[0][0][0],
      re = V.cells[0],
      ae = Object.keys(ee).filter((e) => ee[e].location === Location.DETAIL),
      {
        minPillUid: oe,
        maxPillUid: se,
        goalPillUid: le,
        minPillInfo: de,
        maxPillInfo: ce,
        goalPillInfo: ue,
      } = te,
      he =
        te.minType === MeasureParamType.STATIC
          ? null === te.minValue
            ? void 0
            : te.minValue
          : null === oe ||
            !(null == ae ? void 0 : ae.some((e) => e === `${oe}`)) ||
            isNaN(getFinalValue(ne, oe, de))
          ? void 0
          : Number(getFinalValue(ne, oe, de)),
      pe =
        te.maxType === MeasureParamType.STATIC
          ? null === te.maxValue
            ? void 0
            : te.maxValue
          : null === se ||
            !(null == ae ? void 0 : ae.some((e) => e === `${se}`)) ||
            isNaN(getFinalValue(ne, se, ce))
          ? void 0
          : Number(getFinalValue(ne, se, ce)),
      ge =
        te.goalType === MeasureParamType.STATIC
          ? null === te.goalValue
            ? void 0
            : te.goalValue
          : null === le ||
            !(null == ae ? void 0 : ae.some((e) => e === `${le}`)) ||
            isNaN(getFinalValue(ne, le, ue))
          ? void 0
          : Number(getFinalValue(ne, le, ue)),
      fe =
        ie.showMeasure && ie.showName && null != (C = ie.name)
          ? C
          : ee[re.value[0]].alias,
      me = Number(getFinalValue(ne, re.value[0], J.vizFieldBlock.measure[0])),
      ye = void 0 === he ? 0 : he,
      be = void 0 === pe ? 1 : pe,
      ve = ge > Math.max(ye, be) || ge < Math.min(ye, be) ? void 0 : ge,
      Te =
        null !=
        (F =
          null == ($ = null == K ? void 0 : K.specialValue)
            ? void 0
            : $.measures)
          ? F
          : SpecialValueType.BRACKET_TXT,
      _e = createFormatter(ie.percentFormat, Te),
      Ce = calcPercent({
        originGoalValue: ge,
        minValue: ye,
        measureValue: me,
        labelFormatMethod: _e,
      }),
      Ae = calcLiquidMeasure({
        minValue: ye,
        maxValue: be,
        measureValue: me,
      }),
      xe = calcLiquidGoal({
        maxValue: be,
        minValue: ye,
        goalValue: ve,
      }),
      Se = {
        current: [intl.i18n``, me],
        goal: [intl.i18n``, ve],
        max: [intl.i18n``, null != be ? be : pe],
      },
      Re = new Set(ie.labelParams),
      Me = Object.keys(Se)
        .map((e) => (Re.has(e) ? `${Se[e][1]}` : ""))
        .filter((e) => !!e)
        .join(" / "),
      Pe = [
        {
          id: "data",
          values: [
            {
              current: me,
              name: fe,
              emptyName: "",
              percent: Ce,
              measurePercent: Ae,
            },
          ],
        },
      ];
    return (
      (T.payload = {
        min: ye,
        max: be,
        goal: ve,
        originGoalValue: ge,
        originMaxValue: pe,
        originMinValue: he,
        current: me,
        name: fe,
        percent: Ce,
        goalPercent: xe,
        measurePercent: Ae,
        detail: Me,
      }),
      (Y.data = Pe),
      Y
    );
  },
  calcLiquidMeasure = ({ maxValue: e, minValue: T, measureValue: C }) => {
    if (!C || 0 === C || T === e) return 0;
    const $ = Math.max(T, e),
      F = Math.min(T, e);
    return Math.max(0, Math.min((C - F) / ($ - F), 1));
  },
  calcLiquidGoal = ({ maxValue: e, minValue: T, goalValue: C }) => {
    if (lodash.exports.isUndefined(C) || T === e) return;
    const $ = Math.max(T, e),
      F = Math.min(T, e);
    return (C - F) / ($ - F);
  },
  calcPercent = ({
    originGoalValue: e,
    minValue: T,
    measureValue: C,
    labelFormatMethod: $,
  }) => (void 0 === e || e - T == 0 ? "-" : `${$((C - T) / (e - T))}`),
  liquidReverse = (e, T) => {
    const { vizData: C, payload: $ } = T,
      { displayConf: F } = C;
    return {
      ...e,
      reverse: $.max < $.min ? !F.reverse : F.reverse,
    };
  },
  getCenterX = (e) => {
    const { x: T } = e.getLiquidBackPosAndSize();
    return T;
  },
  getRadius = (e, T, C, $) => {
    const { size: F, width: V, height: Y } = $.getLiquidBackPosAndSize();
    if (e === LiquidShapeType.CIRCLE)
      return (Math.sqrt(1 - (T - 0.5) * (T - 0.5) * 4) * F) / 2;
    if (e === LiquidShapeType.RECT) return V / 2;
    if (e === LiquidShapeType.SQUARE) return F / 2;
    if (e === LiquidShapeType.DIAMOND) return T <= 0.5 ? Y * T : Y * (1 - T);
    if (e === LiquidShapeType.TRIANGLE) {
      return (F * (C ? T : 1 - T)) / 2;
    }
    if (e === LiquidShapeType.STAR) {
      let e = [];
      e = C ? [0.38, 0.615] : [0.385, 0.62];
      const { size: F } = $.getLiquidBackPosAndSize();
      if (T <= e[0] || T >= e[1]) {
        const e = ((F / 2) * 0.956) / Math.cos(Math.PI / 10);
        return (
          (e + e * Math.cos(Math.PI / 5)) *
          (C ? T : 1 - T) *
          Math.tan(Math.PI / 10)
        );
      }
      const V = ((F / 2) * 0.956) / Math.cos(Math.PI / 10),
        Y = V + V * Math.cos(Math.PI / 5);
      return ((C ? 1 - T : T) * Y - 0.24 * Y) / Math.tan(Math.PI / 5);
    }
    if (e === LiquidShapeType.DROP) {
      const e = 0.65,
        $ = 0.97 * F,
        V = 0.52 * (0.675 * $),
        Y = C ? 1 - T : T;
      return Y >= 0.5
        ? Math.sqrt(Math.pow(V, 2) - Math.pow(Math.abs(Y - e) * $, 2))
        : Y * $ * 0.57 - 8;
    }
    return V / 2;
  },
  getY = (e, T, C, $) => {
    const F = C ? 1 : -1,
      { y: V, size: Y } = $.getLiquidBackPosAndSize();
    if (e === LiquidShapeType.STAR) {
      if (C) {
        const e = ((Y / 2) * 0.956) / Math.cos(Math.PI / 10),
          C = V - Y / 2;
        return C + T * (V - Y / 2 + (e + e * Math.cos(Math.PI / 5)) - C);
      }
      const e = ((Y / 2) * 0.956) / Math.cos(Math.PI / 10),
        $ = V - Y / 2 + (e + e * Math.cos(Math.PI / 5));
      return $ + T * (V - Y / 2 - $);
    }
    if (e === LiquidShapeType.DROP) {
      const { size: e, startY: F } = $.getLiquidBackPosAndSize();
      let V, Y, K;
      return (
        C
          ? ((V = 0.97 * e), (Y = 0.017 * e + F), (K = Y + V))
          : ((V = 0.97 * e), (K = 0.017 * e + F), (Y = K + V)),
        Y + T * (K - Y)
      );
    }
    return V + F * (T - 0.5) * Y;
  },
  liquidGoal = (e, T) => {
    const { payload: C, vizData: $, measureText: F } = T,
      { goalPercent: V, detail: Y } = C;
    if (lodash.exports.isNil(V) || V < 0 || V > 1)
      return {
        ...e,
      };
    const { displayConf: K } = $,
      { measure: J } = K,
      {
        labelLineColor: ee = "#963824",
        labelLineWidth: te = 1,
        labelVisible: ie = !0,
        labelFont: ne = "D-DIN",
        labelWeight: re = "normal",
        labelColor: ae = "#963824",
        labelBackColor: oe = "#963824",
        labelSize: se = 12,
        labelOffsetX: le = 0,
        labelOffsetY: de = 0,
      } = J,
      { maskShape: ce = LiquidShapeType.CIRCLE, reverse: ue = !1 } = e,
      he = [4, 2],
      pe = (e) => getCenterX(e) - getRadius(ce, V, ue, e),
      ge = (e) => getCenterX(e) + getRadius(ce, V, ue, e),
      fe = () => {
        const e = createGoalFormatMethod(T)(Y),
          C = F(e, {
            fontSize: se,
            fontFamily: ne,
            fontWeight: re,
          });
        return {
          width: C.width + 2 * he[0] + ((e + "").includes("") ? se : 0),
          height: C.height + 2 * he[1],
        };
      },
      me = [
        {
          type: "rule",
          style: {
            stroke: ee,
            lineWidth: te,
            x: (e, T) => pe(T),
            x1: (e, T) => ge(T),
            y: (e, T) => getY(ce, V, ue, T),
            y1: (e, T) => getY(ce, V, ue, T),
          },
        },
        {
          type: "symbol",
          style: {
            fill: ee,
            size: getLineSymbolSize(te),
            x: (e, T) => pe(T),
            y: (e, T) => getY(ce, V, ue, T),
            symbolType: "triangle",
            angle: 90,
          },
        },
        {
          type: "symbol",
          style: {
            fill: ee,
            size: getLineSymbolSize(te),
            x: (e, T) => ge(T),
            y: (e, T) => getY(ce, V, ue, T),
            symbolType: "triangle",
            angle: -90,
          },
        },
        {
          type: "rect",
          style: {
            fill: oe,
            cornerRadius: 3,
            visible: ie,
            x: (e, T) => pe(T) - he[0],
            y: (e, T) => getY(ce, V, ue, T) - fe().height + he[1],
            width: fe().width,
            height: fe().height,
            dx: le + he[0],
            dy: -(de + he[1] + 2),
          },
        },
        {
          type: "text",
          style: {
            visible: ie,
            text: createGoalFormatMethod(T)(Y),
            fill: ae,
            fontSize: se,
            fontFamily: ne,
            fontWeight: re,
            x: (e, T) => pe(T),
            y: (e, T) => getY(ce, V, ue, T),
            textBaseline: "bottom",
            textAlign: "left",
            dx: le + he[0],
            dy: -(de + he[1] + 2),
          },
        },
      ];
    return {
      ...e,
      extensionMark: me,
    };
  },
  INVALID_VALUE_MAP$1 = {
    [SpecialValueType$1.BRACKET_TXT]: " ",
    [SpecialValueType$1.NULL]: "NULL",
    [SpecialValueType$1.ZERO]: "0",
    [SpecialValueType$1.DASH]: "--",
  },
  getFormatMethodWithValue = (e, T, C, $, F) => () => {
    const $ = getFieldFormat,
      V = createFormatter;
    if (null !== F && isNaN(Number(F))) return F;
    if (void 0 === e) return F;
    return V($(e, T, "field"), INVALID_VALUE_MAP$1[C])(F);
  },
  liquidIndicator = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V, payload: Y } = T,
      { displayConf: K } = V,
      { measure: J, specialValue: ee } = K,
      { showMeasure: te } = J,
      { current: ie, percent: ne, name: re } = Y,
      {
        showName: ae,
        nameSize: oe,
        nameColor: se,
        nameWeight: le = 400,
        nameFont: de = LIQUID_FONT_FAMILY,
        showValue: ce,
        valueSize: ue,
        valueColor: he,
        valueWeight: pe = 400,
        valueFont: ge = LIQUID_FONT_FAMILY,
        percentVisible: fe,
        percentSize: me,
        percentColor: ye,
        percentWeight: be = 400,
        percentFont: ve = LIQUID_FONT_FAMILY,
      } = J,
      Te = getFields(V, Location.MEASURE, isRenderField)[0],
      _e =
        null != (C = null == ee ? void 0 : ee.measures)
          ? C
          : SpecialValueType$1.BRACKET_TXT,
      Ce = {
        visible: ce,
        text: getFormatMethodWithValue(Te, V, _e, "", ie)(),
        fontSize: ue,
        fill: he,
        fontWeight: pe,
        fontFamily: ge,
        pickable: !1,
      },
      Ae = {
        visible: ae,
        text: ae ? re : "",
        fontSize: oe,
        fill: se,
        fontWeight: le,
        fontFamily: de,
        pickable: !1,
      },
      xe = {
        visible: fe,
        text: ne,
        fontSize: me,
        fill: ye,
        fontWeight: be,
        fontFamily: ve,
        pickable: !1,
      },
      Se =
        "bottom" === J.namePosition
          ? J.displayType === DialMeasureDisplayType.BOTH
            ? [xe, Ce, Ae]
            : [Ce, Ae]
          : J.displayType === DialMeasureDisplayType.BOTH
          ? [Ae, xe, Ce]
          : [Ae, Ce],
      Re = {
        space: 5,
        visible: null == ($ = Se[0].visible) || $,
        style: Se[0],
      },
      Me = Se.slice(1).map((e) => {
        var T;
        return {
          space: 5,
          visible: null == (T = e.visible) || T,
          style: e,
        };
      });
    return (
      (F.indicator = {
        pickable: !1,
        visible: te,
        fixed: !0,
        title: Re,
        content: Me,
      }),
      F
    );
  },
  liquidStyle = (e, { vizData: T, payload: C }) => {
    const $ = {
        ...e,
      },
      { style: F } = T.displayConf,
      {
        maskShape: V = LiquidShapeType.CIRCLE,
        background: Y = "rgba(0,0,0,0)",
        lineType: K = "solid",
        padding: J = 20,
        margin: ee = 0,
        ratio: te = 1,
      } = F;
    return (
      ($.maskShape = V),
      ($.liquidBackground = {
        style: {
          fill: Y,
          lineDash: "dash" === K ? [8, 8] : [0],
          lineWidth: 1,
          fillOpacity: 1,
          stroke: "rgba(255, 255, 255, 0.3)",
          scaleX: te,
          scaleY: te,
          scaleCenter: ["50%", "50%"],
        },
      }),
      ($.liquidOutline = {
        style: {
          lineDash: "dash" === K ? [8, 8] : [0],
          lineWidth: 1,
          stroke: "rgba(255, 255, 255, 0.15)",
          scaleX: te,
          scaleY: te,
          scaleCenter: ["50%", "50%"],
        },
      }),
      ($.outlineMargin = ee),
      ($.outlinePadding = J),
      $
    );
  },
  DEFAULT_LABEL_OFFSET = 4,
  referenceLine = (e, { vizData: T }) => {
    const { referenceLine: C, chartType: $ } = T,
      F = [];
    return (
      lodash.exports.isEmpty(C) ||
        C.filter(
          (e) =>
            e.position &&
            !lodash.exports.isNil(e.value) &&
            (![
              ChartType.COLUMN_PERCENT,
              ChartType.BAR_PERCENT,
              ChartType.AREA_PERCENT,
            ].includes($) ||
              lodash.exports.inRange(e.value, 0, 1) ||
              1 === e.value)
        ).forEach((e) => {
          const C = getMarkLineItem({
            referenceLineItem: e,
            vizData: T,
          });
          C && F.push(C);
        }),
      {
        ...e,
        markLine: F,
      }
    );
  },
  getMarkLineItem = ({ vizData: e, referenceLineItem: T }) => {
    const C = T.line,
      $ = T.label,
      { chartType: F } = e,
      V = getFormatter$1({
        vizData: e,
        referenceLineItem: T,
      }),
      Y = getFieldName({
        vizData: e,
        referenceLineItem: T,
      }),
      K = {
        style: {
          stroke: C.color,
          lineWidth: C.width,
          lineDash: getLineDash(C.style),
        },
      },
      J = getLabelText({
        ...$,
        value: T.value,
        formatter: V,
        fieldName: Y,
      }),
      ee = {
        visible: !lodash.exports.isEmpty(J),
        type: "rich",
        text: J,
        ...getLabelPositionAndOffset({
          position: T.position,
          offset: $.offset,
          chartType: F,
        }),
        labelBackground: {
          style: {
            fill: C.color,
          },
        },
        style: {
          fill: $.color,
          strokeOpacity: 0,
          fontWeight: $.fontWeight,
          fontSize: $.fontSize,
          fontFamily: "inherit" === $.fontFamily ? "" : $.fontFamily,
        },
      };
    let te = {
        visible: !0,
        symbolType: "triangleDown",
        size: getLineSymbolSize(C.width),
        style: {
          fill: C.color,
        },
      },
      ie = {
        visible: !1,
      };
    return (
      "y2" === T.position && ([te, ie] = [ie, te]),
      {
        id: T.id,
        name: T.name,
        interactive: !1,
        autoRange: !0,
        line: K,
        label: ee,
        startSymbol: te,
        endSymbol: ie,
        ...getReferenceLineValueConfig(T),
      }
    );
  },
  getFieldName = ({ vizData: e, referenceLineItem: T }) => {
    var C;
    const { fieldMap: $ } = e;
    if (T.fieldId) return null == (C = $[T.fieldId]) ? void 0 : C.alias;
  },
  getFormatter$1 = ({ vizData: e, referenceLineItem: T }) => {
    var C, $, F, V;
    const { locationMap: Y, fieldMap: K, chartType: J } = e,
      { format: ee, position: te } = T,
      ie = ("y2" === te ? Y.subMeasure : Y.measure) || [];
    let ne = null != (C = T.fieldId) ? C : ie[0];
    ((J === ChartType.SCATTER && "y" === te) ||
      (J === ChartType.BILATERAL && "x2" === te)) &&
      (ne = ie[1]);
    const re = null == ($ = K[ne]) ? void 0 : $.format,
      ae =
        null == (V = null == (F = K[ne]) ? void 0 : F.autoFormat)
          ? void 0
          : V.label,
      oe =
        re && "auto" in re && !0 === (null == re ? void 0 : re.auto) ? ae : re,
      se =
        ee && "auto" in ee && !0 === (null == ee ? void 0 : ee.auto) ? oe : ee;
    return createFormatter(se);
  },
  getLineDash = (e) => {
    switch (e) {
      case ReferenceLineStyle.dashed:
        return [3, 3];
      case ReferenceLineStyle.dotted:
        return [1, 1];
      case ReferenceLineStyle.solid:
      default:
        return [];
    }
  },
  getLabelText = ({
    value: e,
    showValue: T,
    showField: C,
    text: $,
    align: F,
    gap: V,
    formatter: Y,
    fieldName: K,
  }) => {
    const J = $.slice();
    C && K && J.push(K), T && J.push(Y(e));
    const ee =
      F === ReferenceLineLabelAlign.horizontal
        ? [
            {
              image: "",
              width: V,
            },
          ]
        : [
            {
              text: "\n",
            },
            {
              image: "",
              height: V,
            },
            {
              text: "\n",
            },
          ];
    return J.reduce(
      (e, T, C) => (
        e.push({
          text: T,
        }),
        C < J.length - 1 && e.push(...ee),
        e
      ),
      []
    );
  },
  getLabelPositionAndOffset = ({ position: e, chartType: T, offset: C }) => {
    let $,
      F = 0,
      V = 0;
    switch (e) {
      case "y2":
        ($ = "insideEndTop"), (V = -DEFAULT_LABEL_OFFSET);
        break;
      case "x":
        T === ChartType.BILATERAL && ($ = "insideStartBottom"),
          ($ = "insideStartBottom"),
          (F = -DEFAULT_LABEL_OFFSET);
        break;
      case "x2":
        ($ = "insideStartBottom"), (F = -DEFAULT_LABEL_OFFSET);
        break;
      default:
        ($ = "insideStartTop"), (V = -DEFAULT_LABEL_OFFSET);
    }
    return {
      dx: C.x + F,
      dy: -C.y + V,
      position: $,
    };
  },
  getReferenceLineValueConfig = ({ position: e, value: T }) => {
    let C = e;
    switch (e) {
      case "y2":
        C = "y";
        break;
      case "x2":
        C = "x";
    }
    return {
      [C]: T,
      relativeSeriesId: isSubAxis(e) ? SUB_SERIES_ID : MAIN_SERIES_ID,
    };
  },
  isSubAxis = (e) => ["x2", "y2"].includes(e),
  combinationReferenceLine = (e, T) => {
    const C = {
      ...e,
    };
    return (
      (C.indicators = e.indicators.map((e, C) => {
        var $;
        const F = T.vizData,
          V = F.displayConf.combination.list[C],
          Y = [...V.main, ...V.sub].map((e) => String(e));
        return (
          (e.chartSpec = referenceLine(e.chartSpec, {
            ...T,
            vizData: {
              ...F,
              referenceLine:
                null == ($ = F.referenceLine)
                  ? void 0
                  : $.filter((e) => Y.includes(e.fieldId)),
            },
          })),
          e
        );
      })),
      {
        ...C,
      }
    );
  },
  NODE_KEY_FIELD = "key",
  NODE_VALUE_FIELD = "value",
  hierarchySankey = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      { datasets: Y } = V,
      K =
        null !=
        (F =
          null == ($ = null == (C = V.cells[0]) ? void 0 : C.value)
            ? void 0
            : $[0])
          ? F
          : NODE_VALUE_FIELD,
      J = [...Y[0][0][0]].map((e) => {
        const T = {
          ...e,
          [K]: e.value,
        };
        return delete e.type, T;
      }),
      ee = [...V.datasets[0][0][1]];
    return {
      ...e,
      data: [
        {
          id: "data",
          parser: {
            clone: !1,
          },
          values: [
            {
              nodes: generateTree(J, ee),
            },
          ],
        },
      ],
    };
  },
  generateTree = (e, T) => {
    const C = {},
      $ = {},
      F = e.reduce(
        (e, T) => (
          (T.children = []), (e[T.key] = T), (C[T.key] = 0), ($[T.key] = 0), e
        ),
        {}
      );
    T.forEach((e) => {
      const T = F[e.from],
        V = F[e.to];
      T && (C[T.key] = 1 + (C[T.key] || 0)),
        V && ($[V.key] = 1 + ($[V.key] || 0));
    });
    const V = Array.from(Object.values(F)).filter((e) => {
        const T = $[e.key],
          F = C[e.key];
        return 0 === T && 0 !== F;
      }),
      Y = V.reduce((e, T) => e.add(T.key), new Set()),
      K = lodash.exports.groupBy(T, (e) => e.key);
    for (const J in K) {
      const e = K[J],
        T = e.find((e) => Y.has(e.from));
      if (!(null == T ? void 0 : T.from)) continue;
      let C = F[T.from];
      e.forEach((e) => {
        var T, $, V;
        const Y = {
            ...F[e.to],
            value: e.value,
            link: e,
            children: [],
          },
          K = null == (T = C.children) ? void 0 : T.find((T) => T.key === e.to);
        K && K.value
          ? ((K.value += null != ($ = Y.value) ? $ : 0), (C = K))
          : (null == (V = null == C ? void 0 : C.children) || V.push(Y),
            (C = Y));
      });
    }
    return V;
  },
  initSankey = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $;
    return {
      ...e,
      nodeGap: 5,
      nodeWidth: 12,
      nodeAlign: "justify",
      iterations: 0,
      padding: {
        top: F.showDimensionLabel
          ? (null != (C = F.dimensionLabelSize) ? C : 0) + 8
          : 0,
        left: 2,
        bottom: 0,
        right: 2,
      },
      nodeKey: (e) => e[NODE_KEY_FIELD],
      categoryField: NODE_KEY_FIELD,
      valueField: NODE_VALUE_FIELD,
      link: {
        style: {
          pathType: F.shape === SankeyShape.Line ? "line" : "smooth",
        },
      },
    };
  },
  sankeyColor = (e, T) => {
    var C;
    const { color: $ } = color(e, T),
      { vizData: F } = T,
      { datasets: V } = F,
      Y = null == (C = F.cells[0]) ? void 0 : C.value,
      { specified: K } = $,
      J = getColorItems(F),
      ee = Object.values(K).length
        ? K
        : $.range.reduce((e, T, C) => ((e[J[C]] = T), e), {}),
      te = [...V[0][0][0]]
        .map((e) => {
          var T;
          return {
            ...e,
            [null != (T = null == Y ? void 0 : Y[0]) ? T : "value"]: e.value,
          };
        })
        .map((e) => e[NODE_KEY_FIELD]),
      ie = Object.entries(ee).reduce((e, T) => {
        const [C, $] = T;
        return te.filter((e) => e.endsWith(C)).forEach((T) => (e[T] = $)), e;
      }, {}),
      ne = {
        ...$,
        field: "color",
        domain: te,
        specified: ie,
      };
    return {
      ...e,
      color: ne,
    };
  },
  sankeyDimensionLabel = (e, T) => {
    const { vizData: C } = T,
      { fieldMap: $ } = C,
      { displayConf: F } = C;
    if (!F.showDimensionLabel) return e;
    const { nodes: V } = e.data[0].values[0],
      Y = findFirstPath(V[0]);
    return {
      ...e,
      region: [
        {
          clip: !1,
        },
      ],
      extensionMark: Y.map((e, T) => {
        var C, V;
        return {
          type: "text",
          dataId: CHART_DATA_ID,
          style: {
            text: $[e.group].alias,
            x: (C) => {
              const $ = (C.columns ? C.columns.flat() : C.nodes).find((T) => {
                var C;
                return (
                  T.key === e.key ||
                  (null == (C = T.datum) ? void 0 : C.key) === e.key
                );
              });
              return $
                ? 0 === T
                  ? $.x0
                  : T === Y.length - 1
                  ? $.x1
                  : ($.x0 + $.x1) / 2
                : 0;
            },
            textAlign: () =>
              0 === T ? "left" : T === Y.length - 1 ? "right" : "center",
            fontSize: null != (C = F.dimensionLabelSize) ? C : 12,
            fill: null != (V = F.dimensionLabelColor) ? V : "#000000",
            y: -8,
            dx: -2,
          },
        };
      }),
    };
  };
function findFirstPath(e) {
  let T = [];
  return (
    (function e(C, $) {
      $.push(C),
        C.children && 0 !== C.children.length
          ? C.children.forEach((T) => {
              e(T, $);
            })
          : (T = [...$]),
        $.pop();
    })(e, []),
    T
  );
}
const TRANSPARENT_COLOR$1 = "rgba(255,255,255,0)",
  CELL_PADDING_LEFT = 0,
  CELL_PADDING_LEFT_TIGHT = 0,
  CELL_PADDING_TOP = 0,
  CELL_PADDING_TOP_TIGHT = 0,
  CELL_LINE_HEIGHT = 18,
  lineDashMap = {
    [LineStyleType.SOLID]: null,
    [LineStyleType.DASHED]: [4, 2],
    [LineStyleType.DOTTED]: [1, 1],
  },
  tableChartTheme = (e, T) => (isTableChart(T.vizData) ? createTheme(e, T) : e),
  createTheme = (e, T) => {
    const { displayConf: C } = T.vizData,
      { titleSize: $, titleColor: F, partingLineColor: V } = C.pivot,
      Y = {
        borderColor: null != V ? V : "rgba(0,4,20,0.2)",
        cellBgColor: "rgba(178,186,207, 0.2)",
        titleSize: $,
        titleColor: F,
      };
    return {
      ...e,
      theme: {
        underlayBackgroundColor: "rgba(255,255,255,0)",
        ...buildBodyStyle(T, Y),
        ...buildHeaderStyle(T, Y),
        ...buildRowHeaderStyle(T, Y),
        ...buildCornerHeaderStyle(T, Y),
        ...buildCornerRightTopCellStyle(T, Y),
        ...buildCornerLeftBottomCellStyle(T, Y),
        ...buildCornerRightBottomCellStyle(T, Y),
        ...buildRightFrozenStyle(T, Y),
        ...buildBottomFrozenStyle(T, Y),
        ...buildSelectionStyle(),
        ...buildFrameStyle(),
      },
    };
  },
  buildBodyStyle = (e, T) => {
    var C;
    const { borderColor: $ } = T,
      { vizData: F } = e;
    if (isPivot(e.vizData))
      return {
        bodyStyle: {
          borderColor: $,
          borderLineWidth: [1, 0, 0, 1],
          bgColor: TRANSPARENT_COLOR$1,
          padding: 1,
        },
      };
    const { displayConf: V } = F,
      Y =
        (null == (C = V.combination) ? void 0 : C.layout) ===
        CombinationLayout.COLUMN
          ? "horizontal"
          : "vertical";
    return {
      bodyStyle: {
        borderColor: $,
        borderLineWidth: "vertical" === Y ? [0, 0, 2, 0] : [0, 0, 0, 2],
        bgColor: TRANSPARENT_COLOR$1,
        padding: "vertical" === Y ? [0, 0, 1, 0] : [0, 0, 0, 1],
      },
    };
  },
  buildHeaderStyle = (e, T) => {
    const { borderColor: C, cellBgColor: $, titleSize: F, titleColor: V } = T;
    return isPivot(e.vizData)
      ? {
          headerStyle: {
            borderColor: C,
            fontSize: F,
            color: V,
            textAlign: "center",
            borderLineWidth: [0, 0, 1, 1],
            padding: [4, 0, 4, 0],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        }
      : {
          headerStyle: {
            borderColor: C,
            fontSize: F,
            color: V,
            textAlign: "center",
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        };
  },
  buildRowHeaderStyle = (e, T) => {
    const { borderColor: C, cellBgColor: $, titleSize: F, titleColor: V } = T;
    return isPivot(e.vizData)
      ? {
          rowHeaderStyle: {
            borderColor: C,
            fontSize: F,
            color: V,
            padding: [0, 0, 0, 4],
            borderLineWidth: [1, 1, 0, 0],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        }
      : {
          rowHeaderStyle: {
            borderColor: C,
            fontSize: F,
            color: V,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        };
  },
  buildCornerHeaderStyle = (e, T) => {
    const { borderColor: C, titleSize: $, titleColor: F } = T;
    return isPivot(e.vizData)
      ? {
          cornerHeaderStyle: {
            borderColor: C,
            textAlign: "center",
            fontSize: $,
            color: F,
            fontWeight: "bold",
            borderLineWidth: [0, 1, 1, 0],
            padding: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        }
      : {
          cornerHeaderStyle: {
            borderColor: C,
            textAlign: "center",
            fontSize: $,
            color: F,
            fontWeight: "bold",
            borderLineWidth: [0, 0, 0, 0],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        };
  },
  buildCornerRightTopCellStyle = (e, T) => {
    const { borderColor: C } = T;
    return isPivot(e.vizData)
      ? {
          cornerRightTopCellStyle: {
            borderColor: C,
            borderLineWidth: [0, 0, 1, 1],
            padding: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        }
      : {
          cornerRightTopCellStyle: {
            borderColor: C,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        };
  },
  buildCornerLeftBottomCellStyle = (e, T) => {
    const { borderColor: C } = T;
    return isPivot(e.vizData)
      ? {
          cornerLeftBottomCellStyle: {
            borderColor: C,
            borderLineWidth: [1, 0, 0, 0],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        }
      : {
          cornerLeftBottomCellStyle: {
            borderColor: C,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        };
  },
  buildCornerRightBottomCellStyle = (e, T) => {
    const { borderColor: C } = T;
    return isPivot(e.vizData)
      ? {
          cornerRightBottomCellStyle: {
            borderColor: C,
            borderLineWidth: [1, 0, 0, 1],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        }
      : {
          cornerRightBottomCellStyle: {
            borderColor: C,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: "",
            },
          },
        };
  },
  buildRightFrozenStyle = (e, T) => {
    const { borderColor: C, cellBgColor: $ } = T;
    return isPivot(e.vizData)
      ? {
          rightFrozenStyle: {
            borderColor: C,
            borderLineWidth: [1, 0, 1, 1],
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        }
      : {
          rightFrozenStyle: {
            borderColor: C,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        };
  },
  buildBottomFrozenStyle = (e, T) => {
    const { borderColor: C, cellBgColor: $ } = T;
    return isPivot(e.vizData)
      ? {
          bottomFrozenStyle: {
            borderColor: C,
            borderLineWidth: [1, 0, 0, 1],
            padding: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        }
      : {
          bottomFrozenStyle: {
            borderColor: C,
            borderLineWidth: 0,
            bgColor: TRANSPARENT_COLOR$1,
            hover: {
              cellBgColor: $,
            },
          },
        };
  },
  buildSelectionStyle = () => ({
    selectionStyle: {
      cellBgColor: "",
      cellBorderColor: "",
    },
  }),
  buildFrameStyle = () => ({
    frameStyle: {
      borderLineWidth: 0,
      bgColor: TRANSPARENT_COLOR$1,
    },
  }),
  theme$1 = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te;
    const ie = {
        ...e,
      },
      { vizData: ne } = T,
      { chartType: re } = ne;
    isSymbolLikeChart(re) &&
      (ie.point = {
        ...(null != (C = ie.point) ? C : {}),
      }),
      isLineLikeChart(re) &&
        ((ie.line = {
          ...(null != ($ = ie.line) ? $ : {}),
        }),
        (ie.seriesMark = "line"),
        (ie.markOverlap = !0)),
      isAreaLikeChart(re) &&
        (ie.area = {
          ...(null != (F = ie.area) ? F : {}),
          visible: !0,
          style: {
            fillOpacity: 0.35,
          },
        }),
      isPolarChart(re) &&
        ((ie.pie = {
          ...(null != (V = ie.pie) ? V : {}),
        }),
        (ie.rose = {
          ...(null != (Y = ie.rose) ? Y : {}),
        })),
      isBilateral(ne) &&
        lodash.exports.isArray(ie.axes) &&
        ie.axes.forEach((e) => {
          "band" === e.type &&
            ((e.paddingInner = 0.35), (e.paddingOuter = 0.2));
        }),
      isRadarChart(ne) &&
        ((ie.area = {
          ...(null != (K = ie.area) ? K : {}),
          visible: !0,
          style: {
            ...(null != (ee = null == (J = ie.area) ? void 0 : J.style)
              ? ee
              : {}),
            fillOpacity: 0.35,
          },
        }),
        (ie.seriesMark = "line"),
        (ie.markOverlap = !1)),
      isMapChart(ne) && (ie.padding = 0),
      isFunnelChart(ne) &&
        (ie.funnel = {
          ...(null != (te = ie.funnel) ? te : {}),
          style: {
            lineWidth: 1,
          },
        });
    return [regionClip, backgroundColor].reduce(
      (e, C) => (null == C ? void 0 : C(e, T)),
      ie
    );
  },
  trendStyle = (e, { vizData: T }) => {
    var C;
    const $ = T.displayConf;
    if (!(null == (C = $.lineStyle) ? void 0 : C.trendMode)) return e;
    const { areaColorGradient: F, crosshair: V } = $.lineStyle,
      Y = {
        ...e,
      };
    return (
      F &&
        (Y.area = {
          ...Y.area,
          style: {
            fillOpacity: 0.5,
            fill: {
              gradient: "linear",
              x0: 0.5,
              y0: 0,
              x1: 0.5,
              y1: 1,
              stops: [
                {
                  offset: 0,
                  opacity: 0.7,
                },
                {
                  offset: 1,
                  opacity: 0,
                  color: "#fff",
                },
              ],
            },
          },
        }),
      V &&
        (Y.crosshair = {
          xField: {
            line: {
              visible: !0,
              type: "line",
              width: 3,
              style: {
                stroke: "#D1D5DA",
                opacity: 1,
                lineDash: [5, 5],
              },
            },
          },
        }),
      Y
    );
  },
  area = {
    initial: {
      type: "area",
    },
    pipes: [
      cartesian,
      commonLayout,
      datasets,
      stack,
      percent,
      xyAxes$1,
      color,
      legend,
      label,
      tooltip,
      theme$1,
      lineStyle,
      trendStyle,
      invalidType,
      referenceLine,
      displayMode,
      animation,
      brush,
      crosshair,
      pivot,
      tableChartTheme,
      tableChartLegend,
      tableChartDisplayMode,
    ],
  },
  transpose = (e) => ({
    ...e,
    xField: e.yField,
    yField: e.xField,
    direction: "horizontal",
  }),
  bar$1 = {
    initial: {
      type: "bar",
    },
    pipes: [
      cartesian,
      commonLayout,
      datasets,
      transpose,
      stack,
      percent,
      yxAxes,
      color,
      legend,
      label,
      tooltip,
      barInteractive,
      theme$1,
      referenceLine,
      displayMode,
      animation,
      brush,
      crosshair,
      barStyle,
      pivot,
      tableChartTheme,
      tableChartLegend,
      tableChartDisplayMode,
    ],
  },
  bilateral = {
    initial: {},
    pipes: [
      initMultiSeriesChart,
      commonLayout,
      bilateralLayout,
      datasets,
      multiSeriesStack,
      yxxAxes,
      color,
      multiSeriesLabel,
      legend,
      tooltip,
      seriesPipelineWrapper(barInteractive),
      theme$1,
      referenceLine,
      crosshair,
      barStyle,
      seriesPipelineWrapper(animation),
    ],
  },
  size = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      Y = V.cells[0],
      K = getScatterSizeRange(V).map((e) => chartSpaceSizeToVChartSize(e)),
      J = null == (C = V.displayConf.size) ? void 0 : C.domain,
      ee = {
        ...e,
      };
    if (
      (null == ($ = Y.size) ? void 0 : $[0]) &&
      ((ee.sizeField = Y.size[0]),
      (ee.size = {
        type: "linear",
        range: [...K.map(chartSpaceSizeToVChartSize)],
      }),
      J)
    ) {
      const e =
        null != (F = V.fieldMap[Y.size[0]].domain)
          ? F
          : getMinMaxFromDomain(
              getDomainFromDataset(V.datasets.flat(3), Y.size[0])
            );
      (ee.size.domain = J.map((T, C) => ("auto" === T ? e[C] : T))),
        e[0] < J[0] &&
          (ee.size.range.unshift(K[0]), ee.size.domain.unshift(e[0])),
        e[1] > J[1] && (ee.size.range.push(K[1]), ee.size.domain.push(e[1]));
    }
    return ee;
  },
  circleViews = {
    initial: {},
    pipes: [
      initScatter,
      commonLayout,
      datasets,
      xyAxes$1,
      circleViewsLabel,
      scatterLegend,
      color,
      size,
      tooltip,
      theme$1,
      scatterInteractive,
      referenceLine,
      animation,
    ],
  },
  column = {
    initial: {
      type: "bar",
    },
    pipes: [
      cartesian,
      commonLayout,
      datasets,
      stack,
      percent,
      xyAxes$1,
      color,
      legend,
      label,
      tooltip,
      columnInteractive,
      theme$1,
      trendStyle,
      referenceLine,
      displayMode,
      animation,
      brush,
      crosshair,
      barStyle,
      pivot,
      tableChartTheme,
      tableChartLegend,
      tableChartDisplayMode,
    ],
  },
  combination = {
    initial: {},
    pipes: [
      initCombination,
      commonLayout,
      datasets,
      xAxes,
      legend,
      combinationRecords,
      combinationIndicators,
      combinationLabel,
      combinationReferenceLine,
      animation,
      pivot,
      tableChartLegend,
      tableChartTheme,
      tableChartDisplayMode,
      barStyle,
    ],
  },
  dualAxisInteractive = buildInteractive([common, bar$2]),
  dualAxis = {
    initial: {},
    pipes: [
      initMultiSeriesChart,
      commonLayout,
      datasets,
      multiSeriesStack,
      xyyAxes,
      color,
      legend,
      multiSeriesLabel,
      tooltip,
      multipleLineStyle,
      crosshair,
      seriesPipelineWrapper(dualAxisInteractive),
      seriesPipelineWrapper(invalidType),
      backgroundColor,
      seriesPipelineWrapper(theme$1),
      seriesPipelineWrapper(animation),
      referenceLine,
      displayMode,
      barStyle,
      brush,
      pivot,
      tableChartTheme,
      tableChartLegend,
      tableChartDisplayMode,
    ],
  },
  funnelRate = (e, { vizData: T }) => {
    var C;
    const $ = T.cells[0],
      F = String(null == (C = $.size) ? void 0 : C[0]),
      V = e.data[0].values[0];
    return (
      (e.data[0].values = e.data[0].values.map((T, C) => {
        const $ = converStringToNumber(T[F]),
          Y = C > 0 ? converStringToNumber(e.data[0].values[C - 1][F]) : null,
          K = converStringToNumber(V[F]);
        return {
          ...T,
          transfer:
            lodash.exports.isNil($) || lodash.exports.isNil(Y) ? null : $ / Y,
          baseTransfer:
            lodash.exports.isNil($) || lodash.exports.isNil(K) ? null : $ / K,
        };
      })),
      e
    );
  },
  transformLayer = (e, { vizData: T }) => {
    const C = T.displayConf,
      { transform: $ } = C,
      {
        labelContent: F,
        visible: V,
        labelColor: Y,
        labelSize: K,
        labelFont: J,
        labelWeight: ee,
      } = C.label;
    return {
      ...e,
      isTransform: !0,
      transformLabel: {
        ...e.transformLabel,
        visible: V && F.includes(LabelContent.TRANSFER),
        style: {
          fontSize: K,
          fill: Y === LabelColor.DEFAULT || Y === LabelColor.AUTO ? void 0 : Y,
          fontFamily: J,
          fontWeight: ee,
        },
      },
      transform: {
        ...e.transform,
        interactive: !1,
        style: {
          fill: null == $ ? void 0 : $.backgroundColor,
        },
      },
    };
  },
  funnel$1 = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      { interactiveStyle: F } = $,
      V = buildHover(F),
      Y = buildSelected(F),
      K = buildSelectedReverse();
    return {
      ...e,
      funnel: {
        ...C.funnel,
        state: {
          hover: {
            ...V,
          },
          selected: {
            ...Y,
          },
          selected_reverse: {
            ...K,
          },
        },
      },
    };
  },
  funnelInteractive = buildInteractive([common, funnel$1]),
  funnel = {
    initial: {
      type: "funnel",
    },
    pipes: [
      initFunnel,
      datasets,
      transformLayer,
      funnelRate,
      color,
      legend,
      funnelLabel,
      funnelInteractive,
      tooltip,
      theme$1,
      animation,
    ],
  },
  gauge = {
    initial: {
      type: "gauge",
    },
    pipes: [
      initGauge,
      gaugeData,
      gaugeReverse,
      gaugeAxis,
      gaugeSection,
      gaugeStyle,
      gaugeIndicator,
      gaugeExtensionMark,
      tooltip,
      theme$1,
    ],
  },
  histogramAxis = (e, { vizData: T }) => {
    var C;
    const $ = T.displayConf,
      F = Object.keys(T.fieldMap).find(
        (e) => T.fieldMap[e].location === Location.DIMENSION
      ),
      V =
        null == (C = e.series.find((e) => e.id === MAIN_SERIES_ID))
          ? void 0
          : C.data.values;
    let Y,
      K,
      J = 1 / 0,
      ee = -1 / 0;
    if (V) {
      const e = Math.abs(
        parseFloat(V[0][`${F}_interval_0`]) -
          parseFloat(V[0][`${F}_interval_1`])
      );
      V.forEach((e) => {
        (J = Math.min(J, parseFloat(e[`${F}_interval_0`]))),
          (ee = Math.max(ee, parseFloat(e[`${F}_interval_1`])));
      }),
        (Y = {
          ...axisMeasure(
            {
              ...$.axisMeasure[0],
              numFormat: {
                auto: !1,
                kSep: !0,
                precision: 0,
                precisionType: PrecisionType.DECIMAL_DIGITS,
                type: FormatType.DIGIT,
                unit: null,
                prefix: "",
                suffix: "",
              },
            },
            "left"
          ),
          orient: "left",
          seriesId: MAIN_SERIES_ID,
          grid: {
            visible: !0,
            style: {
              stroke: "#DADCDD",
              lineWidth: 1,
              lineDash: [4, 2],
            },
          },
        }),
        Y &&
          (Y.domainLine = {
            visible: !1,
          }),
        (K = {
          ...axisMeasure(
            {
              ...$.axisMeasure[0],
              numFormat: {
                type: FormatType.DIGIT,
                precision: 2,
                precisionType: PrecisionType.DECIMAL_DIGITS,
              },
            },
            "bottom"
          ),
          seriesId: MAIN_SERIES_ID,
          grid: {
            visible: !0,
            style: {
              stroke: "#DADCDD",
              lineWidth: 1,
              lineDash: [4, 2],
            },
          },
          min: J,
          max: ee,
          tick: {
            visible: !1,
            tickStep: e,
          },
        });
    }
    const te = {
      ...axisMeasure(
        {
          ...$.axisMeasure[0],
          numFormat: {
            type: FormatType.PERCENT,
          },
        },
        "right"
      ),
      seriesId: SUB_SERIES_ID,
      grid: {
        visible: !1,
      },
    };
    (te.domainLine = {
      visible: !1,
    }),
      (te.zero = !0);
    const ie = {
      ...axisDimension($.axisDimension[0], "bottom", $.specialValue),
      seriesId: SUB_SERIES_ID,
      grid: {
        visible: !0,
        style: {
          stroke: "#DADCDD",
          lineWidth: 1,
          lineDash: [4, 2],
        },
      },
    };
    return (
      (ie.visible = !1),
      (ie.paddingOuter = 0),
      (ie.paddingInner = 0),
      "value" === $.histogram.showType
        ? {
            ...e,
            axes: [Y, K],
          }
        : "ratio" === $.histogram.showType
        ? ((ie.visible = !0),
          {
            ...e,
            axes: [te, ie],
          })
        : {
            ...e,
            axes: [Y, te, K, ie],
          }
    );
  },
  histogramColor = (e, { vizData: T }) => {
    const C = T.displayConf;
    if (
      ((T.cells[0].color = ["type"]),
      (T.colorItems = ["value", "ratio"]),
      !C.color)
    )
      return e;
    const { colorItems: $ = [] } = T,
      F = $,
      V = getColorsFromScheme(C.color, F);
    return (
      (V[0] = getColorFromGradients(V[0])),
      (V[1] = chroma(getColorFromGradients(V[0])).darken().css()),
      {
        ...e,
        color: {
          field: void 0,
          type: "ordinal",
          range: V,
        },
      }
    );
  },
  histogramDatasets = (e, { vizData: T }) => {
    var C;
    const $ = T.displayConf,
      { fieldMap: F, datasets: V } = T,
      Y = Object.keys(F).find((e) => F[e].location === Location.DIMENSION);
    let K = JSON.parse(JSON.stringify(V[0][0][0])),
      J = 0;
    "ordinary" === $.histogram.type
      ? K.forEach((e) => {
          J += parseFloat(e[`${Y}_value`]);
        })
      : ((J = -1 / 0),
        K.forEach((e) => {
          J = Math.max(parseFloat(e[`${Y}_value`]), J);
        })),
      (K = K.map((e) => {
        for (const T in e)
          if (
            -1 !== T.search("interval") &&
            -1 === T.search("interval_0") &&
            -1 === T.search("interval_1")
          ) {
            const C = e[T].split("_");
            (e[`${T}_0`] = C[0]),
              (e[`${T}_1`] = C[1]),
              (e[T] = e[T].replace("_", "-"));
          }
        return (
          (e[`${Y}_ratio`] = e[`${Y}_value`] / J),
          (e.type = "ratio"),
          (e.secondType = "value"),
          e
        );
      }));
    let ee = JSON.parse(JSON.stringify(K));
    (ee = ee.map((e) => ((e.type = "value"), (e.secondType = "ratio"), e))),
      F[`${Y}_interval`] || (F[`${Y}_interval`] = {}),
      F[`${Y}_value`] || (F[`${Y}_value`] = {}),
      (F[`${Y}_interval`].alias = "interval"),
      (F[`${Y}_value`].alias = "value");
    const te = e.series.find((e) => e.id === MAIN_SERIES_ID),
      ie = e.series.find((e) => e.id === SUB_SERIES_ID),
      ne = {};
    return (
      F &&
        Object.keys(F).forEach((e) => {
          ne[e] = {
            alias: F[e].alias,
          };
        }),
      te &&
        (te.data = {
          id: "interval",
          values: ee,
          fields: ne,
        }),
      ie &&
        ((ie.data = {
          id: "band",
          values: K,
          fields: ne,
        }),
        (ie.line = {
          ...ie.line,
          style: {
            ...(null == (C = null == ie ? void 0 : ie.line) ? void 0 : C.style),
            curveType: "monotone",
          },
        })),
      {
        ...e,
        series: [te, ie].filter(Boolean),
      }
    );
  },
  histogramTooltip = (e, { vizData: T }) => {
    var C, $;
    const F = Object.keys(T.fieldMap).find(
        (e) => T.fieldMap[e].location === Location.DIMENSION
      ),
      { showType: V } =
        null != ($ = null == (C = T.displayConf) ? void 0 : C.histogram)
          ? $
          : {},
      Y = {
        ...e,
      },
      K = {
        title: {
          value: (e) => e[`${F}_interval`],
        },
        content: [
          V === HistogramShowType.RATIO
            ? {}
            : {
                key: "value",
                value: (e) => e[`${F}_value`],
                hasShape: !1,
              },
          V === HistogramShowType.VALUE
            ? {}
            : {
                key: "ratio",
                value: (e) => percentFormatter(e[`${F}_ratio`], 4),
                hasShape: !1,
              },
        ],
      };
    return (
      e.series.forEach((e) => {
        e.tooltip = {
          mark: K,
          dimension: K,
        };
      }),
      Y
    );
  },
  histogramCrosshair = (e, T) => {
    const { vizData: C } = T,
      $ = C.displayConf;
    return {
      ...e,
      crosshair: {
        ...e.crosshair,
        xField: {
          visible: !0,
          bindingAxesIndex: [
            $.histogram.showType === HistogramShowType.DEFAULT ? 2 : 1,
          ],
          line: {
            type: "rect",
            style: {
              stroke: "rgba(0,0,0,0)",
              fillOpacity: 0.2,
              fill: "#b2bacf",
            },
          },
        },
        gridZIndex: 0,
      },
    };
  },
  histogram = {
    initial: {
      type: "common",
    },
    pipes: [
      initHistogram,
      commonLayout,
      histogramDatasets,
      histogramAxis,
      histogramColor,
      histogramTooltip,
      histogramCrosshair,
      histogramInteractive,
      backgroundColor,
      seriesPipelineWrapper(theme$1),
      animation,
      brush,
    ],
  },
  line = {
    initial: {
      type: "line",
    },
    pipes: [
      cartesian,
      commonLayout,
      datasets,
      stack,
      percent,
      xyAxes$1,
      color,
      legend,
      label,
      tooltip,
      theme$1,
      lineStyle,
      trendStyle,
      invalidType,
      referenceLine,
      displayMode,
      animation,
      brush,
      forecast,
      crosshair,
      pivot,
      tableChartTheme,
      tableChartLegend,
      tableChartDisplayMode,
    ],
  },
  map = {
    initial: {
      type: "map",
    },
    pipes: [
      initMap,
      location,
      datasets,
      color,
      mapLegend,
      mapLabel,
      tooltip,
      theme$1,
      mapInteractive,
      animation,
    ],
  },
  pie = {
    initial: {
      type: "pie",
    },
    pipes: [
      polar,
      datasets,
      polarRadius,
      color,
      polarMerge,
      polarLabel,
      legend,
      centerValue,
      polarInteractive,
      tooltip,
      theme$1,
      animation,
    ],
  },
  progress = {
    initial: {},
    pipes: [
      initProgress,
      progressData,
      progressAxis,
      progressIndicator,
      progressStyle,
      progressText,
      progressGoal,
      progressSection,
      theme$1,
      animation,
      tooltip,
    ],
  },
  radar = {
    initial: {
      type: "radar",
    },
    pipes: [
      initRadar,
      datasets,
      radarAxis,
      color,
      radarLabel,
      legend,
      tooltip,
      theme$1,
      lineStyle,
      invalidType,
      animation,
    ],
  },
  rose = {
    initial: {
      type: "rose",
    },
    pipes: [
      polar,
      roseAxis,
      datasets,
      polarRadius,
      polarLabel,
      color,
      polarMerge,
      legend,
      centerValue,
      polarInteractive,
      tooltip,
      theme$1,
      animation,
    ],
  },
  sankey = {
    initial: {
      type: "sankey",
    },
    pipes: [
      initSankey,
      sankeyColor,
      hierarchySankey,
      sankeyLegend,
      sankeyLabel,
      sankeyDimensionLabel,
      tooltip,
      theme$1,
      sankeyInteractive,
      animation,
    ],
  },
  scatter = {
    initial: {},
    pipes: [
      initScatter,
      commonLayout,
      datasets,
      yyAxes,
      scatterLabel,
      scatterLegend,
      color,
      size,
      tooltip,
      theme$1,
      scatterInteractive,
      referenceLine,
      animation,
      brush,
    ],
  },
  scatterMap = {
    initial: {
      type: "common",
    },
    pipes: [
      initScatterMap,
      location,
      datasets,
      scatterMapColor,
      scatterMapSize,
      scatterMapLegend,
      scatterMapLabel,
      tooltip,
      multipleInteractive,
      backgroundColor,
      seriesPipelineWrapper(theme$1),
      seriesPipelineWrapper(animation),
    ],
  },
  waterfallData = (e, { vizData: T }) => {
    var C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae, oe, se, le;
    const { datasets: de, cells: ce, chartType: ue, fieldMap: he } = T,
      pe = T.cells[0],
      ge =
        null !=
        (C = Object.keys(he).filter(
          (e) => T.fieldMap[e].location === Location.DETAIL
        ))
          ? C
          : [],
      fe = T.displayConf,
      { color: me } = fe,
      ye = {};
    he &&
      (Object.keys(he).forEach((e) => {
        ye[e] = {
          alias: he[e].alias,
        };
      }),
      Object.keys(he).forEach((e) => {
        var T, C, $, F;
        "string" ==
          typeof (null == (C = null == (T = he[e]) ? void 0 : T.domain)
            ? void 0
            : C[0]) &&
          ((ye[e].domain = he[e].domain),
          (ye[e].lockStatisticsByDomain = !0),
          (null == ($ = null == pe ? void 0 : pe.x) ? void 0 : $[0]) &&
            e === (null == (F = null == pe ? void 0 : pe.x) ? void 0 : F[0]) &&
            (ye[e].sortIndex = 0));
      }));
    const be = null == ($ = null == pe ? void 0 : pe.x) ? void 0 : $[0],
      ve = null == (F = null == pe ? void 0 : pe.y) ? void 0 : F[0];
    let Te = de[0][0][0];
    const _e = [];
    if (ue === ChartType.WATERFALL) {
      const e = intl.i18n``,
        T = [];
      "string" ==
        typeof (null == (Y = null == (V = he[be]) ? void 0 : V.domain)
          ? void 0
          : Y[0]) && lodash.exports.set(ye, `${be}.domain`, T);
      let C = 0;
      Te = Te.map((e) => {
        const $ = {
            ...e,
          },
          F = $[be];
        T.push(F);
        const V = Number($[ve]);
        return (
          (C += V),
          ($.type =
            V >= 0
              ? WaterfallColorsDictKey.Increase
              : WaterfallColorsDictKey.Decrease),
          _e.includes($.type) || _e.push($.type),
          $
        );
      });
      const $ = null == (K = null == pe ? void 0 : pe.foldInfo) ? void 0 : K.id,
        F = Te[0][null != $ ? $ : ve];
      Te.push({
        ...(null != (J = Te[0]) ? J : []),
        [be]: e,
        [ve]: `${C}`,
        [F]: `${C}`,
        type: WaterfallColorsDictKey.Total,
        isTotal: !0,
      }),
        _e.push(WaterfallColorsDictKey.Total),
        T.push(e);
    } else if (ue === ChartType.WATERFALL_CHANGE) {
      (Te = Te.map((e) =>
        Object.keys(e).reduce((T, C) => {
          var $;
          return {
            ...T,
            [C]: createFormatter(null == ($ = he[C]) ? void 0 : $.format)(e[C]),
          };
        }, {})
      )),
        (ye.x = lodash.exports.cloneDeep(ye[be])),
        delete ye[be].sortIndex,
        delete ye[be].domain,
        delete ye[be].lockStatisticsByDomain;
      const T =
          null !=
          (re =
            null != (ne = ge[0])
              ? ne
              : null ==
                (ie =
                  null ==
                  (te =
                    null == (ee = null == ce ? void 0 : ce[0])
                      ? void 0
                      : ee.cartesianInfo)
                    ? void 0
                    : te.fieldList)
              ? void 0
              : ie[0])
            ? re
            : Object.keys(he).filter((e) => e !== be && e !== ve)[0],
        C = [];
      Te.forEach((e) => {
        let $ = C.findIndex((T) => T.title === e[be]);
        $ < 0 &&
          ($ =
            C.push({
              title: e[be],
              measure: 0,
              segments: [],
              displaySegments: [],
            }) - 1);
        const F = {
          title: e[T],
          measure: Number(e[ve]),
        };
        C[$].segments.push(F),
          C[$].displaySegments.push({
            ...F,
          }),
          (C[$].measure += F.measure);
      });
      const $ = new Map();
      C.forEach((e) => {
        var T, C;
        $.set(
          e.title,
          null == (C = null == (T = he[be]) ? void 0 : T.domain)
            ? void 0
            : C.indexOf(e.title)
        );
      }),
        C.sort((e, T) => $.get(e.title) - $.get(T.title)),
        C.forEach((e, T) => {
          T > 0 &&
            C[T - 1].segments.forEach((T) => {
              const C = e.displaySegments.findIndex((e) => e.title === T.title);
              C < 0
                ? e.displaySegments.push({
                    ...T,
                    measure: -T.measure,
                  })
                : (e.displaySegments[C].measure -= T.measure);
            });
        }),
        C.forEach((e) => {
          var T;
          e.displaySegments.sort(
            (e, T) => Math.abs(T.measure) - Math.abs(e.measure)
          );
          const { maxItemCount: C = 0 } = null != (T = fe.segment) ? T : {};
          if (e.displaySegments.length > C) {
            const T = e.displaySegments.slice(0, C);
            T.push({
              title: intl.i18n``,
              measure: e.displaySegments
                .slice(C)
                .map((e) => e.measure)
                .reduce((e, T) => e + T, 0),
              isOthers: !0,
            }),
              T.sort((e, T) => T.measure - e.measure),
              (e.displaySegments = T);
          } else e.displaySegments.sort((e, T) => T.measure - e.measure);
        }),
        (Te = []),
        (ye.x.domain = []);
      const F = null == (ae = ce[0].foldInfo) ? void 0 : ae.key,
        V = Object.entries(
          null !=
            (le =
              null == (se = null == (oe = ce[0]) ? void 0 : oe.foldInfo)
                ? void 0
                : se.foldMap)
            ? le
            : {}
        ),
        Y = V[0][0],
        K = V[0][1];
      C.forEach((e, C) => {
        C > 0 &&
          e.displaySegments.forEach(($) => {
            const V = $.isOthers
                ? WaterfallColorsDictKey.Others
                : $.measure >= 0
                ? WaterfallColorsDictKey.Increase
                : WaterfallColorsDictKey.Decrease,
              J = $.title + Array(C).fill("").join("");
            Te.push({
              [F]: K,
              [be]: e.title,
              [T]: $.title,
              [ve]: $.measure,
              [Y]: $.measure,
              x: J,
              type: V,
            }),
              ye.x.domain.push(J),
              _e.includes(V) || _e.push(V);
          });
        const $ = WaterfallColorsDictKey.Item;
        Te.push({
          [F]: K,
          [be]: e.title,
          [ve]: e.measure,
          [Y]: e.measure,
          x: e.title,
          type: $,
          isTotal: !0,
        }),
          ye.x.domain.push(e.title),
          _e.includes($) || _e.push($);
      }),
        (e.xField = "x");
    }
    return {
      ...e,
      seriesField: "type",
      data: [
        {
          id: CHART_DATA_ID,
          values: Te,
          fields: ye,
        },
      ],
      color: {
        field: "type",
        type: "ordinal",
        domain: _e,
        range: _e.map((e) => {
          var T;
          return null == (T = me.colorsDict) ? void 0 : T[e];
        }),
      },
      total: {
        type: "field",
        tagField: "isTotal",
        valueField: ve,
      },
    };
  },
  getLabelCustomOverlapFunc = (e, T) => (T, C, $, F) => {
    if (!T || T.length <= 1) return;
    const V = [],
      Y = [],
      K = [];
    for (const te of T) e.includes(te.attribute.text) ? Y.push(te) : K.push(te);
    let J = 0,
      ee = 0;
    for (; J <= Y.length - 1 && ee <= Y.length - 1; ) {
      for (
        V.push(Y[J]), ee = J + 1;
        ee <= Y.length - 1 && checkIsOverlap(Y[J], Y[ee]);

      )
        Y[ee].setAttribute("fillOpacity", 0), ee++;
      J = ee;
    }
    (J = 0),
      K.forEach((e, T) => {
        V.some((T) => checkIsOverlap(T, e)) ||
        (T > 0 && checkIsOverlap(K[J], e))
          ? e.setAttribute("fillOpacity", 0)
          : (J = T);
      });
  },
  xyAxes = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      V = F.displayConf,
      Y = null == (C = F.cells[0].x) ? void 0 : C[0],
      K = axisDimension(V.axisDimension[0], "bottom", V.specialValue, {
        spec: e,
        format:
          F.chartType === ChartType.WATERFALL_CHANGE
            ? void 0
            : F.fieldMap[Y].format,
        id: void 0,
        labelCustomOverlap:
          F.chartType === ChartType.WATERFALL_CHANGE
            ? getLabelCustomOverlapFunc(
                null != ($ = F.fieldMap[Y].domain) ? $ : []
              )
            : void 0,
      }),
      J = axisMeasure(V.axisMeasure[0], "left", {
        spec: e,
      });
    return {
      ...e,
      axes: [K, J],
    };
  },
  waterfallDisplay = (e, T) => ({
    ...e,
    stackLabel: {
      visible: !1,
    },
    leaderLine: {
      style: {
        lineDash: [1, 1],
      },
    },
  }),
  waterfall = {
    initial: {
      type: "waterfall",
    },
    pipes: [
      cartesian,
      commonLayout,
      waterfallData,
      xyAxes,
      label,
      waterfallDisplay,
      barStyle,
      theme$1,
      referenceLine,
      tooltip,
      barInteractive,
      displayMode,
      animation,
      crosshair,
    ],
  },
  wordCloud$1 = (e, { vizData: T }) => {
    const C = {
        ...e,
      },
      { displayConf: $ } = T,
      { interactiveStyle: F } = $,
      V = buildHover(F),
      Y = buildSelected(F),
      K = buildSelectedReverse();
    return {
      ...e,
      word: {
        ...C.word,
        state: {
          hover: {
            ...V,
          },
          selected: {
            ...Y,
          },
          selected_reverse: {
            ...K,
          },
        },
      },
    };
  },
  wordCloudInteractive = buildInteractive([common, wordCloud$1]),
  wordCloud = {
    initial: {
      type: "wordCloud",
    },
    pipes: [
      initWordCloud,
      datasets,
      color,
      wordCloudInteractive,
      tooltip,
      theme$1,
      animation,
    ],
  },
  liquid = {
    initial: {},
    pipes: [
      initLiquid,
      liquidData,
      liquidReverse,
      liquidIndicator,
      liquidStyle,
      liquidGoal,
      theme$1,
      animation,
      tooltip,
    ],
  },
  columnOrder = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $ } = T,
      { displayConf: F } = $,
      { columns: V } = C;
    if (V && F.columnOrder) {
      const e = F.columnOrder;
      C.columns = [...V].sort(
        (T, C) => e.indexOf(T.field) - e.indexOf(C.field)
      );
    }
    return C;
  },
  getFormatter = (e, T, C) => {
    var $, F;
    const { fieldMap: V } = T,
      Y = T.displayConf;
    if (!V[e]) return;
    const K = C || getFieldFormat(e, T),
      J =
        (null == ($ = Y.specialValue) ? void 0 : $.dimensions) ||
        SpecialValueType$1.NULL,
      ee =
        (null == (F = Y.specialValue) ? void 0 : F.measures) ||
        SpecialValueType$1.BRACKET_TXT,
      te = V[e].role === Role.MEASURE ? ee : J;
    return createFormatter(K, INVALID_VALUE_MAP$5[te]);
  },
  formatter$1 = (e, T) => {
    const C = completeFieldFormat(e.columns, T);
    return {
      ...e,
      columns: C,
    };
  },
  completeFieldFormat = (e, { vizData: T }) => (
    e.forEach((e) => {
      const { field: C } = e;
      if (!C) return;
      const $ = getFormatter(C, T);
      $ && (e.fieldFormat = (e) => $(e[C]));
    }),
    e
  ),
  keyValuePairsToObj = (e) => {
    var T;
    return null !=
      (T =
        null == e ? void 0 : e.reduce((e, T) => ((e[T.key] = T.value), e), {}))
      ? T
      : {};
  },
  keyValuePairsToColumnWidthDict = (e) => keyValuePairsToObj(e);
var ColumnType = ((e) => (
  (e.Image = "image"),
  (e.Video = "video"),
  (e.Link = "link"),
  (e.Sparkline = "sparkline"),
  e
))(ColumnType || {});
const iconSource = {
    [TableIconType.FLAG]:
      '<svg width="1em" height="1em" viewBox="0 0 1024 1024" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M111.709091 78.289455h795.927273v884.363636l-393.541819-132.654546-402.385454 132.654546z"/></svg>',
    [TableIconType.STAR]:
      '<svg width="1em" height="1em" viewBox="0 0 1024 1024" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M512 878.824727l-316.416 121.483637 47.243636-345.786182L0 398.429091l332.567273-57.949091L512 26.437818l179.432727 314.042182L1024 398.429091l-242.827636 256.093091 47.243636 345.832727z"/></svg>',
    [TableIconType.CIRCLE]:
      '<svg width="1em" height="1em" viewBox="0 0 1024 1024" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M512 954.181818a442.181818 442.181818 0 1 0 0-884.363636 442.181818 442.181818 0 0 0 0 884.363636z"/></svg>',
    [TableIconType.SQUARE]:
      '<svg width="1em" height="1em" viewBox="0 0 1024 1024" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M116.363636 116.363636h791.272728v791.272728h-791.272728z"/></svg>',
  },
  iconOffset = {
    [TableIconType.FLAG]: -0.1,
    [TableIconType.STAR]: 0,
    [TableIconType.CIRCLE]: -0.08,
    [TableIconType.SQUARE]: -0.12,
  },
  getOriginRecord = (e, T, C) => {
    if (!e || "number" != typeof T || "number" != typeof C) return {};
    const $ = e.getCellOriginRecord(T, C);
    return Array.isArray($) ? $[$.length - 1] : $;
  },
  COMPACT_FIELD_PREFIX = "#tmp_group_",
  COMPACT_GROUP_PREFIX = "group",
  COMPACT_GROUP_INDICATOR_PREFIX = "index",
  COMPACT_GROUP_DIM_KEY = "_COMPACT_GROUP_DIMENSION_",
  COMPACT_GROUP_INDEX_KEY = "_COMPACT_GROUP_INDEX_",
  COMPACT_GROUP_ORIGIN_FIELD_KEY = "_COMPACT_GROUP_ORIGIN_FIELD_",
  getGroupsForTranspose = (e, T) => {
    const C = [],
      $ = {};
    let F = 1;
    const V = {};
    return (
      null == e ||
        e.forEach((e) => {
          const Y = [];
          e.field && Y.push(e.field),
            e.isGroup &&
              Y.push(
                ...e.children
                  .map((e) => {
                    var T;
                    return null != (T = e.field) ? T : "";
                  })
                  .filter((e) => "" !== e)
              );
          const K = `${COMPACT_GROUP_PREFIX}-${Y.join("-")}`;
          let J;
          Y.forEach((C) => {
            var $;
            (V[C] = K),
              !("title" in e) &&
                T &&
                (J = null == ($ = T[C]) ? void 0 : $.title);
          }),
            Y.length > F && (F = Y.length);
          const ee = {
            groupId: K,
            fields: Y,
            title: "title" in e ? e.title : J,
          };
          C.push(ee), ($[K] = ee);
        }),
      {
        groups: C,
        groupMap: $,
        groupLength: F,
        fieldGroupMap: V,
      }
    );
  },
  listTableCompact = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C;
    return checkEnable(T)
      ? (!$.transpose && "vertical" === $.compactDirection) ||
        ($.transpose && "horizontal" === $.compactDirection)
        ? {
            ...e,
            ...transposeCompact$1(e, T),
          }
        : {
            ...e,
            ...commonCompact$1(e, T),
          }
      : e;
  },
  checkEnable = (e) => {
    const { vizData: T } = e,
      { displayConf: C } = T;
    return !(
      !0 !== C.compact ||
      !T.fieldGroups ||
      !T.fieldGroups.length ||
      C.columnOrder
    );
  },
  commonCompact$1 = (e, T) => {
    var C, $, F, V, Y, K, J;
    const ee = {
        ...e,
      },
      { vizData: te } = T,
      { displayConf: ie } = te,
      { fieldGroups: ne } = te,
      { columns: re } = ee,
      ae = [],
      oe = {};
    (null != (C = te.cells[0].column) ? C : []).forEach((e) => {
      oe[e] = {
        type: "single",
      };
    }),
      null == ne ||
        ne.forEach((e, T) => {
          e.field && ae.push(e.field),
            e.isGroup &&
              ae.push(
                ...e.children
                  .map((e) => {
                    var T;
                    return null != (T = e.field) ? T : "";
                  })
                  .filter((e) => "" !== e)
              ),
            e.isGroup && e.children.length > 0
              ? ((oe[e.field] = {
                  type: "group",
                  title: e.title,
                }),
                e.children.forEach(({ field: C }) => {
                  var $;
                  void 0 !== C &&
                    (oe[C] = {
                      type: "related",
                      parent:
                        null != ($ = e.field)
                          ? $
                          : `${COMPACT_FIELD_PREFIX}${T}`,
                      originalParent: e.field,
                    });
                }))
              : (oe[e.field] = {
                  type: "single",
                });
        }),
      null == re ||
        re.forEach((e) => {
          const { field: T } = e;
          oe[T] ||
            (oe[T] = {
              type: "single",
            });
        });
    const se = [],
      { transpose: le } = ie,
      de = {},
      ce = [];
    null == re ||
      re.forEach((e) => {
        var T, C, $;
        const { field: F } = e;
        if ("single" === oe[F].type) se.push(e);
        else if ("group" === oe[F].type) {
          const T = {
            ...e,
            title: oe[F].title,
            hideColumnsSubHeader: !0,
            columns: [e],
            columnWidthComputeMode: le ? "normal" : "only-body",
          };
          se.push(T), (de[F] = se[se.length - 1]);
        } else {
          if (
            null == (T = oe[F].parent)
              ? void 0
              : T.startsWith(COMPACT_FIELD_PREFIX)
          ) {
            const T = Number(
                null == (C = oe[F].parent)
                  ? void 0
                  : C.substring(COMPACT_FIELD_PREFIX.length)
              ),
              V = null == ($ = te.fieldGroups) ? void 0 : $[T];
            if (!0 === (null == V ? void 0 : V.isGroup)) {
              const T = {
                ...e,
                title: null == V ? void 0 : V.title,
                hideColumnsSubHeader: !0,
                columns: [],
                columnWidthComputeMode: le ? "normal" : "only-body",
              };
              se.push(T),
                (de[F] = se[se.length - 1]),
                null == V ||
                  V.children.forEach(({ field: e }) => {
                    e && (oe[e].parent = F);
                  });
            }
          }
          oe[F].originalParent || (de[oe[F].parent].title = e.title),
            ce.push(e);
        }
      }),
      ce.forEach((e) => {
        const { field: T } = e,
          C = de[oe[T].parent];
        C && (null == C ? void 0 : C.columns) ? C.columns.push(e) : se.push(e);
      });
    const { theme: ue = {} } = ee,
      [he, pe, ge, fe] =
        null != (F = null == ($ = ue.bodyStyle) ? void 0 : $.borderColor)
          ? F
          : [null, null, null, null],
      me =
        null != (Y = null == (V = ue.headerStyle) ? void 0 : V.padding)
          ? Y
          : [],
      ye =
        null != (J = null == (K = ue.bodyStyle) ? void 0 : K.borderLineWidth)
          ? J
          : [];
    for (const be of Object.keys(de)) {
      de[be].headerStyle.textAlign = "center";
      const { columns: e } = de[be];
      null == e ||
        e.forEach((T, C) => {
          if (0 === C) {
            const e = [
              me[0],
              3 + ye[1] / 2,
              me[2],
              null === ie.rowPadding ? 10 + ye[3] / 2 : me[3],
            ];
            ie.transpose
              ? "object" == typeof T.style &&
                (T.style.borderColor = [he, pe, null, fe])
              : "object" == typeof T.style &&
                (T.style.borderColor = [he, null, ge, fe]),
              "object" == typeof T.style && (T.style.padding = e),
              "object" == typeof T.headerStyle && (T.headerStyle.padding = e);
          } else if (C === e.length - 1) {
            const e = [
              me[0],
              null === ie.rowPadding ? 3 + ye[1] / 2 : me[1],
              me[2],
              3 + ye[3] / 2,
            ];
            ie.transpose
              ? "object" == typeof T.style &&
                (T.style.borderColor = [null, pe, ge, fe])
              : "object" == typeof T.style &&
                (T.style.borderColor = [he, pe, ge, null]),
              "object" == typeof T.style && (T.style.padding = e),
              "object" == typeof T.headerStyle && (T.headerStyle.padding = e);
          } else {
            const e = [me[0], 3 + ye[1] / 2, me[2], 3 + ye[3] / 2];
            ie.transpose
              ? "object" == typeof T.style &&
                (T.style.borderColor = [null, pe, null, fe])
              : "object" == typeof T.style &&
                (T.style.borderColor = [he, null, ge, null]),
              "object" == typeof T.style && (T.style.padding = e),
              "object" == typeof T.headerStyle && (T.headerStyle.padding = e);
          }
        });
    }
    return {
      ...ee,
      columns: se,
    };
  },
  transposeCompact$1 = (e, T) => {
    var C, $, F, V, Y, K;
    const J = {
        ...e,
      },
      { vizData: ee } = T,
      { displayConf: te } = ee,
      { columnWidth: ie, transpose: ne, display: re } = te,
      { columns: ae, records: oe, theme: se = {}, menu: le } = J,
      [de, ce, ue, he] =
        null != ($ = null == (C = se.bodyStyle) ? void 0 : C.borderColor)
          ? $
          : [null, null, null, null],
      pe =
        null != (V = null == (F = se.headerStyle) ? void 0 : F.padding)
          ? V
          : [],
      ge =
        null != (K = null == (Y = se.bodyStyle) ? void 0 : Y.borderLineWidth)
          ? K
          : [],
      fe = keyValuePairsToColumnWidthDict(
        null != ie ? ie : [...defaultConfig.columnWidth]
      ),
      {
        groups: me,
        groupMap: ye,
        groupLength: be,
        fieldGroupMap: ve,
      } = getGroupsForTranspose(ee.fieldGroups),
      Te = [],
      _e = {},
      Ce = {};
    null == ae ||
      ae.forEach((e) => {
        var T;
        const { field: C } = e;
        _e[C] = e;
        const $ = ve[C];
        if ($)
          if (Ce[$]) {
            const T = ye[ve[C]],
              F = Ce[$];
            T.title || (F.title = e.title);
          } else {
            const F = ye[ve[C]],
              V = {
                ...e,
                cellType:
                  e.cellType === ColumnType.Sparkline ? e.cellType : void 0,
                field: $,
                title: null != (T = null == F ? void 0 : F.title) ? T : e.title,
                columnWidthComputeMode: ne ? "normal" : "only-body",
                fieldFormat: (e) => {
                  var T, V;
                  const Y =
                      null == (T = null == F ? void 0 : F.fields)
                        ? void 0
                        : T[e[COMPACT_GROUP_INDEX_KEY]],
                    K = _e[Y];
                  if (
                    (null == K ? void 0 : K.fieldFormat) &&
                    "function" == typeof K.fieldFormat
                  )
                    return K.fieldFormat(e);
                  const J = getFormatter(null != Y ? Y : C, ee);
                  return null != (V = null == J ? void 0 : J(e[$])) ? V : e[$];
                },
                style: (T) => {
                  var C;
                  const { table: $, col: V, row: Y } = T,
                    K = getOriginRecord($, V, Y),
                    J =
                      null == (C = null == F ? void 0 : F.fields)
                        ? void 0
                        : C[K[COMPACT_GROUP_INDEX_KEY]],
                    ee = _e[J],
                    ie = te.transpose
                      ? [
                          pe[0],
                          (null == K ? void 0 : K[COMPACT_GROUP_INDEX_KEY]) <
                          be - 1
                            ? 9 + ge[1] / 2
                            : pe[1],
                          pe[2],
                          (null == K ? void 0 : K[COMPACT_GROUP_INDEX_KEY]) > 0
                            ? 3 + ge[3] / 2
                            : pe[3],
                        ]
                      : void 0;
                  return {
                    ...lodash.exports.omit(e.style, ["bgColor", "icon"]),
                    ...lodash.exports.pick(null == ee ? void 0 : ee.style, [
                      "bgColor",
                      "color",
                      "icon",
                      "font",
                      "underline",
                      "textAlign",
                    ]),
                    borderColor: (e) => {
                      const { table: T, row: C, col: $ } = e,
                        F = getOriginRecord(T, $, C);
                      return te.transpose
                        ? [
                            de,
                            (null == F ? void 0 : F[COMPACT_GROUP_INDEX_KEY]) <
                            be - 1
                              ? null
                              : ce,
                            ue,
                            (null == F ? void 0 : F[COMPACT_GROUP_INDEX_KEY]) >
                            0
                              ? null
                              : he,
                          ]
                        : [
                            (null == F ? void 0 : F[COMPACT_GROUP_INDEX_KEY]) >
                            0
                              ? null
                              : de,
                            ce,
                            (null == F ? void 0 : F[COMPACT_GROUP_INDEX_KEY]) <
                            be - 1
                              ? null
                              : ue,
                            he,
                          ];
                    },
                    padding: ie,
                  };
                },
              };
            ne ||
              (V.width =
                ("standard" === re ? "auto" : fe[$]) || fe.default || "auto"),
              Te.push(V),
              (Ce[$] = V);
          }
        else
          Te.push({
            ...e,
            mergeCell: !0,
          });
      });
    const Ae = [];
    null == oe ||
      oe.forEach((e) => {
        for (let T = 0; T < be; T++) {
          const C = {
            [COMPACT_GROUP_INDEX_KEY]: T,
            [COMPACT_GROUP_ORIGIN_FIELD_KEY]: {},
          };
          me.forEach(($) => {
            const { groupId: F, fields: V } = $;
            V[T]
              ? ((C[COMPACT_GROUP_ORIGIN_FIELD_KEY][F] = V[T]),
                (C[F] = e[V[T]]))
              : V.some((e) => _e[e].cellType === ColumnType.Sparkline) &&
                (C[F] = []);
          }),
            Ae.push({
              ...e,
              ...C,
            });
        }
      });
    const xe = {
      ...le,
    };
    return (
      (null == le ? void 0 : le.dropDownMenuHighlight) &&
        (xe.dropDownMenuHighlight = le.dropDownMenuHighlight.filter((e) => {
          var T;
          const C = ve[e.field],
            $ = ye[C];
          return (
            !$ ||
            (0 === (null == (T = $.fields) ? void 0 : T.indexOf(e.field)) &&
              ((e.field = C), !0))
          );
        })),
      (J.columns = Te),
      (J.records = Ae),
      (J.menu = xe),
      J
    );
  },
  loopLayoutColumnsOrRows = (e, T) => {
    e &&
      e.forEach((e, C, $) => {
        const F = T(e, C, $);
        Array.isArray(e.children) &&
          !0 !== F &&
          loopLayoutColumnsOrRows(e.children, T);
      });
  },
  getColumnOrRowsGroups$2 = (e, T, C, $) => {
    const { indicators: F = [], rowTree: V, columnTree: Y } = e,
      K = getIndicatorChildrenInSourceTree("columnTree" === $ ? Y : V),
      J = (e, C) =>
        e.map((e) => {
          var $;
          if (!1 === e.isGroup)
            return {
              indicatorKey: e.field,
              title:
                null ==
                ($ =
                  null == F
                    ? void 0
                    : F.find((T) => T.indicatorKey === e.field))
                  ? void 0
                  : $.title,
              children: K,
            };
          {
            const $ = J(e.children, C + 1);
            return {
              dimensionKey: T.get(C),
              value: e.title,
              children: $.filter((e) => {
                var T;
                return (
                  ((null == (T = e.children) ? void 0 : T.length) > 0 &&
                    lodash.exports.isNil(e.indicatorKey)) ||
                  !lodash.exports.isNil(e.indicatorKey)
                );
              }),
            };
          }
        });
    return J(C, 0);
  },
  getIndicatorChildrenInSourceTree = (e) => {
    let T;
    return (
      loopLayoutColumnsOrRows(
        e,
        (e, C, $) =>
          !(T || !$.length || !$.every((e) => !!e.indicatorKey)) &&
          ((T = e.children), !0)
      ),
      T
    );
  },
  completeTree = (e, T, C, $, F) => {
    const V = getColumnOrRowsGroups$2(e, T, C, F);
    return insertMeasureTreeGroupToPivotTree(e[F], V);
  },
  insertMeasureTreeGroupToPivotTree = (e, T) => {
    let C = lodash.exports.cloneDeep(e);
    return (
      C.every((e) => !!e.indicatorKey)
        ? (C = T)
        : loopLayoutColumnsOrRows(
            C,
            (e) =>
              !(
                !Array.isArray(e.children) ||
                !e.children.every((e) => !!e.indicatorKey)
              ) && ((e.children = T), !0)
          ),
      C
    );
  },
  levelTraversalFieldGroup = (e, T) => {
    let C = 0,
      $ = [...e];
    for (; 0 !== $.length; ) {
      T($, C++);
      const e = [];
      null == $ ||
        $.forEach((T) => {
          T.isGroup && e.push(...T.children);
        }),
        ($ = e);
    }
  },
  getMeasurePosition = (e) => {
    var T;
    const C = e.cells[0],
      { foldInfo: $, row: F, column: V } = C,
      Y = null != (T = null == $ ? void 0 : $.key) ? T : "";
    if (F && -1 !== F.indexOf(Y)) return "rows";
    if (V && -1 !== V.indexOf(Y)) return "columns";
    if (lodash.exports.isNil(Y)) {
      if (
        lodash.exports.isNil(null == V ? void 0 : V.length) ||
        0 === (null == V ? void 0 : V.length)
      )
        return "columns";
      if (
        lodash.exports.isNil(null == F ? void 0 : F.length) ||
        0 === (null == F ? void 0 : F.length)
      )
        return "rows";
    }
    return "columns";
  },
  getFieldGroupLevelDimensions = (e) => {
    const T = new Map();
    return (
      levelTraversalFieldGroup(e, (e, C) => {
        const $ = e.filter((e) => e.isGroup);
        if (0 === $.length) return;
        const F = $.map((e) => e.isGroup && e.field).join("-");
        T.set(C, F);
      }),
      T
    );
  },
  getFieldPath = (e) => {
    const T = new Map(),
      C = new Map(),
      $ = (e, F) => {
        e.forEach((e) => {
          var V;
          !1 === e.isGroup && e.field && T.set(e.field, [...F]),
            !0 === e.isGroup &&
              e.children &&
              (C.set(
                null != (V = null == e ? void 0 : e.field) ? V : "",
                e.title
              ),
              F.push(String(e.field)),
              $(e.children, F),
              F.pop());
        });
      };
    return $(e, []), [T, C];
  },
  completeRecords = (e, T, C, $) => {
    const F = C,
      [V, Y] = getFieldPath(T),
      K = T.some((e) =>
        lodash.exports.isBoolean(null == e ? void 0 : e.autoExpand)
      ),
      J = Array.from(V.keys());
    return (
      F.forEach((T) => {
        const C = Object.keys(T);
        J.every((e) => !C.includes(e)) && delete T[$];
        for (let $ = 0; $ < J.length; $++) {
          const F = J[$],
            ee = V.get(F);
          if (F in T && ee) {
            ee.forEach((C, $) => {
              T[e.get($)] = Y.get(C);
            });
            break;
          }
          if (K) {
            const $ = [...ee],
              F = lodash.exports.intersection($, C);
            if (null == F ? void 0 : F.length) {
              const C = lodash.exports.findIndex(
                $,
                (e) => e === lodash.exports.last(F)
              );
              C > -1 &&
                ee.forEach(($, F) => {
                  F <= C && (T[e.get(F)] = Y.get($));
                });
            }
          }
        }
      }),
      F
    );
  },
  completeDimensions = (e, T, C, $, F = !1, V = !1) => {
    const Y = [...T];
    let K = Y.length - 1;
    for (const J of e.values()) {
      const e = F ? K : Y.findIndex((e) => e.dimensionKey === $);
      Y.splice(e, 0, {
        dimensionKey: J,
        title: V ? "" : intl.i18n``,
        drillDown: !1,
        drillUp: !1,
        showSort: !1,
        width: "auto",
      }),
        K++;
    }
    return Y;
  },
  pivotTableCompact = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C;
    if (!$.compact || !C.fieldGroups || !C.fieldGroups.length) return e;
    const F = "rows" === getMeasurePosition(C) ? "vertical" : "horizontal";
    return $.compactDirection && $.compactDirection !== F
      ? {
          ...e,
          ...transposeCompact(e, T),
        }
      : {
          ...e,
          ...commonCompact(e, T),
        };
  },
  commonCompact = (e, T) => {
    var C, $, F, V, Y, K, J, ee;
    const te = {
        ...e,
      },
      { vizData: ie } = T,
      { displayConf: ne } = ie,
      { customColWidth: re, rowHeaderWidth: ae } = ne,
      oe = ie.cells[0],
      { foldInfo: se } = oe,
      le = null == se ? void 0 : se.key,
      {
        rows: de = [],
        indicators: ce = [],
        records: ue,
        theme: he,
        columns: pe = [],
      } = te,
      ge = getMeasurePosition(ie),
      fe = "rows" === ge ? "rowTree" : "columnTree",
      me = {},
      ye = {};
    null == (C = ie.fieldGroups) ||
      C.forEach((e, T) => {
        e.isGroup && e.children.length > 0
          ? (e.field &&
              (me[e.field] = {
                type: "group",
                title: e.title,
              }),
            e.children.forEach(({ field: C }) => {
              var $;
              C &&
                (me[C] = {
                  type: "related",
                  parent:
                    null != ($ = e.field) ? $ : `${COMPACT_FIELD_PREFIX}${T}`,
                  originalParent: e.field,
                });
            }))
          : e.field &&
            (me[e.field] = {
              type: "single",
            });
      }),
      null == ce ||
        ce.forEach((e) => {
          const T = "string" == typeof e ? e : e.indicatorKey;
          me[T] ||
            (me[T] = {
              type: "single",
            });
        });
    const be = [],
      ve = {},
      Te = {},
      _e = [];
    null == ce ||
      ce.forEach((e) => {
        var T, C, $;
        if ("string" == typeof e) return;
        const F = e.indicatorKey,
          V = {
            indicatorKey: e.indicatorKey,
            value: e.title,
          };
        if ("single" === me[F].type) be.push(V);
        else if ("group" === me[F].type) {
          const e = `${F}`,
            T = {
              dimensionKey: COMPACT_GROUP_DIM_KEY,
              originIndicator: V,
              value: e,
              children: [V],
            };
          be.push(T), (ve[F] = T), (Te[e] = me[F].title);
        } else {
          if (
            null == (T = me[F].parent)
              ? void 0
              : T.startsWith(COMPACT_FIELD_PREFIX)
          ) {
            const e = Number(
                null == (C = me[F].parent)
                  ? void 0
                  : C.substring(COMPACT_FIELD_PREFIX.length)
              ),
              T = null == ($ = ie.fieldGroups) ? void 0 : $[e];
            if (null == T ? void 0 : T.isGroup) {
              const e = `${F}`,
                C = {
                  dimensionKey: COMPACT_GROUP_DIM_KEY,
                  originIndicator: V,
                  value: e,
                  children: [],
                };
              be.push(C),
                (ve[F] = C),
                (Te[e] = null == T ? void 0 : T.title),
                null == T ||
                  T.children.forEach(({ field: e }) => {
                    e && (me[e].parent = F);
                  });
            }
          }
          me[F].originalParent || (Te[me[F].parent] = e.title), _e.push(e);
        }
      }),
      _e.forEach((e) => {
        const T = e.indicatorKey,
          C = ve[me[T].parent],
          $ = {
            indicatorKey: T,
            value: e.title,
          };
        Array.isArray(null == C ? void 0 : C.children)
          ? C.children.push($)
          : be.push($);
      });
    const Ce = getIndicatorChildrenInSourceTree(te[fe]);
    if (
      (be.forEach((e) => {
        var T;
        if (
          (Array.isArray(e.children) &&
            (null == (T = e.children) ||
              T.forEach((T, C) => {
                var $;
                T.indicatorKey &&
                  (ye[T.indicatorKey] = {
                    value: e.value,
                    index: C,
                    length: null == ($ = e.children) ? void 0 : $.length,
                  });
              })),
          Ce)
        ) {
          const T = lodash.exports.cloneDeep(Ce);
          loopLayoutColumnsOrRows(
            T,
            (T) => !T.children && ((T.children = e.children), !0)
          ),
            (e.children = T);
        }
      }),
      "rows" === ge)
    ) {
      const e = [...de],
        T = e.findIndex((e) =>
          "string" != typeof e ? e.dimensionKey === le : e
        ),
        C = e[T],
        F = {
          dimensionKey: COMPACT_GROUP_DIM_KEY,
          title: null != ($ = C.title) ? $ : "",
          dropDownMenu: C.dropDownMenu,
          drillDown: !1,
          drillUp: !1,
          showSort: !1,
          width: "auto",
          headerFormat: (e) => {
            var T;
            return null != (T = Te[e]) ? T : e;
          },
        };
      e.splice(T, 0, F), (te.rows = e);
    } else {
      const e = [...pe],
        T = e.findIndex((e) =>
          "string" != typeof e ? e.dimensionKey === le : e
        ),
        C = e[T],
        $ = {
          dimensionKey: COMPACT_GROUP_DIM_KEY,
          title: null != (F = C.title) ? F : "",
          dropDownMenu: C.dropDownMenu,
          drillDown: !1,
          drillUp: !1,
          showSort: !1,
          headerFormat: (e) => {
            var T;
            return null != (T = Te[e]) ? T : e;
          },
        };
      e.splice(T, 0, $), (te.columns = e);
    }
    return (
      (te.defaultHeaderColWidth = null != ae ? ae : "auto"),
      (te.indicators =
        null == (V = te.indicators)
          ? void 0
          : V.map(
              (e, T) => (
                "string" != typeof e && (e.width = null != re ? re : "auto"), e
              )
            )),
      (te[fe] = insertMeasureTreeGroupToPivotTree(te[fe], be)),
      (te.records =
        null == ue
          ? void 0
          : ue.map((e) => {
              const T = {
                ...e,
              };
              return (
                Object.keys(ye).forEach((e) => {
                  const C = ye[e];
                  e in T && C && (T[COMPACT_GROUP_DIM_KEY] = C.value);
                }),
                T
              );
            })),
      (te.indicators =
        null == (Y = te.indicators)
          ? void 0
          : Y.map((e) => {
              var T, C, $, F, V, Y, K, J, ee;
              if ("string" == typeof e) return e;
              const te = {
                  ...e,
                },
                ie =
                  null == (T = null == he ? void 0 : he.bodyStyle)
                    ? void 0
                    : T.borderColor,
                ne =
                  null !=
                  ($ =
                    null == (C = null == he ? void 0 : he.headerStyle)
                      ? void 0
                      : C.padding)
                    ? $
                    : [],
                re = ye[te.indicatorKey];
              if (!re) return te;
              if ((te.style || (te.style = {}), "rows" === ge)) {
                let e = null == ie ? void 0 : ie[0],
                  T =
                    null != (F = null == ie ? void 0 : ie[2])
                      ? F
                      : null == ie
                      ? void 0
                      : ie[0];
                re.index > 0 && (e = null),
                  re.index < re.length - 1 && (T = null),
                  (te.style.borderColor = [
                    e,
                    null == ie ? void 0 : ie[1],
                    T,
                    null != (V = null == ie ? void 0 : ie[3])
                      ? V
                      : null == ie
                      ? void 0
                      : ie[1],
                  ]);
              }
              if ("columns" === ge) {
                let e =
                    null != (Y = null == ie ? void 0 : ie[3])
                      ? Y
                      : null == ie
                      ? void 0
                      : ie[1],
                  T = null == ie ? void 0 : ie[1],
                  C =
                    null != (K = null == ne ? void 0 : ne[3])
                      ? K
                      : null == ne
                      ? void 0
                      : ne[1],
                  $ = null == ne ? void 0 : ne[1];
                re.index > 0 && ((e = null), (C = 4)),
                  re.index < re.length - 1 && ((T = null), ($ = 4)),
                  (te.style.borderColor = [
                    null == ie ? void 0 : ie[0],
                    T,
                    null != (J = null == ie ? void 0 : ie[2])
                      ? J
                      : null == ie
                      ? void 0
                      : ie[0],
                    e,
                  ]),
                  (te.style.padding = [
                    null == ne ? void 0 : ne[0],
                    $,
                    null != (ee = null == ne ? void 0 : ne[2])
                      ? ee
                      : null == ne
                      ? void 0
                      : ne[0],
                    C,
                  ]);
              }
              return te;
            })),
      (te.menu = {
        ...(null != (K = null == te ? void 0 : te.menu) ? K : {}),
        dropDownMenuHighlight:
          null ==
          (ee = null == (J = te.menu) ? void 0 : J.dropDownMenuHighlight)
            ? void 0
            : ee.map((e) => {
                const T = {
                  ...e,
                };
                return (
                  Array.isArray(T.field) &&
                    T.field.forEach((e) => {
                      if (e.indicatorKey && ve[e.indicatorKey]) {
                        const T = ve[e.indicatorKey];
                        delete e.indicatorKey,
                          (e.value = T.value),
                          (e.dimensionKey = T.dimensionKey);
                      }
                    }),
                  T
                );
              }),
      }),
      (te.hideIndicatorName = !0),
      te
    );
  },
  transposeCompact = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae, oe;
    const se = {
        ...e,
      },
      { vizData: le } = T,
      { cells: de } = le,
      { displayConf: ce } = le,
      { display: ue, customColWidth: he, rowHeaderWidth: pe } = ce,
      { theme: ge, indicators: fe } = se,
      me = de[0],
      { foldInfo: ye } = me,
      be = null == ye ? void 0 : ye.key,
      ve = getMeasurePosition(le),
      Te = "rows" === ve ? "rowTree" : "columnTree",
      _e = "rows" === ve ? "columnTree" : "rowTree",
      Ce =
        null == (C = null == ge ? void 0 : ge.bodyStyle)
          ? void 0
          : C.borderColor,
      Ae =
        null !=
        (F =
          null == ($ = null == ge ? void 0 : ge.headerStyle)
            ? void 0
            : $.padding)
          ? F
          : [],
      xe = {};
    null == fe ||
      fe.forEach((e) => {
        "string" != typeof e && (xe[e.indicatorKey] = e);
      });
    const {
        groups: Se,
        groupMap: Re,
        groupLength: Me,
        fieldGroupMap: Pe,
      } = getGroupsForTranspose(le.fieldGroups, xe),
      Be = [],
      Ee = {},
      Le = getIndicatorChildrenInSourceTree(se[Te]);
    null == fe ||
      fe.forEach((e) => {
        const T = e.indicatorKey,
          C = Pe[T],
          $ = {
            dimensionKey: be,
            indicatorKey: T,
            value: e.value,
          };
        if (C) {
          if (!Ee[C]) {
            const e = Re[C],
              T = {
                dimensionKey: COMPACT_GROUP_DIM_KEY,
                originIndicator: $,
                value: null == e ? void 0 : e.groupId,
                children: Le,
              };
            Be.push(T), (Ee[C] = T);
          }
        } else
          Be.push({
            dimensionKey: COMPACT_GROUP_DIM_KEY,
            originIndicator: $,
            value: e.value,
            children: Le,
          });
      }),
      (se[Te] = insertMeasureTreeGroupToPivotTree(e[Te], Be));
    const we = [];
    for (let $e = 0; $e < Me; $e++)
      we.push({
        indicatorKey: `${COMPACT_GROUP_INDICATOR_PREFIX}-${$e}`,
        value: "",
      });
    const De = lodash.exports.cloneDeep(e[_e]);
    let Ie;
    if (
      ((null == (V = me["rows" === ve ? "column" : "row"]) ? void 0 : V.length)
        ? ((Ie = null != (Y = lodash.exports.cloneDeep(De)) ? Y : []),
          loopLayoutColumnsOrRows(
            null != Ie ? Ie : [],
            (e) => !e.children && ((e.children = we), !0)
          ))
        : (Ie = we),
      (se[_e] = Ie),
      "rows" === ve)
    ) {
      const e = [...(null != (K = se.rows) ? K : [])],
        T = e.findIndex((e) =>
          "string" != typeof e ? e.dimensionKey === be : e
        ),
        C = e[T],
        $ = {
          dimensionKey: COMPACT_GROUP_DIM_KEY,
          title: null != (J = C.title) ? J : "",
          drillDown: !1,
          drillUp: !1,
          showSort: !1,
          headerType: C.headerType,
          dropDownMenu: C.dropDownMenu,
          width: "auto",
          headerFormat: (e) => {
            var T, C;
            return null != (C = null == (T = Re[e]) ? void 0 : T.title) ? C : e;
          },
        };
      e.splice(T, 0, $), (se.rows = e);
    } else {
      const e = [...(null != (ee = se.columns) ? ee : [])],
        T = e.findIndex((e) =>
          "string" != typeof e ? e.dimensionKey === be : e
        ),
        C = e[T],
        $ = {
          dimensionKey: COMPACT_GROUP_DIM_KEY,
          title: null != (te = C.title) ? te : "",
          drillDown: !1,
          drillUp: !1,
          showSort: !1,
          headerType: C.headerType,
          dropDownMenu: C.dropDownMenu,
          headerFormat: (e) => {
            var T, C;
            return null != (C = null == (T = Re[e]) ? void 0 : T.title) ? C : e;
          },
        };
      e.splice(T, 0, $), (se.columns = e);
    }
    se.indicators = Array.from({
      length: Me,
    }).map((e, T) => ({
      indicatorKey: `${COMPACT_GROUP_INDICATOR_PREFIX}-${T}`,
      title: "",
      width: "custom" === ue && null != he ? he : "auto",
      format: (e, C, $, F) => {
        var V;
        const Y = getOriginRecord(F, C, $);
        if (!Y) return "";
        const K = xe[Y[COMPACT_GROUP_ORIGIN_FIELD_KEY]];
        return "function" == typeof (null == K ? void 0 : K.format)
          ? null == K
            ? void 0
            : K.format(e, C, $, F)
          : null != (V = Y[`${COMPACT_GROUP_INDICATOR_PREFIX}-${T}`])
          ? V
          : "";
      },
      icon: (e) => {
        const { col: T, row: C, table: $ } = e,
          F = getOriginRecord($, T, C);
        if (!F) return "";
        const V = xe[null == F ? void 0 : F[COMPACT_GROUP_ORIGIN_FIELD_KEY]];
        return "function" == typeof (null == V ? void 0 : V.icon)
          ? V.icon(e)
          : void 0;
      },
      style: (e) => {
        var C, $, F, V, Y, K, J, ee;
        const { table: te, col: ie, row: ne } = e,
          re = getOriginRecord(te, ie, ne);
        let ae = {};
        if (re) {
          const T =
            null == (C = xe[re[COMPACT_GROUP_ORIGIN_FIELD_KEY]])
              ? void 0
              : C.style;
          ae = null != ($ = "function" == typeof T ? T(e) : T) ? $ : {};
        }
        if ("columns" === ve) {
          let e = null == Ce ? void 0 : Ce[0],
            C =
              null != (F = null == Ce ? void 0 : Ce[2])
                ? F
                : null == Ce
                ? void 0
                : Ce[0];
          T > 0 && (e = null),
            T < Me - 1 && (C = null),
            (ae.borderColor = [
              e,
              null == Ce ? void 0 : Ce[1],
              C,
              null != (V = null == Ce ? void 0 : Ce[3])
                ? V
                : null == Ce
                ? void 0
                : Ce[1],
            ]);
        } else {
          let e =
              null != (Y = null == Ce ? void 0 : Ce[3])
                ? Y
                : null == Ce
                ? void 0
                : Ce[1],
            C = null == Ce ? void 0 : Ce[1],
            $ =
              null != (K = null == Ae ? void 0 : Ae[3])
                ? K
                : null == Ae
                ? void 0
                : Ae[1],
            F = null == Ae ? void 0 : Ae[1];
          T > 0 && ((e = null), ($ = 4)),
            T < Me - 1 && ((C = null), (F = 4)),
            (ae.borderColor = [
              null == Ce ? void 0 : Ce[0],
              C,
              null != (J = null == Ce ? void 0 : Ce[2])
                ? J
                : null == Ce
                ? void 0
                : Ce[0],
              e,
            ]),
            (ae.padding = [
              null == Ae ? void 0 : Ae[0],
              F,
              null != (ee = null == Ae ? void 0 : Ae[2])
                ? ee
                : null == Ae
                ? void 0
                : Ae[0],
              $,
            ]);
        }
        return ae;
      },
      headerStyle: {
        borderColor: [null, null, null, null],
      },
    }));
    const Oe = [];
    return (
      null == (ie = se.records) ||
        ie.forEach((e) => {
          for (let T = 0; T < Me; T++) {
            const C = {
              [COMPACT_GROUP_INDEX_KEY]: T,
            };
            Se.forEach(($) => {
              const { fields: F } = $;
              F[T] &&
                F[T] in e &&
                ((C[be] = `${COMPACT_GROUP_INDICATOR_PREFIX}-${T}`),
                (C[COMPACT_GROUP_DIM_KEY] = $.groupId),
                (C[COMPACT_GROUP_ORIGIN_FIELD_KEY] = F[T]),
                (C[`${COMPACT_GROUP_INDICATOR_PREFIX}-${T}`] = e[F[T]]),
                Oe.push({
                  ...e,
                  ...C,
                }));
            });
          }
        }),
      (se.records = Oe),
      (se.indicators = se.indicators.map((e) => {
        var T;
        if ("string" == typeof e) return e;
        const C = {
          ...e,
        };
        return (
          (null == (T = me["columnTree" === _e ? "column" : "row"])
            ? void 0
            : T.length) && (C.width = null != he ? he : "auto"),
          C
        );
      })),
      (se.defaultHeaderRowHeight = null != pe ? pe : "auto"),
      (se.menu = {
        ...(null != (ne = se.menu) ? ne : {}),
        dropDownMenuHighlight:
          null ==
          (ae =
            null == (re = null == se ? void 0 : se.menu)
              ? void 0
              : re.dropDownMenuHighlight)
            ? void 0
            : ae.map((e) => {
                const T = {
                  ...e,
                };
                return (
                  Array.isArray(T.field) &&
                    T.field.forEach((e) => {
                      var T;
                      if (e.indicatorKey) {
                        const C = Pe[e.indicatorKey],
                          $ = Re[C];
                        if (!$) return;
                        return (
                          0 ===
                            (null == (T = $.fields)
                              ? void 0
                              : T.indexOf(e.indicatorKey)) &&
                            (delete e.indicatorKey,
                            (e.dimensionKey = COMPACT_GROUP_DIM_KEY),
                            (e.value = $.groupId)),
                          !1
                        );
                      }
                    }),
                  T
                );
              }),
      }),
      (se.hideIndicatorName = !!(null ==
      (oe = me["columns" === ve ? "row" : "column"])
        ? void 0
        : oe.length)),
      (se.indicatorsAsCol = "rows" === ve),
      se
    );
  },
  compact = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? pivotTableCompact(e, T)
      : listTableCompact(e, T),
  getColumnMinMax$1 = ({
    field: e,
    records: T = [],
    valueType: C,
    excludeTotal: $,
    statistic: F = {},
  }) => {
    if ("number" === C && T.length > 0) {
      const { min: C, max: V } = F;
      if (!lodash.exports.isNil(C) && !lodash.exports.isNil(V)) return [C, V];
      let Y = null != V ? V : Number.MIN_SAFE_INTEGER,
        K = null != C ? C : Number.MAX_SAFE_INTEGER;
      for (let F = 0; F < T.length; F++)
        ($ && isCombined(T[F])) ||
          (isNum$1(T[F][e]) &&
            (lodash.exports.isNil(C) && (K = Math.min(parseFloat(T[F][e]), K)),
            lodash.exports.isNil(V) && (Y = Math.max(parseFloat(T[F][e]), Y))));
      return [K, Y];
    }
    return [void 0, void 0];
  },
  isEmptyLine = (e) => {
    const { col: T, row: C, table: $ } = e;
    return getOriginRecord($, T, C)[EMPTY_LINE_TAG];
  },
  isExcludeTotalAndProcessingTotal$1 = (e, T) => {
    const { excludeTotal: C } = e,
      { col: $, row: F, table: V } = T,
      Y = getOriginRecord(V, $, F);
    return !(!C || !isCombined(Y));
  },
  calcRuleValue$1 = (e, T, C, $) => {
    var F;
    return "computed" === e.operandType && e.computedValue
      ? null != (F = null == C ? void 0 : C[e.computedValue])
        ? F
        : e.value
      : "cmpField" === e.operandType && e.cmpFieldId && T
      ? T[e.cmpFieldId]
      : e.operandType && "fixed" !== e.operandType
      ? "number" == typeof $ && "timeProgress" === e.operandType
        ? $
        : void 0
      : e.value;
  };
function isNum$1(e) {
  return "NaN" !== parseFloat(e).toString();
}
function toNum$1(e) {
  return parseFloat(e);
}
function RuleMatch$1(e, T, C) {
  switch (e) {
    case "all":
      return !0;
    case "none":
      return !1;
    case "empty":
      return !isNum$1(T);
    case "notEmpty":
      return isNum$1(T);
    case "<":
      return isNum$1(T) && toNum$1(T) < toNum$1(C);
    case "<=":
      return isNum$1(T) && toNum$1(T) <= toNum$1(C);
    case "!=":
      return isNum$1(T) && toNum$1(T) !== toNum$1(C);
    case "=":
      return isNum$1(T) && toNum$1(T) === toNum$1(C);
    case ">":
      return isNum$1(T) && toNum$1(T) > toNum$1(C);
    case ">=":
      return isNum$1(T) && toNum$1(T) >= toNum$1(C);
    case "%":
      return isNum$1(T) && toNum$1(T) % toNum$1(C) == 0;
    case "include":
      return null == T
        ? void 0
        : T.toString().includes(null == C ? void 0 : C.toString());
    case "exclude":
      return !(null == T
        ? void 0
        : T.toString().includes(null == C ? void 0 : C.toString()));
    case "startsWith":
      return null == T
        ? void 0
        : T.toString().startsWith(null == C ? void 0 : C.toString());
    case "endsWith":
      return null == T
        ? void 0
        : T.toString().endsWith(null == C ? void 0 : C.toString());
    case "strEqual":
      return (
        (null == T ? void 0 : T.toString()) ===
        (null == C ? void 0 : C.toString())
      );
    case "strNotEqual":
      return (
        (null == T ? void 0 : T.toString()) !==
        (null == C ? void 0 : C.toString())
      );
  }
  return !1;
}
function isMatchRule$1(e, T, C, $, F) {
  for (const V of e) {
    const e = calcRuleValue$1(V, C, $, F);
    if (!RuleMatch$1(V.ruleType, T, e)) return !1;
  }
  return !0;
}
function isMatchRuleGroup$1(e, T, C, $) {
  var F, V;
  if (!e.rules.length && !e.groups.length) return !0;
  const Y = "and" === e.operator;
  let K = Y;
  for (const J of e.rules) {
    const e = null != (F = J.pillId) ? F : $,
      ee = e ? C[e] : {},
      te = isMatchRule$1(
        [J],
        null != (V = T[`${e}`]) ? V : J.defaultPillValue,
        T,
        ee
      );
    if (Y) {
      if (((K = K && te), !K)) return K;
    } else if (((K = K || te), K)) return K;
  }
  for (const J of e.groups) {
    const e = isMatchRuleGroup$1(J, T, C, $);
    if (Y) {
      if (((K = K && e), !K)) return K;
    } else if (((K = K || e), K)) return K;
  }
  return K;
}
function instanceOfTableVisualBarData$1(e) {
  return (
    e && "positiveColor" in e && "negativeColor" in e && "barAxisColor" in e
  );
}
function instanceOfTableVisualColorLevelsData$1(e) {
  return (
    e &&
    "colors" in e &&
    "levels" in e &&
    Array.isArray(e.colors) &&
    Array.isArray(e.levels) &&
    e.colors.length === e.levels.length + 2
  );
}
function instanceOfTableVisualRule$1(e) {
  return (
    e &&
    "ruleType" in e &&
    ("value" in e || "computedValue" in e || "cmpFieldId" in e)
  );
}
function instanceOfTableVisualRules$1(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualRule$1(e))
  );
}
function instanceOfTableVisualTagData$1(e) {
  return (
    !!e &&
    "rules" in e &&
    "color" in e &&
    "tagIcon" in e &&
    "tagIconPosition" in e &&
    instanceOfTableVisualRules$1(e.rules)
  );
}
function instanceOfTableVisualTagDataArray$1(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualTagData$1(e))
  );
}
function instanceOfTableVisualSingleColorData$1(e) {
  var T, C;
  return (
    !!e &&
    "ruleGroup" in e &&
    "color" in e &&
    "bgColor" in e &&
    instanceOfTableVisualRules$1(
      null == (C = null == (T = e.ruleGroup.groups) ? void 0 : T[0])
        ? void 0
        : C.rules
    )
  );
}
function instanceOfTableVisualSingleColorDataArray$1(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualSingleColorData$1(e))
  );
}
function valuePercent$1(e, T, C) {
  return T === e ? (C >= T ? 1 : 0) : (C - e) / (T - e);
}
function linearInterpolations$1(e, T, C) {
  const $ = [];
  for (let F = 0; F < e.length; F++)
    $[F] = linearInterpolation$1(e[F], T[F], C);
  return $;
}
function linearInterpolation$1(e, T, C) {
  return e + (T - e) * C;
}
function getPropertyDefine$1(e) {
  return "function" == typeof e ? e : () => e;
}
function updatePropertyDefine$1(e, T) {
  return T && "function" == typeof e
    ? (...C) => {
        const $ = e(...C);
        return void 0 !== $ ? $ : getPropertyDefine$1(T)(...C);
      }
    : getPropertyDefine$1(void 0 === e ? T : e);
}
const LABEL_COLOR_WHITE$1 = "#ffffff",
  LABEL_COLOR_BLACK$1 = "#141414",
  LABEL_L_THRESHOLD$1 = 0.75,
  getDataValue$1 = (e, T) => {
    const { dataValue: C, col: $, row: F, table: V } = e;
    if (!T) return C;
    const Y = getOriginRecord(V, $, F);
    return null == Y ? void 0 : Y[T];
  };
var colorLevel$1 = (e, T, C, $, F, V) => {
  var Y, K, J, ee, te;
  const { data: ie, excludeTotal: ne } = T,
    re =
      null != (K = null != (Y = ie.pillId) ? Y : e.indicatorKey) ? K : e.field,
    { fieldMap: ae } = V,
    oe = isNumberType(ae[re].type) ? "number" : "string",
    [se, le] = getColumnMinMax$1({
      field: re,
      records: $,
      valueType: oe,
      excludeTotal: ne,
      statistic:
        null == (J = null == V ? void 0 : V.statistics) ? void 0 : J[re],
    }),
    de = isNum$1(ie.min) ? ie.min : se,
    ce = isNum$1(ie.max) ? ie.max : le,
    ue = ce >= de ? ce : de,
    he = de < ce ? de : ce,
    pe = [he, ...ie.levels, ue],
    ge = (he + ue) / 2,
    fe = pe[pe.length - 1],
    me = pe[0],
    ye = (e) => {
      if (isExcludeTotalAndProcessingTotal$1(T, e) || isEmptyLine(e)) return;
      const C = getDataValue$1(e, ie.pillId);
      return colorLevelFunc$1(ie, C, ge, me, fe, pe);
    };
  e.style = {
    ...e.style,
    bgColor: updatePropertyDefine$1(
      ye,
      null == (ee = e.style) ? void 0 : ee.bgColor
    ),
    color: updatePropertyDefine$1(
      ie.autoLabelColor
        ? (e) => {
            const T = ye(e);
            if (T) return getAutoLabelColor$1(T);
          }
        : (e) => {
            if (!isExcludeTotalAndProcessingTotal$1(T, e) && !isEmptyLine(e))
              return ie.labelColor;
          },
      null == (te = e.style) ? void 0 : te.color
    ),
  };
};
const colorLevelFunc$1 = (e, T, C, $, F, V) => {
    let Y = $,
      K = F;
    const J = Number(T);
    if (
      (lodash.exports.isString(T) && lodash.exports.isEmpty(T)) ||
      lodash.exports.isNil(T) ||
      !isNum$1(J)
    ) {
      if ("color" === e.emptyType) return e.emptyColor;
      if ("hidden" === e.emptyType) return TRANSPARENT_COLOR$1;
    }
    if (J < Y) return e.colors[0];
    if (J > K) return e.colors[e.colors.length - 1];
    for (let ee = 1; ee < V.length; ee++) {
      const T = V[ee];
      if (((K = "median" === T ? C : T), J <= K)) {
        const T = valuePercent$1(Y, K, J);
        return `rgba(${linearInterpolations$1(
          chroma(e.colors[ee - 1]).rgba(),
          chroma(e.colors[ee]).rgba(),
          T
        )
          .map(Math.floor)
          .join(",")})`;
      }
      Y = K;
    }
  },
  getAutoLabelColor$1 = (e) => {
    const [, , T] = chroma(e).hsl();
    return T >= LABEL_L_THRESHOLD$1 ? LABEL_COLOR_BLACK$1 : LABEL_COLOR_WHITE$1;
  };
var TableVisualType$1 = ((e) => (
    (e.TAG = "tag"),
    (e.COLOR_LEVELS = "colorLevels"),
    (e.BAR = "bar"),
    (e.SINGLE_COLOR = "singleColor"),
    e
  ))(TableVisualType$1 || {}),
  bar = (e, T, C, $, F, V) => {
    var Y;
    const { data: K, excludeTotal: J } = T;
    let ee, te;
    if ((ee = e.indicatorKey)) te = "number";
    else {
      const T = C.find((e) => e.field === K.pillId);
      if (T) (te = getType(T, V)), (ee = T.field);
      else if (V.fieldMap[String(K.pillId)]) {
        const e = V.fieldMap[String(K.pillId)];
        (ee = K.pillId), (te = e.role === Role.MEASURE ? "number" : "string");
      } else (te = getType(e, V)), (ee = e.field);
    }
    const [ie, ne] = getColumnMinMax$1({
      field: ee,
      records: $,
      valueType: te,
      excludeTotal: J,
      statistic:
        null == (Y = null == V ? void 0 : V.statistics) ? void 0 : Y[ee],
    });
    (e.cellType = "progressbar"),
      (e.min = ie),
      (e.max = ne),
      (e.dependField = C.find((e) => e.field === K.pillId) ? ee : K.pillId),
      (e.barType = !1 !== K.barAxis ? "negative" : "negative_no_axis"),
      (e.style = {
        ...e.style,
        showBar: (e) =>
          !isExcludeTotalAndProcessingTotal$1(T, e) && !isEmptyLine(e),
        barPositiveColor: `rgba(${chroma(K.positiveColor)
          .rgb()
          .join(",")}, 0.5)`,
        barNegativeColor: `rgba(${chroma(K.negativeColor)
          .rgb()
          .join(",")}, 0.5)`,
        barBgColor: "transparent",
        barAxisColor: K.barAxisColor,
        barHeight: "100%",
        barPadding:
          !1 !== K.barAxis
            ? ["25%", 10]
            : "right" === K.orientation
            ? [0, 0, 0, 10]
            : [0, 10, 0, 0],
        showBarMark: !0,
        barMarkWidth: 2,
        barMarkPosition: "bottom" === K.barMarkPosition ? "bottom" : "right",
        barMarkPositiveColor: K.positiveColor,
        barMarkNegativeColor: K.negativeColor,
        barRightToLeft: "right" === K.orientation,
      });
  };
const getType = (e, T) => {
    const C = isRawTable(T),
      { fieldMap: $ } = T,
      { field: F } = e,
      V = $[F];
    return V
      ? C
        ? V.role === Role.MEASURE
          ? "number"
          : "string"
        : isNumberType(V.type)
        ? "number"
        : "string"
      : "string";
  },
  getFlatHeaders = (e) => {
    const T = [],
      C = (e) => {
        e.forEach((e) => {
          e.columns ? C(e.columns) : T.push(e);
        });
      };
    return C(e), T;
  };
var singleColor = (e, T, C) => {
  const { data: $ } = T,
    F = (e) => {
      if (isExcludeTotalAndProcessingTotal$1(T, e)) return null;
      let F = null;
      const { col: V, row: Y, table: K } = e,
        J = getOriginRecord(K, V, Y),
        ee = Object.fromEntries(getFlatHeaders(C).map((e) => [e.field, e]));
      for (let T = 0; T < $.length; T++)
        if (isMatchRuleGroup$1($[T].ruleGroup, J, ee)) {
          F = $[T];
          break;
        }
      return F;
    },
    { bgColor: V = "#000", color: Y = "#000" } = e.style;
  e.style = {
    ...e.style,
    color: (T) => {
      const C = F(T);
      return C
        ? C.color
        : ((T) => ("function" == typeof Y ? Y.bind(e.style)(T) : Y))(T);
    },
    bgColor: (T) => {
      const C = F(T);
      return C
        ? C.bgColor
        : ((T) => ("function" == typeof V ? V.bind(e.style)(T) : V))(T);
    },
  };
};
const NewIconUpArrow = (e) =>
    `<svg t="1644533554308" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="41733" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M241.365333 911.914667a83.925333 83.925333 0 1 1-122.88-114.346667l510.72-549.034667H304.64a69.973333 69.973333 0 0 1-69.973333-69.973333V155.306667C234.666667 116.650667 265.941333 85.333333 304.64 85.333333h553.685333c38.613333 0 69.973333 31.317333 69.973334 69.973334l-0.042667 553.685333a69.973333 69.973333 0 0 1-69.973333 69.930667h-23.296a69.973333 69.973333 0 0 1-69.973334-69.973334V349.098667L241.408 911.914667z" p-id="41734"></path>\n  </svg>`,
  NewIconDownArrow = (e) =>
    `<svg t="1644533681770" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="41863" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M265.856 114.389333a77.397333 77.397333 0 1 0-120.874667 96.725334l461.653334 577.024h-286.293334c-35.669333 0-64.554667 28.885333-64.554666 64.512v21.504c0 35.626667 28.885333 64.512 64.512 64.512h510.677333c35.626667 0 64.512-28.885333 64.512-64.512V363.52c0-35.626667-28.885333-64.512-64.512-64.512h-21.504c-35.626667 0-64.512 28.885333-64.512 64.512v349.781333L265.813333 114.346667z" p-id="41864"></path>\n  </svg>`,
  NewIconGentleArrow = (e) =>
    `<svg t="1644571091374" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="40847" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M586.144 782.912a58.24 58.24 0 0 0 0 82.304l13.696 13.76a58.24 58.24 0 0 0 82.304 0l325.824-325.76a58.24 58.24 0 0 0 0-82.368l-325.76-325.76a58.24 58.24 0 0 0-82.368 0l-13.696 13.696a58.24 58.24 0 0 0 0 82.304l200.384 200.32H69.92a69.824 69.824 0 1 0 0 139.712H787.936l-201.792 201.792z" p-id="40848"></path>\n  </svg>`,
  IconExclamation = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 1024 1024">\n    <path d="M512 789.333333a64 64 0 1 1 0 128 64 64 0 0 1 0-128z m-6.058667-682.666666a64 64 0 0 1 64.725334 63.274666l5.333333 469.333334a64 64 0 0 1-128 1.450666l-5.333333-469.333333A64 64 0 0 1 505.941333 106.666667z" />\n  </svg>`,
  NewIconUpRound = (e) =>
    `<svg t="1644534085318" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="42385" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M512 768a256 256 0 1 0 0-512 256 256 0 0 0 0 512z" p-id="42386"></path><path d="M512 746.666667a234.666667 234.666667 0 1 0 0-469.333334 234.666667 234.666667 0 0 0 0 469.333334z m256-234.666667a256 256 0 1 1-512 0 256 256 0 0 1 512 0z" p-id="42387"></path>\n  </svg>`,
  IconUpStrong = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 1024 1024">\n    <path d="M512 441.770667l280.458667 275.861333a64 64 0 0 0 89.749333-91.264l-325.333333-320a64 64 0 0 0-89.749334 0l-325.333333 320a64 64 0 0 0 89.749333 91.264L512 441.770667z" />\n  </svg>`,
  IconDownStrong = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 1024 1024">\n    <path d="M512 582.229333l280.458667-275.861333a64 64 0 0 1 89.749333 91.264l-325.333333 320a64 64 0 0 1-89.749334 0l-325.333333-320a64 64 0 0 1 89.749333-91.264L512 582.229333z" />\n  </svg>`,
  IconBar = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 1024 1024">\n    <path d="M170.666667 576a64 64 0 1 1 0-128h682.666666a64 64 0 1 1 0 128H170.666667z" />\n  </svg>`,
  NewIconUpTriangle = (e) =>
    `<svg t="1644533796105" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="41993" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M556.288 275.456l282.368 312.576c33.28 36.906667 6.229333 94.634667-44.373333 94.634667H229.632c-11.306667 0-22.4-3.157333-31.914667-9.088a57.6 57.6 0 0 1-21.76-24.362667 55.466667 55.466667 0 0 1 9.344-61.184l282.368-312.533333c5.546667-6.101333 12.373333-11.050667 19.968-14.378667a60.458667 60.458667 0 0 1 68.693334 14.336z" p-id="41994"></path><path d="M540.458667 289.706667l282.368 312.618666c19.968 22.186667 4.992 59.008-28.501334 59.008H229.546667a39.04 39.04 0 0 1-20.608-5.845333 36.266667 36.266667 0 0 1-13.738667-15.36 34.090667 34.090667 0 0 1 5.845333-37.76l282.368-312.576a37.546667 37.546667 0 0 1 12.757334-9.173333 39.168 39.168 0 0 1 44.245333 9.130666z m298.197333 298.325333l-282.368-312.576a60.501333 60.501333 0 0 0-88.661333 0.042667l-282.368 312.533333a55.466667 55.466667 0 0 0-9.344 61.141333c4.693333 10.026667 12.245333 18.474667 21.76 24.405334 9.514667 5.973333 20.608 9.088 31.914666 9.088h564.736c50.56 0 77.653333-57.728 44.330667-94.634667z" p-id="41995"></path>\n  </svg>`,
  NewIconDownTriangle = (e) =>
    `<svg t="1644533848549" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="42124" width="${e.width}" height="${e.height}" fill="${e.color}">\n    <path d="M467.712 748.544l-282.368-312.576C152.064 399.061333 179.114667 341.333333 229.717333 341.333333h564.693334c11.306667 0 22.4 3.157333 31.914666 9.088 9.514667 5.930667 17.066667 14.378667 21.76 24.362667a55.381333 55.381333 0 0 1-9.344 61.184l-282.368 312.533333a58.88 58.88 0 0 1-19.968 14.378667 60.501333 60.501333 0 0 1-68.693333-14.336z" p-id="42125"></path><path d="M483.541333 734.293333L201.173333 421.632c-19.968-22.186667-4.992-59.008 28.501334-59.008H794.453333c7.338667 0 14.506667 2.048 20.608 5.845333a36.266667 36.266667 0 0 1 13.738667 15.36 34.133333 34.133333 0 0 1-5.845333 37.76l-282.368 312.576a37.589333 37.589333 0 0 1-12.757334 9.173334 39.125333 39.125333 0 0 1-44.245333-9.130667z m-298.197333-298.325333l282.368 312.576c5.546667 6.144 12.373333 11.008 19.968 14.336a60.501333 60.501333 0 0 0 68.693333-14.378667l282.368-312.533333a55.381333 55.381333 0 0 0 9.344-61.141333 57.6 57.6 0 0 0-21.76-24.405334A60.288 60.288 0 0 0 794.410667 341.333333H229.674667c-50.56 0-77.653333 57.728-44.330667 94.634667z" p-id="42126"></path>\n  </svg>`,
  TailedarrowUp = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 16 16">\n    <path d="M8.65274 1.73179C8.77451 1.60524 8.97705 1.60524 9.09881 1.73179L13.7325 6.54729C13.9218 6.74393 13.7824 7.07143 13.5095 7.07143H4.24206C3.96916 7.07143 3.8298 6.74393 4.01902 6.54729L8.65274 1.73179Z M7.0188 6.4523a0.62 0.62 0 0 1 0.62 -0.62h2.4762a0.612 0.612 0 0 1 0.612 0.612v7.428574a0.612 0.612 0 0 1 -0.612 0.612h-2.476194a0.612 0.612 0 0 1 -0.612 -0.612z" p-id="42126"></path>\n  </svg>`,
  TailedarrowDown = (e) =>
    `<svg xmlns="http://www.w3.org/2000/svg" width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 16 16">\n    <path d="M8.94076 14.2682C8.819 14.3948 8.61646 14.3948 8.49469 14.2682L3.86097 9.45271C3.67175 9.25607 3.81111 8.92857 4.08401 8.92857H13.3514C13.6243 8.92857 13.7637 9.25607 13.5745 9.45271L8.94076 14.2682Z M6.85507 2.147a0.62 0.62 0 0 1 0.62 -0.62h2.4762a0.62 0.62 0 0 1 0.62 0.62v7.42857a0.62 0.62 0 0 1 -0.62 0.62h-2.4762a0.62 0.62 0 0 1 -0.62 -0.62z" p-id="42126"></path>\n  </svg>`,
  IconSortAsc = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 15 15" fill="${e.color}" xmlns="http://www.w3.org/2000/svg">\n    <path d="M4.03332 1.43335L4.45758 1.00909C4.22327 0.774771 3.84337 0.774771 3.60906 1.00909L4.03332 1.43335ZM1.00906 3.60909C0.77474 3.8434 0.77474 4.2233 1.00906 4.45761C1.24337 4.69193 1.62327 4.69193 1.85758 4.45761L1.00906 3.60909ZM6.20905 4.45761C6.44337 4.69193 6.82327 4.69193 7.05758 4.45761C7.2919 4.2233 7.2919 3.8434 7.05758 3.60909L6.20905 4.45761ZM3.43332 14C3.43332 14.3314 3.70195 14.6 4.03332 14.6C4.36469 14.6 4.63332 14.3314 4.63332 14H3.43332ZM8.79999 3.43335C8.46862 3.43335 8.19999 3.70198 8.19999 4.03335C8.19999 4.36472 8.46862 4.63335 8.79999 4.63335V3.43335ZM14 4.63335C14.3314 4.63335 14.6 4.36472 14.6 4.03335C14.6 3.70198 14.3314 3.43335 14 3.43335V4.63335ZM8.79999 6.90002C8.46862 6.90002 8.19999 7.16865 8.19999 7.50002C8.19999 7.83139 8.46862 8.10002 8.79999 8.10002V6.90002ZM12.2667 8.10002C12.598 8.10002 12.8667 7.83139 12.8667 7.50002C12.8667 7.16865 12.598 6.90002 12.2667 6.90002V8.10002ZM8.79999 10.3667C8.46862 10.3667 8.19999 10.6353 8.19999 10.9667C8.19999 11.2981 8.46862 11.5667 8.79999 11.5667V10.3667ZM10.5333 11.5667C10.8647 11.5667 11.1333 11.2981 11.1333 10.9667C11.1333 10.6353 10.8647 10.3667 10.5333 10.3667V11.5667ZM3.60906 1.00909L1.00906 3.60909L1.85758 4.45761L4.45758 1.85761L3.60906 1.00909ZM3.60906 1.85761L6.20905 4.45761L7.05758 3.60909L4.45758 1.00909L3.60906 1.85761ZM3.43332 1.43335V14H4.63332V1.43335H3.43332ZM8.79999 4.63335H14V3.43335H8.79999V4.63335ZM8.79999 8.10002H12.2667V6.90002H8.79999V8.10002ZM8.79999 11.5667H10.5333V10.3667H8.79999V11.5667Z" fill="${e.color}"/>\n  </svg>`,
  IconSortDesc = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 15 15" fill="${e.color}" xmlns="http://www.w3.org/2000/svg">\n    <path d="M4.03333 13.5667L3.60907 13.9909C3.84339 14.2252 4.22328 14.2252 4.4576 13.9909L4.03333 13.5667ZM7.0576 11.3909C7.29191 11.1566 7.29191 10.7767 7.0576 10.5424C6.82328 10.3081 6.44339 10.3081 6.20907 10.5424L7.0576 11.3909ZM1.8576 10.5424C1.62328 10.3081 1.24338 10.3081 1.00907 10.5424C0.774756 10.7767 0.774756 11.1566 1.00907 11.3909L1.8576 10.5424ZM4.63333 1C4.63333 0.668629 4.36471 0.4 4.03333 0.4C3.70196 0.4 3.43333 0.668629 3.43333 1H4.63333ZM8.8 3.43333C8.46863 3.43333 8.2 3.70196 8.2 4.03333C8.2 4.3647 8.46863 4.63333 8.8 4.63333V3.43333ZM14 4.63333C14.3314 4.63333 14.6 4.3647 14.6 4.03333C14.6 3.70196 14.3314 3.43333 14 3.43333V4.63333ZM8.8 6.9C8.46863 6.9 8.2 7.16863 8.2 7.5C8.2 7.83137 8.46863 8.1 8.8 8.1V6.9ZM12.2667 8.1C12.598 8.1 12.8667 7.83137 12.8667 7.5C12.8667 7.16863 12.598 6.9 12.2667 6.9V8.1ZM8.8 10.3667C8.46863 10.3667 8.2 10.6353 8.2 10.9667C8.2 11.298 8.46863 11.5667 8.8 11.5667V10.3667ZM10.5333 11.5667C10.8647 11.5667 11.1333 11.298 11.1333 10.9667C11.1333 10.6353 10.8647 10.3667 10.5333 10.3667V11.5667ZM4.4576 13.9909L7.0576 11.3909L6.20907 10.5424L3.60907 13.1424L4.4576 13.9909ZM4.4576 13.1424L1.8576 10.5424L1.00907 11.3909L3.60907 13.9909L4.4576 13.1424ZM3.43333 1V13.5667H4.63333V1H3.43333ZM8.8 4.63333H14V3.43333H8.8V4.63333ZM8.8 8.1H12.2667V6.9H8.8V8.1ZM8.8 11.5667H10.5333V10.3667H8.8V11.5667Z" fill="${e.color}"/>\n  </svg>`,
  IconFrozenCol = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <path d="M3 2.5C2.17157 2.5 1.5 3.17157 1.5 4V12C1.5 12.8284 2.17157 13.5 3 13.5H13C13.8284 13.5 14.5 12.8284 14.5 12V4C14.5 3.17157 13.8284 2.5 13 2.5H3Z" stroke="${e.color}" stroke-linecap="round" stroke-linejoin="round"/>\n    <path d="M7 3V13" stroke="${e.color}" stroke-linecap="round" stroke-linejoin="round"/>\n    <path d="M2 6L7 3" stroke="${e.color}" stroke-width="0.7" stroke-linecap="square"/>\n    <path d="M2 9L7 6" stroke="${e.color}" stroke-width="0.7" stroke-linecap="square"/>\n    <path d="M2 12L7 9" stroke="${e.color}" stroke-width="0.7" stroke-linecap="square"/>\n    <path d="M5 13L7 12" stroke="${e.color}" stroke-width="0.7" stroke-linecap="square"/>\n  </svg>`,
  IconHeaderSortAsc = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 20 20" fill="${e.color}" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 4L9.6084 3.54541C9.83347 3.35153 10.1665 3.35153 10.3916 3.54541L10 4ZM13.3916 6.12975C13.6427 6.34603 13.6709 6.72488 13.4546 6.97594C13.2383 7.227 12.8595 7.2552 12.6084 7.03892L13.3916 6.12975ZM7.3916 7.03892C7.14054 7.2552 6.76169 7.227 6.54541 6.97594C6.32914 6.72488 6.35734 6.34603 6.6084 6.12975L7.3916 7.03892ZM10.6 15C10.6 15.3314 10.3314 15.6 10 15.6C9.66863 15.6 9.4 15.3314 9.4 15H10.6ZM10.3916 3.54541L13.3916 6.12975L12.6084 7.03892L9.6084 4.45459L10.3916 3.54541ZM10.3916 4.45459L7.3916 7.03892L6.6084 6.12975L9.6084 3.54541L10.3916 4.45459ZM9.4 15V4H10.6V15H9.4Z" fill="${e.color}"/>\n  </svg>`,
  IconHeaderSortDesc = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 20 20" fill="${e.color}" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 16L9.6084 16.4546C9.83347 16.6485 10.1665 16.6485 10.3916 16.4546L10 16ZM13.3916 13.8702C13.6427 13.654 13.6709 13.2751 13.4546 13.0241C13.2383 12.773 12.8595 12.7448 12.6084 12.9611L13.3916 13.8702ZM7.3916 12.9611C7.14054 12.7448 6.76169 12.773 6.54541 13.0241C6.32914 13.2751 6.35734 13.654 6.6084 13.8702L7.3916 12.9611ZM10.6 5C10.6 4.66863 10.3314 4.4 10 4.4C9.66863 4.4 9.4 4.66863 9.4 5H10.6ZM10.3916 16.4546L13.3916 13.8702L12.6084 12.9611L9.6084 15.5454L10.3916 16.4546ZM10.3916 15.5454L7.3916 12.9611L6.6084 13.8702L9.6084 16.4546L10.3916 15.5454ZM9.4 5V16H10.6V5H9.4Z" fill="${e.color}"/>\n  </svg>`,
  IconAdd = (e) =>
    `<svg width="${e.width}" height="${e.height}" fill="${e.color}"  xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12"><path d="M9.5,5.5h-3v-3C6.5,2.2,6.3,2,6,2S5.5,2.2,5.5,2.5v3h-3C2.2,5.5,2,5.7,2,6s0.2,0.5,0.5,0.5h3v3\tC5.5,9.8,5.7,10,6,10s0.5-0.2,0.5-0.5v-3h3C9.8,6.5,10,6.3,10,6S9.8,5.5,9.5,5.5z" fill="${e.color}"/></svg>`,
  iconMinus = (e) =>
    `<svg  width="${e.width}" height="${e.height}" fill="${e.color}" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M819.2 556.8H224c-25.6 0-44.8-19.2-44.8-44.8s19.2-44.8 44.8-44.8h595.2c25.6 0 44.8 19.2 44.8 44.8s-19.2 44.8-44.8 44.8z" fill="${e.color}" /></svg>`,
  IconEmpty = (e) =>
    `<svg width="${e.width}" height="${e.height}" viewBox="0 0 20 20" fill="${e.color}" xmlns="http://www.w3.org/2000/svg">\n    <path d="M Z" />\n  </svg>`,
  iconSvgMap = {
    "icon-arrow-up": NewIconUpArrow,
    "icon-arrow-down": NewIconDownArrow,
    "icon-right-strong": NewIconGentleArrow,
    "icon-exclamation": IconExclamation,
    "icon-circle": NewIconUpRound,
    "icon-up-strong": IconUpStrong,
    "icon-down-strong": IconDownStrong,
    "icon-bar": IconBar,
    "icon-triangle": NewIconUpTriangle,
    "icon-sanjiao": NewIconDownTriangle,
    "icon-tailedarrow-up": TailedarrowUp,
    "icon-tailedarrow-down": TailedarrowDown,
    "icon-add": IconAdd,
    "icon-minus": iconMinus,
    empty: IconEmpty,
  },
  getIconSvg = (e, T) => {
    var C;
    return null == (C = iconSvgMap[e]) ? void 0 : C.call(iconSvgMap, T);
  };
var tag = (e, T, C, $, F, V, Y, K) => {
  var J, ee;
  const { displayConf: te } = V,
    { data: ie, excludeTotal: ne } = T,
    re = null != (J = e.indicatorKey) ? J : e.field,
    ae = (e) => {
      if (isExcludeTotalAndProcessingTotal$1(T, e) || isEmptyLine(e))
        return null;
      let $ = null;
      const { dataValue: F, col: V, row: J, table: ee } = e,
        te = getOriginRecord(ee, V, J),
        ne = C
          ? Object.fromEntries(getFlatHeaders(C).map((e) => [e.field, e]))
          : void 0;
      for (let T = 0; T < ie.length; T++) {
        const { pillId: e } = ie[T];
        if (
          isMatchRule$1(
            ie[T].rules.map((T) => ({
              ...T,
              pillId: e,
            })),
            e && !Y && lodash.exports.has(te, e)
              ? null == te
                ? void 0
                : te[e]
              : F,
            te,
            ne && e ? (null == ne ? void 0 : ne[e]) : {},
            K
          )
        ) {
          $ = ie[T];
          break;
        }
      }
      return $;
    };
  (e.style = {
    ...e.style,
    color: updatePropertyDefine$1(
      (e) => {
        const T = ae(e);
        return T ? T.textColor || T.color : te.bodyFontColor;
      },
      null == (ee = e.style) ? void 0 : ee.color
    ),
  }),
    (e.icon = updatePropertyDefine$1((e) => {
      const T = ae(e);
      if (T && "none" !== T.tagIconPosition)
        return {
          name: `${T.tagIcon}|${T.color}`,
          svg: getIconSvg(T.tagIcon, {
            width: "12px",
            height: "12px",
            color: T.color,
          }),
          positionType:
            "left" === T.tagIconPosition
              ? F.TYPES.IconPosition.left
              : F.TYPES.IconPosition.right,
          width: 12,
          height: 12,
        };
    }, e.icon)),
    (e.fieldFormat = updatePropertyDefine$1((e) => {
      const T = null == e ? void 0 : e[re];
      if (ne && isCombined(e)) return;
      let C = null;
      for (let $ = 0; $ < ie.length; $++) {
        const F = ie[$].pillId ? (null == e ? void 0 : e[ie[$].pillId]) : T;
        if (isMatchRule$1(ie[$].rules, F)) {
          C = ie[$];
          break;
        }
      }
      return "onlyTag" === (null == C ? void 0 : C.tagIconPosition)
        ? ""
        : void 0;
    }, e.fieldFormat)),
    (e.format = updatePropertyDefine$1((e, T, C, $) => {
      const F = getOriginRecord($, T, C);
      if (ne && isCombined(F)) return;
      let V = null;
      for (let Y = 0; Y < ie.length; Y++) {
        const T = ie[Y].pillId ? (null == F ? void 0 : F[ie[Y].pillId]) : e;
        if (isMatchRule$1(ie[Y].rules, T)) {
          V = ie[Y];
          break;
        }
      }
      return "onlyTag" === (null == V ? void 0 : V.tagIconPosition)
        ? ""
        : void 0;
    }, e.format));
};
const processorMap = {
    [TableVisualType$1.BAR]: bar,
    [TableVisualType$1.COLOR_LEVELS]: colorLevel$1,
    [TableVisualType$1.SINGLE_COLOR]: singleColor,
    [TableVisualType$1.TAG]: tag,
  },
  checkPillIdInFieldMap = (e, T) => {
    const { type: C, data: $ } = e;
    if (C === TableVisualType$1.SINGLE_COLOR) {
      const e = (C) =>
        !C.rules.some((e) => e.pillId && !T[e.pillId]) &&
        C.groups.every((T) => e(T));
      return $.every((T) => e(T.ruleGroup));
    }
    if (C === TableVisualType$1.TAG)
      return $.every((e) => !e.pillId || T[e.pillId]);
    if (C === TableVisualType$1.COLOR_LEVELS) {
      const { pillId: e } = null != $ ? $ : {};
      return !e || T[e];
    }
    if (C === TableVisualType$1.BAR) {
      const { pillId: e } = null != $ ? $ : {};
      return !e || T[e];
    }
    return !0;
  },
  listTableConditionalFormat = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $, VTable: F } = T,
      { columns: V, records: Y } = C;
    if (!V) return C;
    const K = {},
      J = (e, T, C) => {
        K[e] || (K[e] = []), checkPillIdInFieldMap(T, C) && K[e].push(T);
      };
    return (
      V.forEach((e) => {
        var T;
        const { field: C } = e,
          F = $.fieldMap[C];
        if (
          F &&
          (null == (T = F.contentFormat) ? void 0 : T.conditionalFormat)
        ) {
          const { conditionalFormat: e } = F.contentFormat,
            { type: T, data: V, excludeTotal: Y } = e;
          T === TableVisualType$1.SINGLE_COLOR &&
          instanceOfTableVisualSingleColorDataArray$1(V)
            ? V.forEach((e) => {
                "row" !== e.effectScope &&
                  J(
                    C,
                    {
                      type: TableVisualType$1.SINGLE_COLOR,
                      data: [e],
                      excludeTotal: Y,
                    },
                    $.fieldMap
                  );
              })
            : J(C, e, $.fieldMap);
        }
      }),
      V.forEach((e) => {
        var T;
        const { field: C } = e,
          F = $.fieldMap[C];
        if (
          F &&
          (null == (T = F.contentFormat) ? void 0 : T.conditionalFormat)
        ) {
          const { conditionalFormat: e } = F.contentFormat,
            { type: T, data: C, excludeTotal: Y } = e;
          T === TableVisualType$1.SINGLE_COLOR &&
            instanceOfTableVisualSingleColorDataArray$1(C) &&
            C.forEach((e) => {
              "row" === e.effectScope &&
                V.forEach((T) => {
                  const { field: C } = T;
                  J(
                    C,
                    {
                      type: TableVisualType$1.SINGLE_COLOR,
                      data: [e],
                      excludeTotal: Y,
                    },
                    $.fieldMap
                  );
                });
            });
        }
      }),
      (C.columns = V.map((e) => {
        var T;
        const C = {
            ...e,
          },
          { field: J } = e;
        return (
          [...(null != (T = K[J]) ? T : [])].reverse().forEach((e) => {
            var T, K;
            const { type: J } = e;
            null == (K = (T = processorMap)[J]) || K.call(T, C, e, V, Y, F, $);
          }),
          C
        );
      })),
      C
    );
  },
  getPeriodCondition$1 = (e, T) => {
    var C;
    const { periodCompare: $ } = e.displayConf;
    if ($ && $.length) {
      const e =
        null == (C = $.find((e) => String(e.uniqueId) === String(T)))
          ? void 0
          : C.conditionalFormat;
      return PeriodConditionList.find((T) => T.key === e);
    }
    return null;
  },
  generatePeriodConditionColor$1 = (e, T) => {
    const C = getConditionIndexByValue$1(T);
    return e.colors[C];
  },
  generatePeriodConditionIcon$1 = (e, T) => {
    const C = getConditionIndexByValue$1(T),
      $ = e.members[C],
      F = generatePeriodConditionColor$1(e, T);
    return {
      name: `${$}${F}`,
      interactive: !1,
      svg: getIconSvg($, {
        width: "12px",
        height: "12px",
        color: F,
      }),
      marginRight: 2,
      positionType: "contentLeft",
      width: 12,
      height: 12,
    };
  },
  getConditionIndexByValue$1 = (e) => (e ? (e > 0 ? 0 : e < 0 ? 2 : 0) : 1),
  getColumnOriginUniqueIdFromCellRecord = (e) =>
    null == e ? void 0 : e.OKR_TABLE_COLUMN_UNIQUE_ID,
  getColumnFromRecord = (e, T) => {
    var C, $;
    if (!T) return;
    const { tableColumns: F } = e.displayConf,
      V = T.OKR_TABLE_COLUMN_KEY;
    return null ==
      ($ = null == (C = null == F ? void 0 : F.values) ? void 0 : C.find)
      ? void 0
      : $.call(C, (e) => String(e.id) === String(V));
  },
  OKRTableConditionalFormat = (e, T) => {
    const { vizData: C, VTable: $ } = T,
      { indicators: F, records: V } = e,
      Y = getFields(C, Location.MEASURE, isRenderField),
      { fieldMap: K } = C,
      J = {};
    null == Y ||
      Y.forEach((e) => {
        var T;
        const C = K[e];
        if (
          C &&
          (null == (T = C.contentFormat) ? void 0 : T.conditionalFormat)
        ) {
          const { conditionalFormat: T } = C.contentFormat;
          ((e, T) => {
            J[e] || (J[e] = []), J[e].push(T);
          })(e, T);
        }
      });
    const ee =
      null == F ? void 0 : F.map((e) => setTableVisual$1(e, V, C, $, J));
    return {
      ...e,
      indicators: ee,
    };
  },
  setTableVisual$1 = (e, T, C, $, F) => {
    const V = {
        ...e,
      },
      { displayConf: Y } = C;
    return (
      (V.style = (F) => {
        var V, K, J;
        const { table: ee, row: te, col: ie } = F,
          ne = getOriginRecord(ee, ie, te),
          re = getColumnOriginUniqueIdFromCellRecord(ne),
          ae = getColumnFromRecord(C, ne),
          oe = getConditionalFormat(ae, C, re, ne);
        if (
          ae &&
          ["measureValue", "goalProgress"].includes(ae.type) &&
          isValidVisual$1(oe)
        ) {
          const F = lodash.exports.cloneDeep(e),
            { pastDays: J, allDays: ee } = calcDiffDays(Y, ae.dateUnit),
            te = J / ee;
          return (
            null == (K = (V = processorMap)[oe.type]) ||
              K.call(V, F, oe, [], T, $, C, !0, te),
            {
              ...F.style,
            }
          );
        }
        return {
          ...(null != (J = e.style) ? J : {}),
        };
      }),
      (V.icon = (F) => {
        var V, K, J;
        const { table: ee, row: te, col: ie } = F,
          ne = getOriginRecord(ee, ie, te),
          re = getColumnOriginUniqueIdFromCellRecord(ne),
          ae = getColumnFromRecord(C, ne),
          oe = getConditionalFormat(ae, C, re, ne);
        if (
          ae &&
          ["measureValue", "goalProgress"].includes(ae.type) &&
          isValidVisual$1(oe)
        ) {
          const J = lodash.exports.cloneDeep(e),
            { pastDays: ee, allDays: te } = calcDiffDays(Y, ae.dateUnit),
            ie = ee / te;
          return (
            null == (K = (V = processorMap)[oe.type]) ||
              K.call(V, J, oe, [], T, $, C, !0, ie),
            J.icon(F)
          );
        }
        return null == (J = null == e ? void 0 : e.icon)
          ? void 0
          : J.call(e, F);
      }),
      (V.format = updatePropertyDefine$1((V, Y, K, J) => {
        var ee;
        const te = getOriginRecord(J, Y, K),
          ie = getColumnOriginUniqueIdFromCellRecord(te),
          ne = getColumnFromRecord(C, te),
          re = F[ie];
        if (
          ie &&
          re &&
          re.length &&
          "measureValue" === (null == ne ? void 0 : ne.type)
        ) {
          const F = lodash.exports.cloneDeep(e);
          if (
            (re.forEach((e) => {
              var V, Y;
              isValidVisual$1(e) &&
                (null == (Y = (V = processorMap)[e.type]) ||
                  Y.call(V, F, e, [], T, $, C, !0));
            }),
            F)
          )
            return null == (ee = F.format) ? void 0 : ee.call(F, V, Y, K, J);
        }
      }, e.format)),
      V
    );
  },
  getConditionalFormat = (e, T, C, $) => {
    var F;
    if ("measureValue" === (null == e ? void 0 : e.type)) {
      const { fieldMap: e } = T,
        $ = e[C];
      if ($ && (null == (F = $.contentFormat) ? void 0 : F.conditionalFormat)) {
        const { conditionalFormat: e } = $.contentFormat;
        return e;
      }
    } else if ("goalProgress" === (null == e ? void 0 : e.type)) {
      const { okrInfo: e = {} } = T.other,
        { cells: C } = T,
        { foldInfo: F } = C[0],
        V = null == F ? void 0 : F.id,
        Y = e.conditionalFormatMap,
        K = $[V];
      return null == Y ? void 0 : Y[K];
    }
  },
  isValidVisual$1 = (e) => {
    if (!e) return !1;
    const { type: T, data: C } = e;
    return !!(
      (T === TableVisualType$1.BAR && instanceOfTableVisualBarData$1(C)) ||
      (T === TableVisualType$1.COLOR_LEVELS &&
        instanceOfTableVisualColorLevelsData$1(C)) ||
      (T === TableVisualType$1.TAG && instanceOfTableVisualTagDataArray$1(C))
    );
  },
  getDeadlineTime = (e) => {
    var T, C;
    return "relative" === e.deadlineConfig.defaultType
      ? hooks()
          .subtract(
            (null == (T = null == e ? void 0 : e.deadlineConfig)
              ? void 0
              : T.relativeValue) || 1,
            "day"
          )
          .format("YYYY-MM-DD")
      : null == (C = null == e ? void 0 : e.deadlineConfig)
      ? void 0
      : C.absoluteTime;
  },
  calcDiffDays = (e, T) => {
    const C = hooks(getDeadlineTime(e), "YYYY-MM-DD"),
      $ = C.clone().startOf(T),
      F = C.clone().endOf(T).diff($, "days") + 1,
      V = C.diff($, "days") + 1;
    return {
      pastDays: V,
      allDays: F,
      percent: F <= 0 ? "0%" : `${((V / F) * 100).toFixed(1)}%`,
    };
  },
  pivotTableConditionalFormat = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V, VTable: Y } = T;
    if (!F.indicators) return F;
    const K = {};
    return (
      null == (C = F.indicators) ||
        C.forEach((e) => {
          var T;
          if ("string" == typeof e) return;
          const C = V.fieldMap[e.indicatorKey];
          if (
            C &&
            (null == (T = C.contentFormat) ? void 0 : T.conditionalFormat)
          ) {
            const { conditionalFormat: T } = C.contentFormat;
            ((e, T) => {
              K[e] || (K[e] = []), K[e].push(T);
            })(e.indicatorKey, T);
          }
        }),
      (F.indicators =
        null == ($ = F.indicators)
          ? void 0
          : $.map((e) => {
              var T;
              if ("string" == typeof e) return e;
              const C = {
                ...e,
              };
              return (
                (null != (T = K[C.indicatorKey]) ? T : []).forEach((e) => {
                  var T, $;
                  const { type: K, data: J } = e;
                  ((K === TableVisualType$1.BAR &&
                    instanceOfTableVisualBarData$1(J)) ||
                    (K === TableVisualType$1.COLOR_LEVELS &&
                      instanceOfTableVisualColorLevelsData$1(J)) ||
                    (K === TableVisualType$1.TAG &&
                      instanceOfTableVisualTagDataArray$1(J))) &&
                    (null == ($ = (T = processorMap)[K]) ||
                      $.call(T, C, e, F.indicators, F.records, Y, V));
                }),
                C
              );
            })),
      F
    );
  },
  TREND_TABLE_MEASURE_FOLD_ID = "__BYTECHARTS_TRENDTABLE_DATE_COLUMN",
  TREND_CELL_PADDING = 4,
  trendTableConditionalFormat = (e, T) => {
    const C = {
        ...e,
      },
      { indicators: $ } = C;
    return (
      (C.indicators =
        null == $
          ? void 0
          : $.map((e) =>
              "string" == typeof e
                ? e
                : e.title === TREND_TABLE_MEASURE_FOLD_ID
                ? setTableVisual(e, C.records, T)
                : e
            )),
      C
    );
  },
  setTableVisual = (e, T, C) => {
    var $;
    const { vizData: F, VTable: V } = C,
      { fieldMap: Y, cells: K } = F,
      J = getFields(F, Location.MEASURE, isRenderField),
      { id: ee = "" } = null != ($ = K[0].foldInfo) ? $ : {},
      te = {};
    if (
      (null == J ||
        J.forEach((e) => {
          var T;
          const C = Y[e];
          if (
            C &&
            (null == (T = C.contentFormat) ? void 0 : T.conditionalFormat)
          ) {
            const { conditionalFormat: T } = C.contentFormat;
            ((e, T) => {
              te[e] || (te[e] = []), te[e].push(T);
            })(e, T);
          }
        }),
      !Object.keys(te).length)
    )
      return e;
    const ie = {
      ...e,
    };
    return (
      (ie.style = (C) => {
        const { table: $, col: Y, row: K } = C,
          J = getOriginRecord($, Y, K),
          ie = null == J ? void 0 : J[ee],
          ne = te[ie],
          re = lodash.exports.cloneDeep(e);
        return ie && (null == ne ? void 0 : ne.length)
          ? (ne.forEach((e) => {
              var C, $;
              const { type: Y } = e;
              isValidVisual(e) &&
                (null == ($ = (C = processorMap)[Y]) ||
                  $.call(C, re, e, [], T, V, F, !0));
            }),
            {
              ...re.style,
            })
          : {
              ...e.style,
            };
      }),
      (ie.icon = ($) => {
        var F, V;
        const { table: Y, col: K, row: J } = $,
          ie = getOriginRecord(Y, K, J),
          ne = null == ie ? void 0 : ie[ee],
          re = te[ne],
          ae = lodash.exports.cloneDeep(e),
          { vizData: oe, VTable: se } = C;
        return (
          ne &&
            (null == re ? void 0 : re.length) &&
            re.forEach((e) => {
              var C, $;
              const { type: F } = e;
              isValidVisual(e) &&
                (null == ($ = (C = processorMap)[F]) ||
                  $.call(C, ae, e, [], T, se, oe, !0),
                (ae.indicatorKey = TREND_TABLE_MEASURE_FOLD_ID));
            }),
          ae
            ? null == (F = ae.icon)
              ? void 0
              : F.call(ae, $)
            : null == (V = null == e ? void 0 : e.icon)
            ? void 0
            : V.call(e, $)
        );
      }),
      (ie.format = ($, F, V, Y) => {
        var K, J;
        const ie = getOriginRecord(Y, F, V),
          ne = null == ie ? void 0 : ie[ee],
          re = te[ne],
          ae = lodash.exports.cloneDeep(e),
          { vizData: oe, VTable: se } = C;
        return (
          ne &&
            (null == re ? void 0 : re.length) &&
            re.forEach((e) => {
              var C, $;
              const { type: F } = e;
              isValidVisual(e) &&
                (null == ($ = (C = processorMap)[F]) ||
                  $.call(C, ae, e, [], T, se, oe, !0),
                (ae.indicatorKey = TREND_TABLE_MEASURE_FOLD_ID));
            }),
          ae
            ? null == (K = ae.format)
              ? void 0
              : K.call(ae, $, F, V, Y)
            : null == (J = null == e ? void 0 : e.format)
            ? void 0
            : J.call(e, $, F, V, Y)
        );
      }),
      ie
    );
  },
  isValidVisual = (e) => {
    const { type: T, data: C } = e;
    return !!(
      (T === TableVisualType$1.BAR && instanceOfTableVisualBarData$1(C)) ||
      (T === TableVisualType$1.COLOR_LEVELS &&
        instanceOfTableVisualColorLevelsData$1(C)) ||
      (T === TableVisualType$1.TAG && instanceOfTableVisualTagDataArray$1(C))
    );
  },
  conditionalFormat$1 = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? isOKRTable(T.vizData)
        ? OKRTableConditionalFormat(e, T)
        : isTrendTable(T.vizData)
        ? trendTableConditionalFormat(e, T)
        : pivotTableConditionalFormat(e, T)
      : listTableConditionalFormat(e, T),
  MENU_SORT_ASC = "sort_asc",
  MENU_SORT_DESC = "sort_desc",
  MENU_FROZEN_COL = "frozen_col",
  MENU_DIMMET_INFO = "dimmet_info",
  MENU_NUM_FORMAT = "num_format",
  MENU_VISUAL_STYLE = "visual_style",
  MENU_SORT_CANCEL = "sort_cancel";
var ConditionalFormatColor = ((e) => (
  (e.DEFAULT_RED = "#E33232"),
  (e.DEFAULT_GREEN = "#058D52"),
  (e.DEFAULT_YELLOW = "#D29B19"),
  (e.DEFAULT_GRAY = "#959DA5"),
  (e.DEFAULT_TEXT_COLOR = "#9EAFC6"),
  e
))(ConditionalFormatColor || {});
const headerMenuItemKey = {
    MENU_SORT_ASC: MENU_SORT_ASC,
    MENU_SORT_DESC: MENU_SORT_DESC,
    MENU_FROZEN_COL: MENU_FROZEN_COL,
    MENU_DIMMET_INFO: MENU_DIMMET_INFO,
    MENU_NUM_FORMAT: MENU_NUM_FORMAT,
    MENU_VISUAL_STYLE: MENU_VISUAL_STYLE,
    MENU_SORT_CANCEL: MENU_SORT_CANCEL,
  },
  PeriodConditionList = [
    {
      key: "group1",
      members: ["icon-add", "icon-bar", "icon-minus"],
      colors: [
        ConditionalFormatColor.DEFAULT_GREEN,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_RED,
      ],
    },
    {
      key: "group2",
      members: ["icon-triangle", "icon-bar", "icon-sanjiao"],
      colors: [
        ConditionalFormatColor.DEFAULT_GREEN,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_RED,
      ],
    },
    {
      key: "group3",
      members: ["icon-up-strong", "icon-bar", "icon-down-strong"],
      colors: [
        ConditionalFormatColor.DEFAULT_GREEN,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_RED,
      ],
    },
    {
      key: "group4",
      members: ["icon-tailedarrow-up", "icon-bar", "icon-tailedarrow-down"],
      colors: [
        ConditionalFormatColor.DEFAULT_GREEN,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_RED,
      ],
    },
    {
      key: "group5",
      members: ["icon-add", "icon-bar", "icon-minus"],
      colors: [
        ConditionalFormatColor.DEFAULT_RED,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_GREEN,
      ],
    },
    {
      key: "group6",
      members: ["icon-triangle", "icon-bar", "icon-sanjiao"],
      colors: [
        ConditionalFormatColor.DEFAULT_RED,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_GREEN,
      ],
    },
    {
      key: "group7",
      members: ["icon-up-strong", "icon-bar", "icon-down-strong"],
      colors: [
        ConditionalFormatColor.DEFAULT_RED,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_GREEN,
      ],
    },
    {
      key: "group8",
      members: ["icon-tailedarrow-up", "icon-bar", "icon-tailedarrow-down"],
      colors: [
        ConditionalFormatColor.DEFAULT_RED,
        ConditionalFormatColor.DEFAULT_GRAY,
        ConditionalFormatColor.DEFAULT_GREEN,
      ],
    },
  ],
  cornerMark = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? pivotTableCornerMark(e, T)
      : listTableCornerMark(e, T),
  listTableCornerMark = (e, T) => {
    const C = {
        ...e,
      },
      { markedTableCells: $ } = null != T ? T : {};
    if (!(null == $ ? void 0 : $.length)) return C;
    if (!C.columns) return C;
    const F = (e) => {
      var T, C;
      (e.headerStyle = {
        ...(null != (T = e.headerStyle) ? T : {}),
        marked: ({ col: e, row: T }) =>
          $.some((C) => C.col === e && C.row === T),
      }),
        (e.style = {
          ...(null != (C = e.style) ? C : {}),
          marked: ({ col: e, row: T }) =>
            $.some((C) => C.col === e && C.row === T),
        }),
        e.columns && e.columns.forEach(F);
    };
    return (
      (C.columns = C.columns.map((e) => {
        const T = {
          ...e,
        };
        return F(T), T;
      })),
      C
    );
  },
  pivotTableCornerMark = (e, T) => {
    var C, $, F, V, Y, K;
    const J = {
        ...e,
      },
      { markedTableCells: ee } = null != T ? T : {};
    if (!(null == ee ? void 0 : ee.length)) return J;
    const te = (e) => {
      var T;
      const C = {
        ...e,
      };
      return (
        (C.headerStyle = {
          ...(null != (T = C.headerStyle) ? T : {}),
          marked: (e) => {
            const { col: T, row: C } = e;
            return ee.some((e) => e.col === T && e.row === C);
          },
        }),
        C
      );
    };
    return (
      (J.rows = null == (C = J.rows) ? void 0 : C.map(te)),
      (J.columns = null == ($ = J.columns) ? void 0 : $.map(te)),
      (J.indicators =
        null == (F = J.indicators)
          ? void 0
          : F.map((e) => {
              var T, C;
              const $ = {
                ...e,
              };
              return (
                ($.headerStyle = {
                  ...(null != (T = $.headerStyle) ? T : {}),
                  marked: (e) => {
                    const { col: T, row: C } = e;
                    return ee.some((e) => e.col === T && e.row === C);
                  },
                }),
                ($.style = {
                  ...(null != (C = $.style) ? C : {}),
                  marked: (e) => {
                    const { col: T, row: C } = e;
                    return ee.some((e) => e.col === T && e.row === C);
                  },
                }),
                $
              );
            })),
      (J.corner = {
        ...(null != (V = null == J ? void 0 : J.corner) ? V : {}),
        headerStyle: {
          ...(null !=
          (K =
            null == (Y = null == J ? void 0 : J.corner)
              ? void 0
              : Y.headerStyle)
            ? K
            : {}),
          marked: (e) => {
            const { col: T, row: C } = e;
            return ee.some((e) => e.col === T && e.row === C);
          },
        },
      }),
      J
    );
  },
  getTableCellPadding = (e) => {
    var T, C;
    const $ =
        "tight" === e.rowSpaceMode
          ? CELL_PADDING_TOP_TIGHT
          : "custom" === e.rowSpaceMode
          ? null != (T = e.rowPadding)
            ? T
            : CELL_PADDING_TOP_TIGHT
          : CELL_PADDING_TOP,
      F =
        "tight" === e.colSpaceMode
          ? CELL_PADDING_LEFT_TIGHT
          : "custom" === e.colSpaceMode
          ? null != (C = e.colPadding)
            ? C
            : CELL_PADDING_TOP_TIGHT
          : CELL_PADDING_LEFT;
    return [$, F, $, F];
  },
  getPivotTableCellPadding = (e) => {
    var T;
    const C =
      "tight" === e.rowSpaceMode
        ? CELL_PADDING_TOP_TIGHT
        : "custom" === e.rowSpaceMode
        ? null != (T = e.customRowPadding)
          ? T
          : CELL_PADDING_TOP_TIGHT
        : CELL_PADDING_TOP;
    return [C, CELL_PADDING_LEFT, C, CELL_PADDING_LEFT];
  },
  getTableCellBorderColor = (e) => {
    var T, C, $, F, V, Y;
    return [
      null == (T = e.gridLineHorizontal) || T
        ? null != (C = e.gridLineHorizontalColor)
          ? C
          : e.gridLineColor
        : null,
      null == ($ = e.gridLineVertical) || $
        ? null != (F = e.gridLineVerticalColor)
          ? F
          : e.gridLineColor
        : null,
      null,
      null == (V = e.gridLineVertical) || V
        ? null != (Y = e.gridLineVerticalColor)
          ? Y
          : e.gridLineColor
        : null,
    ];
  },
  getTableCellBorderLineWidth = (e) => {
    var T, C, $;
    return [
      null == (T = e.gridLineHorizontal) || T ? e.gridLineHorizontalWidth : 0,
      null == (C = e.gridLineVertical) || C ? e.gridLineVerticalWidth : 0,
      0,
      null == ($ = e.gridLineVertical) || $ ? e.gridLineVerticalWidth : 0,
    ];
  },
  getTableCellBorderLineDash = (e) => {
    var T, C, $, F, V, Y, K, J, ee;
    const te = getTableCellBorderLineWidth(e);
    return [
      (null == (T = e.gridLineHorizontal) || T) &&
      null !=
        ($ =
          null == (C = lineDashMap[e.gridLineHorizontalStyle])
            ? void 0
            : C.map((e) => e * te[0]))
        ? $
        : null,
      (null == (F = e.gridLineVertical) || F) &&
      null !=
        (Y =
          null == (V = lineDashMap[e.gridLineVerticalStyle])
            ? void 0
            : V.map((e) => e * te[1]))
        ? Y
        : null,
      null,
      (null == (K = e.gridLineVertical) || K) &&
      null !=
        (ee =
          null == (J = lineDashMap[e.gridLineVerticalStyle])
            ? void 0
            : J.map((e) => e * te[3]))
        ? ee
        : null,
    ];
  },
  getFontBold = (e) => (e ? "bold" : "normal"),
  getFontItalic = (e) => (e ? "italic" : "normal"),
  getHeaderStyle = (e, T) => {
    var C, $;
    const {
        headerFontBold: F,
        headerFontItalic: V,
        headerFontUnderline: Y,
        headerFontSize: K = 0,
        headerFontColor: J,
        headerFont: ee = FONT_FAMILY,
        headerFontWeight: te,
        headerTextAlign: ie = "center",
      } = e,
      ne = getFontBold(F);
    return {
      fontFamily: ee,
      fontSize: K,
      fontVariant: "normal",
      fontStyle: getFontItalic(V),
      fontWeight: null != te ? te : ne,
      textAlign: ie,
      color: null != J ? J : null == T ? void 0 : T.color,
      bgColor: getBgColorInHeaderStyle(e),
      lineHeight: Math.max(CELL_LINE_HEIGHT, K),
      underline:
        null != (C = (null == T ? void 0 : T.underline) ? void 0 : Y)
          ? C
          : null == T
          ? void 0
          : T.underline,
      underlineDash:
        null != ($ = Y ? null : void 0)
          ? $
          : null == T
          ? void 0
          : T.underlineDash,
    };
  },
  getBodyStyle = (e, T) => {
    const {
        bodyFontBold: C,
        bodyFontItalic: $,
        bodyFontUnderline: F,
        bodyFontSize: V = 0,
        bodyFontColor: Y,
        bodyFont: K = FONT_FAMILY,
        bodyFontWeight: J,
        bodyTextAlign: ee = "center",
      } = e,
      te = getFontBold(C),
      ie = getFontItalic($);
    return {
      fontFamily: null != K ? K : FONT_FAMILY,
      fontSize: V,
      fontStyle: ie,
      fontWeight: null != J ? J : te,
      textAlign: ee,
      fontVariant: "normal",
      color: null != Y ? Y : null == T ? void 0 : T.color,
      bgColor: getBgColorInBodyStyle(e),
      lineHeight: Math.max(CELL_LINE_HEIGHT, V),
      underline: null != F ? F : null == T ? void 0 : T.underline,
    };
  },
  getSubHeaderStyle = (e, T) => {
    var C, $;
    const {
        headerFontSize: F = 0,
        headerSubTitleFontBold: V,
        headerSubTitleFontItalic: Y,
        headerSubTitleFontSize: K,
        headerSubTitleFontUnderline: J,
        headerSubTitleFontColor: ee,
      } = e,
      te = getFontBold(V),
      ie = getFontItalic(Y);
    return {
      fontFamily: FONT_FAMILY,
      fontSize: K,
      fontVariant: "normal",
      fontStyle: ie,
      fontWeight: te,
      color: null != ee ? ee : null == T ? void 0 : T.color,
      bgColor: getBgColorInHeaderStyle(e),
      lineHeight: Math.max(CELL_LINE_HEIGHT, F),
      underline:
        null != (C = (null == T ? void 0 : T.underline) ? void 0 : J)
          ? C
          : null == T
          ? void 0
          : T.underline,
      underlineDash:
        null != ($ = J ? null : void 0)
          ? $
          : null == T
          ? void 0
          : T.underlineDash,
    };
  },
  getBgColorInHeaderStyle = ({ headerBackground: e, headerColor: T }) =>
    null == e || e ? T : TRANSPARENT_COLOR$1,
  getBgColorInBodyStyle = ({
    alternateRow: e,
    rowColor: T = TRANSPARENT_COLOR$1,
    alternateRowColor: C,
  }) =>
    null == e || e
      ? ({ row: e, table: $ }) =>
          (e - $.columnHeaderLevelCount) % 2 == 0 ? T : null != C ? C : T
      : T,
  highlight = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? pivotTableHighlight(e, T)
      : listTableHighlight(e, T),
  listTableHighlight = (e, T) => {
    var C;
    const $ = {
        ...e,
      },
      { vizData: F } = T,
      { displayConf: V } = F,
      { highlightMark: Y } = null != T ? T : {},
      { selectedBodyKeys: K, selectedHeaderKeys: J } = null != Y ? Y : {};
    if (!$.columns) return $;
    if (!K && !J) return $;
    const ee = {},
      te = {};
    return (
      (null == K ? void 0 : K.length) &&
        (K.forEach((e) => {
          const [T, C] = e.split("_").map(Number);
          ee[C] || ((ee[C] = []), (te[C] = [])), ee[C].push(T);
        }),
        Object.keys(ee).forEach((e) => {
          const T = ee[Number(e)];
          T.sort((e, T) => e - T);
          let C = -2;
          T.forEach((T) => {
            T > C + 1 ? te[e].push([T, T]) : (te[e][te[e].length - 1][1] = T),
              (C = T);
          });
        })),
      ($.columns =
        null == (C = $.columns)
          ? void 0
          : C.map((e) => {
              var T, C;
              const $ = {
                ...e,
              };
              return (
                ($.style = {
                  ...(null != (T = e.style) ? T : {}),
                  bgColor: (T) => {
                    const { row: C, col: $ } = T;
                    if (te[$])
                      for (const [e, V] of te[$])
                        if (C >= e && C <= V) return "rgba(253, 253, 194)";
                    const F = getBgColorInBodyStyle(V);
                    return "function" == typeof e.style.bgColor
                      ? e.style.bgColor(T)
                      : "function" == typeof F
                      ? F(T)
                      : F;
                  },
                }),
                ($.headerStyle = {
                  ...(null != (C = e.headerStyle) ? C : {}),
                  bgColor: (T) => {
                    const { row: C, col: $ } = T;
                    for (const e of null != J ? J : []) {
                      const [T, F] = e.split("_").map(Number);
                      if (C === T && $ === F) return "rgba(250, 243, 155)";
                    }
                    return "function" == typeof e.headerStyle.bgColor
                      ? e.headerStyle.bgColor(T)
                      : getBgColorInHeaderStyle(V);
                  },
                }),
                $
              );
            })),
      $
    );
  },
  pivotTableHighlight = (e, T) => {
    const C = {
        ...e,
      },
      { highlightMark: $ } = null != T ? T : {},
      { selectedBodyKeys: F, selectedHeaderKeys: V } = null != $ ? $ : {},
      { indicators: Y } = C,
      { displayConf: K } = T.vizData;
    if (Y) {
      if (!F && !V) return C;
      if (F || V) {
        const e = {};
        (null == F ? void 0 : F.length) &&
          F.forEach((T) => {
            const [C, $] = T.split("_").map(Number);
            e[$] || (e[$] = []), e[$].push(C);
          }),
          (C.indicators = C.indicators.map((T) => {
            var C, $, F;
            const V = {
                ...T,
              },
              Y =
                null !=
                ($ =
                  null == (C = null == V ? void 0 : V.style)
                    ? void 0
                    : C.bgColor)
                  ? $
                  : getBgColorInBodyStyle(K);
            return (
              (V.style = {
                ...(null != (F = V.style) ? F : {}),
                bgColor: (T) => {
                  var C;
                  const { row: $, col: F } = T;
                  return (null == (C = e[F]) ? void 0 : C.includes($))
                    ? "rgba(253, 253, 194)"
                    : "function" != typeof Y
                    ? "function" === Y
                      ? Y(T)
                      : Y
                    : void 0;
                },
              }),
              V
            );
          }));
      }
      return C;
    }
  },
  initColumns = (e, T) => {
    const C = {
        ...e,
      },
      $ = generateColumns(T),
      F = generateRecords(T);
    return (C.columns = $), (C.records = F), C;
  },
  generateColumns = (e) => {
    var T, C, $, F;
    const { vizData: V } = e,
      { fieldMap: Y, statistics: K } = V,
      { displayConf: J } = V,
      ee = [
        ...getFields(V, Location.DIMENSION, isRenderField),
        ...getFields(V, Location.MEASURE, isRenderField),
      ].filter((e) => {
        var T;
        return void 0 !== (null == (T = Y[e]) ? void 0 : T.alias);
      }),
      te = Array.isArray(
        null ==
          ($ =
            null == (C = null == (T = V.datasets) ? void 0 : T[0])
              ? void 0
              : C[0])
          ? void 0
          : $[0]
      )
        ? V.datasets[0][0][0]
        : null != (F = V.datasets)
        ? F
        : [];
    return ee.map((e) => {
      var T, C, $;
      return {
        ...(isNumberType(Y[e].type) && {
          firstRow: Number(null == (T = te[0]) ? void 0 : T[e]),
          ...(null == K ? void 0 : K[e]),
        }),
        field: e,
        title: null != ($ = null == (C = Y[e]) ? void 0 : C.alias) ? $ : "",
        showSort: J.sortable && !V.fieldMap[e].disableSort,
        style: Y[e].style,
        headerStyle: Y[e].headerStyle,
      };
    });
  },
  generateRecords = (e) => {
    var T, C, $, F;
    const { vizData: V } = e,
      { fieldMap: Y } = V,
      K = [
        ...getFields(V, Location.DIMENSION),
        ...getFields(V, Location.MEASURE),
      ].filter((e) => {
        var T;
        return void 0 !== (null == (T = Y[e]) ? void 0 : T.alias);
      });
    let J;
    J = Array.isArray(
      null ==
        ($ =
          null == (C = null == (T = V.datasets) ? void 0 : T[0])
            ? void 0
            : C[0])
        ? void 0
        : $[0]
    )
      ? V.datasets[0][0][0]
      : null != (F = V.datasets)
      ? F
      : [];
    const ee = J.map((e) => {
        const T = {};
        return (
          [...K, "combined"].forEach((C) => {
            T[C] = e[C];
          }),
          T
        );
      }),
      { pageSize: te, scrollSize: ie } = V.displayConf,
      ne = ee.length,
      re =
        ne <= te
          ? te - ne
          : (ne - te) % ie != 0 && ie - ((ne - te) % ie) < te
          ? ie - ((ne - te) % ie)
          : 0,
      ae = [];
    for (let oe = 0; oe < re; oe++) {
      const e = {};
      K.forEach((T) => {
        e[T] = " ";
      }),
        (e[EMPTY_LINE_TAG] = !0),
        ae.push(lodash.exports.cloneDeep(e));
    }
    return (e.wholeData = ee.concat(ae)), getPageDataSource(ee.concat(ae), V);
  },
  getPageDataSource = (e, T, C) => {
    var $, F, V;
    const { displayConf: Y } = T,
      { page: K = 1, pageSize: J = 10 } = T.displayConf,
      ee = null != ($ = Y.pagination) && $,
      te = Y.loadPartialData
        ? 0
        : null != (V = null == (F = T.pagination) ? void 0 : F.offset)
        ? V
        : 0;
    return ee
      ? null == e
        ? void 0
        : e.slice((K - 1) * J - te, K * J - te)
      : e;
  };
class Generator$1 {
  static GenAutoIncrementId() {
    return Generator$1.auto_increment_id++;
  }
}
var MeasureModeEnum, MeasureModeEnum2;
(Generator$1.auto_increment_id = 0),
  (MeasureModeEnum2 = MeasureModeEnum || (MeasureModeEnum = {})),
  (MeasureModeEnum2[(MeasureModeEnum2.estimate = 0)] = "estimate"),
  (MeasureModeEnum2[(MeasureModeEnum2.actualBounding = 1)] = "actualBounding"),
  (MeasureModeEnum2[(MeasureModeEnum2.fontBounding = 2)] = "fontBounding");
const circleThreshold$1 = tau$1 - 1e-8;
class BoundsContext$1 {
  constructor(e) {
    this.init(e);
  }
  init(e) {
    this.bounds = e;
  }
  arc(e, T, C, $, F, V) {
    if (Math.abs(F - $) > circleThreshold$1)
      return this.bounds.add(e - C, T - C), void this.bounds.add(e + C, T + C);
    let Y,
      K,
      J,
      ee,
      te = 1 / 0,
      ie = -1 / 0,
      ne = 1 / 0,
      re = -1 / 0;
    function ae(e) {
      (J = C * Math.cos(e)),
        (ee = C * Math.sin(e)),
        J < te && (te = J),
        J > ie && (ie = J),
        ee < ne && (ne = ee),
        ee > re && (re = ee);
    }
    if ((ae($), ae(F), F !== $))
      if (
        (($ %= tau$1) < 0 && ($ += tau$1),
        (F %= tau$1) < 0 && (F += tau$1),
        F < $ && ((V = !V), (Y = $), ($ = F), (F = Y)),
        V)
      )
        for (
          F -= tau$1, Y = $ - ($ % halfPi$2), K = 0;
          K < 4 && Y > F;
          ++K, Y -= halfPi$2
        )
          ae(Y);
      else
        for (
          Y = $ - ($ % halfPi$2) + halfPi$2, K = 0;
          K < 4 && Y < F;
          ++K, Y += halfPi$2
        )
          ae(Y);
    this.bounds.add(e + te, T + ne), this.bounds.add(e + ie, T + re);
  }
  arcTo(e, T, C, $, F) {
    this.bounds.add(e, T);
  }
  bezierCurveTo(e, T, C, $, F, V) {
    this.bounds.add(e, T), this.bounds.add(C, $), this.bounds.add(F, V);
  }
  closePath() {}
  ellipse() {
    throw new Error("ellipse");
  }
  lineTo(e, T) {
    this.bounds.add(e, T);
  }
  moveTo(e, T) {
    this.bounds.add(e, T);
  }
  quadraticCurveTo(e, T, C, $) {
    this.bounds.add(e, T), this.bounds.add(C, $);
  }
  rect(e, T, C, $) {
    this.bounds.add(e, T), this.bounds.add(e + C, T + $);
  }
  clear() {
    this.bounds.clear();
  }
  release(...e) {}
}
class CurvePath$1 {
  constructor() {
    (this.curves = []), (this.bounds = new AABBBounds$1());
  }
  getCurveLengths() {
    return this.curves.map((e) => e.getLength());
  }
  getPointAt(e) {
    return {
      x: 0,
      y: 0,
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
}
const rePathCommand$1 =
    /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
  commandLengths$1 = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7,
  },
  enumCommandMap$1 = {
    A: 0,
    AT: 1,
    C: 2,
    Z: 3,
    E: 4,
    L: 5,
    M: 6,
    Q: 7,
    R: 8,
  };
let currPath$1,
  coordsStr$1,
  commandChar$1,
  coordStr$1,
  coordNumber$1,
  standardCommandLen$1;
function parseSvgPath$1(e) {
  if (!e) return [];
  const T = e.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === T) return [];
  let C, $;
  const F = [];
  for (let V = 0, Y = T.length; V < Y; V++)
    if (
      ((currPath$1 = T[V]),
      (coordsStr$1 = currPath$1.slice(1)),
      (commandChar$1 = currPath$1[0]),
      (C = [commandChar$1]),
      ($ = coordsStr$1.match(rePathCommand$1)),
      null !== $)
    ) {
      for (let e = 0, T = $.length; e < T; e++)
        (coordStr$1 = $[e]),
          (coordNumber$1 = parseFloat(coordStr$1)),
          Number.isNaN(coordNumber$1) || C.push(coordNumber$1);
      if (
        ((standardCommandLen$1 = commandLengths$1[commandChar$1]),
        C.length - 1 > standardCommandLen$1)
      ) {
        let e,
          T = commandChar$1;
        for (let $ = 1, V = C.length; $ < V; $ += standardCommandLen$1) {
          e = [T];
          for (let T = $, F = $ + standardCommandLen$1; T < F; T++)
            e.push(C[T]);
          F.push(e), "m" === T ? (T = "l") : "M" === T && (T = "L");
        }
      } else F.push(C);
    } else F.push(C);
  return F;
}
var UpdateTag$1,
  UpdateTag2,
  IContainPointMode$1,
  IContainPointMode2,
  AttributeUpdateType$1,
  AttributeUpdateType2,
  AnimateStatus$1,
  AnimateStatus2,
  AnimateMode$1,
  AnimateMode2,
  AnimateStepType$1,
  AnimateStepType2,
  Direction$1,
  Direction2,
  CurveTypeEnum$1,
  CurveTypeEnum2,
  BaseRenderContributionTime$1,
  BaseRenderContributionTime2;
function segments$1(e, T, C, $, F, V, Y, K, J) {
  const ee = degreeToRadian$2(Y),
    te = Math.sin(ee),
    ie = Math.cos(ee),
    ne = ie * (K - e) * 0.5 + te * (J - T) * 0.5,
    re = ie * (J - T) * 0.5 - te * (K - e) * 0.5;
  let ae =
    (ne * ne) / ((C = Math.abs(C)) * C) + (re * re) / (($ = Math.abs($)) * $);
  ae > 1 && ((ae = Math.sqrt(ae)), (C *= ae), ($ *= ae));
  const oe = ie / C,
    se = te / C,
    le = -te / $,
    de = ie / $,
    ce = oe * K + se * J,
    ue = le * K + de * J,
    he = oe * e + se * T,
    pe = le * e + de * T;
  let ge = 1 / ((he - ce) * (he - ce) + (pe - ue) * (pe - ue)) - 0.25;
  ge < 0 && (ge = 0);
  let fe = Math.sqrt(ge);
  V === F && (fe = -fe);
  const me = 0.5 * (ce + he) - fe * (pe - ue),
    ye = 0.5 * (ue + pe) + fe * (he - ce),
    be = Math.atan2(ue - ye, ce - me);
  let ve = Math.atan2(pe - ye, he - me) - be;
  ve < 0 && 1 === V ? (ve += tau$1) : ve > 0 && 0 === V && (ve -= tau$1);
  const Te = Math.ceil(Math.abs(ve / (halfPi$2 + 0.001))),
    _e = [];
  for (let Ce = 0; Ce < Te; ++Ce) {
    const e = be + (Ce * ve) / Te,
      T = be + ((Ce + 1) * ve) / Te;
    _e[Ce] = [me, ye, e, T, C, $, te, ie];
  }
  return _e;
}
function bezier$1(e) {
  const T = e[0],
    C = e[1],
    $ = e[2],
    F = e[3],
    V = e[4],
    Y = e[5],
    K = e[6],
    J = e[7],
    ee = J * V,
    te = -K * Y,
    ie = K * V,
    ne = J * Y,
    re = Math.cos($),
    ae = Math.sin($),
    oe = Math.cos(F),
    se = Math.sin(F),
    le = 0.5 * (F - $),
    de = Math.sin(0.5 * le),
    ce = ((8 / 3) * de * de) / Math.sin(le),
    ue = T + re - ce * ae,
    he = C + ae + ce * re,
    pe = T + oe,
    ge = C + se,
    fe = pe + ce * se,
    me = ge - ce * oe;
  return [
    ee * ue + te * he,
    ie * ue + ne * he,
    ee * fe + te * me,
    ie * fe + ne * me,
    ee * pe + te * ge,
    ie * pe + ne * ge,
  ];
}
function drawArc$1(e, T, C, $) {
  const F = segments$1($[5], $[6], $[0], $[1], $[3], $[4], $[2], T, C);
  for (let V = 0; V < F.length; ++V) {
    const T = bezier$1(F[V]);
    e.bezierCurveTo(T[0], T[1], T[2], T[3], T[4], T[5]);
  }
}
(UpdateTag2 = UpdateTag$1 || (UpdateTag$1 = {})),
  (UpdateTag2[(UpdateTag2.NONE = 0)] = "NONE"),
  (UpdateTag2[(UpdateTag2.UPDATE_BOUNDS = 1)] = "UPDATE_BOUNDS"),
  (UpdateTag2[(UpdateTag2.UPDATE_SHAPE = 2)] = "UPDATE_SHAPE"),
  (UpdateTag2[(UpdateTag2.CLEAR_SHAPE = 253)] = "CLEAR_SHAPE"),
  (UpdateTag2[(UpdateTag2.UPDATE_SHAPE_AND_BOUNDS = 3)] =
    "UPDATE_SHAPE_AND_BOUNDS"),
  (UpdateTag2[(UpdateTag2.INIT = 179)] = "INIT"),
  (UpdateTag2[(UpdateTag2.CLEAR_BOUNDS = 254)] = "CLEAR_BOUNDS"),
  (UpdateTag2[(UpdateTag2.UPDATE_GLOBAL_MATRIX = 32)] = "UPDATE_GLOBAL_MATRIX"),
  (UpdateTag2[(UpdateTag2.CLEAR_GLOBAL_MATRIX = 223)] = "CLEAR_GLOBAL_MATRIX"),
  (UpdateTag2[(UpdateTag2.UPDATE_LOCAL_MATRIX = 16)] = "UPDATE_LOCAL_MATRIX"),
  (UpdateTag2[(UpdateTag2.CLEAR_LOCAL_MATRIX = 239)] = "CLEAR_LOCAL_MATRIX"),
  (UpdateTag2[(UpdateTag2.UPDATE_GLOBAL_LOCAL_MATRIX = 48)] =
    "UPDATE_GLOBAL_LOCAL_MATRIX"),
  (UpdateTag2[(UpdateTag2.UPDATE_LAYOUT = 128)] = "UPDATE_LAYOUT"),
  (UpdateTag2[(UpdateTag2.CLEAR_LAYOUT = 127)] = "CLEAR_LAYOUT"),
  (IContainPointMode2 = IContainPointMode$1 || (IContainPointMode$1 = {})),
  (IContainPointMode2[(IContainPointMode2.GLOBAL = 1)] = "GLOBAL"),
  (IContainPointMode2[(IContainPointMode2.LOCAL = 16)] = "LOCAL"),
  (IContainPointMode2[(IContainPointMode2.GLOBAL_ACCURATE = 3)] =
    "GLOBAL_ACCURATE"),
  (IContainPointMode2[(IContainPointMode2.LOCAL_ACCURATE = 48)] =
    "LOCAL_ACCURATE"),
  (AttributeUpdateType2 =
    AttributeUpdateType$1 || (AttributeUpdateType$1 = {})),
  (AttributeUpdateType2[(AttributeUpdateType2.INIT = 0)] = "INIT"),
  (AttributeUpdateType2[(AttributeUpdateType2.DEFAULT = 1)] = "DEFAULT"),
  (AttributeUpdateType2[(AttributeUpdateType2.STATE = 2)] = "STATE"),
  (AttributeUpdateType2[(AttributeUpdateType2.ANIMATE_BIND = 10)] =
    "ANIMATE_BIND"),
  (AttributeUpdateType2[(AttributeUpdateType2.ANIMATE_PLAY = 11)] =
    "ANIMATE_PLAY"),
  (AttributeUpdateType2[(AttributeUpdateType2.ANIMATE_START = 12)] =
    "ANIMATE_START"),
  (AttributeUpdateType2[(AttributeUpdateType2.ANIMATE_UPDATE = 13)] =
    "ANIMATE_UPDATE"),
  (AttributeUpdateType2[(AttributeUpdateType2.ANIMATE_END = 14)] =
    "ANIMATE_END"),
  (AttributeUpdateType2[(AttributeUpdateType2.TRANSLATE = 20)] = "TRANSLATE"),
  (AttributeUpdateType2[(AttributeUpdateType2.TRANSLATE_TO = 21)] =
    "TRANSLATE_TO"),
  (AttributeUpdateType2[(AttributeUpdateType2.SCALE = 22)] = "SCALE"),
  (AttributeUpdateType2[(AttributeUpdateType2.SCALE_TO = 23)] = "SCALE_TO"),
  (AttributeUpdateType2[(AttributeUpdateType2.ROTATE = 24)] = "ROTATE"),
  (AttributeUpdateType2[(AttributeUpdateType2.ROTATE_TO = 25)] = "ROTATE_TO"),
  (AnimateStatus2 = AnimateStatus$1 || (AnimateStatus$1 = {})),
  (AnimateStatus2[(AnimateStatus2.INITIAL = 0)] = "INITIAL"),
  (AnimateStatus2[(AnimateStatus2.RUNNING = 1)] = "RUNNING"),
  (AnimateStatus2[(AnimateStatus2.PAUSED = 2)] = "PAUSED"),
  (AnimateStatus2[(AnimateStatus2.END = 3)] = "END"),
  (AnimateMode2 = AnimateMode$1 || (AnimateMode$1 = {})),
  (AnimateMode2[(AnimateMode2.NORMAL = 0)] = "NORMAL"),
  (AnimateMode2[(AnimateMode2.SET_ATTR_IMMEDIATELY = 1)] =
    "SET_ATTR_IMMEDIATELY"),
  (AnimateStepType2 = AnimateStepType$1 || (AnimateStepType$1 = {})),
  (AnimateStepType2.wait = "wait"),
  (AnimateStepType2.from = "from"),
  (AnimateStepType2.to = "to"),
  (AnimateStepType2.customAnimate = "customAnimate"),
  (Direction2 = Direction$1 || (Direction$1 = {})),
  (Direction2[(Direction2.ROW = 1)] = "ROW"),
  (Direction2[(Direction2.COLUMN = 2)] = "COLUMN"),
  (CurveTypeEnum2 = CurveTypeEnum$1 || (CurveTypeEnum$1 = {})),
  (CurveTypeEnum2[(CurveTypeEnum2.CubicBezierCurve = 0)] = "CubicBezierCurve"),
  (CurveTypeEnum2[(CurveTypeEnum2.QuadraticBezierCurve = 1)] =
    "QuadraticBezierCurve"),
  (CurveTypeEnum2[(CurveTypeEnum2.ArcCurve = 2)] = "ArcCurve"),
  (CurveTypeEnum2[(CurveTypeEnum2.LineCurve = 3)] = "LineCurve"),
  (CurveTypeEnum2[(CurveTypeEnum2.EllipseCurve = 4)] = "EllipseCurve"),
  (CurveTypeEnum2[(CurveTypeEnum2.MoveCurve = 5)] = "MoveCurve"),
  (BaseRenderContributionTime2 =
    BaseRenderContributionTime$1 || (BaseRenderContributionTime$1 = {})),
  (BaseRenderContributionTime2[
    (BaseRenderContributionTime2.beforeFillStroke = 0)
  ] = "beforeFillStroke"),
  (BaseRenderContributionTime2[
    (BaseRenderContributionTime2.afterFillStroke = 1)
  ] = "afterFillStroke");
const addArcToBezierPath$2 = (e, T, C, $, F, V, Y) => {
    const K = Math.abs(C - T),
      J = K > 0.5 * Math.PI ? Math.ceil((2 * K) / Math.PI) : 1,
      ee = (C - T) / J;
    for (let te = 0; te < J; te++) {
      const C = T + ee * te,
        K = T + ee * (te + 1),
        J = (4 * Math.tan(Math.abs(ee) / 4)) / 3,
        ie = K < C ? -1 : 1,
        ne = Math.cos(C),
        re = Math.sin(C),
        ae = Math.cos(K),
        oe = Math.sin(K),
        se = ne * V + $,
        le = re * Y + F,
        de = ae * V + $,
        ce = oe * Y + F,
        ue = V * J * ie,
        he = Y * J * ie;
      e.push(se - ue * re, le + he * ne, de + ue * oe, ce - he * ae, de, ce);
    }
  },
  commandFuncs$1 = [
    (e, T, C, $, F, V, Y) =>
      T.arc(
        e[1] * F + C,
        e[2] * V + $,
        (e[3] * (F + V)) / 2,
        e[4],
        e[5],
        e[6],
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.arcTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        (e[5] * (F + V)) / 2,
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.bezierCurveTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        e[5] * F + C,
        e[6] * V + $,
        Y
      ),
    (e, T, C, $) => T.closePath(),
    (e, T, C, $, F, V) =>
      T.ellipse(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F,
        e[4] * V,
        e[5],
        e[6],
        e[7],
        e[8]
      ),
    (e, T, C, $, F, V, Y) => T.lineTo(e[1] * F + C, e[2] * V + $, Y),
    (e, T, C, $, F, V, Y) => T.moveTo(e[1] * F + C, e[2] * V + $, Y),
    (e, T, C, $, F, V, Y) =>
      T.quadraticCurveTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.rect(e[1] * F + C, e[2] * V + $, e[3] * F, e[4] * V, Y),
  ];
function renderCommandList$1(e, T, C = 0, $ = 0, F = 1, V = 1, Y) {
  for (let K = 0; K < e.length; K++) {
    const J = e[K];
    commandFuncs$1[J[0]](J, T, C, $, F, V, Y);
  }
}
class Curve$1 {
  getLength(e) {
    return null != e
      ? this.calcProjLength(e)
      : (Number.isFinite(this.length) || (this.length = this.calcLength()),
        this.length);
  }
}
function snapLength$1(e, T) {
  let C = 0;
  const $ = e.length;
  for (let F = 0; F < $; F++) {
    const V = e[F],
      Y = T[F],
      K = e[(F + 1) % $],
      J = T[(F + 1) % $];
    C += PointService$1.distanceNN(V, Y, K, J);
  }
  return C / 2;
}
function cubicLength$1(e, T, C, $, F) {
  return snapLength$1([e.x, T.x, C.x, $.x], [e.y, T.y, C.y, $.y]);
}
function cubicCalc$1(e, T, C, $, F) {
  const V = 1 - F;
  return V * V * V * e + 3 * T * F * V * V + 3 * C * F * F * V + $ * F * F * F;
}
function cubicPointAt$1(e, T, C, $, F) {
  const V = cubicCalc$1(e.x, T.x, C.x, $.x, F),
    Y = cubicCalc$1(e.y, T.y, C.y, $.y, F);
  return new Point$1(V, Y);
}
function divideCubic$1(e, T) {
  const { p0: C, p1: $, p2: F, p3: V } = e,
    Y = cubicPointAt$1(C, $, F, V, T),
    K = PointService$1.pointAtPP(C, $, T),
    J = PointService$1.pointAtPP($, F, T),
    ee = PointService$1.pointAtPP(F, V, T),
    te = PointService$1.pointAtPP(K, J, T),
    ie = PointService$1.pointAtPP(J, ee, T);
  return [
    new CubicBezierCurve$1(C, K, te, Y),
    new CubicBezierCurve$1(Y, ie, ee, V),
  ];
}
class CubicBezierCurve$1 extends Curve$1 {
  constructor(e, T, C, $) {
    super(),
      (this.type = CurveTypeEnum$1.CubicBezierCurve),
      (this.p0 = e),
      (this.p1 = T),
      (this.p2 = C),
      (this.p3 = $);
  }
  _validPoint() {
    return Number.isFinite(
      this.p0.x +
        this.p0.y +
        this.p1.x +
        this.p1.y +
        this.p2.x +
        this.p2.y +
        this.p3.x +
        this.p3.y
    );
  }
  getPointAt(e) {
    if (!1 !== this.defined)
      return cubicPointAt$1(this.p0, this.p1, this.p2, this.p3, e);
    throw new Error("definedfalsegetPointAt");
  }
  calcLength() {
    return this._validPoint()
      ? cubicLength$1(this.p0, this.p1, this.p2, this.p3)
      : 60;
  }
  calcProjLength(e) {
    return e === Direction$1.ROW
      ? abs$1(this.p0.x - this.p3.x)
      : e === Direction$1.COLUMN
      ? abs$1(this.p0.y - this.p3.y)
      : 0;
  }
  getAngleAt(e) {
    const T = max$1(e - 0.01, 0),
      C = min$1(e + 0.01, 1),
      $ = this.getPointAt(T),
      F = this.getPointAt(C);
    return atan2$1(F.y - $.y, F.x - $.x);
  }
}
function divideLinear$1(e, T) {
  const { p0: C, p1: $ } = e,
    F = PointService$1.pointAtPP(C, $, T);
  return [new LineCurve$1(C, F), new LineCurve$1(F, $)];
}
class LineCurve$1 extends Curve$1 {
  constructor(e, T) {
    super(),
      (this.type = CurveTypeEnum$1.LineCurve),
      (this.p0 = e),
      (this.p1 = T);
  }
  getPointAt(e) {
    if (!1 !== this.defined)
      return PointService$1.pointAtPP(this.p0, this.p1, e);
    throw new Error("definedfalsegetPointAt");
  }
  getAngleAt(e) {
    return (
      null == this.angle &&
        (this.angle = atan2$1(this.p1.y - this.p0.y, this.p1.x - this.p0.x)),
      this.angle
    );
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint()
      ? PointService$1.distancePP(this.p0, this.p1)
      : 60;
  }
  calcProjLength(e) {
    return e === Direction$1.ROW
      ? abs$1(this.p0.x - this.p1.x)
      : e === Direction$1.COLUMN
      ? abs$1(this.p0.y - this.p1.y)
      : 0;
  }
}
class SegContext$1 {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(e, T) {
    this.init(e, T);
  }
  init(e, T) {
    (this._lastX = this._lastY = this._startX = this._startY = 0),
      (this.curveType = e),
      (this.direction = T),
      (this.curves = []);
  }
  bezierCurveTo(e, T, C, $, F, V, Y, K) {
    const J = new CubicBezierCurve$1(
      new Point$1(this._lastX, this._lastY),
      new Point$1(e, T),
      new Point$1(C, $),
      new Point$1(F, V)
    );
    (J.originP1 = this._lastOriginP),
      (J.originP2 = K),
      (J.defined = Y),
      this.curves.push(J),
      (this._lastX = F),
      (this._lastY = V),
      (this._lastOriginP = K);
  }
  closePath() {
    if (this.curves.length < 2) return;
    const e = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, e.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContextellipse");
  }
  lineTo(e, T, C, $) {
    const F = this.addLinearCurve(e, T, C, this._lastOriginP, $);
    this.curves.push(F),
      (this._lastX = e),
      (this._lastY = T),
      (this._lastOriginP = $);
  }
  moveTo(e, T, C) {
    return (
      (this._lastX = this._startX = e),
      (this._lastY = this._startY = T),
      (this._lastOriginP = C),
      (this._startOriginP = C),
      this
    );
  }
  quadraticCurveTo(e, T, C, $) {
    throw new Error("SegContextquadraticCurveTo");
  }
  clear() {
    (this.curves = []), (this.length = NaN);
  }
  tryUpdateLength(e) {
    return this.getLength(e);
  }
  addLinearCurve(e, T, C, $, F) {
    const V = new LineCurve$1(
      new Point$1(this._lastX, this._lastY),
      new Point$1(e, T)
    );
    return (V.originP1 = $), (V.originP2 = F), (V.defined = C), V;
  }
  getPointAt(e) {
    throw new Error("");
  }
  getCurveLengths() {
    return [];
  }
  getLength(e) {
    var T, C;
    if (e === Direction$1.COLUMN) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        C = this.curves[this.curves.length - 1],
        $ = null !== (T = C.p3) && void 0 !== T ? T : C.p1;
      return abs$1(e.p0.y - $.y);
    }
    if (e === Direction$1.ROW) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1],
        $ = null !== (C = T.p3) && void 0 !== C ? C : T.p1;
      return abs$1(e.p0.x - $.x);
    }
    return (
      Number.isFinite(this.length) ||
        (this.length = this.curves.reduce((e, T) => e + T.getLength(), 0)),
      this.length
    );
  }
}
class ReflectSegContext$1 extends SegContext$1 {
  bezierCurveTo(e, T, C, $, F, V, Y, K) {
    return super.bezierCurveTo(T, e, $, C, V, F, Y, K);
  }
  lineTo(e, T, C, $) {
    return super.lineTo(T, e, C, $);
  }
  moveTo(e, T, C) {
    return super.moveTo(T, e, C);
  }
  clear() {
    return super.clear();
  }
}
function genCurveSegments$1(e, T, C = 1) {
  let $ = !1;
  for (let F = 0, V = T.length; F <= V; F++)
    F >= V === $ && (($ = !$) ? e.lineStart() : e.lineEnd()),
      $ && e.point(T[F]);
}
function genSegContext$1(e, T, C) {
  const $ =
    null != T
      ? T
      : abs$1(C[C.length - 1].x - C[0].x) > abs$1(C[C.length - 1].y - C[0].y)
      ? Direction$1.ROW
      : Direction$1.COLUMN;
  return "monotoneY" === e
    ? new ReflectSegContext$1(e, $)
    : new SegContext$1(e, $);
}
class Linear$1 {
  constructor(e, T) {
    (this.context = e), T && (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._point = 0), this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined && !1 !== e.defined,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(
          T,
          C,
          !1 !== this._lastDefined && !1 !== e.defined,
          e
        );
    }
    this._lastDefined = e.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genLinearSegments$1(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  const F = genSegContext$1("linear", C, e);
  return genLinearTypeSegments$1(new Linear$1(F, $), e), F;
}
function genLinearTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 1);
}
function point$7(e, T, C, $, F) {
  e.context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + T) / 6,
    (e._y0 + 4 * e._y1 + C) / 6,
    $,
    e.lastPoint1
  );
}
class Basis$1 {
  constructor(e, T) {
    (this.context = e), (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._y0 = this._y1 = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    2 === this._point &&
      point$7(
        this,
        6 * this._x1 - (this._x0 + 4 * this._x1),
        6 * this._y1 - (this._y0 + 4 * this._y1),
        !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
        this.lastPoint1
      ),
      (this._line || (0 !== this._line && 1 === this._point)) &&
        this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point$7(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._x0 = this._x1),
      (this._x1 = T),
      (this._y0 = this._y1),
      (this._y1 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genBasisTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 2);
}
function genBasisSegments$1(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments$1(e, T);
  const F = genSegContext$1("basis", C, e);
  return genBasisTypeSegments$1(new Basis$1(F, $), e), F;
}
function sign$1(e) {
  return e < 0 ? -1 : 1;
}
function slope3$1(e, T, C) {
  const $ = e._x1 - e._x0,
    F = T - e._x1,
    V = (e._y1 - e._y0) / ($ || Number(F < 0 && -0)),
    Y = (C - e._y1) / (F || Number($ < 0 && -0)),
    K = (V * F + Y * $) / ($ + F);
  return (
    (sign$1(V) + sign$1(Y)) *
      Math.min(Math.abs(V), Math.abs(Y), 0.5 * Math.abs(K)) || 0
  );
}
function slope2$1(e, T) {
  const C = e._x1 - e._x0;
  return C ? ((3 * (e._y1 - e._y0)) / C - T) / 2 : T;
}
function point$6(e, T, C, $, F) {
  const V = e._x0,
    Y = e._y0,
    K = e._x1,
    J = e._y1,
    ee = (K - V) / 3;
  e.context.bezierCurveTo(
    V + ee,
    Y + ee * T,
    K - ee,
    J - ee * C,
    K,
    J,
    $,
    e.lastPoint1
  );
}
class MonotoneX$1 {
  constructor(e, T) {
    (this.context = e), (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(
          this._x1,
          this._y1,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
        break;
      case 3:
        point$6(
          this,
          this._t0,
          slope2$1(this, this._t0),
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
    }
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    let T = NaN;
    const C = e.x,
      $ = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                C,
                $,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
                e
              )
            : this.context.moveTo(C, $, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        (this._point = 3),
          point$6(
            this,
            slope2$1(this, (T = slope3$1(this, C, $))),
            T,
            !1 !== this._lastDefined1 && !1 !== this._lastDefined2
          );
        break;
      default:
        point$6(
          this,
          this._t0,
          (T = slope3$1(this, C, $)),
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._x0 = this._x1),
      (this._x1 = C),
      (this._y0 = this._y1),
      (this._y1 = $),
      (this._t0 = T),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = !1 !== e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
class MonotoneY$1 extends MonotoneX$1 {
  constructor(e, T) {
    super(e, T);
  }
  point(e) {
    return super.point({
      y: e.x,
      x: e.y,
      defined: e.defined,
    });
  }
}
function genMonotoneXTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 2);
}
function genMonotoneXSegments$1(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments$1(e, T);
  const F = genSegContext$1("monotoneX", C, e);
  return genMonotoneXTypeSegments$1(new MonotoneX$1(F, $), e), F;
}
function genMonotoneYTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 2);
}
function genMonotoneYSegments$1(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments$1(e, T);
  const F = genSegContext$1("monotoneY", C, e);
  return genMonotoneYTypeSegments$1(new MonotoneY$1(F, $), e), F;
}
class Step$3 {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this._t = T), (this.startPoint = C);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x = this._y = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t &&
      this._t < 1 &&
      2 === this._point &&
      this.context.lineTo(
        this._x,
        this._y,
        !1 !== this._lastDefined,
        this.lastPoint
      ),
      (this._line || (0 !== this._line && 1 === this._point)) &&
        this.context.closePath(),
      this._line >= 0 &&
        ((this._t = 1 - this._t), (this._line = 1 - this._line));
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined && !1 !== e.defined,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0)
          this.context.lineTo(
            this._x,
            C,
            !1 !== this._lastDefined && !1 !== e.defined,
            this.lastPoint
          ),
            this.context.lineTo(
              T,
              C,
              !1 !== this._lastDefined && !1 !== e.defined,
              e
            );
        else {
          const $ = this._x * (1 - this._t) + T * this._t;
          this.context.lineTo(
            $,
            this._y,
            !1 !== this._lastDefined && !1 !== e.defined,
            this.lastPoint
          ),
            this.context.lineTo(
              $,
              C,
              !1 !== this._lastDefined && !1 !== e.defined,
              e
            );
        }
    }
    (this._lastDefined = e.defined),
      (this._x = T),
      (this._y = C),
      (this.lastPoint = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genStepSegments$1(e, T, C = {}) {
  const { direction: $, startPoint: F } = C;
  if (e.length < 2 - Number(!!F)) return null;
  const V = new SegContext$1(
    "step",
    null != $
      ? $
      : abs$1(e[e.length - 1].x - e[0].x) > abs$1(e[e.length - 1].y - e[0].y)
      ? Direction$1.ROW
      : Direction$1.COLUMN
  );
  return genStepTypeSegments$1(new Step$3(V, T, F), e), V;
}
function genStepTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 1);
}
class LinearClosed$1 extends Linear$1 {
  lineEnd() {
    this.context.closePath();
  }
}
function genLinearClosedSegments$1(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  const F = genSegContext$1("linear", C, e);
  return genLinearClosedTypeSegments$1(new LinearClosed$1(F, $), e), F;
}
function genLinearClosedTypeSegments$1(e, T) {
  return genCurveSegments$1(e, T, 1);
}
function point$5(e, T, C, $, F) {
  let V = e._x1,
    Y = e._y1,
    K = e._x2,
    J = e._y2;
  if (e._l01_a > epsilon$1) {
    const T = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
      C = 3 * e._l01_a * (e._l01_a + e._l12_a);
    (V = (V * T - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / C),
      (Y = (Y * T - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / C);
  }
  if (e._l23_a > epsilon$1) {
    const $ = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
      F = 3 * e._l23_a * (e._l23_a + e._l12_a);
    (K = (K * $ + e._x1 * e._l23_2a - T * e._l12_2a) / F),
      (J = (J * $ + e._y1 * e._l23_2a - C * e._l12_2a) / F);
  }
  e.context.bezierCurveTo(V, Y, K, J, e._x2, e._y2, $, e.lastPoint1);
}
class CatmullRom$1 {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this.startPoint = C), (this._alpha = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(
          this._x2,
          this._y2,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2,
        });
    }
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const { x: T, y: C } = e;
    if (this._point) {
      const e = this._x2 - T,
        $ = this._y2 - C;
      this._l23_a = Math.sqrt(
        (this._l23_2a = Math.pow(e * e + $ * $, this._alpha))
      );
    }
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2
              )
            : this.context.moveTo(T, C);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$5(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = T),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function commonGenCatmullRomSegments$1(e, T) {
  return function (C, $, F = {}) {
    const { direction: V, startPoint: Y } = F;
    if (C.length < 2 - Number(!!Y)) return null;
    if (C.length < 3 - Number(!!Y)) return genLinearSegments$1(C, F);
    const K = genSegContext$1(e, V, C);
    return genCurveSegments$1(new T(K, $, Y), C, 2), K;
  };
}
const genCatmullRomSegments$1 = commonGenCatmullRomSegments$1(
  "catmullRom",
  CatmullRom$1
);
class CatmullRomClosed$1 {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this.startPoint = C), (this._alpha = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0);
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1),
          this.context.closePath();
        break;
      case 2:
        this.context.lineTo(
          this._x3,
          this._y3,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        ),
          this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3,
        }),
          this.point({
            x: this._x4,
            y: this._y4,
          }),
          this.point({
            x: this._x5,
            y: this._y5,
          });
    }
  }
  point(e) {
    const { x: T, y: C } = e;
    if (this._point) {
      const e = this._x2 - T,
        $ = this._y2 - C;
      this._l23_a = Math.sqrt(
        (this._l23_2a = Math.pow(e * e + $ * $, this._alpha))
      );
    }
    switch (this._point) {
      case 0:
        (this._point = 1), (this._x3 = T), (this._y3 = C);
        break;
      case 1:
        (this._point = 2),
          this.context.moveTo((this._x4 = T), (this._y4 = C), e);
        break;
      case 2:
        (this._point = 3), (this._x5 = T), (this._y5 = C);
        break;
      default:
        point$5(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = T),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
const genCatmullRomClosedSegments$1 = commonGenCatmullRomSegments$1(
  "catmullRomClosed",
  CatmullRomClosed$1
);
function calcLineCache$2(e, T, C) {
  var $, F;
  switch (T) {
    case "linear":
    default:
      return genLinearSegments$1(e, C);
    case "basis":
      return genBasisSegments$1(e, C);
    case "monotoneX":
      return genMonotoneXSegments$1(e, C);
    case "monotoneY":
      return genMonotoneYSegments$1(e, C);
    case "step":
      return genStepSegments$1(e, 0.5, C);
    case "stepBefore":
      return genStepSegments$1(e, 0, C);
    case "stepAfter":
      return genStepSegments$1(e, 1, C);
    case "catmullRom":
      return genCatmullRomSegments$1(
        e,
        null !== ($ = null == C ? void 0 : C.curveTension) && void 0 !== $
          ? $
          : 0.5,
        C
      );
    case "catmullRomClosed":
      return genCatmullRomClosedSegments$1(
        e,
        null !== (F = null == C ? void 0 : C.curveTension) && void 0 !== F
          ? F
          : 0.5,
        C
      );
    case "linearClosed":
      return genLinearClosedSegments$1(e, C);
  }
}
class CustomPath2D$1 extends CurvePath$1 {
  constructor(e) {
    super(),
      (this.commandList = []),
      e && (this._ctx = e),
      (this._boundsContext = new BoundsContext$1(this.bounds));
  }
  setCtx(e) {
    this._ctx = e;
  }
  moveTo(e, T) {
    return (
      this.commandList.push([enumCommandMap$1.M, e, T]),
      this._ctx && this._ctx.moveTo(e, T),
      this
    );
  }
  lineTo(e, T) {
    return (
      this.commandList.push([enumCommandMap$1.L, e, T]),
      this._ctx && this._ctx.lineTo(e, T),
      this
    );
  }
  quadraticCurveTo(e, T, C, $) {
    return (
      this.commandList.push([enumCommandMap$1.Q, e, T, C, $]),
      this._ctx && this._ctx.quadraticCurveTo(e, T, C, $),
      this
    );
  }
  bezierCurveTo(e, T, C, $, F, V) {
    return (
      this.commandList.push([enumCommandMap$1.C, e, T, C, $, F, V]),
      this._ctx && this._ctx.bezierCurveTo(e, T, C, $, F, V),
      this
    );
  }
  arcTo(e, T, C, $, F) {
    return (
      this.commandList.push([enumCommandMap$1.AT, e, T, C, $, F]),
      this._ctx && this._ctx.arcTo(e, T, C, $, F),
      this
    );
  }
  ellipse(e, T, C, $, F, V, Y, K) {
    return (
      this.commandList.push([enumCommandMap$1.E, e, T, C, $, F, V, Y, K]),
      this._ctx && this._ctx.ellipse(e, T, C, $, F, V, Y, K),
      this
    );
  }
  rect(e, T, C, $) {
    return (
      this.commandList.push([enumCommandMap$1.R, e, T, C, $]),
      this._ctx && this._ctx.rect(e, T, C, $),
      this
    );
  }
  arc(e, T, C, $, F, V) {
    return (
      this.commandList.push([enumCommandMap$1.A, e, T, C, $, F, V]),
      this._ctx && this._ctx.arc(e, T, C, $, F, V),
      this
    );
  }
  closePath() {
    return (
      this.commandList.push([enumCommandMap$1.Z]),
      this._ctx && this._ctx.closePath(),
      this
    );
  }
  addCurve(e) {
    this.curves.push(e);
  }
  clear() {
    (this.transformCbList = null),
      (this.commandList.length = 0),
      (this.curves.length = 0);
  }
  beginPath() {
    this.clear();
  }
  toString() {
    if (!this.toStringCbList) {
      const e = [];
      (e[enumCommandMap$1.M] = (e) => `M${e[1]} ${e[2]}`),
        (e[enumCommandMap$1.L] = (e) => `L${e[1]} ${e[2]}`),
        (e[enumCommandMap$1.Q] = (e) => `Q${e[1]} ${e[2]} ${e[3]} ${e[4]}`),
        (e[enumCommandMap$1.C] = (e) =>
          `C${e[1]} ${e[2]} ${e[3]} ${e[4]} ${e[5]} ${e[6]}`),
        (e[enumCommandMap$1.A] = (e) => {
          const T = [];
          addArcToBezierPath$2(T, e[4], e[5], e[1], e[2], e[3], e[3]);
          let C = "";
          for (let $ = 0; $ < T.length; $ += 6)
            C += `C${T[$]} ${T[$ + 1]} ${T[$ + 2]} ${T[$ + 3]} ${T[$ + 4]} ${
              T[$ + 5]
            }`;
          return C;
        }),
        (e[enumCommandMap$1.R] = (e) =>
          `M${e[1]} ${e[2]} h${e[3]} v${e[4]} H${e[1]}Z`),
        (e[enumCommandMap$1.Z] = (e) => "Z"),
        (this.toStringCbList = e);
    }
    const e = this.toStringCbList;
    let T = "";
    return (
      this.commandList.forEach((C) => {
        T += e[C[0]](C);
      }),
      T
    );
  }
  fromString(e, T, C, $, F) {
    this.clear();
    const V = parseSvgPath$1(e);
    return this._runCommandStrList(V, T, C, $, F), this._updateBounds(), this;
  }
  fromLine(e) {
    const { points: T, curveType: C, clipRangeByDimension: $ } = e.attribute;
    if (!T) return;
    const F = calcLineCache$2(T, C);
    "x" === $
      ? (this.direction = Direction$1.ROW)
      : "y" === $
      ? (this.direction = Direction$1.COLUMN)
      : "auto" === $ && (this.direction = F.direction),
      (this.curves = F.curves);
  }
  fromCustomPath2D(e, T, C, $, F) {
    return (
      this.clear(),
      this._runCommandList(e.commandList, T, C, $, F),
      this._updateBounds(),
      this
    );
  }
  transform(e, T, C, $) {
    const F = this.commandList;
    if (!this.transformCbList) {
      const e = [];
      (e[enumCommandMap$1.M] = this.moveToTransform),
        (e[enumCommandMap$1.L] = this.lineToTransform),
        (e[enumCommandMap$1.Q] = this.quadraticCurveToTransform),
        (e[enumCommandMap$1.C] = this.bezierCurveToTransform),
        (e[enumCommandMap$1.AT] = this.arcToTransform),
        (e[enumCommandMap$1.E] = this.ellipseTransform),
        (e[enumCommandMap$1.R] = this.rectTransform),
        (e[enumCommandMap$1.A] = this.arcTransform),
        (e[enumCommandMap$1.Z] = this.closePathTransform),
        (this.transformCbList = e);
    }
    F.forEach((F) => {
      this.transformCbList[F[0]](F, e, T, C, $);
    }),
      this._updateBounds();
  }
  moveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C);
  }
  lineToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C);
  }
  quadraticCurveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C);
  }
  bezierCurveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C),
      (e[5] = e[5] * $ + T),
      (e[6] = e[6] * F + C);
  }
  arcToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C),
      (e[5] = (e[5] * ($ + F)) / 2);
  }
  ellipseTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $),
      (e[4] = e[4] * F);
  }
  rectTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $),
      (e[4] = e[4] * F);
  }
  arcTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C), (e[3] = (e[3] * ($ + F)) / 2);
  }
  closePathTransform() {}
  _runCommandStrList(e, T = 0, C = 0, $ = 1, F = 1) {
    let V,
      Y,
      K,
      J,
      ee,
      te = null,
      ie = 0,
      ne = 0,
      re = 0,
      ae = 0;
    for (let oe = 0, se = e.length; oe < se; ++oe) {
      switch (
        ((V = e[oe]), (1 === $ && 1 === F) || (V = scale$2(V, $, F)), V[0])
      ) {
        case "l":
          (ie += V[1]), (ne += V[2]), this.lineTo(ie + T, ne + C);
          break;
        case "L":
          (ie = V[1]), (ne = V[2]), this.lineTo(ie + T, ne + C);
          break;
        case "h":
          (ie += V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "H":
          (ie = V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "v":
          (ne += V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "V":
          (ne = V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "m":
          (ie += V[1]), (ne += V[2]), this.moveTo(ie + T, ne + C);
          break;
        case "M":
          (ie = V[1]), (ne = V[2]), this.moveTo(ie + T, ne + C);
          break;
        case "c":
          (Y = ie + V[5]),
            (K = ne + V[6]),
            (re = ie + V[3]),
            (ae = ne + V[4]),
            this.bezierCurveTo(
              ie + V[1] + T,
              ne + V[2] + C,
              re + T,
              ae + C,
              Y + T,
              K + C
            ),
            (ie = Y),
            (ne = K);
          break;
        case "C":
          (ie = V[5]),
            (ne = V[6]),
            (re = V[3]),
            (ae = V[4]),
            this.bezierCurveTo(
              V[1] + T,
              V[2] + C,
              re + T,
              ae + C,
              ie + T,
              ne + C
            );
          break;
        case "s":
          (Y = ie + V[3]),
            (K = ne + V[4]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.bezierCurveTo(
              re + T,
              ae + C,
              ie + V[1] + T,
              ne + V[2] + C,
              Y + T,
              K + C
            ),
            (re = ie + V[1]),
            (ae = ne + V[2]),
            (ie = Y),
            (ne = K);
          break;
        case "S":
          (Y = V[3]),
            (K = V[4]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.bezierCurveTo(
              re + T,
              ae + C,
              V[1] + T,
              V[2] + C,
              Y + T,
              K + C
            ),
            (ie = Y),
            (ne = K),
            (re = V[1]),
            (ae = V[2]);
          break;
        case "q":
          (Y = ie + V[3]),
            (K = ne + V[4]),
            (re = ie + V[1]),
            (ae = ne + V[2]),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K);
          break;
        case "Q":
          (Y = V[3]),
            (K = V[4]),
            this.quadraticCurveTo(V[1] + T, V[2] + C, Y + T, K + C),
            (ie = Y),
            (ne = K),
            (re = V[1]),
            (ae = V[2]);
          break;
        case "t":
          (Y = ie + V[1]),
            (K = ne + V[2]),
            null === te[0].match(/[QqTt]/)
              ? ((re = ie), (ae = ne))
              : "t" === te[0]
              ? ((re = 2 * ie - J), (ae = 2 * ne - ee))
              : "q" === te[0] && ((re = 2 * ie - re), (ae = 2 * ne - ae)),
            (J = re),
            (ee = ae),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K),
            (re = ie + V[1]),
            (ae = ne + V[2]);
          break;
        case "T":
          (Y = V[1]),
            (K = V[2]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K);
          break;
        case "a":
          drawArc$1(this, ie + T, ne + C, [
            V[1],
            V[2],
            V[3],
            V[4],
            V[5],
            V[6] + ie + T,
            V[7] + ne + C,
          ]),
            (ie += V[6]),
            (ne += V[7]);
          break;
        case "A":
          drawArc$1(this, ie + T, ne + C, [
            V[1],
            V[2],
            V[3],
            V[4],
            V[5],
            V[6] + T,
            V[7] + C,
          ]),
            (ie = V[6]),
            (ne = V[7]);
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      te = V;
    }
  }
  _runCommandList(e, T = 0, C = 0, $ = 1, F = 1) {
    if (0 !== T || 0 !== C || 1 !== $ || 1 !== F)
      for (let V = 0, Y = e.length; V < Y; ++V) {
        const Y = e[V].slice();
        switch (Y[0]) {
          case enumCommandMap$1.L:
            this.lineToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.M:
            this.moveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.C:
            this.bezierCurveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.Q:
            this.quadraticCurveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.A:
            this.arcToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.E:
            this.ellipseTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.R:
            this.rectTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.AT:
            this.arcToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap$1.Z:
            this.closePath();
        }
      }
    else this.commandList = e.map((e) => e.slice());
  }
  _updateBounds() {
    this.bounds.clear(),
      renderCommandList$1(this.commandList, this._boundsContext);
  }
  release() {
    (this.commandList = []), (this._boundsContext = null), (this._ctx = null);
  }
  getLength() {
    if (this.direction === Direction$1.COLUMN) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1];
      return abs$1(e.p0.y - T.p1.y);
    }
    if (this.direction === Direction$1.ROW) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1];
      return abs$1(e.p0.x - T.p1.x);
    }
    return this.curves.reduce((e, T) => e + T.getLength(), 0);
  }
  getAttrAt(e) {
    if (!this.curves)
      return {
        pos: {
          x: 0,
          y: 0,
        },
        angle: 0,
      };
    let T,
      C = 0;
    for (let F = 0; F < this.curves.length; F++) {
      T = this.curves[F];
      const $ = T.getLength(this.direction);
      if (C + $ >= e) break;
      C += $;
    }
    const $ = (e - C) / T.getLength(this.direction);
    return {
      pos: T.getPointAt($),
      angle: T.getAngleAt($),
    };
  }
}
const temp$1 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$2(e, T, C) {
  const $ = (temp$1[0] = e[0]);
  if ("a" === $ || "A" === $)
    (temp$1[1] = T * e[1]),
      (temp$1[2] = C * e[2]),
      (temp$1[3] = e[3]),
      (temp$1[4] = e[4]),
      (temp$1[5] = e[5]),
      (temp$1[6] = T * e[6]),
      (temp$1[7] = C * e[7]);
  else if ("h" === $ || "H" === $) temp$1[1] = T * e[1];
  else if ("v" === $ || "V" === $) temp$1[1] = C * e[1];
  else
    for (let F = 1, V = e.length; F < V; ++F)
      temp$1[F] = (F % 2 == 1 ? T : C) * e[F];
  return temp$1;
}
const DefaultLayout$1 = {
    alignSelf: "auto",
  },
  DefaultTransform$1 = {
    x: 0,
    y: 0,
    z: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    scrollX: 0,
    scrollY: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    angle: 0,
    alpha: 0,
    beta: 0,
    scaleCenter: [0, 0],
    anchor: [0, 0],
    anchor3d: [0, 0],
    postMatrix: new Matrix$1(),
  },
  DefaultFillStyle$1 = {
    fillOpacity: 1,
    fill: !1,
    shadowBlur: 0,
    shadowColor: "black",
    shadowOffsetX: 0,
    shadowOffsetY: 0,
  },
  commonStroke$1 = {
    strokeOpacity: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    strokeBoundsBuffer: 2,
    stroke: !1,
  },
  DefaultStrokeStyle$1 = Object.assign(
    {
      outerBorder: Object.assign(Object.assign({}, commonStroke$1), {
        distance: 0,
      }),
      innerBorder: Object.assign(Object.assign({}, commonStroke$1), {
        distance: 0,
      }),
    },
    commonStroke$1
  ),
  DefaultTextStyle$1 = {
    text: "",
    maxLineWidth: 1 / 0,
    maxWidth: 1 / 0,
    textAlign: "left",
    textBaseline: "alphabetic",
    fontSize: 16,
    fontFamily:
      "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
    fontWeight: "",
    ellipsis: "",
    fontVariant: "",
    fontStyle: "",
    lineHeight: void 0,
    underline: 0,
    lineThrough: 0,
    scaleIn3d: !1,
    direction: "horizontal",
    wordBreak: "break-all",
    ignoreBuf: !1,
    verticalMode: 0,
    wrap: !1,
    whiteSpace: "no-wrap",
    heightLimit: 1 / 0,
    lineClamp: 1 / 0,
    suffixPosition: "end",
    underlineDash: [],
    underlineOffset: 0,
    disableAutoClipedPoptip: void 0,
    measureMode: MeasureModeEnum.fontBounding,
    keepCenterInLine: !1,
  },
  DefaultPickStyle$1 = {
    pickStrokeBuffer: 0,
  },
  DefaultStyle$1 = Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          {
            forceBoundsWidth: void 0,
            forceBoundsHeight: void 0,
            opacity: 1,
            background: null,
            backgroundOpacity: 1,
            backgroundCornerRadius: 0,
            texture: null,
            textureColor: "black",
            textureSize: 10,
            texturePadding: 2,
            backgroundMode: "no-repeat",
            backgroundFit: !0,
            blur: 0,
            cursor: null,
            html: null,
            react: null,
          },
          DefaultFillStyle$1
        ),
        DefaultStrokeStyle$1
      ),
      DefaultLayout$1
    ),
    DefaultPickStyle$1
  ),
  DefaultConnectAttribute$1 = {
    connectedType: "none",
    connectedStyle: {},
    connectedX: NaN,
    connectedY: NaN,
  },
  DefaultDebugAttribute$1 = {
    _debug_bounds: !1,
  },
  DefaultAttribute$1 = Object.assign(
    Object.assign(
      Object.assign(
        {
          strokeSeg: null,
          renderable: !0,
          pickable: !0,
          shadowGraphic: void 0,
          childrenPickable: !0,
          fillPickable: !0,
          strokePickable: !0,
          visible: !0,
          zIndex: 0,
          layout: null,
          boundsPadding: 0,
          fillStrokeOrder: 0,
          renderStyle: "default",
          pickMode: "accurate",
          customPickShape: null,
          boundsMode: "accurate",
          keepDirIn3d: !0,
          shadowRootIdx: 1,
          globalZIndex: 1,
          globalCompositeOperation: "",
          overflow: "hidden",
          shadowPickMode: "graphic",
          keepStrokeScale: !1,
        },
        DefaultDebugAttribute$1
      ),
      DefaultStyle$1
    ),
    DefaultTransform$1
  ),
  DefaultArcAttribute$1 = Object.assign(Object.assign({}, DefaultAttribute$1), {
    startAngle: 0,
    endAngle: pi2$1,
    innerRadius: 0,
    outerRadius: 1,
    innerPadding: 0,
    outerPadding: 0,
    cornerRadius: 0,
    padRadius: 0,
    padAngle: 0,
    cap: !1,
    forceShowCap: !1,
  }),
  DefaultAreaAttribute$1 = Object.assign(
    Object.assign(
      Object.assign({}, DefaultAttribute$1),
      DefaultConnectAttribute$1
    ),
    {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      closePath: !1,
      curveTension: 1,
    }
  ),
  DefaultCircleAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      radius: 1,
      startAngle: 0,
      endAngle: pi2$1,
    }
  ),
  DefaultGroupAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      width: 0,
      height: 0,
      cornerRadius: 0,
      path: [],
      clip: !1,
      visibleAll: !0,
      display: "relative",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-start",
      alignItems: "flex-start",
      alignContent: "flex-start",
      baseOpacity: 1,
    }
  ),
  DefaultGlyphAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      path: "",
      width: 0,
      height: 0,
      cornerRadius: 0,
      clip: !1,
    }
  ),
  DefaultLineAttribute$1 = Object.assign(
    Object.assign(
      Object.assign({}, DefaultAttribute$1),
      DefaultConnectAttribute$1
    ),
    {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      clipRangeByDimension: "default",
      closePath: !1,
      curveTension: 1,
    }
  ),
  DefaultPathAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      path: new CustomPath2D$1(),
      fillStrokeOrder: 1,
      customPath: () => {
        Logger$1.getInstance().warn("");
      },
    }
  ),
  DefaultPolygonAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      points: [],
      cornerRadius: 0,
      closePath: !0,
    }
  ),
  DefaultRectAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      width: 0,
      height: 0,
      x1: 0,
      y1: 0,
      strokeBoundsBuffer: 0,
      cornerRadius: 0,
    }
  );
Object.assign(Object.assign({}, DefaultAttribute$1), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
});
const DefaultSymbolAttribute$1 = Object.assign(
    Object.assign({}, DefaultAttribute$1),
    {
      symbolType: "circle",
      size: 10,
      keepDirIn3d: !0,
    }
  ),
  DefaultTextAttribute$1 = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute$1), DefaultTextStyle$1),
    {
      strokeBoundsBuffer: 0,
      keepDirIn3d: !0,
    }
  ),
  DefaultRichTextAttribute$1 = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute$1), DefaultTextStyle$1),
    {
      editable: !1,
      width: 300,
      height: 300,
      ellipsis: !0,
      wordBreak: "break-word",
      verticalDirection: "top",
      textAlign: "left",
      textBaseline: "top",
      layoutDirection: "horizontal",
      textConfig: [],
      disableAutoWrapLine: !1,
      maxHeight: void 0,
      maxWidth: void 0,
      singleLine: !1,
    }
  ),
  DefaultImageAttribute$1 = Object.assign(
    Object.assign(
      {
        repeatX: "no-repeat",
        repeatY: "no-repeat",
        image: "",
        width: 0,
        height: 0,
      },
      DefaultAttribute$1
    ),
    {
      fill: !0,
      cornerRadius: 0,
    }
  ),
  DefaultRichTextIconAttribute$1 = Object.assign(
    Object.assign({}, DefaultImageAttribute$1),
    {
      backgroundShowMode: "never",
      backgroundWidth: 0,
      backgroundHeight: 0,
      textAlign: "left",
      textBaseline: "middle",
      direction: "horizontal",
      margin: 0,
      id: "",
      width: 20,
      height: 20,
      backgroundFill: "rgba(101, 117, 168, 0.1)",
      backgroundFillOpacity: 1,
      backgroundStroke: !1,
      backgroundStrokeOpacity: 1,
      backgroundRadius: 4,
      opacity: 1,
    }
  );
class Application$1 {}
const application$1 = new Application$1(),
  defaultThemeObj$1 = {
    arc: DefaultArcAttribute$1,
    area: DefaultAreaAttribute$1,
    circle: DefaultCircleAttribute$1,
    line: DefaultLineAttribute$1,
    path: DefaultPathAttribute$1,
    symbol: DefaultSymbolAttribute$1,
    text: DefaultTextAttribute$1,
    rect: DefaultRectAttribute$1,
    polygon: DefaultPolygonAttribute$1,
    richtext: DefaultRichTextAttribute$1,
    richtextIcon: DefaultRichTextIconAttribute$1,
    image: DefaultImageAttribute$1,
    group: DefaultGroupAttribute$1,
    glyph: DefaultGlyphAttribute$1,
  },
  themeKeys$1 = Object.keys(defaultThemeObj$1);
function newThemeObj$1() {
  return {
    arc: Object.assign({}, defaultThemeObj$1.arc),
    area: Object.assign({}, defaultThemeObj$1.area),
    circle: Object.assign({}, defaultThemeObj$1.circle),
    line: Object.assign({}, defaultThemeObj$1.line),
    path: Object.assign({}, defaultThemeObj$1.path),
    symbol: Object.assign({}, defaultThemeObj$1.symbol),
    text: Object.assign({}, defaultThemeObj$1.text),
    rect: Object.assign({}, defaultThemeObj$1.rect),
    polygon: Object.assign({}, defaultThemeObj$1.polygon),
    richtext: Object.assign({}, defaultThemeObj$1.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj$1.richtextIcon),
    image: Object.assign({}, defaultThemeObj$1.image),
    group: Object.assign({}, defaultThemeObj$1.group),
    glyph: Object.assign({}, defaultThemeObj$1.glyph),
  };
}
function combine$1(e, T) {
  Object.keys(T).forEach((C) => {
    e[C] = T[C];
  });
}
const globalThemeObj$1 = newThemeObj$1();
class Theme$1 {
  constructor() {
    this.initTheme(), (this.dirty = !1);
  }
  initTheme() {
    (this._defaultTheme = {}),
      themeKeys$1.forEach((e) => {
        this._defaultTheme[e] = Object.create(globalThemeObj$1[e]);
      }),
      (this.combinedTheme = this._defaultTheme);
  }
  getTheme(e) {
    if (!e) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let T = {};
    const C = this.getParentWithTheme(e);
    return C && (T = C.theme), this.applyTheme(e, T), this.combinedTheme;
  }
  getParentWithTheme(e) {
    for (; e.parent; ) if ((e = e.parent).theme) return e;
    return null;
  }
  applyTheme(e, T, C = !1) {
    if (this.dirty) {
      const $ = this.getParentWithTheme(e);
      if ($) {
        const e = $.theme;
        (e.dirty || C) && e.applyTheme($, T, !0);
      }
      this.userTheme
        ? this.doCombine($ && $.theme.combinedTheme)
        : ($
            ? (this.combinedTheme = $.theme.combinedTheme)
            : ((this.combinedTheme = this._defaultTheme),
              Logger$1.getInstance().warn("")),
          (this.dirty = !1));
    }
    return this.combinedTheme;
  }
  doCombine(e) {
    const T = this.userTheme,
      C = this.combinedTheme;
    themeKeys$1.forEach(($) => {
      const F = Object.create(globalThemeObj$1[$]);
      e && e[$] && combine$1(F, e[$]),
        C[$] && combine$1(F, C[$]),
        T[$] && combine$1(F, T[$]),
        (this.combinedTheme[$] = F);
    }),
      T.common &&
        themeKeys$1.forEach((e) => {
          combine$1(this.combinedTheme[e], T.common);
        }),
      (this.dirty = !1);
  }
  setTheme(e, T) {
    let C = this.userTheme;
    C
      ? Object.keys(e).forEach((T) => {
          C[T] ? Object.assign(C[T], e[T]) : (C[T] = Object.assign({}, e[T]));
        })
      : (C = e),
      (this.userTheme = C),
      (this.dirty = !0),
      this.dirtyChildren(T);
  }
  resetTheme(e, T) {
    (this.userTheme = e), (this.dirty = !0), this.dirtyChildren(T);
  }
  dirtyChildren(e) {
    e.forEachChildren((e) => {
      e.isContainer && (e.theme && (e.theme.dirty = !0), this.dirtyChildren(e));
    });
  }
}
const globalTheme$1 = new Theme$1();
function getTheme$1(e, T) {
  return e.glyphHost
    ? getTheme$1(e.glyphHost)
    : T
    ? (e.isContainer, T)
    : getThemeFromGroup$1(e) ||
      (e.attachedThemeGraphic && getTheme$1(e.attachedThemeGraphic)) ||
      globalTheme$1.getTheme();
}
function getThemeFromGroup$1(e) {
  let T;
  if (((T = e.isContainer ? e : e.parent), T)) {
    for (; T && !T.theme; ) T = T.parent;
    return T
      ? (T.theme || T.createTheme(), T.theme.getTheme(T))
      : globalTheme$1.getTheme();
  }
  return null;
}
var __awaiter$3 =
  (globalThis && globalThis.__awaiter) ||
  function (e, T, C, $) {
    return new (C || (C = Promise))(function (F, V) {
      function Y(e) {
        try {
          J($.next(e));
        } catch (T) {
          V(T);
        }
      }
      function K(e) {
        try {
          J($.throw(e));
        } catch (T) {
          V(T);
        }
      }
      function J(e) {
        var T;
        e.done
          ? F(e.value)
          : ((T = e.value),
            T instanceof C
              ? T
              : new C(function (e) {
                  e(T);
                })).then(Y, K);
      }
      J(($ = $.apply(e, T || [])).next());
    });
  };
class Node$1 extends EventEmitter {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(),
      (this._uid = Generator$1.GenAutoIncrementId()),
      (this._firstChild = null),
      (this._lastChild = null),
      (this.parent = null),
      (this._count = 1);
  }
  forEachChildren(e, T = !1) {
    if (T) {
      let T = this._lastChild,
        C = 0;
      for (; T; ) {
        if (e(T, C++)) return;
        T = T._prev;
      }
    } else {
      let T = this._firstChild,
        C = 0;
      for (; T; ) {
        if (e(T, C++)) return;
        T = T._next;
      }
    }
  }
  forEachChildrenAsync(e, T = !1) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (T) {
        let T = this._lastChild,
          C = 0;
        for (; T; ) {
          let $ = e(T, C++);
          if (($.then && ($ = yield $), $)) return;
          T = T._prev;
        }
      } else {
        let T = this._firstChild,
          C = 0;
        for (; T; ) {
          let $ = e(T, C++);
          if (($.then && ($ = yield $), $)) return;
          T = T._next;
        }
      }
    });
  }
  forEach(e) {
    return this.forEachChildren(e);
  }
  appendChild(e, T = !0) {
    if (this._uid === e._uid) return null;
    if (!T && e.isAncestorsOf(this))
      throw new Error("Node::appendChildappend");
    return (
      e.parent && e.parent.removeChild(e),
      (e.parent = this),
      this._lastChild
        ? ((this._lastChild._next = e),
          (e._prev = this._lastChild),
          (this._lastChild = e))
        : ((this._firstChild = this._lastChild = e),
          (e._prev = e._next = null)),
      this._idMap || (this._idMap = new Map()),
      this._idMap.set(e._uid, e),
      this.setCount(e.count),
      (this._structEdit = !0),
      e
    );
  }
  appendChildArrHighPerformance(e, T = !1) {
    return console.error(""), e;
  }
  insertBefore(e, T) {
    if (!T) return this.appendChild(e);
    if (this === e || e === T) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertBeforeinsert");
    return T.parent !== this
      ? null
      : (e.parent && e.parent.removeChild(e),
        (e.parent = this),
        (e._prev = T._prev),
        T._prev ? (T._prev._next = e) : (this._firstChild = e),
        (T._prev = e),
        (e._next = T),
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(e._uid, e),
        (this._structEdit = !0),
        this.setCount(e.count),
        e);
  }
  insertAfter(e, T) {
    if (!T) return this.appendChild(e);
    if (this === e || e === T) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertAfterinsert");
    return T.parent !== this
      ? null
      : (e.parent && e.parent.removeChild(e),
        (e.parent = this),
        T._next
          ? ((T._next._prev = e), (e._next = T._next))
          : (this._lastChild = e),
        (T._next = e),
        (e._prev = T),
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(e._uid, e),
        (this._structEdit = !0),
        this.setCount(e.count),
        e);
  }
  insertInto(e, T) {
    if (
      (!this._ignoreWarn &&
        this._nodeList &&
        Logger$1.getInstance().warn(
          "insertIntoKeepIdxinsertInto"
        ),
      T >= this.childrenCount)
    )
      return this.appendChild(e);
    if (this === e) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertBeforeinsert");
    if ((e.parent && e.parent.removeChild(e), (e.parent = this), 0 === T))
      (e._next = this._firstChild),
        this._firstChild && (this._firstChild._prev = e),
        (e._prev = null),
        (this._firstChild = e);
    else {
      let C = this._firstChild;
      for (let e = 0; e < T; e++) {
        if (!C) return null;
        e > 0 && (C = C._next);
      }
      if (!C) return null;
      (e._next = C._next),
        (e._prev = C),
        (C._next = e),
        e._next && (e._next._prev = e);
    }
    return (
      this._idMap || (this._idMap = new Map()),
      this._idMap.set(e._uid, e),
      (this._structEdit = !0),
      this.setCount(e.count),
      e
    );
  }
  insertIntoKeepIdx(e, T) {
    if (
      (this._nodeList || (this._nodeList = this.children), this._nodeList[T])
    ) {
      const C = this._nodeList[T];
      return this._nodeList.splice(T, 0, e), this.insertBefore(e, C);
    }
    let C;
    this._nodeList[T] = e;
    for (let F = T - 1; F >= 0 && ((C = this._nodeList[F]), !C); F--);
    if (C) return C._next ? this.insertBefore(e, C._next) : this.appendChild(e);
    this._ignoreWarn = !0;
    const $ = this.insertInto(e, 0);
    return (this._ignoreWarn = !1), $;
  }
  removeChild(e) {
    if (!this._idMap) return null;
    if (!this._idMap.has(e._uid)) return null;
    if ((this._idMap.delete(e._uid), this._nodeList)) {
      const T = this._nodeList.findIndex((T) => T === e);
      T >= 0 && this._nodeList.splice(T, 1);
    }
    return (
      e._prev ? (e._prev._next = e._next) : (this._firstChild = e._next),
      e._next ? (e._next._prev = e._prev) : (this._lastChild = e._prev),
      (e.parent = null),
      (e._prev = null),
      (e._next = null),
      (this._structEdit = !0),
      this.setCount(-e.count),
      e
    );
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(e) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let T = this._firstChild;
    for (; T; ) {
      const e = T._next;
      (T.parent = null),
        (T._prev = null),
        (T._next = null),
        (T = T._next),
        (T = e);
    }
    (this._firstChild = null),
      (this._lastChild = null),
      this._idMap.clear(),
      (this._structEdit = !0),
      this.setCount(1 - this._count);
  }
  replaceChild(e, T) {
    throw new Error("");
  }
  find(e, T = !1) {
    let C = null;
    return (
      this.forEachChildren((T, $) => !(T === this || !e(T, $) || ((C = T), 0))),
      T &&
        this.forEachChildren((T) => {
          if (T.isContainer) {
            const $ = T.find(e, !0);
            if ($) return (C = $), !0;
          }
          return !1;
        }),
      C
    );
  }
  findAll(e, T = !1) {
    let C = [];
    return (
      this.forEachChildren((T, $) => {
        T !== this && e(T, $) && C.push(T);
      }),
      T &&
        this.forEachChildren((T) => {
          if (T.isContainer) {
            const $ = T.findAll(e, !0);
            $.length && (C = C.concat($));
          }
        }),
      C
    );
  }
  getElementById(e) {
    return this.find((T) => T.id === e, !0);
  }
  findChildById(e) {
    return this.getElementById(e);
  }
  findChildByUid(e) {
    return (this._idMap && this._idMap.get(e)) || null;
  }
  getElementsByName(e) {
    return this.findAll((T) => T.name === e, !0);
  }
  findChildrenByName(e) {
    return this.getElementsByName(e);
  }
  getElementsByType(e) {
    return this.findAll((T) => T.type === e, !0);
  }
  getChildByName(e, T = !1) {
    return this.find((T) => T.name === e, T);
  }
  getChildAt(e) {
    let T = this._firstChild;
    if (!T) return null;
    for (let C = 0; C < e; C++) {
      if (!T._next) return null;
      T = T._next;
    }
    return T;
  }
  at(e) {
    return this.getChildAt(e);
  }
  containNode(e) {
    if (!this._idMap) return !1;
    if (this._idMap.has(e._uid)) return !0;
    let T = this._firstChild;
    for (; T; ) {
      if (T.containNode(e)) return !0;
      T = T._next;
    }
    return !1;
  }
  getRootNode() {
    let e = this.parent;
    for (; null == e ? void 0 : e.parent; ) e = e.parent;
    return e || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(e) {
    return this.appendChild(e);
  }
  add(e) {
    return this.appendChild(e);
  }
  getChildren() {
    const e = [];
    let T = this._firstChild;
    for (; T; ) e.push(T), (T = T._next);
    return e;
  }
  isChildOf(e) {
    return !!this.parent && this.parent._uid === e._uid;
  }
  isParentOf(e) {
    return e.isChildOf(this);
  }
  isDescendantsOf(e) {
    let T = this.parent;
    if (!T) return !1;
    do {
      if (T._uid === e._uid) return !0;
      T = T.parent;
    } while (null !== T);
    return !1;
  }
  isAncestorsOf(e) {
    return e.isDescendantsOf(this);
  }
  getAncestor(e) {
    throw new Error("");
  }
  setAllDescendantsProps(e, T) {
    let C = this._firstChild;
    for (; C; ) (C[e] = T), C.setAllDescendantsProps(e, T), (C = C._next);
  }
  setCount(e) {
    this._count += e;
    let T = this.parent;
    if (T)
      do {
        (T._count += e), (T = T.parent);
      } while (null !== T);
  }
  clone() {
    throw new Error("");
  }
  cloneTo(e) {
    throw new Error("");
  }
  getParent() {
    return this.parent;
  }
  del(e) {
    return this.removeChild(e);
  }
  addEventListener(e, T, C) {
    const $ = (isBoolean$2(C, !0) && C) || (isObject$2(C) && C.capture),
      F = isObject$2(C) && C.once,
      V = isFunction$2(T) ? void 0 : T;
    return (
      (e = $ ? `${e}capture` : e),
      (T = isFunction$2(T) ? T : T.handleEvent),
      F ? super.once(e, T, V) : super.on(e, T, V),
      this
    );
  }
  on(e, T, C) {
    return this.addEventListener(e, T, C);
  }
  removeEventListener(e, T, C) {
    const $ = (isBoolean$2(C, !0) && C) || (isObject$2(C) && C.capture),
      F = isFunction$2(T) ? void 0 : T;
    (e = $ ? `${e}capture` : e), (T = isFunction$2(T) ? T : T.handleEvent);
    const V = isObject$2(C) && C.once;
    return super.off(e, T, F, V), this;
  }
  off(e, T, C) {
    return this.removeEventListener(e, T, C);
  }
  once(e, T, C) {
    return isObject$2(C)
      ? ((C.once = !0), this.addEventListener(e, T, C))
      : this.addEventListener(e, T, {
          once: !0,
        });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(e, ...T) {
    return super.emit(e.type, e, ...T), !e.defaultPrevented;
  }
  emit(e, T) {
    return this.dispatchEvent(e, T);
  }
  release() {
    this.removeAllListeners();
  }
}
class FederatedEvent$1 {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(e) {
    (this.bubbles = !0),
      (this.cancelBubble = !0),
      (this.cancelable = !1),
      (this.composed = !1),
      (this.defaultPrevented = !1),
      (this.eventPhase = FederatedEvent$1.prototype.NONE),
      (this.propagationStopped = !1),
      (this.propagationImmediatelyStopped = !1),
      (this.layer = {
        x: 0,
        y: 0,
      }),
      (this.page = {
        x: 0,
        y: 0,
      }),
      (this.canvas = {
        x: 0,
        y: 0,
      }),
      (this.viewport = {
        x: 0,
        y: 0,
      }),
      (this.NONE = 0),
      (this.CAPTURING_PHASE = 1),
      (this.AT_TARGET = 2),
      (this.BUBBLING_PHASE = 3),
      (this.manager = e);
  }
  composedPath() {
    return (
      !this.manager ||
        (this.path && this.path[this.path.length - 1] === this.target) ||
        (this.path = this.target
          ? this.manager.propagationPath(this.target)
          : []),
      this.composedDetailPath(),
      this.path
    );
  }
  composedDetailPath() {
    return (
      this.pickParams && this.pickParams.graphic
        ? ((this.detailPath = this.path.slice()),
          this._composedDetailPath(this.pickParams))
        : (this.detailPath = this.path.slice()),
      this.detailPath
    );
  }
  _composedDetailPath(e) {
    if (e && e.graphic) {
      const T = this.pickParams.graphic;
      if (T.stage) {
        const C = T.stage.eventSystem.manager.propagationPath(T);
        this.detailPath.push(C), this._composedDetailPath(e.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.preventDefault();
    } catch (e) {
      this.nativeEvent.preventDefault &&
        isFunction$2(this.nativeEvent.preventDefault) &&
        this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = !0;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.stopPropagation();
    } catch (e) {
      this.nativeEvent.stopPropagation &&
        isFunction$2(this.nativeEvent.stopPropagation) &&
        this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = !0;
  }
  initEvent() {}
  initUIEvent() {}
  clone() {
    throw new Error("Method not implemented.");
  }
}
class CustomEvent$1 extends FederatedEvent$1 {
  constructor(e, T) {
    super(), (this.type = e), (this.detail = T);
  }
}
const EventTarget$1 = {
  dispatchEvent(e) {
    var T;
    if (!(e instanceof FederatedEvent$1))
      throw new Error(
        "DisplayObject cannot propagate events outside of the Federated Events API"
      );
    return (
      (e.defaultPrevented = !1),
      (e.path = []),
      e.detailPath && (e.detailPath = []),
      (e.target = this),
      null === (T = null == e ? void 0 : e.manager) ||
        void 0 === T ||
        T.dispatchEvent(e),
      !e.defaultPrevented
    );
  },
  emit(e, T) {
    return this.dispatchEvent(new CustomEvent$1(e, T));
  },
};
class Easing$1 {
  constructor() {}
  static linear(e) {
    return e;
  }
  static none() {
    return this.linear;
  }
  static get(e) {
    return (
      e < -1 ? (e = -1) : e > 1 && (e = 1),
      function (T) {
        return 0 === e
          ? T
          : e < 0
          ? T * (T * -e + 1 + e)
          : T * ((2 - T) * e + (1 - e));
      }
    );
  }
  static getPowIn(e) {
    return function (T) {
      return Math.pow(T, e);
    };
  }
  static getPowOut(e) {
    return function (T) {
      return 1 - Math.pow(1 - T, e);
    };
  }
  static getPowInOut(e) {
    return function (T) {
      return (T *= 2) < 1
        ? 0.5 * Math.pow(T, e)
        : 1 - 0.5 * Math.abs(Math.pow(2 - T, e));
    };
  }
  static getBackIn(e) {
    return function (T) {
      return T * T * ((e + 1) * T - e);
    };
  }
  static getBackOut(e) {
    return function (T) {
      return --T * T * ((e + 1) * T + e) + 1;
    };
  }
  static getBackInOut(e) {
    return (
      (e *= 1.525),
      function (T) {
        return (T *= 2) < 1
          ? T * T * ((e + 1) * T - e) * 0.5
          : 0.5 * ((T -= 2) * T * ((e + 1) * T + e) + 2);
      }
    );
  }
  static sineIn(e) {
    return 1 - Math.cos((e * Math.PI) / 2);
  }
  static sineOut(e) {
    return Math.sin((e * Math.PI) / 2);
  }
  static sineInOut(e) {
    return -(Math.cos(Math.PI * e) - 1) / 2;
  }
  static expoIn(e) {
    return 0 === e ? 0 : Math.pow(2, 10 * e - 10);
  }
  static expoOut(e) {
    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e);
  }
  static expoInOut(e) {
    return 0 === e
      ? 0
      : 1 === e
      ? 1
      : e < 0.5
      ? Math.pow(2, 20 * e - 10) / 2
      : (2 - Math.pow(2, -20 * e + 10)) / 2;
  }
  static circIn(e) {
    return -(Math.sqrt(1 - e * e) - 1);
  }
  static circOut(e) {
    return Math.sqrt(1 - --e * e);
  }
  static circInOut(e) {
    return (e *= 2) < 1
      ? -0.5 * (Math.sqrt(1 - e * e) - 1)
      : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  }
  static bounceOut(e) {
    return e < 1 / 2.75
      ? 7.5625 * e * e
      : e < 2 / 2.75
      ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
      : e < 2.5 / 2.75
      ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
      : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  }
  static bounceIn(e) {
    return 1 - Easing$1.bounceOut(1 - e);
  }
  static bounceInOut(e) {
    return e < 0.5
      ? 0.5 * Easing$1.bounceIn(2 * e)
      : 0.5 * Easing$1.bounceOut(2 * e - 1) + 0.5;
  }
  static getElasticIn(e, T) {
    return function (C) {
      if (0 === C || 1 === C) return C;
      const $ = (T / pi2$1) * Math.asin(1 / e);
      return -e * Math.pow(2, 10 * (C -= 1)) * Math.sin(((C - $) * pi2$1) / T);
    };
  }
  static getElasticOut(e, T) {
    return function (C) {
      if (0 === C || 1 === C) return C;
      const $ = (T / pi2$1) * Math.asin(1 / e);
      return e * Math.pow(2, -10 * C) * Math.sin(((C - $) * pi2$1) / T) + 1;
    };
  }
  static getElasticInOut(e, T) {
    return function (C) {
      const $ = (T / pi2$1) * Math.asin(1 / e);
      return (C *= 2) < 1
        ? e *
            Math.pow(2, 10 * (C -= 1)) *
            Math.sin(((C - $) * pi2$1) / T) *
            -0.5
        : e *
            Math.pow(2, -10 * (C -= 1)) *
            Math.sin(((C - $) * pi2$1) / T) *
            0.5 +
            1;
    };
  }
}
(Easing$1.quadIn = Easing$1.getPowIn(2)),
  (Easing$1.quadOut = Easing$1.getPowOut(2)),
  (Easing$1.quadInOut = Easing$1.getPowInOut(2)),
  (Easing$1.cubicIn = Easing$1.getPowIn(3)),
  (Easing$1.cubicOut = Easing$1.getPowOut(3)),
  (Easing$1.cubicInOut = Easing$1.getPowInOut(3)),
  (Easing$1.quartIn = Easing$1.getPowIn(4)),
  (Easing$1.quartOut = Easing$1.getPowOut(4)),
  (Easing$1.quartInOut = Easing$1.getPowInOut(4)),
  (Easing$1.quintIn = Easing$1.getPowIn(5)),
  (Easing$1.quintOut = Easing$1.getPowOut(5)),
  (Easing$1.quintInOut = Easing$1.getPowInOut(5)),
  (Easing$1.backIn = Easing$1.getBackIn(1.7)),
  (Easing$1.backOut = Easing$1.getBackOut(1.7)),
  (Easing$1.backInOut = Easing$1.getBackInOut(1.7)),
  (Easing$1.elasticIn = Easing$1.getElasticIn(1, 0.3)),
  (Easing$1.elasticOut = Easing$1.getElasticOut(1, 0.3)),
  (Easing$1.elasticInOut = Easing$1.getElasticInOut(1, 0.3 * 1.5));
class DefaultTimeline$1 {
  constructor() {
    (this.id = Generator$1.GenAutoIncrementId()),
      (this.animateHead = null),
      (this.animateTail = null),
      (this.animateCount = 0),
      (this.paused = !1);
  }
  addAnimate(e) {
    this.animateTail
      ? ((this.animateTail.nextAnimate = e),
        (e.prevAnimate = this.animateTail),
        (this.animateTail = e),
        (e.nextAnimate = null))
      : ((this.animateHead = e), (this.animateTail = e)),
      this.animateCount++;
  }
  pause() {
    this.paused = !0;
  }
  resume() {
    this.paused = !1;
  }
  tick(e) {
    if (this.paused) return;
    let T = this.animateHead;
    for (this.animateCount = 0; T; )
      T.status === AnimateStatus$1.END
        ? this.removeAnimate(T)
        : T.status === AnimateStatus$1.RUNNING ||
          T.status === AnimateStatus$1.INITIAL
        ? (this.animateCount++, T.advance(e))
        : T.status === AnimateStatus$1.PAUSED && this.animateCount++,
        (T = T.nextAnimate);
  }
  clear() {
    let e = this.animateHead;
    for (; e; ) e.release(), (e = e.nextAnimate);
    (this.animateHead = null),
      (this.animateTail = null),
      (this.animateCount = 0);
  }
  removeAnimate(e, T = !0) {
    e._onRemove && e._onRemove.forEach((e) => e()),
      e === this.animateHead
        ? ((this.animateHead = e.nextAnimate),
          e === this.animateTail
            ? (this.animateTail = null)
            : (this.animateHead.prevAnimate = null))
        : e === this.animateTail
        ? ((this.animateTail = e.prevAnimate),
          (this.animateTail.nextAnimate = null))
        : ((e.prevAnimate.nextAnimate = e.nextAnimate),
          (e.nextAnimate.prevAnimate = e.prevAnimate)),
      T && e.release();
  }
}
const defaultTimeline$1 = new DefaultTimeline$1();
class ACustomAnimate$1 {
  constructor(e, T, C, $, F) {
    (this.from = e),
      (this.to = T),
      (this.duration = C),
      (this.easing = $),
      (this.params = F),
      (this.updateCount = 0);
  }
  bind(e, T) {
    (this.target = e), (this.subAnimate = T), this.onBind();
  }
  onBind() {}
  onFirstRun() {}
  onStart() {}
  onEnd() {}
  getEndProps() {
    return this.to;
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var e;
    const T = this.getEndProps();
    return T
      ? this._endProps === T
        ? this._mergedEndProps
        : ((this._endProps = T),
          void (this._mergedEndProps = Object.assign(
            {},
            null !== (e = this.step.prev.getLastProps()) && void 0 !== e
              ? e
              : {},
            T
          )))
      : this.step.prev
      ? this.step.prev.getLastProps()
      : T;
  }
  update(e, T, C) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const e = this.step.getLastProps();
      Object.keys(e).forEach((T) => {
        this.subAnimate.animate.validAttr(T) && (C[T] = e[T]);
      });
    }
    (this.updateCount += 1), this.onUpdate(e, T, C), e && this.onEnd();
  }
}
class CbAnimate$1 extends ACustomAnimate$1 {
  constructor(e) {
    super(null, null, 0, "linear"), (this.cb = e);
  }
  onUpdate(e, T, C) {}
  onStart() {
    this.cb();
  }
}
class Animate$1 {
  constructor(e = Generator$1.GenAutoIncrementId(), T = defaultTimeline$1, C) {
    (this.id = e),
      (this.timeline = T),
      (this.status = AnimateStatus$1.INITIAL),
      (this.tailAnimate = new SubAnimate$1(this)),
      (this.subAnimates = [this.tailAnimate]),
      (this.timeScale = 1),
      (this.rawPosition = -1),
      (this._startTime = 0),
      (this._duringTime = 0),
      this.timeline.addAnimate(this),
      (this.slience = C);
  }
  setTimeline(e) {
    e !== this.timeline &&
      (this.timeline.removeAnimate(this, !1), e.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((e, T) => e + T.totalDuration, 0);
  }
  after(e) {
    const T = e.getDuration();
    return (this._startTime = T), this;
  }
  afterAll(e) {
    let T = -1 / 0;
    return (
      e.forEach((e) => {
        T = max$1(e.getDuration(), T);
      }),
      (this._startTime = T),
      this
    );
  }
  parallel(e) {
    return (this._startTime = e.getStartTime()), this;
  }
  static AddInterpolate(e, T) {
    Animate$1.interpolateMap.set(e, T);
  }
  play(e) {
    if ((this.tailAnimate.play(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return (
      1 === this.subAnimates.length &&
        this.tailAnimate.totalDuration === e.duration &&
        this.trySetAttribute(e.getFromProps(), e.mode),
      this
    );
  }
  trySetAttribute(e, T = Animate$1.mode) {
    e &&
      T & AnimateMode$1.SET_ATTR_IMMEDIATELY &&
      this.target.setAttributes &&
      this.target.setAttributes(e, !1, {
        type: AttributeUpdateType$1.ANIMATE_PLAY,
      });
  }
  runCb(e) {
    const T = new CbAnimate$1(() => {
      e(this, T.step.prev);
    });
    return this.tailAnimate.play(T), this;
  }
  customInterpolate(e, T, C, $, F, V) {
    const Y =
      Animate$1.interpolateMap.get(e) || Animate$1.interpolateMap.get("");
    return !!Y && Y(e, T, C, $, F, V);
  }
  pause() {
    this.status === AnimateStatus$1.RUNNING &&
      (this.status = AnimateStatus$1.PAUSED);
  }
  resume() {
    this.status === AnimateStatus$1.PAUSED &&
      (this.status = AnimateStatus$1.RUNNING);
  }
  to(e, T, C, $) {
    if ((this.tailAnimate.to(e, T, C, $), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  from(e, T, C, $) {
    if ((this.tailAnimate.from(e, T, C, $), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  wait(e) {
    if ((this.tailAnimate.wait(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  startAt(e) {
    if ((this.tailAnimate.startAt(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  loop(e) {
    if (((this.tailAnimate.loop = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  reversed(e) {
    if (((this.tailAnimate.reversed = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  bounce(e) {
    if (((this.tailAnimate.bounce = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const e = new SubAnimate$1(this, this.tailAnimate);
    return (
      (this.tailAnimate = e),
      this.subAnimates.push(e),
      e.bind(this.target),
      this
    );
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(e) {
    this._preventAttrs && this._preventAttrs.delete(e);
  }
  preventAttr(e) {
    this._preventAttrs || (this._preventAttrs = new Set()),
      this._preventAttrs.add(e);
  }
  preventAttrs(e) {
    e.forEach((e) => this.preventAttr(e));
  }
  validAttr(e) {
    return !this._preventAttrs || !this._preventAttrs.has(e);
  }
  bind(e) {
    return (
      (this.target = e),
      this.target.onAnimateBind &&
        !this.slience &&
        this.target.onAnimateBind(this),
      this.subAnimates.forEach((T) => {
        T.bind(e);
      }),
      this
    );
  }
  advance(e) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + e * this.timeScale < this._startTime)
        return void (this._duringTime += e * this.timeScale);
      (e = this._duringTime + e * this.timeScale - this._startTime),
        (this._duringTime = this._startTime);
    }
    this.status === AnimateStatus$1.INITIAL &&
      ((this.status = AnimateStatus$1.RUNNING),
      this._onStart && this._onStart.forEach((e) => e())),
      this.setPosition(Math.max(this.rawPosition, 0) + e * this.timeScale) &&
        this.status === AnimateStatus$1.RUNNING &&
        ((this.status = AnimateStatus$1.END),
        this._onEnd && this._onEnd.forEach((e) => e()));
  }
  setPosition(e) {
    let T,
      C = 0;
    const $ = this.rawPosition,
      F = this.subAnimates.reduce((e, T) => e + T.totalDuration, 0);
    e < 0 && (e = 0);
    const V = e >= F;
    if ((V && (e = F), e === $)) return V;
    for (
      let Y = 0;
      Y < this.subAnimates.length &&
      ((T = this.subAnimates[Y]), !(C + T.totalDuration >= e));
      Y++
    )
      (C += T.totalDuration), (T = void 0);
    return (this.rawPosition = e), T.setPosition(e - C), V;
  }
  onStart(e) {
    this._onStart || (this._onStart = []), this._onStart.push(e);
  }
  onEnd(e) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(e);
  }
  onRemove(e) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(e);
  }
  onFrame(e) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(e);
  }
  release() {
    this.status = AnimateStatus$1.END;
  }
  stop(e) {
    e || this.target.onStop(),
      "start" === e
        ? this.target.onStop(this.getStartProps())
        : "end" === e
        ? this.target.onStop(this.getEndProps())
        : this.target.onStop(e),
      this.release();
  }
}
(Animate$1.mode = AnimateMode$1.NORMAL), (Animate$1.interpolateMap = new Map());
class SubAnimate$1 {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(e, T) {
    (this.rawPosition = -1),
      (this.position = 0),
      (this.loop = 0),
      (this.duration = 0),
      (this.animate = e),
      (this.stepHead = new Step$2(
        0,
        0,
        T ? Object.assign({}, T.stepTail.props) : {}
      )),
      (this.stepTail = this.stepHead),
      (this.dirty = !0),
      (this._startAt = 0);
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(e) {
    return (this.target = e), this;
  }
  play(e) {
    let T = e.duration;
    (null == T || T < 0) && (T = 0);
    const C = e.easing,
      $ = "string" == typeof C ? Easing$1[C] : C,
      F = this._addStep(T, null, $);
    return (
      (F.type = AnimateStepType$1.customAnimate),
      this._appendProps(e.getEndProps(), F, !1),
      this._appendCustomAnimate(e, F),
      this
    );
  }
  to(e, T, C, $) {
    (null == T || T < 0) && (T = 0);
    const F = "string" == typeof C ? Easing$1[C] : C,
      V = this._addStep(T, null, F);
    return (
      (V.type = AnimateStepType$1.to),
      this._appendProps(e, V, !!$ && $.tempProps),
      V.propKeys || (V.propKeys = Object.keys(V.props)),
      ($ && $.noPreventAttrs) ||
        this.target.animates.forEach((e) => {
          e.id !== this.animate.id && e.preventAttrs(V.propKeys);
        }),
      this
    );
  }
  from(e, T, C, $) {
    this.to(e, 0, C, $);
    const F = {};
    this.stepTail.propKeys ||
      (this.stepTail.propKeys = Object.keys(this.stepTail.props)),
      this.stepTail.propKeys.forEach((e) => {
        F[e] = this.getLastPropByName(e, this.stepTail);
      }),
      this.to(F, T, C, $),
      (this.stepTail.type = AnimateStepType$1.from);
  }
  startAt(e) {
    return e < 0 && (e = 0), (this._startAt = e), this;
  }
  getStartProps() {
    var e;
    return null === (e = this.stepHead) || void 0 === e ? void 0 : e.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(e) {
    if (e > 0) {
      const T = this._addStep(+e, null);
      (T.type = AnimateStepType$1.wait),
        T.prev.customAnimate
          ? (T.props = T.prev.customAnimate.getEndProps())
          : (T.props = T.prev.props),
        this.target.onAddStep && this.target.onAddStep(T);
    }
    return this;
  }
  _addStep(e, T, C) {
    const $ = new Step$2(this.duration, e, T, C);
    return (
      (this.duration += e), this.stepTail.append($), (this.stepTail = $), $
    );
  }
  _appendProps(e, T, C) {
    T.props = C ? e : Object.assign({}, e);
    let $ = T.prev;
    const F = T.props;
    for (
      T.propKeys || (T.propKeys = Object.keys(T.props)),
        T.propKeys.forEach((e) => {
          void 0 === T.props[e] &&
            (T.props[e] = this.target.getDefaultAttribute(e));
        });
      $.prev;

    )
      $.props &&
        ($.propKeys || ($.propKeys = Object.keys($.props)),
        $.propKeys.forEach((e) => {
          void 0 === F[e] && (F[e] = $.props[e]);
        })),
        (T.propKeys = Object.keys(T.props)),
        ($ = $.prev);
    const V = this.stepHead.props;
    T.propKeys || (T.propKeys = Object.keys(F)),
      T.propKeys.forEach((e) => {
        if (void 0 === V[e]) {
          const T = this.animate.getStartProps();
          V[e] = T[e] = this.target.getComputedAttribute(e);
        }
      }),
      this.target.onAddStep && this.target.onAddStep(T);
  }
  _appendCustomAnimate(e, T) {
    (T.customAnimate = e), (e.step = T), e.bind(this.target, this);
  }
  setPosition(e) {
    var T;
    const C = this.duration,
      $ = this.loop,
      F = this.rawPosition;
    let V,
      Y,
      K = !1;
    const J = null !== (T = this._startAt) && void 0 !== T ? T : 0;
    if ((e < 0 && (e = 0), e < J)) return (this.rawPosition = e), !1;
    if (((e -= J), C <= 0 && ((K = !0), C < 0))) return K;
    if (
      ((V = Math.floor(e / C)),
      (Y = e - V * C),
      (K = e >= $ * C + C),
      K && ((Y = C), (V = $), (e = Y * V + C)),
      e === F)
    )
      return K;
    const ee = !this.reversed != !(this.bounce && V % 2);
    return (
      ee && (Y = C - Y),
      (this._deltaPosition = Y - this.position),
      (this.position = Y),
      (this.rawPosition = e + J),
      this.updatePosition(K, ee),
      K
    );
  }
  updatePosition(e, T) {
    if (!this.stepHead) return;
    let C = this.stepHead.next;
    const $ = this.position,
      F = this.duration;
    if (this.target && C) {
      let V = C.next;
      for (; V && V.position <= $; ) (C = V), (V = C.next);
      let Y = e ? (0 === F ? 1 : $ / F) : ($ - C.position) / C.duration;
      C.easing && (Y = C.easing(Y)),
        this.tryCallCustomAnimateLifeCycle(
          C,
          this._lastStep || (T ? this.stepTail : this.stepHead),
          T
        ),
        this.updateTarget(C, Y, e),
        (this._lastStep = C),
        this.animate._onFrame && this.animate._onFrame.forEach((e) => e(C, Y));
    }
  }
  tryCallCustomAnimateLifeCycle(e, T, C) {
    if (e !== T)
      if (C) {
        let C = T.prev;
        for (; C && C !== e; )
          C.customAnimate &&
            (C.customAnimate.onStart && C.customAnimate.onStart(),
            C.customAnimate.onEnd && C.customAnimate.onEnd()),
            (C = e.prev);
        T &&
          T.customAnimate &&
          T.customAnimate.onEnd &&
          T.customAnimate.onEnd(),
          e &&
            e.customAnimate &&
            e.customAnimate.onStart &&
            e.customAnimate.onStart();
      } else {
        let C = T.next;
        for (; C && C !== e; )
          C.customAnimate &&
            (C.customAnimate.onStart && C.customAnimate.onStart(),
            C.customAnimate.onEnd && C.customAnimate.onEnd()),
            (C = C.next);
        T &&
          T.customAnimate &&
          T.customAnimate.onEnd &&
          T.customAnimate.onEnd(),
          e &&
            e.customAnimate &&
            e.customAnimate.onStart &&
            e.customAnimate.onStart();
      }
  }
  getLastPropByName(e, T) {
    let C = T.prev;
    for (; C; ) {
      if (C.props && void 0 !== C.props[e]) return C.props[e];
      if (C.customAnimate) {
        const T = C.customAnimate.getEndProps()[e];
        if (void 0 !== T) return T;
      }
      C = C.prev;
    }
    return (
      Logger$1.getInstance().warn("step"), T.props[e]
    );
  }
  updateTarget(e, T, C) {
    (null == e.props && null == e.customAnimate) ||
      this.target.onStep(this, this.animate, e, T, C);
  }
}
class Step$2 {
  constructor(e, T, C, $) {
    (this.duration = T),
      (this.position = e),
      (this.props = C),
      (this.easing = $);
  }
  append(e) {
    (e.prev = this), (e.next = this.next), (this.next = e);
  }
  getLastProps() {
    let e = this.prev;
    for (; e; ) {
      if (e.props) return e.props;
      if (e.customAnimate) return e.customAnimate.getMergedEndProps();
      e = e.prev;
    }
    return null;
  }
}
const DefaultStateAnimateConfig$1 = {
  duration: 200,
  easing: "cubicOut",
};
var Edge$1, Edge2;
(Edge2 = Edge$1 || (Edge$1 = {})),
  (Edge2[(Edge2.Top = 1)] = "Top"),
  (Edge2[(Edge2.Right = 2)] = "Right"),
  (Edge2[(Edge2.Bottom = 4)] = "Bottom"),
  (Edge2[(Edge2.Left = 8)] = "Left"),
  (Edge2[(Edge2.ALL = 15)] = "ALL");
const _strokeVec4$1 = [!1, !1, !1, !1],
  parseStroke$1 = (e) => {
    var T;
    let C = !0;
    if (isBoolean$2(e, !0)) {
      for (let $ = 0; $ < 4; $++)
        (_strokeVec4$1[$] = e),
          C && (C = !(null !== (T = _strokeVec4$1[$]) && void 0 !== T && !T));
      C = e;
    } else if (Array.isArray(e))
      for (let $ = 0; $ < 4; $++)
        (_strokeVec4$1[$] = !!e[$]), C && (C = !!_strokeVec4$1[$]);
    else
      (_strokeVec4$1[0] = !1),
        (_strokeVec4$1[1] = !1),
        (_strokeVec4$1[2] = !1),
        (_strokeVec4$1[3] = !1);
    return {
      isFullStroke: C,
      stroke: _strokeVec4$1,
    };
  },
  _paddingVec4$1 = [0, 0, 0, 0],
  parsePadding$1 = (e) =>
    e
      ? isArray$2(e)
        ? 0 === e.length
          ? 0
          : 1 === e.length
          ? e[0]
          : 2 === e.length
          ? ((_paddingVec4$1[0] = e[0]),
            (_paddingVec4$1[2] = e[0]),
            (_paddingVec4$1[1] = e[1]),
            (_paddingVec4$1[3] = e[1]),
            _paddingVec4$1)
          : e
        : e
      : 0,
  _coords$1 = [
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
  ],
  indexList$1 = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds$1(e, T, C, $) {
  for (; e >= pi2$1; ) e -= pi2$1;
  for (; e < 0; ) e += pi2$1;
  for (; e > T; ) T += pi2$1;
  (_coords$1[0].x = C),
    (_coords$1[1].y = C),
    (_coords$1[2].x = -C),
    (_coords$1[3].y = -C);
  const F = Math.ceil(e / halfPi$2) % 4,
    V = Math.ceil(T / halfPi$2) % 4;
  if (
    ($.add(cos$1(e) * C, sin$1(e) * C),
    $.add(cos$1(T) * C, sin$1(T) * C),
    F !== V || T - e > pi$1)
  ) {
    let e = !1;
    for (let T = 0; T < indexList$1.length; T++)
      if (e || F !== indexList$1[T]) {
        if (e && V === indexList$1[T]) break;
        if (e) {
          const e = _coords$1[indexList$1[T]];
          $.add(e.x, e.y);
        }
      } else {
        e = !0;
        const T = _coords$1[F];
        $.add(T.x, T.y);
      }
  }
}
function pointInterpolation$1(e, T, C) {
  const { x: $, y: F } = pointAt$1(e.x, e.y, T.x, T.y, C),
    { x: V, y: Y } = pointAt$1(e.x1, e.y1, T.x1, T.y1, C),
    K = new Point$1($, F, V, Y);
  return (K.defined = T.defined), K;
}
function pointsInterpolation$1(e, T, C) {
  if (!e || !T) return [];
  Array.isArray(e) || (e = [e]), Array.isArray(T) || (T = [T]);
  let $ = [];
  if (e.length > T.length) {
    $ = T.map((e) => {
      const T = new Point$1(e.x, e.y, e.x1, e.y1);
      return (T.defined = e.defined), T;
    });
    for (let F = 0; F < T.length; F++)
      $[F] = pointInterpolation$1(e[F], T[F], C);
  } else {
    $ = T.map((e) => {
      const T = new Point$1(e.x, e.y, e.x1, e.y1);
      return (T.defined = e.defined), T;
    });
    for (let F = 0; F < e.length; F++)
      $[F] = pointInterpolation$1(e[F], T[F], C);
  }
  return $;
}
function getAttributeFromDefaultAttrList$1(e, T) {
  if (isArray$2(e)) {
    let C;
    for (let $ = 0; $ < e.length && void 0 === C; $++) C = e[$][T];
    return C;
  }
  return e[T];
}
class RafBasedSTO$1 {
  constructor(e = RafBasedSTO$1.TimeOut) {
    (this.durations = []),
      (this.timeout = e),
      (this.lastDate = 0),
      (this.durationsListThreshold = 30);
  }
  call(e) {
    return (
      (this.lastDate = Date.now()),
      setTimeout(
        () => {
          this.appendDuration(Date.now() - this.lastDate), e(0);
        },
        this.timeout,
        !0
      )
    );
  }
  clear(e) {
    clearTimeout(e);
  }
  appendDuration(e) {
    this.durations.push(e),
      this.durations.length > this.durationsListThreshold &&
        this.durations.shift(),
      (this.timeout = Math.min(
        Math.max(
          this.durations.reduce((e, T) => e + T, 0) / this.durations.length,
          1e3 / 60
        ),
        1e3 / 30
      ));
  }
}
RafBasedSTO$1.TimeOut = 1e3 / 60;
const rafBasedSto$1 = new RafBasedSTO$1(),
  _calculateLineHeight = (e, T) =>
    isString$2(e) && "%" === e[e.length - 1]
      ? T * (Number.parseFloat(e.substring(0, e.length - 1)) / 100)
      : e,
  calculateLineHeight$1 = (e, T) => {
    const C = _calculateLineHeight(e, T);
    return isNaN(C) ? C : Math.max(T, C);
  };
var ColorType$1, ColorType2;
(ColorType2 = ColorType$1 || (ColorType$1 = {})),
  (ColorType2[(ColorType2.Color255 = 0)] = "Color255"),
  (ColorType2[(ColorType2.Color1 = 1)] = "Color1");
class ColorStore$1 {
  static Get(e, T = ColorType$1.Color1, C = [0, 0, 0, 1]) {
    if (T === ColorType$1.Color1) {
      const T = ColorStore$1.store1[e];
      if (T)
        return (C[0] = T[0]), (C[1] = T[1]), (C[2] = T[2]), (C[3] = T[3]), C;
      const $ = Color$1.parseColorString(e);
      if ($) {
        const T = [$.r / 255, $.g / 255, $.b / 255, $.opacity];
        (ColorStore$1.store1[e] = T),
          (ColorStore$1.store255[e] = [$.r, $.g, $.b, $.opacity]),
          (C[0] = T[0]),
          (C[1] = T[1]),
          (C[2] = T[2]),
          (C[3] = T[3]);
      }
      return C;
    }
    const $ = ColorStore$1.store255[e];
    if ($) return (C[0] = $[0]), (C[1] = $[1]), (C[2] = $[2]), (C[3] = $[3]), C;
    const F = Color$1.parseColorString(e);
    return (
      F &&
        ((ColorStore$1.store1[e] = [
          F.r / 255,
          F.g / 255,
          F.b / 255,
          F.opacity,
        ]),
        (ColorStore$1.store255[e] = [F.r, F.g, F.b, F.opacity]),
        (C[0] = F.r),
        (C[1] = F.g),
        (C[2] = F.b),
        (C[3] = F.opacity)),
      C
    );
  }
  static Set(e, T, C) {
    if (T === ColorType$1.Color1) {
      if (ColorStore$1.store1[e]) return;
      (ColorStore$1.store1[e] = C),
        (ColorStore$1.store255[e] = [
          Math.floor(255 * C[0]),
          Math.floor(255 * C[1]),
          Math.floor(255 * C[2]),
          Math.floor(255 * C[3]),
        ]);
    } else {
      if (ColorStore$1.store255[e]) return;
      (ColorStore$1.store255[e] = C),
        (ColorStore$1.store1[e] = [C[0] / 255, C[1] / 255, C[2] / 255, C[3]]);
    }
  }
}
function colorArrayToString$1(e, T = !1) {
  return Array.isArray(e) && isNumber$2(e[0])
    ? T
      ? `rgb(${Math.round(e[0])},${Math.round(e[1])},${Math.round(
          e[2]
        )},${e[3].toFixed(2)})`
      : `rgb(${Math.round(e[0])},${Math.round(e[1])},${Math.round(e[2])})`
    : e;
}
function interpolateColor$1(e, T, C, $, F) {
  return (Array.isArray(e) && !isNumber$2(e[0])) ||
    (Array.isArray(T) && !isNumber$2(T[0]))
    ? new Array(4)
        .fill(0)
        .map((F, V) =>
          _interpolateColor$1(
            isArray$2(e) ? e[V] : e,
            isArray$2(T) ? T[V] : T,
            C,
            $
          )
        )
    : _interpolateColor$1(e, T, C, $, F);
}
function _interpolateColor$1(e, T, C, $, F) {
  if (!e || !T)
    return (
      (e && colorArrayToString$1(e)) || (T && colorArrayToString$1(T)) || !1
    );
  let V,
    Y,
    K = !1,
    J = !1;
  if (
    (Array.isArray(e)
      ? (V = e)
      : "string" == typeof e
      ? (V = ColorStore$1.Get(e, ColorType$1.Color255))
      : (K = !0),
    Array.isArray(T)
      ? (Y = T)
      : "string" == typeof T
      ? (Y = ColorStore$1.Get(T, ColorType$1.Color255))
      : (J = !0),
    K !== J)
  ) {
    const V = K ? e : T,
      Y = K ? T : e,
      J = Object.assign(Object.assign({}, V), {
        stops: V.stops.map((e) =>
          Object.assign(Object.assign({}, e), {
            color: colorArrayToString$1(Y),
          })
        ),
      });
    return K
      ? interpolateColor$1(V, J, C, $, F)
      : interpolateColor$1(J, V, C, $, F);
  }
  if (K) {
    if (e.gradient === T.gradient) {
      const $ = e,
        F = T,
        V = $.stops,
        Y = F.stops;
      if (V.length !== Y.length) return !1;
      if ("linear" === $.gradient)
        return interpolateGradientLinearColor$1($, F, C);
      if ("radial" === $.gradient)
        return interpolateGradientRadialColor$1($, F, C);
      if ("conical" === $.gradient)
        return interpolateGradientConicalColor$1($, F, C);
    }
    return !1;
  }
  return (
    F && F(V, Y), colorArrayToString$1(interpolatePureColorArray$1(V, Y, C), $)
  );
}
function interpolateGradientLinearColor$1(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "linear",
    x0: e.x0 + (T.x0 - e.x0) * C,
    x1: e.x1 + (T.x1 - e.x1) * C,
    y0: e.y0 + (T.y0 - e.y0) * C,
    y1: e.y1 + (T.y1 - e.y1) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr$1($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolateGradientRadialColor$1(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "radial",
    x0: e.x0 + (T.x0 - e.x0) * C,
    x1: e.x1 + (T.x1 - e.x1) * C,
    y0: e.y0 + (T.y0 - e.y0) * C,
    y1: e.y1 + (T.y1 - e.y1) * C,
    r0: e.r0 + (T.r0 - e.r0) * C,
    r1: e.r1 + (T.r1 - e.r1) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr$1($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolateGradientConicalColor$1(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "conical",
    startAngle: e.startAngle + (T.startAngle - e.startAngle) * C,
    endAngle: e.endAngle + (T.endAngle - e.endAngle) * C,
    x: e.x + (T.x - e.x) * C,
    y: e.y + (T.y - e.y) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr$1($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolatePureColorArray$1(e, T, C) {
  return [
    e[0] + (T[0] - e[0]) * C,
    e[1] + (T[1] - e[1]) * C,
    e[2] + (T[2] - e[2]) * C,
    e[3] + (T[3] - e[3]) * C,
  ];
}
(ColorStore$1.store255 = {}), (ColorStore$1.store1 = {});
const _fromColorRGB$1 = [0, 0, 0, 0],
  _toColorRGB$1 = [0, 0, 0, 0];
function colorStringInterpolationToStr$1(e, T, C) {
  return (
    ColorStore$1.Get(e, ColorType$1.Color255, _fromColorRGB$1),
    ColorStore$1.Get(T, ColorType$1.Color255, _toColorRGB$1),
    `rgba(${Math.round(
      _fromColorRGB$1[0] + (_toColorRGB$1[0] - _fromColorRGB$1[0]) * C
    )},${Math.round(
      _fromColorRGB$1[1] + (_toColorRGB$1[1] - _fromColorRGB$1[1]) * C
    )},${Math.round(
      _fromColorRGB$1[2] + (_toColorRGB$1[2] - _fromColorRGB$1[2]) * C
    )},${_fromColorRGB$1[3] + (_toColorRGB$1[3] - _fromColorRGB$1[3]) * C})`
  );
}
class ResourceLoader$1 {
  static GetImage(e, T) {
    var C;
    const $ = ResourceLoader$1.cache.get(e);
    $
      ? "fail" === $.loadState
        ? application$1.global.getRequestAnimationFrame()(() => {
            T.imageLoadFail(e);
          })
        : "init" === $.loadState || "loading" === $.loadState
        ? null === (C = $.waitingMark) || void 0 === C || C.push(T)
        : T && T.imageLoadSuccess(e, $.data)
      : ResourceLoader$1.loadImage(e, T);
  }
  static GetSvg(e, T) {
    var C;
    let $ = ResourceLoader$1.cache.get(e);
    $
      ? "fail" === $.loadState
        ? application$1.global.getRequestAnimationFrame()(() => {
            T.imageLoadFail(e);
          })
        : "init" === $.loadState || "loading" === $.loadState
        ? null === (C = $.waitingMark) || void 0 === C || C.push(T)
        : T && T.imageLoadSuccess(e, $.data)
      : (($ = {
          type: "image",
          loadState: "init",
        }),
        ResourceLoader$1.cache.set(e, $),
        ($.dataPromise = application$1.global.loadSvg(e)),
        $.dataPromise
          ? (($.waitingMark = [T]),
            $.dataPromise.then((T) => {
              var C;
              ($.loadState = (null == T ? void 0 : T.data)
                ? "success"
                : "fail"),
                ($.data = null == T ? void 0 : T.data),
                null === (C = $.waitingMark) ||
                  void 0 === C ||
                  C.map((C, F) => {
                    (null == T ? void 0 : T.data)
                      ? (($.loadState = "success"),
                        ($.data = T.data),
                        C.imageLoadSuccess(e, T.data))
                      : (($.loadState = "fail"), C.imageLoadFail(e));
                  }),
                $.waitingMark && ($.waitingMark = []);
            }))
          : (($.loadState = "fail"), T.imageLoadFail(e)));
  }
  static GetFile(e, T) {
    let C = ResourceLoader$1.cache.get(e);
    return C
      ? "init" === C.loadState || "fail" === C.loadState
        ? Promise.reject()
        : "loading" === C.loadState
        ? C.dataPromise.then((e) => e.data)
        : Promise.resolve(C.data)
      : ((C = {
          type: T,
          loadState: "init",
        }),
        ResourceLoader$1.cache.set(e, C),
        "arrayBuffer" === T
          ? (C.dataPromise = application$1.global.loadArrayBuffer(e))
          : "blob" === T
          ? (C.dataPromise = application$1.global.loadBlob(e))
          : "json" === T && (C.dataPromise = application$1.global.loadJson(e)),
        C.dataPromise.then((e) => e.data));
  }
  static loading() {
    setTimeout(() => {
      if (!ResourceLoader$1.isLoading && ResourceLoader$1.toLoadAueue.length) {
        ResourceLoader$1.isLoading = !0;
        const e = ResourceLoader$1.toLoadAueue.splice(0, 10),
          T = [];
        e.forEach((e) => {
          const { url: C, marks: $ } = e,
            F = {
              type: "image",
              loadState: "init",
            };
          if (
            (ResourceLoader$1.cache.set(C, F),
            (F.dataPromise = application$1.global.loadImage(C)),
            F.dataPromise)
          ) {
            F.waitingMark = $;
            const e = F.dataPromise.then((e) => {
              var T;
              (F.loadState = (null == e ? void 0 : e.data)
                ? "success"
                : "fail"),
                (F.data = null == e ? void 0 : e.data),
                null === (T = F.waitingMark) ||
                  void 0 === T ||
                  T.map((T, $) => {
                    (null == e ? void 0 : e.data)
                      ? ((F.loadState = "success"),
                        (F.data = e.data),
                        T.imageLoadSuccess(C, e.data))
                      : ((F.loadState = "fail"), T.imageLoadFail(C));
                  }),
                F.waitingMark && (F.waitingMark = []);
            });
            T.push(e);
          } else (F.loadState = "fail"), $.forEach((e) => e.imageLoadFail(C));
        }),
          Promise.all(T)
            .then(() => {
              (ResourceLoader$1.isLoading = !1),
                this.onLoadSuccessCb.forEach((e) => e()),
                ResourceLoader$1.loading();
            })
            .catch((e) => {
              console.error(e),
                (ResourceLoader$1.isLoading = !1),
                this.onLoadSuccessCb.forEach((e) => e()),
                ResourceLoader$1.loading();
            });
      }
    }, 0);
  }
  static loadImage(e, T) {
    const C = getIndex$1(e, ResourceLoader$1.toLoadAueue);
    if (-1 !== C)
      return (
        ResourceLoader$1.toLoadAueue[C].marks.push(T),
        void ResourceLoader$1.loading()
      );
    ResourceLoader$1.toLoadAueue.push({
      url: e,
      marks: [T],
    }),
      ResourceLoader$1.loading();
  }
  static improveImageLoading(e) {
    const T = getIndex$1(e, ResourceLoader$1.toLoadAueue);
    if (-1 !== T) {
      const e = ResourceLoader$1.toLoadAueue.splice(T, 1);
      ResourceLoader$1.toLoadAueue.unshift(e[0]);
    }
  }
  static onLoadSuccess(e) {
    this.onLoadSuccessCb.push(e);
  }
}
function getIndex$1(e, T) {
  for (let C = 0; C < T.length; C++) if (T[C].url === e) return C;
  return -1;
}
(ResourceLoader$1.cache = new Map()),
  (ResourceLoader$1.isLoading = !1),
  (ResourceLoader$1.toLoadAueue = []),
  (ResourceLoader$1.onLoadSuccessCb = []);
const tempMatrix$1 = new Matrix$1(),
  tempBounds$2 = new AABBBounds$1(),
  GRAPHIC_UPDATE_TAG_KEY$1 = [
    "lineWidth",
    "scaleX",
    "scaleY",
    "angle",
    "anchor",
    "visible",
  ],
  tempConstantXYKey$1 = ["x", "y"],
  tempConstantScaleXYKey$1 = ["scaleX", "scaleY"],
  tempConstantAngleKey$1 = ["angle"],
  point$4 = new Point$1(),
  NOWORK_ANIMATE_ATTR$1 = {
    strokeSeg: 1,
    boundsPadding: 2,
    pickMode: 1,
    boundsMode: 1,
    customPickShape: 1,
    pickable: 1,
    childrenPickable: 1,
    visible: 1,
    zIndex: 1,
    layout: 1,
    keepDirIn3d: 1,
    globalZIndex: 1,
    outerBorder: 1,
    innerBorder: 1,
    lineDash: 1,
    lineCap: 1,
    lineJoin: 1,
    miterLimit: 2,
    strokeBoundsBuffer: 2,
    scaleCenter: 1,
    anchor: 1,
    anchor3d: 1,
    postMatrix: 1,
    backgroundMode: 2,
    background: 1,
    texture: 1,
    cursor: 1,
    html: 1,
  };
class Graphic$1 extends Node$1 {
  static mixin(e) {
    const T = Object.keys(e);
    for (let C = 0; C < T.length; ++C) {
      const $ = T[C];
      Object.defineProperty(
        Graphic$1.prototype,
        $,
        Object.getOwnPropertyDescriptor(e, $)
      );
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(!0);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(!0);
  }
  constructor(e = {}) {
    var T;
    super(),
      (this._AABBBounds = new AABBBounds$1()),
      (this._updateTag = UpdateTag$1.INIT),
      (this.attribute = e),
      (this.valid = this.isValid()),
      (this.updateAABBBoundsStamp = 0),
      e.background
        ? this.loadImage(
            null !== (T = e.background.background) && void 0 !== T
              ? T
              : e.background,
            !0
          )
        : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic);
  }
  setMode(e) {
    "3d" === e ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  getOffsetXY(e, T = !1) {
    var C, $;
    const { dx: F = e.dx, dy: V = e.dy } = this.attribute;
    if (T && this.parent) {
      const e = this.parent.attribute;
      (point$4.x = F + (null !== (C = e.scrollX) && void 0 !== C ? C : 0)),
        (point$4.y = V + (null !== ($ = e.scrollY) && void 0 !== $ ? $ : 0));
    } else (point$4.x = F), (point$4.y = V);
    return point$4;
  }
  onAnimateBind(e) {
    this._emitCustomEvent("animate-bind", e);
  }
  tryUpdateAABBBounds(e) {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application$1.graphicService.beforeUpdateAABBBounds(
      this,
      this.stage,
      !0,
      this._AABBBounds
    );
    const T = this.doUpdateAABBBounds(e);
    return (
      application$1.graphicService.afterUpdateAABBBounds(
        this,
        this.stage,
        this._AABBBounds,
        this,
        !0
      ),
      T
    );
  }
  tryUpdateOBBBounds() {
    return (
      this._OBBBounds || (this._OBBBounds = new OBBBounds()),
      this.tryUpdateAABBBounds(),
      this.updateOBBBoundsStamp === this.updateAABBBoundsStamp
        ? this._OBBBounds
        : ((this.updateOBBBoundsStamp = this.updateAABBBoundsStamp),
          this.valid
            ? this.doUpdateOBBBounds()
            : (this._OBBBounds.clear(), this._OBBBounds))
    );
  }
  combindShadowAABBBounds(e) {
    if (this.shadowRoot) {
      const T = this.shadowRoot.AABBBounds.clone();
      e.union(T);
    }
  }
  doUpdateOBBBounds() {
    return this._OBBBounds;
  }
  doUpdateAABBBounds(e) {
    this.updateAABBBoundsStamp++;
    const T = this.getGraphicTheme();
    this._AABBBounds.clear();
    const C = this.attribute,
      $ = this.updateAABBBounds(C, T, this._AABBBounds, e),
      { boundsPadding: F = T.boundsPadding } = C,
      V = parsePadding$1(F);
    return V && $.expand(V), this.clearUpdateBoundTag(), $;
  }
  updatePathProxyAABBBounds(e) {
    const T =
      "function" == typeof this.pathProxy
        ? this.pathProxy(this.attribute)
        : this.pathProxy;
    if (!T) return !1;
    const C = new BoundsContext$1(e);
    return renderCommandList$1(T.commandList, C, 0, 0), !0;
  }
  tryUpdateGlobalAABBBounds() {
    const e = this.AABBBounds;
    return (
      this._globalAABBBounds
        ? this._globalAABBBounds.setValue(e.x1, e.y1, e.x2, e.y2)
        : (this._globalAABBBounds = e.clone()),
      this._globalAABBBounds.empty() ||
        (this.parent &&
          this._globalAABBBounds.transformWithMatrix(
            this.parent.globalTransMatrix
          )),
      this._globalAABBBounds
    );
  }
  tryUpdateGlobalTransMatrix(e = !0) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const e = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
      }
    } else
      this._globalTransMatrix = this.parent
        ? this.parent.globalTransMatrix.clone()
        : this.transMatrix.clone();
    return (
      this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(),
      this._globalTransMatrix
    );
  }
  shouldUpdateGlobalMatrix() {
    return !0;
  }
  tryUpdateLocalTransMatrix(e = !0) {
    return (
      this._transMatrix || (this._transMatrix = new Matrix$1()),
      this.shouldUpdateLocalMatrix() &&
        (this.doUpdateLocalMatrix(), e && this.clearUpdateLocalPositionTag()),
      this._transMatrix
    );
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot
      ? (!!(this._updateTag & UpdateTag$1.UPDATE_BOUNDS) ||
          this.shadowRoot.shouldUpdateAABBBounds()) &&
          application$1.graphicService.validCheck(
            this.attribute,
            this.getGraphicTheme(),
            this._AABBBounds,
            this
          )
      : !!(this._updateTag & UpdateTag$1.UPDATE_BOUNDS) &&
          application$1.graphicService.validCheck(
            this.attribute,
            this.getGraphicTheme(),
            this._AABBBounds,
            this
          );
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot
      ? !!(this._updateTag & UpdateTag$1.UPDATE_BOUNDS) ||
          this.shadowRoot.shouldUpdateAABBBounds()
      : !!(this._updateTag & UpdateTag$1.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag$1.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var e, T;
    const C = this.attribute;
    return Number.isFinite(
      (null !== (e = C.x) && void 0 !== e ? e : 0) +
        (null !== (T = C.y) && void 0 !== T ? T : 0)
    );
  }
  _validNumber(e) {
    return null == e || Number.isFinite(e);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag$1.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag$1.CLEAR_SHAPE;
  }
  containsPoint(e, T, C, $) {
    if (!$) return !1;
    if (C === IContainPointMode$1.GLOBAL) {
      const C = new Point$1(e, T);
      this.parent && this.parent.globalTransMatrix.transformPoint(C, C),
        (e = C.x),
        (T = C.y);
    }
    return $.containsPoint(this, {
      x: e,
      y: T,
    });
  }
  setAttributes(e, T = !1, C) {
    (e =
      (this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(e, this.attribute, null, C)) ||
      e).background
      ? this.loadImage(e.background, !0)
      : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic),
      this._setAttributes(e, T, C);
  }
  _setAttributes(e, T = !1, C) {
    const $ = Object.keys(e);
    for (let F = 0; F < $.length; F++) {
      const T = $[F];
      this.attribute[T] = e[T];
    }
    (this.valid = this.isValid()),
      this.updateShapeAndBoundsTagSetted() || (!T && !this.needUpdateTags($))
        ? this.addUpdateBoundTag()
        : this.addUpdateShapeAndBoundsTag(),
      this.addUpdatePositionTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(C);
  }
  setAttribute(e, T, C, $) {
    var F;
    const V =
      this.onBeforeAttributeUpdate &&
      this.onBeforeAttributeUpdate(
        {
          [e]: T,
        },
        this.attribute,
        e,
        $
      );
    V
      ? this._setAttributes(V, C, $)
      : isNil$2(null === (F = this.normalAttrs) || void 0 === F ? void 0 : F[e])
      ? ((this.attribute[e] = T),
        (this.valid = this.isValid()),
        this.updateShapeAndBoundsTagSetted() || (!C && !this.needUpdateTag(e))
          ? this.addUpdateBoundTag()
          : this.addUpdateShapeAndBoundsTag(),
        this.addUpdatePositionTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($))
      : (this.normalAttrs[e] = T),
      "background" === e
        ? this.loadImage(T, !0)
        : "shadowGraphic" === e && this.setShadowGraphic(T);
  }
  needUpdateTags(e, T = GRAPHIC_UPDATE_TAG_KEY$1) {
    for (let C = 0; C < T.length; C++) {
      const $ = T[C];
      if (-1 !== e.indexOf($)) return !0;
    }
    return !1;
  }
  needUpdateTag(e, T = GRAPHIC_UPDATE_TAG_KEY$1) {
    for (let C = 0; C < T.length; C++) if (e === T[C]) return !0;
    return !1;
  }
  initAttributes(e) {
    const T = {
      type: AttributeUpdateType$1.INIT,
    };
    (e =
      (this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(e, this.attribute, null, T)) ||
      e),
      (this.attribute = e),
      e.background
        ? this.loadImage(e.background, !0)
        : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic),
      (this._updateTag = UpdateTag$1.INIT),
      (this.valid = this.isValid()),
      this.onAttributeUpdate(T);
  }
  translate(e, T) {
    var C, $;
    if (0 === e && 0 === T) return this;
    const F = {
        type: AttributeUpdateType$1.TRANSLATE,
      },
      V =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            x: e,
            y: T,
          },
          this.attribute,
          tempConstantXYKey$1,
          F
        );
    V && ((e = V.x), (T = V.y), delete V.x, delete V.y, this._setAttributes(V));
    const Y = this.attribute,
      K = Y.postMatrix;
    return (
      K
        ? application$1.transformUtil.fromMatrix(K, K).translate(e, T)
        : ((Y.x =
            (null !== (C = Y.x) && void 0 !== C ? C : DefaultTransform$1.x) +
            e),
          (Y.y =
            (null !== ($ = Y.y) && void 0 !== $ ? $ : DefaultTransform$1.y) +
            T)),
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(F),
      this
    );
  }
  translateTo(e, T) {
    const C = this.attribute;
    if (C.x === e && C.y === T) return this;
    const $ = {
        type: AttributeUpdateType$1.TRANSLATE_TO,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            x: e,
            y: T,
          },
          this.attribute,
          tempConstantXYKey$1,
          $
        );
    return F
      ? (this._setAttributes(F, !1, $), this)
      : ((C.x = e),
        (C.y = T),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($),
        this);
  }
  scale(e, T, C) {
    var $, F;
    if (1 === e && 1 === T) return this;
    const V = {
        type: AttributeUpdateType$1.SCALE,
      },
      Y =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            scaleX: e,
            scaleY: T,
            scaleCenter: C,
          },
          this.attribute,
          tempConstantScaleXYKey$1,
          V
        );
    Y &&
      ((e = Y.scaleX),
      (T = Y.scaleY),
      delete Y.scaleX,
      delete Y.scaleY,
      this._setAttributes(Y));
    const K = this.attribute;
    if (C) {
      let { postMatrix: $ } = this.attribute;
      $ || (($ = new Matrix$1()), (K.postMatrix = $)),
        application$1.transformUtil.fromMatrix($, $).scale(e, T, C);
    } else
      (K.scaleX =
        (null !== ($ = K.scaleX) && void 0 !== $
          ? $
          : DefaultTransform$1.scaleX) * e),
        (K.scaleY =
          (null !== (F = K.scaleY) && void 0 !== F
            ? F
            : DefaultTransform$1.scaleY) * T);
    return (
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(V),
      this
    );
  }
  scaleTo(e, T) {
    const C = this.attribute;
    if (C.scaleX === e && C.scaleY === T) return this;
    const $ = {
        type: AttributeUpdateType$1.SCALE_TO,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            scaleX: e,
            scaleY: T,
          },
          this.attribute,
          tempConstantScaleXYKey$1,
          $
        );
    return F
      ? (this._setAttributes(F, !1, $), this)
      : ((C.scaleX = e),
        (C.scaleY = T),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($),
        this);
  }
  rotate(e, T) {
    var C;
    if (0 === e) return this;
    const $ = {
        type: AttributeUpdateType$1.ROTATE,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            angle: e,
            rotateCenter: T,
          },
          this.attribute,
          tempConstantAngleKey$1,
          $
        );
    F && (delete F.angle, this._setAttributes(F, !1, $));
    const V = this.attribute;
    if (T) {
      let { postMatrix: C } = this.attribute;
      C || ((C = new Matrix$1()), (V.postMatrix = C)),
        application$1.transformUtil.fromMatrix(C, C).rotate(e, T);
    } else
      V.angle =
        (null !== (C = V.angle) && void 0 !== C
          ? C
          : DefaultTransform$1.angle) + e;
    return (
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate($),
      this
    );
  }
  rotateTo(e) {
    const T = this.attribute;
    if (T.angle === e) return this;
    const C = {
        type: AttributeUpdateType$1.ROTATE_TO,
      },
      $ =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          e,
          this.attribute,
          tempConstantAngleKey$1,
          C
        );
    return $
      ? (this._setAttributes($, !1, C), this)
      : ((T.angle = e),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(C),
        this);
  }
  skewTo(e, T) {
    return this;
  }
  animate(e) {
    this.animates || (this.animates = new Map());
    const T = new Animate$1(
      null == e ? void 0 : e.id,
      this.stage && this.stage.getTimeline(),
      null == e ? void 0 : e.slience
    );
    if ((T.bind(this), e)) {
      const { onStart: C, onFrame: $, onEnd: F, onRemove: V } = e;
      null != C && T.onStart(C),
        null != $ && T.onFrame($),
        null != F && T.onEnd(F),
        null != V && T.onRemove(V),
        (T.interpolateFunc = e.interpolate);
    }
    return (
      this.animates.set(T.id, T),
      T.onRemove(() => {
        this.animates.delete(T.id);
      }),
      T
    );
  }
  onAttributeUpdate(e) {
    (e && e.skipUpdateCallback) ||
      (application$1.graphicService.onAttributeUpdate(this),
      this._emitCustomEvent("afterAttributeUpdate", e));
  }
  update(e) {
    e
      ? (e.bounds &&
          this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode),
        e.trans && this.tryUpdateLocalTransMatrix())
      : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode),
        this.tryUpdateLocalTransMatrix());
  }
  hasState(e) {
    return (
      !(!this.currentStates || !this.currentStates.length) &&
      (!!isNil$2(e) || this.currentStates.includes(e))
    );
  }
  getState(e) {
    var T;
    return null === (T = this.states) || void 0 === T ? void 0 : T[e];
  }
  applyStateAttrs(e, T, C, $) {
    var F, V, Y, K;
    if (C) {
      const C = Object.keys(e),
        J = this.getNoWorkAnimateAttr(),
        ee = {};
      let te;
      C.forEach((T) => {
        J[T]
          ? (te || (te = {}), (te[T] = e[T]))
          : (ee[T] = $ && void 0 === e[T] ? this.getDefaultAttribute(T) : e[T]);
      });
      const ie = this.animate({
        slience: !0,
      });
      (ie.stateNames = T),
        ie.to(
          ee,
          null !==
            (V =
              null === (F = this.stateAnimateConfig) || void 0 === F
                ? void 0
                : F.duration) && void 0 !== V
            ? V
            : DefaultStateAnimateConfig$1.duration,
          null !==
            (K =
              null === (Y = this.stateAnimateConfig) || void 0 === Y
                ? void 0
                : Y.easing) && void 0 !== K
            ? K
            : DefaultStateAnimateConfig$1.easing
        ),
        te &&
          this.setAttributes(te, !1, {
            type: AttributeUpdateType$1.STATE,
          });
    } else
      this.stopStateAnimates(),
        this.setAttributes(e, !1, {
          type: AttributeUpdateType$1.STATE,
        });
  }
  updateNormalAttrs(e) {
    const T = {};
    this.normalAttrs
      ? (Object.keys(e).forEach((e) => {
          e in this.normalAttrs
            ? ((T[e] = this.normalAttrs[e]), delete this.normalAttrs[e])
            : (T[e] = this.getNormalAttribute(e));
        }),
        Object.keys(this.normalAttrs).forEach((T) => {
          e[T] = this.normalAttrs[T];
        }))
      : Object.keys(e).forEach((e) => {
          T[e] = this.getNormalAttribute(e);
        }),
      (this.normalAttrs = T);
  }
  stopStateAnimates(e = "end") {
    this.animates &&
      this.animates.forEach((T) => {
        T.stateNames && (T.stop(e), this.animates.delete(T.id));
      });
  }
  getNormalAttribute(e) {
    let T = this.attribute[e];
    return (
      this.animates &&
        this.animates.forEach((C) => {
          if (C.stateNames) {
            const $ = C.getEndProps();
            has$2($, e) && (T = $[e]);
          }
        }),
      T
    );
  }
  clearStates(e) {
    this.hasState() && this.normalAttrs
      ? ((this.currentStates = []),
        this.applyStateAttrs(this.normalAttrs, this.currentStates, e, !0))
      : (this.currentStates = []),
      (this.normalAttrs = null);
  }
  removeState(e, T) {
    if ((this.currentStates ? this.currentStates.indexOf(e) : -1) >= 0) {
      const C = this.currentStates.filter((T) => T !== e);
      this.useStates(C, T);
    }
  }
  toggleState(e, T) {
    if (this.hasState(e)) this.removeState(e, T);
    else if ((this.currentStates ? this.currentStates.indexOf(e) : -1) < 0) {
      const C = this.currentStates ? this.currentStates.slice() : [];
      C.push(e), this.useStates(C, T);
    }
  }
  addState(e, T, C) {
    var $;
    if (
      this.currentStates &&
      this.currentStates.includes(e) &&
      (T || 1 === this.currentStates.length)
    )
      return;
    const F =
      T &&
      (null === ($ = this.currentStates) || void 0 === $ ? void 0 : $.length)
        ? this.currentStates.concat([e])
        : [e];
    this.useStates(F, C);
  }
  useStates(e, T) {
    var C;
    if (!e.length) return void this.clearStates(T);
    if (
      (null === (C = this.currentStates) || void 0 === C
        ? void 0
        : C.length) === e.length &&
      !e.some((e, T) => this.currentStates[T] !== e)
    )
      return;
    const $ = {};
    e.forEach((T) => {
      var C;
      const F = this.stateProxy
        ? this.stateProxy(T, e)
        : null === (C = this.states) || void 0 === C
        ? void 0
        : C[T];
      F && Object.assign($, F);
    }),
      this.updateNormalAttrs($),
      (this.currentStates = e),
      this.applyStateAttrs($, e, T);
  }
  addUpdateBoundTag() {
    (this._updateTag |= UpdateTag$1.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag(),
      this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag$1.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    (this._updateTag |= UpdateTag$1.UPDATE_SHAPE_AND_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag(),
      this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (
      (this._updateTag & UpdateTag$1.UPDATE_SHAPE_AND_BOUNDS) ===
      UpdateTag$1.UPDATE_SHAPE_AND_BOUNDS
    );
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag$1.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(),
      (this._updateTag |= UpdateTag$1.UPDATE_GLOBAL_LOCAL_MATRIX);
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(),
      (this._updateTag |= UpdateTag$1.UPDATE_GLOBAL_MATRIX);
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag$1.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag$1.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag$1.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag$1.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag$1.UPDATE_LAYOUT);
  }
  getAnchor(e, T) {
    const C = [0, 0],
      $ = () => {
        if (T.b) return T.b;
        const { scaleX: e, scaleY: C, angle: $ } = this.attribute;
        return (
          tempBounds$2.copy(this._AABBBounds),
          this.setAttributes({
            scaleX: 1,
            scaleY: 1,
            angle: 0,
          }),
          (T.b = this.AABBBounds.clone()),
          this._AABBBounds.copy(tempBounds$2),
          this.setAttributes({
            scaleX: e,
            scaleY: C,
            angle: $,
          }),
          T.b
        );
      };
    if ("string" == typeof e[0]) {
      const T = parseFloat(e[0]) / 100,
        F = $();
      C[0] = F.x1 + (F.x2 - F.x1) * T;
    } else C[0] = e[0];
    if ("string" == typeof e[1]) {
      const T = parseFloat(e[1]) / 100,
        F = $();
      C[1] = F.y1 + (F.y2 - F.y1) * T;
    } else C[1] = e[1];
    return C;
  }
  doUpdateLocalMatrix() {
    const {
      x: e = DefaultTransform$1.x,
      y: T = DefaultTransform$1.y,
      scaleX: C = DefaultTransform$1.scaleX,
      scaleY: $ = DefaultTransform$1.scaleY,
      angle: F = DefaultTransform$1.angle,
      scaleCenter: V,
      anchor: Y,
      postMatrix: K,
    } = this.attribute;
    let J = [0, 0];
    const ee = {};
    if ((Y && (J = this.getAnchor(Y, ee)), !V || (1 === C && 1 === $)))
      normalTransform$1(
        this._transMatrix,
        this._transMatrix.reset(),
        e,
        T,
        C,
        $,
        F,
        Y && J
      );
    else {
      const Y = this._transMatrix;
      Y.reset(),
        Y.translate(J[0], J[1]),
        Y.rotate(F),
        Y.translate(-J[0], -J[1]),
        Y.translate(e, T),
        (J = this.getAnchor(V, ee)),
        application$1.transformUtil.fromMatrix(Y, Y).scale(C, $, {
          x: J[0],
          y: J[1],
        });
    }
    const te = this.getOffsetXY(DefaultTransform$1);
    if (((this._transMatrix.e += te.x), (this._transMatrix.f += te.y), K)) {
      const e = tempMatrix$1.setValue(K.a, K.b, K.c, K.d, K.e, K.f),
        T = this._transMatrix;
      e.multiply(T.a, T.b, T.c, T.d, T.e, T.f),
        T.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(
        this.transMatrix.a,
        this.transMatrix.b,
        this.transMatrix.c,
        this.transMatrix.d,
        this.transMatrix.e,
        this.transMatrix.f
      );
      const { scrollX: e = 0, scrollY: T = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(e, T);
    }
  }
  setStage(e, T) {
    if (this.stage !== e) {
      if (
        ((this.stage = e),
        (this.layer = T),
        this.setStageToShadowRoot(e, T),
        this.animates && this.animates.size)
      ) {
        const T = e.getTimeline();
        this.animates.forEach((e) => {
          e.setTimeline(T);
        });
      }
      this._onSetStage && this._onSetStage(this, e, T),
        application$1.graphicService.onSetStage(this, e);
    }
  }
  setStageToShadowRoot(e, T) {
    this.shadowRoot && this.shadowRoot.setStage(e, T);
  }
  onAddStep(e) {}
  onStop(e) {
    e &&
      this.setAttributes(e, !1, {
        type: AttributeUpdateType$1.ANIMATE_END,
      });
  }
  onStep(e, T, C, $, F) {
    const V = {};
    if (C.customAnimate) C.customAnimate.update(F, $, V);
    else {
      const Y = C.props,
        K = C.parsedProps,
        J = C.propKeys;
      this.stepInterpolate(e, T, V, C, $, F, Y, void 0, K, J);
    }
    this.setAttributes(V, !1, {
      type: AttributeUpdateType$1.ANIMATE_UPDATE,
      animationState: {
        ratio: $,
        end: F,
        step: C,
        isFirstFrameOfStep: e.getLastStep() !== C,
      },
    }),
      this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(e, T, C, $, F, V, Y, K, J, ee) {
    ee || ((ee = Object.keys(Y)), ($.propKeys = ee)),
      V
        ? $.propKeys.forEach((e) => {
            T.validAttr(e) && (C[e] = Y[e]);
          })
        : ee.forEach((V) => {
            var ee;
            if (!T.validAttr(V)) return;
            const te = Y[V],
              ie =
                null !== (ee = K && K[V]) && void 0 !== ee
                  ? ee
                  : e.getLastPropByName(V, $);
            if (null == te || null == ie || te === ie) return void (C[V] = te);
            let ne;
            (ne = T.interpolateFunc && T.interpolateFunc(V, F, ie, te, C)),
              ne ||
                ((ne = T.customInterpolate(V, F, ie, te, this, C)),
                ne ||
                  this.defaultInterpolate(te, ie, V, C, J, F) ||
                  this._interpolate(V, F, ie, te, C));
          }),
      ($.parsedProps = J);
  }
  defaultInterpolate(e, T, C, $, F, V) {
    if (Number.isFinite(e)) return ($[C] = T + (e - T) * V), !0;
    if ("fill" === C) {
      F || (F = {});
      const Y = F.fillColorArray,
        K = interpolateColor$1(T, null != Y ? Y : e, V, !1, (e, T) => {
          F.fillColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    if ("stroke" === C) {
      F || (F = {});
      const Y = F.strokeColorArray,
        K = interpolateColor$1(T, null != Y ? Y : e, V, !1, (e, T) => {
          F.strokeColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    if ("shadowColor" === C) {
      F || (F = {});
      const Y = F.shadowColorArray,
        K = interpolateColor$1(T, null != Y ? Y : e, V, !0, (e, T) => {
          F.shadowColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    return !1;
  }
  _interpolate(e, T, C, $, F) {}
  getDefaultAttribute(e) {
    return this.getGraphicTheme()[e];
  }
  getComputedAttribute(e) {
    var T;
    return null !== (T = this.attribute[e]) && void 0 !== T
      ? T
      : this.getDefaultAttribute(e);
  }
  onSetStage(e, T = !1) {
    (this._onSetStage = e), T && this.stage && e(this, this.stage);
  }
  attachShadow(e) {
    return (
      e && (e.shadowHost = this),
      (this.shadowRoot =
        null != e ? e : application$1.graphicService.creator.shadowRoot(this)),
      this.addUpdateBoundTag(),
      this.shadowRoot.setStage(this.stage, this.layer),
      this.shadowRoot
    );
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), (this.shadowRoot = null));
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((e) => e.toJson()),
    };
  }
  createPathProxy(e) {
    return (
      isString$2(e, !0)
        ? (this.pathProxy = new CustomPath2D$1().fromString(e))
        : (this.pathProxy = new CustomPath2D$1()),
      this.pathProxy
    );
  }
  loadImage(e, T = !1) {
    if (!e || (T && backgroundNotImage$1(e))) return;
    const C = e;
    this.resources || (this.resources = new Map());
    const $ = {
      data: "init",
      state: null,
    };
    this.resources.set(C, $),
      "string" == typeof e
        ? (($.state = "loading"),
          e.startsWith("<svg")
            ? (ResourceLoader$1.GetSvg(e, this),
              (this.backgroundImg = this.backgroundImg || T))
            : (isValidUrl$2(e) || e.includes("/") || isBase64$2(e)) &&
              (ResourceLoader$1.GetImage(e, this),
              (this.backgroundImg = this.backgroundImg || T)))
        : isObject$2(e)
        ? (($.state = "success"),
          ($.data = e),
          (this.backgroundImg = this.backgroundImg || T))
        : ($.state = "fail");
  }
  setShadowGraphic(e) {
    e ? this.attachShadow().add(e) : this.detachShadow();
  }
  imageLoadSuccess(e, T, C) {
    if (!this.resources) return;
    const $ = this.resources.get(e);
    $ &&
      (($.state = "success"),
      ($.data = T),
      C && C(),
      this.addUpdateBoundTag(),
      this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(e, T) {
    if (!this.resources) return;
    const C = this.resources.get(e);
    C && ((C.state = "fail"), T && T());
  }
  _stopAnimates(e) {
    e &&
      e.forEach((e) => {
        e.stop();
      });
  }
  stopAnimates(e = !1) {
    this._stopAnimates(this.animates),
      this.shadowRoot && this.shadowRoot.stopAnimates(!0),
      this.isContainer &&
        e &&
        this.forEachChildren((T) => {
          T.stopAnimates(e);
        });
  }
  release() {
    (this.releaseStatus = "released"),
      application$1.graphicService.onRelease(this);
  }
  _emitCustomEvent(e, T) {
    var C, $;
    if (this._events && e in this._events) {
      const F = new CustomEvent$1(e, T);
      (F.bubbles = !1),
        (F.manager =
          null ===
            ($ =
              null === (C = this.stage) || void 0 === C
                ? void 0
                : C.eventSystem) || void 0 === $
            ? void 0
            : $.manager),
        this.dispatchEvent(F);
    }
  }
}
function backgroundNotImage$1(e) {
  return !(!e.fill && !e.stroke);
}
function boundStroke$1(e, T, C, $ = 0) {
  return e.expand(T + ($ / 2 + (C ? miterAdjustment$1(C, T) : 0))), e;
}
function miterAdjustment$1(e, T) {
  return e ? T : 0;
}
Graphic$1.mixin(EventTarget$1), globalThis && globalThis.__awaiter;
let NUMBER_TYPE$1 = 0;
function genNumberType$1() {
  return NUMBER_TYPE$1++;
}
var TextDirection$1, TextDirection2;
function verticalLayout$1(e) {
  const T = [];
  let C = 0,
    $ = "";
  for (let F = 0; F < e.length; F++)
    rotateText$1(e[F])
      ? C
        ? ($ += e[F])
        : ((C = 1), ($ = e[F]))
      : (C &&
          (T.push({
            text: $,
            direction: TextDirection$1.VERTICAL,
          }),
          ($ = ""),
          (C = 0)),
        T.push({
          text: e[F],
          direction: TextDirection$1.HORIZONTAL,
        }));
  return (
    $ &&
      T.push({
        text: $,
        direction: TextDirection$1.VERTICAL,
      }),
    T
  );
}
(TextDirection2 = TextDirection$1 || (TextDirection$1 = {})),
  (TextDirection2[(TextDirection2.HORIZONTAL = 0)] = "HORIZONTAL"),
  (TextDirection2[(TextDirection2.VERTICAL = 1)] = "VERTICAL");
const rotateCharList$1 = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
  ],
  rotateCharMap$1 = new Map();
rotateCharList$1.forEach((e) => rotateCharMap$1.set(e, !0));
const noRotateCharList$1 = [""],
  noRotateCharMap$1 = new Map();
function rotateText$1(e) {
  if (rotateCharMap$1.has(e)) return !0;
  if (noRotateCharMap$1.has(e)) return !1;
  let T = !1;
  return e.codePointAt(0) < 256 && (T = !0), T;
}
noRotateCharList$1.forEach((e) => noRotateCharMap$1.set(e, !0));
const ARC_NUMBER_TYPE$1 = genNumberType$1(),
  ARC3D_NUMBER_TYPE$1 = genNumberType$1(),
  AREA_NUMBER_TYPE$1 = genNumberType$1(),
  CIRCLE_NUMBER_TYPE$1 = genNumberType$1();
genNumberType$1();
const GROUP_NUMBER_TYPE$1 = genNumberType$1(),
  IMAGE_NUMBER_TYPE$1 = genNumberType$1(),
  LINE_NUMBER_TYPE$1 = genNumberType$1(),
  PATH_NUMBER_TYPE$1 = genNumberType$1(),
  POLYGON_NUMBER_TYPE$1 = genNumberType$1();
genNumberType$1();
const RECT_NUMBER_TYPE$1 = genNumberType$1();
genNumberType$1();
const RICHTEXT_NUMBER_TYPE$1 = genNumberType$1(),
  SYMBOL_NUMBER_TYPE$1 = genNumberType$1(),
  TEXT_NUMBER_TYPE$1 = genNumberType$1(),
  GraphicService$1 = Symbol.for("GraphicService"),
  GraphicCreator$2 = Symbol.for("GraphicCreator"),
  SVG_PARSE_ATTRIBUTE_MAP$1 = {
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-width": "lineWidth",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    stroke: "stroke",
    fill: "fill",
  },
  SVG_PARSE_ATTRIBUTE_MAP_KEYS$1 = Object.keys(SVG_PARSE_ATTRIBUTE_MAP$1);
var GroupUpdateAABBBoundsMode$1, GroupUpdateAABBBoundsMode2;
(GroupUpdateAABBBoundsMode2 =
  GroupUpdateAABBBoundsMode$1 || (GroupUpdateAABBBoundsMode$1 = {})),
  (GroupUpdateAABBBoundsMode2[(GroupUpdateAABBBoundsMode2.LESS_GROUP = 0)] =
    "LESS_GROUP"),
  (GroupUpdateAABBBoundsMode2[(GroupUpdateAABBBoundsMode2.MORE_GROUP = 1)] =
    "MORE_GROUP");
class Group$2 extends Graphic$1 {
  constructor(e) {
    super(e),
      (this.type = "group"),
      (this.parent = null),
      (this.isContainer = !0),
      (this.numberType = GROUP_NUMBER_TYPE$1),
      (this._childUpdateTag = UpdateTag$1.UPDATE_BOUNDS);
  }
  setMode(e) {
    "3d" === e ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  setTheme(e) {
    return (
      this.theme || (this.theme = new Theme$1()), this.theme.setTheme(e, this)
    );
  }
  createTheme() {
    this.theme || (this.theme = new Theme$1());
  }
  visibleAll(e) {
    this.setAttribute("visible", e),
      this.forEachChildren((T) => {
        T.isContainer && T.visibleAll
          ? T.visibleAll(e)
          : T.setAttribute("visible", e);
      });
  }
  hideAll() {
    this.visibleAll(!1);
  }
  showAll() {
    this.visibleAll(!0);
  }
  containsPoint(e, T, C) {
    if (C === IContainPointMode$1.GLOBAL) {
      const C = new Point$1(e, T);
      return (
        this.parent && this.parent.globalTransMatrix.transformPoint(C, C),
        this.AABBBounds.contains(C.x, C.y)
      );
    }
    return this.AABBBounds.contains(e, T);
  }
  shouldUpdateAABBBounds() {
    return (
      !!super.shouldUpdateAABBBounds() ||
      !!(this._childUpdateTag & UpdateTag$1.UPDATE_BOUNDS)
    );
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application$1.graphicService.beforeUpdateAABBBounds(
      this,
      this.stage,
      !0,
      this._AABBBounds
    );
    const e = this.shouldSelfChangeUpdateAABBBounds(),
      T = this.doUpdateAABBBounds();
    return (
      this.addUpdateLayoutTag(),
      application$1.graphicService.afterUpdateAABBBounds(
        this,
        this.stage,
        this._AABBBounds,
        this,
        e
      ),
      T
    );
  }
  doUpdateLocalMatrix() {
    const {
      x: e = DefaultTransform$1.x,
      y: T = DefaultTransform$1.y,
      dx: C = DefaultTransform$1.dx,
      dy: $ = DefaultTransform$1.dy,
      scaleX: F = DefaultTransform$1.scaleX,
      scaleY: V = DefaultTransform$1.scaleY,
      angle: Y = DefaultTransform$1.angle,
      postMatrix: K,
    } = this.attribute;
    if (
      0 !== e ||
      0 !== T ||
      0 !== C ||
      0 !== $ ||
      1 !== F ||
      1 !== V ||
      0 !== Y ||
      K
    )
      return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  getGraphicTheme() {
    return getTheme$1(this).group;
  }
  updateAABBBounds(e, T, C) {
    const $ = C;
    C = C.clone();
    const { width: F, height: V, path: Y, clip: K = T.clip } = e;
    if (
      (Y && Y.length
        ? Y.forEach((e) => {
            C.union(e.AABBBounds);
          })
        : null != F && null != V && C.set(0, 0, Math.max(0, F), Math.max(0, V)),
      !K)
    ) {
      this.forEachChildren((e) => {
        C.union(e.AABBBounds);
      });
      const { scrollX: T = 0, scrollY: $ = 0 } = e;
      C.translate(T, $);
    }
    return (
      application$1.graphicService.updateTempAABBBounds(C),
      application$1.graphicService.transformAABBBounds(e, C, T, !1, this),
      $.copy(C),
      $
    );
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++;
    const e = super.doUpdateAABBBounds();
    return (
      this.parent && this.parent.addChildUpdateBoundTag(),
      this._emitCustomEvent("AAABBBoundsChange"),
      e
    );
  }
  clearUpdateBoundTag() {
    (this._updateTag &= UpdateTag$1.CLEAR_BOUNDS),
      (this._childUpdateTag &= UpdateTag$1.CLEAR_BOUNDS);
  }
  addUpdateBoundTag() {
    (this._updateTag |= UpdateTag$1.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag$1.UPDATE_BOUNDS ||
      ((this._childUpdateTag |= UpdateTag$1.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(e) {
    const T = super.appendChild(e);
    return (
      this.stage && T && ((T.stage = this.stage), (T.layer = this.layer)),
      this.addUpdateBoundTag(),
      application$1.graphicService.onAddIncremental(e, this, this.stage),
      T
    );
  }
  incrementalClearChild() {
    super.removeAllChild(),
      this.addUpdateBoundTag(),
      application$1.graphicService.onClearIncremental(this, this.stage);
  }
  _updateChildToStage(e) {
    return (
      this.stage && e && e.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      e
    );
  }
  appendChild(e, T = !0) {
    const C = super.appendChild(e);
    return (
      T && this.stage && C && C.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      C
    );
  }
  insertBefore(e, T) {
    return this._updateChildToStage(super.insertBefore(e, T));
  }
  insertAfter(e, T) {
    return this._updateChildToStage(super.insertAfter(e, T));
  }
  insertInto(e, T) {
    return this._updateChildToStage(super.insertInto(e, T));
  }
  removeChild(e) {
    const T = super.removeChild(e);
    return (
      (e.stage = null),
      application$1.graphicService.onRemove(e),
      this.addUpdateBoundTag(),
      T
    );
  }
  removeAllChild(e = !1) {
    this.forEachChildren((T) => {
      application$1.graphicService.onRemove(T),
        e && T.isContainer && T.removeAllChild(e);
    }),
      super.removeAllChild(),
      this.addUpdateBoundTag();
  }
  setStage(e, T) {
    this.stage !== e &&
      ((this.stage = e),
      (this.layer = T),
      this.setStageToShadowRoot(e, T),
      this._onSetStage && this._onSetStage(this, e, T),
      application$1.graphicService.onSetStage(this, e),
      this.forEachChildren((T) => {
        T.setStage(e, this.layer);
      }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(),
      this.forEachChildren((e) => {
        e.isContainer && e.addUpdateGlobalPositionTag();
      });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(),
      this.forEachChildren((e) => {
        e.isContainer && e.addUpdateGlobalPositionTag();
      });
  }
  tryUpdateGlobalTransMatrix(e = !0) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const e = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
        }
      } else
        this._globalTransMatrix = this.parent
          ? this.parent.globalTransMatrix.clone()
          : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), e && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag$1.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(e, T) {
    return this.find((T) => T.name === e, T);
  }
  createOrUpdateChild(e, T, C) {
    let $ = this._getChildByName(e);
    return (
      $
        ? $.setAttributes(T)
        : (($ = application$1.graphicService.creator[C](T)),
          ($.name = e),
          this.add($)),
      $
    );
  }
  clone() {
    return new Group$2(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Group$2.NOWORK_ANIMATE_ATTR;
  }
}
function createGroup$1(e) {
  return new Group$2(e);
}
function textDrawOffsetX$1(e, T) {
  return "end" === e || "right" === e ? -T : "center" === e ? -T / 2 : 0;
}
function textLayoutOffsetY$1(e, T, C, $ = 0) {
  return "middle" === e
    ? -T / 2
    : "top" === e
    ? 0
    : "bottom" === e
    ? $ - T
    : e && "alphabetic" !== e
    ? 0
    : (C || (C = T), -(T - C) / 2 - 0.79 * C);
}
Group$2.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR$1;
class CanvasTextLayout$1 {
  constructor(e, T, C) {
    (this.fontFamily = e), (this.textOptions = T), (this.textMeasure = C);
  }
  LayoutBBox(e, T, C, $) {
    if (
      ((e.xOffset =
        "left" === T || "start" === T
          ? 0
          : "center" === T
          ? e.width / -2
          : "right" === T || "end" === T
          ? -e.width
          : 0),
      "top" === C)
    )
      e.yOffset = 0;
    else if ("middle" === C) e.yOffset = e.height / -2;
    else if ("alphabetic" === C) {
      let T = 0.79;
      if (1 === $.length) {
        const e = $[0];
        T = e.ascent / (e.ascent + e.descent);
      }
      e.yOffset = e.height * -T;
    } else e.yOffset = -e.height;
    return e;
  }
  GetLayoutByLines(e, T, C, $, F = "", V, Y) {
    const {
      lineWidth: K,
      suffixPosition: J = "end",
      measureMode: ee = MeasureModeEnum.actualBounding,
      keepCenterInLine: te = !1,
    } = null != Y ? Y : {};
    e = e.map((e) => e.toString());
    const ie = [],
      ne = [0, 0];
    if ("number" == typeof K && K !== 1 / 0) {
      let T;
      for (let C = 0, $ = e.length; C < $; C++) {
        const $ = this.textMeasure.measureTextPixelADscentAndWidth(
          e[C],
          this.textOptions,
          ee
        );
        let Y = e[C].toString();
        if ($.width > K) {
          const $ = this.textMeasure.clipTextWithSuffix(
            e[C],
            this.textOptions,
            K,
            F,
            V,
            J
          );
          (Y = $.str), (T = $.width);
        } else T = $.width;
        ie.push({
          str: Y,
          width: T,
          ascent: $.ascent,
          descent: $.descent,
          keepCenterInLine: te,
        });
      }
      ne[0] = K;
    } else {
      let T,
        C,
        $ = 0;
      for (let F = 0, V = e.length; F < V; F++) {
        C = e[F];
        const V = this.textMeasure.measureTextPixelADscentAndWidth(
          e[F],
          this.textOptions,
          ee
        );
        (T = V.width),
          ($ = Math.max($, T)),
          ie.push({
            str: C,
            width: T,
            ascent: V.ascent,
            descent: V.descent,
            keepCenterInLine: te,
          });
      }
      ne[0] = $;
    }
    (ne[1] = ie.length * $),
      (ne[0] = ie.reduce((e, T) => Math.max(e, T.width), 0));
    const re = {
      xOffset: 0,
      yOffset: 0,
      width: ne[0],
      height: ne[1],
    };
    return this.LayoutBBox(re, T, C, ie), this.layoutWithBBox(re, ie, T, C, $);
  }
  layoutWithBBox(e, T, C, $, F) {
    const V = [0, 0],
      Y = T.length * F;
    "top" === $ ||
      ("middle" === $
        ? (V[1] = (e.height - Y) / 2)
        : "bottom" === $ && (V[1] = e.height - Y));
    for (let K = 0; K < T.length; K++) this.lineOffset(e, T[K], C, $, F, V);
    return {
      bbox: e,
      lines: T,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight: F,
      textAlign: C,
      textBaseline: $,
    };
  }
  lineOffset(e, T, C, $, F, V) {
    if (
      ("left" === C || "start" === C
        ? (T.leftOffset = 0)
        : "center" === C
        ? (T.leftOffset = (e.width - T.width) / 2)
        : ("right" !== C && "end" !== C) || (T.leftOffset = e.width - T.width),
      (T.topOffset = F / 2 + (T.ascent - T.descent) / 2 + V[1]),
      !T.keepCenterInLine)
    ) {
      const e = 0,
        C = T.ascent + T.descent + e;
      if (
        (C < F - e &&
          ("bottom" === $
            ? (T.topOffset += (F - C) / 2)
            : "top" === $ && (T.topOffset -= (F - C) / 2)),
        "alphabetic" === $)
      ) {
        const e = F / (T.ascent + T.descent);
        T.topOffset = F / 2 + ((T.ascent - T.descent) / 2) * e + V[1];
      }
    }
    return (V[1] += F), T;
  }
}
const TEXT_UPDATE_TAG_KEY$1 = [
  "text",
  "maxLineWidth",
  "maxWidth",
  "textAlign",
  "textBaseline",
  "heightLimit",
  "lineClamp",
  "fontSize",
  "fontFamily",
  "fontWeight",
  "ellipsis",
  "lineHeight",
  "direction",
  "wordBreak",
  "heightLimit",
  "lineClamp",
  ...GRAPHIC_UPDATE_TAG_KEY$1,
];
class Text$2 extends Graphic$1 {
  get font() {
    const e = this.getGraphicTheme();
    return (
      this._font || (this._font = getContextFont$2(this.attribute, e)),
      this._font
    );
  }
  get clipedText() {
    var e;
    const T = this.attribute,
      C = this.getGraphicTheme(),
      $ = this.getMaxWidth(C);
    return Number.isFinite($)
      ? (this.tryUpdateAABBBounds(), this.cache.clipedText)
      : (null !== (e = T.text) && void 0 !== e ? e : C.text).toString();
  }
  get clipedWidth() {
    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    var e, T;
    const C = this.getGraphicTheme(),
      $ = this.attribute,
      F = this.getMaxWidth(C);
    if (!Number.isFinite(F)) return !1;
    const { text: V } = this.attribute;
    if (
      (this.tryUpdateAABBBounds(),
      null ===
        (T =
          null === (e = this.cache) || void 0 === e ? void 0 : e.layoutData) ||
      void 0 === T
        ? void 0
        : T.lines)
    ) {
      let e = "";
      return (
        this.cache.layoutData.lines.forEach((T) => {
          e += T.str;
        }),
        (Array.isArray(V) ? V.join("") : V) !== e
      );
    }
    return "vertical" === $.direction &&
      this.cache.verticalList &&
      this.cache.verticalList[0]
      ? this.cache.verticalList[0].map((e) => e.text).join("") !==
          $.text.toString()
      : null != this.clipedText && this.clipedText !== $.text.toString();
  }
  get multilineLayout() {
    return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  get isMultiLine() {
    return (
      Array.isArray(this.attribute.text) ||
      "normal" === this.attribute.whiteSpace
    );
  }
  constructor(
    e = {
      text: "",
      fontSize: 16,
    }
  ) {
    super(e),
      (this.type = "text"),
      (this.numberType = TEXT_NUMBER_TYPE$1),
      (this.cache = {});
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: e } = this.attribute;
    return isArray$2(e)
      ? !e.every((e) => null == e || "" === e)
      : null != e && "" !== e;
  }
  getGraphicTheme() {
    return getTheme$1(this).text;
  }
  doUpdateOBBBounds() {
    const e = this.getGraphicTheme();
    this._OBBBounds.clear();
    const T = this.attribute,
      { angle: C = e.angle } = T;
    if (!C) {
      const e = this.AABBBounds;
      return this._OBBBounds.setValue(e.x1, e.y1, e.x2, e.y2), this._OBBBounds;
    }
    this.obbText || (this.obbText = new Text$2({})),
      this.obbText.setAttributes(
        Object.assign(Object.assign({}, T), {
          angle: 0,
        })
      );
    const $ = this.obbText.AABBBounds,
      { x: F, y: V } = T,
      Y = {
        x: ($.x1 + $.x2) / 2,
        y: ($.y1 + $.y2) / 2,
      },
      K = rotatePoint(Y, C, {
        x: F,
        y: V,
      });
    return (
      this._OBBBounds.copy($),
      this._OBBBounds.translate(K.x - Y.x, K.y - Y.y),
      (this._OBBBounds.angle = C),
      this._OBBBounds
    );
  }
  updateAABBBounds(e, T, C) {
    const { text: $ = T.text } = this.attribute;
    Array.isArray($)
      ? this.updateMultilineAABBBounds($)
      : this.updateSingallineAABBBounds($);
    const { tb1: F } = application$1.graphicService.updateTempAABBBounds(C),
      {
        scaleX: V = T.scaleX,
        scaleY: Y = T.scaleY,
        shadowBlur: K = T.shadowBlur,
        strokeBoundsBuffer: J = T.strokeBoundsBuffer,
      } = e;
    if (K) {
      boundStroke$1(F, K / Math.abs(V + Y), !0, J), C.union(F);
    }
    return (
      application$1.graphicService.combindShadowAABBBounds(C, this),
      (null == e.forceBoundsHeight && null == e.forceBoundsWidth) ||
        application$1.graphicService.updateHTMLTextAABBBounds(e, T, C),
      transformBoundsWithMatrix$1(C, C, this.transMatrix),
      C
    );
  }
  updateSingallineAABBBounds(e) {
    this.updateMultilineAABBBounds([e]);
    const T = this.cache.layoutData;
    if (T && T.lines && T.lines.length) {
      const e = T.lines[0];
      (this.cache.clipedText = e.str), (this.cache.clipedWidth = e.width);
    }
    return this._AABBBounds;
  }
  updateMultilineAABBBounds(e) {
    const T = this.getGraphicTheme(),
      { direction: C = T.direction, underlineOffset: $ = T.underlineOffset } =
        this.attribute,
      F =
        "horizontal" === C
          ? this.updateHorizontalMultilineAABBBounds(e)
          : this.updateVerticalMultilineAABBBounds(e);
    return (
      "horizontal" === C &&
        $ &&
        this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + $),
      F
    );
  }
  guessLineHeightBuf(e) {
    return e ? 0.1 * e : 0;
  }
  updateHorizontalMultilineAABBBounds(e) {
    var T;
    const C = this.getGraphicTheme(),
      $ = this.attribute,
      {
        fontFamily: F = C.fontFamily,
        textAlign: V = C.textAlign,
        textBaseline: Y = C.textBaseline,
        fontSize: K = C.fontSize,
        fontWeight: J = C.fontWeight,
        ellipsis: ee = C.ellipsis,
        maxLineWidth: te,
        stroke: ie = C.stroke,
        wrap: ne = C.wrap,
        measureMode: re = C.measureMode,
        lineWidth: ae = C.lineWidth,
        whiteSpace: oe = C.whiteSpace,
        suffixPosition: se = C.suffixPosition,
        ignoreBuf: le = C.ignoreBuf,
        keepCenterInLine: de = C.keepCenterInLine,
      } = $,
      ce = le ? 0 : this.guessLineHeightBuf(K),
      ue = this.getLineHeight($, C, ce);
    if ("normal" === oe || ne) return this.updateWrapAABBBounds(e);
    if (
      !this.shouldUpdateShape() &&
      (null === (T = this.cache) || void 0 === T ? void 0 : T.layoutData)
    ) {
      const e = this.cache.layoutData.bbox;
      return (
        this._AABBBounds.set(
          e.xOffset,
          e.yOffset,
          e.xOffset + e.width,
          e.yOffset + e.height
        ),
        ie && this._AABBBounds.expand(ae / 2),
        this._AABBBounds
      );
    }
    const he = application$1.graphicUtil.textMeasure,
      pe = new CanvasTextLayout$1(
        F,
        {
          fontSize: K,
          fontWeight: J,
          fontFamily: F,
          lineHeight: ue,
        },
        he
      ).GetLayoutByLines(
        e,
        V,
        Y,
        ue,
        !0 === ee ? C.ellipsis : ee || void 0,
        !1,
        {
          lineWidth: te,
          suffixPosition: se,
          measureMode: re,
          keepCenterInLine: de,
        }
      ),
      { bbox: ge } = pe;
    return (
      (this.cache.layoutData = pe),
      this.clearUpdateShapeTag(),
      this._AABBBounds.set(
        ge.xOffset,
        ge.yOffset,
        ge.xOffset + ge.width,
        ge.yOffset + ge.height
      ),
      ie && this._AABBBounds.expand(ae / 2),
      this._AABBBounds
    );
  }
  updateWrapAABBBounds(e) {
    var T, C, $;
    const F = this.getGraphicTheme(),
      {
        fontFamily: V = F.fontFamily,
        textAlign: Y = F.textAlign,
        textBaseline: K = F.textBaseline,
        fontSize: J = F.fontSize,
        ellipsis: ee = F.ellipsis,
        maxLineWidth: te,
        stroke: ie = F.stroke,
        lineWidth: ne = F.lineWidth,
        wordBreak: re = F.wordBreak,
        fontWeight: ae = F.fontWeight,
        ignoreBuf: oe = F.ignoreBuf,
        measureMode: se = F.measureMode,
        suffixPosition: le = F.suffixPosition,
        heightLimit: de = 0,
        lineClamp: ce,
        keepCenterInLine: ue = F.keepCenterInLine,
      } = this.attribute,
      he = oe ? 0 : this.guessLineHeightBuf(J),
      pe = this.getLineHeight(this.attribute, F, he);
    if (
      !this.shouldUpdateShape() &&
      (null === (T = this.cache) || void 0 === T ? void 0 : T.layoutData)
    ) {
      const e = this.cache.layoutData.bbox;
      return (
        this._AABBBounds.set(
          e.xOffset,
          e.yOffset,
          e.xOffset + e.width,
          e.yOffset + e.height
        ),
        ie && this._AABBBounds.expand(ne / 2),
        this._AABBBounds
      );
    }
    const ge = application$1.graphicUtil.textMeasure,
      fe = {
        fontSize: J,
        fontWeight: ae,
        fontFamily: V,
        lineHeight: pe,
      },
      me = new CanvasTextLayout$1(V, fe, ge),
      ye = isArray$2(e) ? e.map((e) => e.toString()) : [e.toString()],
      be = [],
      ve = [0, 0];
    let Te = 1 / 0;
    if (
      (de > 0 && (Te = Math.max(Math.floor(de / pe), 1)),
      ce && (Te = Math.min(Te, ce)),
      "number" == typeof te && te !== 1 / 0)
    ) {
      if (te > 0)
        for (let T = 0; T < ye.length; T++) {
          const e = ye[T];
          let F = !0;
          if (T === Te - 1) {
            const C = ge.clipTextWithSuffix(
                e,
                fe,
                te,
                ee,
                !1,
                le,
                T !== ye.length - 1
              ),
              $ = ge.measureTextPixelADscentAndWidth(C.str, fe, se);
            be.push({
              str: C.str,
              width: C.width,
              ascent: $.ascent,
              descent: $.descent,
              keepCenterInLine: ue,
            });
            break;
          }
          const V = ge.clipText(
            e,
            fe,
            te,
            "break-all" !== re,
            "keep-all" === re
          );
          if (("" !== e && "" === V.str) || V.wordBreaked) {
            if (ee) {
              const T = ge.clipTextWithSuffix(e, fe, te, ee, !1, le);
              (V.str = null !== (C = T.str) && void 0 !== C ? C : ""),
                (V.width = null !== ($ = T.width) && void 0 !== $ ? $ : 0);
            } else (V.str = ""), (V.width = 0);
            F = !1;
          }
          const Y = ge.measureTextPixelADscentAndWidth(V.str, fe, se);
          be.push({
            str: V.str,
            width: V.width,
            ascent: Y.ascent,
            descent: Y.descent,
            keepCenterInLine: ue,
          });
          let K = V.str.length;
          if (
            (!V.wordBreaked ||
              ("" !== e && "" === V.str) ||
              ((F = !0), (K = V.wordBreaked)),
            V.str.length === e.length)
          );
          else if (F) {
            let C = e.substring(K);
            "keep-all" === re && (C = C.replace(/^\s+/g, "")),
              ye.splice(T + 1, 0, C);
          }
        }
      let e = 0;
      be.forEach((T) => {
        e = Math.max(e, T.width);
      }),
        (ve[0] = e);
    } else {
      let e,
        T,
        C = 0;
      for (let $ = 0, F = ye.length; $ < F; $++) {
        if ($ === Te - 1) {
          const e = ge.clipTextWithSuffix(ye[$], fe, te, ee, !1, le),
            T = ge.measureTextPixelADscentAndWidth(e.str, fe, se);
          be.push({
            str: e.str,
            width: e.width,
            ascent: T.ascent,
            descent: T.descent,
            keepCenterInLine: ue,
          }),
            (C = Math.max(C, e.width));
          break;
        }
        (T = ye[$]), (e = ge.measureTextWidth(T, fe)), (C = Math.max(C, e));
        const F = ge.measureTextPixelADscentAndWidth(T, fe, se);
        be.push({
          str: T,
          width: e,
          ascent: F.ascent,
          descent: F.descent,
          keepCenterInLine: ue,
        });
      }
      ve[0] = C;
    }
    ve[1] = be.length * pe;
    const _e = {
      xOffset: 0,
      yOffset: 0,
      width: ve[0],
      height: ve[1],
    };
    me.LayoutBBox(_e, Y, K, be);
    const Ce = me.layoutWithBBox(_e, be, Y, K, pe);
    return (
      (this.cache.layoutData = Ce),
      this.clearUpdateShapeTag(),
      this._AABBBounds.set(
        _e.xOffset,
        _e.yOffset,
        _e.xOffset + _e.width,
        _e.yOffset + _e.height
      ),
      ie && this._AABBBounds.expand(ne / 2),
      this._AABBBounds
    );
  }
  updateVerticalMultilineAABBBounds(e) {
    var T, C;
    const $ = this.getGraphicTheme(),
      F = application$1.graphicUtil.textMeasure;
    let V;
    const Y = this.attribute,
      {
        maxLineWidth: K = $.maxLineWidth,
        ellipsis: J = $.ellipsis,
        fontFamily: ee = $.fontFamily,
        fontSize: te = $.fontSize,
        fontWeight: ie = $.fontWeight,
        stroke: ne = $.stroke,
        lineWidth: re = $.lineWidth,
        verticalMode: ae = $.verticalMode,
        suffixPosition: oe = $.suffixPosition,
      } = Y,
      se = this.getLineHeight(Y, $, 0);
    let { textAlign: le = $.textAlign, textBaseline: de = $.textBaseline } = Y;
    if (!ae) {
      const e = le;
      (le =
        null !== (T = Text$2.baselineMapAlign[de]) && void 0 !== T
          ? T
          : "left"),
        (de =
          null !== (C = Text$2.alignMapBaseline[e]) && void 0 !== C
            ? C
            : "top");
    }
    if (((V = 0), !this.shouldUpdateShape() && this.cache)) {
      this.cache.verticalList.forEach((e) => {
        const T = e.reduce((e, T) => e + T.width, 0);
        V = max$1(T, V);
      });
      const e = textDrawOffsetX$1(le, V),
        T = this.cache.verticalList.length * se,
        C = textLayoutOffsetY$1(de, T, te);
      return (
        this._AABBBounds.set(C, e, C + T, e + V),
        ne && this._AABBBounds.expand(re / 2),
        this._AABBBounds
      );
    }
    const ce = e.map((e) => verticalLayout$1(e.toString()));
    ce.forEach((e, T) => {
      if (Number.isFinite(K))
        if (J) {
          const C = !0 === J ? $.ellipsis : J,
            Y = F.clipTextWithSuffixVertical(
              e,
              {
                fontSize: te,
                fontWeight: ie,
                fontFamily: ee,
              },
              K,
              C,
              !1,
              oe
            );
          (ce[T] = Y.verticalList), (V = Y.width);
        } else {
          const C = F.clipTextVertical(
            e,
            {
              fontSize: te,
              fontWeight: ie,
              fontFamily: ee,
            },
            K,
            !1
          );
          (ce[T] = C.verticalList), (V = C.width);
        }
      else
        (V = 0),
          e.forEach((e) => {
            const T =
              e.direction === TextDirection$1.HORIZONTAL
                ? te
                : F.measureTextWidth(e.text, {
                    fontSize: te,
                    fontWeight: ie,
                    fontFamily: ee,
                  });
            (V += T), (e.width = T);
          });
    }),
      (this.cache.verticalList = ce),
      this.clearUpdateShapeTag(),
      this.cache.verticalList.forEach((e) => {
        const T = e.reduce((e, T) => e + T.width, 0);
        V = max$1(T, V);
      });
    const ue = textDrawOffsetX$1(le, V),
      he = this.cache.verticalList.length * se,
      pe = textLayoutOffsetY$1(de, he, te);
    return (
      this._AABBBounds.set(pe, ue, pe + he, ue + V),
      ne && this._AABBBounds.expand(re / 2),
      this._AABBBounds
    );
  }
  getMaxWidth(e) {
    var T, C;
    const $ = this.attribute;
    return null !==
      (C = null !== (T = $.maxLineWidth) && void 0 !== T ? T : $.maxWidth) &&
      void 0 !== C
      ? C
      : e.maxWidth;
  }
  getLineHeight(e, T, C) {
    var $;
    return null !==
      ($ = calculateLineHeight$1(e.lineHeight, e.fontSize || T.fontSize)) &&
      void 0 !== $
      ? $
      : (e.fontSize || T.fontSize) + C;
  }
  needUpdateTags(e, T = TEXT_UPDATE_TAG_KEY$1) {
    return super.needUpdateTags(e, T);
  }
  needUpdateTag(e, T = TEXT_UPDATE_TAG_KEY$1) {
    return super.needUpdateTag(e, T);
  }
  clone() {
    return new Text$2(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Text$2.NOWORK_ANIMATE_ATTR;
  }
  getBaselineMapAlign() {
    return Text$2.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return Text$2.alignMapBaseline;
  }
}
function createText$1(e) {
  return new Text$2(e);
}
(Text$2.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    ellipsis: 1,
    wordBreak: 1,
    direction: 1,
    textAlign: 1,
    textBaseline: 1,
    fontFamily: 1,
    fontWeight: 1,
  },
  NOWORK_ANIMATE_ATTR$1
)),
  (Text$2.baselineMapAlign = {
    top: "left",
    bottom: "right",
    middle: "center",
  }),
  (Text$2.alignMapBaseline = {
    left: "top",
    right: "bottom",
    center: "middle",
  });
const isType = (e, T) => Object.prototype.toString.call(e) === `[object ${T}]`,
  isType$1 = isType,
  isBoolean = (e, T = !1) =>
    T ? "boolean" == typeof e : !0 === e || !1 === e || isType$1(e, "Boolean"),
  isBoolean$1 = isBoolean,
  isFunction = (e) => "function" == typeof e,
  isFunction$1 = isFunction,
  isNil = (e) => null == e,
  isNil$1 = isNil,
  isValid = (e) => null != e,
  isValid$1 = isValid,
  isObject = (e) => {
    const T = typeof e;
    return (null !== e && "object" === T) || "function" === T;
  },
  isObject$1 = isObject,
  isString = (e, T = !1) => {
    const C = typeof e;
    return T ? "string" === C : "string" === C || isType$1(e, "String");
  },
  isString$1 = isString,
  isArray = (e) => (Array.isArray ? Array.isArray(e) : isType$1(e, "Array")),
  isArray$1 = isArray,
  isArrayLike = function (e) {
    return null !== e && "function" != typeof e && Number.isFinite(e.length);
  },
  isArrayLike$1 = isArrayLike,
  isNumber = (e, T = !1) => {
    const C = typeof e;
    return T ? "number" === C : "number" === C || isType$1(e, "Number");
  },
  isNumber$1 = isNumber,
  isValidNumber = (e) => isNumber$1(e) && Number.isFinite(e),
  isValidNumber$1 = isValidNumber,
  isValidUrl = (e) =>
    new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(e),
  isValidUrl$1 = isValidUrl,
  isBase64 = (e) =>
    new RegExp(
      /^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g
    ).test(e),
  isBase64$1 = isBase64,
  hasOwnProperty = Object.prototype.hasOwnProperty,
  has = (e, T) => null != e && hasOwnProperty.call(e, T),
  has$1 = has;
function last(e) {
  if (isArrayLike$1(e)) return e[e.length - 1];
}
const maxInArray = (e, T) => {
    var C;
    if (0 === e.length) return;
    let $ = e[0];
    for (let F = 1; F < e.length; F++) {
      const V = e[F];
      (null !== (C = null == T ? void 0 : T(V, $)) && void 0 !== C
        ? C
        : V - $ > 0) && ($ = V);
    }
    return $;
  },
  minInArray = (e, T) => {
    var C;
    if (0 === e.length) return;
    let $ = e[0];
    for (let F = 1; F < e.length; F++) {
      const V = e[F];
      (null !== (C = null == T ? void 0 : T(V, $)) && void 0 !== C
        ? C
        : V - $ < 0) && ($ = V);
    }
    return $;
  };
function arrayEqual(e, T) {
  if (!isArray$1(e) || !isArray$1(T)) return !1;
  if (e.length !== T.length) return !1;
  for (let C = 0; C < e.length; C++) if (e[C] !== T[C]) return !1;
  return !0;
}
const hasConsole = "undefined" != typeof console;
function log(e, T, C) {
  const $ = [T].concat([].slice.call(C));
  hasConsole && console[e].apply(console, $);
}
var LoggerLevel, LoggerLevel2;
(LoggerLevel2 = LoggerLevel || (LoggerLevel = {})),
  (LoggerLevel2[(LoggerLevel2.None = 0)] = "None"),
  (LoggerLevel2[(LoggerLevel2.Error = 1)] = "Error"),
  (LoggerLevel2[(LoggerLevel2.Warn = 2)] = "Warn"),
  (LoggerLevel2[(LoggerLevel2.Info = 3)] = "Info"),
  (LoggerLevel2[(LoggerLevel2.Debug = 4)] = "Debug");
class Logger {
  static getInstance(e, T) {
    return (
      Logger._instance && isNumber$1(e)
        ? Logger._instance.level(e)
        : Logger._instance || (Logger._instance = new Logger(e, T)),
      Logger._instance
    );
  }
  static setInstance(e) {
    return (Logger._instance = e);
  }
  static setInstanceLevel(e) {
    Logger._instance
      ? Logger._instance.level(e)
      : (Logger._instance = new Logger(e));
  }
  static clearInstance() {
    Logger._instance = null;
  }
  constructor(e = LoggerLevel.None, T) {
    (this._onErrorHandler = []), (this._level = e), (this._method = T);
  }
  addErrorHandler(e) {
    this._onErrorHandler.find((T) => T === e) || this._onErrorHandler.push(e);
  }
  removeErrorHandler(e) {
    const T = this._onErrorHandler.findIndex((T) => T === e);
    T < 0 || this._onErrorHandler.splice(T, 1);
  }
  callErrorHandler(...e) {
    this._onErrorHandler.forEach((T) => T(...e));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(e) {
    return arguments.length ? ((this._level = +e), this) : this._level;
  }
  error(...e) {
    var T;
    return (
      this._level >= LoggerLevel.Error &&
        (this._onErrorHandler.length
          ? this.callErrorHandler(...e)
          : log(
              null !== (T = this._method) && void 0 !== T ? T : "error",
              "ERROR",
              e
            )),
      this
    );
  }
  warn(...e) {
    return (
      this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", e),
      this
    );
  }
  info(...e) {
    return (
      this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", e),
      this
    );
  }
  debug(...e) {
    return (
      this._level >= LoggerLevel.Debug &&
        log(this._method || "log", "DEBUG", e),
      this
    );
  }
}
Logger._instance = null;
const clamp = function (e, T, C) {
    return e < T ? T : e > C ? C : e;
  },
  clamp$1 = clamp,
  epsilon = 1e-12,
  pi = Math.PI,
  halfPi$1 = pi / 2,
  tau = 2 * pi,
  pi2 = 2 * Math.PI,
  abs = Math.abs,
  atan2 = Math.atan2,
  cos = Math.cos,
  max = Math.max,
  min = Math.min,
  sin = Math.sin,
  sqrt = Math.sqrt,
  pow = Math.pow;
function acos(e) {
  return e > 1 ? 0 : e < -1 ? pi : Math.acos(e);
}
function asin(e) {
  return e >= 1 ? halfPi$1 : e <= -1 ? -halfPi$1 : Math.asin(e);
}
function pointAt(e, T, C, $, F) {
  let V = C,
    Y = $;
  return (
    "number" == typeof e && "number" == typeof C && (V = (1 - F) * e + F * C),
    "number" == typeof T && "number" == typeof $ && (Y = (1 - F) * T + F * $),
    {
      x: V,
      y: Y,
    }
  );
}
class Point {
  constructor(e = 0, T = 0, C, $) {
    (this.x = 0),
      (this.y = 0),
      (this.x = e),
      (this.y = T),
      (this.x1 = C),
      (this.y1 = $);
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.x1 = e.x1),
      (this.y1 = e.y1),
      (this.defined = e.defined),
      (this.context = e.context),
      this
    );
  }
  set(e, T) {
    return (this.x = e), (this.y = T), this;
  }
  add(e) {
    return isNumber$1(e)
      ? ((this.x += e), void (this.y += e))
      : ((this.x += e.x), (this.y += e.y), this);
  }
  sub(e) {
    return isNumber$1(e)
      ? ((this.x -= e), void (this.y -= e))
      : ((this.x -= e.x), (this.y -= e.y), this);
  }
  multi(e) {
    throw new Error("");
  }
  div(e) {
    throw new Error("");
  }
}
class PointService {
  static distancePP(e, T) {
    return sqrt(pow(e.x - T.x, 2) + pow(e.y - T.y, 2));
  }
  static distanceNN(e, T, C, $) {
    return sqrt(pow(e - C, 2) + pow(T - $, 2));
  }
  static distancePN(e, T, C) {
    return sqrt(pow(T - e.x, 2) + pow(C - e.y, 2));
  }
  static pointAtPP(e, T, C) {
    return new Point((T.x - e.x) * C + e.x, (T.y - e.y) * C + e.y);
  }
}
function degreeToRadian(e) {
  return e * (Math.PI / 180);
}
function radianToDegree(e) {
  return (180 * e) / Math.PI;
}
const clampRadian = (e = 0) => {
    if (e < 0) for (; e < -tau; ) e += tau;
    else if (e > 0) for (; e > tau; ) e -= tau;
    return e;
  },
  clampAngleByRadian = clampRadian;
function getRectIntersect(e, T, C) {
  if (null === e) return T;
  if (null === T) return e;
  const {
    x11: $,
    x12: F,
    y11: V,
    y12: Y,
    x21: K,
    x22: J,
    y21: ee,
    y22: te,
  } = formatTwoBBox(e, T, C);
  return $ >= J || F <= K || V >= te || Y <= ee
    ? {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
      }
    : {
        x1: Math.max($, K),
        y1: Math.max(V, ee),
        x2: Math.min(F, J),
        y2: Math.min(Y, te),
      };
}
var InnerBBox, InnerBBox2;
(InnerBBox2 = InnerBBox || (InnerBBox = {})),
  (InnerBBox2[(InnerBBox2.NONE = 0)] = "NONE"),
  (InnerBBox2[(InnerBBox2.BBOX1 = 1)] = "BBOX1"),
  (InnerBBox2[(InnerBBox2.BBOX2 = 2)] = "BBOX2");
const formatTwoBBox = (e, T, C) => {
  let $ = e.x1,
    F = e.x2,
    V = e.y1,
    Y = e.y2,
    K = T.x1,
    J = T.x2,
    ee = T.y1,
    te = T.y2;
  return (
    C &&
      ($ > F && ([$, F] = [F, $]),
      V > Y && ([V, Y] = [Y, V]),
      K > J && ([K, J] = [J, K]),
      ee > te && ([ee, te] = [te, ee])),
    {
      x11: $,
      x12: F,
      y11: V,
      y12: Y,
      x21: K,
      x22: J,
      y21: ee,
      y22: te,
    }
  );
};
function isRectIntersect(e, T, C) {
  if (e && T) {
    if (!C) return !(e.x1 > T.x2 || e.x2 < T.x1 || e.y1 > T.y2 || e.y2 < T.y1);
    const {
      x11: $,
      x12: F,
      y11: V,
      y12: Y,
      x21: K,
      x22: J,
      y21: ee,
      y22: te,
    } = formatTwoBBox(e, T, !0);
    return !($ > J || F < K || V > te || Y < ee);
  }
  return !0;
}
const eastAsianCharacterInfo = (e) => {
  let T = e.charCodeAt(0),
    C = 2 === e.length ? e.charCodeAt(1) : 0,
    $ = T;
  return (
    55296 <= T &&
      T <= 56319 &&
      56320 <= C &&
      C <= 57343 &&
      ((T &= 1023), (C &= 1023), ($ = (T << 10) | C), ($ += 65536)),
    12288 === $ || (65281 <= $ && $ <= 65376) || (65504 <= $ && $ <= 65510)
      ? "F"
      : 8361 === $ ||
        (65377 <= $ && $ <= 65470) ||
        (65474 <= $ && $ <= 65479) ||
        (65482 <= $ && $ <= 65487) ||
        (65490 <= $ && $ <= 65495) ||
        (65498 <= $ && $ <= 65500) ||
        (65512 <= $ && $ <= 65518)
      ? "H"
      : (4352 <= $ && $ <= 4447) ||
        (4515 <= $ && $ <= 4519) ||
        (4602 <= $ && $ <= 4607) ||
        (9001 <= $ && $ <= 9002) ||
        (11904 <= $ && $ <= 11929) ||
        (11931 <= $ && $ <= 12019) ||
        (12032 <= $ && $ <= 12245) ||
        (12272 <= $ && $ <= 12283) ||
        (12289 <= $ && $ <= 12350) ||
        (12353 <= $ && $ <= 12438) ||
        (12441 <= $ && $ <= 12543) ||
        (12549 <= $ && $ <= 12589) ||
        (12593 <= $ && $ <= 12686) ||
        (12688 <= $ && $ <= 12730) ||
        (12736 <= $ && $ <= 12771) ||
        (12784 <= $ && $ <= 12830) ||
        (12832 <= $ && $ <= 12871) ||
        (12880 <= $ && $ <= 13054) ||
        (13056 <= $ && $ <= 19903) ||
        (19968 <= $ && $ <= 42124) ||
        (42128 <= $ && $ <= 42182) ||
        (43360 <= $ && $ <= 43388) ||
        (44032 <= $ && $ <= 55203) ||
        (55216 <= $ && $ <= 55238) ||
        (55243 <= $ && $ <= 55291) ||
        (63744 <= $ && $ <= 64255) ||
        (65040 <= $ && $ <= 65049) ||
        (65072 <= $ && $ <= 65106) ||
        (65108 <= $ && $ <= 65126) ||
        (65128 <= $ && $ <= 65131) ||
        (110592 <= $ && $ <= 110593) ||
        (127488 <= $ && $ <= 127490) ||
        (127504 <= $ && $ <= 127546) ||
        (127552 <= $ && $ <= 127560) ||
        (127568 <= $ && $ <= 127569) ||
        (131072 <= $ && $ <= 194367) ||
        (177984 <= $ && $ <= 196605) ||
        (196608 <= $ && $ <= 262141)
      ? "W"
      : (32 <= $ && $ <= 126) ||
        (162 <= $ && $ <= 163) ||
        (165 <= $ && $ <= 166) ||
        172 === $ ||
        175 === $ ||
        (10214 <= $ && $ <= 10221) ||
        (10629 <= $ && $ <= 10630)
      ? "Na"
      : 161 === $ ||
        164 === $ ||
        (167 <= $ && $ <= 168) ||
        170 === $ ||
        (173 <= $ && $ <= 174) ||
        (176 <= $ && $ <= 180) ||
        (182 <= $ && $ <= 186) ||
        (188 <= $ && $ <= 191) ||
        198 === $ ||
        208 === $ ||
        (215 <= $ && $ <= 216) ||
        (222 <= $ && $ <= 225) ||
        230 === $ ||
        (232 <= $ && $ <= 234) ||
        (236 <= $ && $ <= 237) ||
        240 === $ ||
        (242 <= $ && $ <= 243) ||
        (247 <= $ && $ <= 250) ||
        252 === $ ||
        254 === $ ||
        257 === $ ||
        273 === $ ||
        275 === $ ||
        283 === $ ||
        (294 <= $ && $ <= 295) ||
        299 === $ ||
        (305 <= $ && $ <= 307) ||
        312 === $ ||
        (319 <= $ && $ <= 322) ||
        324 === $ ||
        (328 <= $ && $ <= 331) ||
        333 === $ ||
        (338 <= $ && $ <= 339) ||
        (358 <= $ && $ <= 359) ||
        363 === $ ||
        462 === $ ||
        464 === $ ||
        466 === $ ||
        468 === $ ||
        470 === $ ||
        472 === $ ||
        474 === $ ||
        476 === $ ||
        593 === $ ||
        609 === $ ||
        708 === $ ||
        711 === $ ||
        (713 <= $ && $ <= 715) ||
        717 === $ ||
        720 === $ ||
        (728 <= $ && $ <= 731) ||
        733 === $ ||
        735 === $ ||
        (768 <= $ && $ <= 879) ||
        (913 <= $ && $ <= 929) ||
        (931 <= $ && $ <= 937) ||
        (945 <= $ && $ <= 961) ||
        (963 <= $ && $ <= 969) ||
        1025 === $ ||
        (1040 <= $ && $ <= 1103) ||
        1105 === $ ||
        8208 === $ ||
        (8211 <= $ && $ <= 8214) ||
        (8216 <= $ && $ <= 8217) ||
        (8220 <= $ && $ <= 8221) ||
        (8224 <= $ && $ <= 8226) ||
        (8228 <= $ && $ <= 8231) ||
        8240 === $ ||
        (8242 <= $ && $ <= 8243) ||
        8245 === $ ||
        8251 === $ ||
        8254 === $ ||
        8308 === $ ||
        8319 === $ ||
        (8321 <= $ && $ <= 8324) ||
        8364 === $ ||
        8451 === $ ||
        8453 === $ ||
        8457 === $ ||
        8467 === $ ||
        8470 === $ ||
        (8481 <= $ && $ <= 8482) ||
        8486 === $ ||
        8491 === $ ||
        (8531 <= $ && $ <= 8532) ||
        (8539 <= $ && $ <= 8542) ||
        (8544 <= $ && $ <= 8555) ||
        (8560 <= $ && $ <= 8569) ||
        8585 === $ ||
        (8592 <= $ && $ <= 8601) ||
        (8632 <= $ && $ <= 8633) ||
        8658 === $ ||
        8660 === $ ||
        8679 === $ ||
        8704 === $ ||
        (8706 <= $ && $ <= 8707) ||
        (8711 <= $ && $ <= 8712) ||
        8715 === $ ||
        8719 === $ ||
        8721 === $ ||
        8725 === $ ||
        8730 === $ ||
        (8733 <= $ && $ <= 8736) ||
        8739 === $ ||
        8741 === $ ||
        (8743 <= $ && $ <= 8748) ||
        8750 === $ ||
        (8756 <= $ && $ <= 8759) ||
        (8764 <= $ && $ <= 8765) ||
        8776 === $ ||
        8780 === $ ||
        8786 === $ ||
        (8800 <= $ && $ <= 8801) ||
        (8804 <= $ && $ <= 8807) ||
        (8810 <= $ && $ <= 8811) ||
        (8814 <= $ && $ <= 8815) ||
        (8834 <= $ && $ <= 8835) ||
        (8838 <= $ && $ <= 8839) ||
        8853 === $ ||
        8857 === $ ||
        8869 === $ ||
        8895 === $ ||
        8978 === $ ||
        (9312 <= $ && $ <= 9449) ||
        (9451 <= $ && $ <= 9547) ||
        (9552 <= $ && $ <= 9587) ||
        (9600 <= $ && $ <= 9615) ||
        (9618 <= $ && $ <= 9621) ||
        (9632 <= $ && $ <= 9633) ||
        (9635 <= $ && $ <= 9641) ||
        (9650 <= $ && $ <= 9651) ||
        (9654 <= $ && $ <= 9655) ||
        (9660 <= $ && $ <= 9661) ||
        (9664 <= $ && $ <= 9665) ||
        (9670 <= $ && $ <= 9672) ||
        9675 === $ ||
        (9678 <= $ && $ <= 9681) ||
        (9698 <= $ && $ <= 9701) ||
        9711 === $ ||
        (9733 <= $ && $ <= 9734) ||
        9737 === $ ||
        (9742 <= $ && $ <= 9743) ||
        (9748 <= $ && $ <= 9749) ||
        9756 === $ ||
        9758 === $ ||
        9792 === $ ||
        9794 === $ ||
        (9824 <= $ && $ <= 9825) ||
        (9827 <= $ && $ <= 9829) ||
        (9831 <= $ && $ <= 9834) ||
        (9836 <= $ && $ <= 9837) ||
        9839 === $ ||
        (9886 <= $ && $ <= 9887) ||
        (9918 <= $ && $ <= 9919) ||
        (9924 <= $ && $ <= 9933) ||
        (9935 <= $ && $ <= 9953) ||
        9955 === $ ||
        (9960 <= $ && $ <= 9983) ||
        10045 === $ ||
        10071 === $ ||
        (10102 <= $ && $ <= 10111) ||
        (11093 <= $ && $ <= 11097) ||
        (12872 <= $ && $ <= 12879) ||
        (57344 <= $ && $ <= 63743) ||
        (65024 <= $ && $ <= 65039) ||
        65533 === $ ||
        (127232 <= $ && $ <= 127242) ||
        (127248 <= $ && $ <= 127277) ||
        (127280 <= $ && $ <= 127337) ||
        (127344 <= $ && $ <= 127386) ||
        (917760 <= $ && $ <= 917999) ||
        (983040 <= $ && $ <= 1048573) ||
        (1048576 <= $ && $ <= 1114109)
      ? "A"
      : "N"
  );
};
function getContextFont$1(e, T = {}, C) {
  C || (C = 1);
  const {
    fontStyle: $ = T.fontStyle,
    fontVariant: F = T.fontVariant,
    fontWeight: V = T.fontWeight,
    fontSize: Y = T.fontSize,
    fontFamily: K = T.fontFamily,
  } = e;
  return (
    ($ ? $ + " " : "") +
    (F ? F + " " : "") +
    (V ? V + " " : "") +
    Y * C +
    "px " +
    (K || "sans-serif")
  );
}
class TextMeasure {
  constructor(e, T) {
    (this._numberCharSize = null),
      (this._fullCharSize = null),
      (this._letterCharSize = null),
      (this._specialCharSizeMap = {}),
      (this._canvas = null),
      (this._context = null),
      (this._contextSaved = !1),
      (this._notSupportCanvas = !1),
      (this._notSupportVRender = !1),
      (this._userSpec = {}),
      (this.specialCharSet = "-/: .,@%'\"~"),
      (this._option = e),
      (this._userSpec = null != T ? T : {}),
      (this.textSpec = this._initSpec()),
      isValid$1(e.specialCharSet) && (this.specialCharSet = e.specialCharSet),
      (this._standardMethod = isValid$1(e.getTextBounds)
        ? this.fullMeasure.bind(this)
        : this.measureWithNaiveCanvas.bind(this));
  }
  initContext() {
    if (this._notSupportCanvas) return !1;
    if (
      (isNil$1(this._canvas) &&
        (isValid$1(this._option.getCanvasForMeasure) &&
          (this._canvas = this._option.getCanvasForMeasure()),
        isNil$1(this._canvas) &&
          "undefined" != typeof window &&
          void 0 !== window.document &&
          globalThis &&
          isValid$1(globalThis.document) &&
          (this._canvas = globalThis.document.createElement("canvas"))),
      isNil$1(this._context) && isValid$1(this._canvas))
    ) {
      const e = this._canvas.getContext("2d");
      isValid$1(e) &&
        (e.save(),
        (e.font = getContextFont$1(this.textSpec)),
        (this._contextSaved = !0),
        (this._context = e));
    }
    return !isNil$1(this._context) || ((this._notSupportCanvas = !0), !1);
  }
  _initSpec() {
    var e, T, C;
    const { defaultFontParams: $ = {} } = this._option,
      {
        fontStyle: F = $.fontStyle,
        fontVariant: V = $.fontVariant,
        fontWeight: Y = null !== (e = $.fontWeight) && void 0 !== e
          ? e
          : "normal",
        fontSize: K = null !== (T = $.fontSize) && void 0 !== T ? T : 12,
        fontFamily: J = null !== (C = $.fontFamily) && void 0 !== C
          ? C
          : "sans-serif",
        align: ee,
        textAlign: te = null != ee ? ee : "center",
        baseline: ie,
        textBaseline: ne = null != ie ? ie : "middle",
        ellipsis: re,
        limit: ae,
      } = this._userSpec;
    let { lineHeight: oe = K } = this._userSpec;
    if (isString$1(oe) && "%" === oe[oe.length - 1]) {
      const e = Number.parseFloat(oe.substring(0, oe.length - 1)) / 100;
      oe = K * e;
    }
    return {
      fontStyle: F,
      fontVariant: V,
      fontFamily: J,
      fontSize: K,
      fontWeight: Y,
      textAlign: te,
      textBaseline: ne,
      ellipsis: re,
      limit: ae,
      lineHeight: oe,
    };
  }
  measure(e, T) {
    switch (T) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(e);
      case "canvas":
        return this.measureWithNaiveCanvas(e);
      case "simple":
        return this.quickMeasureWithoutCanvas(e);
      default:
        return this.quickMeasure(e);
    }
  }
  fullMeasure(e) {
    if (isNil$1(e))
      return {
        width: 0,
        height: 0,
      };
    if (isNil$1(this._option.getTextBounds) || !this._notSupportVRender)
      return this.measureWithNaiveCanvas(e);
    const {
      fontFamily: T,
      fontSize: C,
      fontWeight: $,
      textAlign: F,
      textBaseline: V,
      ellipsis: Y,
      limit: K,
      lineHeight: J,
    } = this.textSpec;
    let ee;
    try {
      const te = this._option.getTextBounds({
        text: e,
        fontFamily: T,
        fontSize: C,
        fontWeight: $,
        textAlign: F,
        textBaseline: V,
        ellipsis: !!Y,
        maxLineWidth: K || 1 / 0,
        lineHeight: J,
      });
      ee = {
        width: te.width(),
        height: te.height(),
      };
    } catch (te) {
      (this._notSupportVRender = !0), (ee = this.measureWithNaiveCanvas(e));
    }
    return ee;
  }
  measureWithNaiveCanvas(e) {
    return this._measureReduce(e, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(e) {
    var T;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(e);
    const C = this._context.measureText(e),
      { fontSize: $, lineHeight: F } = this.textSpec;
    return {
      width: C.width,
      height: null !== (T = F) && void 0 !== T ? T : $,
    };
  }
  quickMeasure(e) {
    return this._measureReduce(e, this._quickMeasure.bind(this));
  }
  _quickMeasure(e) {
    const T = {
      width: 0,
      height: 0,
    };
    for (let C = 0; C < e.length; C++) {
      const $ = e[C];
      let F = this._measureSpecialChar($);
      isNil$1(F) &&
        TextMeasure.NUMBERS_CHAR_SET.includes($) &&
        (F = this._measureNumberChar()),
        isNil$1(F) &&
          ["F", "W"].includes(eastAsianCharacterInfo($)) &&
          (F = this._measureFullSizeChar()),
        isNil$1(F) && (F = this._measureLetterChar()),
        (T.width += F.width),
        (T.height = Math.max(T.height, F.height));
    }
    return T;
  }
  quickMeasureWithoutCanvas(e) {
    return this._measureReduce(e, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(e) {
    var T;
    const C = {
        width: 0,
        height: 0,
      },
      { fontSize: $, lineHeight: F } = this.textSpec;
    for (let V = 0; V < e.length; V++) {
      const T = e[V],
        F = ["F", "W"].includes(eastAsianCharacterInfo(T)) ? 1 : 0.53;
      C.width += F * $;
    }
    return (C.height = null !== (T = F) && void 0 !== T ? T : $), C;
  }
  _measureReduce(e, T) {
    var C;
    const { fontSize: $, lineHeight: F } = this.textSpec,
      V = {
        width: 0,
        height: 0,
      };
    if (isNil$1(e)) return V;
    if (isArray$1(e)) {
      const Y = e.filter(isValid$1).map((e) => e.toString());
      return 0 === Y.length
        ? V
        : 1 === Y.length
        ? T(Y[0])
        : {
            width: Y.reduce((e, C) => Math.max(e, T(C).width), 0),
            height:
              Y.length * ((null !== (C = F) && void 0 !== C ? C : $) + 1) + 1,
          };
    }
    return T(e.toString());
  }
  _measureNumberChar() {
    if (isNil$1(this._numberCharSize)) {
      const e = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: e.width / TextMeasure.NUMBERS_CHAR_SET.length,
        height: e.height,
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return (
      isNil$1(this._fullCharSize) &&
        (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)),
      this._fullCharSize
    );
  }
  _measureLetterChar() {
    if (isNil$1(this._letterCharSize)) {
      const e = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: e.width / TextMeasure.ALPHABET_CHAR_SET.length,
        height: e.height,
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(e) {
    return isValid$1(this._specialCharSizeMap[e])
      ? this._specialCharSizeMap[e]
      : this.specialCharSet.includes(e)
      ? ((this._specialCharSizeMap[e] = this._standardMethod(e)),
        this._specialCharSizeMap[e])
      : null;
  }
  release() {
    isValid$1(this._canvas) && (this._canvas = null),
      isValid$1(this._context) &&
        (this._contextSaved &&
          (this._context.restore(), (this._contextSaved = !1)),
        (this._context = null));
  }
}
function transformBoundsWithMatrix(e, T, C) {
  const { x1: $, y1: F, x2: V, y2: Y } = T;
  return C.onlyTranslate()
    ? (e !== T && e.setValue(T.x1, T.y1, T.x2, T.y2), e.translate(C.e, C.f), T)
    : (e.clear(),
      e.add(C.a * $ + C.c * F + C.e, C.b * $ + C.d * F + C.f),
      e.add(C.a * V + C.c * F + C.e, C.b * V + C.d * F + C.f),
      e.add(C.a * V + C.c * Y + C.e, C.b * V + C.d * Y + C.f),
      e.add(C.a * $ + C.c * Y + C.e, C.b * $ + C.d * Y + C.f),
      T);
}
(TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz"),
  (TextMeasure.NUMBERS_CHAR_SET = "0123456789"),
  (TextMeasure.FULL_SIZE_CHAR = "");
class Bounds {
  constructor(e) {
    e ? this.setValue(e.x1, e.y1, e.x2, e.y2) : this.clear();
  }
  clone() {
    return new Bounds(this);
  }
  clear() {
    return (
      (this.x1 = +Number.MAX_VALUE),
      (this.y1 = +Number.MAX_VALUE),
      (this.x2 = -Number.MAX_VALUE),
      (this.y2 = -Number.MAX_VALUE),
      this
    );
  }
  empty() {
    return (
      this.x1 === +Number.MAX_VALUE &&
      this.y1 === +Number.MAX_VALUE &&
      this.x2 === -Number.MAX_VALUE &&
      this.y2 === -Number.MAX_VALUE
    );
  }
  equals(e) {
    return (
      this.x1 === e.x1 &&
      this.y1 === e.y1 &&
      this.x2 === e.x2 &&
      this.y2 === e.y2
    );
  }
  setValue(e = 0, T = 0, C = 0, $ = 0) {
    return (this.x1 = e), (this.y1 = T), (this.x2 = C), (this.y2 = $), this;
  }
  set(e = 0, T = 0, C = 0, $ = 0) {
    return (
      C < e ? ((this.x2 = e), (this.x1 = C)) : ((this.x1 = e), (this.x2 = C)),
      $ < T ? ((this.y2 = T), (this.y1 = $)) : ((this.y1 = T), (this.y2 = $)),
      this
    );
  }
  add(e = 0, T = 0) {
    return (
      e < this.x1 && (this.x1 = e),
      T < this.y1 && (this.y1 = T),
      e > this.x2 && (this.x2 = e),
      T > this.y2 && (this.y2 = T),
      this
    );
  }
  expand(e = 0) {
    return (
      isArray$1(e)
        ? ((this.y1 -= e[0]),
          (this.x2 += e[1]),
          (this.y2 += e[2]),
          (this.x1 -= e[3]))
        : ((this.x1 -= e), (this.y1 -= e), (this.x2 += e), (this.y2 += e)),
      this
    );
  }
  round() {
    return (
      (this.x1 = Math.floor(this.x1)),
      (this.y1 = Math.floor(this.y1)),
      (this.x2 = Math.ceil(this.x2)),
      (this.y2 = Math.ceil(this.y2)),
      this
    );
  }
  translate(e = 0, T = 0) {
    return (this.x1 += e), (this.x2 += e), (this.y1 += T), (this.y2 += T), this;
  }
  rotate(e = 0, T = 0, C = 0) {
    const $ = this.rotatedPoints(e, T, C);
    return this.clear()
      .add($[0], $[1])
      .add($[2], $[3])
      .add($[4], $[5])
      .add($[6], $[7]);
  }
  scale(e = 0, T = 0, C = 0, $ = 0) {
    const F = this.scalePoints(e, T, C, $);
    return this.clear().add(F[0], F[1]).add(F[2], F[3]);
  }
  union(e) {
    return (
      e.x1 < this.x1 && (this.x1 = e.x1),
      e.y1 < this.y1 && (this.y1 = e.y1),
      e.x2 > this.x2 && (this.x2 = e.x2),
      e.y2 > this.y2 && (this.y2 = e.y2),
      this
    );
  }
  intersect(e) {
    return (
      e.x1 > this.x1 && (this.x1 = e.x1),
      e.y1 > this.y1 && (this.y1 = e.y1),
      e.x2 < this.x2 && (this.x2 = e.x2),
      e.y2 < this.y2 && (this.y2 = e.y2),
      this
    );
  }
  encloses(e) {
    return (
      e &&
      this.x1 <= e.x1 &&
      this.x2 >= e.x2 &&
      this.y1 <= e.y1 &&
      this.y2 >= e.y2
    );
  }
  alignsWith(e) {
    return (
      e &&
      (this.x1 === e.x1 ||
        this.x2 === e.x2 ||
        this.y1 === e.y1 ||
        this.y2 === e.y2)
    );
  }
  intersects(e) {
    return (
      e &&
      !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2)
    );
  }
  contains(e = 0, T = 0) {
    return !(e < this.x1 || e > this.x2 || T < this.y1 || T > this.y2);
  }
  containsPoint(e) {
    return !(e.x < this.x1 || e.x > this.x2 || e.y < this.y1 || e.y > this.y2);
  }
  width() {
    return this.empty() ? 0 : this.x2 - this.x1;
  }
  height() {
    return this.empty() ? 0 : this.y2 - this.y1;
  }
  scaleX(e = 0) {
    return (this.x1 *= e), (this.x2 *= e), this;
  }
  scaleY(e = 0) {
    return (this.y1 *= e), (this.y2 *= e), this;
  }
  transformWithMatrix(e) {
    return transformBoundsWithMatrix(this, this, e), this;
  }
  copy(e) {
    return (
      (this.x1 = e.x1),
      (this.y1 = e.y1),
      (this.x2 = e.x2),
      (this.y2 = e.y2),
      this
    );
  }
  rotatedPoints(e, T, C) {
    const { x1: $, y1: F, x2: V, y2: Y } = this,
      K = Math.cos(e),
      J = Math.sin(e),
      ee = T - T * K + C * J,
      te = C - T * J - C * K;
    return [
      K * $ - J * F + ee,
      J * $ + K * F + te,
      K * $ - J * Y + ee,
      J * $ + K * Y + te,
      K * V - J * F + ee,
      J * V + K * F + te,
      K * V - J * Y + ee,
      J * V + K * Y + te,
    ];
  }
  scalePoints(e, T, C, $) {
    const { x1: F, y1: V, x2: Y, y2: K } = this;
    return [
      e * F + (1 - e) * C,
      T * V + (1 - T) * $,
      e * Y + (1 - e) * C,
      T * K + (1 - T) * $,
    ];
  }
}
class AABBBounds extends Bounds {}
class Matrix {
  constructor(e = 1, T = 0, C = 0, $ = 1, F = 0, V = 0) {
    (this.a = e),
      (this.b = T),
      (this.c = C),
      (this.d = $),
      (this.e = F),
      (this.f = V);
  }
  equalToMatrix(e) {
    return !(
      this.e !== e.e ||
      this.f !== e.f ||
      this.a !== e.a ||
      this.d !== e.d ||
      this.b !== e.b ||
      this.c !== e.c
    );
  }
  equalTo(e, T, C, $, F, V) {
    return !(
      this.e !== F ||
      this.f !== V ||
      this.a !== e ||
      this.d !== $ ||
      this.b !== T ||
      this.c !== C
    );
  }
  setValue(e, T, C, $, F, V) {
    return (
      (this.a = e),
      (this.b = T),
      (this.c = C),
      (this.d = $),
      (this.e = F),
      (this.f = V),
      this
    );
  }
  reset() {
    return (
      (this.a = 1),
      (this.b = 0),
      (this.c = 0),
      (this.d = 1),
      (this.e = 0),
      (this.f = 0),
      this
    );
  }
  getInverse() {
    const e = this.a,
      T = this.b,
      C = this.c,
      $ = this.d,
      F = this.e,
      V = this.f,
      Y = new Matrix(),
      K = e * $ - T * C;
    return (
      (Y.a = $ / K),
      (Y.b = -T / K),
      (Y.c = -C / K),
      (Y.d = e / K),
      (Y.e = (C * V - $ * F) / K),
      (Y.f = -(e * V - T * F) / K),
      Y
    );
  }
  rotate(e) {
    const T = Math.cos(e),
      C = Math.sin(e),
      $ = this.a * T + this.c * C,
      F = this.b * T + this.d * C,
      V = this.a * -C + this.c * T,
      Y = this.b * -C + this.d * T;
    return (this.a = $), (this.b = F), (this.c = V), (this.d = Y), this;
  }
  rotateByCenter(e, T, C) {
    const $ = Math.cos(e),
      F = Math.sin(e),
      V = (1 - $) * T + F * C,
      Y = (1 - $) * C - F * T,
      K = $ * this.a - F * this.b,
      J = F * this.a + $ * this.b,
      ee = $ * this.c - F * this.d,
      te = F * this.c + $ * this.d,
      ie = $ * this.e - F * this.f + V,
      ne = F * this.e + $ * this.f + Y;
    return (
      (this.a = K),
      (this.b = J),
      (this.c = ee),
      (this.d = te),
      (this.e = ie),
      (this.f = ne),
      this
    );
  }
  scale(e, T) {
    return (this.a *= e), (this.b *= e), (this.c *= T), (this.d *= T), this;
  }
  setScale(e, T) {
    return (
      (this.b = (this.b / this.a) * e),
      (this.c = (this.c / this.d) * T),
      (this.a = e),
      (this.d = T),
      this
    );
  }
  transform(e, T, C, $, F, V) {
    return this.multiply(e, T, C, $, F, V), this;
  }
  translate(e, T) {
    return (
      (this.e += this.a * e + this.c * T),
      (this.f += this.b * e + this.d * T),
      this
    );
  }
  transpose() {
    const { a: e, b: T, c: C, d: $, e: F, f: V } = this;
    return (
      (this.a = T),
      (this.b = e),
      (this.c = $),
      (this.d = C),
      (this.e = V),
      (this.f = F),
      this
    );
  }
  multiply(e, T, C, $, F, V) {
    const Y = this.a,
      K = this.b,
      J = this.c,
      ee = this.d,
      te = Y * e + J * T,
      ie = K * e + ee * T,
      ne = Y * C + J * $,
      re = K * C + ee * $,
      ae = Y * F + J * V + this.e,
      oe = K * F + ee * V + this.f;
    return (
      (this.a = te),
      (this.b = ie),
      (this.c = ne),
      (this.d = re),
      (this.e = ae),
      (this.f = oe),
      this
    );
  }
  interpolate(e, T) {
    const C = new Matrix();
    return (
      (C.a = this.a + (e.a - this.a) * T),
      (C.b = this.b + (e.b - this.b) * T),
      (C.c = this.c + (e.c - this.c) * T),
      (C.d = this.d + (e.d - this.d) * T),
      (C.e = this.e + (e.e - this.e) * T),
      (C.f = this.f + (e.f - this.f) * T),
      C
    );
  }
  transformPoint(e, T) {
    const { a: C, b: $, c: F, d: V, e: Y, f: K } = this,
      J = C * V - $ * F,
      ee = V / J,
      te = -$ / J,
      ie = -F / J,
      ne = C / J,
      re = (F * K - V * Y) / J,
      ae = -(C * K - $ * Y) / J,
      { x: oe, y: se } = e;
    (T.x = oe * ee + se * ie + re), (T.y = oe * te + se * ne + ae);
  }
  onlyTranslate(e = 1) {
    return this.a === e && 0 === this.b && 0 === this.c && this.d === e;
  }
  clone() {
    return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  toTransformAttrs() {
    const e = this.a,
      T = this.b,
      C = this.c,
      $ = this.d,
      F = e * $ - T * C,
      V = {
        x: this.e,
        y: this.f,
        rotateDeg: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0,
      };
    if (0 !== e || 0 !== T) {
      const Y = Math.sqrt(e * e + T * T);
      (V.rotateDeg = T > 0 ? Math.acos(e / Y) : -Math.acos(e / Y)),
        (V.scaleX = Y),
        (V.scaleY = F / Y),
        (V.skewX = (e * C + T * $) / F),
        (V.skewY = 0);
    } else if (0 !== C || 0 !== $) {
      const Y = Math.sqrt(C * C + $ * $);
      (V.rotateDeg =
        Math.PI / 2 - ($ > 0 ? Math.acos(-C / Y) : -Math.acos(C / Y))),
        (V.scaleX = F / Y),
        (V.scaleY = Y),
        (V.skewX = 0),
        (V.skewY = (e * C + T * $) / F);
    }
    return (V.rotateDeg = radianToDegree(V.rotateDeg)), V;
  }
}
function normalTransform(e, T, C, $, F, V, Y, K) {
  const J = T.a,
    ee = T.b,
    te = T.c,
    ie = T.d,
    ne = T.e,
    re = T.f,
    ae = cos(Y),
    oe = sin(Y);
  let se, le;
  K ? ((se = K[0]), (le = K[1])) : ((se = C), (le = $));
  const de = se - C,
    ce = le - $,
    ue = J * ae + te * oe,
    he = ee * ae + ie * oe,
    pe = te * ae - J * oe,
    ge = ie * ae - ee * oe;
  (e.a = F * ue),
    (e.b = F * he),
    (e.c = V * pe),
    (e.d = V * ge),
    (e.e = ne + J * se + te * le - ue * de - pe * ce),
    (e.f = re + ee * se + ie * le - he * de - ge * ce);
}
class LRU {
  constructor() {
    (this.CLEAN_THRESHOLD = 1e3),
      (this.L_TIME = 1e3),
      (this.R_COUNT = 1),
      (this.R_TIMESTAMP_MAX_SIZE = 20);
  }
  clearCache(e, T) {
    const {
      CLEAN_THRESHOLD: C = this.CLEAN_THRESHOLD,
      L_TIME: $ = this.L_TIME,
      R_COUNT: F = this.R_COUNT,
    } = T;
    if (e.size < C) return 0;
    let V = 0;
    const Y = (T) => {
        V++, e.delete(T);
      },
      K = Date.now();
    return (
      e.forEach((e, T) => {
        if (e.timestamp.length < F) return Y(T);
        let C = 0;
        for (
          ;
          K - e.timestamp[e.timestamp.length - 1 - C] < $ && (C++, !(C >= F));

        );
        if (C < F) return Y(T);
        for (; K - e.timestamp[0] > $; ) e.timestamp.shift();
      }),
      V
    );
  }
  addLimitedTimestamp(e, T, C) {
    const { R_TIMESTAMP_MAX_SIZE: $ = this.R_TIMESTAMP_MAX_SIZE } = C;
    e.timestamp.length > $ && e.timestamp.shift(), e.timestamp.push(T);
  }
  clearTimeStamp(e, T) {
    const { L_TIME: C = this.L_TIME } = T,
      $ = Date.now();
    e.forEach((e) => {
      for (; $ - e.timestamp[0] > C; ) e.timestamp.shift();
    });
  }
  clearItemTimestamp(e, T) {
    const { L_TIME: C = this.L_TIME } = T,
      $ = Date.now();
    for (; $ - e.timestamp[0] > C; ) e.timestamp.shift();
  }
}
function hslToRgb(e, T, C) {
  (T /= 100), (C /= 100);
  const $ = (1 - Math.abs(2 * C - 1)) * T,
    F = $ * (1 - Math.abs(((e / 60) % 2) - 1)),
    V = C - $ / 2;
  let Y = 0,
    K = 0,
    J = 0;
  return (
    0 <= e && e < 60
      ? ((Y = $), (K = F), (J = 0))
      : 60 <= e && e < 120
      ? ((Y = F), (K = $), (J = 0))
      : 120 <= e && e < 180
      ? ((Y = 0), (K = $), (J = F))
      : 180 <= e && e < 240
      ? ((Y = 0), (K = F), (J = $))
      : 240 <= e && e < 300
      ? ((Y = F), (K = 0), (J = $))
      : 300 <= e && e < 360 && ((Y = $), (K = 0), (J = F)),
    (Y = Math.round(255 * (Y + V))),
    (K = Math.round(255 * (K + V))),
    (J = Math.round(255 * (J + V))),
    {
      r: Y,
      g: K,
      b: J,
    }
  );
}
function rgbToHsl(e, T, C) {
  (e /= 255), (T /= 255), (C /= 255);
  const $ = Math.min(e, T, C),
    F = Math.max(e, T, C),
    V = F - $;
  let Y = 0,
    K = 0,
    J = 0;
  return (
    (Y =
      0 === V
        ? 0
        : F === e
        ? ((T - C) / V) % 6
        : F === T
        ? (C - e) / V + 2
        : (e - T) / V + 4),
    (Y = Math.round(60 * Y)),
    Y < 0 && (Y += 360),
    (J = (F + $) / 2),
    (K = 0 === V ? 0 : V / (1 - Math.abs(2 * J - 1))),
    (K = +(100 * K).toFixed(1)),
    (J = +(100 * J).toFixed(1)),
    {
      h: Y,
      s: K,
      l: J,
    }
  );
}
const REG_HEX = /^#([0-9a-f]{3,8})$/,
  DEFAULT_COLORS_OPACITY = {
    transparent: 4294967040,
  },
  DEFAULT_COLORS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  };
function hex(e) {
  return (
    ((e = Math.max(0, Math.min(255, Math.round(e) || 0))) < 16 ? "0" : "") +
    e.toString(16)
  );
}
function rgb(e) {
  return isNumber$1(e)
    ? new RGB(e >> 16, (e >> 8) & 255, 255 & e, 1)
    : isArray$1(e)
    ? new RGB(e[0], e[1], e[2])
    : new RGB(255, 255, 255);
}
function rgba(e) {
  return isNumber$1(e)
    ? new RGB(e >>> 24, (e >>> 16) & 255, (e >>> 8) & 255, 255 & e)
    : isArray$1(e)
    ? new RGB(e[0], e[1], e[2], e[3])
    : new RGB(255, 255, 255, 1);
}
function SRGBToLinear(e) {
  return e < 0.04045
    ? 0.0773993808 * e
    : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
}
function LinearToSRGB(e) {
  return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
const setHex = (e, T) => {
  const C = REG_HEX.exec(e);
  if (T || C) {
    const e = parseInt(C[1], 16),
      T = C[1].length;
    return 3 === T
      ? new RGB(
          ((e >> 8) & 15) + (((e >> 8) & 15) << 4),
          ((e >> 4) & 15) + (((e >> 4) & 15) << 4),
          (15 & e) + ((15 & e) << 4),
          1
        )
      : 6 === T
      ? rgb(e)
      : 8 === T
      ? new RGB(
          (e >> 24) & 255,
          (e >> 16) & 255,
          (e >> 8) & 255,
          (255 & e) / 255
        )
      : null;
  }
};
class Color {
  static Brighter(e, T = 1) {
    return 1 === T ? e : new Color(e).brighter(T).toRGBA();
  }
  static SetOpacity(e, T = 1) {
    return 1 === T ? e : new Color(e).setOpacity(T).toRGBA();
  }
  static getColorBrightness(e, T = "hsl") {
    const C = e instanceof Color ? e : new Color(e);
    switch (T) {
      case "hsv":
      default:
        return C.getHSVBrightness();
      case "hsl":
        return C.getHSLBrightness();
      case "lum":
        return C.getLuminance();
      case "lum2":
        return C.getLuminance2();
      case "lum3":
        return C.getLuminance3();
    }
  }
  static parseColorString(e) {
    if (isValid$1(DEFAULT_COLORS_OPACITY[e]))
      return rgba(DEFAULT_COLORS_OPACITY[e]);
    if (isValid$1(DEFAULT_COLORS[e])) return rgb(DEFAULT_COLORS[e]);
    const T = `${e}`.trim().toLowerCase(),
      C = setHex(T);
    if (void 0 !== C) return C;
    if (/^(rgb|RGB|rgba|RGBA)/.test(T)) {
      const e = T.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB(
        parseInt(e[0], 10),
        parseInt(e[1], 10),
        parseInt(e[2], 10),
        parseFloat(e[3])
      );
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(T)) {
      const e = T.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
        C = hslToRgb(
          parseInt(e[0], 10),
          parseInt(e[1], 10),
          parseInt(e[2], 10)
        );
      return new RGB(C.r, C.g, C.b, parseFloat(e[3]));
    }
  }
  constructor(e) {
    const T = Color.parseColorString(e);
    this.color = T || new RGB(255, 255, 255);
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(e) {
    const { r: T, g: C, b: $ } = this.color;
    return (
      (this.color.r = Math.max(0, Math.min(255, Math.floor(T * e)))),
      (this.color.g = Math.max(0, Math.min(255, Math.floor(C * e)))),
      (this.color.b = Math.max(0, Math.min(255, Math.floor($ * e)))),
      this
    );
  }
  add(e) {
    const { r: T, g: C, b: $ } = this.color;
    return (
      (this.color.r += Math.min(255, T + e.color.r)),
      (this.color.g += Math.min(255, C + e.color.g)),
      (this.color.b += Math.min(255, $ + e.color.b)),
      this
    );
  }
  sub(e) {
    return (
      (this.color.r = Math.max(0, this.color.r - e.color.r)),
      (this.color.g = Math.max(0, this.color.g - e.color.g)),
      (this.color.b = Math.max(0, this.color.b - e.color.b)),
      this
    );
  }
  multiply(e) {
    const { r: T, g: C, b: $ } = this.color;
    return (
      (this.color.r = Math.max(0, Math.min(255, Math.floor(T * e.color.r)))),
      (this.color.g = Math.max(0, Math.min(255, Math.floor(C * e.color.g)))),
      (this.color.b = Math.max(0, Math.min(255, Math.floor($ * e.color.b)))),
      this
    );
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return (
      0.5 *
      (Math.max(this.color.r, this.color.g, this.color.b) / 255 +
        Math.min(this.color.r, this.color.g, this.color.b) / 255)
    );
  }
  setHsl(e, T, C) {
    const $ = this.color.opacity,
      F = rgbToHsl(this.color.r, this.color.g, this.color.b),
      V = hslToRgb(
        isNil$1(e) ? F.h : clamp$1(e, 0, 360),
        isNil$1(T) ? F.s : T >= 0 && T <= 1 ? 100 * T : T,
        isNil$1(C) ? F.l : C <= 1 && C >= 0 ? 100 * C : C
      );
    return (this.color = new RGB(V.r, V.g, V.b, $)), this;
  }
  setRGB(e, T, C) {
    return (
      !isNil$1(e) && (this.color.r = e),
      !isNil$1(T) && (this.color.g = T),
      !isNil$1(C) && (this.color.b = C),
      this
    );
  }
  setHex(e) {
    const T = `${e}`.trim().toLowerCase(),
      C = setHex(T, !0);
    return null != C ? C : this;
  }
  setColorName(e) {
    const T = DEFAULT_COLORS[e.toLowerCase()];
    return void 0 !== T && this.setHex(T), this;
  }
  setScalar(e) {
    return (this.color.r = e), (this.color.g = e), (this.color.b = e), this;
  }
  setOpacity(e = 1) {
    return (this.color.opacity = e), this;
  }
  getLuminance() {
    return (
      (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) /
      255
    );
  }
  getLuminance2() {
    return (
      (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) /
      255
    );
  }
  getLuminance3() {
    return (
      (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255
    );
  }
  clone() {
    return new Color(this.color.toString());
  }
  copyGammaToLinear(e, T = 2) {
    return (
      (this.color.r = Math.pow(e.color.r, T)),
      (this.color.g = Math.pow(e.color.g, T)),
      (this.color.b = Math.pow(e.color.b, T)),
      this
    );
  }
  copyLinearToGamma(e, T = 2) {
    const C = T > 0 ? 1 / T : 1;
    return (
      (this.color.r = Math.pow(e.color.r, C)),
      (this.color.g = Math.pow(e.color.g, C)),
      (this.color.b = Math.pow(e.color.b, C)),
      this
    );
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return (
      (this.color.r = SRGBToLinear(e.color.r)),
      (this.color.g = SRGBToLinear(e.color.g)),
      (this.color.b = SRGBToLinear(e.color.b)),
      this
    );
  }
  copyLinearToSRGB(e) {
    return (
      (this.color.r = LinearToSRGB(e.color.r)),
      (this.color.g = LinearToSRGB(e.color.g)),
      (this.color.b = LinearToSRGB(e.color.b)),
      this
    );
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
}
class RGB {
  constructor(e, T, C, $) {
    (this.r = isNaN(+e) ? 255 : Math.max(0, Math.min(255, +e))),
      (this.g = isNaN(+T) ? 255 : Math.max(0, Math.min(255, +T))),
      (this.b = isNaN(+C) ? 255 : Math.max(0, Math.min(255, +C))),
      isValid$1($)
        ? (this.opacity = isNaN(+$) ? 1 : Math.max(0, Math.min(1, +$)))
        : (this.opacity = 1);
  }
  formatHex() {
    return `#${
      hex(this.r) +
      hex(this.g) +
      hex(this.b) +
      (1 === this.opacity ? "" : hex(255 * this.opacity))
    }`;
  }
  formatRgb() {
    const e = this.opacity;
    return `${1 === e ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${
      1 === e ? ")" : `,${e})`
    }`;
  }
  formatHsl() {
    const e = this.opacity,
      { h: T, s: C, l: $ } = rgbToHsl(this.r, this.g, this.b);
    return `${1 === e ? "hsl(" : "hsla("}${T},${C}%,${$}%${
      1 === e ? ")" : `,${e})`
    }`;
  }
  toString() {
    return this.formatHex();
  }
}
class Text$1 extends Text$2 {
  constructor(e) {
    var T, C, $, F, V, Y, K, J, ee, te, ie;
    e.textBaseline || (e.textBaseline = "top");
    const ne = isArray$1(e.boundsPadding),
      re = [
        null !==
          (C =
            null !== (T = e.marginTop) && void 0 !== T
              ? T
              : ne
              ? e.boundsPadding[0]
              : e.boundsPadding) && void 0 !== C
          ? C
          : 0,
        null !==
          (F =
            null !== ($ = e.marginRight) && void 0 !== $
              ? $
              : ne
              ? e.boundsPadding[1]
              : e.boundsPadding) && void 0 !== F
          ? F
          : 0,
        null !==
          (K =
            null !== (V = e.marginBottom) && void 0 !== V
              ? V
              : ne
              ? null !== (Y = e.boundsPadding[2]) && void 0 !== Y
                ? Y
                : e.boundsPadding[0]
              : e.boundsPadding) && void 0 !== K
          ? K
          : 0,
        null !==
          (te =
            null !== (J = e.marginLeft) && void 0 !== J
              ? J
              : ne
              ? null !== (ee = e.boundsPadding[3]) && void 0 !== ee
                ? ee
                : e.boundsPadding[1]
              : e.boundsPadding) && void 0 !== te
          ? te
          : 0,
      ];
    (e.boundsPadding = re),
      (e.fill = null !== (ie = e.fill) && void 0 !== ie ? ie : "#000"),
      super(e);
  }
  getSize(e) {
    this.AABBBounds.width();
  }
}
class Group$1 extends Group$2 {
  constructor(e) {
    var T, C, $, F, V, Y, K, J, ee, te;
    const ie = isArray$1(e.boundsPadding),
      ne = [
        null !==
          (C =
            null !== (T = e.marginTop) && void 0 !== T
              ? T
              : ie
              ? e.boundsPadding[0]
              : e.boundsPadding) && void 0 !== C
          ? C
          : 0,
        null !==
          (F =
            null !== ($ = e.marginRight) && void 0 !== $
              ? $
              : ie
              ? e.boundsPadding[1]
              : e.boundsPadding) && void 0 !== F
          ? F
          : 0,
        null !==
          (K =
            null !== (V = e.marginBottom) && void 0 !== V
              ? V
              : ie
              ? null !== (Y = e.boundsPadding[2]) && void 0 !== Y
                ? Y
                : e.boundsPadding[0]
              : e.boundsPadding) && void 0 !== K
          ? K
          : 0,
        null !==
          (te =
            null !== (J = e.marginLeft) && void 0 !== J
              ? J
              : ie
              ? null !== (ee = e.boundsPadding[3]) && void 0 !== ee
                ? ee
                : e.boundsPadding[1]
              : e.boundsPadding) && void 0 !== te
          ? te
          : 0,
      ];
    (e.boundsPadding = ne), super(e);
  }
}
class Generator {
  static GenAutoIncrementId() {
    return Generator.auto_increment_id++;
  }
}
Generator.auto_increment_id = 0;
class ContainerModule {
  constructor(e) {
    (this.id = Generator.GenAutoIncrementId()), (this.registry = e);
  }
}
const NAMED_TAG = "named",
  INJECT_TAG = "inject",
  MULTI_INJECT_TAG = "multi_inject",
  TAGGED = "inversify:tagged",
  PARAM_TYPES = "inversify:paramtypes";
class Metadata {
  constructor(e, T) {
    (this.key = e), (this.value = T);
  }
  toString() {
    return this.key === NAMED_TAG
      ? `named: ${String(this.value).toString()} `
      : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
}
const Reflect$1 =
  ((Reflect2 = {}),
  (function (e) {
    const T = Object.prototype.hasOwnProperty,
      C = "function" == typeof Symbol,
      $ =
        C && void 0 !== Symbol.toPrimitive
          ? Symbol.toPrimitive
          : "@@toPrimitive",
      F = C && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator",
      V = "function" == typeof Object.create,
      Y =
        {
          __proto__: [],
        } instanceof Array,
      K = !V && !Y,
      J = {
        create: V
          ? function () {
              return fe(Object.create(null));
            }
          : Y
          ? function () {
              return fe({
                __proto__: null,
              });
            }
          : function () {
              return fe({});
            },
        has: K
          ? function (e, C) {
              return T.call(e, C);
            }
          : function (e, T) {
              return T in e;
            },
        get: K
          ? function (e, C) {
              return T.call(e, C) ? e[C] : void 0;
            }
          : function (e, T) {
              return e[T];
            },
      },
      ee = Object.getPrototypeOf(Function),
      te =
        "object" == typeof process &&
        process.env &&
        "true" === {}.REFLECT_METADATA_USE_MAP_POLYFILL,
      ie =
        te ||
        "function" != typeof Map ||
        "function" != typeof Map.prototype.entries
          ? (function () {
              const e = {},
                T = [],
                C = (function () {
                  function e(e, T, C) {
                    (this._index = 0),
                      (this._keys = e),
                      (this._values = T),
                      (this._selector = C);
                  }
                  return (
                    (e.prototype["@@iterator"] = function () {
                      return this;
                    }),
                    (e.prototype[F] = function () {
                      return this;
                    }),
                    (e.prototype.next = function () {
                      const e = this._index;
                      if (e >= 0 && e < this._keys.length) {
                        const C = this._selector(
                          this._keys[e],
                          this._values[e]
                        );
                        return (
                          e + 1 >= this._keys.length
                            ? ((this._index = -1),
                              (this._keys = T),
                              (this._values = T))
                            : this._index++,
                          {
                            value: C,
                            done: !1,
                          }
                        );
                      }
                      return {
                        value: void 0,
                        done: !0,
                      };
                    }),
                    (e.prototype.throw = function (e) {
                      throw (
                        (this._index >= 0 &&
                          ((this._index = -1),
                          (this._keys = T),
                          (this._values = T)),
                        e)
                      );
                    }),
                    (e.prototype.return = function (e) {
                      return (
                        this._index >= 0 &&
                          ((this._index = -1),
                          (this._keys = T),
                          (this._values = T)),
                        {
                          value: e,
                          done: !0,
                        }
                      );
                    }),
                    e
                  );
                })();
              return (function () {
                function T() {
                  (this._keys = []),
                    (this._values = []),
                    (this._cacheKey = e),
                    (this._cacheIndex = -2);
                }
                return (
                  Object.defineProperty(T.prototype, "size", {
                    get: function () {
                      return this._keys.length;
                    },
                    enumerable: !0,
                    configurable: !0,
                  }),
                  (T.prototype.has = function (e) {
                    return this._find(e, !1) >= 0;
                  }),
                  (T.prototype.get = function (e) {
                    const T = this._find(e, !1);
                    return T >= 0 ? this._values[T] : void 0;
                  }),
                  (T.prototype.set = function (e, T) {
                    const C = this._find(e, !0);
                    return (this._values[C] = T), this;
                  }),
                  (T.prototype.delete = function (T) {
                    const C = this._find(T, !1);
                    if (C >= 0) {
                      const $ = this._keys.length;
                      for (let e = C + 1; e < $; e++)
                        (this._keys[e - 1] = this._keys[e]),
                          (this._values[e - 1] = this._values[e]);
                      return (
                        this._keys.length--,
                        this._values.length--,
                        T === this._cacheKey &&
                          ((this._cacheKey = e), (this._cacheIndex = -2)),
                        !0
                      );
                    }
                    return !1;
                  }),
                  (T.prototype.clear = function () {
                    (this._keys.length = 0),
                      (this._values.length = 0),
                      (this._cacheKey = e),
                      (this._cacheIndex = -2);
                  }),
                  (T.prototype.keys = function () {
                    return new C(this._keys, this._values, $);
                  }),
                  (T.prototype.values = function () {
                    return new C(this._keys, this._values, V);
                  }),
                  (T.prototype.entries = function () {
                    return new C(this._keys, this._values, Y);
                  }),
                  (T.prototype["@@iterator"] = function () {
                    return this.entries();
                  }),
                  (T.prototype[F] = function () {
                    return this.entries();
                  }),
                  (T.prototype._find = function (e, T) {
                    return (
                      this._cacheKey !== e &&
                        (this._cacheIndex = this._keys.indexOf(
                          (this._cacheKey = e)
                        )),
                      this._cacheIndex < 0 &&
                        T &&
                        ((this._cacheIndex = this._keys.length),
                        this._keys.push(e),
                        this._values.push(void 0)),
                      this._cacheIndex
                    );
                  }),
                  T
                );
              })();
              function $(e, T) {
                return e;
              }
              function V(e, T) {
                return T;
              }
              function Y(e, T) {
                return [e, T];
              }
            })()
          : Map,
      ne =
        (te ||
        "function" != typeof Set ||
        "function" != typeof Set.prototype.entries
          ? (function () {
              function e() {
                this._map = new ie();
              }
              Object.defineProperty(e.prototype, "size", {
                get: function () {
                  return this._map.size;
                },
                enumerable: !0,
                configurable: !0,
              }),
                (e.prototype.has = function (e) {
                  return this._map.has(e);
                }),
                (e.prototype.add = function (e) {
                  return this._map.set(e, e), this;
                }),
                (e.prototype.delete = function (e) {
                  return this._map.delete(e);
                }),
                (e.prototype.clear = function () {
                  this._map.clear();
                }),
                (e.prototype.keys = function () {
                  return this._map.keys();
                }),
                (e.prototype.values = function () {
                  return this._map.values();
                }),
                (e.prototype.entries = function () {
                  return this._map.entries();
                }),
                (e.prototype["@@iterator"] = function () {
                  return this.keys();
                }),
                (e.prototype[F] = function () {
                  return this.keys();
                });
            })()
          : Set,
        new (te || "function" != typeof WeakMap
          ? (function () {
              const e = 16,
                C = J.create(),
                $ = F();
              return (function () {
                function e() {
                  this._key = F();
                }
                return (
                  (e.prototype.has = function (e) {
                    const T = V(e, !1);
                    return void 0 !== T && J.has(T, this._key);
                  }),
                  (e.prototype.get = function (e) {
                    const T = V(e, !1);
                    return void 0 !== T ? J.get(T, this._key) : void 0;
                  }),
                  (e.prototype.set = function (e, T) {
                    return (V(e, !0)[this._key] = T), this;
                  }),
                  (e.prototype.delete = function (e) {
                    const T = V(e, !1);
                    return void 0 !== T && delete T[this._key];
                  }),
                  (e.prototype.clear = function () {
                    this._key = F();
                  }),
                  e
                );
              })();
              function F() {
                let e;
                do {
                  e = "@@WeakMap@@" + K();
                } while (J.has(C, e));
                return (C[e] = !0), e;
              }
              function V(e, C) {
                if (!T.call(e, $)) {
                  if (!C) return;
                  Object.defineProperty(e, $, {
                    value: J.create(),
                  });
                }
                return e[$];
              }
              function Y(e, T) {
                for (let C = 0; C < T; ++C) e[C] = (255 * Math.random()) | 0;
                return e;
              }
              function K() {
                const T =
                  ((C = e),
                  "function" == typeof Uint8Array
                    ? "undefined" != typeof crypto
                      ? crypto.getRandomValues(new Uint8Array(C))
                      : Y(new Uint8Array(C), C)
                    : Y(new Array(C), C));
                var C;
                (T[6] = (79 & T[6]) | 64), (T[8] = (191 & T[8]) | 128);
                let $ = "";
                for (let F = 0; F < e; ++F) {
                  const e = T[F];
                  (4 !== F && 6 !== F && 8 !== F) || ($ += "-"),
                    e < 16 && ($ += "0"),
                    ($ += e.toString(16).toLowerCase());
                }
                return $;
              }
            })()
          : WeakMap)());
    function re(e, T, C) {
      let $ = ne.get(e);
      if (le($)) {
        if (!C) return;
        ($ = new ie()), ne.set(e, $);
      }
      let F = $.get(T);
      if (le(F)) {
        if (!C) return;
        (F = new ie()), $.set(T, F);
      }
      return F;
    }
    function ae(e, T, C) {
      if (oe(e, T, C)) return !0;
      const $ = ge(T);
      return !de($) && ae(e, $, C);
    }
    function oe(e, T, C) {
      const $ = re(T, C, !1);
      return !le($) && !!$.has(e);
    }
    function se(e, T, C) {
      if (oe(e, T, C))
        return (function (e, T, C) {
          const $ = re(T, C, !1);
          if (!le($)) return $.get(e);
        })(e, T, C);
      const $ = ge(T);
      return de($) ? void 0 : se(e, $, C);
    }
    function le(e) {
      return void 0 === e;
    }
    function de(e) {
      return null === e;
    }
    function ce(e) {
      return "object" == typeof e ? null !== e : "function" == typeof e;
    }
    function ue(e, T) {
      switch (
        (function (e) {
          if (null === e) return 1;
          switch (typeof e) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return null === e ? 1 : 6;
            default:
              return 6;
          }
        })(e)
      ) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return e;
      }
      const C = 3 === T ? "string" : 5 === T ? "number" : "default",
        F = (function (e, T) {
          const C = e[T];
          if (null != C) {
            if (!pe(C)) throw new TypeError();
            return C;
          }
        })(e, $);
      if (void 0 !== F) {
        const T = F.call(e, C);
        if (ce(T)) throw new TypeError();
        return T;
      }
      return (function (e, T) {
        if ("string" === T) {
          const T = e.toString;
          if (pe(T)) {
            const C = T.call(e);
            if (!ce(C)) return C;
          }
          const C = e.valueOf;
          if (pe(C)) {
            const T = C.call(e);
            if (!ce(T)) return T;
          }
        } else {
          const T = e.valueOf;
          if (pe(T)) {
            const C = T.call(e);
            if (!ce(C)) return C;
          }
          const C = e.toString;
          if (pe(C)) {
            const T = C.call(e);
            if (!ce(T)) return T;
          }
        }
        throw new TypeError();
      })(e, "default" === C ? "number" : C);
    }
    function he(e) {
      const T = ue(e, 3);
      return "symbol" == typeof T
        ? T
        : (function (e) {
            return "" + e;
          })(T);
    }
    function pe(e) {
      return "function" == typeof e;
    }
    function ge(e) {
      const T = Object.getPrototypeOf(e);
      if ("function" != typeof e || e === ee) return T;
      if (T !== ee) return T;
      const C = e.prototype,
        $ = C && Object.getPrototypeOf(C);
      if (null == $ || $ === Object.prototype) return T;
      const F = $.constructor;
      return "function" != typeof F || F === e ? T : F;
    }
    function fe(e) {
      return (e.__ = void 0), delete e.__, e;
    }
    e("defineMetadata", function (e, T, C, $) {
      if (!ce(C)) throw new TypeError();
      return (F = e), (V = T), void re(C, $, !0).set(F, V);
      var F, V;
    }),
      e("hasMetadata", function (e, T, C) {
        if (!ce(T)) throw new TypeError();
        return le(C) || (C = he(C)), ae(e, T, C);
      }),
      e("hasOwnMetadata", function (e, T, C) {
        if (!ce(T)) throw new TypeError();
        return le(C) || (C = he(C)), oe(e, T, C);
      }),
      e("getMetadata", function (e, T, C) {
        if (!ce(T)) throw new TypeError();
        return le(C) || (C = he(C)), se(e, T, C);
      });
  })(
    ((target = Reflect2),
    function (e, T) {
      "function" != typeof target[e] &&
        Object.defineProperty(target, e, {
          configurable: !0,
          writable: !0,
          value: T,
        });
    })
  ),
  Reflect2);
var Reflect2, target;
function _tagParameterOrProperty(e, T, C, $) {
  const F = [$];
  let V = {};
  Reflect$1.hasOwnMetadata(e, T) && (V = Reflect$1.getMetadata(e, T));
  let Y = V[C];
  void 0 === Y && (Y = []),
    Y.push(...F),
    (V[C] = Y),
    Reflect$1.defineMetadata(e, V, T);
}
function tagParameter(e, T, C, $) {
  _tagParameterOrProperty(TAGGED, e, C.toString(), $);
}
function createTaggedDecorator(e) {
  return (T, C, $) => {
    tagParameter(T, C, $, e);
  };
}
function injectBase(e) {
  return (T) => (C, $, F) => createTaggedDecorator(new Metadata(e, T))(C, $, F);
}
const inject = injectBase(INJECT_TAG),
  multiInject = injectBase(MULTI_INJECT_TAG);
function injectable() {
  return function (e) {
    return Reflect$1.defineMetadata(PARAM_TYPES, null, e), e;
  };
}
function named(e) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, e));
}
const BindingScopeEnum = {
    Singleton: "Singleton",
    Transient: "Transient",
  },
  BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider",
  };
class Binding {
  constructor(e, T) {
    (this.id = Generator.GenAutoIncrementId()),
      (this.activated = !1),
      (this.serviceIdentifier = e),
      (this.scope = T),
      (this.type = BindingTypeEnum.Invalid),
      (this.constraint = (e) => !0),
      (this.implementationType = null),
      (this.cache = null),
      (this.factory = null),
      (this.provider = null),
      (this.dynamicValue = null);
  }
  clone() {
    const e = new Binding(this.serviceIdentifier, this.scope);
    return (
      (e.activated = e.scope === BindingScopeEnum.Singleton && this.activated),
      (e.implementationType = this.implementationType),
      (e.dynamicValue = this.dynamicValue),
      (e.scope = this.scope),
      (e.type = this.type),
      (e.provider = this.provider),
      (e.constraint = this.constraint),
      (e.cache = this.cache),
      e
    );
  }
}
class MetadataReader {
  getConstructorMetadata(e) {
    return {
      compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, e),
      userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, e) || {},
    };
  }
  getPropertiesMetadata(e) {
    throw new Error("");
  }
}
const taggedConstraint = (e) => (T) => {
    const C = (C) => {
      if (null == C) return !1;
      if (C.key === e && C.value === T) return !0;
      if (null == C.constructorArgsMetadata) return !1;
      const $ = C.constructorArgsMetadata;
      for (let F = 0; F < $.length; F++)
        if ($[F].key === e && $[F].value === T) return !0;
      return !1;
    };
    return (C.metaData = new Metadata(e, T)), C;
  },
  namedConstraint = taggedConstraint(NAMED_TAG);
class BindingInSyntax {
  constructor(e) {
    this._binding = e;
  }
  inRequestScope() {
    throw new Error("");
  }
  inSingletonScope() {
    return (this._binding.scope = BindingScopeEnum.Singleton), this;
  }
  inTransientScope() {
    return (this._binding.scope = BindingScopeEnum.Transient), this;
  }
  whenTargetNamed(e) {
    return (this._binding.constraint = namedConstraint(e)), this;
  }
}
class BindingToSyntax {
  constructor(e) {
    this._binding = e;
  }
  to(e) {
    return (
      (this._binding.type = BindingTypeEnum.Instance),
      (this._binding.implementationType = e),
      new BindingInSyntax(this._binding)
    );
  }
  toSelf() {
    const e = this._binding.serviceIdentifier;
    return this.to(e);
  }
  toDynamicValue(e) {
    return (
      (this._binding.type = BindingTypeEnum.DynamicValue),
      (this._binding.cache = null),
      (this._binding.dynamicValue = e),
      (this._binding.implementationType = null),
      new BindingInSyntax(this._binding)
    );
  }
  toConstantValue(e) {
    return (
      (this._binding.type = BindingTypeEnum.ConstantValue),
      (this._binding.cache = e),
      (this._binding.dynamicValue = null),
      (this._binding.implementationType = null),
      (this._binding.scope = BindingScopeEnum.Singleton),
      new BindingInSyntax(this._binding)
    );
  }
  toFactory(e) {
    return (
      (this._binding.type = BindingTypeEnum.Factory),
      (this._binding.factory = e),
      (this._binding.scope = BindingScopeEnum.Singleton),
      new BindingInSyntax(this._binding)
    );
  }
  toService(e) {
    this.toDynamicValue((T) => T.container.get(e));
  }
}
class Container {
  constructor(e) {
    const T = e || {};
    (T.defaultScope = T.defaultScope || BindingScopeEnum.Transient),
      (this.options = T),
      (this.id = Generator.GenAutoIncrementId()),
      (this._bindingDictionary = new Map()),
      (this._metadataReader = new MetadataReader());
  }
  load(e) {
    const T = this._getContainerModuleHelpersFactory()(e.id);
    e.registry(
      T.bindFunction,
      T.unbindFunction,
      T.isboundFunction,
      T.rebindFunction
    );
  }
  get(e) {
    const T = this._getNotAllArgs(e, !1);
    return this._get(T);
  }
  getAll(e) {
    const T = this._getAllArgs(e);
    return this._get(T);
  }
  getTagged(e, T, C) {
    const $ = this._getNotAllArgs(e, !1, T, C);
    return this._get($);
  }
  getNamed(e, T) {
    return this.getTagged(e, NAMED_TAG, T);
  }
  isBound(e) {
    return this._bindingDictionary.has(e);
  }
  bind(e) {
    const T = this.options.defaultScope,
      C = new Binding(e, T),
      $ = this._bindingDictionary.get(e) || [];
    return $.push(C), this._bindingDictionary.set(e, $), new BindingToSyntax(C);
  }
  unbind(e) {
    this._bindingDictionary.delete(e);
  }
  rebind(e) {
    return this.unbind(e), this.bind(e);
  }
  _getContainerModuleHelpersFactory() {
    const e = (e, T) => {
        e._binding.moduleId = T;
      },
      T = (T) => (C) => {
        const $ = this.bind(C);
        return e($, T), $;
      },
      C = () => (e) => this.unbind(e),
      $ = () => (e) => this.isBound(e),
      F = (T) => (C) => {
        const $ = this.rebind(C);
        return e($, T), $;
      };
    return (e) => ({
      bindFunction: T(e),
      isboundFunction: $(),
      rebindFunction: F(e),
      unbindFunction: C(),
      unbindAsyncFunction: (e) => null,
    });
  }
  _getNotAllArgs(e, T, C, $) {
    return {
      avoidConstraints: !1,
      isMultiInject: T,
      serviceIdentifier: e,
      key: C,
      value: $,
    };
  }
  _getAllArgs(e) {
    return {
      avoidConstraints: !0,
      isMultiInject: !0,
      serviceIdentifier: e,
    };
  }
  _get(e) {
    const T = [];
    return (
      this._bindingDictionary
        .get(e.serviceIdentifier)
        .filter((T) => T.constraint(e))
        .forEach((e) => {
          T.push(this._resolveFromBinding(e));
        }),
      e.isMultiInject || 1 !== T.length ? T : T[0]
    );
  }
  _getChildRequest(e) {
    const T = e.implementationType,
      { userGeneratedMetadata: C } =
        this._metadataReader.getConstructorMetadata(T),
      $ = Object.keys(C),
      F = [];
    for (let V = 0; V < $.length; V++) {
      const e = C[V],
        T = {};
      e.forEach((e) => {
        T[e.key] = e.value;
      });
      const $ = {
          inject: T[INJECT_TAG],
          multiInject: T[MULTI_INJECT_TAG],
        },
        Y = $.inject || $.multiInject,
        K = {
          serviceIdentifier: Y,
          constructorArgsMetadata: e,
        },
        J = {
          injectIdentifier: Y,
          metadata: e,
          bindings: this._bindingDictionary
            .get(Y)
            .filter((e) => e.constraint(K)),
        };
      F.push(J);
    }
    return F;
  }
  _resolveFromBinding(e) {
    const T = this._getResolvedFromBinding(e);
    return this._saveToScope(e, T), T;
  }
  _getResolvedFromBinding(e) {
    let T;
    switch (e.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        T = e.cache;
        break;
      case BindingTypeEnum.Instance:
        T = this._resolveInstance(e, e.implementationType);
        break;
      default:
        T = e.dynamicValue({
          container: this,
        });
    }
    return T;
  }
  _resolveInstance(e, T) {
    if (e.activated) return e.cache;
    const C = this._getChildRequest(e);
    return this._createInstance(T, C);
  }
  _createInstance(e, T) {
    return T.length ? new e(...this._resolveRequests(T)) : new e();
  }
  _resolveRequests(e) {
    return e.map((e) =>
      e.bindings.length > 1
        ? e.bindings.map((e) => this._resolveFromBinding(e))
        : this._resolveFromBinding(e.bindings[0])
    );
  }
  _saveToScope(e, T) {
    e.scope === BindingScopeEnum.Singleton &&
      ((e.cache = T), (e.activated = !0));
  }
}
const ContributionProvider = Symbol("ContributionProvider");
class ContributionProviderCache {
  constructor(e, T) {
    (this.serviceIdentifier = e), (this.container = T);
  }
  getContributions() {
    return (
      this.caches ||
        ((this.caches = []),
        this.container &&
          this.container.isBound(this.serviceIdentifier) &&
          this.caches.push(...this.container.getAll(this.serviceIdentifier))),
      this.caches
    );
  }
}
function bindContributionProvider(e, T) {
  e(ContributionProvider)
    .toDynamicValue(({ container: e }) => new ContributionProviderCache(T, e))
    .inSingletonScope()
    .whenTargetNamed(T);
}
function bindContributionProviderNoSingletonScope(e, T) {
  e(ContributionProvider)
    .toDynamicValue(({ container: e }) => new ContributionProviderCache(T, e))
    .whenTargetNamed(T);
}
class Hook {
  constructor(e, T) {
    (this._args = e), (this.name = T), (this.taps = []);
  }
  tap(e, T) {
    this._tap("sync", e, T);
  }
  unTap(e, T) {
    const C = "string" == typeof e ? e.trim() : e.name;
    C &&
      (this.taps = this.taps.filter(
        (e) => !(e.name === C && (!T || e.fn === T))
      ));
  }
  _parseOptions(e, T, C) {
    let $;
    if ("string" == typeof T)
      $ = {
        name: T.trim(),
      };
    else if ("object" != typeof T || null === T)
      throw new Error("Invalid tap options");
    if ("string" != typeof $.name || "" === $.name)
      throw new Error("Missing name for tap");
    return (
      ($ = Object.assign(
        {
          type: e,
          fn: C,
        },
        $
      )),
      $
    );
  }
  _tap(e, T, C) {
    this._insert(this._parseOptions(e, T, C));
  }
  _insert(e) {
    let T;
    "string" == typeof e.before
      ? (T = new Set([e.before]))
      : Array.isArray(e.before) && (T = new Set(e.before));
    let C = 0;
    "number" == typeof e.stage && (C = e.stage);
    let $ = this.taps.length;
    for (; $ > 0; ) {
      $--;
      const e = this.taps[$];
      this.taps[$ + 1] = e;
      const F = e.stage || 0;
      if (T) {
        if (T.has(e.name)) {
          T.delete(e.name);
          continue;
        }
        if (T.size > 0) continue;
      }
      if (!(F > C)) {
        $++;
        break;
      }
    }
    this.taps[$] = e;
  }
}
class SyncHook extends Hook {
  call(...e) {
    this.taps.map((e) => e.fn).forEach((T) => T(...e));
  }
}
const EnvContribution = Symbol.for("EnvContribution"),
  VGlobal = Symbol.for("VGlobal");
var __decorate$1c =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$W =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$H =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultGlobal = class {
  get env() {
    return this._env;
  }
  get devicePixelRatio() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getDevicePixelRatio()
    );
  }
  get supportEvent() {
    return (
      this._env || this.setEnv("browser"), this.envContribution.supportEvent
    );
  }
  set supportEvent(e) {
    this._env || this.setEnv("browser"),
      (this.envContribution.supportEvent = e);
  }
  get supportsTouchEvents() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.supportsTouchEvents
    );
  }
  set supportsTouchEvents(e) {
    this._env || this.setEnv("browser"),
      (this.envContribution.supportsTouchEvents = e);
  }
  get supportsPointerEvents() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.supportsPointerEvents
    );
  }
  set supportsPointerEvents(e) {
    this._env || this.setEnv("browser"),
      (this.envContribution.supportsPointerEvents = e);
  }
  get supportsMouseEvents() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.supportsMouseEvents
    );
  }
  set supportsMouseEvents(e) {
    this._env || this.setEnv("browser"),
      (this.envContribution.supportsMouseEvents = e);
  }
  get applyStyles() {
    return (
      this._env || this.setEnv("browser"), this.envContribution.applyStyles
    );
  }
  set applyStyles(e) {
    this._env || this.setEnv("browser"), (this.envContribution.applyStyles = e);
  }
  constructor(e) {
    (this.contributions = e),
      (this.id = Generator.GenAutoIncrementId()),
      (this.hooks = {
        onSetEnv: new SyncHook(["lastEnv", "env", "global"]),
      }),
      (this.measureTextMethod = "native"),
      (this.optimizeVisible = !1);
  }
  bindContribution(e) {
    const T = [];
    if (
      (this.contributions.getContributions().forEach((C) => {
        const $ = C.configure(this, e);
        $ && $.then && T.push($);
      }),
      T.length)
    )
      return Promise.all(T);
  }
  getDynamicCanvasCount() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getDynamicCanvasCount()
    );
  }
  getStaticCanvasCount() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getStaticCanvasCount()
    );
  }
  setEnv(e, T) {
    if ((T && !0 === T.force) || this._env !== e)
      return this.deactiveCurrentEnv(), this.activeEnv(e, T);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(e, T) {
    const C = this._env;
    this._env = e;
    const $ = this.bindContribution(T);
    if ($ && $.then)
      return $.then(() => {
        (this.envParams = T), this.hooks.onSetEnv.call(C, e, this);
      });
    (this.envParams = T), this.hooks.onSetEnv.call(C, e, this);
  }
  setActiveEnvContribution(e) {
    this.envContribution = e;
  }
  createCanvas(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.createCanvas(e)
    );
  }
  createOffscreenCanvas(e) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.createOffscreenCanvas(e)
    );
  }
  releaseCanvas(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(e)
    );
  }
  addEventListener(e, T, C) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.addEventListener(e, T, C)
    );
  }
  removeEventListener(e, T, C) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.removeEventListener(e, T, C)
    );
  }
  dispatchEvent(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(e)
    );
  }
  getRequestAnimationFrame() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getRequestAnimationFrame()
    );
  }
  getCancelAnimationFrame() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getCancelAnimationFrame()
    );
  }
  getElementById(e) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getElementById
        ? this.envContribution.getElementById(e)
        : null
    );
  }
  getRootElement() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getRootElement
        ? this.envContribution.getRootElement()
        : null
    );
  }
  getDocument() {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getDocument
        ? this.envContribution.getDocument()
        : null
    );
  }
  mapToCanvasPoint(e, T) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.mapToCanvasPoint
        ? this.envContribution.mapToCanvasPoint(e, T)
        : null
    );
  }
  loadImage(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.loadImage(e)
    );
  }
  loadSvg(e) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(e);
  }
  loadJson(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.loadJson(e)
    );
  }
  loadArrayBuffer(e) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.loadArrayBuffer(e)
    );
  }
  loadBlob(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.loadBlob(e)
    );
  }
  isChrome() {
    return (
      null != this._isChrome ||
        (this._env || this.setEnv("browser"),
        (this._isChrome =
          "browser" === this._env &&
          navigator.userAgent.indexOf("Chrome") > -1)),
      this._isChrome
    );
  }
  isSafari() {
    return (
      null != this._isSafari ||
        (this._env || this.setEnv("browser"),
        (this._isSafari =
          "browser" === this._env &&
          /Safari/.test(navigator.userAgent) &&
          !/Chrome/.test(navigator.userAgent))),
      this._isSafari
    );
  }
  getNativeAABBBounds(e) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getNativeAABBBounds(e)
    );
  }
  removeDom(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.removeDom(e)
    );
  }
  createDom(e) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.createDom(e)
    );
  }
  updateDom(e, T) {
    return (
      this._env || this.setEnv("browser"), this.envContribution.updateDom(e, T)
    );
  }
  getElementTop(e, T = !1) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getElementTop(e, T)
    );
  }
  getElementLeft(e, T = !1) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getElementLeft(e, T)
    );
  }
  getElementTopLeft(e, T = !1) {
    return (
      this._env || this.setEnv("browser"),
      this.envContribution.getElementTopLeft(e, T)
    );
  }
};
DefaultGlobal = __decorate$1c(
  [
    injectable(),
    __param$H(0, inject(ContributionProvider)),
    __param$H(0, named(EnvContribution)),
    __metadata$W("design:paramtypes", [Object]),
  ],
  DefaultGlobal
);
const circleThreshold = tau - 1e-8;
class BoundsContext {
  constructor(e) {
    this.init(e);
  }
  init(e) {
    this.bounds = e;
  }
  arc(e, T, C, $, F, V) {
    if (Math.abs(F - $) > circleThreshold)
      return this.bounds.add(e - C, T - C), void this.bounds.add(e + C, T + C);
    let Y,
      K,
      J,
      ee,
      te = 1 / 0,
      ie = -1 / 0,
      ne = 1 / 0,
      re = -1 / 0;
    function ae(e) {
      (J = C * Math.cos(e)),
        (ee = C * Math.sin(e)),
        J < te && (te = J),
        J > ie && (ie = J),
        ee < ne && (ne = ee),
        ee > re && (re = ee);
    }
    if ((ae($), ae(F), F !== $))
      if (
        (($ %= tau) < 0 && ($ += tau),
        (F %= tau) < 0 && (F += tau),
        F < $ && ((V = !V), (Y = $), ($ = F), (F = Y)),
        V)
      )
        for (
          F -= tau, Y = $ - ($ % halfPi$1), K = 0;
          K < 4 && Y > F;
          ++K, Y -= halfPi$1
        )
          ae(Y);
      else
        for (
          Y = $ - ($ % halfPi$1) + halfPi$1, K = 0;
          K < 4 && Y < F;
          ++K, Y += halfPi$1
        )
          ae(Y);
    this.bounds.add(e + te, T + ne), this.bounds.add(e + ie, T + re);
  }
  arcTo(e, T, C, $, F) {
    throw new Error("arcTo");
  }
  bezierCurveTo(e, T, C, $, F, V) {
    this.bounds.add(e, T), this.bounds.add(C, $), this.bounds.add(F, V);
  }
  closePath() {}
  ellipse() {
    throw new Error("ellipse");
  }
  lineTo(e, T) {
    this.bounds.add(e, T);
  }
  moveTo(e, T) {
    this.bounds.add(e, T);
  }
  quadraticCurveTo(e, T, C, $) {
    this.bounds.add(e, T), this.bounds.add(C, $);
  }
  rect(e, T, C, $) {
    this.bounds.add(e, T), this.bounds.add(e + C, T + $);
  }
  clear() {
    this.bounds.clear();
  }
  release(...e) {}
}
class CurvePath {
  constructor() {
    (this.curves = []), (this.bounds = new AABBBounds());
  }
  getCurveLengths() {
    return this.curves.map((e) => e.getLength());
  }
  getPointAt(e) {
    return {
      x: 0,
      y: 0,
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
}
const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
  commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7,
  },
  enumCommandMap = {
    A: 0,
    AT: 1,
    C: 2,
    Z: 3,
    E: 4,
    L: 5,
    M: 6,
    Q: 7,
    R: 8,
  };
let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
function parseSvgPath(e) {
  if (!e) return [];
  const T = e.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === T) return [];
  let C, $;
  const F = [];
  for (let V = 0, Y = T.length; V < Y; V++)
    if (
      ((currPath = T[V]),
      (coordsStr = currPath.slice(1)),
      (commandChar = currPath[0]),
      (C = [commandChar]),
      ($ = coordsStr.match(rePathCommand)),
      null !== $)
    ) {
      for (let e = 0, T = $.length; e < T; e++)
        (coordStr = $[e]),
          (coordNumber = parseFloat(coordStr)),
          Number.isNaN(coordNumber) || C.push(coordNumber);
      if (
        ((standardCommandLen = commandLengths[commandChar]),
        C.length - 1 > standardCommandLen)
      ) {
        let e;
        for (let T = 1, $ = C.length; T < $; T += standardCommandLen) {
          e = [commandChar];
          for (let $ = T, F = T + standardCommandLen; $ < F; $++) e.push(C[$]);
          F.push(e);
        }
      } else F.push(C);
    } else F.push(C);
  return F;
}
var UpdateTag,
  IContainPointMode,
  AttributeUpdateType,
  AnimateStatus,
  AnimateMode,
  AnimateStepType,
  Direction,
  CurveTypeEnum,
  BaseRenderContributionTime;
function segments(e, T, C, $, F, V, Y, K, J) {
  const ee = degreeToRadian(Y),
    te = Math.sin(ee),
    ie = Math.cos(ee),
    ne = ie * (K - e) * 0.5 + te * (J - T) * 0.5,
    re = ie * (J - T) * 0.5 - te * (K - e) * 0.5;
  let ae =
    (ne * ne) / ((C = Math.abs(C)) * C) + (re * re) / (($ = Math.abs($)) * $);
  ae > 1 && ((ae = Math.sqrt(ae)), (C *= ae), ($ *= ae));
  const oe = ie / C,
    se = te / C,
    le = -te / $,
    de = ie / $,
    ce = oe * K + se * J,
    ue = le * K + de * J,
    he = oe * e + se * T,
    pe = le * e + de * T;
  let ge = 1 / ((he - ce) * (he - ce) + (pe - ue) * (pe - ue)) - 0.25;
  ge < 0 && (ge = 0);
  let fe = Math.sqrt(ge);
  V === F && (fe = -fe);
  const me = 0.5 * (ce + he) - fe * (pe - ue),
    ye = 0.5 * (ue + pe) + fe * (he - ce),
    be = Math.atan2(ue - ye, ce - me);
  let ve = Math.atan2(pe - ye, he - me) - be;
  ve < 0 && 1 === V ? (ve += tau) : ve > 0 && 0 === V && (ve -= tau);
  const Te = Math.ceil(Math.abs(ve / (halfPi$1 + 0.001))),
    _e = [];
  for (let Ce = 0; Ce < Te; ++Ce) {
    const e = be + (Ce * ve) / Te,
      T = be + ((Ce + 1) * ve) / Te;
    _e[Ce] = [me, ye, e, T, C, $, te, ie];
  }
  return _e;
}
function bezier(e) {
  const T = e[0],
    C = e[1],
    $ = e[2],
    F = e[3],
    V = e[4],
    Y = e[5],
    K = e[6],
    J = e[7],
    ee = J * V,
    te = -K * Y,
    ie = K * V,
    ne = J * Y,
    re = Math.cos($),
    ae = Math.sin($),
    oe = Math.cos(F),
    se = Math.sin(F),
    le = 0.5 * (F - $),
    de = Math.sin(0.5 * le),
    ce = ((8 / 3) * de * de) / Math.sin(le),
    ue = T + re - ce * ae,
    he = C + ae + ce * re,
    pe = T + oe,
    ge = C + se,
    fe = pe + ce * se,
    me = ge - ce * oe;
  return [
    ee * ue + te * he,
    ie * ue + ne * he,
    ee * fe + te * me,
    ie * fe + ne * me,
    ee * pe + te * ge,
    ie * pe + ne * ge,
  ];
}
function drawArc(e, T, C, $) {
  const F = segments($[5], $[6], $[0], $[1], $[3], $[4], $[2], T, C);
  for (let V = 0; V < F.length; ++V) {
    const T = bezier(F[V]);
    e.bezierCurveTo(T[0], T[1], T[2], T[3], T[4], T[5]);
  }
}
!(function (e) {
  (e[(e.NONE = 0)] = "NONE"),
    (e[(e.UPDATE_BOUNDS = 1)] = "UPDATE_BOUNDS"),
    (e[(e.UPDATE_SHAPE = 2)] = "UPDATE_SHAPE"),
    (e[(e.CLEAR_SHAPE = 253)] = "CLEAR_SHAPE"),
    (e[(e.UPDATE_SHAPE_AND_BOUNDS = 3)] = "UPDATE_SHAPE_AND_BOUNDS"),
    (e[(e.INIT = 179)] = "INIT"),
    (e[(e.CLEAR_BOUNDS = 254)] = "CLEAR_BOUNDS"),
    (e[(e.UPDATE_GLOBAL_MATRIX = 32)] = "UPDATE_GLOBAL_MATRIX"),
    (e[(e.CLEAR_GLOBAL_MATRIX = 223)] = "CLEAR_GLOBAL_MATRIX"),
    (e[(e.UPDATE_LOCAL_MATRIX = 16)] = "UPDATE_LOCAL_MATRIX"),
    (e[(e.CLEAR_LOCAL_MATRIX = 239)] = "CLEAR_LOCAL_MATRIX"),
    (e[(e.UPDATE_GLOBAL_LOCAL_MATRIX = 48)] = "UPDATE_GLOBAL_LOCAL_MATRIX"),
    (e[(e.UPDATE_LAYOUT = 128)] = "UPDATE_LAYOUT"),
    (e[(e.CLEAR_LAYOUT = 127)] = "CLEAR_LAYOUT");
})(UpdateTag || (UpdateTag = {})),
  (function (e) {
    (e[(e.GLOBAL = 1)] = "GLOBAL"),
      (e[(e.LOCAL = 16)] = "LOCAL"),
      (e[(e.GLOBAL_ACCURATE = 3)] = "GLOBAL_ACCURATE"),
      (e[(e.LOCAL_ACCURATE = 48)] = "LOCAL_ACCURATE");
  })(IContainPointMode || (IContainPointMode = {})),
  (function (e) {
    (e[(e.INIT = 0)] = "INIT"),
      (e[(e.DEFAULT = 1)] = "DEFAULT"),
      (e[(e.STATE = 2)] = "STATE"),
      (e[(e.ANIMATE_BIND = 10)] = "ANIMATE_BIND"),
      (e[(e.ANIMATE_PLAY = 11)] = "ANIMATE_PLAY"),
      (e[(e.ANIMATE_START = 12)] = "ANIMATE_START"),
      (e[(e.ANIMATE_UPDATE = 13)] = "ANIMATE_UPDATE"),
      (e[(e.ANIMATE_END = 14)] = "ANIMATE_END"),
      (e[(e.TRANSLATE = 20)] = "TRANSLATE"),
      (e[(e.TRANSLATE_TO = 21)] = "TRANSLATE_TO"),
      (e[(e.SCALE = 22)] = "SCALE"),
      (e[(e.SCALE_TO = 23)] = "SCALE_TO"),
      (e[(e.ROTATE = 24)] = "ROTATE"),
      (e[(e.ROTATE_TO = 25)] = "ROTATE_TO");
  })(AttributeUpdateType || (AttributeUpdateType = {})),
  (function (e) {
    (e[(e.INITIAL = 0)] = "INITIAL"),
      (e[(e.RUNNING = 1)] = "RUNNING"),
      (e[(e.PAUSED = 2)] = "PAUSED"),
      (e[(e.END = 3)] = "END");
  })(AnimateStatus || (AnimateStatus = {})),
  (function (e) {
    (e[(e.NORMAL = 0)] = "NORMAL"),
      (e[(e.SET_ATTR_IMMEDIATELY = 1)] = "SET_ATTR_IMMEDIATELY");
  })(AnimateMode || (AnimateMode = {})),
  (function (e) {
    (e.wait = "wait"),
      (e.from = "from"),
      (e.to = "to"),
      (e.customAnimate = "customAnimate");
  })(AnimateStepType || (AnimateStepType = {})),
  (function (e) {
    (e[(e.ROW = 1)] = "ROW"), (e[(e.COLUMN = 2)] = "COLUMN");
  })(Direction || (Direction = {})),
  (function (e) {
    (e[(e.CubicBezierCurve = 0)] = "CubicBezierCurve"),
      (e[(e.QuadraticBezierCurve = 1)] = "QuadraticBezierCurve"),
      (e[(e.ArcCurve = 2)] = "ArcCurve"),
      (e[(e.LineCurve = 3)] = "LineCurve"),
      (e[(e.EllipseCurve = 4)] = "EllipseCurve"),
      (e[(e.MoveCurve = 5)] = "MoveCurve");
  })(CurveTypeEnum || (CurveTypeEnum = {})),
  (function (e) {
    (e[(e.beforeFillStroke = 0)] = "beforeFillStroke"),
      (e[(e.afterFillStroke = 1)] = "afterFillStroke");
  })(BaseRenderContributionTime || (BaseRenderContributionTime = {}));
const addArcToBezierPath$1 = (e, T, C, $, F, V, Y) => {
    const K = Math.abs(C - T),
      J = (4 * Math.tan(K / 4)) / 3,
      ee = C < T ? -1 : 1,
      te = Math.cos(T),
      ie = Math.sin(T),
      ne = Math.cos(C),
      re = Math.sin(C),
      ae = te * V + $,
      oe = ie * Y + F,
      se = ne * V + $,
      le = re * Y + F,
      de = V * J * ee,
      ce = Y * J * ee;
    e.push(ae - de * ie, oe + ce * te, se + de * re, le - ce * ne, se, le);
  },
  commandFuncs = [
    (e, T, C, $, F, V, Y) =>
      T.arc(
        e[1] * F + C,
        e[2] * V + $,
        (e[3] * (F + V)) / 2,
        e[4],
        e[5],
        e[6],
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.arcTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        (e[5] * (F + V)) / 2,
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.bezierCurveTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        e[5] * F + C,
        e[6] * V + $,
        Y
      ),
    (e, T, C, $) => T.closePath(),
    (e, T, C, $, F, V) =>
      T.ellipse(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F,
        e[4] * V,
        e[5],
        e[6],
        e[7],
        e[8]
      ),
    (e, T, C, $, F, V, Y) => T.lineTo(e[1] * F + C, e[2] * V + $, Y),
    (e, T, C, $, F, V, Y) => T.moveTo(e[1] * F + C, e[2] * V + $, Y),
    (e, T, C, $, F, V, Y) =>
      T.quadraticCurveTo(
        e[1] * F + C,
        e[2] * V + $,
        e[3] * F + C,
        e[4] * V + $,
        Y
      ),
    (e, T, C, $, F, V, Y) =>
      T.rect(e[1] * F + C, e[2] * V + $, e[3] * F, e[4] * V, Y),
  ];
function renderCommandList(e, T, C = 0, $ = 0, F = 1, V = 1, Y) {
  for (let K = 0; K < e.length; K++) {
    const J = e[K];
    commandFuncs[J[0]](J, T, C, $, F, V, Y);
  }
}
class Curve {
  getLength(e) {
    return null != e
      ? this.calcProjLength(e)
      : (Number.isFinite(this.length) || (this.length = this.calcLength()),
        this.length);
  }
}
function snapLength(e, T) {
  let C = 0;
  const $ = e.length;
  for (let F = 0; F < $; F++) {
    const V = e[F],
      Y = T[F],
      K = e[(F + 1) % $],
      J = T[(F + 1) % $];
    C += PointService.distanceNN(V, Y, K, J);
  }
  return C / 2;
}
function cubicLength(e, T, C, $, F) {
  return snapLength([e.x, T.x, C.x, $.x], [e.y, T.y, C.y, $.y]);
}
function cubicCalc(e, T, C, $, F) {
  const V = 1 - F;
  return V * V * V * e + 3 * T * F * V * V + 3 * C * F * F * V + $ * F * F * F;
}
function cubicPointAt(e, T, C, $, F) {
  const V = cubicCalc(e.x, T.x, C.x, $.x, F),
    Y = cubicCalc(e.y, T.y, C.y, $.y, F);
  return new Point(V, Y);
}
function divideCubic(e, T) {
  const { p0: C, p1: $, p2: F, p3: V } = e,
    Y = cubicPointAt(C, $, F, V, T),
    K = PointService.pointAtPP(C, $, T),
    J = PointService.pointAtPP($, F, T),
    ee = PointService.pointAtPP(F, V, T),
    te = PointService.pointAtPP(K, J, T),
    ie = PointService.pointAtPP(J, ee, T);
  return [
    new CubicBezierCurve(C, K, te, Y),
    new CubicBezierCurve(Y, ie, ee, V),
  ];
}
class CubicBezierCurve extends Curve {
  constructor(e, T, C, $) {
    super(),
      (this.type = CurveTypeEnum.CubicBezierCurve),
      (this.p0 = e),
      (this.p1 = T),
      (this.p2 = C),
      (this.p3 = $);
  }
  _validPoint() {
    return Number.isFinite(
      this.p0.x +
        this.p0.y +
        this.p1.x +
        this.p1.y +
        this.p2.x +
        this.p2.y +
        this.p3.x +
        this.p3.y
    );
  }
  getPointAt(e) {
    if (!1 !== this.defined)
      return cubicPointAt(this.p0, this.p1, this.p2, this.p3, e);
    throw new Error("definedfalsegetPointAt");
  }
  calcLength() {
    return this._validPoint()
      ? cubicLength(this.p0, this.p1, this.p2, this.p3)
      : 60;
  }
  calcProjLength(e) {
    return e === Direction.ROW
      ? abs(this.p0.x - this.p3.x)
      : e === Direction.COLUMN
      ? abs(this.p0.y - this.p3.y)
      : 0;
  }
  getAngleAt(e) {
    const T = max(e - 0.01, 0),
      C = min(e + 0.01, 1),
      $ = this.getPointAt(T),
      F = this.getPointAt(C);
    return atan2(F.y - $.y, F.x - $.x);
  }
}
function divideLinear(e, T) {
  const { p0: C, p1: $ } = e,
    F = PointService.pointAtPP(C, $, T);
  return [new LineCurve(C, F), new LineCurve(F, $)];
}
class LineCurve extends Curve {
  constructor(e, T) {
    super(),
      (this.type = CurveTypeEnum.LineCurve),
      (this.p0 = e),
      (this.p1 = T);
  }
  getPointAt(e) {
    if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, e);
    throw new Error("definedfalsegetPointAt");
  }
  getAngleAt(e) {
    return (
      null == this.angle &&
        (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)),
      this.angle
    );
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(e) {
    return e === Direction.ROW
      ? abs(this.p0.x - this.p1.x)
      : e === Direction.COLUMN
      ? abs(this.p0.y - this.p1.y)
      : 0;
  }
}
class SegContext {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(e, T) {
    this.init(e, T);
  }
  init(e, T) {
    (this._lastX = this._lastY = this._startX = this._startY = 0),
      (this.curveType = e),
      (this.direction = T),
      (this.curves = []);
  }
  bezierCurveTo(e, T, C, $, F, V, Y, K) {
    const J = new CubicBezierCurve(
      new Point(this._lastX, this._lastY),
      new Point(e, T),
      new Point(C, $),
      new Point(F, V)
    );
    (J.originP1 = this._lastOriginP),
      (J.originP2 = K),
      (J.defined = Y),
      this.curves.push(J),
      (this._lastX = F),
      (this._lastY = V),
      (this._lastOriginP = K);
  }
  closePath() {
    if (this.curves.length < 2) return;
    const e = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, e.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContextellipse");
  }
  lineTo(e, T, C, $) {
    const F = this.addLinearCurve(e, T, C, this._lastOriginP, $);
    this.curves.push(F),
      (this._lastX = e),
      (this._lastY = T),
      (this._lastOriginP = $);
  }
  moveTo(e, T, C) {
    return (
      (this._lastX = this._startX = e),
      (this._lastY = this._startY = T),
      (this._lastOriginP = C),
      (this._startOriginP = C),
      this
    );
  }
  quadraticCurveTo(e, T, C, $) {
    throw new Error("SegContextquadraticCurveTo");
  }
  clear() {
    (this.curves = []), (this.length = NaN);
  }
  tryUpdateLength(e) {
    return this.getLength(e);
  }
  addLinearCurve(e, T, C, $, F) {
    const V = new LineCurve(
      new Point(this._lastX, this._lastY),
      new Point(e, T)
    );
    return (V.originP1 = $), (V.originP2 = F), (V.defined = C), V;
  }
  getPointAt(e) {
    throw new Error("");
  }
  getCurveLengths() {
    return [];
  }
  getLength(e) {
    var T, C;
    if (e === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        C = this.curves[this.curves.length - 1],
        $ = null !== (T = C.p3) && void 0 !== T ? T : C.p1;
      return abs(e.p0.y - $.y);
    }
    if (e === Direction.ROW) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1],
        $ = null !== (C = T.p3) && void 0 !== C ? C : T.p1;
      return abs(e.p0.x - $.x);
    }
    return (
      Number.isFinite(this.length) ||
        (this.length = this.curves.reduce((e, T) => e + T.getLength(), 0)),
      this.length
    );
  }
}
class ReflectSegContext extends SegContext {
  bezierCurveTo(e, T, C, $, F, V, Y, K) {
    return super.bezierCurveTo(T, e, $, C, V, F, Y, K);
  }
  lineTo(e, T, C, $) {
    return super.lineTo(T, e, C, $);
  }
  moveTo(e, T, C) {
    return super.moveTo(T, e, C);
  }
  clear() {
    return super.clear();
  }
}
function genCurveSegments(e, T, C = 1) {
  let $ = !1;
  for (let F = 0, V = T.length; F <= V; F++)
    F >= V === $ && (($ = !$) ? e.lineStart() : e.lineEnd()),
      $ && e.point(T[F]);
}
function genSegContext(e, T, C) {
  const $ =
    null != T
      ? T
      : abs(C[C.length - 1].x - C[0].x) > abs(C[C.length - 1].y - C[0].y)
      ? Direction.ROW
      : Direction.COLUMN;
  return "monotoneY" === e ? new ReflectSegContext(e, $) : new SegContext(e, $);
}
class Linear {
  constructor(e, T) {
    (this.context = e), T && (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._point = 0), this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined && !1 !== e.defined,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(
          T,
          C,
          !1 !== this._lastDefined && !1 !== e.defined,
          e
        );
    }
    this._lastDefined = e.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genLinearSegments(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  const F = genSegContext("linear", C, e);
  return genLinearTypeSegments(new Linear(F, $), e), F;
}
function genLinearTypeSegments(e, T) {
  return genCurveSegments(e, T, 1);
}
function point$3(e, T, C, $, F) {
  e.context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + T) / 6,
    (e._y0 + 4 * e._y1 + C) / 6,
    $,
    e.lastPoint1
  );
}
class Basis {
  constructor(e, T) {
    (this.context = e), (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._y0 = this._y1 = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    2 === this._point &&
      point$3(
        this,
        6 * this._x1 - (this._x0 + 4 * this._x1),
        6 * this._y1 - (this._y0 + 4 * this._y1),
        !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
        this.lastPoint1
      ),
      (this._line || (0 !== this._line && 1 === this._point)) &&
        this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point$3(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._x0 = this._x1),
      (this._x1 = T),
      (this._y0 = this._y1),
      (this._y1 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genBasisTypeSegments(e, T) {
  return genCurveSegments(e, T, 2);
}
function genBasisSegments(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments(e, T);
  const F = genSegContext("basis", C, e);
  return genBasisTypeSegments(new Basis(F, $), e), F;
}
function sign(e) {
  return e < 0 ? -1 : 1;
}
function slope3(e, T, C) {
  const $ = e._x1 - e._x0,
    F = T - e._x1,
    V = (e._y1 - e._y0) / ($ || Number(F < 0 && -0)),
    Y = (C - e._y1) / (F || Number($ < 0 && -0)),
    K = (V * F + Y * $) / ($ + F);
  return (
    (sign(V) + sign(Y)) *
      Math.min(Math.abs(V), Math.abs(Y), 0.5 * Math.abs(K)) || 0
  );
}
function slope2(e, T) {
  const C = e._x1 - e._x0;
  return C ? ((3 * (e._y1 - e._y0)) / C - T) / 2 : T;
}
function point$2(e, T, C, $, F) {
  const V = e._x0,
    Y = e._y0,
    K = e._x1,
    J = e._y1,
    ee = (K - V) / 3;
  e.context.bezierCurveTo(
    V + ee,
    Y + ee * T,
    K - ee,
    J - ee * C,
    K,
    J,
    $,
    e.lastPoint1
  );
}
class MonotoneX {
  constructor(e, T) {
    (this.context = e), (this.startPoint = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(
          this._x1,
          this._y1,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
        break;
      case 3:
        point$2(
          this,
          this._t0,
          slope2(this, this._t0),
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
    }
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    let T = NaN;
    const C = e.x,
      $ = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                C,
                $,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
                e
              )
            : this.context.moveTo(C, $, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        (this._point = 3),
          point$2(
            this,
            slope2(this, (T = slope3(this, C, $))),
            T,
            !1 !== this._lastDefined1 && !1 !== this._lastDefined2
          );
        break;
      default:
        point$2(
          this,
          this._t0,
          (T = slope3(this, C, $)),
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._x0 = this._x1),
      (this._x1 = C),
      (this._y0 = this._y1),
      (this._y1 = $),
      (this._t0 = T),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = !1 !== e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
class MonotoneY extends MonotoneX {
  constructor(e, T) {
    super(e, T);
  }
  point(e) {
    return super.point({
      y: e.x,
      x: e.y,
      defined: e.defined,
    });
  }
}
function genMonotoneXTypeSegments(e, T) {
  return genCurveSegments(e, T, 2);
}
function genMonotoneXSegments(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments(e, T);
  const F = genSegContext("monotoneX", C, e);
  return genMonotoneXTypeSegments(new MonotoneX(F, $), e), F;
}
function genMonotoneYTypeSegments(e, T) {
  return genCurveSegments(e, T, 2);
}
function genMonotoneYSegments(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  if (e.length < 3 - Number(!!$)) return genLinearSegments(e, T);
  const F = genSegContext("monotoneY", C, e);
  return genMonotoneYTypeSegments(new MonotoneY(F, $), e), F;
}
class Step$1 {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this._t = T), (this.startPoint = C);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x = this._y = NaN),
      (this._point = 0),
      this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t &&
      this._t < 1 &&
      2 === this._point &&
      this.context.lineTo(
        this._x,
        this._y,
        !1 !== this._lastDefined,
        this.lastPoint
      ),
      (this._line || (0 !== this._line && 1 === this._point)) &&
        this.context.closePath(),
      this._line >= 0 &&
        ((this._t = 1 - this._t), (this._line = 1 - this._line));
  }
  point(e) {
    const T = e.x,
      C = e.y;
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined && !1 !== e.defined,
                e
              )
            : this.context.moveTo(T, C, e);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0)
          this.context.lineTo(
            this._x,
            C,
            !1 !== this._lastDefined && !1 !== e.defined,
            this.lastPoint
          ),
            this.context.lineTo(
              T,
              C,
              !1 !== this._lastDefined && !1 !== e.defined,
              e
            );
        else {
          const $ = this._x * (1 - this._t) + T * this._t;
          this.context.lineTo(
            $,
            this._y,
            !1 !== this._lastDefined && !1 !== e.defined,
            this.lastPoint
          ),
            this.context.lineTo(
              $,
              C,
              !1 !== this._lastDefined && !1 !== e.defined,
              e
            );
        }
    }
    (this._lastDefined = e.defined),
      (this._x = T),
      (this._y = C),
      (this.lastPoint = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genStepSegments(e, T, C = {}) {
  const { direction: $, startPoint: F } = C;
  if (e.length < 2 - Number(!!F)) return null;
  const V = new SegContext(
    "step",
    null != $
      ? $
      : abs(e[e.length - 1].x - e[0].x) > abs(e[e.length - 1].y - e[0].y)
      ? Direction.ROW
      : Direction.COLUMN
  );
  return genStepTypeSegments(new Step$1(V, T, F), e), V;
}
function genStepTypeSegments(e, T) {
  return genCurveSegments(e, T, 1);
}
class LinearClosed extends Linear {
  lineEnd() {
    this.context.closePath();
  }
}
function genLinearClosedSegments(e, T = {}) {
  const { direction: C, startPoint: $ } = T;
  if (e.length < 2 - Number(!!$)) return null;
  const F = genSegContext("linear", C, e);
  return genLinearClosedTypeSegments(new LinearClosed(F, $), e), F;
}
function genLinearClosedTypeSegments(e, T) {
  return genCurveSegments(e, T, 1);
}
function point$1(e, T, C, $, F) {
  let V = e._x1,
    Y = e._y1,
    K = e._x2,
    J = e._y2;
  if (e._l01_a > epsilon) {
    const T = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
      C = 3 * e._l01_a * (e._l01_a + e._l12_a);
    (V = (V * T - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / C),
      (Y = (Y * T - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / C);
  }
  if (e._l23_a > epsilon) {
    const $ = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
      F = 3 * e._l23_a * (e._l23_a + e._l12_a);
    (K = (K * $ + e._x1 * e._l23_2a - T * e._l12_2a) / F),
      (J = (J * $ + e._y1 * e._l23_2a - C * e._l12_2a) / F);
  }
  e.context.bezierCurveTo(V, Y, K, J, e._x2, e._y2, $, e.lastPoint1);
}
class CatmullRom {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this.startPoint = C), (this._alpha = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(
          this._x2,
          this._y2,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        );
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2,
        });
    }
    (this._line || (0 !== this._line && 1 === this._point)) &&
      this.context.closePath(),
      (this._line = 1 - this._line);
  }
  point(e) {
    const { x: T, y: C } = e;
    if (this._point) {
      const e = this._x2 - T,
        $ = this._y2 - C;
      this._l23_a = Math.sqrt(
        (this._l23_2a = Math.pow(e * e + $ * $, this._alpha))
      );
    }
    switch (this._point) {
      case 0:
        (this._point = 1),
          this._line
            ? this.context.lineTo(
                T,
                C,
                !1 !== this._lastDefined1 && !1 !== this._lastDefined2
              )
            : this.context.moveTo(T, C);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = T),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function commonGenCatmullRomSegments(e, T) {
  return function (C, $, F = {}) {
    const { direction: V, startPoint: Y } = F;
    if (C.length < 2 - Number(!!Y)) return null;
    if (C.length < 3 - Number(!!Y)) return genLinearSegments(C, F);
    const K = genSegContext(e, V, C);
    return genCurveSegments(new T(K, $, Y), C, 2), K;
  };
}
const genCatmullRomSegments = commonGenCatmullRomSegments(
  "catmullRom",
  CatmullRom
);
class CatmullRomClosed {
  constructor(e, T = 0.5, C) {
    (this.context = e), (this.startPoint = C), (this._alpha = T);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    (this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0);
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1),
          this.context.closePath();
        break;
      case 2:
        this.context.lineTo(
          this._x3,
          this._y3,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2,
          this.lastPoint1
        ),
          this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3,
        }),
          this.point({
            x: this._x4,
            y: this._y4,
          }),
          this.point({
            x: this._x5,
            y: this._y5,
          });
    }
  }
  point(e) {
    const { x: T, y: C } = e;
    if (this._point) {
      const e = this._x2 - T,
        $ = this._y2 - C;
      this._l23_a = Math.sqrt(
        (this._l23_2a = Math.pow(e * e + $ * $, this._alpha))
      );
    }
    switch (this._point) {
      case 0:
        (this._point = 1), (this._x3 = T), (this._y3 = C);
        break;
      case 1:
        (this._point = 2),
          this.context.moveTo((this._x4 = T), (this._y4 = C), e);
        break;
      case 2:
        (this._point = 3), (this._x5 = T), (this._y5 = C);
        break;
      default:
        point$1(
          this,
          T,
          C,
          !1 !== this._lastDefined1 && !1 !== this._lastDefined2
        );
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = T),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = C),
      (this._lastDefined1 = this._lastDefined2),
      (this._lastDefined2 = e.defined),
      (this.lastPoint0 = this.lastPoint1),
      (this.lastPoint1 = e);
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
const genCatmullRomClosedSegments = commonGenCatmullRomSegments(
  "catmullRomClosed",
  CatmullRomClosed
);
function calcLineCache$1(e, T, C) {
  var $, F;
  switch (T) {
    case "linear":
    default:
      return genLinearSegments(e, C);
    case "basis":
      return genBasisSegments(e, C);
    case "monotoneX":
      return genMonotoneXSegments(e, C);
    case "monotoneY":
      return genMonotoneYSegments(e, C);
    case "step":
      return genStepSegments(e, 0.5, C);
    case "stepBefore":
      return genStepSegments(e, 0, C);
    case "stepAfter":
      return genStepSegments(e, 1, C);
    case "catmullRom":
      return genCatmullRomSegments(
        e,
        null !== ($ = null == C ? void 0 : C.curveTension) && void 0 !== $
          ? $
          : 0.5,
        C
      );
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(
        e,
        null !== (F = null == C ? void 0 : C.curveTension) && void 0 !== F
          ? F
          : 0.5,
        C
      );
    case "linearClosed":
      return genLinearClosedSegments(e, C);
  }
}
class CustomPath2D extends CurvePath {
  constructor(e) {
    super(),
      (this.commandList = []),
      e && (this._ctx = e),
      (this._boundsContext = new BoundsContext(this.bounds));
  }
  setCtx(e) {
    this._ctx = e;
  }
  moveTo(e, T) {
    return (
      this.commandList.push([enumCommandMap.M, e, T]),
      this._ctx && this._ctx.moveTo(e, T),
      this
    );
  }
  lineTo(e, T) {
    return (
      this.commandList.push([enumCommandMap.L, e, T]),
      this._ctx && this._ctx.lineTo(e, T),
      this
    );
  }
  quadraticCurveTo(e, T, C, $) {
    return (
      this.commandList.push([enumCommandMap.Q, e, T, C, $]),
      this._ctx && this._ctx.quadraticCurveTo(e, T, C, $),
      this
    );
  }
  bezierCurveTo(e, T, C, $, F, V) {
    return (
      this.commandList.push([enumCommandMap.C, e, T, C, $, F, V]),
      this._ctx && this._ctx.bezierCurveTo(e, T, C, $, F, V),
      this
    );
  }
  arcTo(e, T, C, $, F) {
    return (
      this.commandList.push([enumCommandMap.AT, e, T, C, $, F]),
      this._ctx && this._ctx.arcTo(e, T, C, $, F),
      this
    );
  }
  ellipse(e, T, C, $, F, V, Y, K) {
    return (
      this.commandList.push([enumCommandMap.E, e, T, C, $, F, V, Y, K]),
      this._ctx && this._ctx.ellipse(e, T, C, $, F, V, Y, K),
      this
    );
  }
  rect(e, T, C, $) {
    return (
      this.commandList.push([enumCommandMap.R, e, T, C, $]),
      this._ctx && this._ctx.rect(e, T, C, $),
      this
    );
  }
  arc(e, T, C, $, F, V) {
    return (
      this.commandList.push([enumCommandMap.A, e, T, C, $, F, V]),
      this._ctx && this._ctx.arc(e, T, C, $, F, V),
      this
    );
  }
  closePath() {
    return (
      this.commandList.push([enumCommandMap.Z]),
      this._ctx && this._ctx.closePath(),
      this
    );
  }
  addCurve(e) {
    this.curves.push(e);
  }
  clear() {
    (this.transformCbList = null),
      (this.commandList.length = 0),
      (this.curves.length = 0);
  }
  beginPath() {
    this.clear();
  }
  toString() {
    if (!this.toStringCbList) {
      const e = [];
      (e[enumCommandMap.M] = (e) => `M${e[1]} ${e[2]}`),
        (e[enumCommandMap.L] = (e) => `L${e[1]} ${e[2]}`),
        (e[enumCommandMap.Q] = (e) => `Q${e[1]} ${e[2]} ${e[3]} ${e[4]}`),
        (e[enumCommandMap.C] = (e) =>
          `C${e[1]} ${e[2]} ${e[3]} ${e[4]} ${e[5]} ${e[6]}`),
        (e[enumCommandMap.A] = (e) => {
          const T = [];
          addArcToBezierPath$1(T, e[4], e[5], e[1], e[2], e[3], e[3]);
          let C = "";
          for (let $ = 0; $ < T.length; $ += 6)
            C += `C${T[$]} ${T[$ + 1]} ${T[$ + 2]} ${T[$ + 3]} ${T[$ + 4]} ${
              T[$ + 5]
            }`;
          return C;
        }),
        (e[enumCommandMap.R] = (e) =>
          `M${e[1]} ${e[2]} h${e[3]} v${e[4]} H${e[1]}Z`),
        (e[enumCommandMap.Z] = (e) => "Z"),
        (this.toStringCbList = e);
    }
    const e = this.toStringCbList;
    let T = "";
    return (
      this.commandList.forEach((C) => {
        T += e[C[0]](C);
      }),
      T
    );
  }
  fromString(e, T, C, $, F) {
    this.clear();
    const V = parseSvgPath(e);
    return this._runCommandStrList(V, T, C, $, F), this._updateBounds(), this;
  }
  fromLine(e) {
    const { points: T, curveType: C, clipRangeByDimension: $ } = e.attribute;
    if (!T) return;
    const F = calcLineCache$1(T, C);
    "x" === $
      ? (this.direction = Direction.ROW)
      : "y" === $
      ? (this.direction = Direction.COLUMN)
      : "auto" === $ && (this.direction = F.direction),
      (this.curves = F.curves);
  }
  fromCustomPath2D(e, T, C, $, F) {
    return (
      this.clear(),
      this._runCommandList(e.commandList, T, C, $, F),
      this._updateBounds(),
      this
    );
  }
  transform(e, T, C, $) {
    const F = this.commandList;
    if (!this.transformCbList) {
      const e = [];
      (e[enumCommandMap.M] = this.moveToTransform),
        (e[enumCommandMap.L] = this.lineToTransform),
        (e[enumCommandMap.Q] = this.quadraticCurveToTransform),
        (e[enumCommandMap.C] = this.bezierCurveToTransform),
        (e[enumCommandMap.AT] = this.arcToTransform),
        (e[enumCommandMap.E] = this.ellipseTransform),
        (e[enumCommandMap.R] = this.rectTransform),
        (e[enumCommandMap.A] = this.arcTransform),
        (e[enumCommandMap.Z] = this.closePathTransform),
        (this.transformCbList = e);
    }
    F.forEach((F) => {
      this.transformCbList[F[0]](F, e, T, C, $);
    }),
      this._updateBounds();
  }
  moveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C);
  }
  lineToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C);
  }
  quadraticCurveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C);
  }
  bezierCurveToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C),
      (e[5] = e[5] * $ + T),
      (e[6] = e[6] * F + C);
  }
  arcToTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $ + T),
      (e[4] = e[4] * F + C),
      (e[5] = (e[5] * ($ + F)) / 2);
  }
  ellipseTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $),
      (e[4] = e[4] * F);
  }
  rectTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T),
      (e[2] = e[2] * F + C),
      (e[3] = e[3] * $),
      (e[4] = e[4] * F);
  }
  arcTransform(e, T, C, $, F) {
    (e[1] = e[1] * $ + T), (e[2] = e[2] * F + C), (e[3] = (e[3] * ($ + F)) / 2);
  }
  closePathTransform() {}
  _runCommandStrList(e, T = 0, C = 0, $ = 1, F = 1) {
    let V,
      Y,
      K,
      J,
      ee,
      te = null,
      ie = 0,
      ne = 0,
      re = 0,
      ae = 0;
    for (let oe = 0, se = e.length; oe < se; ++oe) {
      switch (
        ((V = e[oe]), (1 === $ && 1 === F) || (V = scale$1(V, $, F)), V[0])
      ) {
        case "l":
          (ie += V[1]), (ne += V[2]), this.lineTo(ie + T, ne + C);
          break;
        case "L":
          (ie = V[1]), (ne = V[2]), this.lineTo(ie + T, ne + C);
          break;
        case "h":
          (ie += V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "H":
          (ie = V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "v":
          (ne += V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "V":
          (ne = V[1]), this.lineTo(ie + T, ne + C);
          break;
        case "m":
          (ie += V[1]), (ne += V[2]), this.moveTo(ie + T, ne + C);
          break;
        case "M":
          (ie = V[1]), (ne = V[2]), this.moveTo(ie + T, ne + C);
          break;
        case "c":
          (Y = ie + V[5]),
            (K = ne + V[6]),
            (re = ie + V[3]),
            (ae = ne + V[4]),
            this.bezierCurveTo(
              ie + V[1] + T,
              ne + V[2] + C,
              re + T,
              ae + C,
              Y + T,
              K + C
            ),
            (ie = Y),
            (ne = K);
          break;
        case "C":
          (ie = V[5]),
            (ne = V[6]),
            (re = V[3]),
            (ae = V[4]),
            this.bezierCurveTo(
              V[1] + T,
              V[2] + C,
              re + T,
              ae + C,
              ie + T,
              ne + C
            );
          break;
        case "s":
          (Y = ie + V[3]),
            (K = ne + V[4]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.bezierCurveTo(
              re + T,
              ae + C,
              ie + V[1] + T,
              ne + V[2] + C,
              Y + T,
              K + C
            ),
            (re = ie + V[1]),
            (ae = ne + V[2]),
            (ie = Y),
            (ne = K);
          break;
        case "S":
          (Y = V[3]),
            (K = V[4]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.bezierCurveTo(
              re + T,
              ae + C,
              V[1] + T,
              V[2] + C,
              Y + T,
              K + C
            ),
            (ie = Y),
            (ne = K),
            (re = V[1]),
            (ae = V[2]);
          break;
        case "q":
          (Y = ie + V[3]),
            (K = ne + V[4]),
            (re = ie + V[1]),
            (ae = ne + V[2]),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K);
          break;
        case "Q":
          (Y = V[3]),
            (K = V[4]),
            this.quadraticCurveTo(V[1] + T, V[2] + C, Y + T, K + C),
            (ie = Y),
            (ne = K),
            (re = V[1]),
            (ae = V[2]);
          break;
        case "t":
          (Y = ie + V[1]),
            (K = ne + V[2]),
            null === te[0].match(/[QqTt]/)
              ? ((re = ie), (ae = ne))
              : "t" === te[0]
              ? ((re = 2 * ie - J), (ae = 2 * ne - ee))
              : "q" === te[0] && ((re = 2 * ie - re), (ae = 2 * ne - ae)),
            (J = re),
            (ee = ae),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K),
            (re = ie + V[1]),
            (ae = ne + V[2]);
          break;
        case "T":
          (Y = V[1]),
            (K = V[2]),
            (re = 2 * ie - re),
            (ae = 2 * ne - ae),
            this.quadraticCurveTo(re + T, ae + C, Y + T, K + C),
            (ie = Y),
            (ne = K);
          break;
        case "a":
          drawArc(this, ie + T, ne + C, [
            V[1],
            V[2],
            V[3],
            V[4],
            V[5],
            V[6] + ie + T,
            V[7] + ne + C,
          ]),
            (ie += V[6]),
            (ne += V[7]);
          break;
        case "A":
          drawArc(this, ie + T, ne + C, [
            V[1],
            V[2],
            V[3],
            V[4],
            V[5],
            V[6] + T,
            V[7] + C,
          ]),
            (ie = V[6]),
            (ne = V[7]);
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      te = V;
    }
  }
  _runCommandList(e, T = 0, C = 0, $ = 1, F = 1) {
    if (0 !== T || 0 !== C || 1 !== $ || 1 !== F)
      for (let V = 0, Y = e.length; V < Y; ++V) {
        const Y = e[V].slice();
        switch (Y[0]) {
          case enumCommandMap.L:
            this.lineToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.M:
            this.moveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.C:
            this.bezierCurveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.Q:
            this.quadraticCurveToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.A:
            this.arcToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.E:
            this.ellipseTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.R:
            this.rectTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.AT:
            this.arcToTransform(Y, T, C, $, F);
            break;
          case enumCommandMap.Z:
            this.closePath();
        }
      }
    else this.commandList = e.map((e) => e.slice());
  }
  _updateBounds() {
    this.bounds.clear(),
      renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    (this.commandList = []), (this._boundsContext = null), (this._ctx = null);
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1];
      return abs(e.p0.y - T.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this.curves.length) return 0;
      const e = this.curves[0],
        T = this.curves[this.curves.length - 1];
      return abs(e.p0.x - T.p1.x);
    }
    return this.curves.reduce((e, T) => e + T.getLength(), 0);
  }
  getAttrAt(e) {
    if (!this.curves)
      return {
        pos: {
          x: 0,
          y: 0,
        },
        angle: 0,
      };
    let T,
      C = 0;
    for (let F = 0; F < this.curves.length; F++) {
      T = this.curves[F];
      const $ = T.getLength(this.direction);
      if (C + $ >= e) break;
      C += $;
    }
    const $ = (e - C) / T.getLength(this.direction);
    return {
      pos: T.getPointAt($),
      angle: T.getAngleAt($),
    };
  }
}
const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(e, T, C) {
  const $ = (temp[0] = e[0]);
  if ("a" === $ || "A" === $)
    (temp[1] = T * e[1]),
      (temp[2] = C * e[2]),
      (temp[3] = e[3]),
      (temp[4] = e[4]),
      (temp[5] = e[5]),
      (temp[6] = T * e[6]),
      (temp[7] = C * e[7]);
  else if ("h" === $ || "H" === $) temp[1] = T * e[1];
  else if ("v" === $ || "V" === $) temp[1] = C * e[1];
  else
    for (let F = 1, V = e.length; F < V; ++F)
      temp[F] = (F % 2 == 1 ? T : C) * e[F];
  return temp;
}
const DefaultLayout = {
    alignSelf: "auto",
  },
  DefaultTransform = {
    x: 0,
    y: 0,
    z: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    scrollX: 0,
    scrollY: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    angle: 0,
    alpha: 0,
    beta: 0,
    scaleCenter: [0, 0],
    anchor: [0, 0],
    anchor3d: [0, 0],
    postMatrix: new Matrix(),
  },
  DefaultFillStyle = {
    fillOpacity: 1,
    fill: !1,
    shadowBlur: 0,
    shadowColor: "black",
    shadowOffsetX: 0,
    shadowOffsetY: 0,
  },
  commonStroke = {
    strokeOpacity: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    strokeBoundsBuffer: 2,
    stroke: !1,
  },
  DefaultStrokeStyle = Object.assign(
    {
      outerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0,
      }),
      innerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0,
      }),
    },
    commonStroke
  ),
  DefaultTextStyle = {
    text: "",
    maxLineWidth: 1 / 0,
    textAlign: "left",
    textBaseline: "alphabetic",
    fontSize: 16,
    fontFamily:
      "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
    fontWeight: "",
    ellipsis: "",
    fontVariant: "",
    fontStyle: "",
    lineHeight: void 0,
    underline: 0,
    lineThrough: 0,
    scaleIn3d: !1,
    direction: "horizontal",
    wordBreak: "break-all",
    ignoreBuf: !1,
    verticalMode: 0,
    wrap: !1,
    whiteSpace: "no-wrap",
    heightLimit: 1 / 0,
    lineClamp: 1 / 0,
    suffixPosition: "end",
    underlineDash: [],
    underlineOffset: 0,
    disableAutoClipedPoptip: void 0,
  },
  DefaultPickStyle = {
    pickStrokeBuffer: 0,
  },
  DefaultStyle = Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          {
            forceBoundsWidth: void 0,
            forceBoundsHeight: void 0,
            opacity: 1,
            background: null,
            backgroundOpacity: 1,
            backgroundCornerRadius: 0,
            texture: null,
            textureColor: "black",
            textureSize: 10,
            texturePadding: 2,
            backgroundMode: "no-repeat",
            backgroundFit: !0,
            blur: 0,
            cursor: null,
            html: null,
            react: null,
          },
          DefaultFillStyle
        ),
        DefaultStrokeStyle
      ),
      DefaultLayout
    ),
    DefaultPickStyle
  ),
  DefaultConnectAttribute = {
    connectedType: "none",
    connectedStyle: {},
    connectedX: NaN,
    connectedY: NaN,
  },
  DefaultDebugAttribute = {
    _debug_bounds: !1,
  },
  DefaultAttribute = Object.assign(
    Object.assign(
      Object.assign(
        {
          strokeSeg: null,
          renderable: !0,
          pickable: !0,
          shadowGraphic: void 0,
          childrenPickable: !0,
          fillPickable: !0,
          strokePickable: !0,
          visible: !0,
          zIndex: 0,
          layout: null,
          boundsPadding: 0,
          renderStyle: "default",
          pickMode: "accurate",
          customPickShape: null,
          boundsMode: "accurate",
          keepDirIn3d: !0,
          shadowRootIdx: 1,
          globalZIndex: 1,
          globalCompositeOperation: "",
          overflow: "hidden",
          shadowPickMode: "graphic",
        },
        DefaultDebugAttribute
      ),
      DefaultStyle
    ),
    DefaultTransform
  ),
  DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    startAngle: 0,
    endAngle: pi2,
    innerRadius: 0,
    outerRadius: 1,
    innerPadding: 0,
    outerPadding: 0,
    cornerRadius: 0,
    padRadius: 0,
    padAngle: 0,
    cap: !1,
    forceShowCap: !1,
  }),
  DefaultAreaAttribute = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute),
    {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      closePath: !1,
      curveTension: 1,
    }
  ),
  DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    radius: 1,
    startAngle: 0,
    endAngle: pi2,
  }),
  DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    width: 0,
    height: 0,
    cornerRadius: 0,
    path: [],
    clip: !1,
    visibleAll: !0,
    display: "relative",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "flex-start",
    alignItems: "flex-start",
    alignContent: "flex-start",
    baseOpacity: 1,
  }),
  DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    path: "",
    width: 0,
    height: 0,
    cornerRadius: 0,
    clip: !1,
  }),
  DefaultLineAttribute = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute),
    {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      clipRangeByDimension: "default",
      closePath: !1,
      curveTension: 1,
    }
  ),
  DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    path: new CustomPath2D(),
    customPath: () => {
      Logger.getInstance().warn("");
    },
  }),
  DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    points: [],
    cornerRadius: 0,
    closePath: !0,
  }),
  DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    width: 0,
    height: 0,
    x1: 0,
    y1: 0,
    strokeBoundsBuffer: 0,
    cornerRadius: 0,
  });
Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
});
const DefaultSymbolAttribute = Object.assign(
    Object.assign({}, DefaultAttribute),
    {
      symbolType: "circle",
      size: 10,
      keepDirIn3d: !0,
    }
  ),
  DefaultTextAttribute = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle),
    {
      strokeBoundsBuffer: 0,
      keepDirIn3d: !0,
    }
  ),
  DefaultRichTextAttribute = Object.assign(
    Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle),
    {
      editable: !1,
      width: 300,
      height: 300,
      ellipsis: !0,
      wordBreak: "break-word",
      verticalDirection: "top",
      textAlign: "left",
      textBaseline: "top",
      layoutDirection: "horizontal",
      textConfig: [],
      disableAutoWrapLine: !1,
      maxHeight: void 0,
      maxWidth: void 0,
      singleLine: !1,
    }
  ),
  DefaultImageAttribute = Object.assign(
    Object.assign(
      {
        repeatX: "no-repeat",
        repeatY: "no-repeat",
        image: "",
        width: 0,
        height: 0,
      },
      DefaultAttribute
    ),
    {
      fill: !0,
      cornerRadius: 0,
    }
  ),
  DefaultRichTextIconAttribute = Object.assign(
    Object.assign({}, DefaultImageAttribute),
    {
      backgroundShowMode: "never",
      backgroundWidth: 0,
      backgroundHeight: 0,
      textAlign: "left",
      textBaseline: "middle",
      direction: "horizontal",
      margin: 0,
      id: "",
      width: 20,
      height: 20,
      backgroundFill: "rgba(101, 117, 168, 0.1)",
      backgroundFillOpacity: 1,
      backgroundStroke: !1,
      backgroundStrokeOpacity: 1,
      backgroundRadius: 4,
      opacity: 1,
    }
  );
class Application {}
const application = new Application(),
  DIRECTION_KEY = {
    horizontal: {
      width: "width",
      height: "height",
      left: "left",
      top: "top",
      x: "x",
      y: "y",
      bottom: "bottom",
    },
    vertical: {
      width: "height",
      height: "width",
      left: "top",
      top: "left",
      x: "y",
      y: "x",
      bottom: "right",
    },
  },
  defaultFormatting = {
    fontSize: 16,
    fontFamily: "sans-serif",
    fill: !0,
    stroke: !1,
    fontWeight: "normal",
    lineHeight: "normal",
    fontStyle: "normal",
    textDecoration: "none",
    textAlign: "left",
    script: "normal",
  },
  regLetter = /\w|\(|\)|-/,
  regPunctuation = /[.?!,;:/]/,
  regFirstSpace = /\S/;
function applyFillStyle(e, T) {
  const C = (T && T.fill) || defaultFormatting.fill;
  if (!C) return void (e.globalAlpha = 0);
  const { fillOpacity: $ = 1, opacity: F = 1 } = T;
  (e.globalAlpha = $ * F), (e.fillStyle = C);
  let V = T.fontSize || 16;
  switch (T.script) {
    case "super":
    case "sub":
      V *= 0.8;
  }
  e.setTextStyle({
    textAlign: "left",
    textBaseline: T.textBaseline || "alphabetic",
    fontStyle: T.fontStyle || "",
    fontWeight: T.fontWeight || "",
    fontSize: V,
    fontFamily: T.fontFamily || "sans-serif",
  });
}
function applyStrokeStyle(e, T) {
  const C = (T && T.stroke) || defaultFormatting.stroke;
  if (!C) return void (e.globalAlpha = 0);
  const { strokeOpacity: $ = 1, opacity: F = 1 } = T;
  (e.globalAlpha = $ * F),
    (e.lineWidth = T && "number" == typeof T.lineWidth ? T.lineWidth : 1),
    (e.strokeStyle = C);
  let V = T.fontSize || 16;
  switch (T.script) {
    case "super":
    case "sub":
      V *= 0.8;
  }
  e.setTextStyle({
    textAlign: "left",
    textBaseline: T.textBaseline || "alphabetic",
    fontStyle: T.fontStyle || "",
    fontWeight: T.fontWeight || "",
    fontSize: V,
    fontFamily: T.fontFamily || "sans-serif",
  });
}
function getStrByWithCanvas(e, T, C, $, F) {
  if (!T || T <= 0) return 0;
  const V = application.graphicUtil.textMeasure;
  let Y = $,
    K = e.slice(0, Y),
    J = Math.floor(V.measureText(K, C).width),
    ee = e.slice(0, Y + 1),
    te = Math.floor(V.measureText(ee, C).width);
  for (; J > T || te <= T; ) {
    if ((J > T ? Y-- : Y++, Y > e.length)) {
      Y = e.length;
      break;
    }
    if (Y < 0) {
      Y = 0;
      break;
    }
    (K = e.slice(0, Y)),
      (J = Math.floor(V.measureText(K, C).width)),
      (ee = e.slice(0, Y + 1)),
      (te = Math.floor(V.measureText(ee, C).width));
  }
  return F && (Y = testLetter(e, Y)), Y;
}
function testLetter(e, T) {
  let C = T;
  for (
    ;
    (regLetter.test(e[C - 1]) && regLetter.test(e[C])) ||
    regPunctuation.test(e[C]);

  )
    if ((C--, C <= 0)) return T;
  return C;
}
function measureTextCanvas(e, T) {
  const C = application.graphicUtil.textMeasure.measureText(e, T),
    $ = {
      ascent: 0,
      height: 0,
      descent: 0,
      width: 0,
    };
  return (
    "number" != typeof C.actualBoundingBoxAscent ||
    "number" != typeof C.actualBoundingBoxDescent
      ? (($.width = Math.floor(C.width)),
        ($.height = T.fontSize || 0),
        ($.ascent = $.height),
        ($.descent = 0))
      : (($.width = Math.floor(C.width)),
        ($.height = Math.floor(
          C.actualBoundingBoxAscent + C.actualBoundingBoxDescent
        )),
        ($.ascent = Math.floor(C.actualBoundingBoxAscent)),
        ($.descent = $.height - $.ascent)),
    $
  );
}
var __decorate$1b =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let ATextMeasure = class {
  configure(e, T) {
    (this.canvas = e.canvas),
      (this.context = e.context),
      e.bindTextMeasure(this);
  }
  measureTextWidth(e, T) {
    return this.context
      ? (this.context.setTextStyleWithoutAlignBaseline(T),
        this.context.measureText(e).width)
      : this.estimate(e, T).width;
  }
  estimate(e, { fontSize: T = DefaultTextAttribute.fontSize }) {
    let C = 0,
      $ = 0;
    for (let F = 0; F < e.length; F++) e.charCodeAt(F) < 128 ? C++ : $++;
    return {
      width: ~~(0.8 * C * T + $ * T),
      height: T,
    };
  }
  measureTextPixelHeight(e, T) {
    var C;
    if (!this.context)
      return null !== (C = T.fontSize) && void 0 !== C
        ? C
        : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(T);
    const $ = this.context.measureText(e);
    return Math.abs($.actualBoundingBoxAscent - $.actualBoundingBoxDescent);
  }
  measureTextBoundHieght(e, T) {
    var C;
    if (!this.context)
      return null !== (C = T.fontSize) && void 0 !== C
        ? C
        : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(T);
    const $ = this.context.measureText(e);
    return Math.abs($.fontBoundingBoxAscent - $.fontBoundingBoxDescent);
  }
  measureText(e, T) {
    return this.context
      ? (this.context.setTextStyleWithoutAlignBaseline(T),
        this.context.measureText(e))
      : this.estimate(e, T);
  }
  clipTextVertical(e, T, C, $) {
    if (0 === e.length)
      return {
        verticalList: e,
        width: 0,
      };
    const { fontSize: F = 12 } = T;
    e.forEach((e) => {
      e.width = 0 === e.direction ? F : this.measureTextWidth(e.text, T);
    });
    const V = [];
    let Y = 0,
      K = 0;
    for (; K < e.length && Y + e[K].width < C; K++)
      (Y += e[K].width), V.push(e[K]);
    if (e[K] && e[K].text.length > 1) {
      const F = this._clipText(
        e[K].text,
        T,
        C - Y,
        0,
        e[K].text.length - 1,
        "end",
        !1
      );
      if ($ && F.str !== e[K].text) {
        let C = "",
          $ = 0;
        for (let T = 0; T < K; T++) {
          const F = e[T];
          (C += F.text), ($ += F.text.length);
        }
        C += e[K].text;
        let V = testLetter(C, $ + F.str.length);
        (V -= $),
          V !== F.str.length - 1 &&
            ((F.str = F.str.substring(0, V)),
            (F.width = this.measureTextWidth(F.str, T)));
      }
      V.push(
        Object.assign(Object.assign({}, e[K]), {
          text: F.str,
          width: F.width,
        })
      ),
        (Y += F.width);
    }
    return {
      verticalList: V,
      width: Y,
    };
  }
  clipText(e, T, C, $) {
    if (0 === e.length)
      return {
        str: "",
        width: 0,
      };
    let F = this.measureTextWidth(e, T);
    if (F <= C)
      return {
        str: e,
        width: F,
      };
    if (((F = this.measureTextWidth(e[0], T)), F > C))
      return {
        str: "",
        width: 0,
      };
    const V = this._clipText(e, T, C, 0, e.length - 1, "end", !1);
    if ($ && V.str !== e) {
      const C = testLetter(e, V.str.length);
      C !== V.str.length &&
        ((V.str = e.substring(0, C)),
        (V.width = this.measureTextWidth(V.str, T)));
    }
    return V;
  }
  _clipText(e, T, C, $, F, V, Y) {
    let K;
    if ("start" === V)
      (K = this._clipTextStart(e, T, C, $, F)), Y && (K.result = Y + K.str);
    else if ("middle" === V) {
      const $ = this._clipTextMiddle(e, T, C, "", "", 0, 0, 1);
      K = {
        str: "none",
        width: $.width,
        result: $.left + Y + $.right,
      };
    } else (K = this._clipTextEnd(e, T, C, $, F)), Y && (K.result = K.str + Y);
    return K;
  }
  _clipTextEnd(e, T, C, $, F) {
    const V = Math.floor(($ + F) / 2),
      Y = e.substring(0, V + 1),
      K = this.measureTextWidth(Y, T);
    let J;
    if (K > C) {
      if (Y.length <= 1)
        return {
          str: "",
          width: 0,
        };
      const F = e.substring(0, V);
      return (
        (J = this.measureTextWidth(F, T)),
        J <= C
          ? {
              str: F,
              width: J,
            }
          : this._clipTextEnd(e, T, C, $, V)
      );
    }
    if (K < C) {
      if (V >= e.length - 1)
        return {
          str: e,
          width: this.measureTextWidth(e, T),
        };
      const $ = e.substring(0, V + 2);
      return (
        (J = this.measureTextWidth($, T)),
        J >= C
          ? {
              str: Y,
              width: K,
            }
          : this._clipTextEnd(e, T, C, V, F)
      );
    }
    return {
      str: Y,
      width: K,
    };
  }
  _clipTextStart(e, T, C, $, F) {
    const V = Math.ceil(($ + F) / 2),
      Y = e.substring(V - 1, e.length - 1),
      K = this.measureTextWidth(Y, T);
    let J;
    if (K > C) {
      if (Y.length <= 1)
        return {
          str: "",
          width: 0,
        };
      const $ = e.substring(V, e.length - 1);
      return (
        (J = this.measureTextWidth($, T)),
        J <= C
          ? {
              str: $,
              width: J,
            }
          : this._clipTextStart(e, T, C, V, e.length - 1)
      );
    }
    if (K < C) {
      if (V <= 0)
        return {
          str: e,
          width: this.measureTextWidth(e, T),
        };
      const F = e.substring(V - 2, e.length - 1);
      return (
        (J = this.measureTextWidth(F, T)),
        J >= C
          ? {
              str: Y,
              width: K,
            }
          : this._clipTextStart(e, T, C, $, V)
      );
    }
    return {
      str: Y,
      width: K,
    };
  }
  _clipTextMiddle(e, T, C, $, F, V, Y, K) {
    const J = e.substring(0, K),
      ee = this.measureTextWidth(J, T);
    if (ee + Y > C)
      return {
        left: $,
        right: F,
        width: V + Y,
      };
    const te = e.substring(e.length - K, e.length),
      ie = this.measureTextWidth(te, T);
    return ee + ie > C
      ? {
          left: J,
          right: F,
          width: ee + Y,
        }
      : this._clipTextMiddle(e, T, C, J, te, ee, ie, K + 1);
  }
  clipTextWithSuffixVertical(e, T, C, $, F, V) {
    if ("" === $) return this.clipTextVertical(e, T, C, F);
    if (0 === e.length)
      return {
        verticalList: e,
        width: 0,
      };
    const Y = this.clipTextVertical(e, T, C, F);
    if (
      Y.verticalList.length === e.length &&
      Y.verticalList[Y.verticalList.length - 1].width === e[e.length - 1].width
    )
      return Y;
    const K = this.measureTextWidth($, T);
    if (K > C) return Y;
    let J;
    if (((C -= K), "start" === V)) {
      const V = this.revertVerticalList(e);
      J = this.clipTextVertical(V, T, C, F);
      const Y = this.revertVerticalList(J.verticalList);
      Y.unshift({
        text: $,
        direction: 1,
        width: K,
      }),
        (J.verticalList = Y);
    } else if ("middle" === V) {
      const V = this.clipTextVertical(e, T, C / 2, F),
        Y = this.revertVerticalList(e),
        ee = this.clipTextVertical(Y, T, C / 2, F);
      V.verticalList.push({
        text: $,
        direction: 1,
        width: K,
      }),
        this.revertVerticalList(ee.verticalList).forEach((e) =>
          V.verticalList.push(e)
        ),
        (J = {
          verticalList: V.verticalList,
          width: V.width + ee.width,
        });
    } else
      (J = this.clipTextVertical(e, T, C, F)),
        J.verticalList.push({
          text: $,
          direction: 1,
          width: K,
        });
    return (J.width += K), J;
  }
  revertVerticalList(e) {
    return e.reverse().map((e) => {
      const T = e.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, e), {
        text: T,
      });
    });
  }
  clipTextWithSuffix(e, T, C, $, F, V, Y = !1) {
    if ("" === $) return this.clipText(e, T, C, F);
    if (0 === e.length)
      return {
        str: "",
        width: 0,
      };
    const K = this.measureTextWidth(e, T);
    if (!Y && K <= C)
      return {
        str: e,
        width: K,
      };
    const J = this.measureTextWidth($, T);
    if (J > C)
      return {
        str: "",
        width: 0,
      };
    if (Y && K + J <= C)
      return {
        str: e + $,
        width: K + J,
      };
    C -= J;
    const ee = this._clipText(e, T, C, 0, e.length - 1, V, $);
    if (F && ee.str !== e) {
      const C = testLetter(e, ee.str.length);
      C !== ee.str.length &&
        ((ee.result = e.substring(0, C)),
        (ee.width = this.measureTextWidth(ee.str, T)));
    } else Y && ee.str === e && (ee.result = e + $);
    return (ee.str = ee.result), (ee.width += J), ee;
  }
};
ATextMeasure = __decorate$1b([injectable()], ATextMeasure);
var __decorate$1a =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
const TextMeasureContribution = Symbol.for("TextMeasureContribution");
let DefaultTextMeasureContribution = class extends ATextMeasure {};
DefaultTextMeasureContribution = __decorate$1a(
  [injectable()],
  DefaultTextMeasureContribution
);
const container = new Container(),
  CanvasFactory = Symbol.for("CanvasFactory"),
  Context2dFactory = Symbol.for("Context2dFactory");
function wrapCanvas(e) {
  return container.getNamed(CanvasFactory, application.global.env)(e);
}
class DefaultCanvasAllocate {
  constructor() {
    (this.pools = []), (this.allocatedCanvas = []);
  }
  shareCanvas() {
    return this.allocatedCanvas.length
      ? this.allocatedCanvas[0]
      : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return (
      this._commonCanvas ||
        (this._commonCanvas = this.allocate({
          width: 100,
          height: 100,
          dpr: 2,
        })),
      this._commonCanvas
    );
  }
  allocate(e) {
    if (!this.pools.length) {
      const T = wrapCanvas(
        Object.assign(
          {
            nativeCanvas: application.global.createCanvas(e),
          },
          e
        )
      );
      return this.allocatedCanvas.push(T), T;
    }
    const T = this.pools.pop();
    return T.resize(e.width, e.height), (T.dpr = e.dpr), T;
  }
  allocateByObj(e) {
    if (!this.pools.length) {
      const T = {
          width: e.width / e.dpr,
          height: e.height / e.dpr,
          dpr: e.dpr,
        },
        C = wrapCanvas(
          Object.assign(
            {
              nativeCanvas: application.global.createCanvas(T),
            },
            T
          )
        );
      return this.allocatedCanvas.push(C), C;
    }
    const T = this.pools.pop();
    return (T.width = e.width), (T.height = e.height), T;
  }
  free(e) {
    this.pools.push(e);
  }
  get length() {
    return this.pools.length;
  }
  release(...e) {
    this.pools = [];
  }
}
const canvasAllocate = new DefaultCanvasAllocate();
var __decorate$19 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$V =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
const VWindow = Symbol.for("VWindow"),
  WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
let DefaultWindow = class {
  get width() {
    if (this._handler) {
      const e = this._handler.getWH();
      return (this._width = e.width);
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const e = this._handler.getWH();
      return (this._height = e.height);
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    (this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"]),
    }),
      (this.active = () => {
        const e = this.global;
        e.env &&
          !this.actived &&
          (container
            .getNamed(WindowHandlerContribution, e.env)
            .configure(this, e),
          (this.actived = !0));
      }),
      (this._uid = Generator.GenAutoIncrementId()),
      (this.global = application.global),
      this.postInit();
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var e;
    return null !== (e = this._handler.getStyle()) && void 0 !== e ? e : {};
  }
  set style(e) {
    this._handler.setStyle(e);
  }
  create(e) {
    var T, C;
    this._handler.createWindow(e);
    const $ = this._handler.getWH();
    (this._width = $.width),
      (this._height = $.height),
      e.viewBox
        ? this.setViewBox(e.viewBox)
        : !1 !== e.canvasControled
        ? this.setViewBox({
            x1: 0,
            y1: 0,
            x2: this._width,
            y2: this._height,
          })
        : this.setViewBox({
            x1: 0,
            y1: 0,
            x2: null !== (T = e.width) && void 0 !== T ? T : this._width,
            y2: null !== (C = e.height) && void 0 !== C ? C : this._height,
          }),
      (this.title = this._handler.getTitle()),
      (this.resizable = !0);
  }
  setWindowHandler(e) {
    this._handler = e;
  }
  setDpr(e) {
    return this._handler.setDpr(e);
  }
  resize(e, T) {
    return this._handler.resizeWindow(e, T);
  }
  configure() {
    throw new Error("");
  }
  release() {
    return (
      this.global.hooks.onSetEnv.unTap("window", this.active),
      this._handler.releaseWindow()
    );
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(e) {
    return this._handler.getImageBuffer
      ? this._handler.getImageBuffer(e)
      : null;
  }
  addEventListener(e, T, C) {
    return this._handler.addEventListener(e, T, C);
  }
  removeEventListener(e, T, C) {
    return this._handler.removeEventListener(e, T, C);
  }
  dispatchEvent(e) {
    return this._handler.dispatchEvent(e);
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(e) {
    this._handler.clearViewBox(e);
  }
  setViewBox(e) {
    this._handler.setViewBox(e);
  }
  setViewBoxTransform(e, T, C, $, F, V) {
    this._handler.setViewBoxTransform(e, T, C, $, F, V);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(e, T) {
    const C = this._handler.getViewBox(),
      $ = {
        x: e,
        y: T,
      };
    return (
      this._handler.getViewBoxTransform().transformPoint(
        {
          x: e,
          y: T,
        },
        $
      ),
      ($.x -= C.x1),
      ($.y -= C.y1),
      $
    );
  }
  hasSubView() {
    const e = this._handler.getViewBox();
    return !(
      0 === e.x1 &&
      0 === e.y1 &&
      this.width === e.width() &&
      this.height === e.height()
    );
  }
  isVisible(e) {
    return this._handler.isVisible(e);
  }
  onVisibleChange(e) {
    return this._handler.onVisibleChange(e);
  }
  getTopLeft(e) {
    return this._handler.getTopLeft(e);
  }
};
DefaultWindow = __decorate$19(
  [injectable(), __metadata$V("design:paramtypes", [])],
  DefaultWindow
);
var __decorate$18 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$U =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$G =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(e) {
    (this.contributions = e),
      (this.configured = !1),
      (this.global = application.global),
      this.global.hooks.onSetEnv.tap("graphic-util", (e, T, C) => {
        (this.configured = !1), this.configure(C, T);
      });
  }
  get textMeasure() {
    return (
      this._textMeasure || this.configure(this.global, this.global.env),
      this._textMeasure
    );
  }
  configure(e, T) {
    this.configured ||
      (this.contributions.getContributions().forEach((e) => {
        e.configure(this, T);
      }),
      (this.configured = !0));
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const e = canvasAllocate.shareCanvas();
      (this._canvas = e), (this._context = e.getContext("2d"));
    }
  }
  bindTextMeasure(e) {
    this._textMeasure = e;
  }
  measureText(e, T, C = "native") {
    var $;
    this.configure(this.global, this.global.env);
    const F = this.global.measureTextMethod;
    this.global.measureTextMethod = C;
    const V = {
      width: this._textMeasure.measureTextWidth(e, T),
      height:
        null !== ($ = T.fontSize) && void 0 !== $
          ? $
          : DefaultTextStyle.fontSize,
    };
    return (this.global.measureTextMethod = F), V;
  }
  createTextMeasureInstance(e, T, C) {
    return (
      this.configure(this.global, this.global.env),
      new TextMeasure(
        Object.assign(
          {
            defaultFontParams: {
              fontFamily: DefaultTextStyle.fontFamily,
              fontSize: DefaultTextStyle.fontSize,
            },
            getCanvasForMeasure: C || (() => this.canvas),
            getTextBounds: void 0,
            specialCharSet:
              "-/: .,@%'\"~" +
              TextMeasure.ALPHABET_CHAR_SET +
              TextMeasure.ALPHABET_CHAR_SET.toUpperCase(),
          },
          null != T ? T : {}
        ),
        e
      )
    );
  }
  drawGraphicToCanvas(e, T, C) {
    if (!T.defaultLayer) return null;
    const $ = container.get(VWindow),
      F = e.AABBBounds,
      V = F.width(),
      Y = F.height(),
      K = -F.x1,
      J = -F.y1;
    $.create({
      viewBox: {
        x1: K,
        y1: J,
        x2: F.x2,
        y2: F.y2,
      },
      width: V,
      height: Y,
      canvas: C,
      dpr: T.window.dpr,
      canvasControled: !0,
      offscreen: !0,
      title: "",
    });
    const ee = T.params.optimize.disableCheckGraphicWidthOutRange;
    (T.params.optimize.disableCheckGraphicWidthOutRange = !0),
      T.defaultLayer.getNativeHandler().drawTo($, [e], {
        transMatrix: $.getViewBoxTransform(),
        viewBox: $.getViewBox(),
        stage: T,
        layer: T.defaultLayer,
        renderService: T.renderService,
        background: "transparent",
        clear: !0,
        updateBounds: !1,
      }),
      (T.params.optimize.disableCheckGraphicWidthOutRange = ee);
    const te = $.getNativeHandler();
    return te.nativeCanvas ? te.nativeCanvas : null;
  }
};
var TransformMode, TransformMode2;
(DefaultGraphicUtil = __decorate$18(
  [
    injectable(),
    __param$G(0, inject(ContributionProvider)),
    __param$G(0, named(TextMeasureContribution)),
    __metadata$U("design:paramtypes", [Object]),
  ],
  DefaultGraphicUtil
)),
  (TransformMode2 = TransformMode || (TransformMode = {})),
  (TransformMode2[(TransformMode2.transform = 0)] = "transform"),
  (TransformMode2[(TransformMode2.matrix = 1)] = "matrix");
const _matrix = new Matrix();
let DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(e) {
    return (
      (this.mode = TransformMode.transform),
      (this.originTransform = e),
      this.matrix.reset(),
      this
    );
  }
  fromMatrix(e, T) {
    return (
      (this.mode = TransformMode.matrix),
      (this.outSourceMatrix = e),
      (this.outTargetMatrix = T),
      this
    );
  }
  scaleMatrix(e, T, C) {
    const $ = this.outSourceMatrix;
    if (
      (_matrix.setValue($.a, $.b, $.c, $.d, $.e, $.f),
      this.outTargetMatrix.reset(),
      C)
    ) {
      const { x: $, y: F } = C;
      this.outTargetMatrix.translate($, F),
        this.outTargetMatrix.scale(e, T),
        this.outTargetMatrix.translate(-$, -F);
    } else this.outTargetMatrix.scale(e, T);
    return (
      this.outTargetMatrix.multiply(
        _matrix.a,
        _matrix.b,
        _matrix.c,
        _matrix.d,
        _matrix.e,
        _matrix.f
      ),
      this
    );
  }
  rotateMatrix(e, T) {
    const C = this.outSourceMatrix;
    if (
      (_matrix.setValue(C.a, C.b, C.c, C.d, C.e, C.f),
      this.outTargetMatrix.reset(),
      T)
    ) {
      const { x: C, y: $ } = T;
      this.outTargetMatrix.translate(C, $),
        this.outTargetMatrix.rotate(e),
        this.outTargetMatrix.translate(-C, -$);
    } else this.outTargetMatrix.rotate(e);
    return (
      this.outTargetMatrix.multiply(
        _matrix.a,
        _matrix.b,
        _matrix.c,
        _matrix.d,
        _matrix.e,
        _matrix.f
      ),
      this
    );
  }
  scale(e, T, C) {
    return this.mode === TransformMode.matrix
      ? this.scaleMatrix(e, T, C)
      : this;
  }
  rotate(e, T) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(e, T) : this;
  }
  translateMatrix(e, T) {
    const C = this.outSourceMatrix;
    return (
      _matrix.setValue(C.a, C.b, C.c, C.d, C.e, C.f),
      this.outTargetMatrix.reset(),
      this.outTargetMatrix.translate(e, T),
      this.outTargetMatrix.multiply(
        _matrix.a,
        _matrix.b,
        _matrix.c,
        _matrix.d,
        _matrix.e,
        _matrix.f
      ),
      this
    );
  }
  translate(e, T) {
    return this.mode === TransformMode.matrix
      ? this.translateMatrix(e, T)
      : this;
  }
  simplify(e) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(e) : this;
  }
  simplifyMatrix(e) {
    return this;
  }
};
DefaultTransformUtil = __decorate$18(
  [injectable(), __metadata$U("design:paramtypes", [])],
  DefaultTransformUtil
);
const defaultThemeObj = {
    arc: DefaultArcAttribute,
    area: DefaultAreaAttribute,
    circle: DefaultCircleAttribute,
    line: DefaultLineAttribute,
    path: DefaultPathAttribute,
    symbol: DefaultSymbolAttribute,
    text: DefaultTextAttribute,
    rect: DefaultRectAttribute,
    polygon: DefaultPolygonAttribute,
    richtext: DefaultRichTextAttribute,
    richtextIcon: DefaultRichTextIconAttribute,
    image: DefaultImageAttribute,
    group: DefaultGroupAttribute,
    glyph: DefaultGlyphAttribute,
  },
  themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph),
  };
}
function combine(e, T) {
  Object.keys(T).forEach((C) => {
    e[C] = T[C];
  });
}
const globalThemeObj = newThemeObj();
class Theme {
  constructor() {
    this.initTheme(), (this.dirty = !1);
  }
  initTheme() {
    (this._defaultTheme = {}),
      themeKeys.forEach((e) => {
        this._defaultTheme[e] = Object.create(globalThemeObj[e]);
      }),
      (this.combinedTheme = this._defaultTheme);
  }
  getTheme(e) {
    if (!e) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let T = {};
    const C = this.getParentWithTheme(e);
    return C && (T = C.theme), this.applyTheme(e, T), this.combinedTheme;
  }
  getParentWithTheme(e) {
    for (; e.parent; ) if ((e = e.parent).theme) return e;
    return null;
  }
  applyTheme(e, T, C = !1) {
    if (this.dirty) {
      const $ = this.getParentWithTheme(e);
      if ($) {
        const e = $.theme;
        (e.dirty || C) && e.applyTheme($, T, !0);
      }
      this.userTheme
        ? this.doCombine($ && $.theme.combinedTheme)
        : ($
            ? (this.combinedTheme = $.theme.combinedTheme)
            : ((this.combinedTheme = this._defaultTheme),
              Logger.getInstance().warn("")),
          (this.dirty = !1));
    }
    return this.combinedTheme;
  }
  doCombine(e) {
    const T = this.userTheme,
      C = this.combinedTheme;
    themeKeys.forEach(($) => {
      const F = Object.create(globalThemeObj[$]);
      e && e[$] && combine(F, e[$]),
        C[$] && combine(F, C[$]),
        T[$] && combine(F, T[$]),
        (this.combinedTheme[$] = F);
    }),
      T.common &&
        themeKeys.forEach((e) => {
          combine(this.combinedTheme[e], T.common);
        }),
      (this.dirty = !1);
  }
  setTheme(e, T) {
    let C = this.userTheme;
    C
      ? Object.keys(e).forEach((T) => {
          C[T] ? Object.assign(C[T], e[T]) : (C[T] = Object.assign({}, e[T]));
        })
      : (C = e),
      (this.userTheme = C),
      (this.dirty = !0),
      this.dirtyChildren(T);
  }
  resetTheme(e, T) {
    (this.userTheme = e), (this.dirty = !0), this.dirtyChildren(T);
  }
  dirtyChildren(e) {
    e.forEachChildren((e) => {
      e.isContainer && (e.theme && (e.theme.dirty = !0), this.dirtyChildren(e));
    });
  }
}
const globalTheme = new Theme();
function getTheme(e, T) {
  return e.glyphHost
    ? getTheme(e.glyphHost)
    : T
    ? (e.isContainer, T)
    : getThemeFromGroup(e) ||
      (e.attachedThemeGraphic && getTheme(e.attachedThemeGraphic)) ||
      globalTheme.getTheme();
}
function getThemeFromGroup(e) {
  let T;
  if (((T = e.isContainer ? e : e.parent), T)) {
    for (; T && !T.theme; ) T = T.parent;
    return T
      ? (T.theme || T.createTheme(), T.theme.getTheme(T))
      : globalTheme.getTheme();
  }
  return null;
}
var __awaiter$2 =
  (globalThis && globalThis.__awaiter) ||
  function (e, T, C, $) {
    return new (C || (C = Promise))(function (F, V) {
      function Y(e) {
        try {
          J($.next(e));
        } catch (T) {
          V(T);
        }
      }
      function K(e) {
        try {
          J($.throw(e));
        } catch (T) {
          V(T);
        }
      }
      function J(e) {
        var T;
        e.done
          ? F(e.value)
          : ((T = e.value),
            T instanceof C
              ? T
              : new C(function (e) {
                  e(T);
                })).then(Y, K);
      }
      J(($ = $.apply(e, T || [])).next());
    });
  };
class Node extends EventEmitter {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(),
      (this._uid = Generator.GenAutoIncrementId()),
      (this._firstChild = null),
      (this._lastChild = null),
      (this.parent = null),
      (this._count = 1);
  }
  forEachChildren(e, T = !1) {
    if (T) {
      let T = this._lastChild,
        C = 0;
      for (; T; ) {
        if (e(T, C++)) return;
        T = T._prev;
      }
    } else {
      let T = this._firstChild,
        C = 0;
      for (; T; ) {
        if (e(T, C++)) return;
        T = T._next;
      }
    }
  }
  forEachChildrenAsync(e, T = !1) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (T) {
        let T = this._lastChild,
          C = 0;
        for (; T; ) {
          let $ = e(T, C++);
          if (($.then && ($ = yield $), $)) return;
          T = T._prev;
        }
      } else {
        let T = this._firstChild,
          C = 0;
        for (; T; ) {
          let $ = e(T, C++);
          if (($.then && ($ = yield $), $)) return;
          T = T._next;
        }
      }
    });
  }
  forEach(e) {
    return this.forEachChildren(e);
  }
  appendChild(e, T = !0) {
    if (this._uid === e._uid) return null;
    if (!T && e.isAncestorsOf(this))
      throw new Error("Node::appendChildappend");
    return (
      e.parent && e.parent.removeChild(e),
      (e.parent = this),
      this._lastChild
        ? ((this._lastChild._next = e),
          (e._prev = this._lastChild),
          (this._lastChild = e))
        : ((this._firstChild = this._lastChild = e),
          (e._prev = e._next = null)),
      this._idMap || (this._idMap = new Map()),
      this._idMap.set(e._uid, e),
      this.setCount(e.count),
      (this._structEdit = !0),
      e
    );
  }
  appendChildArrHighPerformance(e, T = !1) {
    return console.error(""), e;
  }
  insertBefore(e, T) {
    if (!T) return this.appendChild(e);
    if (this._uid === e._uid) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertBeforeinsert");
    return T.parent !== this
      ? null
      : (e.parent && e.parent.removeChild(e),
        (e.parent = this),
        (e._prev = T._prev),
        T._prev ? (T._prev._next = e) : (this._firstChild = e),
        (T._prev = e),
        (e._next = T),
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(e._uid, e),
        (this._structEdit = !0),
        this.setCount(e.count),
        e);
  }
  insertAfter(e, T) {
    if (!T) return this.appendChild(e);
    if (this._uid === e._uid) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertAfterinsert");
    return T.parent !== this
      ? null
      : (e.parent && e.parent.removeChild(e),
        (e.parent = this),
        T._next
          ? ((T._next._prev = e), (e._next = T._next))
          : (this._lastChild = e),
        (T._next = e),
        (e._prev = T),
        this._idMap || (this._idMap = new Map()),
        this._idMap.set(e._uid, e),
        (this._structEdit = !0),
        this.setCount(e.count),
        e);
  }
  insertInto(e, T) {
    if (
      (!this._ignoreWarn &&
        this._nodeList &&
        Logger.getInstance().warn(
          "insertIntoKeepIdxinsertInto"
        ),
      T >= this.childrenCount)
    )
      return this.appendChild(e);
    if (this._uid === e._uid) return null;
    if (e.isAncestorsOf(this))
      throw new Error("Node::insertBeforeinsert");
    if ((e.parent && e.parent.removeChild(e), (e.parent = this), 0 === T))
      (e._next = this._firstChild),
        this._firstChild && (this._firstChild._prev = e),
        (e._prev = null),
        (this._firstChild = e);
    else {
      let C = this._firstChild;
      for (let e = 0; e < T; e++) {
        if (!C) return null;
        e > 0 && (C = C._next);
      }
      if (!C) return null;
      (e._next = C._next),
        (e._prev = C),
        (C._next = e),
        e._next && (e._next._prev = e);
    }
    return (
      this._idMap || (this._idMap = new Map()),
      this._idMap.set(e._uid, e),
      (this._structEdit = !0),
      this.setCount(e.count),
      e
    );
  }
  insertIntoKeepIdx(e, T) {
    if (
      (this._nodeList || (this._nodeList = this.children), this._nodeList[T])
    ) {
      const C = this._nodeList[T];
      return this._nodeList.splice(T, 0, e), this.insertBefore(e, C);
    }
    let C;
    this._nodeList[T] = e;
    for (let F = T - 1; F >= 0 && ((C = this._nodeList[F]), !C); F--);
    if (C) return C._next ? this.insertBefore(e, C._next) : this.appendChild(e);
    this._ignoreWarn = !0;
    const $ = this.insertInto(e, 0);
    return (this._ignoreWarn = !1), $;
  }
  removeChild(e) {
    if (!this._idMap) return null;
    if (!this._idMap.has(e._uid)) return null;
    if ((this._idMap.delete(e._uid), this._nodeList)) {
      const T = this._nodeList.findIndex((T) => T === e);
      T >= 0 && this._nodeList.splice(T, 1);
    }
    return (
      e._prev ? (e._prev._next = e._next) : (this._firstChild = e._next),
      e._next ? (e._next._prev = e._prev) : (this._lastChild = e._prev),
      (e.parent = null),
      (e._prev = null),
      (e._next = null),
      (this._structEdit = !0),
      this.setCount(-e.count),
      e
    );
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(e) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let T = this._firstChild;
    for (; T; ) {
      const e = T._next;
      (T.parent = null),
        (T._prev = null),
        (T._next = null),
        (T = T._next),
        (T = e);
    }
    (this._firstChild = null),
      (this._lastChild = null),
      this._idMap.clear(),
      (this._structEdit = !0),
      this.setCount(1 - this._count);
  }
  replaceChild(e, T) {
    throw new Error("");
  }
  find(e, T = !1) {
    let C = null;
    return (
      this.forEachChildren((T, $) => !(T === this || !e(T, $) || ((C = T), 0))),
      T &&
        this.forEachChildren((T) => {
          if (T.isContainer) {
            const $ = T.find(e, !0);
            if ($) return (C = $), !0;
          }
          return !1;
        }),
      C
    );
  }
  findAll(e, T = !1) {
    let C = [];
    return (
      this.forEachChildren((T, $) => {
        T !== this && e(T, $) && C.push(T);
      }),
      T &&
        this.forEachChildren((T) => {
          if (T.isContainer) {
            const $ = T.findAll(e, !0);
            $.length && (C = C.concat($));
          }
        }),
      C
    );
  }
  getElementById(e) {
    return this.find((T) => T.id === e, !0);
  }
  findChildById(e) {
    return this.getElementById(e);
  }
  findChildByUid(e) {
    return (this._idMap && this._idMap.get(e)) || null;
  }
  getElementsByName(e) {
    return this.findAll((T) => T.name === e, !0);
  }
  findChildrenByName(e) {
    return this.getElementsByName(e);
  }
  getElementsByType(e) {
    return this.findAll((T) => T.type === e, !0);
  }
  getChildByName(e, T = !1) {
    return this.find((T) => T.name === e, T);
  }
  getChildAt(e) {
    let T = this._firstChild;
    if (!T) return null;
    for (let C = 0; C < e; C++) {
      if (!T._next) return null;
      T = T._next;
    }
    return T;
  }
  at(e) {
    return this.getChildAt(e);
  }
  containNode(e) {
    if (!this._idMap) return !1;
    if (this._idMap.has(e._uid)) return !0;
    let T = this._firstChild;
    for (; T; ) {
      if (T.containNode(e)) return !0;
      T = T._next;
    }
    return !1;
  }
  getRootNode() {
    let e = this.parent;
    for (; null == e ? void 0 : e.parent; ) e = e.parent;
    return e || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(e) {
    return this.appendChild(e);
  }
  add(e) {
    return this.appendChild(e);
  }
  getChildren() {
    const e = [];
    let T = this._firstChild;
    for (; T; ) e.push(T), (T = T._next);
    return e;
  }
  isChildOf(e) {
    return !!this.parent && this.parent._uid === e._uid;
  }
  isParentOf(e) {
    return e.isChildOf(this);
  }
  isDescendantsOf(e) {
    let T = this.parent;
    if (!T) return !1;
    do {
      if (T._uid === e._uid) return !0;
      T = T.parent;
    } while (null !== T);
    return !1;
  }
  isAncestorsOf(e) {
    return e.isDescendantsOf(this);
  }
  getAncestor(e) {
    throw new Error("");
  }
  setAllDescendantsProps(e, T) {
    let C = this._firstChild;
    for (; C; ) (C[e] = T), C.setAllDescendantsProps(e, T), (C = C._next);
  }
  setCount(e) {
    this._count += e;
    let T = this.parent;
    if (T)
      do {
        (T._count += e), (T = T.parent);
      } while (null !== T);
  }
  clone() {
    throw new Error("");
  }
  cloneTo(e) {
    throw new Error("");
  }
  getParent() {
    return this.parent;
  }
  del(e) {
    return this.removeChild(e);
  }
  addEventListener(e, T, C) {
    const $ = (isBoolean$1(C, !0) && C) || (isObject$1(C) && C.capture),
      F = isObject$1(C) && C.once,
      V = isFunction$1(T) ? void 0 : T;
    return (
      (e = $ ? `${e}capture` : e),
      (T = isFunction$1(T) ? T : T.handleEvent),
      F ? super.once(e, T, V) : super.on(e, T, V),
      this
    );
  }
  on(e, T, C) {
    return this.addEventListener(e, T, C);
  }
  removeEventListener(e, T, C) {
    const $ = (isBoolean$1(C, !0) && C) || (isObject$1(C) && C.capture),
      F = isFunction$1(T) ? void 0 : T;
    (e = $ ? `${e}capture` : e), (T = isFunction$1(T) ? T : T.handleEvent);
    const V = isObject$1(C) && C.once;
    return super.off(e, T, F, V), this;
  }
  off(e, T, C) {
    return this.removeEventListener(e, T, C);
  }
  once(e, T, C) {
    return isObject$1(C)
      ? ((C.once = !0), this.addEventListener(e, T, C))
      : this.addEventListener(e, T, {
          once: !0,
        });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(e, ...T) {
    return super.emit(e.type, e, ...T), !e.defaultPrevented;
  }
  emit(e, T) {
    return this.dispatchEvent(e, T);
  }
  release() {
    this.removeAllListeners();
  }
}
class FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(e) {
    (this.bubbles = !0),
      (this.cancelBubble = !0),
      (this.cancelable = !1),
      (this.composed = !1),
      (this.defaultPrevented = !1),
      (this.eventPhase = FederatedEvent.prototype.NONE),
      (this.propagationStopped = !1),
      (this.propagationImmediatelyStopped = !1),
      (this.layer = {
        x: 0,
        y: 0,
      }),
      (this.page = {
        x: 0,
        y: 0,
      }),
      (this.canvas = {
        x: 0,
        y: 0,
      }),
      (this.viewport = {
        x: 0,
        y: 0,
      }),
      (this.NONE = 0),
      (this.CAPTURING_PHASE = 1),
      (this.AT_TARGET = 2),
      (this.BUBBLING_PHASE = 3),
      (this.manager = e);
  }
  composedPath() {
    return (
      !this.manager ||
        (this.path && this.path[this.path.length - 1] === this.target) ||
        (this.path = this.target
          ? this.manager.propagationPath(this.target)
          : []),
      this.composedDetailPath(),
      this.path
    );
  }
  composedDetailPath() {
    return (
      this.pickParams && this.pickParams.graphic
        ? ((this.detailPath = this.path.slice()),
          this._composedDetailPath(this.pickParams))
        : (this.detailPath = this.path.slice()),
      this.detailPath
    );
  }
  _composedDetailPath(e) {
    if (e && e.graphic) {
      const T = this.pickParams.graphic;
      if (T.stage) {
        const C = T.stage.eventSystem.manager.propagationPath(T);
        this.detailPath.push(C), this._composedDetailPath(e.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.preventDefault();
    } catch (e) {
      this.nativeEvent.preventDefault &&
        isFunction$1(this.nativeEvent.preventDefault) &&
        this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = !0;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.stopPropagation();
    } catch (e) {
      this.nativeEvent.stopPropagation &&
        isFunction$1(this.nativeEvent.stopPropagation) &&
        this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = !0;
  }
  initEvent() {}
  initUIEvent() {}
  clone() {
    throw new Error("Method not implemented.");
  }
}
class CustomEvent extends FederatedEvent {
  constructor(e, T) {
    super(), (this.type = e), (this.detail = T);
  }
}
const EventTarget = {
  dispatchEvent(e) {
    var T;
    if (!(e instanceof FederatedEvent))
      throw new Error(
        "DisplayObject cannot propagate events outside of the Federated Events API"
      );
    return (
      (e.defaultPrevented = !1),
      (e.path = []),
      e.detailPath && (e.detailPath = []),
      (e.target = this),
      null === (T = null == e ? void 0 : e.manager) ||
        void 0 === T ||
        T.dispatchEvent(e),
      !e.defaultPrevented
    );
  },
  emit(e, T) {
    return this.dispatchEvent(new CustomEvent(e, T));
  },
};
class Easing {
  constructor() {}
  static linear(e) {
    return e;
  }
  static none() {
    return this.linear;
  }
  static get(e) {
    return (
      e < -1 ? (e = -1) : e > 1 && (e = 1),
      function (T) {
        return 0 === e
          ? T
          : e < 0
          ? T * (T * -e + 1 + e)
          : T * ((2 - T) * e + (1 - e));
      }
    );
  }
  static getPowIn(e) {
    return function (T) {
      return Math.pow(T, e);
    };
  }
  static getPowOut(e) {
    return function (T) {
      return 1 - Math.pow(1 - T, e);
    };
  }
  static getPowInOut(e) {
    return function (T) {
      return (T *= 2) < 1
        ? 0.5 * Math.pow(T, e)
        : 1 - 0.5 * Math.abs(Math.pow(2 - T, e));
    };
  }
  static getBackIn(e) {
    return function (T) {
      return T * T * ((e + 1) * T - e);
    };
  }
  static getBackOut(e) {
    return function (T) {
      return --T * T * ((e + 1) * T + e) + 1;
    };
  }
  static getBackInOut(e) {
    return (
      (e *= 1.525),
      function (T) {
        return (T *= 2) < 1
          ? T * T * ((e + 1) * T - e) * 0.5
          : 0.5 * ((T -= 2) * T * ((e + 1) * T + e) + 2);
      }
    );
  }
  static sineIn(e) {
    return 1 - Math.cos((e * Math.PI) / 2);
  }
  static sineOut(e) {
    return Math.sin((e * Math.PI) / 2);
  }
  static sineInOut(e) {
    return -(Math.cos(Math.PI * e) - 1) / 2;
  }
  static expoIn(e) {
    return 0 === e ? 0 : Math.pow(2, 10 * e - 10);
  }
  static expoOut(e) {
    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e);
  }
  static expoInOut(e) {
    return 0 === e
      ? 0
      : 1 === e
      ? 1
      : e < 0.5
      ? Math.pow(2, 20 * e - 10) / 2
      : (2 - Math.pow(2, -20 * e + 10)) / 2;
  }
  static circIn(e) {
    return -(Math.sqrt(1 - e * e) - 1);
  }
  static circOut(e) {
    return Math.sqrt(1 - --e * e);
  }
  static circInOut(e) {
    return (e *= 2) < 1
      ? -0.5 * (Math.sqrt(1 - e * e) - 1)
      : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  }
  static bounceOut(e) {
    return e < 1 / 2.75
      ? 7.5625 * e * e
      : e < 2 / 2.75
      ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
      : e < 2.5 / 2.75
      ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
      : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  }
  static bounceIn(e) {
    return 1 - Easing.bounceOut(1 - e);
  }
  static bounceInOut(e) {
    return e < 0.5
      ? 0.5 * Easing.bounceIn(2 * e)
      : 0.5 * Easing.bounceOut(2 * e - 1) + 0.5;
  }
  static getElasticIn(e, T) {
    return function (C) {
      if (0 === C || 1 === C) return C;
      const $ = (T / pi2) * Math.asin(1 / e);
      return -e * Math.pow(2, 10 * (C -= 1)) * Math.sin(((C - $) * pi2) / T);
    };
  }
  static getElasticOut(e, T) {
    return function (C) {
      if (0 === C || 1 === C) return C;
      const $ = (T / pi2) * Math.asin(1 / e);
      return e * Math.pow(2, -10 * C) * Math.sin(((C - $) * pi2) / T) + 1;
    };
  }
  static getElasticInOut(e, T) {
    return function (C) {
      const $ = (T / pi2) * Math.asin(1 / e);
      return (C *= 2) < 1
        ? e * Math.pow(2, 10 * (C -= 1)) * Math.sin(((C - $) * pi2) / T) * -0.5
        : e *
            Math.pow(2, -10 * (C -= 1)) *
            Math.sin(((C - $) * pi2) / T) *
            0.5 +
            1;
    };
  }
}
(Easing.quadIn = Easing.getPowIn(2)),
  (Easing.quadOut = Easing.getPowOut(2)),
  (Easing.quadInOut = Easing.getPowInOut(2)),
  (Easing.cubicIn = Easing.getPowIn(3)),
  (Easing.cubicOut = Easing.getPowOut(3)),
  (Easing.cubicInOut = Easing.getPowInOut(3)),
  (Easing.quartIn = Easing.getPowIn(4)),
  (Easing.quartOut = Easing.getPowOut(4)),
  (Easing.quartInOut = Easing.getPowInOut(4)),
  (Easing.quintIn = Easing.getPowIn(5)),
  (Easing.quintOut = Easing.getPowOut(5)),
  (Easing.quintInOut = Easing.getPowInOut(5)),
  (Easing.backIn = Easing.getBackIn(1.7)),
  (Easing.backOut = Easing.getBackOut(1.7)),
  (Easing.backInOut = Easing.getBackInOut(1.7)),
  (Easing.elasticIn = Easing.getElasticIn(1, 0.3)),
  (Easing.elasticOut = Easing.getElasticOut(1, 0.3)),
  (Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5));
class DefaultTimeline {
  constructor() {
    (this.id = Generator.GenAutoIncrementId()),
      (this.animateHead = null),
      (this.animateTail = null),
      (this.animateCount = 0),
      (this.paused = !1);
  }
  addAnimate(e) {
    this.animateTail
      ? ((this.animateTail.nextAnimate = e),
        (e.prevAnimate = this.animateTail),
        (this.animateTail = e),
        (e.nextAnimate = null))
      : ((this.animateHead = e), (this.animateTail = e)),
      this.animateCount++;
  }
  pause() {
    this.paused = !0;
  }
  resume() {
    this.paused = !1;
  }
  tick(e) {
    if (this.paused) return;
    let T = this.animateHead;
    for (this.animateCount = 0; T; )
      T.status === AnimateStatus.END
        ? this.removeAnimate(T)
        : T.status === AnimateStatus.RUNNING ||
          T.status === AnimateStatus.INITIAL
        ? (this.animateCount++, T.advance(e))
        : T.status === AnimateStatus.PAUSED && this.animateCount++,
        (T = T.nextAnimate);
  }
  clear() {
    let e = this.animateHead;
    for (; e; ) e.release(), (e = e.nextAnimate);
    (this.animateHead = null),
      (this.animateTail = null),
      (this.animateCount = 0);
  }
  removeAnimate(e, T = !0) {
    e._onRemove && e._onRemove.forEach((e) => e()),
      e === this.animateHead
        ? ((this.animateHead = e.nextAnimate),
          e === this.animateTail
            ? (this.animateTail = null)
            : (this.animateHead.prevAnimate = null))
        : e === this.animateTail
        ? ((this.animateTail = e.prevAnimate),
          (this.animateTail.nextAnimate = null))
        : ((e.prevAnimate.nextAnimate = e.nextAnimate),
          (e.nextAnimate.prevAnimate = e.prevAnimate)),
      T && e.release();
  }
}
const defaultTimeline = new DefaultTimeline();
class ACustomAnimate {
  constructor(e, T, C, $, F) {
    (this.from = e),
      (this.to = T),
      (this.duration = C),
      (this.easing = $),
      (this.params = F),
      (this.updateCount = 0);
  }
  bind(e, T) {
    (this.target = e), (this.subAnimate = T), this.onBind();
  }
  onBind() {}
  onFirstRun() {}
  onStart() {}
  onEnd() {}
  getEndProps() {
    return this.to;
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var e;
    const T = this.getEndProps();
    return T
      ? this._endProps === T
        ? this._mergedEndProps
        : ((this._endProps = T),
          void (this._mergedEndProps = Object.assign(
            {},
            null !== (e = this.step.prev.getLastProps()) && void 0 !== e
              ? e
              : {},
            T
          )))
      : this.step.prev
      ? this.step.prev.getLastProps()
      : T;
  }
  update(e, T, C) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const e = this.step.getLastProps();
      Object.keys(e).forEach((T) => {
        this.subAnimate.animate.validAttr(T) && (C[T] = e[T]);
      });
    }
    (this.updateCount += 1), this.onUpdate(e, T, C), e && this.onEnd();
  }
}
class CbAnimate extends ACustomAnimate {
  constructor(e) {
    super(null, null, 0, "linear"), (this.cb = e);
  }
  onUpdate(e, T, C) {}
  onStart() {
    this.cb();
  }
}
class Animate {
  constructor(e = Generator.GenAutoIncrementId(), T = defaultTimeline) {
    (this.id = e),
      (this.timeline = T),
      (this.status = AnimateStatus.INITIAL),
      (this.tailAnimate = new SubAnimate(this)),
      (this.subAnimates = [this.tailAnimate]),
      (this.timeScale = 1),
      (this.rawPosition = -1),
      (this._startTime = 0),
      (this._duringTime = 0),
      this.timeline.addAnimate(this);
  }
  setTimeline(e) {
    e !== this.timeline &&
      (this.timeline.removeAnimate(this, !1), e.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((e, T) => e + T.totalDuration, 0);
  }
  after(e) {
    const T = e.getDuration();
    return (this._startTime = T), this;
  }
  afterAll(e) {
    let T = -1 / 0;
    return (
      e.forEach((e) => {
        T = max(e.getDuration(), T);
      }),
      (this._startTime = T),
      this
    );
  }
  parallel(e) {
    return (this._startTime = e.getStartTime()), this;
  }
  static AddInterpolate(e, T) {
    Animate.interpolateMap.set(e, T);
  }
  play(e) {
    if ((this.tailAnimate.play(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return (
      1 === this.subAnimates.length &&
        this.tailAnimate.totalDuration === e.duration &&
        this.trySetAttribute(e.getFromProps(), e.mode),
      this
    );
  }
  trySetAttribute(e, T = Animate.mode) {
    e &&
      T & AnimateMode.SET_ATTR_IMMEDIATELY &&
      this.target.setAttributes &&
      this.target.setAttributes(e, !1, {
        type: AttributeUpdateType.ANIMATE_PLAY,
      });
  }
  runCb(e) {
    const T = new CbAnimate(() => {
      e(this, T.step.prev);
    });
    return this.tailAnimate.play(T), this;
  }
  customInterpolate(e, T, C, $, F, V) {
    const Y = Animate.interpolateMap.get(e) || Animate.interpolateMap.get("");
    return !!Y && Y(e, T, C, $, F, V);
  }
  pause() {
    this.status === AnimateStatus.RUNNING &&
      (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED &&
      (this.status = AnimateStatus.RUNNING);
  }
  to(e, T, C, $) {
    if ((this.tailAnimate.to(e, T, C, $), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  from(e, T, C, $) {
    if ((this.tailAnimate.from(e, T, C, $), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  wait(e) {
    if ((this.tailAnimate.wait(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  startAt(e) {
    if ((this.tailAnimate.startAt(e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  loop(e) {
    if (((this.tailAnimate.loop = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  reversed(e) {
    if (((this.tailAnimate.reversed = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  bounce(e) {
    if (((this.tailAnimate.bounce = e), this.target)) {
      const e = this.target.stage;
      e && e.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const e = new SubAnimate(this, this.tailAnimate);
    return (
      (this.tailAnimate = e),
      this.subAnimates.push(e),
      e.bind(this.target),
      this
    );
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(e) {
    this._preventAttrs && this._preventAttrs.delete(e);
  }
  preventAttr(e) {
    this._preventAttrs || (this._preventAttrs = new Set()),
      this._preventAttrs.add(e);
  }
  preventAttrs(e) {
    e.forEach((e) => this.preventAttr(e));
  }
  validAttr(e) {
    return !this._preventAttrs || !this._preventAttrs.has(e);
  }
  bind(e) {
    return (
      (this.target = e),
      this.target.onAnimateBind && this.target.onAnimateBind(this),
      this.subAnimates.forEach((T) => {
        T.bind(e);
      }),
      this
    );
  }
  advance(e) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + e * this.timeScale < this._startTime)
        return void (this._duringTime += e * this.timeScale);
      (e = this._duringTime + e * this.timeScale - this._startTime),
        (this._duringTime = this._startTime);
    }
    this.status === AnimateStatus.INITIAL &&
      ((this.status = AnimateStatus.RUNNING),
      this._onStart && this._onStart.forEach((e) => e())),
      this.setPosition(this.rawPosition + e * this.timeScale) &&
        this.status === AnimateStatus.RUNNING &&
        ((this.status = AnimateStatus.END),
        this._onEnd && this._onEnd.forEach((e) => e()));
  }
  setPosition(e) {
    let T,
      C = 0;
    const $ = this.rawPosition,
      F = this.subAnimates.reduce((e, T) => e + T.totalDuration, 0);
    e < 0 && (e = 0);
    const V = e >= F;
    if ((V && (e = F), e === $)) return V;
    for (
      let Y = 0;
      Y < this.subAnimates.length &&
      ((T = this.subAnimates[Y]), !(C + T.totalDuration >= e));
      Y++
    )
      (C += T.totalDuration), (T = void 0);
    return (this.rawPosition = e), T.setPosition(e - C), V;
  }
  onStart(e) {
    this._onStart || (this._onStart = []), this._onStart.push(e);
  }
  onEnd(e) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(e);
  }
  onRemove(e) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(e);
  }
  onFrame(e) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(e);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(e) {
    e || this.target.onStop(),
      "start" === e
        ? this.target.onStop(this.getStartProps())
        : "end" === e
        ? this.target.onStop(this.getEndProps())
        : this.target.onStop(e),
      this.release();
  }
}
(Animate.mode = AnimateMode.NORMAL), (Animate.interpolateMap = new Map());
class SubAnimate {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(e, T) {
    (this.rawPosition = -1),
      (this.position = 0),
      (this.loop = 0),
      (this.duration = 0),
      (this.animate = e),
      (this.stepHead = new Step(
        0,
        0,
        T ? Object.assign({}, T.stepTail.props) : {}
      )),
      (this.stepTail = this.stepHead),
      (this.dirty = !0),
      (this._startAt = 0);
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(e) {
    return (this.target = e), this;
  }
  play(e) {
    let T = e.duration;
    (null == T || T < 0) && (T = 0);
    const C = e.easing,
      $ = "string" == typeof C ? Easing[C] : C,
      F = this._addStep(T, null, $);
    return (
      (F.type = AnimateStepType.customAnimate),
      this._appendProps(e.getEndProps(), F, !1),
      this._appendCustomAnimate(e, F),
      this
    );
  }
  to(e, T, C, $) {
    (null == T || T < 0) && (T = 0);
    const F = "string" == typeof C ? Easing[C] : C,
      V = this._addStep(T, null, F);
    return (
      (V.type = AnimateStepType.to),
      this._appendProps(e, V, !!$ && $.tempProps),
      V.propKeys || (V.propKeys = Object.keys(V.props)),
      ($ && $.noPreventAttrs) ||
        this.target.animates.forEach((e) => {
          e.id !== this.animate.id && e.preventAttrs(V.propKeys);
        }),
      this
    );
  }
  from(e, T, C, $) {
    this.to(e, 0, C, $);
    const F = {};
    this.stepTail.propKeys ||
      (this.stepTail.propKeys = Object.keys(this.stepTail.props)),
      this.stepTail.propKeys.forEach((e) => {
        F[e] = this.getLastPropByName(e, this.stepTail);
      }),
      this.to(F, T, C, $),
      (this.stepTail.type = AnimateStepType.from);
  }
  startAt(e) {
    return e < 0 && (e = 0), (this._startAt = e), this;
  }
  getStartProps() {
    var e;
    return null === (e = this.stepHead) || void 0 === e ? void 0 : e.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(e) {
    if (e > 0) {
      const T = this._addStep(+e, null);
      (T.type = AnimateStepType.wait),
        T.prev.customAnimate
          ? (T.props = T.prev.customAnimate.getEndProps())
          : (T.props = T.prev.props),
        this.target.onAddStep && this.target.onAddStep(T);
    }
    return this;
  }
  _addStep(e, T, C) {
    const $ = new Step(this.duration, e, T, C);
    return (
      (this.duration += e), this.stepTail.append($), (this.stepTail = $), $
    );
  }
  _appendProps(e, T, C) {
    T.props = C ? e : Object.assign({}, e);
    let $ = T.prev;
    const F = T.props;
    for (
      T.propKeys || (T.propKeys = Object.keys(T.props)),
        T.propKeys.forEach((e) => {
          void 0 === T.props[e] &&
            (T.props[e] = this.target.getDefaultAttribute(e));
        });
      $.prev;

    )
      $.props &&
        ($.propKeys || ($.propKeys = Object.keys($.props)),
        $.propKeys.forEach((e) => {
          void 0 === F[e] && (F[e] = $.props[e]);
        })),
        (T.propKeys = Object.keys(T.props)),
        ($ = $.prev);
    const V = this.stepHead.props;
    T.propKeys || (T.propKeys = Object.keys(F)),
      T.propKeys.forEach((e) => {
        if (void 0 === V[e]) {
          const T = this.animate.getStartProps();
          V[e] = T[e] = this.target.getComputedAttribute(e);
        }
      }),
      this.target.onAddStep && this.target.onAddStep(T);
  }
  _appendCustomAnimate(e, T) {
    (T.customAnimate = e), (e.step = T), e.bind(this.target, this);
  }
  setPosition(e) {
    var T;
    const C = this.duration,
      $ = this.loop,
      F = this.rawPosition;
    let V,
      Y,
      K = !1;
    const J = null !== (T = this._startAt) && void 0 !== T ? T : 0;
    if ((e < 0 && (e = 0), e < J)) return (this.rawPosition = e), !1;
    if (((e -= J), C <= 0)) return (K = !0), K;
    if (
      ((V = Math.floor(e / C)),
      (Y = e - V * C),
      (K = e >= $ * C + C),
      K && ((Y = C), (V = $), (e = Y * V + C)),
      e === F)
    )
      return K;
    const ee = !this.reversed != !(this.bounce && V % 2);
    return (
      ee && (Y = C - Y),
      (this._deltaPosition = Y - this.position),
      (this.position = Y),
      (this.rawPosition = e + J),
      this.updatePosition(K, ee),
      K
    );
  }
  updatePosition(e, T) {
    if (!this.stepHead) return;
    let C = this.stepHead.next;
    const $ = this.position,
      F = this.duration;
    if (this.target && C) {
      let V = C.next;
      for (; V && V.position <= $; ) (C = V), (V = C.next);
      let Y = e ? (0 === F ? 1 : $ / F) : ($ - C.position) / C.duration;
      C.easing && (Y = C.easing(Y)),
        this.tryCallCustomAnimateLifeCycle(
          C,
          this._lastStep || (T ? this.stepTail : this.stepHead),
          T
        ),
        this.updateTarget(C, Y, e),
        (this._lastStep = C),
        this.animate._onFrame && this.animate._onFrame.forEach((e) => e(C, Y));
    }
  }
  tryCallCustomAnimateLifeCycle(e, T, C) {
    if (e !== T)
      if (C) {
        let C = T.prev;
        for (; C && C !== e; )
          C.customAnimate &&
            (C.customAnimate.onStart && C.customAnimate.onStart(),
            C.customAnimate.onEnd && C.customAnimate.onEnd()),
            (C = e.prev);
        T &&
          T.customAnimate &&
          T.customAnimate.onEnd &&
          T.customAnimate.onEnd(),
          e &&
            e.customAnimate &&
            e.customAnimate.onStart &&
            e.customAnimate.onStart();
      } else {
        let C = T.next;
        for (; C && C !== e; )
          C.customAnimate &&
            (C.customAnimate.onStart && C.customAnimate.onStart(),
            C.customAnimate.onEnd && C.customAnimate.onEnd()),
            (C = C.next);
        T &&
          T.customAnimate &&
          T.customAnimate.onEnd &&
          T.customAnimate.onEnd(),
          e &&
            e.customAnimate &&
            e.customAnimate.onStart &&
            e.customAnimate.onStart();
      }
  }
  getLastPropByName(e, T) {
    let C = T.prev;
    for (; C; ) {
      if (C.props && void 0 !== C.props[e]) return C.props[e];
      if (C.customAnimate) {
        const T = C.customAnimate.getEndProps()[e];
        if (void 0 !== T) return T;
      }
      C = C.prev;
    }
    return Logger.getInstance().warn("step"), T.props[e];
  }
  updateTarget(e, T, C) {
    (null == e.props && null == e.customAnimate) ||
      this.target.onStep(this, this.animate, e, T, C);
  }
}
class Step {
  constructor(e, T, C, $) {
    (this.duration = T),
      (this.position = e),
      (this.props = C),
      (this.easing = $);
  }
  append(e) {
    (e.prev = this), (e.next = this.next), (this.next = e);
  }
  getLastProps() {
    let e = this.prev;
    for (; e; ) {
      if (e.props) return e.props;
      if (e.customAnimate) return e.customAnimate.getMergedEndProps();
      e = e.prev;
    }
    return null;
  }
}
const DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut",
};
var Edge;
!(function (e) {
  (e[(e.Top = 1)] = "Top"),
    (e[(e.Right = 2)] = "Right"),
    (e[(e.Bottom = 4)] = "Bottom"),
    (e[(e.Left = 8)] = "Left"),
    (e[(e.ALL = 15)] = "ALL");
})(Edge || (Edge = {}));
const _strokeVec4 = [!1, !1, !1, !1],
  parseStroke = (e) => {
    var T;
    let C = !0;
    if (isBoolean$1(e, !0)) {
      for (let $ = 0; $ < 4; $++)
        (_strokeVec4[$] = e),
          C && (C = !(null !== (T = _strokeVec4[$]) && void 0 !== T && !T));
      C = e;
    } else if (Array.isArray(e))
      for (let $ = 0; $ < 4; $++)
        (_strokeVec4[$] = !!e[$]), C && (C = !!_strokeVec4[$]);
    else
      (_strokeVec4[0] = !1),
        (_strokeVec4[1] = !1),
        (_strokeVec4[2] = !1),
        (_strokeVec4[3] = !1);
    return {
      isFullStroke: C,
      stroke: _strokeVec4,
    };
  },
  _paddingVec4 = [0, 0, 0, 0],
  parsePadding = (e) =>
    e
      ? isArray$1(e)
        ? 0 === e.length
          ? 0
          : 1 === e.length
          ? e[0]
          : 2 === e.length
          ? ((_paddingVec4[0] = e[0]),
            (_paddingVec4[2] = e[0]),
            (_paddingVec4[1] = e[1]),
            (_paddingVec4[3] = e[1]),
            _paddingVec4)
          : e
        : e
      : 0,
  _coords = [
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
    {
      x: 0,
      y: 0,
    },
  ],
  indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(e, T, C, $) {
  for (; e >= pi2; ) e -= pi2;
  for (; e < 0; ) e += pi2;
  for (; e > T; ) T += pi2;
  (_coords[0].x = C),
    (_coords[1].y = C),
    (_coords[2].x = -C),
    (_coords[3].y = -C);
  const F = Math.ceil(e / halfPi$1) % 4,
    V = Math.ceil(T / halfPi$1) % 4;
  if (
    ($.add(cos(e) * C, sin(e) * C),
    $.add(cos(T) * C, sin(T) * C),
    F !== V || T - e > pi)
  ) {
    let e = !1;
    for (let T = 0; T < indexList.length; T++)
      if (e || F !== indexList[T]) {
        if (e && V === indexList[T]) break;
        if (e) {
          const e = _coords[indexList[T]];
          $.add(e.x, e.y);
        }
      } else {
        e = !0;
        const T = _coords[F];
        $.add(T.x, T.y);
      }
  }
}
function pointInterpolation(e, T, C) {
  const { x: $, y: F } = pointAt(e.x, e.y, T.x, T.y, C),
    { x: V, y: Y } = pointAt(e.x1, e.y1, T.x1, T.y1, C),
    K = new Point($, F, V, Y);
  return (K.defined = T.defined), K;
}
function pointsInterpolation(e, T, C) {
  if (!e || !T) return [];
  Array.isArray(e) || (e = [e]), Array.isArray(T) || (T = [T]);
  let $ = [];
  if (e.length > T.length) {
    $ = T.map((e) => {
      const T = new Point(e.x, e.y, e.x1, e.y1);
      return (T.defined = e.defined), T;
    });
    for (let F = 0; F < T.length; F++) $[F] = pointInterpolation(e[F], T[F], C);
  } else {
    $ = T.map((e) => {
      const T = new Point(e.x, e.y, e.x1, e.y1);
      return (T.defined = e.defined), T;
    });
    for (let F = 0; F < e.length; F++) $[F] = pointInterpolation(e[F], T[F], C);
  }
  return $;
}
function getAttributeFromDefaultAttrList(e, T) {
  if (isArray$1(e)) {
    let C;
    for (let $ = 0; $ < e.length && void 0 === C; $++) C = e[$][T];
    return C;
  }
  return e[T];
}
class RafBasedSTO {
  constructor(e = RafBasedSTO.TimeOut) {
    (this.durations = []),
      (this.timeout = e),
      (this.lastDate = 0),
      (this.durationsListThreshold = 30);
  }
  call(e) {
    return (
      (this.lastDate = Date.now()),
      setTimeout(
        () => {
          this.appendDuration(Date.now() - this.lastDate), e(0);
        },
        this.timeout,
        !0
      )
    );
  }
  clear(e) {
    clearTimeout(e);
  }
  appendDuration(e) {
    this.durations.push(e),
      this.durations.length > this.durationsListThreshold &&
        this.durations.shift(),
      (this.timeout = Math.min(
        Math.max(
          this.durations.reduce((e, T) => e + T, 0) / this.durations.length,
          1e3 / 60
        ),
        1e3 / 30
      ));
  }
}
RafBasedSTO.TimeOut = 1e3 / 60;
const rafBasedSto = new RafBasedSTO(),
  calculateLineHeight = (e, T) =>
    isString$1(e) && "%" === e[e.length - 1]
      ? T * (Number.parseFloat(e.substring(0, e.length - 1)) / 100)
      : e,
  normalizeRectAttributes = (e) => {
    if (!e)
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
      };
    let T = isNil$1(e.width) ? e.x1 - e.x : e.width,
      C = isNil$1(e.height) ? e.y1 - e.y : e.height,
      $ = 0,
      F = 0;
    return (
      T < 0 ? (($ = T), (T = -T)) : Number.isNaN(T) && (T = 0),
      C < 0 ? ((F = C), (C = -C)) : Number.isNaN(C) && (C = 0),
      {
        x: $,
        y: F,
        width: T,
        height: C,
      }
    );
  };
var ColorType;
!(function (e) {
  (e[(e.Color255 = 0)] = "Color255"), (e[(e.Color1 = 1)] = "Color1");
})(ColorType || (ColorType = {}));
class ColorStore {
  static Get(e, T = ColorType.Color1, C = [0, 0, 0, 1]) {
    if (T === ColorType.Color1) {
      const T = ColorStore.store1[e];
      if (T)
        return (C[0] = T[0]), (C[1] = T[1]), (C[2] = T[2]), (C[3] = T[3]), C;
      const $ = Color.parseColorString(e);
      if ($) {
        const T = [$.r / 255, $.g / 255, $.b / 255, $.opacity];
        (ColorStore.store1[e] = T),
          (ColorStore.store255[e] = [$.r, $.g, $.b, $.opacity]),
          (C[0] = T[0]),
          (C[1] = T[1]),
          (C[2] = T[2]),
          (C[3] = T[3]);
      }
      return C;
    }
    const $ = ColorStore.store255[e];
    if ($) return (C[0] = $[0]), (C[1] = $[1]), (C[2] = $[2]), (C[3] = $[3]), C;
    const F = Color.parseColorString(e);
    return (
      F &&
        ((ColorStore.store1[e] = [F.r / 255, F.g / 255, F.b / 255, F.opacity]),
        (ColorStore.store255[e] = [F.r, F.g, F.b, F.opacity]),
        (C[0] = F.r),
        (C[1] = F.g),
        (C[2] = F.b),
        (C[3] = F.opacity)),
      C
    );
  }
  static Set(e, T, C) {
    if (T === ColorType.Color1) {
      if (ColorStore.store1[e]) return;
      (ColorStore.store1[e] = C),
        (ColorStore.store255[e] = [
          Math.floor(255 * C[0]),
          Math.floor(255 * C[1]),
          Math.floor(255 * C[2]),
          Math.floor(255 * C[3]),
        ]);
    } else {
      if (ColorStore.store255[e]) return;
      (ColorStore.store255[e] = C),
        (ColorStore.store1[e] = [C[0] / 255, C[1] / 255, C[2] / 255, C[3]]);
    }
  }
}
function colorArrayToString(e, T = !1) {
  return Array.isArray(e) && isNumber$1(e[0])
    ? T
      ? `rgb(${Math.round(e[0])},${Math.round(e[1])},${Math.round(
          e[2]
        )},${e[3].toFixed(2)})`
      : `rgb(${Math.round(e[0])},${Math.round(e[1])},${Math.round(e[2])})`
    : e;
}
function interpolateColor(e, T, C, $, F) {
  return (Array.isArray(e) && !isNumber$1(e[0])) ||
    (Array.isArray(T) && !isNumber$1(T[0]))
    ? new Array(4)
        .fill(0)
        .map((F, V) =>
          _interpolateColor(
            isArray$1(e) ? e[V] : e,
            isArray$1(T) ? T[V] : T,
            C,
            $
          )
        )
    : _interpolateColor(e, T, C, $, F);
}
function _interpolateColor(e, T, C, $, F) {
  if (!e || !T)
    return (e && colorArrayToString(e)) || (T && colorArrayToString(T)) || !1;
  let V,
    Y,
    K = !1,
    J = !1;
  if (
    (Array.isArray(e)
      ? (V = e)
      : "string" == typeof e
      ? (V = ColorStore.Get(e, ColorType.Color255))
      : (K = !0),
    Array.isArray(T)
      ? (Y = T)
      : "string" == typeof T
      ? (Y = ColorStore.Get(T, ColorType.Color255))
      : (J = !0),
    K !== J)
  ) {
    const V = K ? e : T,
      Y = K ? T : e,
      J = Object.assign(Object.assign({}, V), {
        stops: V.stops.map((e) =>
          Object.assign(Object.assign({}, e), {
            color: colorArrayToString(Y),
          })
        ),
      });
    return K
      ? interpolateColor(V, J, C, $, F)
      : interpolateColor(J, V, C, $, F);
  }
  if (K) {
    if (e.gradient === T.gradient) {
      const $ = e,
        F = T,
        V = $.stops,
        Y = F.stops;
      if (V.length !== Y.length) return !1;
      if ("linear" === $.gradient)
        return interpolateGradientLinearColor($, F, C);
      if ("radial" === $.gradient)
        return interpolateGradientRadialColor($, F, C);
      if ("conical" === $.gradient)
        return interpolateGradientConicalColor($, F, C);
    }
    return !1;
  }
  return (
    F && F(V, Y), colorArrayToString(interpolatePureColorArray(V, Y, C), $)
  );
}
function interpolateGradientLinearColor(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "linear",
    x0: e.x0 + (T.x0 - e.x0) * C,
    x1: e.x1 + (T.x1 - e.x1) * C,
    y0: e.y0 + (T.y0 - e.y0) * C,
    y1: e.y1 + (T.y1 - e.y1) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolateGradientRadialColor(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "radial",
    x0: e.x0 + (T.x0 - e.x0) * C,
    x1: e.x1 + (T.x1 - e.x1) * C,
    y0: e.y0 + (T.y0 - e.y0) * C,
    y1: e.y1 + (T.y1 - e.y1) * C,
    r0: e.r0 + (T.r0 - e.r0) * C,
    r1: e.r1 + (T.r1 - e.r1) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolateGradientConicalColor(e, T, C) {
  const $ = e.stops,
    F = T.stops;
  return {
    gradient: "conical",
    startAngle: e.startAngle + (T.startAngle - e.startAngle) * C,
    endAngle: e.endAngle + (T.endAngle - e.endAngle) * C,
    x: e.x + (T.x - e.x) * C,
    y: e.y + (T.y - e.y) * C,
    stops: new Array($.length).fill(0).map((e, T) => ({
      color: colorStringInterpolationToStr($[T].color, F[T].color, C),
      offset: $[T].offset + (F[T].offset - $[T].offset) * C,
    })),
  };
}
function interpolatePureColorArray(e, T, C) {
  return [
    e[0] + (T[0] - e[0]) * C,
    e[1] + (T[1] - e[1]) * C,
    e[2] + (T[2] - e[2]) * C,
    e[3] + (T[3] - e[3]) * C,
  ];
}
(ColorStore.store255 = {}), (ColorStore.store1 = {});
const _fromColorRGB = [0, 0, 0, 0],
  _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(e, T, C) {
  return (
    ColorStore.Get(e, ColorType.Color255, _fromColorRGB),
    ColorStore.Get(T, ColorType.Color255, _toColorRGB),
    `rgba(${Math.round(
      _fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * C
    )},${Math.round(
      _fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * C
    )},${Math.round(
      _fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * C
    )},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * C})`
  );
}
class ResourceLoader {
  static GetImage(e, T) {
    var C;
    const $ = ResourceLoader.cache.get(e);
    $
      ? "fail" === $.loadState
        ? application.global.getRequestAnimationFrame()(() => {
            T.imageLoadFail(e);
          })
        : "init" === $.loadState || "loading" === $.loadState
        ? null === (C = $.waitingMark) || void 0 === C || C.push(T)
        : T && T.imageLoadSuccess(e, $.data)
      : ResourceLoader.loadImage(e, T);
  }
  static GetSvg(e, T) {
    var C;
    let $ = ResourceLoader.cache.get(e);
    $
      ? "fail" === $.loadState
        ? application.global.getRequestAnimationFrame()(() => {
            T.imageLoadFail(e);
          })
        : "init" === $.loadState || "loading" === $.loadState
        ? null === (C = $.waitingMark) || void 0 === C || C.push(T)
        : T && T.imageLoadSuccess(e, $.data)
      : (($ = {
          type: "image",
          loadState: "init",
        }),
        ResourceLoader.cache.set(e, $),
        ($.dataPromise = application.global.loadSvg(e)),
        $.dataPromise
          ? (($.waitingMark = [T]),
            $.dataPromise.then((T) => {
              var C;
              ($.loadState = (null == T ? void 0 : T.data)
                ? "success"
                : "fail"),
                ($.data = null == T ? void 0 : T.data),
                null === (C = $.waitingMark) ||
                  void 0 === C ||
                  C.map((C, F) => {
                    (null == T ? void 0 : T.data)
                      ? (($.loadState = "success"),
                        ($.data = T.data),
                        C.imageLoadSuccess(e, T.data))
                      : (($.loadState = "fail"), C.imageLoadFail(e));
                  });
            }))
          : (($.loadState = "fail"), T.imageLoadFail(e)));
  }
  static GetFile(e, T) {
    let C = ResourceLoader.cache.get(e);
    return C
      ? "init" === C.loadState || "fail" === C.loadState
        ? Promise.reject()
        : "loading" === C.loadState
        ? C.dataPromise.then((e) => e.data)
        : Promise.resolve(C.data)
      : ((C = {
          type: T,
          loadState: "init",
        }),
        ResourceLoader.cache.set(e, C),
        "arrayBuffer" === T
          ? (C.dataPromise = application.global.loadArrayBuffer(e))
          : "blob" === T
          ? (C.dataPromise = application.global.loadBlob(e))
          : "json" === T && (C.dataPromise = application.global.loadJson(e)),
        C.dataPromise.then((e) => e.data));
  }
  static loading() {
    setTimeout(() => {
      if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
        ResourceLoader.isLoading = !0;
        const e = ResourceLoader.toLoadAueue.splice(0, 10),
          T = [];
        e.forEach((e) => {
          const { url: C, marks: $ } = e,
            F = {
              type: "image",
              loadState: "init",
            };
          if (
            (ResourceLoader.cache.set(C, F),
            (F.dataPromise = application.global.loadImage(C)),
            F.dataPromise)
          ) {
            F.waitingMark = $;
            const e = F.dataPromise.then((e) => {
              var T;
              (F.loadState = (null == e ? void 0 : e.data)
                ? "success"
                : "fail"),
                (F.data = null == e ? void 0 : e.data),
                null === (T = F.waitingMark) ||
                  void 0 === T ||
                  T.map((T, $) => {
                    (null == e ? void 0 : e.data)
                      ? ((F.loadState = "success"),
                        (F.data = e.data),
                        T.imageLoadSuccess(C, e.data))
                      : ((F.loadState = "fail"), T.imageLoadFail(C));
                  });
            });
            T.push(e);
          } else (F.loadState = "fail"), $.forEach((e) => e.imageLoadFail(C));
        }),
          Promise.all(T)
            .then(() => {
              (ResourceLoader.isLoading = !1),
                this.onLoadSuccessCb.forEach((e) => e()),
                ResourceLoader.loading();
            })
            .catch((e) => {
              console.error(e),
                (ResourceLoader.isLoading = !1),
                this.onLoadSuccessCb.forEach((e) => e()),
                ResourceLoader.loading();
            });
      }
    }, 0);
  }
  static loadImage(e, T) {
    const C = getIndex(e, ResourceLoader.toLoadAueue);
    if (-1 !== C)
      return (
        ResourceLoader.toLoadAueue[C].marks.push(T),
        void ResourceLoader.loading()
      );
    ResourceLoader.toLoadAueue.push({
      url: e,
      marks: [T],
    }),
      ResourceLoader.loading();
  }
  static improveImageLoading(e) {
    const T = getIndex(e, ResourceLoader.toLoadAueue);
    if (-1 !== T) {
      const e = ResourceLoader.toLoadAueue.splice(T, 1);
      ResourceLoader.toLoadAueue.unshift(e[0]);
    }
  }
  static onLoadSuccess(e) {
    this.onLoadSuccessCb.push(e);
  }
}
function getIndex(e, T) {
  for (let C = 0; C < T.length; C++) if (T[C].url === e) return C;
  return -1;
}
(ResourceLoader.cache = new Map()),
  (ResourceLoader.isLoading = !1),
  (ResourceLoader.toLoadAueue = []),
  (ResourceLoader.onLoadSuccessCb = []);
const tempMatrix = new Matrix(),
  tempBounds$1 = new AABBBounds(),
  GRAPHIC_UPDATE_TAG_KEY = [
    "lineWidth",
    "scaleX",
    "scaleY",
    "angle",
    "anchor",
    "visible",
  ],
  tempConstantXYKey = ["x", "y"],
  tempConstantScaleXYKey = ["scaleX", "scaleY"],
  tempConstantAngleKey = ["angle"],
  point = new Point(),
  NOWORK_ANIMATE_ATTR = {
    strokeSeg: 1,
    boundsPadding: 2,
    pickMode: 1,
    boundsMode: 1,
    customPickShape: 1,
    pickable: 1,
    childrenPickable: 1,
    visible: 1,
    zIndex: 1,
    layout: 1,
    keepDirIn3d: 1,
    globalZIndex: 1,
    outerBorder: 1,
    innerBorder: 1,
    lineDash: 1,
    lineCap: 1,
    lineJoin: 1,
    miterLimit: 2,
    strokeBoundsBuffer: 2,
    scaleCenter: 1,
    anchor: 1,
    anchor3d: 1,
    postMatrix: 1,
    backgroundMode: 2,
    background: 1,
    texture: 1,
    cursor: 1,
    html: 1,
  };
class Graphic extends Node {
  static mixin(e) {
    const T = Object.keys(e);
    for (let C = 0; C < T.length; ++C) {
      const $ = T[C];
      Object.defineProperty(
        Graphic.prototype,
        $,
        Object.getOwnPropertyDescriptor(e, $)
      );
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(!0);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(!0);
  }
  constructor(e = {}) {
    var T;
    super(),
      (this._AABBBounds = new AABBBounds()),
      (this._updateTag = UpdateTag.INIT),
      (this.attribute = e),
      (this.valid = this.isValid()),
      e.background
        ? this.loadImage(
            null !== (T = e.background.background) && void 0 !== T
              ? T
              : e.background,
            !0
          )
        : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic);
  }
  setMode(e) {
    "3d" === e ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  getOffsetXY(e, T = !1) {
    var C, $;
    const { dx: F = e.dx, dy: V = e.dy } = this.attribute;
    if (T && this.parent) {
      const e = this.parent.attribute;
      (point.x = F + (null !== (C = e.scrollX) && void 0 !== C ? C : 0)),
        (point.y = V + (null !== ($ = e.scrollY) && void 0 !== $ ? $ : 0));
    } else (point.x = F), (point.y = V);
    return point;
  }
  onAnimateBind(e) {
    this._emitCustomEvent("animate-bind", e);
  }
  tryUpdateAABBBounds(e) {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(
      this,
      this.stage,
      !0,
      this._AABBBounds
    );
    const T = this.doUpdateAABBBounds(e);
    return (
      application.graphicService.afterUpdateAABBBounds(
        this,
        this.stage,
        this._AABBBounds,
        this,
        !0
      ),
      T
    );
  }
  combindShadowAABBBounds(e) {
    if (this.shadowRoot) {
      const T = this.shadowRoot.AABBBounds.clone();
      e.union(T);
    }
  }
  tryUpdateGlobalAABBBounds() {
    const e = this.AABBBounds;
    return (
      this._globalAABBBounds
        ? this._globalAABBBounds.setValue(e.x1, e.y1, e.x2, e.y2)
        : (this._globalAABBBounds = e.clone()),
      this._globalAABBBounds.empty() ||
        (this.parent &&
          this._globalAABBBounds.transformWithMatrix(
            this.parent.globalTransMatrix
          )),
      this._globalAABBBounds
    );
  }
  tryUpdateGlobalTransMatrix(e = !0) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const e = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
      }
    } else
      this._globalTransMatrix = this.parent
        ? this.parent.globalTransMatrix.clone()
        : this.transMatrix.clone();
    return (
      this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(),
      this._globalTransMatrix
    );
  }
  shouldUpdateGlobalMatrix() {
    return !0;
  }
  tryUpdateLocalTransMatrix(e = !0) {
    return (
      this._transMatrix || (this._transMatrix = new Matrix()),
      this.shouldUpdateLocalMatrix() &&
        (this.doUpdateLocalMatrix(), e && this.clearUpdateLocalPositionTag()),
      this._transMatrix
    );
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot
      ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) ||
          this.shadowRoot.shouldUpdateAABBBounds()
      : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot
      ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) ||
          this.shadowRoot.shouldUpdateAABBBounds()
      : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var e, T;
    const C = this.attribute;
    return Number.isFinite(
      (null !== (e = C.x) && void 0 !== e ? e : 0) +
        (null !== (T = C.y) && void 0 !== T ? T : 0)
    );
  }
  _validNumber(e) {
    return null == e || Number.isFinite(e);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(e, T, C, $) {
    if (!$) return !1;
    if (C === IContainPointMode.GLOBAL) {
      const C = new Point(e, T);
      this.parent && this.parent.globalTransMatrix.transformPoint(C, C),
        (e = C.x),
        (T = C.y);
    }
    return $.containsPoint(this, {
      x: e,
      y: T,
    });
  }
  setAttributes(e, T = !1, C) {
    (e =
      (this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(e, this.attribute, null, C)) ||
      e).background
      ? this.loadImage(e.background, !0)
      : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic),
      this._setAttributes(e, T, C);
  }
  _setAttributes(e, T = !1, C) {
    const $ = Object.keys(e);
    for (let F = 0; F < $.length; F++) {
      const T = $[F];
      this.attribute[T] = e[T];
    }
    (this.valid = this.isValid()),
      this.updateShapeAndBoundsTagSetted() || (!T && !this.needUpdateTags($))
        ? this.addUpdateBoundTag()
        : this.addUpdateShapeAndBoundsTag(),
      this.addUpdatePositionTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(C);
  }
  setAttribute(e, T, C, $) {
    var F;
    const V =
      this.onBeforeAttributeUpdate &&
      this.onBeforeAttributeUpdate(
        {
          [e]: T,
        },
        this.attribute,
        e,
        $
      );
    V
      ? this._setAttributes(V, C, $)
      : isNil$1(null === (F = this.normalAttrs) || void 0 === F ? void 0 : F[e])
      ? ((this.attribute[e] = T),
        (this.valid = this.isValid()),
        this.updateShapeAndBoundsTagSetted() || (!C && !this.needUpdateTag(e))
          ? this.addUpdateBoundTag()
          : this.addUpdateShapeAndBoundsTag(),
        this.addUpdatePositionTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($))
      : (this.normalAttrs[e] = T),
      "background" === e
        ? this.loadImage(T, !0)
        : "shadowGraphic" === e && this.setShadowGraphic(T);
  }
  needUpdateTags(e, T = GRAPHIC_UPDATE_TAG_KEY) {
    for (let C = 0; C < T.length; C++) {
      const $ = T[C];
      if (-1 !== e.indexOf($)) return !0;
    }
    return !1;
  }
  needUpdateTag(e, T = GRAPHIC_UPDATE_TAG_KEY) {
    for (let C = 0; C < T.length; C++) if (e === T[C]) return !0;
    return !1;
  }
  initAttributes(e) {
    const T = {
      type: AttributeUpdateType.INIT,
    };
    (e =
      (this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(e, this.attribute, null, T)) ||
      e),
      (this.attribute = e),
      e.background
        ? this.loadImage(e.background, !0)
        : e.shadowGraphic && this.setShadowGraphic(e.shadowGraphic),
      (this._updateTag = UpdateTag.INIT),
      (this.valid = this.isValid()),
      this.onAttributeUpdate(T);
  }
  translate(e, T) {
    var C, $;
    if (0 === e && 0 === T) return this;
    const F = {
        type: AttributeUpdateType.TRANSLATE,
      },
      V =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            x: e,
            y: T,
          },
          this.attribute,
          tempConstantXYKey,
          F
        );
    V && ((e = V.x), (T = V.y), delete V.x, delete V.y, this._setAttributes(V));
    const Y = this.attribute,
      K = Y.postMatrix;
    return (
      K
        ? application.transformUtil.fromMatrix(K, K).translate(e, T)
        : ((Y.x =
            (null !== (C = Y.x) && void 0 !== C ? C : DefaultTransform.x) + e),
          (Y.y =
            (null !== ($ = Y.y) && void 0 !== $ ? $ : DefaultTransform.y) + T)),
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(F),
      this
    );
  }
  translateTo(e, T) {
    const C = this.attribute;
    if (C.x === e && C.y === T) return this;
    const $ = {
        type: AttributeUpdateType.TRANSLATE_TO,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            x: e,
            y: T,
          },
          this.attribute,
          tempConstantXYKey,
          $
        );
    return F
      ? (this._setAttributes(F, !1, $), this)
      : ((C.x = e),
        (C.y = T),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($),
        this);
  }
  scale(e, T, C) {
    var $, F;
    if (1 === e && 1 === T) return this;
    const V = {
        type: AttributeUpdateType.SCALE,
      },
      Y =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            scaleX: e,
            scaleY: T,
            scaleCenter: C,
          },
          this.attribute,
          tempConstantScaleXYKey,
          V
        );
    Y &&
      ((e = Y.scaleX),
      (T = Y.scaleY),
      delete Y.scaleX,
      delete Y.scaleY,
      this._setAttributes(Y));
    const K = this.attribute;
    if (C) {
      let { postMatrix: $ } = this.attribute;
      $ || (($ = new Matrix()), (K.postMatrix = $)),
        application.transformUtil.fromMatrix($, $).scale(e, T, C);
    } else
      (K.scaleX =
        (null !== ($ = K.scaleX) && void 0 !== $
          ? $
          : DefaultTransform.scaleX) * e),
        (K.scaleY =
          (null !== (F = K.scaleY) && void 0 !== F
            ? F
            : DefaultTransform.scaleY) * T);
    return (
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate(V),
      this
    );
  }
  scaleTo(e, T) {
    const C = this.attribute;
    if (C.scaleX === e && C.scaleY === T) return this;
    const $ = {
        type: AttributeUpdateType.SCALE_TO,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            scaleX: e,
            scaleY: T,
          },
          this.attribute,
          tempConstantScaleXYKey,
          $
        );
    return F
      ? (this._setAttributes(F, !1, $), this)
      : ((C.scaleX = e),
        (C.scaleY = T),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate($),
        this);
  }
  rotate(e, T) {
    var C;
    if (0 === e) return this;
    const $ = {
        type: AttributeUpdateType.ROTATE,
      },
      F =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          {
            angle: e,
            rotateCenter: T,
          },
          this.attribute,
          tempConstantAngleKey,
          $
        );
    F && (delete F.angle, this._setAttributes(F, !1, $));
    const V = this.attribute;
    if (T) {
      let { postMatrix: C } = this.attribute;
      C || ((C = new Matrix()), (V.postMatrix = C)),
        application.transformUtil.fromMatrix(C, C).rotate(e, T);
    } else
      V.angle =
        (null !== (C = V.angle) && void 0 !== C ? C : DefaultTransform.angle) +
        e;
    return (
      this.addUpdatePositionTag(),
      this.addUpdateBoundTag(),
      this.addUpdateLayoutTag(),
      this.onAttributeUpdate($),
      this
    );
  }
  rotateTo(e) {
    const T = this.attribute;
    if (T.angle === e) return this;
    const C = {
        type: AttributeUpdateType.ROTATE_TO,
      },
      $ =
        this.onBeforeAttributeUpdate &&
        this.onBeforeAttributeUpdate(
          e,
          this.attribute,
          tempConstantAngleKey,
          C
        );
    return $
      ? (this._setAttributes($, !1, C), this)
      : ((T.angle = e),
        this.addUpdatePositionTag(),
        this.addUpdateBoundTag(),
        this.addUpdateLayoutTag(),
        this.onAttributeUpdate(C),
        this);
  }
  skewTo(e, T) {
    return this;
  }
  animate(e) {
    this.animates || (this.animates = new Map());
    const T = new Animate(
      null == e ? void 0 : e.id,
      this.stage && this.stage.getTimeline()
    ).bind(this);
    if (e) {
      const { onStart: C, onFrame: $, onEnd: F, onRemove: V } = e;
      null != C && T.onStart(C),
        null != $ && T.onFrame($),
        null != F && T.onEnd(F),
        null != V && T.onRemove(V),
        (T.interpolateFunc = e.interpolate);
    }
    return (
      this.animates.set(T.id, T),
      T.onRemove(() => {
        this.animates.delete(T.id);
      }),
      T
    );
  }
  onAttributeUpdate(e) {
    (e && e.skipUpdateCallback) ||
      (application.graphicService.onAttributeUpdate(this),
      this._emitCustomEvent("afterAttributeUpdate", e));
  }
  update(e) {
    e
      ? (e.bounds &&
          this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode),
        e.trans && this.tryUpdateLocalTransMatrix())
      : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode),
        this.tryUpdateLocalTransMatrix());
  }
  hasState(e) {
    return (
      !(!this.currentStates || !this.currentStates.length) &&
      (!!isNil$1(e) || this.currentStates.includes(e))
    );
  }
  getState(e) {
    var T;
    return null === (T = this.states) || void 0 === T ? void 0 : T[e];
  }
  applyStateAttrs(e, T, C, $) {
    var F, V, Y, K;
    if (C) {
      const C = Object.keys(e),
        J = this.getNoWorkAnimateAttr(),
        ee = {};
      let te;
      C.forEach((T) => {
        J[T]
          ? (te || (te = {}), (te[T] = e[T]))
          : (ee[T] = $ && void 0 === e[T] ? this.getDefaultAttribute(T) : e[T]);
      });
      const ie = this.animate();
      (ie.stateNames = T),
        ie.to(
          ee,
          null !==
            (V =
              null === (F = this.stateAnimateConfig) || void 0 === F
                ? void 0
                : F.duration) && void 0 !== V
            ? V
            : DefaultStateAnimateConfig.duration,
          null !==
            (K =
              null === (Y = this.stateAnimateConfig) || void 0 === Y
                ? void 0
                : Y.easing) && void 0 !== K
            ? K
            : DefaultStateAnimateConfig.easing
        ),
        te &&
          this.setAttributes(te, !1, {
            type: AttributeUpdateType.STATE,
          });
    } else
      this.stopStateAnimates(),
        this.setAttributes(e, !1, {
          type: AttributeUpdateType.STATE,
        });
  }
  updateNormalAttrs(e) {
    const T = {};
    this.normalAttrs
      ? (Object.keys(e).forEach((e) => {
          e in this.normalAttrs
            ? ((T[e] = this.normalAttrs[e]), delete this.normalAttrs[e])
            : (T[e] = this.getNormalAttribute(e));
        }),
        Object.keys(this.normalAttrs).forEach((T) => {
          e[T] = this.normalAttrs[T];
        }))
      : Object.keys(e).forEach((e) => {
          T[e] = this.getNormalAttribute(e);
        }),
      (this.normalAttrs = T);
  }
  stopStateAnimates(e = "end") {
    this.animates &&
      this.animates.forEach((T) => {
        T.stateNames && (T.stop(e), this.animates.delete(T.id));
      });
  }
  getNormalAttribute(e) {
    let T = this.attribute[e];
    return (
      this.animates &&
        this.animates.forEach((C) => {
          if (C.stateNames) {
            const $ = C.getEndProps();
            has$1($, e) && (T = $[e]);
          }
        }),
      T
    );
  }
  clearStates(e) {
    this.hasState() && this.normalAttrs
      ? ((this.currentStates = []),
        this.applyStateAttrs(this.normalAttrs, this.currentStates, e, !0))
      : (this.currentStates = []),
      (this.normalAttrs = null);
  }
  removeState(e, T) {
    if ((this.currentStates ? this.currentStates.indexOf(e) : -1) >= 0) {
      const C = this.currentStates.filter((T) => T !== e);
      this.useStates(C, T);
    }
  }
  toggleState(e, T) {
    if (this.hasState(e)) this.removeState(e, T);
    else if ((this.currentStates ? this.currentStates.indexOf(e) : -1) < 0) {
      const C = this.currentStates ? this.currentStates.slice() : [];
      C.push(e), this.useStates(C, T);
    }
  }
  addState(e, T, C) {
    var $;
    if (
      this.currentStates &&
      this.currentStates.includes(e) &&
      (T || 1 === this.currentStates.length)
    )
      return;
    const F =
      T &&
      (null === ($ = this.currentStates) || void 0 === $ ? void 0 : $.length)
        ? this.currentStates.concat([e])
        : [e];
    this.useStates(F, C);
  }
  useStates(e, T) {
    var C;
    if (!e.length) return void this.clearStates(T);
    if (
      (null === (C = this.currentStates) || void 0 === C
        ? void 0
        : C.length) === e.length &&
      !e.some((e, T) => this.currentStates[T] !== e)
    )
      return;
    const $ = {};
    e.forEach((T) => {
      var C;
      const F = this.stateProxy
        ? this.stateProxy(T, e)
        : null === (C = this.states) || void 0 === C
        ? void 0
        : C[T];
      F && Object.assign($, F);
    }),
      this.updateNormalAttrs($),
      (this.currentStates = e),
      this.applyStateAttrs($, e, T);
  }
  addUpdateBoundTag() {
    (this._updateTag |= UpdateTag.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag(),
      this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    (this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag(),
      this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (
      (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) ===
      UpdateTag.UPDATE_SHAPE_AND_BOUNDS
    );
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(),
      (this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX);
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(),
      (this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(e, T) {
    const C = [0, 0],
      $ = () => {
        if (T.b) return T.b;
        const { scaleX: e, scaleY: C, angle: $ } = this.attribute;
        return (
          tempBounds$1.copy(this._AABBBounds),
          this.setAttributes({
            scaleX: 1,
            scaleY: 1,
            angle: 0,
          }),
          (T.b = this.AABBBounds.clone()),
          this._AABBBounds.copy(tempBounds$1),
          this.setAttributes({
            scaleX: e,
            scaleY: C,
            angle: $,
          }),
          T.b
        );
      };
    if ("string" == typeof e[0]) {
      const T = parseFloat(e[0]) / 100,
        F = $();
      C[0] = F.x1 + (F.x2 - F.x1) * T;
    } else C[0] = e[0];
    if ("string" == typeof e[1]) {
      const T = parseFloat(e[1]) / 100,
        F = $();
      C[1] = F.y1 + (F.y2 - F.y1) * T;
    } else C[1] = e[1];
    return C;
  }
  doUpdateLocalMatrix() {
    const {
      x: e = DefaultTransform.x,
      y: T = DefaultTransform.y,
      scaleX: C = DefaultTransform.scaleX,
      scaleY: $ = DefaultTransform.scaleY,
      angle: F = DefaultTransform.angle,
      scaleCenter: V,
      anchor: Y,
      postMatrix: K,
    } = this.attribute;
    let J = [0, 0];
    const ee = {};
    if ((Y && (J = this.getAnchor(Y, ee)), !V || (1 === C && 1 === $)))
      normalTransform(
        this._transMatrix,
        this._transMatrix.reset(),
        e,
        T,
        C,
        $,
        F,
        Y && J
      );
    else {
      const Y = this._transMatrix;
      Y.reset(),
        Y.translate(J[0], J[1]),
        Y.rotate(F),
        Y.translate(-J[0], -J[1]),
        Y.translate(e, T),
        (J = this.getAnchor(V, ee)),
        application.transformUtil.fromMatrix(Y, Y).scale(C, $, {
          x: J[0],
          y: J[1],
        });
    }
    const te = this.getOffsetXY(DefaultTransform);
    if (((this._transMatrix.e += te.x), (this._transMatrix.f += te.y), K)) {
      const e = tempMatrix.setValue(K.a, K.b, K.c, K.d, K.e, K.f),
        T = this._transMatrix;
      e.multiply(T.a, T.b, T.c, T.d, T.e, T.f),
        T.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(
        this.transMatrix.a,
        this.transMatrix.b,
        this.transMatrix.c,
        this.transMatrix.d,
        this.transMatrix.e,
        this.transMatrix.f
      );
      const { scrollX: e = 0, scrollY: T = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(e, T);
    }
  }
  setStage(e, T) {
    if (this.stage !== e) {
      if (
        ((this.stage = e),
        (this.layer = T),
        this.setStageToShadowRoot(e, T),
        this.animates && this.animates.size)
      ) {
        const T = e.getTimeline();
        this.animates.forEach((e) => {
          e.setTimeline(T);
        });
      }
      this._onSetStage && this._onSetStage(this, e, T),
        application.graphicService.onSetStage(this, e);
    }
  }
  setStageToShadowRoot(e, T) {
    this.shadowRoot && this.shadowRoot.setStage(e, T);
  }
  onAddStep(e) {}
  onStop(e) {
    e &&
      this.setAttributes(e, !1, {
        type: AttributeUpdateType.ANIMATE_END,
      });
  }
  onStep(e, T, C, $, F) {
    const V = {};
    if (C.customAnimate) C.customAnimate.update(F, $, V);
    else {
      const Y = C.props,
        K = C.parsedProps,
        J = C.propKeys;
      this.stepInterpolate(e, T, V, C, $, F, Y, void 0, K, J);
    }
    this.setAttributes(V, !1, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio: $,
        end: F,
        step: C,
        isFirstFrameOfStep: e.getLastStep() !== C,
      },
    }),
      this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(e, T, C, $, F, V, Y, K, J, ee) {
    ee || ((ee = Object.keys(Y)), ($.propKeys = ee)),
      V
        ? $.propKeys.forEach((e) => {
            T.validAttr(e) && (C[e] = Y[e]);
          })
        : ee.forEach((V) => {
            var ee;
            if (!T.validAttr(V)) return;
            const te = Y[V],
              ie =
                null !== (ee = K && K[V]) && void 0 !== ee
                  ? ee
                  : e.getLastPropByName(V, $);
            if (null == te || null == ie) return void (C[V] = te);
            let ne;
            (ne = T.interpolateFunc && T.interpolateFunc(V, F, ie, te, C)),
              ne ||
                ((ne = T.customInterpolate(V, F, ie, te, this, C)),
                ne ||
                  this.defaultInterpolate(te, ie, V, C, J, F) ||
                  this._interpolate(V, F, ie, te, C));
          }),
      ($.parsedProps = J);
  }
  defaultInterpolate(e, T, C, $, F, V) {
    if (Number.isFinite(e)) return ($[C] = T + (e - T) * V), !0;
    if ("fill" === C) {
      F || (F = {});
      const Y = F.fillColorArray,
        K = interpolateColor(T, null != Y ? Y : e, V, !1, (e, T) => {
          F.fillColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    if ("stroke" === C) {
      F || (F = {});
      const Y = F.strokeColorArray,
        K = interpolateColor(T, null != Y ? Y : e, V, !1, (e, T) => {
          F.strokeColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    if ("shadowColor" === C) {
      F || (F = {});
      const Y = F.shadowColorArray,
        K = interpolateColor(T, null != Y ? Y : e, V, !0, (e, T) => {
          F.shadowColorArray = T;
        });
      return K && ($[C] = K), !0;
    }
    return !1;
  }
  _interpolate(e, T, C, $, F) {}
  getDefaultAttribute(e) {
    return getTheme(this)[this.type][e];
  }
  getComputedAttribute(e) {
    var T;
    return null !== (T = this.attribute[e]) && void 0 !== T
      ? T
      : this.getDefaultAttribute(e);
  }
  onSetStage(e, T = !1) {
    (this._onSetStage = e), T && this.stage && e(this, this.stage);
  }
  attachShadow(e) {
    return (
      e && (e.shadowHost = this),
      (this.shadowRoot =
        null != e ? e : application.graphicService.creator.shadowRoot(this)),
      this.addUpdateBoundTag(),
      this.shadowRoot.setStage(this.stage, this.layer),
      this.shadowRoot
    );
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), (this.shadowRoot = null));
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((e) => e.toJson()),
    };
  }
  createPathProxy(e) {
    return (
      isString$1(e, !0)
        ? (this.pathProxy = new CustomPath2D().fromString(e))
        : (this.pathProxy = new CustomPath2D()),
      this.pathProxy
    );
  }
  loadImage(e, T = !1) {
    if (!e || (T && backgroundNotImage(e))) return;
    const C = e;
    this.resources || (this.resources = new Map());
    const $ = {
      data: "init",
      state: null,
    };
    this.resources.set(C, $),
      "string" == typeof e
        ? (($.state = "loading"),
          e.startsWith("<svg")
            ? (ResourceLoader.GetSvg(e, this),
              (this.backgroundImg = this.backgroundImg || T))
            : (isValidUrl$1(e) || e.includes("/") || isBase64$1(e)) &&
              (ResourceLoader.GetImage(e, this),
              (this.backgroundImg = this.backgroundImg || T)))
        : isObject$1(e)
        ? (($.state = "success"),
          ($.data = e),
          (this.backgroundImg = this.backgroundImg || T))
        : ($.state = "fail");
  }
  setShadowGraphic(e) {
    e ? this.attachShadow().add(e) : this.detachShadow();
  }
  imageLoadSuccess(e, T, C) {
    if (!this.resources) return;
    const $ = this.resources.get(e);
    $ &&
      (($.state = "success"),
      ($.data = T),
      C && C(),
      this.addUpdateBoundTag(),
      this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(e, T) {
    if (!this.resources) return;
    const C = this.resources.get(e);
    C && ((C.state = "fail"), T && T());
  }
  _stopAnimates(e) {
    e &&
      e.forEach((e) => {
        e.stop();
      });
  }
  stopAnimates(e = !1) {
    this._stopAnimates(this.animates),
      this.shadowRoot && this.shadowRoot.stopAnimates(!0),
      this.isContainer &&
        e &&
        this.forEachChildren((T) => {
          T.stopAnimates(e);
        });
  }
  release() {
    (this.releaseStatus = "released"),
      application.graphicService.onRelease(this);
  }
  _emitCustomEvent(e, T) {
    var C, $;
    if (this._events && e in this._events) {
      const F = new CustomEvent(e, T);
      (F.bubbles = !1),
        (F.manager =
          null ===
            ($ =
              null === (C = this.stage) || void 0 === C
                ? void 0
                : C.eventSystem) || void 0 === $
            ? void 0
            : $.manager),
        this.dispatchEvent(F);
    }
  }
}
function backgroundNotImage(e) {
  return !(!e.fill && !e.stroke);
}
function getAllMatches(e, T) {
  const C = [];
  let $ = T.exec(e);
  for (; $; ) {
    const F = [];
    F.startIndex = T.lastIndex - $[0].length;
    const V = $.length;
    for (let e = 0; e < V; e++) F.push($[e]);
    C.push(F), ($ = T.exec(e));
  }
  return C;
}
Graphic.mixin(EventTarget);
class XmlNode {
  constructor(e) {
    (this.tagname = e), (this.child = []), (this[":@"] = {});
  }
  add(e, T) {
    "__proto__" === e && (e = "#__proto__"),
      this.child.push({
        [e]: T,
      });
  }
  addChild(e) {
    "__proto__" === e.tagname && (e.tagname = "#__proto__"),
      e[":@"] && Object.keys(e[":@"]).length > 0
        ? this.child.push({
            [e.tagname]: e.child,
            ":@": e[":@"],
          })
        : this.child.push({
            [e.tagname]: e.child,
          });
  }
}
function findClosingIndex(e, T, C, $) {
  const F = e.indexOf(T, C);
  if (-1 === F) throw new Error($);
  return F + T.length - 1;
}
function tagExpWithClosingIndex(e, T, C = ">") {
  let $,
    F = "";
  for (let V = T; V < e.length; V++) {
    let T = e[V];
    if ($) T === $ && ($ = "");
    else if ('"' === T || "'" === T) $ = T;
    else if (T === C[0]) {
      if (!C[1])
        return {
          data: F,
          index: V,
        };
      if (e[V + 1] === C[1])
        return {
          data: F,
          index: V,
        };
    } else "\t" === T && (T = " ");
    F += T;
  }
}
function readTagExp(e, T, C, $ = ">") {
  const F = tagExpWithClosingIndex(e, T + 1, $);
  if (!F) return;
  let V = F.data;
  const Y = F.index,
    K = V.search(/\s/);
  let J = V,
    ee = !0;
  -1 !== K &&
    ((J = V.substr(0, K).replace(/\s\s*$/, "")), (V = V.substr(K + 1)));
  const te = J;
  if (C) {
    const e = J.indexOf(":");
    -1 !== e && ((J = J.substr(e + 1)), (ee = J !== F.data.substr(e + 1)));
  }
  return {
    tagName: J,
    tagExp: V,
    closeIndex: Y,
    attrExpPresent: ee,
    rawTagName: te,
  };
}
const attrsRegx = new RegExp(
  "([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?",
  "gm"
);
class OrderedObjParser {
  constructor(e) {
    (this.currentNode = null),
      (this.options = e),
      (this.tagsNodeStack = []),
      (this.docTypeEntities = {});
  }
  addChild(e, T, C) {
    const $ = T.tagname;
    "string" == typeof $ ? ((T.tagname = $), e.addChild(T)) : e.addChild(T);
  }
  buildAttributesMap(e, T, C) {
    const $ = {};
    if (!e) return;
    const F = getAllMatches(e, attrsRegx),
      V = F.length;
    for (let Y = 0; Y < V; Y++) {
      const e = F[Y][1],
        T = F[Y][4];
      e && ($[e] = void 0 === T || (isNaN(T) ? T : Number(T)));
    }
    return $;
  }
  parseXml(e) {
    e = e.replace(/\r\n?/g, "\n");
    const T = new XmlNode("!xml");
    let C = T,
      $ = "",
      F = "";
    for (let V = 0; V < e.length; V++)
      if ("<" === e[V])
        if ("/" === e[V + 1]) {
          const T = findClosingIndex(e, ">", V, "Closing Tag is not closed."),
            Y = F.lastIndexOf(".");
          (F = F.substring(0, Y)),
            (C = this.tagsNodeStack.pop()),
            C &&
              C.child &&
              $ &&
              C.child[C.child.length - 1][":@"] &&
              (C.child[C.child.length - 1][":@"].text = $),
            ($ = ""),
            (V = T);
        } else if ("?" === e[V + 1])
          V = readTagExp(e, V, !1, "?>").closeIndex + 1;
        else if ("!--" === e.substr(V + 1, 3))
          V = findClosingIndex(e, "--\x3e", V + 4, "Comment is not closed.");
        else {
          const Y = readTagExp(e, V, !1);
          let K = Y.tagName,
            J = Y.tagExp;
          const ee = Y.attrExpPresent,
            te = Y.closeIndex;
          if (
            (K !== T.tagname && (F += F ? "." + K : K),
            J.length > 0 && J.lastIndexOf("/") === J.length - 1)
          ) {
            "/" === K[K.length - 1]
              ? ((K = K.substr(0, K.length - 1)),
                (F = F.substr(0, F.length - 1)),
                (J = K))
              : (J = J.substr(0, J.length - 1));
            const e = new XmlNode(K);
            K !== J && ee && (e[":@"] = this.buildAttributesMap(J, F, K)),
              this.addChild(C, e, F),
              (F = F.substr(0, F.lastIndexOf(".")));
          } else {
            const e = new XmlNode(K);
            this.tagsNodeStack.push(C),
              K !== J && ee && (e[":@"] = this.buildAttributesMap(J, F, K)),
              this.addChild(C, e, F),
              (C = e);
          }
          ($ = ""), (V = te);
        }
      else $ += e[V];
    return T.child;
  }
}
function prettify(e, T) {
  return compress(e);
}
function compress(e, T) {
  const C = {};
  for (let $ = 0; $ < e.length; $++) {
    const T = e[$],
      F = propName(T);
    if (void 0 !== F && T[F]) {
      const e = compress(T[F]);
      isLeafTag(e),
        T[":@"] && assignAttributes(e, T[":@"]),
        void 0 !== C[F] && C.hasOwnProperty(F)
          ? (Array.isArray(C[F]) || (C[F] = [C[F]]), C[F].push(e))
          : (C[F] = e);
    }
  }
  return C;
}
function propName(e) {
  const T = Object.keys(e);
  for (let C = 0; C < T.length; C++) {
    const e = T[C];
    if (":@" !== e) return e;
  }
}
function assignAttributes(e, T, C) {
  if (T) {
    const C = Object.keys(T),
      $ = C.length;
    for (let F = 0; F < $; F++) {
      const $ = C[F];
      e[$] = T[$];
    }
  }
}
function isLeafTag(e) {
  return 0 === Object.keys(e).length;
}
class XMLParser {
  constructor(e) {
    this.options = Object.assign({}, XMLParser.defaultOptions, e);
  }
  valid(e) {
    return e.startsWith("<");
  }
  parse(e) {
    if (!this.valid) return !1;
    return prettify(
      new OrderedObjParser(this.options).parseXml(e),
      this.options
    );
  }
}
function isSvg(e) {
  return e.startsWith("<svg") || e.startsWith("<?xml");
}
function boundStroke(e, T, C, $ = 0) {
  return e.expand(T + ($ / 2 + (C ? miterAdjustment(C, T) : 0))), e;
}
function miterAdjustment(e, T) {
  return e ? T : 0;
}
(XMLParser.defaultOptions = {}), globalThis && globalThis.__awaiter;
let NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
function verticalLayout(e) {
  const T = [];
  let C = 0,
    $ = "";
  for (let F = 0; F < e.length; F++)
    rotateText(e[F])
      ? C
        ? ($ += e[F])
        : ((C = 1), ($ = e[F]))
      : (C &&
          (T.push({
            text: $,
            direction: TextDirection.VERTICAL,
          }),
          ($ = ""),
          (C = 0)),
        T.push({
          text: e[F],
          direction: TextDirection.HORIZONTAL,
        }));
  return (
    $ &&
      T.push({
        text: $,
        direction: TextDirection.VERTICAL,
      }),
    T
  );
}
!(function (e) {
  (e[(e.HORIZONTAL = 0)] = "HORIZONTAL"), (e[(e.VERTICAL = 1)] = "VERTICAL");
})(TextDirection || (TextDirection = {}));
const rotateCharList = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
  ],
  rotateCharMap = new Map();
rotateCharList.forEach((e) => rotateCharMap.set(e, !0));
const noRotateCharList = [""],
  noRotateCharMap = new Map();
function rotateText(e) {
  if (rotateCharMap.has(e)) return !0;
  if (noRotateCharMap.has(e)) return !1;
  let T = !1;
  return e.codePointAt(0) < 256 && (T = !0), T;
}
noRotateCharList.forEach((e) => noRotateCharMap.set(e, !0));
const ARC_NUMBER_TYPE = genNumberType(),
  ARC3D_NUMBER_TYPE = genNumberType(),
  AREA_NUMBER_TYPE = genNumberType(),
  CIRCLE_NUMBER_TYPE = genNumberType(),
  GLYPH_NUMBER_TYPE = genNumberType(),
  GROUP_NUMBER_TYPE = genNumberType(),
  IMAGE_NUMBER_TYPE = genNumberType(),
  LINE_NUMBER_TYPE = genNumberType(),
  PATH_NUMBER_TYPE = genNumberType(),
  POLYGON_NUMBER_TYPE = genNumberType(),
  PYRAMID3D_NUMBER_TYPE = genNumberType(),
  RECT_NUMBER_TYPE = genNumberType(),
  RECT3D_NUMBER_TYPE = genNumberType(),
  RICHTEXT_NUMBER_TYPE = genNumberType(),
  SYMBOL_NUMBER_TYPE = genNumberType(),
  TEXT_NUMBER_TYPE = genNumberType(),
  GraphicService = Symbol.for("GraphicService"),
  GraphicCreator$1 = Symbol.for("GraphicCreator"),
  SVG_PARSE_ATTRIBUTE_MAP = {
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-width": "lineWidth",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    stroke: "stroke",
    fill: "fill",
  },
  SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);
var GroupUpdateAABBBoundsMode;
!(function (e) {
  (e[(e.LESS_GROUP = 0)] = "LESS_GROUP"),
    (e[(e.MORE_GROUP = 1)] = "MORE_GROUP");
})(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
class Group extends Graphic {
  constructor(e) {
    super(e),
      (this.type = "group"),
      (this.parent = null),
      (this.isContainer = !0),
      (this.numberType = GROUP_NUMBER_TYPE),
      (this._childUpdateTag = UpdateTag.UPDATE_BOUNDS);
  }
  setMode(e) {
    "3d" === e ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  setTheme(e) {
    return (
      this.theme || (this.theme = new Theme()), this.theme.setTheme(e, this)
    );
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  hideAll() {
    this.setAttribute("visible", !1),
      this.forEachChildren((e) => {
        e.isContainer && e.hideAll
          ? e.hideAll()
          : e.setAttribute("visible", !1);
      });
  }
  showAll() {
    this.setAttribute("visible", !0),
      this.forEachChildren((e) => {
        e.isContainer && e.showAll
          ? e.showAll()
          : e.setAttribute("visible", !0);
      });
  }
  containsPoint(e, T, C) {
    if (C === IContainPointMode.GLOBAL) {
      const C = new Point(e, T);
      return (
        this.parent && this.parent.globalTransMatrix.transformPoint(C, C),
        this.AABBBounds.contains(C.x, C.y)
      );
    }
    return this.AABBBounds.contains(e, T);
  }
  shouldUpdateAABBBounds() {
    return (
      !!super.shouldUpdateAABBBounds() ||
      !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS)
    );
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(
      this,
      this.stage,
      !0,
      this._AABBBounds
    );
    const e = this.shouldSelfChangeUpdateAABBBounds(),
      T = this.doUpdateAABBBounds();
    return (
      this.addUpdateLayoutTag(),
      application.graphicService.afterUpdateAABBBounds(
        this,
        this.stage,
        this._AABBBounds,
        this,
        e
      ),
      T
    );
  }
  doUpdateLocalMatrix() {
    const {
      x: e = DefaultTransform.x,
      y: T = DefaultTransform.y,
      dx: C = DefaultTransform.dx,
      dy: $ = DefaultTransform.dy,
      scaleX: F = DefaultTransform.scaleX,
      scaleY: V = DefaultTransform.scaleY,
      angle: Y = DefaultTransform.angle,
      postMatrix: K,
    } = this.attribute;
    if (
      0 !== e ||
      0 !== T ||
      0 !== C ||
      0 !== $ ||
      1 !== F ||
      1 !== V ||
      0 !== Y ||
      K
    )
      return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  doUpdateAABBBounds() {
    const e = this.attribute,
      T = getTheme(this).group;
    this._AABBBounds.clear();
    const C = application.graphicService.updateGroupAABBBounds(
        e,
        T,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = T.boundsPadding } = e,
      F = parsePadding($);
    return (
      F && C.expand(F),
      this.parent && this.parent.addChildUpdateBoundTag(),
      this.clearUpdateBoundTag(),
      this._emitCustomEvent("AAABBBoundsChange"),
      C
    );
  }
  clearUpdateBoundTag() {
    (this._updateTag &= UpdateTag.CLEAR_BOUNDS),
      (this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS);
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  addUpdateBoundTag() {
    (this._updateTag |= UpdateTag.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS ||
      ((this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS),
      this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(e) {
    const T = super.appendChild(e);
    return (
      this.stage && T && ((T.stage = this.stage), (T.layer = this.layer)),
      this.addUpdateBoundTag(),
      application.graphicService.onAddIncremental(e, this, this.stage),
      T
    );
  }
  incrementalClearChild() {
    super.removeAllChild(),
      this.addUpdateBoundTag(),
      application.graphicService.onClearIncremental(this, this.stage);
  }
  appendChild(e, T = !0) {
    const C = super.appendChild(e);
    return (
      T && this.stage && C && C.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      C
    );
  }
  insertBefore(e, T) {
    const C = super.insertBefore(e, T);
    return (
      this.stage && C && C.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      C
    );
  }
  insertAfter(e, T) {
    const C = super.insertAfter(e, T);
    return (
      this.stage && C && C.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      C
    );
  }
  insertInto(e, T) {
    const C = super.insertInto(e, T);
    return (
      this.stage && C && C.setStage(this.stage, this.layer),
      this.addUpdateBoundTag(),
      C
    );
  }
  removeChild(e) {
    const T = super.removeChild(e);
    return (
      (e.stage = null),
      application.graphicService.onRemove(e),
      this.addUpdateBoundTag(),
      T
    );
  }
  removeAllChild(e = !1) {
    this.forEachChildren((T) => {
      application.graphicService.onRemove(T),
        e && T.isContainer && T.removeAllChild(e);
    }),
      super.removeAllChild(),
      this.addUpdateBoundTag();
  }
  setStage(e, T) {
    this.stage !== e &&
      ((this.stage = e),
      (this.layer = T),
      this.setStageToShadowRoot(e, T),
      this._onSetStage && this._onSetStage(this, e, T),
      application.graphicService.onSetStage(this, e),
      this.forEachChildren((T) => {
        T.setStage(e, this.layer);
      }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(),
      this.forEachChildren((e) => {
        e.isContainer && e.addUpdateGlobalPositionTag();
      });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(),
      this.forEachChildren((e) => {
        e.isContainer && e.addUpdateGlobalPositionTag();
      });
  }
  tryUpdateGlobalTransMatrix(e = !0) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const e = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(e.a, e.b, e.c, e.d, e.e, e.f);
        }
      } else
        this._globalTransMatrix = this.parent
          ? this.parent.globalTransMatrix.clone()
          : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), e && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(e, T) {
    return this.find((T) => T.name === e, T);
  }
  createOrUpdateChild(e, T, C) {
    let $ = this._getChildByName(e);
    return (
      $
        ? $.setAttributes(T)
        : (($ = application.graphicService.creator[C](T)),
          ($.name = e),
          this.add($)),
      $
    );
  }
  clone() {
    return new Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Group.NOWORK_ANIMATE_ATTR;
  }
}
function createGroup(e) {
  return new Group(e);
}
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class Layer extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(e, T, C, $) {
    var F;
    super({}),
      (this.stage = e),
      (this.global = T),
      (this.window = C),
      (this.main = $.main),
      (this.layerHandler = $.layerHandler),
      this.layerHandler.init(this, C, {
        main: $.main,
        canvasId: $.canvasId,
        width: this.viewWidth,
        height: this.viewHeight,
        zIndex: null !== (F = $.zIndex) && void 0 !== F ? F : 0,
      }),
      (this.layer = this),
      (this.subLayers = new Map()),
      (this.theme = new Theme()),
      (this.background = "rgba(0, 0, 0, 0)"),
      (this.afterDrawCbs = []);
  }
  combineSubLayer(e = !0) {
    const T = Array.from(this.subLayers.values()).sort(
      (e, T) => e.zIndex - T.zIndex
    );
    this.layerHandler.merge(
      T.map(
        (T) => (
          T.layer.subLayers.size && T.layer.combineSubLayer(e),
          T.layer.getNativeHandler()
        )
      )
    ),
      e &&
        T.forEach((e) => {
          e.group && (e.group.incremental = 0);
        }),
      T.forEach((e) => {
        application.layerService.releaseLayer(this.stage, e.layer);
      }),
      this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(e, T) {
    super.setStage(e, this);
  }
  pick(e, T) {
    throw new Error("");
  }
  tryRenderSecondaryLayer(e, T) {
    this.layerHandler.secondaryHandlers &&
      this.layerHandler.secondaryHandlers.length &&
      this.layerHandler.secondaryHandlers.forEach((C) => {
        (C.layer.renderCount = this.renderCount), C.layer.render(e, T);
      });
  }
  render(e, T) {
    var C;
    this.layerHandler.render(
      [this],
      {
        renderService: e.renderService,
        stage: this.stage,
        layer: this,
        viewBox: e.viewBox,
        transMatrix: e.transMatrix,
        background:
          null !== (C = e.background) && void 0 !== C ? C : this.background,
        updateBounds: e.updateBounds,
      },
      T
    ),
      this.afterDrawCbs.forEach((e) => e(this)),
      this.tryRenderSecondaryLayer(e, T);
  }
  resize(e, T) {
    this.layerHandler.resize(e, T);
  }
  resizeView(e, T) {
    this.layerHandler.resizeView(e, T);
  }
  setDpr(e) {
    this.layerHandler.setDpr(e);
  }
  afterDraw(e) {
    this.afterDrawCbs.push(e);
  }
  startAnimate(e) {
    throw new Error("");
  }
  setToFrame(e) {
    throw new Error("");
  }
  prepare(e, T) {}
  release() {
    super.release(),
      this.layerHandler.release(),
      this.subLayers &&
        this.subLayers.forEach((e) => {
          application.layerService.releaseLayer(this.stage, e.layer);
        });
  }
  drawTo(e, T) {
    var C;
    this.layerHandler.drawTo(
      e,
      [this],
      Object.assign(
        {
          background:
            null !== (C = T.background) && void 0 !== C ? C : this.background,
          renderService: T.renderService,
          viewBox: T.viewBox,
          transMatrix: T.transMatrix,
          stage: this.stage,
          layer: this,
        },
        T
      )
    ),
      this.afterDrawCbs.forEach((e) => e(this));
  }
}
const TransformUtil = Symbol.for("TransformUtil"),
  GraphicUtil = Symbol.for("GraphicUtil"),
  LayerService = Symbol.for("LayerService"),
  StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution"),
  DynamicLayerHandlerContribution = Symbol.for(
    "DynamicLayerHandlerContribution"
  ),
  VirtualLayerHandlerContribution = Symbol.for(
    "VirtualLayerHandlerContribution"
  );
var DefaultLayerService_1,
  __decorate$17 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$T =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let DefaultLayerService = (DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${
      DefaultLayerService_1.idprefix
    }_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    (this.layerMap = new Map()), (this.global = application.global);
  }
  tryInit() {
    this.inited ||
      ((this.staticLayerCountInEnv = this.global.getStaticCanvasCount()),
      (this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount()),
      (this.inited = !0));
  }
  getStageLayer(e) {
    return this.layerMap.get(e);
  }
  getRecommendedLayerType(e) {
    return (
      e ||
      (0 !== this.staticLayerCountInEnv
        ? "static"
        : 0 !== this.dynamicLayerCountInEnv
        ? "dynamic"
        : "virtual")
    );
  }
  getLayerHandler(e) {
    let T;
    return (
      (T =
        "static" === e
          ? container.get(StaticLayerHandlerContribution)
          : "dynamic" === e
          ? container.get(DynamicLayerHandlerContribution)
          : container.get(VirtualLayerHandlerContribution)),
      T
    );
  }
  createLayer(
    e,
    T = {
      main: !1,
    }
  ) {
    var C;
    this.tryInit();
    let $ = this.getRecommendedLayerType(T.layerMode);
    $ = T.main || T.canvasId ? "static" : $;
    const F = this.getLayerHandler($),
      V = new Layer(
        e,
        this.global,
        e.window,
        Object.assign(
          Object.assign(
            {
              main: !1,
            },
            T
          ),
          {
            layerMode: $,
            canvasId:
              null !== (C = T.canvasId) && void 0 !== C
                ? C
                : DefaultLayerService_1.GenerateLayerId(),
            layerHandler: F,
          }
        )
      ),
      Y = this.layerMap.get(e) || [];
    return Y.push(V), this.layerMap.set(e, Y), this.staticLayerCountInEnv--, V;
  }
  prepareStageLayer(e) {
    let T;
    e.forEachChildren((e) => {
      const C = e.getNativeHandler();
      "virtual" === C.type
        ? ((C.mainHandler = T), T.secondaryHandlers.push(C))
        : ((T = C), (T.secondaryHandlers = []));
    });
  }
  releaseLayer(e, T) {
    T.release();
    const C = this.layerMap.get(e) || [];
    this.layerMap.set(
      e,
      C.filter((e) => e !== T)
    );
  }
  layerCount(e) {
    return (this.layerMap.get(e) || []).length;
  }
  restLayerCount(e) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(e) {
    this.layerMap.delete(e);
  }
});
(DefaultLayerService.idprefix = "visactor_layer"),
  (DefaultLayerService.prefix_count = 0),
  (DefaultLayerService = DefaultLayerService_1 =
    __decorate$17(
      [injectable(), __metadata$T("design:paramtypes", [])],
      DefaultLayerService
    ));
const coreModule = new ContainerModule((e) => {
  e(VGlobal).to(DefaultGlobal).inSingletonScope(),
    e(VWindow).to(DefaultWindow),
    e(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(),
    e(TransformUtil).to(DefaultTransformUtil).inSingletonScope(),
    e(LayerService).to(DefaultLayerService).inSingletonScope();
});
function runFill(e, T) {
  return !(!e && !T);
}
function runStroke(e, T) {
  let C;
  return (
    (C = isArray$1(e) ? e.some((e) => e || void 0 === e) : !!e), C && T > 0
  );
}
function fillVisible(e, T, C) {
  return C && e * T > 0;
}
function rectFillVisible(e, T, C, $, F) {
  return F && e * T > 0 && 0 !== C && 0 !== $;
}
function strokeVisible(e, T) {
  return e * T > 0;
}
function rectStrokeVisible(e, T, C, $) {
  return e * T > 0 && 0 !== C && 0 !== $;
}
function drawPathProxy(e, T, C, $, F, V, Y, K) {
  if (!e.pathProxy) return !1;
  const J = getTheme(e, null == V ? void 0 : V.theme)[e.type.replace("3d", "")],
    {
      fill: ee = J.fill,
      stroke: te = J.stroke,
      opacity: ie = J.opacity,
      fillOpacity: ne = J.fillOpacity,
      lineWidth: re = J.lineWidth,
      strokeOpacity: ae = J.strokeOpacity,
      visible: oe = J.visible,
      x: se = J.x,
      y: le = J.y,
    } = e.attribute,
    de = fillVisible(ie, ne, ee),
    ce = strokeVisible(ie, ae),
    ue = runFill(ee),
    he = runStroke(te, re);
  if (!oe) return !0;
  if (!ue && !he) return !0;
  if (!(de || ce || Y || K)) return !0;
  T.beginPath();
  return (
    renderCommandList(
      ("function" == typeof e.pathProxy
        ? e.pathProxy(e.attribute)
        : e.pathProxy
      ).commandList,
      T,
      C,
      $
    ),
    T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
    he &&
      (K
        ? K(T, e.attribute, J)
        : ce &&
          (T.setStrokeStyle(e, e.attribute, C - se, $ - le, J), T.stroke())),
    ue &&
      (Y
        ? Y(T, e.attribute, J)
        : de &&
          (T.setCommonStyle(e, e.attribute, C - se, $ - le, J), T.fill())),
    !0
  );
}
function intersect(e, T, C, $, F, V, Y, K) {
  const J = C - e,
    ee = $ - T,
    te = Y - F,
    ie = K - V;
  let ne = ie * J - te * ee;
  return ne * ne < epsilon
    ? []
    : ((ne = (te * (T - V) - ie * (e - F)) / ne), [e + ne * J, T + ne * ee]);
}
function cornerTangents(e, T, C, $, F, V, Y) {
  const K = e - C,
    J = T - $,
    ee = (Y ? V : -V) / Math.sqrt(K * K + J * J),
    te = ee * J,
    ie = -ee * K,
    ne = e + te,
    re = T + ie,
    ae = C + te,
    oe = $ + ie,
    se = (ne + ae) / 2,
    le = (re + oe) / 2,
    de = ae - ne,
    ce = oe - re,
    ue = de * de + ce * ce,
    he = F - V,
    pe = ne * oe - ae * re,
    ge = (ce < 0 ? -1 : 1) * Math.sqrt(Math.max(0, he * he * ue - pe * pe));
  let fe = (pe * ce - de * ge) / ue,
    me = (-pe * de - ce * ge) / ue;
  const ye = (pe * ce + de * ge) / ue,
    be = (-pe * de + ce * ge) / ue,
    ve = fe - se,
    Te = me - le,
    _e = ye - se,
    Ce = be - le;
  return (
    ve * ve + Te * Te > _e * _e + Ce * Ce && ((fe = ye), (me = be)),
    {
      cx: fe,
      cy: me,
      x01: -te,
      y01: -ie,
      x11: fe * (F / he - 1),
      y11: me * (F / he - 1),
    }
  );
}
function drawArcPath$1(e, T, C, $, F, V, Y) {
  const { startAngle: K, endAngle: J } = e.getParsedAngle(),
    ee = abs(J - K),
    te = J > K;
  let ie = !1;
  if (F < V) {
    const e = F;
    (F = V), (V = e);
  }
  if (F <= epsilon) T.moveTo(C, $);
  else if (ee >= pi2 - epsilon)
    T.moveTo(C + F * cos(K), $ + F * sin(K)),
      T.arc(C, $, F, K, J, !te),
      V > epsilon &&
        (T.moveTo(C + V * cos(J), $ + V * sin(J)), T.arc(C, $, V, J, K, te));
  else {
    const ne = e.getParsedCornerRadius(),
      re = isArray$1(ne),
      {
        outerDeltaAngle: ae,
        innerDeltaAngle: oe,
        outerStartAngle: se,
        outerEndAngle: le,
        innerEndAngle: de,
        innerStartAngle: ce,
      } = e.getParsePadAngle(K, J),
      ue = re ? ne[0] : ne,
      he = re ? ne[1] : ne,
      pe = re ? ne[2] : ne,
      ge = re ? ne[3] : ne,
      fe = Math.max(he, ue),
      me = Math.max(pe, ge);
    let ye = fe,
      be = me;
    const ve = F * cos(se),
      Te = F * sin(se),
      _e = V * cos(de),
      Ce = V * sin(de);
    let Ae, xe, Se, Re;
    if (
      (me > epsilon || fe > epsilon) &&
      ((Ae = F * cos(le)),
      (xe = F * sin(le)),
      (Se = V * cos(ce)),
      (Re = V * sin(ce)),
      ee < pi)
    ) {
      const e = intersect(ve, Te, Se, Re, Ae, xe, _e, Ce);
      if (e) {
        const T = ve - e[0],
          C = Te - e[1],
          $ = Ae - e[0],
          Y = xe - e[1],
          K =
            1 /
            sin(
              acos(
                (T * $ + C * Y) / (sqrt(T * T + C * C) * sqrt($ * $ + Y * Y))
              ) / 2
            ),
          J = sqrt(e[0] * e[0] + e[1] * e[1]);
        (be = min(me, (V - J) / (K - 1))), (ye = min(fe, (F - J) / (K + 1)));
      }
    }
    if (ae < 0.001) Y && (Y[3] || Y[1]) && T.moveTo(C + ve, $ + Te), (ie = !0);
    else if (ye > epsilon) {
      const e = min(ue, ye),
        V = min(he, ye),
        K = cornerTangents(Se, Re, ve, Te, F, e, Number(te)),
        J = cornerTangents(Ae, xe, _e, Ce, F, V, Number(te));
      ye < fe && e === V
        ? !Y || Y[0]
          ? (T.moveTo(C + K.cx + K.x01, $ + K.cy + K.y01),
            T.arc(
              C + K.cx,
              $ + K.cy,
              ye,
              atan2(K.y01, K.x01),
              atan2(J.y01, J.x01),
              !te
            ))
          : T.moveTo(
              C + K.cx + ye * cos(atan2(J.y01, J.x01)),
              $ + K.cy + ye * sin(atan2(J.y01, J.x01))
            )
        : !Y || Y[0]
        ? (T.moveTo(C + K.cx + K.x01, $ + K.cy + K.y01),
          e > 0 &&
            T.arc(
              C + K.cx,
              $ + K.cy,
              e,
              atan2(K.y01, K.x01),
              atan2(K.y11, K.x11),
              !te
            ),
          T.arc(
            C,
            $,
            F,
            atan2(K.cy + K.y11, K.cx + K.x11),
            atan2(J.cy + J.y11, J.cx + J.x11),
            !te
          ),
          V > 0 &&
            T.arc(
              C + J.cx,
              $ + J.cy,
              V,
              atan2(J.y11, J.x11),
              atan2(J.y01, J.x01),
              !te
            ))
        : V > 0
        ? T.moveTo(
            C + J.cx + V * cos(atan2(J.y01, J.x01)),
            $ + J.cy + V * sin(atan2(J.y01, J.x01))
          )
        : T.moveTo(C + Ae, $ + F * sin(le));
    } else
      !Y || Y[0]
        ? (T.moveTo(C + ve, $ + Te), T.arc(C, $, F, se, le, !te))
        : T.moveTo(C + F * cos(le), $ + F * sin(le));
    if (!(V > epsilon) || oe < 0.001)
      !Y || Y[1] ? T.lineTo(C + _e, $ + Ce) : T.moveTo(C + _e, $ + Ce),
        (ie = !0);
    else if (be > epsilon) {
      const e = min(ge, be),
        F = min(pe, be),
        K = cornerTangents(_e, Ce, Ae, xe, V, -F, Number(te)),
        J = cornerTangents(ve, Te, Se, Re, V, -e, Number(te));
      if (
        (!Y || Y[1]
          ? T.lineTo(C + K.cx + K.x01, $ + K.cy + K.y01)
          : T.moveTo(C + K.cx + K.x01, $ + K.cy + K.y01),
        be < me && e === F)
      ) {
        const e = atan2(J.y01, J.x01);
        !Y || Y[2]
          ? T.arc(C + K.cx, $ + K.cy, be, atan2(K.y01, K.x01), e, !te)
          : T.moveTo(C + K.cx + cos(e), $ + K.cy + sin(e));
      } else
        !Y || Y[2]
          ? (F > 0 &&
              T.arc(
                C + K.cx,
                $ + K.cy,
                F,
                atan2(K.y01, K.x01),
                atan2(K.y11, K.x11),
                !te
              ),
            T.arc(
              C,
              $,
              V,
              atan2(K.cy + K.y11, K.cx + K.x11),
              atan2(J.cy + J.y11, J.cx + J.x11),
              te
            ),
            e > 0 &&
              T.arc(
                C + J.cx,
                $ + J.cy,
                e,
                atan2(J.y11, J.x11),
                atan2(J.y01, J.x01),
                !te
              ))
          : e > 0
          ? T.moveTo(
              C + J.cx + e * cos(atan2(J.y01, J.x01)),
              $ + J.cy + e * sin(atan2(J.y01, J.x01))
            )
          : T.moveTo(C + Se, $ + Re);
    } else
      !Y || Y[1] ? T.lineTo(C + _e, $ + Ce) : T.moveTo(C + _e, $ + Ce),
        !Y || Y[2]
          ? T.arc(C, $, V, de, ce, te)
          : T.moveTo(C + V * cos(ce), $ + V * sin(ce));
  }
  return (
    Y ? Y[3] && T.lineTo(C + F * cos(K), $ + F * sin(K)) : T.closePath(), ie
  );
}
class ConicalCanvas {
  static GetCanvas() {
    try {
      return (
        ConicalCanvas.canvas ||
          (ConicalCanvas.canvas = application.global.createCanvas({})),
        ConicalCanvas.canvas
      );
    } catch (e) {
      return null;
    }
  }
  static GetCtx() {
    if (!ConicalCanvas.ctx) {
      const e = ConicalCanvas.GetCanvas();
      ConicalCanvas.ctx = e.getContext("2d");
    }
    return ConicalCanvas.ctx;
  }
}
class ColorInterpolate extends LRU {
  static getInstance() {
    return (
      ColorInterpolate._instance ||
        (ColorInterpolate._instance = new ColorInterpolate()),
      ColorInterpolate._instance
    );
  }
  constructor(e = [], T = 100) {
    super(),
      (this.cacheParams = {
        CLEAN_THRESHOLD: 100,
        L_TIME: 1e3,
      }),
      (this.dataMap = new Map());
    const C = ConicalCanvas.GetCanvas(),
      $ = ConicalCanvas.GetCtx();
    if (((C.width = T), (C.height = 1), !$)) return;
    if (($.translate(0, 0), !$)) throw new Error("ctx");
    const F = $.createLinearGradient(0, 0, T, 0);
    e.forEach((e) => {
      F.addColorStop(e[0], e[1]);
    }),
      ($.fillStyle = F),
      $.fillRect(0, 0, T, 1),
      (this.rgbaSet = $.getImageData(0, 0, T, 1).data);
  }
  getColor(e) {
    const T = this.rgbaSet.slice(4 * e, 4 * e + 4);
    return `rgba(${T[0]}, ${T[1]}, ${T[2]}, ${T[3] / 255})`;
  }
  GetOrCreate(e, T, C, $, F = [], V = 100) {
    let Y = `${e}${T}${C}${$}`;
    F.forEach((e) => (Y += e.join())), (Y += V);
    let K = this.dataMap.get(Y);
    return (
      K ||
        ((K = {
          data: new ColorInterpolate(F, V),
          timestamp: [],
        }),
        this.addLimitedTimestamp(K, Date.now(), {}),
        this.dataMap.set(Y, K)),
      this.clearCache(this.dataMap, this.cacheParams),
      K.data
    );
  }
}
class ConicalPatternStore {
  static GetSize(e) {
    for (let T = 0; T < ConicalPatternStore.ImageSize.length; T++)
      if (ConicalPatternStore.ImageSize[T] >= e)
        return ConicalPatternStore.ImageSize[T];
    return e;
  }
  static Get(e, T, C, $, F, V, Y) {
    const K = ConicalPatternStore.GenKey(e, T, C, $, F),
      J = ConicalPatternStore.cache[K];
    if (!J || 0 === J.length) return null;
    for (let ee = 0; ee < J.length; ee++)
      if (J[ee].width >= V && J[ee].height >= Y) return J[ee].pattern;
    return null;
  }
  static Set(e, T, C, $, F, V, Y, K) {
    const J = ConicalPatternStore.GenKey(e, T, C, $, F);
    ConicalPatternStore.cache[J]
      ? ConicalPatternStore.cache[J].push({
          width: Y,
          height: K,
          pattern: V,
        })
      : (ConicalPatternStore.cache[J] = [
          {
            width: Y,
            height: K,
            pattern: V,
          },
        ]);
  }
  static GenKey(e, T, C, $, F) {
    return `${T},${C},${$},${F},${e.join()}`;
  }
}
function getConicGradientAt(e, T, C, $) {
  const { stops: F, startAngle: V, endAngle: Y } = $;
  for (; C < 0; ) C += pi2;
  for (; C > pi2; ) C -= pi2;
  if (C < V) return F[0].color;
  if (C > Y) return F[0].color;
  let K,
    J,
    ee = (C - V) / (Y - V);
  for (let te = 0; te < F.length; te++)
    if (F[te].offset >= ee) {
      (K = F[te - 1]), (J = F[te]);
      break;
    }
  return (
    (ee = (ee - K.offset) / (J.offset - K.offset)),
    interpolateColor(K.color, J.color, ee, !1)
  );
}
function createConicalGradient(e, T, C, $, F, V, Y, K, J) {
  const ee = Math.floor((180 * F) / Math.PI),
    te = ConicalCanvas.GetCanvas(),
    ie = ConicalCanvas.GetCtx();
  if (!ie) return null;
  const ne = ConicalPatternStore.GetSize(K),
    re = ConicalPatternStore.GetSize(J);
  let ae = ConicalPatternStore.Get(T, C, $, V, Y, ne, re);
  if (ae) return ae;
  const oe = Math.sqrt(
      Math.max(
        Math.max(
          Math.pow(C, 2) + Math.pow($, 2),
          Math.pow(ne - C, 2) + Math.pow($, 2)
        ),
        Math.max(
          Math.pow(ne - C, 2) + Math.pow(re - $, 2),
          Math.pow(C, 2) + Math.pow(re - $, 2)
        )
      )
    ),
    se = ee + 1,
    le = F / Math.max(1, se - 1),
    de = ColorInterpolate.getInstance().GetOrCreate(C, $, ne, re, T, se),
    ce = (2 * Math.PI * oe) / 360;
  (te.width = ne),
    (te.height = re),
    ie.setTransform(1, 0, 0, 1, 0, 0),
    ie.clearRect(0, 0, ne, re),
    ie.translate(C, $),
    ie.rotate(V);
  for (let he = 0, pe = se - 1; he < pe && !(V + he * le > Y); he++) {
    const e = de.getColor(he);
    ie.beginPath(),
      ie.rotate(le),
      ie.moveTo(0, 0),
      ie.lineTo(oe, -2 * ce),
      ie.lineTo(oe, 0),
      (ie.fillStyle = e),
      ie.closePath(),
      ie.fill();
  }
  const ue = ie.getImageData(0, 0, ne, re);
  return (
    (te.width = ue.width),
    (te.height = ue.height),
    ie.putImageData(ue, 0, 0),
    (ae = e.createPattern(te, "no-repeat")),
    ae && ConicalPatternStore.Set(T, C, $, V, Y, ae, ne, re),
    ae
  );
}
(ConicalPatternStore.cache = {}),
  (ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560]);
const ArcRenderContribution = Symbol.for("ArcRenderContribution"),
  AreaRenderContribution = Symbol.for("AreaRenderContribution"),
  CircleRenderContribution = Symbol.for("CircleRenderContribution"),
  GroupRenderContribution = Symbol.for("GroupRenderContribution"),
  ImageRenderContribution = Symbol.for("ImageRenderContribution"),
  PathRenderContribution = Symbol.for("PathRenderContribution"),
  PolygonRenderContribution = Symbol.for("PolygonRenderContribution"),
  RectRenderContribution = Symbol.for("RectRenderContribution"),
  SymbolRenderContribution = Symbol.for("SymbolRenderContribution"),
  TextRenderContribution = Symbol.for("TextRenderContribution"),
  InteractiveSubRenderContribution = Symbol.for(
    "InteractiveSubRenderContribution"
  ),
  CIRCLE_UPDATE_TAG_KEY = [
    "radius",
    "startAngle",
    "endAngle",
    ...GRAPHIC_UPDATE_TAG_KEY,
  ];
class Circle extends Graphic {
  constructor(
    e = {
      radius: 1,
    }
  ) {
    super(e), (this.type = "circle"), (this.numberType = CIRCLE_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle: e, endAngle: T, radius: C } = this.attribute;
    return this._validNumber(e) && this._validNumber(T) && this._validNumber(C);
  }
  doUpdateAABBBounds(e) {
    const T = getTheme(this).circle;
    this._AABBBounds.clear();
    const C = this.attribute,
      $ = application.graphicService.updateCircleAABBBounds(
        C,
        getTheme(this).circle,
        this._AABBBounds,
        e,
        this
      ),
      { boundsPadding: F = T.boundsPadding } = C,
      V = parsePadding(F);
    return V && $.expand(V), this.clearUpdateBoundTag(), $;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).circle[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var e, T, C;
    const $ = this.attribute,
      F =
        null !== (e = $.radius) && void 0 !== e
          ? e
          : this.getDefaultAttribute("radius"),
      V =
        null !== (T = $.startAngle) && void 0 !== T
          ? T
          : this.getDefaultAttribute("startAngle"),
      Y =
        null !== (C = $.endAngle) && void 0 !== C
          ? C
          : this.getDefaultAttribute("endAngle"),
      K = new CustomPath2D();
    return K.arc(0, 0, F, V, Y), K;
  }
  clone() {
    return new Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Circle.NOWORK_ANIMATE_ATTR;
  }
}
function createCircle(e) {
  return new Circle(e);
}
function getContextFont(e, T = {}, C) {
  C || (C = 1);
  const {
    fontStyle: $ = T.fontStyle,
    fontVariant: F = T.fontVariant,
    fontWeight: V = T.fontWeight,
    fontSize: Y = T.fontSize,
    fontFamily: K = T.fontFamily,
  } = e;
  return (
    ($ ? $ + " " : "") +
    (F ? F + " " : "") +
    (V ? V + " " : "") +
    Y * C +
    "px " +
    (K || "sans-serif")
  );
}
function textDrawOffsetY(e, T) {
  return "top" === e
    ? Math.ceil(0.79 * T)
    : "middle" === e
    ? Math.round(0.3 * T)
    : "bottom" === e
    ? Math.round(-0.21 * T)
    : 0;
}
function textDrawOffsetX(e, T) {
  return "end" === e || "right" === e ? -T : "center" === e ? -T / 2 : 0;
}
function textLayoutOffsetY(e, T, C, $ = 0) {
  return "middle" === e
    ? -T / 2
    : "top" === e
    ? 0
    : "bottom" === e
    ? $ - T
    : e && "alphabetic" !== e
    ? 0
    : (C || (C = T), -(T - C) / 2 - 0.79 * C);
}
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class CanvasTextLayout {
  constructor(e, T, C) {
    (this.fontFamily = e), (this.textOptions = T), (this.textMeasure = C);
  }
  LayoutBBox(e, T, C) {
    if ("left" === T || "start" === T) e.xOffset = 0;
    else if ("center" === T) e.xOffset = e.width / -2;
    else {
      if ("right" !== T && "end" !== T) throw new Error("textAlign");
      e.xOffset = -e.width;
    }
    return (
      (e.yOffset =
        "top" === C
          ? 0
          : "middle" === C
          ? e.height / -2
          : "alphabetic" === C
          ? -0.79 * e.height
          : -e.height),
      e
    );
  }
  GetLayout(e, T, C, $, F, V, Y, K, J) {
    const ee = [],
      te = [T, C],
      ie = [0, 0];
    for (; e.length > 0; ) {
      const { str: C } = this.textMeasure.clipTextWithSuffix(
        e,
        this.textOptions,
        T,
        Y,
        K,
        J
      );
      ee.push({
        str: C,
        width: this.textMeasure.measureTextWidth(C, this.textOptions),
      }),
        (e = e.substring(C.length));
    }
    "left" === $ ||
      "start" === $ ||
      ("center" === $
        ? (ie[0] = te[0] / -2)
        : ("right" !== $ && "end" !== $) || (ie[0] = -te[0])),
      "top" === F ||
        ("middle" === F
          ? (ie[1] = te[1] / -2)
          : "bottom" === F && (ie[1] = -te[1]));
    const ne = {
      xOffset: ie[0],
      yOffset: ie[1],
      width: te[0],
      height: te[1],
    };
    return this.layoutWithBBox(ne, ee, $, F, V);
  }
  GetLayoutByLines(e, T, C, $, F = "", V, Y, K = "end") {
    e = e.map((e) => e.toString());
    const J = [],
      ee = [0, 0];
    if ("number" == typeof Y && Y !== 1 / 0) {
      let T;
      for (let C = 0, $ = e.length; C < $; C++)
        (T = Math.min(
          this.textMeasure.measureTextWidth(e[C], this.textOptions),
          Y
        )),
          J.push({
            str: this.textMeasure.clipTextWithSuffix(
              e[C],
              this.textOptions,
              T,
              F,
              V,
              K
            ).str,
            width: T,
          });
      ee[0] = Y;
    } else {
      let T, C;
      Y = 0;
      for (let $ = 0, F = e.length; $ < F; $++)
        (C = e[$]),
          (T = this.textMeasure.measureTextWidth(C, this.textOptions)),
          (Y = Math.max(Y, T)),
          J.push({
            str: C,
            width: T,
          });
      ee[0] = Y;
    }
    (ee[1] = J.length * $),
      (ee[0] = J.reduce((e, T) => Math.max(e, T.width), 0));
    const te = {
      xOffset: 0,
      yOffset: 0,
      width: ee[0],
      height: ee[1],
    };
    return this.LayoutBBox(te, T, C), this.layoutWithBBox(te, J, T, C, $);
  }
  layoutWithBBox(e, T, C, $, F) {
    const V = [0, 0],
      Y = T.length * F;
    "top" === $ ||
      ("middle" === $
        ? (V[1] = (e.height - Y) / 2)
        : "bottom" === $ && (V[1] = e.height - Y));
    for (let K = 0; K < T.length; K++) this.lineOffset(e, T[K], C, $, F, V);
    return {
      bbox: e,
      lines: T,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight: F,
      textAlign: C,
      textBaseline: $,
    };
  }
  lineOffset(e, T, C, $, F, V) {
    return (
      "left" === C || "start" === C
        ? (T.leftOffset = 0)
        : "center" === C
        ? (T.leftOffset = (e.width - T.width) / 2)
        : ("right" !== C && "end" !== C) || (T.leftOffset = e.width - T.width),
      (T.topOffset =
        (F - this.textOptions.fontSize) / 2 +
        0.79 * this.textOptions.fontSize +
        V[1]),
      (V[1] += F),
      T
    );
  }
}
const TEXT_UPDATE_TAG_KEY = [
  "text",
  "maxLineWidth",
  "textAlign",
  "textBaseline",
  "heightLimit",
  "lineClamp",
  "fontSize",
  "fontFamily",
  "fontWeight",
  "ellipsis",
  "lineHeight",
  "direction",
  "wordBreak",
  "heightLimit",
  "lineClamp",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Text extends Graphic {
  get font() {
    const e = getTheme(this).text;
    return (
      this._font || (this._font = getContextFont(this.attribute, e)), this._font
    );
  }
  get clipedText() {
    var e;
    const T = this.attribute,
      C = getTheme(this).text;
    if (!this.isSimplify()) return;
    const { maxLineWidth: $ = C.maxLineWidth } = T;
    return Number.isFinite($)
      ? (this.tryUpdateAABBBounds(), this.cache.clipedText)
      : (null !== (e = T.text) && void 0 !== e ? e : C.text).toString();
  }
  get clipedWidth() {
    if (this.isSimplify())
      return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    const e = getTheme(this).text,
      T = this.attribute;
    if (this.isMultiLine) return;
    const { maxLineWidth: C = e.maxLineWidth } = T;
    return (
      !!Number.isFinite(C) &&
      (this.tryUpdateAABBBounds(),
      "vertical" === T.direction &&
      this.cache.verticalList &&
      this.cache.verticalList[0]
        ? this.cache.verticalList[0].map((e) => e.text).join("") !==
          T.text.toString()
        : null != this.clipedText && this.clipedText !== T.text.toString())
    );
  }
  get multilineLayout() {
    if (this.isMultiLine)
      return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  isSimplify() {
    return !this.isMultiLine && "vertical" !== this.attribute.direction;
  }
  get isMultiLine() {
    return (
      Array.isArray(this.attribute.text) ||
      "normal" === this.attribute.whiteSpace
    );
  }
  constructor(
    e = {
      text: "",
      fontSize: 16,
    }
  ) {
    super(e),
      (this.type = "text"),
      (this.numberType = TEXT_NUMBER_TYPE),
      (this.cache = {});
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: e } = this.attribute;
    return isArray$1(e)
      ? !e.every((e) => null == e || "" === e)
      : null != e && "" !== e;
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).text;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateTextAABBBounds(
        T,
        e,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = this.attribute,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  updateWrapAABBBounds(e) {
    var T, C, $, F;
    const V = getTheme(this).text,
      {
        fontFamily: Y = V.fontFamily,
        textAlign: K = V.textAlign,
        textBaseline: J = V.textBaseline,
        fontSize: ee = V.fontSize,
        ellipsis: te = V.ellipsis,
        maxLineWidth: ie,
        stroke: ne = V.stroke,
        lineWidth: re = V.lineWidth,
        wordBreak: ae = V.wordBreak,
        fontWeight: oe = V.fontWeight,
        ignoreBuf: se = V.ignoreBuf,
        suffixPosition: le = V.suffixPosition,
        heightLimit: de = 0,
        lineClamp: ce,
      } = this.attribute,
      ue =
        null !==
          (T = calculateLineHeight(
            this.attribute.lineHeight,
            this.attribute.fontSize || V.fontSize
          )) && void 0 !== T
          ? T
          : this.attribute.fontSize || V.fontSize,
      he = se ? 0 : 2;
    if (
      !this.shouldUpdateShape() &&
      (null === (C = this.cache) || void 0 === C ? void 0 : C.layoutData)
    ) {
      const e = this.cache.layoutData.bbox;
      return (
        this._AABBBounds.set(
          e.xOffset,
          e.yOffset,
          e.xOffset + e.width,
          e.yOffset + e.height
        ),
        ne && this._AABBBounds.expand(re / 2),
        this._AABBBounds
      );
    }
    const pe = application.graphicUtil.textMeasure,
      ge = new CanvasTextLayout(
        Y,
        {
          fontSize: ee,
          fontWeight: oe,
          fontFamily: Y,
        },
        pe
      ),
      fe = isArray$1(e) ? e.map((e) => e.toString()) : [e.toString()],
      me = [],
      ye = [0, 0];
    let be = 1 / 0;
    if (
      (de > 0 && (be = Math.max(Math.floor(de / ue), 1)),
      ce && (be = Math.min(be, ce)),
      "number" == typeof ie && ie !== 1 / 0)
    ) {
      if (ie > 0)
        for (let T = 0; T < fe.length; T++) {
          const e = fe[T];
          let C = !0;
          if (T === be - 1) {
            const C = ge.textMeasure.clipTextWithSuffix(
              e,
              ge.textOptions,
              ie,
              te,
              !1,
              le,
              T !== fe.length - 1
            );
            me.push({
              str: C.str,
              width: C.width,
            });
            break;
          }
          const V = ge.textMeasure.clipText(
            e,
            ge.textOptions,
            ie,
            "break-word" === ae
          );
          if ("" !== e && "" === V.str) {
            if (te) {
              const T = ge.textMeasure.clipTextWithSuffix(
                e,
                ge.textOptions,
                ie,
                te,
                !1,
                le
              );
              (V.str = null !== ($ = T.str) && void 0 !== $ ? $ : ""),
                (V.width = null !== (F = T.width) && void 0 !== F ? F : 0);
            } else (V.str = ""), (V.width = 0);
            C = !1;
          }
          if (
            (me.push({
              str: V.str,
              width: V.width,
            }),
            V.str.length === e.length)
          );
          else if (C) {
            const C = e.substring(V.str.length);
            fe.splice(T + 1, 0, C);
          }
        }
      let e = 0;
      me.forEach((T) => {
        e = Math.max(e, T.width);
      }),
        (ye[0] = e);
    } else {
      let e,
        T,
        C = 0;
      for (let $ = 0, F = fe.length; $ < F; $++) {
        if ($ === be - 1) {
          const e = ge.textMeasure.clipTextWithSuffix(
            fe[$],
            ge.textOptions,
            ie,
            te,
            !1,
            le
          );
          me.push({
            str: e.str,
            width: e.width,
          }),
            (C = Math.max(C, e.width));
          break;
        }
        (T = fe[$]),
          (e = ge.textMeasure.measureTextWidth(
            T,
            ge.textOptions,
            "break-word" === ae
          )),
          (C = Math.max(C, e)),
          me.push({
            str: T,
            width: e,
          });
      }
      ye[0] = C;
    }
    ye[1] = me.length * (ue + he);
    const ve = {
      xOffset: 0,
      yOffset: 0,
      width: ye[0],
      height: ye[1],
    };
    ge.LayoutBBox(ve, K, J);
    const Te = ge.layoutWithBBox(ve, me, K, J, ue);
    return (
      (this.cache.layoutData = Te),
      this.clearUpdateShapeTag(),
      this._AABBBounds.set(
        ve.xOffset,
        ve.yOffset,
        ve.xOffset + ve.width,
        ve.yOffset + ve.height
      ),
      ne && this._AABBBounds.expand(re / 2),
      this._AABBBounds
    );
  }
  updateSingallineAABBBounds(e) {
    const T = getTheme(this).text,
      { direction: C = T.direction, underlineOffset: $ = T.underlineOffset } =
        this.attribute,
      F =
        "horizontal" === C
          ? this.updateHorizontalSinglelineAABBBounds(e)
          : this.updateVerticalSinglelineAABBBounds(e);
    return (
      "horizontal" === C &&
        $ &&
        this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + $),
      F
    );
  }
  updateMultilineAABBBounds(e) {
    const T = getTheme(this).text,
      { direction: C = T.direction, underlineOffset: $ = T.underlineOffset } =
        this.attribute,
      F =
        "horizontal" === C
          ? this.updateHorizontalMultilineAABBBounds(e)
          : this.updateVerticalMultilineAABBBounds(e);
    return (
      "horizontal" === C &&
        $ &&
        this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + $),
      F
    );
  }
  updateHorizontalSinglelineAABBBounds(e) {
    var T, C;
    const $ = getTheme(this).text,
      { wrap: F = $.wrap } = this.attribute;
    if (F) return this.updateWrapAABBBounds([e]);
    const V = application.graphicUtil.textMeasure;
    let Y, K;
    const J = this.attribute,
      {
        maxLineWidth: ee = $.maxLineWidth,
        ellipsis: te = $.ellipsis,
        textAlign: ie = $.textAlign,
        textBaseline: ne = $.textBaseline,
        fontFamily: re = $.fontFamily,
        fontSize: ae = $.fontSize,
        fontWeight: oe = $.fontWeight,
        stroke: se = $.stroke,
        lineWidth: le = $.lineWidth,
        ignoreBuf: de = $.ignoreBuf,
        whiteSpace: ce = $.whiteSpace,
        suffixPosition: ue = $.suffixPosition,
      } = J;
    if ("normal" === ce) return this.updateWrapAABBBounds(e);
    const he = de ? 0 : Math.max(2, 0.075 * ae),
      pe = J.fontSize || $.fontSize,
      ge =
        null !== (T = calculateLineHeight(J.lineHeight, pe)) && void 0 !== T
          ? T
          : pe + he;
    if (!this.shouldUpdateShape() && this.cache) {
      Y = null !== (C = this.cache.clipedWidth) && void 0 !== C ? C : 0;
      const e = textDrawOffsetX(ie, Y),
        T = textLayoutOffsetY(ne, ge, ae);
      return (
        this._AABBBounds.set(e, T, e + Y, T + ge),
        se && this._AABBBounds.expand(le / 2),
        this._AABBBounds
      );
    }
    if (Number.isFinite(ee)) {
      if (te) {
        const T = !0 === te ? $.ellipsis : te,
          C = V.clipTextWithSuffix(
            e.toString(),
            {
              fontSize: ae,
              fontWeight: oe,
              fontFamily: re,
            },
            ee,
            T,
            !1,
            ue
          );
        (K = C.str), (Y = C.width);
      } else {
        const T = V.clipText(
          e.toString(),
          {
            fontSize: ae,
            fontWeight: oe,
            fontFamily: re,
          },
          ee,
          !1
        );
        (K = T.str), (Y = T.width);
      }
      (this.cache.clipedText = K), (this.cache.clipedWidth = Y);
    } else
      (Y = V.measureTextWidth(e.toString(), {
        fontSize: ae,
        fontWeight: oe,
        fontFamily: re,
      })),
        (this.cache.clipedText = e.toString()),
        (this.cache.clipedWidth = Y);
    this.clearUpdateShapeTag();
    const fe = textDrawOffsetX(ie, Y);
    let me = ge;
    application.global && application.global.isSafari() && (me += 0.2 * ae);
    const ye = textLayoutOffsetY(ne, me, ae, he);
    return (
      this._AABBBounds.set(fe, ye, fe + Y, ye + me),
      se && this._AABBBounds.expand(le / 2),
      this._AABBBounds
    );
  }
  getBaselineMapAlign() {
    return Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return Text.alignMapBaseline;
  }
  updateVerticalSinglelineAABBBounds(e) {
    var T, C, $;
    const F = getTheme(this).text,
      V = application.graphicUtil.textMeasure;
    let Y;
    const K = this.attribute,
      { ignoreBuf: J = F.ignoreBuf } = K,
      ee = J ? 0 : 2,
      {
        maxLineWidth: te = F.maxLineWidth,
        ellipsis: ie = F.ellipsis,
        fontSize: ne = F.fontSize,
        fontWeight: re = F.fontWeight,
        fontFamily: ae = F.fontFamily,
        stroke: oe = F.stroke,
        lineWidth: se = F.lineWidth,
        verticalMode: le = F.verticalMode,
        suffixPosition: de = F.suffixPosition,
      } = K,
      ce =
        null !==
          (T = calculateLineHeight(K.lineHeight, K.fontSize || F.fontSize)) &&
        void 0 !== T
          ? T
          : (K.fontSize || F.fontSize) + ee;
    let { textAlign: ue = F.textAlign, textBaseline: he = F.textBaseline } = K;
    if (!le) {
      const e = ue;
      (ue =
        null !== (C = Text.baselineMapAlign[he]) && void 0 !== C ? C : "left"),
        (he =
          null !== ($ = Text.alignMapBaseline[e]) && void 0 !== $ ? $ : "top");
    }
    if (!this.shouldUpdateShape() && this.cache) {
      Y = this.cache.clipedWidth;
      const e = textDrawOffsetX(ue, Y),
        T = textLayoutOffsetY(he, ce, ne);
      return (
        this._AABBBounds.set(T, e, T + ce, e + Y),
        oe && this._AABBBounds.expand(se / 2),
        this._AABBBounds
      );
    }
    let pe = [verticalLayout(e.toString())];
    if (Number.isFinite(te)) {
      if (ie) {
        const e = !0 === ie ? F.ellipsis : ie,
          T = V.clipTextWithSuffixVertical(
            pe[0],
            {
              fontSize: ne,
              fontWeight: re,
              fontFamily: ae,
            },
            te,
            e,
            !1,
            de
          );
        (pe = [T.verticalList]), (Y = T.width);
      } else {
        const e = V.clipTextVertical(
          pe[0],
          {
            fontSize: ne,
            fontWeight: re,
            fontFamily: ae,
          },
          te,
          !1
        );
        (pe = [e.verticalList]), (Y = e.width);
      }
      (this.cache.verticalList = pe), (this.cache.clipedWidth = Y);
    } else
      (Y = 0),
        pe[0].forEach((e) => {
          const T =
            e.direction === TextDirection.HORIZONTAL
              ? ne
              : V.measureTextWidth(e.text, {
                  fontSize: ne,
                  fontWeight: re,
                  fontFamily: ae,
                });
          (Y += T), (e.width = T);
        }),
        (this.cache.verticalList = pe),
        (this.cache.clipedWidth = Y);
    this.clearUpdateShapeTag();
    const ge = textDrawOffsetX(ue, Y),
      fe = textLayoutOffsetY(he, ce, ne);
    return (
      this._AABBBounds.set(fe, ge, fe + ce, ge + Y),
      oe && this._AABBBounds.expand(se / 2),
      this._AABBBounds
    );
  }
  updateHorizontalMultilineAABBBounds(e) {
    var T, C;
    const $ = getTheme(this).text,
      { wrap: F = $.wrap } = this.attribute;
    if (F) return this.updateWrapAABBBounds(e);
    const V = this.attribute,
      {
        fontFamily: Y = $.fontFamily,
        textAlign: K = $.textAlign,
        textBaseline: J = $.textBaseline,
        fontSize: ee = $.fontSize,
        fontWeight: te = $.fontWeight,
        ellipsis: ie = $.ellipsis,
        maxLineWidth: ne,
        stroke: re = $.stroke,
        lineWidth: ae = $.lineWidth,
        whiteSpace: oe = $.whiteSpace,
        suffixPosition: se = $.suffixPosition,
      } = V,
      le =
        null !==
          (T = calculateLineHeight(V.lineHeight, V.fontSize || $.fontSize)) &&
        void 0 !== T
          ? T
          : V.fontSize || $.fontSize;
    if ("normal" === oe) return this.updateWrapAABBBounds(e);
    if (
      !this.shouldUpdateShape() &&
      (null === (C = this.cache) || void 0 === C ? void 0 : C.layoutData)
    ) {
      const e = this.cache.layoutData.bbox;
      return (
        this._AABBBounds.set(
          e.xOffset,
          e.yOffset,
          e.xOffset + e.width,
          e.yOffset + e.height
        ),
        re && this._AABBBounds.expand(ae / 2),
        this._AABBBounds
      );
    }
    const de = application.graphicUtil.textMeasure,
      ce = new CanvasTextLayout(
        Y,
        {
          fontSize: ee,
          fontWeight: te,
          fontFamily: Y,
        },
        de
      ).GetLayoutByLines(
        e,
        K,
        J,
        le,
        !0 === ie ? $.ellipsis : ie || void 0,
        !1,
        ne,
        se
      ),
      { bbox: ue } = ce;
    return (
      (this.cache.layoutData = ce),
      this.clearUpdateShapeTag(),
      this._AABBBounds.set(
        ue.xOffset,
        ue.yOffset,
        ue.xOffset + ue.width,
        ue.yOffset + ue.height
      ),
      re && this._AABBBounds.expand(ae / 2),
      this._AABBBounds
    );
  }
  updateVerticalMultilineAABBBounds(e) {
    var T, C, $;
    const F = getTheme(this).text,
      V = application.graphicUtil.textMeasure;
    let Y;
    const K = this.attribute,
      { ignoreBuf: J = F.ignoreBuf } = K,
      ee = J ? 0 : 2,
      {
        maxLineWidth: te = F.maxLineWidth,
        ellipsis: ie = F.ellipsis,
        fontFamily: ne = F.fontFamily,
        fontSize: re = F.fontSize,
        fontWeight: ae = F.fontWeight,
        stroke: oe = F.stroke,
        lineWidth: se = F.lineWidth,
        verticalMode: le = F.verticalMode,
        suffixPosition: de = F.suffixPosition,
      } = K,
      ce =
        null !==
          (T = calculateLineHeight(K.lineHeight, K.fontSize || F.fontSize)) &&
        void 0 !== T
          ? T
          : (K.fontSize || F.fontSize) + ee;
    let { textAlign: ue = F.textAlign, textBaseline: he = F.textBaseline } = K;
    if (!le) {
      const e = ue;
      (ue =
        null !== (C = Text.baselineMapAlign[he]) && void 0 !== C ? C : "left"),
        (he =
          null !== ($ = Text.alignMapBaseline[e]) && void 0 !== $ ? $ : "top");
    }
    if (((Y = 0), !this.shouldUpdateShape() && this.cache)) {
      this.cache.verticalList.forEach((e) => {
        const T = e.reduce((e, T) => e + T.width, 0);
        Y = max(T, Y);
      });
      const e = textDrawOffsetX(ue, Y),
        T = this.cache.verticalList.length * ce,
        C = textLayoutOffsetY(he, T, re);
      return (
        this._AABBBounds.set(C, e, C + T, e + Y),
        oe && this._AABBBounds.expand(se / 2),
        this._AABBBounds
      );
    }
    const pe = e.map((e) => verticalLayout(e.toString()));
    pe.forEach((e, T) => {
      if (Number.isFinite(te))
        if (ie) {
          const C = !0 === ie ? F.ellipsis : ie,
            $ = V.clipTextWithSuffixVertical(
              e,
              {
                fontSize: re,
                fontWeight: ae,
                fontFamily: ne,
              },
              te,
              C,
              !1,
              de
            );
          (pe[T] = $.verticalList), (Y = $.width);
        } else {
          const C = V.clipTextVertical(
            e,
            {
              fontSize: re,
              fontWeight: ae,
              fontFamily: ne,
            },
            te,
            !1
          );
          (pe[T] = C.verticalList), (Y = C.width);
        }
      else
        (Y = 0),
          e.forEach((e) => {
            const T =
              e.direction === TextDirection.HORIZONTAL
                ? re
                : V.measureTextWidth(e.text, {
                    fontSize: re,
                    fontWeight: ae,
                    fontFamily: ne,
                  });
            (Y += T), (e.width = T);
          });
    }),
      (this.cache.verticalList = pe),
      this.clearUpdateShapeTag(),
      this.cache.verticalList.forEach((e) => {
        const T = e.reduce((e, T) => e + T.width, 0);
        Y = max(T, Y);
      });
    const ge = textDrawOffsetX(ue, Y),
      fe = this.cache.verticalList.length * ce,
      me = textLayoutOffsetY(he, fe, re);
    return (
      this._AABBBounds.set(me, ge, me + fe, ge + Y),
      oe && this._AABBBounds.expand(se / 2),
      this._AABBBounds
    );
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).text[e];
  }
  needUpdateTags(e, T = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(e, T);
  }
  needUpdateTag(e, T = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(e, T);
  }
  clone() {
    return new Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Text.NOWORK_ANIMATE_ATTR;
  }
}
function createText(e) {
  return new Text(e);
}
(Text.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    ellipsis: 1,
    wordBreak: 1,
    direction: 1,
    textAlign: 1,
    textBaseline: 1,
    fontFamily: 1,
    fontWeight: 1,
  },
  NOWORK_ANIMATE_ATTR
)),
  (Text.baselineMapAlign = {
    top: "left",
    bottom: "right",
    middle: "center",
  }),
  (Text.alignMapBaseline = {
    left: "top",
    right: "bottom",
    center: "middle",
  });
const WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
class WrapText extends Text {
  constructor(e) {
    super(
      Object.assign(Object.assign({}, e), {
        wrap: !0,
      })
    );
  }
  _isValid() {
    const { text: e } = this.attribute;
    return isArray$1(e)
      ? !e.every((e) => null == e || "" === e)
      : null != e && "" !== e;
  }
  updateMultilineAABBBounds(e) {
    var T, C, $, F;
    const V = getTheme(this).text,
      {
        fontFamily: Y = V.fontFamily,
        textAlign: K = V.textAlign,
        textBaseline: J = V.textBaseline,
        fontSize: ee = V.fontSize,
        ellipsis: te = V.ellipsis,
        maxLineWidth: ie,
        stroke: ne = V.stroke,
        lineWidth: re = V.lineWidth,
        wordBreak: ae = V.wordBreak,
        fontWeight: oe = V.fontWeight,
        ignoreBuf: se = V.ignoreBuf,
        heightLimit: le = 0,
        suffixPosition: de = V.suffixPosition,
        lineClamp: ce,
      } = this.attribute,
      ue =
        null !==
          (T = calculateLineHeight(
            this.attribute.lineHeight,
            this.attribute.fontSize || V.fontSize
          )) && void 0 !== T
          ? T
          : this.attribute.fontSize || V.fontSize,
      he = se ? 0 : 2;
    if (
      !this.shouldUpdateShape() &&
      (null === (C = this.cache) || void 0 === C ? void 0 : C.layoutData)
    ) {
      const e = this.cache.layoutData.bbox;
      return (
        this._AABBBounds.set(
          e.xOffset,
          e.yOffset,
          e.xOffset + e.width,
          e.yOffset + e.height
        ),
        ne && this._AABBBounds.expand(re / 2),
        this._AABBBounds
      );
    }
    const pe = application.graphicUtil.textMeasure,
      ge = new CanvasTextLayout(
        Y,
        {
          fontSize: ee,
          fontWeight: oe,
          fontFamily: Y,
        },
        pe
      ),
      fe = e.map((e) => e.toString()),
      me = [],
      ye = [0, 0];
    let be = 1 / 0;
    if (
      (le > 0 && (be = Math.max(Math.floor(le / ue), 1)),
      ce && (be = Math.min(be, ce)),
      "number" == typeof ie && ie !== 1 / 0)
    ) {
      if (ie > 0)
        for (let T = 0; T < fe.length; T++) {
          const e = fe[T];
          let C = !0;
          if (T === be - 1) {
            const T = ge.textMeasure.clipTextWithSuffix(
              e,
              ge.textOptions,
              ie,
              te,
              !1,
              de
            );
            me.push({
              str: T.str,
              width: T.width,
            });
            break;
          }
          const V = ge.textMeasure.clipText(
            e,
            ge.textOptions,
            ie,
            "break-word" === ae
          );
          if ("" !== e && "" === V.str) {
            if (te) {
              const T = ge.textMeasure.clipTextWithSuffix(
                e,
                ge.textOptions,
                ie,
                te,
                !1,
                de
              );
              (V.str = null !== ($ = T.str) && void 0 !== $ ? $ : ""),
                (V.width = null !== (F = T.width) && void 0 !== F ? F : 0);
            } else (V.str = ""), (V.width = 0);
            C = !1;
          }
          if (
            (me.push({
              str: V.str,
              width: V.width,
            }),
            V.str.length === e.length)
          );
          else if (C) {
            const C = e.substring(V.str.length);
            fe.splice(T + 1, 0, C);
          }
        }
      let e = 0;
      me.forEach((T) => {
        e = Math.max(e, T.width);
      }),
        (ye[0] = e);
    } else {
      let e,
        T,
        C = 0;
      for (let $ = 0, F = fe.length; $ < F; $++) {
        if ($ === be - 1) {
          const e = ge.textMeasure.clipTextWithSuffix(
            fe[$],
            ge.textOptions,
            ie,
            te,
            !1,
            de
          );
          me.push({
            str: e.str,
            width: e.width,
          }),
            (C = Math.max(C, e.width));
          break;
        }
        (T = fe[$]),
          (e = ge.textMeasure.measureTextWidth(
            T,
            ge.textOptions,
            "break-word" === ae
          )),
          (C = Math.max(C, e)),
          me.push({
            str: T,
            width: e,
          });
      }
      ye[0] = C;
    }
    ye[1] = me.length * (ue + he);
    const ve = {
      xOffset: 0,
      yOffset: 0,
      width: ye[0],
      height: ye[1],
    };
    ge.LayoutBBox(ve, K, J);
    const Te = ge.layoutWithBBox(ve, me, K, J, ue);
    return (
      (this.cache.layoutData = Te),
      this.clearUpdateShapeTag(),
      this._AABBBounds.set(
        ve.xOffset,
        ve.yOffset,
        ve.xOffset + ve.width,
        ve.yOffset + ve.height
      ),
      ne && this._AABBBounds.expand(re / 2),
      this._AABBBounds
    );
  }
  needUpdateTags(e) {
    for (let T = 0; T < WRAP_TEXT_UPDATE_TAG_KEY.length; T++) {
      const C = WRAP_TEXT_UPDATE_TAG_KEY[T];
      if (-1 !== e.indexOf(C)) return !0;
    }
    return super.needUpdateTags(e);
  }
  needUpdateTag(e) {
    for (let T = 0; T < WRAP_TEXT_UPDATE_TAG_KEY.length; T++)
      if (e === WRAP_TEXT_UPDATE_TAG_KEY[T]) return !0;
    return super.needUpdateTag(e);
  }
  getNoWorkAnimateAttr() {
    return WrapText.NOWORK_ANIMATE_ATTR;
  }
}
function createWrapText(e) {
  return new WrapText(e);
}
class BaseSymbol {
  bounds(e, T) {
    if (isNumber$1(e)) {
      const C = e / 2;
      (T.x1 = -C), (T.x2 = C), (T.y1 = -C), (T.y2 = C);
    } else
      (T.x1 = -e[0] / 2),
        (T.x2 = e[0] / 2),
        (T.y1 = -e[1] / 2),
        (T.y2 = e[1] / 2);
  }
}
function circle(e, T, C, $, F) {
  return F ? e.arc(C, $, T, 0, tau, !1, F) : e.arc(C, $, T, 0, tau), !1;
}
class CircleSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "circle"),
      (this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0");
  }
  draw(e, T, C, $, F) {
    return circle(e, T / 2, C, $, F);
  }
  drawOffset(e, T, C, $, F, V) {
    return circle(e, T / 2 + F, C, $, V);
  }
  drawToSvgPath(e, T, C, $) {
    const F = e / 2;
    return `M ${T - F}, ${C} a ${F},${F} 0 1,0 ${2 * F},0 a ${F},${F} 0 1,0 -${
      2 * F
    },0`;
  }
}
const circle$1 = new CircleSymbol();
function cross(e, T, C, $, F) {
  return (
    e.moveTo(-3 * T + C, -T + $, F),
    e.lineTo(-T + C, -T + $, F),
    e.lineTo(-T + C, -3 * T + $, F),
    e.lineTo(T + C, -3 * T + $, F),
    e.lineTo(T + C, -T + $, F),
    e.lineTo(3 * T + C, -T + $, F),
    e.lineTo(3 * T + C, T + $, F),
    e.lineTo(T + C, T + $, F),
    e.lineTo(T + C, 3 * T + $, F),
    e.lineTo(-T + C, 3 * T + $, F),
    e.lineTo(-T + C, T + $, F),
    e.lineTo(-3 * T + C, T + $, F),
    e.closePath(),
    !0
  );
}
function crossOffset(e, T, C, $, F, V) {
  return (
    e.moveTo(-3 * T + C - F, -T + $ - F, V),
    e.lineTo(-T + C - F, -T + $ - F, V),
    e.lineTo(-T + C - F, -3 * T + $ - F, V),
    e.lineTo(T + C + F, -3 * T + $ - F, V),
    e.lineTo(T + C + F, -T + $ - F, V),
    e.lineTo(3 * T + C + F, -T + $ - F, V),
    e.lineTo(3 * T + C + F, T + $ + F, V),
    e.lineTo(T + C + F, T + $ + F, V),
    e.lineTo(T + C + F, 3 * T + $ + F, V),
    e.lineTo(-T + C - F, 3 * T + $ + F, V),
    e.lineTo(-T + C - F, T + $ + F, V),
    e.lineTo(-3 * T + C - F, T + $ + F, V),
    e.closePath(),
    !0
  );
}
class CrossSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "cross"),
      (this.pathStr =
        "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z");
  }
  draw(e, T, C, $, F) {
    return cross(e, T / 6, C, $, F);
  }
  drawOffset(e, T, C, $, F, V) {
    return crossOffset(e, T / 6, C, $, F, V);
  }
}
const cross$1 = new CrossSymbol();
function diamond(e, T, C, $, F) {
  return (
    e.moveTo(C, $ - T, F),
    e.lineTo(T + C, $, F),
    e.lineTo(C, $ + T, F),
    e.lineTo(C - T, $, F),
    e.closePath(),
    !0
  );
}
class DiamondSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "diamond"),
      (this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z");
  }
  draw(e, T, C, $, F) {
    return diamond(e, T / 2, C, $, F);
  }
  drawFitDir(e, T, C, $, F) {
    return diamond(e, T / 2, C, $, F);
  }
  drawOffset(e, T, C, $, F, V) {
    return diamond(e, T / 2 + F, C, $, V);
  }
}
const diamond$1 = new DiamondSymbol();
function square(e, T, C, $) {
  const F = 2 * T;
  return e.rect(C - T, $ - T, F, F), !1;
}
class SquareSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "square"),
      (this.pathStr = "M-0.5,-0.5h1v1h-1Z");
  }
  draw(e, T, C, $) {
    return square(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return square(e, T / 2 + F, C, $);
  }
}
const square$1 = new SquareSymbol();
function trianglUp(e, T, C, $) {
  return (
    e.moveTo(C + T, T + $),
    e.lineTo(C - T, T + $),
    e.lineTo(C, $ - T),
    e.closePath(),
    !0
  );
}
function trianglUpOffset(e, T, C, $, F) {
  return (
    e.moveTo(C + T + 2 * F, T + $ + F),
    e.lineTo(C - T - 2 * F, T + $ + F),
    e.lineTo(C, $ - T - 2 * F),
    e.closePath(),
    !0
  );
}
class TriangleUpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "triangleUp"),
      (this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z");
  }
  draw(e, T, C, $) {
    return trianglUp(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return trianglUpOffset(e, T / 2, C, $, F);
  }
}
const triangleUp = new TriangleUpSymbol();
class TriangleSymbol extends TriangleUpSymbol {
  constructor() {
    super(...arguments), (this.type = "triangle");
  }
}
const triangle = new TriangleSymbol(),
  kr = Math.sin(Math.PI / 10) / Math.sin((7 * Math.PI) / 10),
  kx = Math.sin(tau / 10) * kr,
  ky = -Math.cos(tau / 10) * kr;
function star(e, T, C, $) {
  const F = kx * T,
    V = ky * T;
  e.moveTo(C, -T + $), e.lineTo(F + C, V + $);
  for (let Y = 1; Y < 5; ++Y) {
    const K = (tau * Y) / 5,
      J = Math.cos(K),
      ee = Math.sin(K);
    e.lineTo(ee * T + C, -J * T + $),
      e.lineTo(J * F - ee * V + C, ee * F + J * V + $);
  }
  return e.closePath(), !0;
}
class StarSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "star"),
      (this.pathStr =
        "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z");
  }
  draw(e, T, C, $) {
    return star(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return star(e, T / 2 + F, C, $);
  }
}
const star$1 = new StarSymbol(),
  sqrt3$1 = sqrt(3);
function arrow(e, T, C, $) {
  const F = T,
    V = F / sqrt3$1,
    Y = V / 5,
    K = T;
  return (
    e.moveTo(0 + C, -F + $),
    e.lineTo(V / 2 + C, $),
    e.lineTo(Y / 2 + C, $),
    e.lineTo(Y / 2 + C, K + $),
    e.lineTo(-Y / 2 + C, K + $),
    e.lineTo(-Y / 2 + C, $),
    e.lineTo(-V / 2 + C, $),
    e.closePath(),
    !0
  );
}
class ArrowSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "arrow"),
      (this.pathStr =
        "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z");
  }
  draw(e, T, C, $) {
    return arrow(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return arrow(e, T / 2 + F, C, $);
  }
}
const arrow$1 = new ArrowSymbol();
function wedge(e, T, C, $) {
  const F = 2 * T;
  return (
    e.moveTo(C, -T + $),
    e.lineTo(F / 3 / 2 + C, T + $),
    e.lineTo(-F / 3 / 2 + C, T + $),
    e.closePath(),
    !0
  );
}
class WedgeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "wedge"),
      (this.pathStr =
        "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z");
  }
  draw(e, T, C, $) {
    return wedge(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return wedge(e, T / 2 + F, C, $);
  }
}
const wedge$1 = new WedgeSymbol();
function stroke(e, T, C, $) {
  return e.moveTo(-T + C, $), e.lineTo(C, T + $), !1;
}
class StrokeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), (this.type = "stroke"), (this.pathStr = "");
  }
  draw(e, T, C, $) {
    return stroke(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return stroke(e, T / 2 + F, C, $);
  }
}
const stroke$1 = new StrokeSymbol(),
  c = -0.5,
  s = sqrt(3) / 2,
  k = 1 / sqrt(12);
function wye(e, T, C, $) {
  const F = T / 2,
    V = T * k,
    Y = F,
    K = T * k + T,
    J = -Y,
    ee = K;
  return (
    e.moveTo(F + C, V + $),
    e.lineTo(Y + C, K + $),
    e.lineTo(J + C, ee + $),
    e.lineTo(c * F - s * V + C, s * F + c * V + $),
    e.lineTo(c * Y - s * K + C, s * Y + c * K + $),
    e.lineTo(c * J - s * ee + C, s * J + c * ee + $),
    e.lineTo(c * F + s * V + C, c * V - s * F + $),
    e.lineTo(c * Y + s * K + C, c * K - s * Y + $),
    e.lineTo(c * J + s * ee + C, c * ee - s * J + $),
    e.closePath(),
    !1
  );
}
class WyeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "wye"),
      (this.pathStr =
        "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z");
  }
  draw(e, T, C, $) {
    return wye(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return wye(e, T / 2 + F, C, $);
  }
}
const wye$1 = new WyeSymbol();
function trianglLeft(e, T, C, $) {
  return (
    e.moveTo(-T + C, $),
    e.lineTo(T + C, T + $),
    e.lineTo(T + C, $ - T),
    e.closePath(),
    !0
  );
}
function trianglLeftOffset(e, T, C, $, F) {
  return (
    e.moveTo(-T + C - 2 * F, $),
    e.lineTo(T + C + F, T + $ + 2 * F),
    e.lineTo(T + C + F, $ - T - 2 * F),
    e.closePath(),
    !0
  );
}
class TriangleLeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "triangleLeft"),
      (this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z");
  }
  draw(e, T, C, $) {
    return trianglLeft(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return trianglLeftOffset(e, T / 2, C, $, F);
  }
}
const triangleLeft = new TriangleLeftSymbol();
function trianglRight(e, T, C, $) {
  return (
    e.moveTo(C - T, T + $),
    e.lineTo(T + C, $),
    e.lineTo(C - T, $ - T),
    e.closePath(),
    !0
  );
}
function trianglRightOffset(e, T, C, $, F) {
  return (
    e.moveTo(C - T - F, T + $ + 2 * F),
    e.lineTo(T + C + 2 * F, $),
    e.lineTo(C - T - F, $ - T - 2 * F),
    e.closePath(),
    !0
  );
}
class TriangleRightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "triangleRight"),
      (this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z");
  }
  draw(e, T, C, $) {
    return trianglRight(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return trianglRightOffset(e, T / 2, C, $, F);
  }
}
const triangleRight = new TriangleRightSymbol();
function trianglDown(e, T, C, $) {
  return (
    e.moveTo(C - T, $ - T),
    e.lineTo(C + T, $ - T),
    e.lineTo(C, $ + T),
    e.closePath(),
    !0
  );
}
function trianglDownOffset(e, T, C, $, F) {
  return (
    e.moveTo(C - T - 2 * F, $ - T - F),
    e.lineTo(C + T + 2 * F, $ - T - F),
    e.lineTo(C, $ + T + 2 * F),
    e.closePath(),
    !0
  );
}
class TriangleDownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "triangleDown"),
      (this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z");
  }
  draw(e, T, C, $) {
    return trianglDown(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return trianglDownOffset(e, T / 2, C, $, F);
  }
}
const triangleDown = new TriangleDownSymbol(),
  sqrt3 = sqrt(3);
function thinTriangle(e, T, C, $) {
  const F = T * sqrt3;
  return (
    e.moveTo(C, $ + (-F / 3) * 2),
    e.lineTo(T + C, $ + F),
    e.lineTo(C - T, $ + F),
    e.closePath(),
    !0
  );
}
class ThinTriangleSymbol extends TriangleUpSymbol {
  constructor() {
    super(...arguments),
      (this.type = "thinTriangle"),
      (this.pathStr =
        "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z");
  }
  draw(e, T, C, $) {
    return thinTriangle(e, T / 2 / sqrt3, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return thinTriangle(e, T / 2 / sqrt3 + F, C, $);
  }
}
const thinTriangle$1 = new ThinTriangleSymbol();
function arrow2Left(e, T, C, $) {
  const F = 2 * T;
  return e.moveTo(T + C, $ - F), e.lineTo(C - T, $), e.lineTo(T + C, F + $), !0;
}
class Arrow2LeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "arrow2Left"),
      (this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5");
  }
  draw(e, T, C, $) {
    return arrow2Left(e, T / 4, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return arrow2Left(e, T / 4 + F, C, $);
  }
}
const arrow2Left$1 = new Arrow2LeftSymbol();
function arrow2Right(e, T, C, $) {
  const F = 2 * T;
  return e.moveTo(C - T, $ - F), e.lineTo(C + T, $), e.lineTo(C - T, F + $), !0;
}
class Arrow2RightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "arrow2Right"),
      (this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5");
  }
  draw(e, T, C, $) {
    return arrow2Right(e, T / 4, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return arrow2Right(e, T / 4 + F, C, $);
  }
}
const arrow2Right$1 = new Arrow2RightSymbol();
function arrow2Up(e, T, C, $) {
  const F = 2 * T;
  return e.moveTo(C - F, $ + T), e.lineTo(C, $ - T), e.lineTo(C + F, $ + T), !0;
}
class Arrow2UpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "arrow2Up"),
      (this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25");
  }
  draw(e, T, C, $) {
    return arrow2Up(e, T / 4, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return arrow2Up(e, T / 4 + F, C, $);
  }
}
const arrow2Up$1 = new Arrow2UpSymbol();
function arrow2Down(e, T, C, $) {
  const F = 2 * T;
  return e.moveTo(C - F, $ - T), e.lineTo(C, $ + T), e.lineTo(C + F, $ - T), !0;
}
class Arrow2DownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "arrow2Down"),
      (this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25");
  }
  draw(e, T, C, $) {
    return arrow2Down(e, T / 4, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return arrow2Down(e, T / 4 + F, C, $);
  }
}
const arrow2Down$1 = new Arrow2DownSymbol();
function lineV(e, T, C, $, F) {
  return e.moveTo(C, $ - T), e.lineTo(C, $ + T), !0;
}
class LineVSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "lineV"),
      (this.pathStr = "M0,-0.5L0,0.5");
  }
  draw(e, T, C, $, F) {
    return lineV(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F, V) {
    return lineV(e, T / 2 + F, C, $);
  }
  drawToSvgPath(e, T, C, $) {
    const F = e / 2;
    return `M ${T}, ${C - F} L ${T},${C + F}`;
  }
}
const lineV$1 = new LineVSymbol();
function lineH(e, T, C, $, F) {
  return e.moveTo(C - T, $), e.lineTo(C + T, $), !0;
}
class LineHSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "lineH"),
      (this.pathStr = "M-0.5,0L0.5,0");
  }
  draw(e, T, C, $, F) {
    return lineH(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F, V) {
    return lineH(e, T / 2 + F, C, $);
  }
  drawToSvgPath(e, T, C, $) {
    const F = e / 2;
    return `M ${T - F}, ${C} L ${T + F},${C}`;
  }
}
const lineH$1 = new LineHSymbol();
function close(e, T, C, $, F) {
  return (
    e.moveTo(C - T, $ - T),
    e.lineTo(C + T, $ + T),
    e.moveTo(C + T, $ - T),
    e.lineTo(C - T, $ + T),
    !0
  );
}
class CloseSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "close"),
      (this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5");
  }
  draw(e, T, C, $, F) {
    return close(e, T / 2, C, $);
  }
  drawOffset(e, T, C, $, F, V) {
    return close(e, T / 2 + F, C, $);
  }
  drawToSvgPath(e, T, C, $) {
    const F = e / 2;
    return `M ${T - F}, ${C - F} L ${T + F},${C + F} M ${T + F}, ${C - F} L ${
      T - F
    },${C + F}`;
  }
}
const close$1 = new CloseSymbol();
function rectSizeArray(e, T, C, $) {
  return e.rect(C - T[0] / 2, $ - T[1] / 2, T[0], T[1]), !1;
}
function rectSize(e, T, C, $) {
  const F = T,
    V = T / 2;
  return e.rect(C - F / 2, $ - V / 2, F, V), !1;
}
class RectSymbol extends BaseSymbol {
  constructor() {
    super(...arguments),
      (this.type = "rect"),
      (this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z");
  }
  draw(e, T, C, $) {
    return isNumber$1(T) ? rectSize(e, T, C, $) : rectSizeArray(e, T, C, $);
  }
  drawOffset(e, T, C, $, F) {
    return isNumber$1(T)
      ? rectSize(e, T + 2 * F, C, $)
      : rectSizeArray(e, [T[0] + 2 * F, T[1] + 2 * F], C, $);
  }
}
const rect = new RectSymbol(),
  tempBounds = new AABBBounds();
class CustomSymbolClass {
  constructor(e, T, C = !1) {
    (this.pathStr = ""),
      (this.type = e),
      isArray$1(T) ? (this.svgCache = T) : (this.path = T),
      (this.isSvg = C);
  }
  drawOffset(e, T, C, $, F, V, Y) {
    return this.isSvg
      ? !!this.svgCache &&
          (this.svgCache.forEach((F) => {
            e.beginPath(),
              renderCommandList(F.path.commandList, e, C, $, T, T),
              Y && Y(F.path, F.attribute);
          }),
          !1)
      : (renderCommandList(this.path.commandList, e, C, $, T + F, T + F), !1);
  }
  draw(e, T, C, $, F, V) {
    return this.isSvg
      ? !!this.svgCache &&
          (this.svgCache.forEach((F) => {
            e.beginPath(),
              renderCommandList(F.path.commandList, e, C, $, T, T),
              V && V(F.path, F.attribute);
          }),
          !1)
      : (renderCommandList(this.path.commandList, e, C, $, T, T), !1);
  }
  bounds(e, T) {
    if (this.isSvg) {
      if (!this.svgCache) return;
      return (
        T.clear(),
        void this.svgCache.forEach(({ path: C }) => {
          (tempBounds.x1 = C.bounds.x1 * e),
            (tempBounds.y1 = C.bounds.y1 * e),
            (tempBounds.x2 = C.bounds.x2 * e),
            (tempBounds.y2 = C.bounds.y2 * e),
            T.union(tempBounds);
        })
      );
    }
    this.path.bounds &&
      ((T.x1 = this.path.bounds.x1 * e),
      (T.y1 = this.path.bounds.y1 * e),
      (T.x2 = this.path.bounds.x2 * e),
      (T.y2 = this.path.bounds.y2 * e));
  }
}
const builtinSymbols = [
    circle$1,
    cross$1,
    diamond$1,
    square$1,
    thinTriangle$1,
    triangle,
    star$1,
    arrow$1,
    wedge$1,
    stroke$1,
    wye$1,
    triangleLeft,
    triangleRight,
    triangleUp,
    triangleDown,
    arrow2Left$1,
    arrow2Right$1,
    arrow2Up$1,
    arrow2Down$1,
    rect,
    lineV$1,
    lineH$1,
    close$1,
  ],
  builtinSymbolsMap = {};
builtinSymbols.forEach((e) => {
  builtinSymbolsMap[e.type] = e;
});
const builtInSymbolStrMap = {
    arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
    arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
    rectRound:
      "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
    roundLine:
      "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z",
  },
  _tempBounds = new AABBBounds(),
  SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
class Symbol$1 extends Graphic {
  constructor(
    e = {
      symbolType: "circle",
    }
  ) {
    super(e), (this.type = "symbol"), (this.numberType = SYMBOL_NUMBER_TYPE);
  }
  getParsedPath() {
    return (
      this.shouldUpdateShape() &&
        (this.doUpdateParsedPath(), this.clearUpdateShapeTag()),
      this._parsedPath
    );
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { size: e } = this.attribute;
    return isArray$1(e)
      ? 2 === e.length && e.every(this._validNumber)
      : this._validNumber(e);
  }
  doUpdateParsedPath() {
    const e = getTheme(this).symbol;
    let { symbolType: T = e.symbolType } = this.attribute,
      C = builtinSymbolsMap[T];
    if (C) return (this._parsedPath = C), C;
    if (((C = Symbol$1.userSymbolMap[T]), C)) return (this._parsedPath = C), C;
    if (((T = builtInSymbolStrMap[T] || T), !0 === isSvg(T))) {
      const e = new XMLParser(),
        { svg: C } = e.parse(T);
      if (!C) return null;
      const $ = isArray$1(C.path) ? C.path : [C.path];
      _tempBounds.clear();
      const F = [];
      $.forEach((e) => {
        const T = new CustomPath2D().fromString(e.d),
          C = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((T) => {
          e[T] && (C[SVG_PARSE_ATTRIBUTE_MAP[T]] = e[T]);
        }),
          F.push({
            path: T,
            attribute: C,
          }),
          _tempBounds.union(T.bounds);
      });
      const V = _tempBounds.width(),
        Y = _tempBounds.height(),
        K = 1 / max(V, Y);
      return (
        F.forEach((e) => e.path.transform(0, 0, K, K)),
        (this._parsedPath = new CustomSymbolClass(T, F, !0)),
        (Symbol$1.userSymbolMap[T] = this._parsedPath),
        this._parsedPath
      );
    }
    const $ = new CustomPath2D().fromString(T),
      F = $.bounds.width(),
      V = $.bounds.height(),
      Y = 1 / max(F, V);
    return (
      $.transform(0, 0, Y, Y),
      (this._parsedPath = new CustomSymbolClass(T, $)),
      (Symbol$1.userSymbolMap[T] = this._parsedPath),
      this._parsedPath
    );
  }
  doUpdateAABBBounds(e) {
    const T = getTheme(this).symbol;
    this._AABBBounds.clear();
    const C = this.attribute,
      $ = application.graphicService.updateSymbolAABBBounds(
        C,
        getTheme(this).symbol,
        this._AABBBounds,
        e,
        this
      ),
      { boundsPadding: F = T.boundsPadding } = C,
      V = parsePadding(F);
    return V && $.expand(V), this.clearUpdateBoundTag(), $;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).symbol[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const e = this.getParsedPath(),
      T = this.attribute.size,
      C = isArray$1(T) ? T : [T, T];
    return e.path
      ? new CustomPath2D().fromCustomPath2D(e.path, 0, 0, C[0], C[1])
      : new CustomPath2D().fromString(e.pathStr, 0, 0, C[0], C[1]);
  }
  clone() {
    return new Symbol$1(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Symbol$1.NOWORK_ANIMATE_ATTR;
  }
}
function createSymbol(e) {
  return new Symbol$1(e);
}
(Symbol$1.userSymbolMap = {}),
  (Symbol$1.NOWORK_ANIMATE_ATTR = Object.assign(
    {
      symbolType: 1,
    },
    NOWORK_ANIMATE_ATTR
  ));
const LINE_UPDATE_TAG_KEY = [
  "segments",
  "points",
  "curveType",
  "curveTension",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Line$1 extends Graphic {
  constructor(e = {}) {
    super(e), (this.type = "line"), (this.numberType = LINE_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const { points: e, segments: T } = this.attribute;
    return T ? 0 !== T.length : !(!e || e.length <= 1);
  }
  _interpolate(e, T, C, $, F) {
    "points" === e && (F.points = pointsInterpolation(C, $, T));
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).line;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateLineAABBBounds(
        T,
        getTheme(this).line,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).line[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const e = this.attribute,
      T = new CustomPath2D(),
      C = e.segments,
      $ = (e) => {
        if (e && e.length) {
          let C = !0;
          e.forEach((e) => {
            !1 !== e.defined &&
              (C ? T.moveTo(e.x, e.y) : T.lineTo(e.x, e.y), (C = !1));
          });
        }
      };
    return (
      C && C.length
        ? C.forEach((e) => {
            $(e.points);
          })
        : e.points && $(e.points),
      T
    );
  }
  clone() {
    return new Line$1(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Line$1.NOWORK_ANIMATE_ATTR;
  }
}
function createLine(e) {
  return new Line$1(e);
}
Line$1.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    segments: 1,
    curveType: 1,
  },
  NOWORK_ANIMATE_ATTR
);
const RECT_UPDATE_TAG_KEY = [
  "width",
  "x1",
  "y1",
  "height",
  "cornerRadius",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Rect extends Graphic {
  constructor(e) {
    super(e), (this.type = "rect"), (this.numberType = RECT_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return !0;
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).rect;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateRectAABBBounds(
        T,
        getTheme(this).rect,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).rect[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const e = this.attribute,
      { x: T, y: C, width: $, height: F } = normalizeRectAttributes(e),
      V = new CustomPath2D();
    return V.moveTo(T, C), V.rect(T, C, $, F), V;
  }
  clone() {
    return new Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Rect.NOWORK_ANIMATE_ATTR;
  }
}
function createRect(e) {
  return new Rect(e);
}
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
const CUBE_VERTICES = [
  [0, 0, 0],
  [1, 0, 0],
  [1, 1, 0],
  [0, 1, 0],
  [0, 0, 1],
  [1, 0, 1],
  [1, 1, 1],
  [0, 1, 1],
];
class Rect3d extends Rect {
  constructor(e) {
    super(e), (this.type = "rect3d"), (this.numberType = RECT3D_NUMBER_TYPE);
  }
  findFace() {
    const e = {
        polygons: [],
        vertices: [],
        edges: [],
      },
      T = getTheme(this).rect,
      {
        x1: C,
        y1: $,
        x: F,
        y: V,
        length: Y = min(T.width, T.height),
      } = this.attribute;
    let { width: K, height: J } = this.attribute;
    (K = null != K ? K : C - F), (J = null != J ? J : $ - V);
    for (let ee = 0; ee < CUBE_VERTICES.length; ee++) {
      const T = CUBE_VERTICES[ee];
      e.vertices.push([T[0] * K, T[1] * J, T[2] * Y]);
    }
    return (
      e.polygons.push({
        polygon: [0, 1, 5, 4],
        normal: [0, -1, 0],
      }),
      e.polygons.push({
        polygon: [2, 3, 7, 6],
        normal: [0, 1, 0],
      }),
      e.polygons.push({
        polygon: [4, 7, 3, 0],
        normal: [-1, 0, 0],
      }),
      e.polygons.push({
        polygon: [1, 2, 6, 5],
        normal: [1, 0, 0],
      }),
      e.polygons.push({
        polygon: [0, 1, 2, 3],
        normal: [0, 0, -1],
      }),
      e.polygons.push({
        polygon: [4, 5, 6, 7],
        normal: [0, 0, 1],
      }),
      (e.edges = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0],
        [4, 5],
        [5, 6],
        [6, 7],
        [7, 4],
        [0, 4],
        [3, 7],
        [1, 5],
        [2, 6],
      ]),
      e
    );
  }
  getNoWorkAnimateAttr() {
    return Rect3d.NOWORK_ANIMATE_ATTR;
  }
}
function createRect3d(e) {
  return new Rect3d(e);
}
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class Glyph extends Graphic {
  constructor(e) {
    super(e),
      (this.type = "glyph"),
      (this.numberType = GLYPH_NUMBER_TYPE),
      (this.subGraphic = []),
      this._onInit && this._onInit(this),
      (this.valid = this.isValid());
  }
  setSubGraphic(e) {
    this.detachSubGraphic(),
      (this.subGraphic = e),
      e.forEach((e) => {
        (e.glyphHost = this),
          Object.setPrototypeOf(e.attribute, this.attribute);
      }),
      (this.valid = this.isValid()),
      this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach((e) => {
      (e.glyphHost = null), Object.setPrototypeOf(e.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(e) {
    this._onInit = e;
  }
  onUpdate(e) {
    this._onUpdate = e;
  }
  isValid() {
    return !0;
  }
  setAttribute(e, T, C, $) {
    super.setAttribute(e, T, C, $),
      this.subGraphic.forEach((e) => {
        e.addUpdateShapeAndBoundsTag(), e.addUpdatePositionTag();
      });
  }
  setAttributes(e, T = !1, C) {
    super.setAttributes(e, T, C),
      this.subGraphic.forEach((e) => {
        e.addUpdateShapeAndBoundsTag(), e.addUpdatePositionTag();
      });
  }
  translate(e, T) {
    return (
      super.translate(e, T),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  translateTo(e, T) {
    return (
      super.translateTo(e, T),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  scale(e, T, C) {
    return (
      super.scale(e, T, C),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  scaleTo(e, T) {
    return (
      super.scaleTo(e, T),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  rotate(e) {
    return (
      super.rotate(e),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  rotateTo(e) {
    return (
      super.rotate(e),
      this.subGraphic.forEach((e) => {
        e.addUpdatePositionTag(), e.addUpdateBoundTag();
      }),
      this
    );
  }
  doUpdateAABBBounds() {
    this._AABBBounds.clear();
    const e = application.graphicService.updateGlyphAABBBounds(
      this.attribute,
      getTheme(this).glyph,
      this._AABBBounds,
      this
    );
    return this.clearUpdateBoundTag(), e;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  needUpdateTags(e) {
    return !1;
  }
  needUpdateTag(e) {
    return !1;
  }
  useStates(e, T) {
    var C;
    if (!e.length) return void this.clearStates(T);
    if (
      (null === (C = this.currentStates) || void 0 === C
        ? void 0
        : C.length) === e.length &&
      !e.some((e, T) => this.currentStates[T] !== e)
    )
      return;
    this.stopStateAnimates();
    const $ = {},
      F = this.subGraphic.map(() => ({}));
    e.forEach((T) => {
      var C;
      const V = this.glyphStateProxy
        ? this.glyphStateProxy(T, e)
        : this.glyphStates[T];
      V &&
        (Object.assign($, V.attributes),
        (null === (C = V.subAttributes) || void 0 === C ? void 0 : C.length) &&
          F.forEach((e, T) => {
            Object.assign(e, V.subAttributes[T]);
          }));
    }),
      this.subGraphic.forEach((C, $) => {
        C.updateNormalAttrs(F[$]), C.applyStateAttrs(F[$], e, T);
      }),
      this.updateNormalAttrs($),
      (this.currentStates = e),
      this.applyStateAttrs($, e, T);
  }
  clearStates(e) {
    this.stopStateAnimates(),
      this.hasState() && this.normalAttrs
        ? ((this.currentStates = []),
          this.subGraphic.forEach((T) => {
            T.applyStateAttrs(T.normalAttrs, this.currentStates, e, !0),
              (T.normalAttrs = null);
          }),
          this.applyStateAttrs(this.normalAttrs, this.currentStates, e, !0))
        : (this.currentStates = []),
      (this.normalAttrs = null);
  }
  clone() {
    const e = new Glyph(Object.assign({}, this.attribute));
    return e.setSubGraphic(this.subGraphic.map((e) => e.clone())), e;
  }
  getNoWorkAnimateAttr() {
    return Glyph.NOWORK_ANIMATE_ATTR;
  }
}
function createGlyph(e) {
  return new Glyph(e);
}
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class Frame {
  constructor(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne, re) {
    (this.left = e),
      (this.top = T),
      (this.width = C),
      (this.height = $),
      (this.actualHeight = 0),
      (this.bottom = T + $),
      (this.right = e + C),
      (this.ellipsis = F),
      (this.wordBreak = V),
      (this.verticalDirection = Y),
      (this.lines = []),
      (this.globalAlign = K),
      (this.globalBaseline = J),
      (this.layoutDirection = ee),
      (this.directionKey = DIRECTION_KEY[this.layoutDirection]),
      (this.isWidthMax = te),
      (this.isHeightMax = ie),
      (this.singleLine = ne),
      re ? (re.clear(), (this.icons = re)) : (this.icons = new Map());
  }
  draw(e, T) {
    const { width: C, height: $ } = this.getActualSize(),
      F = this.isWidthMax ? Math.min(this.width, C) : this.width || C || 0;
    let V = this.isHeightMax ? Math.min(this.height, $) : this.height || $ || 0;
    V = Math.min(V, $);
    let Y = 0;
    switch (this.globalBaseline) {
      case "top":
        Y = 0;
        break;
      case "middle":
        Y = -V / 2;
        break;
      case "bottom":
        Y = -V;
    }
    let K = 0;
    "right" === this.globalAlign || "end" === this.globalAlign
      ? (K = -F)
      : "center" === this.globalAlign && (K = -F / 2);
    let J = this[this.directionKey.height];
    this.singleLine && (J = this.lines[0].height + 1);
    let ee = !1;
    if ("middle" === this.verticalDirection)
      if (this.actualHeight >= J && 0 !== J)
        for (let te = 0; te < this.lines.length; te++) {
          const { top: C, height: $ } = this.lines[te];
          if (
            C + $ < this[this.directionKey.top] ||
            C + $ > this[this.directionKey.top] + J
          )
            return ee;
          let F = !1;
          this.ellipsis &&
            this.lines[te + 1] &&
            this.lines[te + 1].top + this.lines[te + 1].height >
              this[this.directionKey.top] + J &&
            ((F = !0), (ee = !0)),
            this.lines[te].draw(
              e,
              F,
              this.lines[te][this.directionKey.left] + K,
              this.lines[te][this.directionKey.top] + Y,
              this.ellipsis,
              T
            );
        }
      else {
        const C = Math.floor((J - this.actualHeight) / 2);
        "vertical" === this.layoutDirection ? (K += C) : (Y += C);
        for (let $ = 0; $ < this.lines.length; $++)
          this.lines[$].draw(
            e,
            !1,
            this.lines[$][this.directionKey.left] + K,
            this.lines[$][this.directionKey.top] + Y,
            this.ellipsis,
            T
          );
      }
    else if (
      "bottom" === this.verticalDirection &&
      "vertical" !== this.layoutDirection
    )
      for (let te = 0; te < this.lines.length; te++) {
        const { top: C, height: $ } = this.lines[te],
          F = J - this.lines[te].top - this.lines[te].height;
        if (0 === J) this.lines[te].draw(e, !1, K, F + Y, this.ellipsis, T);
        else {
          if (
            F + $ > this[this.directionKey.top] + J ||
            F < this[this.directionKey.top]
          )
            return ee;
          {
            let C = !1;
            this.ellipsis &&
              this.lines[te + 1] &&
              F - this.lines[te + 1].height < this[this.directionKey.top] &&
              ((C = !0), (ee = !0)),
              this.lines[te].draw(e, C, K, F + Y, this.ellipsis, T);
          }
        }
      }
    else {
      "bottom" === this.verticalDirection &&
        "vertical" === this.layoutDirection &&
        this.singleLine &&
        this.isWidthMax &&
        (K += this.lines[0].height + 1);
      for (let C = 0; C < this.lines.length; C++) {
        "bottom" === this.verticalDirection &&
          "vertical" === this.layoutDirection &&
          (K -= this.lines[C].height + this.lines[C].top);
        const { top: $, height: F } = this.lines[C];
        if (0 === J)
          this.lines[C].draw(
            e,
            !1,
            this.lines[C][this.directionKey.left] + K,
            this.lines[C][this.directionKey.top] + Y,
            this.ellipsis,
            T
          );
        else {
          if (
            $ + F < this[this.directionKey.top] ||
            $ + F > this[this.directionKey.top] + J
          )
            return ee;
          {
            let $ = !1;
            this.ellipsis &&
              this.lines[C + 1] &&
              this.lines[C + 1].top + this.lines[C + 1].height >
                this[this.directionKey.top] + J &&
              (($ = !0), (ee = !0)),
              this.lines[C].draw(
                e,
                $,
                this.lines[C][this.directionKey.left] + K,
                this.lines[C][this.directionKey.top] + Y,
                this.ellipsis,
                T
              );
          }
        }
      }
    }
    return ee;
  }
  getActualSize() {
    return this.ellipsis
      ? this.getActualSizeWidthEllipsis()
      : this.getRawActualSize();
  }
  getRawActualSize() {
    let e = 0,
      T = 0;
    for (let C = 0; C < this.lines.length; C++) {
      const $ = this.lines[C];
      $.actualWidth > e && (e = $.actualWidth), (T += $.height);
    }
    return {
      width: "vertical" === this.layoutDirection ? T : e,
      height: "vertical" === this.layoutDirection ? e : T,
    };
  }
  getActualSizeWidthEllipsis() {
    let e = 0,
      T = 0;
    const { width: C, height: $ } = this.getRawActualSize();
    this.width, this.height;
    let F = this[this.directionKey.height];
    if (
      (this.singleLine && (F = this.lines[0].height + 1),
      "middle" === this.verticalDirection)
    )
      if (this.actualHeight >= F && 0 !== F)
        for (let V = 0; V < this.lines.length; V++) {
          const { top: C, height: $ } = this.lines[V];
          if (
            C + $ < this[this.directionKey.top] ||
            C + $ > this[this.directionKey.top] + F
          );
          else if (
            this.ellipsis &&
            this.lines[V + 1] &&
            this.lines[V + 1].top + this.lines[V + 1].height >
              this[this.directionKey.top] + F
          ) {
            const C = !0 === this.ellipsis ? "..." : this.ellipsis || "",
              $ = this.lines[V].getWidthWithEllips(C);
            $ > e && (e = $), (T += this.lines[V].height);
          } else
            this.lines[V].actualWidth > e && (e = this.lines[V].actualWidth),
              (T += this.lines[V].height);
        }
      else {
        Math.floor((F - this.actualHeight) / 2);
        for (let C = 0; C < this.lines.length; C++)
          this.lines[C].actualWidth > e && (e = this.lines[C].actualWidth),
            (T += this.lines[C].height);
      }
    else if ("bottom" === this.verticalDirection)
      for (let V = 0; V < this.lines.length; V++) {
        const { top: C, height: $ } = this.lines[V],
          Y = F - this.lines[V].top - this.lines[V].height;
        if (0 === F)
          this.lines[V].actualWidth > e && (e = this.lines[V].actualWidth),
            (T += this.lines[V].height);
        else if (
          Y + $ > this[this.directionKey.top] + F ||
          Y < this[this.directionKey.top]
        );
        else if (
          this.ellipsis &&
          this.lines[V + 1] &&
          Y - this.lines[V + 1].height < this[this.directionKey.top]
        ) {
          const C = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            $ = this.lines[V].getWidthWithEllips(C);
          $ > e && (e = $), (T += this.lines[V].height);
        } else
          this.lines[V].actualWidth > e && (e = this.lines[V].actualWidth),
            (T += this.lines[V].height);
      }
    else
      for (let V = 0; V < this.lines.length; V++) {
        const { top: C, height: $ } = this.lines[V];
        if (0 === F)
          this.lines[V].actualWidth > e && (e = this.lines[V].actualWidth),
            (T += this.lines[V].height);
        else if (
          C + $ < this[this.directionKey.top] ||
          C + $ > this[this.directionKey.top] + F
        );
        else if (
          this.ellipsis &&
          this.lines[V + 1] &&
          this.lines[V + 1].top + this.lines[V + 1].height >
            this[this.directionKey.top] + F
        ) {
          const C = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            $ = this.lines[V].getWidthWithEllips(C);
          $ > e && (e = $), (T += this.lines[V].height);
        } else
          this.lines[V].actualWidth > e && (e = this.lines[V].actualWidth),
            (T += this.lines[V].height);
      }
    return {
      width: "vertical" === this.layoutDirection ? T : e,
      height: "vertical" === this.layoutDirection ? e : T,
    };
  }
}
class Paragraph {
  constructor(e, T, C) {
    (this.fontSize = C.fontSize || 16),
      (this.textBaseline = C.textBaseline || "alphabetic");
    const $ = calculateLineHeight(C.lineHeight, this.fontSize);
    (this.lineHeight =
      "number" == typeof $
        ? $ > this.fontSize
          ? $
          : this.fontSize
        : Math.floor(1.2 * this.fontSize)),
      (this.height = this.lineHeight);
    const {
      ascent: F,
      height: V,
      descent: Y,
      width: K,
    } = measureTextCanvas(e, C);
    let J = 0,
      ee = 0,
      te = 0;
    this.height > V &&
      ((J = (this.height - V) / 2), (ee = Math.ceil(J)), (te = Math.floor(J))),
      "top" === this.textBaseline
        ? ((this.ascent = J), (this.descent = V - J))
        : "bottom" === this.textBaseline
        ? ((this.ascent = V - J), (this.descent = J))
        : "middle" === this.textBaseline
        ? ((this.ascent = this.height / 2), (this.descent = this.height / 2))
        : ((this.ascent = F + ee), (this.descent = Y + te)),
      (this.length = e.length),
      (this.width = K || 0),
      (this.text = e || ""),
      (this.newLine = T || !1),
      (this.character = C),
      (this.left = 0),
      (this.top = 0),
      (this.ellipsis = "normal"),
      (this.ellipsisWidth = 0),
      (this.ellipsisOtherParagraphWidth = 0),
      "vertical" === C.direction &&
        ((this.direction = C.direction),
        (this.widthOrigin = this.width),
        (this.heightOrigin = this.height),
        (this.width = this.heightOrigin),
        (this.height = this.widthOrigin),
        (this.lineHeight = this.height)),
      (this.ellipsisStr = "...");
  }
  updateWidth() {
    const { width: e } = measureTextCanvas(this.text, this.character);
    (this.width = e),
      "vertical" === this.direction &&
        ((this.widthOrigin = this.width),
        (this.width = this.heightOrigin),
        (this.height = this.widthOrigin));
  }
  draw(e, T, C, $, F) {
    let V = this.text,
      Y = this.left + C;
    T += this.top;
    let K = this.direction;
    if (this.verticalEllipsis)
      (V = this.ellipsisStr), (K = "vertical"), (T -= this.ellipsisWidth / 2);
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis)
        (V += this.ellipsisStr),
          ("right" !== F && "end" !== F) || (Y -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const e = getStrByWithCanvas(
          V,
          ("vertical" === K ? this.height : this.width) -
            this.ellipsisWidth +
            this.ellipsisOtherParagraphWidth,
          this.character,
          V.length - 1
        );
        if (
          ((V = V.slice(0, e)),
          (V += this.ellipsisStr),
          "right" === F || "end" === F)
        ) {
          const { width: T } = measureTextCanvas(
            this.text.slice(e),
            this.character
          );
          "vertical" === K || (Y -= this.ellipsisWidth - T);
        }
      }
    }
    switch (this.character.script) {
      case "super":
        T -= this.ascent * (1 / 3);
        break;
      case "sub":
        T += this.descent / 2;
    }
    "vertical" === K &&
      (e.save(),
      e.rotateAbout(Math.PI / 2, Y, T),
      e.translate(
        -this.heightOrigin || -this.lineHeight / 2,
        -this.descent / 2
      ),
      e.translate(Y, T),
      (Y = 0),
      (T = 0)),
      this.character.stroke &&
        (applyStrokeStyle(e, this.character), e.strokeText(V, Y, T)),
      applyFillStyle(e, this.character),
      this.character.fill && e.fillText(V, Y, T),
      this.character.fill &&
        ("boolean" == typeof this.character.lineThrough ||
        "boolean" == typeof this.character.underline
          ? (this.character.underline &&
              e.fillRect(
                Y,
                1 + T,
                this.widthOrigin || this.width,
                this.character.fontSize
                  ? Math.max(1, Math.floor(this.character.fontSize / 10))
                  : 1
              ),
            this.character.lineThrough &&
              e.fillRect(
                Y,
                1 + T - this.ascent / 2,
                this.widthOrigin || this.width,
                this.character.fontSize
                  ? Math.max(1, Math.floor(this.character.fontSize / 10))
                  : 1
              ))
          : "underline" === this.character.textDecoration
          ? e.fillRect(
              Y,
              1 + T,
              this.widthOrigin || this.width,
              this.character.fontSize
                ? Math.max(1, Math.floor(this.character.fontSize / 10))
                : 1
            )
          : "line-through" === this.character.textDecoration &&
            e.fillRect(
              Y,
              1 + T - this.ascent / 2,
              this.widthOrigin || this.width,
              this.character.fontSize
                ? Math.max(1, Math.floor(this.character.fontSize / 10))
                : 1
            )),
      "vertical" === K && e.restore();
  }
  getWidthWithEllips(e) {
    let T = this.text;
    const C = "vertical" === e ? this.height : this.width;
    if ("hide" === this.ellipsis) return C;
    if ("add" === this.ellipsis) return C + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const e = getStrByWithCanvas(
        T,
        C - this.ellipsisWidth + this.ellipsisOtherParagraphWidth,
        this.character,
        T.length - 1
      );
      (T = T.slice(0, e)), (T += this.ellipsisStr);
      const { width: $ } = measureTextCanvas(
        this.text.slice(e),
        this.character
      );
      return C + this.ellipsisWidth - $;
    }
    return C;
  }
}
function seperateParagraph(e, T) {
  const C = e.text.slice(0, T),
    $ = e.text.slice(T);
  return [
    new Paragraph(C, e.newLine, e.character),
    new Paragraph($, !0, e.character),
  ];
}
const IMAGE_UPDATE_TAG_KEY = [
  "width",
  "height",
  "image",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Image extends Graphic {
  constructor(e) {
    super(e),
      (this.type = "image"),
      (this.numberType = IMAGE_NUMBER_TYPE),
      this.loadImage(this.attribute.image);
  }
  get width() {
    var e;
    return null !== (e = this.attribute.width) && void 0 !== e ? e : 0;
  }
  set width(e) {
    this.attribute.width === e &&
      ((this.attribute.width = e), this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var e;
    return null !== (e = this.attribute.height) && void 0 !== e ? e : 0;
  }
  set height(e) {
    this.attribute.height === e &&
      ((this.attribute.height = e), this.addUpdateShapeAndBoundsTag());
  }
  get repeatX() {
    var e;
    return null !== (e = this.attribute.repeatX) && void 0 !== e
      ? e
      : "no-repeat";
  }
  set repeatX(e) {
    this.attribute.repeatX === e && (this.attribute.repeatX = e);
  }
  get repeatY() {
    var e;
    return null !== (e = this.attribute.repeatY) && void 0 !== e
      ? e
      : "no-repeat";
  }
  set repeatY(e) {
    this.attribute.repeatY === e && (this.attribute.repeatY = e);
  }
  get image() {
    return this.attribute.image;
  }
  set image(e) {
    e !== this.attribute.image &&
      ((this.attribute.image = e), this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(e, T, C) {
    super.imageLoadSuccess(e, T, () => {
      this.successCallback && this.successCallback();
    });
  }
  imageLoadFail(e, T) {
    super.imageLoadFail(e, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(e, T, C) {
    return e.image && this.loadImage(e.image), super.setAttributes(e, T, C);
  }
  setAttribute(e, T, C, $) {
    return "image" === e && this.loadImage(T), super.setAttribute(e, T, C, $);
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).image;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateImageAABBBounds(
        T,
        getTheme(this).image,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return DefaultImageAttribute[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Image.NOWORK_ANIMATE_ATTR;
  }
}
function createImage(e) {
  return new Image(e);
}
Image.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    image: 1,
    repeatX: 1,
    repeatY: 1,
  },
  NOWORK_ANIMATE_ATTR
);
class RichTextIcon extends Image {
  constructor(e) {
    if (
      (super(e),
      (this._x = 0),
      (this._y = 0),
      (this._hovered = !1),
      (this._marginArray = [0, 0, 0, 0]),
      "always" === e.backgroundShowMode && (this._hovered = !0),
      e.margin)
    ) {
      const T = parsePadding(e.margin);
      this._marginArray = "number" == typeof T ? [T, T, T, T] : T;
    }
    this.onBeforeAttributeUpdate = (e, T, C) => {
      if ((isArray$1(C) && -1 !== C.indexOf("margin")) || "margin" === C)
        if (T.margin) {
          const e = parsePadding(T.margin);
          this._marginArray = "number" == typeof e ? [e, e, e, e] : e;
        } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var e;
    return (
      (null !== (e = this.attribute.width) && void 0 !== e ? e : 0) +
      this._marginArray[1] +
      this._marginArray[3]
    );
  }
  get height() {
    var e;
    return (
      (null !== (e = this.attribute.height) && void 0 !== e ? e : 0) +
      this._marginArray[0] +
      this._marginArray[2]
    );
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const {
        width: e = DefaultImageAttribute.width,
        height: T = DefaultImageAttribute.height,
      } = this.attribute,
      { backgroundWidth: C = e, backgroundHeight: $ = T } = this.attribute,
      F = (C - e) / 2,
      V = ($ - T) / 2;
    return this._AABBBounds.expand([0, 2 * F, 2 * V, 0]), this._AABBBounds;
  }
  setHoverState(e) {
    "hover" === this.attribute.backgroundShowMode &&
      this._hovered !== e &&
      (this._hovered = e);
  }
}
class Line {
  constructor(e, T, C, $, F, V, Y, K) {
    (this.left = e),
      (this.width = T),
      (this.baseline = C),
      (this.ascent = $),
      (this.descent = F),
      (this.top = C - $),
      (this.paragraphs = V.map((e) => e)),
      (this.textAlign =
        (this.paragraphs[0] instanceof RichTextIcon
          ? this.paragraphs[0].attribute.textAlign
          : this.paragraphs[0].character.textAlign) || "left"),
      (this.direction = Y),
      (this.directionKey = DIRECTION_KEY[this.direction]),
      (this.actualWidth = 0);
    let J = 0;
    this.paragraphs.forEach((e, T) => {
      if (0 === T && e instanceof Paragraph) {
        const T = regFirstSpace.exec(e.text);
        0 !== (null == T ? void 0 : T.index) &&
          ((e.text = e.text.slice(null == T ? void 0 : T.index)),
          e.updateWidth());
      }
      (this.actualWidth += e[this.directionKey.width]),
        (J = Math.max(e[this.directionKey.height], J));
    }),
      (this.height = J),
      (this.blankWidth = K ? 0 : this.width - this.actualWidth),
      this.calcOffset(T, K);
  }
  calcOffset(e, T) {
    const C = this.directionKey,
      $ = this.height;
    let F = this.left,
      V = 0;
    this.actualWidth < e &&
      !T &&
      ("right" === this.textAlign || "end" === this.textAlign
        ? (F = e - this.actualWidth)
        : "center" === this.textAlign
        ? (F = (e - this.actualWidth) / 2)
        : "justify" === this.textAlign &&
          (this.paragraphs.length < 2
            ? (F = (e - this.actualWidth) / 2)
            : (V = (e - this.actualWidth) / (this.paragraphs.length - 1)))),
      this.paragraphs.map(function (e) {
        e instanceof RichTextIcon
          ? ((e["_" + C.x] = F),
            (F += e[C.width] + V),
            (e["_" + C.y] =
              "top" === e.attribute.textBaseline
                ? 0
                : "bottom" === e.attribute.textBaseline
                ? $ - e.height
                : ($ - e.height) / 2))
          : ((e[C.left] = F), (F += e[C.width] + V));
      });
  }
  draw(e, T, C, $, F, V) {
    if (F && (T || this.paragraphs.some((e) => e.overflow))) {
      let e = 0;
      for (let C = this.paragraphs.length - 1; C >= 0; C--) {
        const $ = this.paragraphs[C];
        if ($.overflow) continue;
        if ($ instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== $.direction) {
          $.verticalEllipsis = !0;
          break;
        }
        const V = !0 === F ? "..." : F || "";
        $.ellipsisStr = V;
        const { width: Y } = measureTextCanvas(V, $.character),
          K = Y || 0;
        if (K <= this.blankWidth + e) {
          T && ($.ellipsis = "add");
          break;
        }
        if (K <= this.blankWidth + e + $.width) {
          ($.ellipsis = "replace"),
            ($.ellipsisWidth = K),
            ($.ellipsisOtherParagraphWidth = this.blankWidth + e);
          break;
        }
        ($.ellipsis = "hide"), (e += $.width);
      }
    }
    this.paragraphs.map((T, F) => {
      if (T instanceof RichTextIcon)
        return (
          T.setAttributes({
            x: C + T._x,
            y: $ + T._y,
          }),
          void V(T, e, C + T._x, $ + T._y, this.ascent)
        );
      T.draw(e, $ + this.ascent, C, 0 === F, this.textAlign);
    });
  }
  getWidthWithEllips(e) {
    let T = 0;
    for (let $ = this.paragraphs.length - 1; $ >= 0; $--) {
      const C = this.paragraphs[$];
      if (C instanceof RichTextIcon) break;
      const { width: F } = measureTextCanvas(e, C.character),
        V = F || 0;
      if (V <= this.blankWidth + T) {
        (C.ellipsis = "add"), (C.ellipsisWidth = V);
        break;
      }
      if (V <= this.blankWidth + T + C.width) {
        (C.ellipsis = "replace"),
          (C.ellipsisWidth = V),
          (C.ellipsisOtherParagraphWidth = this.blankWidth + T);
        break;
      }
      (C.ellipsis = "hide"), (T += C.width);
    }
    let C = 0;
    return (
      this.paragraphs.map((e, T) => {
        C +=
          e instanceof RichTextIcon
            ? e.width
            : e.getWidthWithEllips(this.direction);
      }),
      C
    );
  }
}
class Wrapper {
  constructor(e) {
    (this.frame = e),
      (this.width = this.frame.width),
      (this.height = this.frame.height),
      (this.lineWidth = 0),
      (this.y = this.frame.top),
      (this.maxAscent = 0),
      (this.maxDescent = 0),
      (this.maxAscentForBlank = 0),
      (this.maxDescentForBlank = 0),
      (this.lineBuffer = []),
      (this.direction = e.layoutDirection),
      (this.directionKey = DIRECTION_KEY[this.direction]);
  }
  store(e) {
    if (e instanceof RichTextIcon) {
      this.frame.icons.set(e.richtextId, e),
        this.lineBuffer.push(e),
        (this.lineWidth += e[this.directionKey.width]);
      let T = 0,
        C = 0;
      "top" === e.attribute.textBaseline
        ? ((T = 0), (C = e.height))
        : "bottom" === e.attribute.textBaseline
        ? ((T = e.height), (C = 0))
        : ((T = e.height / 2), (C = e.height / 2)),
        (this.maxAscent = Math.max(this.maxAscent, T)),
        (this.maxDescent = Math.max(this.maxDescent, C));
    } else
      this.lineBuffer.push(e),
        0 !== e.text.length
          ? ((this.lineWidth += e[this.directionKey.width]),
            (this.maxAscent = Math.max(this.maxAscent, e.ascent)),
            (this.maxDescent = Math.max(this.maxDescent, e.descent)))
          : ((this.maxAscentForBlank = Math.max(
              this.maxAscentForBlank,
              e.ascent
            )),
            (this.maxDescentForBlank = Math.max(
              this.maxDescentForBlank,
              e.descent
            )));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const e = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
      T = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
      C = new Line(
        this.frame.left,
        this[this.directionKey.width],
        this.y + e,
        e,
        T,
        this.lineBuffer,
        this.direction,
        "horizontal" === this.direction
          ? this.frame.isWidthMax
          : this.frame.isHeightMax
      );
    this.frame.lines.push(C),
      (this.frame.actualHeight += C.height),
      (this.y += C.height),
      (this.lineBuffer.length = 0),
      (this.lineWidth =
        this.maxAscent =
        this.maxDescent =
        this.maxAscentForBlank =
        this.maxDescentForBlank =
          0);
  }
  deal(e, T = !1) {
    e instanceof RichTextIcon
      ? ("horizontal" === this.direction && 0 === this.width) ||
        ("vertical" === this.direction && 0 === this.height) ||
        this.lineWidth + e[this.directionKey.width] <=
          this[this.directionKey.width]
        ? this.store(e)
        : 0 === this.lineBuffer.length
        ? (this.store(e), this.send())
        : (this.send(), this.deal(e))
      : "number" != typeof this.width ||
        this.width < 0 ||
        (e.newLine && this.send(),
        0 !== e.text.length &&
          (("horizontal" === this.direction && 0 === this.width) ||
          ("vertical" === this.direction && 0 === this.height) ||
          this.lineWidth + e[this.directionKey.width] <=
            this[this.directionKey.width]
            ? this.store(e)
            : this.lineWidth === this[this.directionKey.width]
            ? (this.send(), this.deal(e))
            : this.cut(e, T)));
  }
  cut(e, T) {
    const C = this[this.directionKey.width] - this.lineWidth || 0,
      $ = Math.ceil((C / e[this.directionKey.width]) * e.length) || 0,
      F = getStrByWithCanvas(
        e.text,
        C,
        e.character,
        $,
        "break-word" === this.frame.wordBreak
      );
    if (0 !== F) {
      const [C, $] = seperateParagraph(e, F);
      this.store(C), T ? this.send() : this.deal($);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(e));
  }
}
const RICHTEXT_UPDATE_TAG_KEY = [
  "width",
  "height",
  "ellipsis",
  "wordBreak",
  "verticalDirection",
  "maxHeight",
  "maxWidth",
  "textAlign",
  "textBaseline",
  "textConfig",
  "layoutDirection",
  "fill",
  "stroke",
  "fontSize",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class RichText extends Graphic {
  constructor(e) {
    super(e),
      (this.type = "richtext"),
      (this._currentHoverIcon = null),
      (this.numberType = RICHTEXT_NUMBER_TYPE);
  }
  get width() {
    var e;
    return null !== (e = this.attribute.width) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.width;
  }
  set width(e) {
    this.attribute.width !== e &&
      ((this.attribute.width = e), this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var e;
    return null !== (e = this.attribute.height) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.height;
  }
  set height(e) {
    this.attribute.height !== e &&
      ((this.attribute.height = e), this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(e) {
    this.attribute.maxWidth !== e &&
      ((this.attribute.maxWidth = e), this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(e) {
    this.attribute.maxHeight !== e &&
      ((this.attribute.maxHeight = e), this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var e;
    return null !== (e = this.attribute.ellipsis) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e &&
      ((this.attribute.ellipsis = e), this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var e;
    return null !== (e = this.attribute.wordBreak) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(e) {
    this.attribute.wordBreak !== e &&
      ((this.attribute.wordBreak = e), this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var e;
    return null !== (e = this.attribute.verticalDirection) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(e) {
    this.attribute.verticalDirection !== e &&
      ((this.attribute.verticalDirection = e),
      this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var e;
    return null !== (e = this.attribute.textAlign) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(e) {
    this.attribute.textAlign !== e &&
      ((this.attribute.textAlign = e), this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var e;
    return null !== (e = this.attribute.textBaseline) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(e) {
    this.attribute.textBaseline !== e &&
      ((this.attribute.textBaseline = e), this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var e;
    return null !== (e = this.attribute.textConfig) && void 0 !== e
      ? e
      : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(e) {
    (this.attribute.textConfig = e), this.addUpdateShapeAndBoundsTag();
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).richtext;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateRichTextAABBBounds(
        T,
        getTheme(this).richtext,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return DefaultRichTextAttribute[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return (
      this.shouldUpdateShape() &&
        (this.doUpdateFrameCache(), this.clearUpdateShapeTag()),
      this._frameCache
    );
  }
  combinedStyleToCharacter(e) {
    const {
      fill: T,
      stroke: C,
      fontSize: $,
      fontFamily: F,
      fontStyle: V,
      fontWeight: Y,
      lineWidth: K,
      opacity: J,
      fillOpacity: ee,
      strokeOpacity: te,
    } = this.attribute;
    return Object.assign(
      {
        fill: T,
        stroke: C,
        fontSize: $,
        fontFamily: F,
        fontStyle: V,
        fontWeight: Y,
        lineWidth: K,
        opacity: J,
        fillOpacity: ee,
        strokeOpacity: te,
      },
      e
    );
  }
  doUpdateFrameCache(e) {
    var T;
    const {
        textConfig: C = [],
        maxWidth: $,
        maxHeight: F,
        width: V,
        height: Y,
        ellipsis: K,
        wordBreak: J,
        verticalDirection: ee,
        textAlign: te,
        textBaseline: ie,
        layoutDirection: ne,
        singleLine: re,
        disableAutoWrapLine: ae,
      } = this.attribute,
      oe = [],
      se = null != e ? e : C;
    for (let ge = 0; ge < se.length; ge++)
      if ("image" in se[ge]) {
        const e = this.combinedStyleToCharacter(se[ge]),
          T =
            e.id &&
            this._frameCache &&
            this._frameCache.icons &&
            this._frameCache.icons.get(e.id);
        if (T) oe.push(T);
        else {
          const T = new RichTextIcon(e);
          (T.successCallback = () => {
            var e;
            this.addUpdateBoundTag(),
              null === (e = this.stage) || void 0 === e || e.renderNextFrame();
          }),
            (T.richtextId = e.id),
            oe.push(T);
        }
      } else {
        const e = this.combinedStyleToCharacter(se[ge]);
        if (
          (isNumber$1(e.text) && (e.text = `${e.text}`),
          e.text && e.text.includes("\n"))
        ) {
          const T = e.text.split("\n");
          for (let C = 0; C < T.length; C++)
            oe.push(new Paragraph(T[C], 0 !== C, e));
        } else e.text && oe.push(new Paragraph(e.text, !1, e));
      }
    const le = "number" == typeof $ && Number.isFinite($) && $ > 0,
      de = "number" == typeof F && Number.isFinite(F) && F > 0,
      ce =
        "number" == typeof V && Number.isFinite(V) && V > 0 && (!le || V <= $),
      ue =
        "number" == typeof Y && Number.isFinite(Y) && Y > 0 && (!de || Y <= F),
      he = new Frame(
        0,
        0,
        (ce ? V : le ? $ : 0) || 0,
        (ue ? Y : de ? F : 0) || 0,
        K,
        J,
        ee,
        te,
        ie,
        ne || "horizontal",
        !ce && le,
        !ue && de,
        re || !1,
        null === (T = this._frameCache) || void 0 === T ? void 0 : T.icons
      ),
      pe = new Wrapper(he);
    if (ae) {
      let e = 0,
        T = !1;
      for (let C = 0; C < oe.length; C++) {
        const $ = oe[C];
        T
          ? (($.overflow = !0),
            ($.left = 1 / 0),
            ($.top = 1 / 0),
            !$.newLine && he.lines[he.lines.length - 1].paragraphs.push($))
          : pe.deal($, !0),
          he.lines.length !== e &&
            ((e = he.lines.length),
            (pe.lineBuffer.length = 0),
            ($.overflow = !0),
            ($.left = 1e3),
            ($.top = 1e3),
            he.lines[he.lines.length - 1].paragraphs.push($),
            (T = !0)),
          $.newLine && ((T = !1), (pe.lineWidth = 0)),
          pe.send();
      }
    } else for (let ge = 0; ge < oe.length; ge++) pe.deal(oe[ge]);
    if ((pe.send(), !("horizontal" === he.layoutDirection ? ce : ue))) {
      const e = he.getActualSizeWidthEllipsis();
      let T = "horizontal" === he.layoutDirection ? e.width : e.height;
      ("horizontal" === he.layoutDirection ? le : de) &&
        (T = Math.min(T, "horizontal" === he.layoutDirection ? $ : F)),
        he.lines.forEach(function (e) {
          e.calcOffset(T, !1);
        });
    }
    this._frameCache = he;
  }
  clone() {
    return new RichText(Object.assign({}, this.attribute));
  }
  setStage(e, T) {
    super.setStage(e, T),
      this.getFrameCache().icons.forEach((C) => {
        C.setStage(e, T);
      });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", (e) => {
      var T, C, $, F, V;
      const Y = this.pickIcon(e.global);
      (Y && Y === this._currentHoverIcon) ||
        (Y
          ? (null === (T = this._currentHoverIcon) ||
              void 0 === T ||
              T.setHoverState(!1),
            (this._currentHoverIcon = Y),
            this._currentHoverIcon.setHoverState(!0),
            null === (C = this.stage) ||
              void 0 === C ||
              C.setCursor(Y.attribute.cursor),
            null === ($ = this.stage) || void 0 === $ || $.renderNextFrame())
          : !Y &&
            this._currentHoverIcon &&
            (this._currentHoverIcon.setHoverState(!1),
            (this._currentHoverIcon = null),
            null === (F = this.stage) || void 0 === F || F.setCursor(),
            null === (V = this.stage) || void 0 === V || V.renderNextFrame()));
    }),
      this.addEventListener("pointerleave", (e) => {
        var T, C;
        this._currentHoverIcon &&
          (this._currentHoverIcon.setHoverState(!1),
          (this._currentHoverIcon = null),
          null === (T = this.stage) || void 0 === T || T.setCursor(),
          null === (C = this.stage) || void 0 === C || C.renderNextFrame());
      });
  }
  pickIcon(e) {
    const T = this.getFrameCache(),
      { e: C, f: $ } = this.globalTransMatrix;
    let F;
    return (
      T.icons.forEach((T) => {
        var V, Y;
        const K = T.AABBBounds.clone();
        K.translate(T._marginArray[3], T._marginArray[0]),
          K.containsPoint({
            x: e.x - C,
            y: e.y - $,
          }) &&
            ((F = T),
            (F.globalX =
              (null !== (V = F.attribute.x) && void 0 !== V ? V : 0) +
              C +
              T._marginArray[3]),
            (F.globalY =
              (null !== (Y = F.attribute.y) && void 0 !== Y ? Y : 0) +
              $ +
              T._marginArray[0]));
      }),
      F
    );
  }
  getNoWorkAnimateAttr() {
    return RichText.NOWORK_ANIMATE_ATTR;
  }
}
function createRichText(e) {
  return new RichText(e);
}
RichText.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    ellipsis: 1,
    wordBreak: 1,
    verticalDirection: 1,
    textAlign: 1,
    textBaseline: 1,
    textConfig: 1,
    layoutDirection: 1,
  },
  NOWORK_ANIMATE_ATTR
);
const PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
class Path extends Graphic {
  constructor(e) {
    super(e), (this.type = "path"), (this.numberType = PATH_NUMBER_TYPE);
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { path: e } = this.attribute;
    return null != e && "" !== e;
  }
  getParsedPathShape() {
    const e = getTheme(this).path;
    if (!this.valid) return e.path;
    const T = this.attribute;
    return T.path instanceof CustomPath2D
      ? T.path
      : (isNil$1(this.cache) && this.doUpdatePathShape(),
        this.cache instanceof CustomPath2D ? this.cache : e.path);
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).path;
    this.doUpdatePathShape(), this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updatePathAABBBounds(
        T,
        getTheme(this).path,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  doUpdatePathShape() {
    const e = this.attribute;
    isString$1(e.path, !0)
      ? (this.cache = new CustomPath2D().fromString(e.path))
      : e.customPath &&
        ((this.cache = new CustomPath2D()), e.customPath(this.cache, this));
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  getDefaultAttribute(e) {
    return getTheme(this).path[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Path.NOWORK_ANIMATE_ATTR;
  }
}
function createPath(e) {
  return new Path(e);
}
Path.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    path: 1,
    customPath: 1,
  },
  NOWORK_ANIMATE_ATTR
);
const AREA_UPDATE_TAG_KEY = [
  "segments",
  "points",
  "curveType",
  "curveTension",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Area extends Graphic {
  constructor(e) {
    super(e), (this.type = "area"), (this.numberType = AREA_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const { points: e, segments: T } = this.attribute;
    return T ? 0 !== T.length : !!e && 0 !== e.length;
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).area;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateAreaAABBBounds(
        T,
        getTheme(this).area,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), C;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  _interpolate(e, T, C, $, F) {
    "points" === e && (F.points = pointsInterpolation(C, $, T));
  }
  getDefaultAttribute(e) {
    return getTheme(this).area[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const e = new CustomPath2D(),
      T = this.attribute,
      C = T.segments,
      $ = (T) => {
        if (T && T.length) {
          let C = !0;
          const $ = [];
          if (
            (T.forEach((T) => {
              var F, V;
              !1 !== T.defined &&
                (C ? e.moveTo(T.x, T.y) : e.lineTo(T.x, T.y),
                $.push({
                  x: null !== (F = T.x1) && void 0 !== F ? F : T.x,
                  y: null !== (V = T.y1) && void 0 !== V ? V : T.y,
                }),
                (C = !1));
            }),
            $.length)
          ) {
            for (let T = $.length - 1; T >= 0; T--) e.lineTo($[T].x, $[T].y);
            e.closePath();
          }
        }
      };
    return (
      T.points
        ? $(T.points)
        : C &&
          C.length &&
          C.forEach((e) => {
            $(e.points);
          }),
      e
    );
  }
  clone() {
    return new Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Area.NOWORK_ANIMATE_ATTR;
  }
}
function createArea(e) {
  return new Area(e);
}
Area.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    segments: 1,
    curveType: 1,
  },
  NOWORK_ANIMATE_ATTR
);
const ARC_UPDATE_TAG_KEY = [
  "innerRadius",
  "outerRadius",
  "startAngle",
  "endAngle",
  "cornerRadius",
  "padAngle",
  "padRadius",
  "cap",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Arc extends Graphic {
  constructor(e) {
    super(e), (this.type = "arc"), (this.numberType = ARC_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      startAngle: e,
      endAngle: T,
      outerRadius: C,
      innerRadius: $,
    } = this.attribute;
    return (
      this._validNumber(e) &&
      this._validNumber(T) &&
      this._validNumber(C) &&
      this._validNumber($)
    );
  }
  getParsedCornerRadius() {
    const e = getTheme(this).arc,
      {
        cornerRadius: T = e.cornerRadius,
        innerPadding: C = e.innerPadding,
        outerPadding: $ = e.outerPadding,
      } = this.attribute;
    let { outerRadius: F = e.outerRadius, innerRadius: V = e.innerRadius } =
      this.attribute;
    if (((F += $), (V -= C), 0 === T || "0%" === T)) return 0;
    const Y = Math.abs(F - V),
      K = (e) =>
        Math.min(isNumber$1(e, !0) ? e : (Y * parseFloat(e)) / 100, Y / 2);
    if (isArray$1(T)) {
      const e = T.map((e) => K(e) || 0);
      return 0 === e.length
        ? [e[0], e[0], e[0], e[0]]
        : 2 === e.length
        ? [e[0], e[1], e[0], e[1]]
        : (3 === e.length && e.push(0), e);
    }
    return K(T);
  }
  getParsedAngle() {
    const e = getTheme(this).arc;
    let { startAngle: T = e.startAngle, endAngle: C = e.endAngle } =
      this.attribute;
    const { cap: $ = e.cap } = this.attribute,
      F = C - T >= 0 ? 1 : -1,
      V = C - T;
    if (
      ((T = clampAngleByRadian(T)), (C = T + V), $ && abs(V) < pi2 - epsilon)
    ) {
      let V = 1,
        Y = 1;
      $.length && ((V = Number($[0])), (Y = Number($[1])));
      let { outerRadius: K = e.outerRadius, innerRadius: J = e.innerRadius } =
        this.attribute;
      const {
        outerPadding: ee = e.outerPadding,
        innerPadding: te = e.innerPadding,
      } = this.attribute;
      (K += ee), (J -= te);
      const ie = Math.abs(K - J) / 2,
        ne = ie / K;
      if (ie > epsilon && K > epsilon)
        return {
          startAngle: T - F * ne * V,
          endAngle: C + F * ne * Y,
          sc: F * ne * V,
          ec: F * ne * Y,
        };
    }
    return {
      startAngle: T,
      endAngle: C,
    };
  }
  getParsePadAngle(e, T) {
    const C = getTheme(this).arc,
      {
        innerPadding: $ = C.innerPadding,
        outerPadding: F = C.outerPadding,
        padAngle: V = C.padAngle,
      } = this.attribute;
    let { outerRadius: Y = C.outerRadius, innerRadius: K = C.innerRadius } =
      this.attribute;
    (Y += F), (K -= $);
    const { padRadius: J = sqrt(Y * Y + K * K) } = this.attribute,
      ee = abs(T - e);
    let te = e,
      ie = T,
      ne = e,
      re = T;
    const ae = V / 2;
    let oe = ee,
      se = ee;
    if (ae > epsilon && J > epsilon) {
      const C = T > e ? 1 : -1;
      let $ = asin((Number(J) / K) * sin(ae)),
        F = asin((Number(J) / Y) * sin(ae));
      return (
        (oe -= 2 * $) > epsilon
          ? (($ *= C), (ne += $), (re -= $))
          : ((oe = 0), (ne = re = (e + T) / 2)),
        (se -= 2 * F) > epsilon
          ? ((F *= C), (te += F), (ie -= F))
          : ((se = 0), (te = ie = (e + T) / 2)),
        {
          outerStartAngle: te,
          outerEndAngle: ie,
          innerStartAngle: ne,
          innerEndAngle: re,
          innerDeltaAngle: oe,
          outerDeltaAngle: se,
        }
      );
    }
    return {
      outerStartAngle: te,
      outerEndAngle: ie,
      innerStartAngle: ne,
      innerEndAngle: re,
      innerDeltaAngle: oe,
      outerDeltaAngle: se,
    };
  }
  doUpdateAABBBounds(e) {
    const T = getTheme(this).arc;
    this._AABBBounds.clear();
    const C = this.attribute,
      $ = application.graphicService.updateArcAABBBounds(
        C,
        getTheme(this).arc,
        this._AABBBounds,
        e,
        this
      ),
      { boundsPadding: F = T.boundsPadding } = C,
      V = parsePadding(F);
    return V && $.expand(V), this.clearUpdateBoundTag(), $;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, ARC_UPDATE_TAG_KEY);
  }
  getDefaultAttribute(e) {
    return getTheme(this).arc[e];
  }
  toCustomPath() {
    const e = this.attribute,
      { startAngle: T, endAngle: C } = this.getParsedAngle();
    let $ = e.innerRadius - (e.innerPadding || 0),
      F = e.outerRadius - (e.outerPadding || 0);
    const V = abs(C - T),
      Y = C > T;
    if (F < $) {
      const e = F;
      (F = $), ($ = e);
    }
    const K = new CustomPath2D();
    if (F <= epsilon) K.moveTo(0, 0);
    else if (V >= pi2 - epsilon)
      K.moveTo(0 + F * cos(T), 0 + F * sin(T)),
        K.arc(0, 0, F, T, C, !Y),
        $ > epsilon &&
          (K.moveTo(0 + $ * cos(C), 0 + $ * sin(C)), K.arc(0, 0, $, C, T, Y));
    else {
      const e = F * cos(T),
        V = F * sin(T),
        J = $ * cos(C),
        ee = $ * sin(C);
      K.moveTo(0 + e, 0 + V),
        K.arc(0, 0, F, T, C, !Y),
        K.lineTo(0 + J, 0 + ee),
        K.arc(0, 0, $, C, T, Y),
        K.closePath();
    }
    return K;
  }
  clone() {
    return new Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Arc.NOWORK_ANIMATE_ATTR;
  }
}
function createArc(e) {
  return new Arc(e);
}
Arc.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    cap: 1,
  },
  NOWORK_ANIMATE_ATTR
);
class Arc3d extends Arc {
  constructor(e) {
    super(e), (this.type = "arc3d"), (this.numberType = ARC3D_NUMBER_TYPE);
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).arc;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updateArc3dAABBBounds(
        T,
        getTheme(this).polygon,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  getNoWorkAnimateAttr() {
    return Arc3d.NOWORK_ANIMATE_ATTR;
  }
}
function createArc3d(e) {
  return new Arc3d(e);
}
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign(
  {
    cap: 1,
  },
  NOWORK_ANIMATE_ATTR
);
const POLYGON_UPDATE_TAG_KEY = [
  "points",
  "cornerRadius",
  ...GRAPHIC_UPDATE_TAG_KEY,
];
class Polygon extends Graphic {
  constructor(e) {
    super(e), (this.type = "polygon"), (this.numberType = POLYGON_NUMBER_TYPE);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { points: e } = this.attribute;
    return e && e.length >= 2;
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).polygon;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updatePolygonAABBBounds(
        T,
        getTheme(this).polygon,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("");
  }
  _interpolate(e, T, C, $, F) {
    "points" === e && (F.points = pointsInterpolation(C, $, T));
  }
  getDefaultAttribute(e) {
    return getTheme(this).polygon[e];
  }
  needUpdateTags(e) {
    return super.needUpdateTags(e, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(e) {
    return super.needUpdateTag(e, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const e = this.attribute.points,
      T = new CustomPath2D();
    return (
      e.forEach((e, C) => {
        0 === C ? T.moveTo(e.x, e.y) : T.lineTo(e.x, e.y);
      }),
      T.closePath(),
      T
    );
  }
  clone() {
    return new Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Polygon.NOWORK_ANIMATE_ATTR;
  }
}
function createPolygon(e) {
  return new Polygon(e);
}
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class Pyramid3d extends Polygon {
  constructor(e) {
    super(e),
      (this.type = "pyramid3d"),
      (this.numberType = PYRAMID3D_NUMBER_TYPE);
  }
  doUpdateAABBBounds() {
    const e = getTheme(this).polygon;
    this._AABBBounds.clear();
    const T = this.attribute,
      C = application.graphicService.updatePyramid3dAABBBounds(
        T,
        getTheme(this).polygon,
        this._AABBBounds,
        this
      ),
      { boundsPadding: $ = e.boundsPadding } = T,
      F = parsePadding($);
    return F && C.expand(F), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  findFace() {
    const { points: e } = this.attribute,
      T = e.map((T, C) => {
        const $ = 3 === C ? e[0] : e[C + 1],
          F = T.x - $.x;
        return 0 === F ? 0 : (T.y - $.y) / F;
      }),
      C = e.map((e) => ({
        p: e,
        d: 0,
      }));
    let $ = !1,
      F = 0;
    for (let Y = 0; Y < T.length - 1; Y++) {
      for (let e = Y + 1; e < T.length; e++) {
        if (T[Y] === T[e]) {
          $ = !0;
          const T = PointService.distancePP(C[Y].p, C[Y + 1].p);
          (C[Y].d = T), (C[Y + 1].d = T), (F = max(F, T));
          const V = PointService.distancePP(C[e].p, C[e + 1].p);
          (C[e].d = V), (C[e + 1].d = V), (F = max(F, V));
        }
        if ($) break;
      }
      if ($) break;
    }
    for (let Y = e.length - 1; Y >= 0; Y--) {
      const T = e[Y];
      C.unshift({
        p: T,
        d: 0,
      });
    }
    for (let Y = 0; Y < e.length; Y++) {
      const T = (F - C[Y + e.length].d) / 2;
      (C[Y].d += T), (C[Y + e.length].d += T);
    }
    const V = {
      polygons: [],
      vertices: [],
      edges: [],
    };
    return (
      C.forEach((e) => {
        V.vertices.push([e.p.x, e.p.y, e.d]);
      }),
      V.polygons.push({
        polygon: [0, 4, 5, 1],
        normal: [0, -1, 0],
      }),
      V.polygons.push({
        polygon: [7, 6, 2, 3],
        normal: [0, 1, 0],
      }),
      V.polygons.push({
        polygon: [0, 4, 7, 3],
        normal: [-1, 0, 0],
      }),
      V.polygons.push({
        polygon: [1, 5, 6, 2],
        normal: [1, 0, 0],
      }),
      V.polygons.push({
        polygon: [0, 1, 2, 3],
        normal: [0, 0, -1],
      }),
      V.polygons.push({
        polygon: [4, 5, 6, 7],
        normal: [0, 0, 1],
      }),
      (V.edges = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0],
        [4, 5],
        [5, 6],
        [6, 7],
        [7, 4],
        [0, 4],
        [3, 7],
        [1, 5],
        [2, 6],
      ]),
      V
    );
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
}
function createPyramid3d(e) {
  return new Pyramid3d(e);
}
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
class ShadowRoot extends Group {
  constructor(e) {
    super({
      x: 0,
      y: 0,
    }),
      (this.type = "shadowroot"),
      (this.shadowHost = e);
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(),
      this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(),
      this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix(e = !0) {
    if (this.shouldUpdateGlobalMatrix()) {
      const T = this.transMatrix;
      this._globalTransMatrix
        ? this._globalTransMatrix.setValue(T.a, T.b, T.c, T.d, T.e, T.f)
        : (this._globalTransMatrix = T.clone()),
        this.doUpdateGlobalMatrix(),
        e && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const e = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(e.a, e.b, e.c, e.d, e.e, e.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return (
      this._globalAABBBounds
        ? this._globalAABBBounds.setValue(
            this._AABBBounds.x1,
            this._AABBBounds.y1,
            this._AABBBounds.x2,
            this._AABBBounds.y2
          )
        : (this._globalAABBBounds = this._AABBBounds.clone()),
      this.shadowHost &&
        this._globalAABBBounds.transformWithMatrix(
          this.shadowHost.globalTransMatrix
        ),
      this._globalAABBBounds
    );
  }
}
function createShadowRoot(e) {
  return new ShadowRoot(e);
}
class DefaultOuterBorderBoundsContribution {
  updateBounds(e, T, C, $) {
    const { outerBorder: F, shadowBlur: V = T.shadowBlur } = e;
    if (F) {
      const e = T.outerBorder,
        { distance: $ = e.distance, lineWidth: Y = e.lineWidth } = F;
      C.expand($ + (V + Y) / 2);
    }
    return C;
  }
}
class DefaultSymbolOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
  updateBounds(e, T, C, $) {
    const {
      outerBorder: F,
      shadowBlur: V = T.shadowBlur,
      strokeBoundsBuffer: Y = T.strokeBoundsBuffer,
    } = e;
    if (F) {
      const e = T.outerBorder,
        { distance: $ = e.distance, lineWidth: K = e.lineWidth } = F;
      boundStroke(C, $ + (V + K) / 2, !0, Y);
    }
    return C;
  }
}
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
class DefaultMatrixAllocate {
  constructor() {
    this.pools = [];
  }
  allocate(e, T, C, $, F, V) {
    if (!this.pools.length) return new Matrix(e, T, C, $, F, V);
    const Y = this.pools.pop();
    return (Y.a = e), (Y.b = T), (Y.c = C), (Y.d = $), (Y.e = F), (Y.f = V), Y;
  }
  allocateByObj(e) {
    if (!this.pools.length) return new Matrix(e.a, e.b, e.c, e.d, e.e, e.f);
    const T = this.pools.pop();
    return (
      (T.a = e.a),
      (T.b = e.b),
      (T.c = e.c),
      (T.d = e.d),
      (T.e = e.e),
      (T.f = e.f),
      T
    );
  }
  free(e) {
    this.pools.push(e);
  }
  get length() {
    return this.pools.length;
  }
  release(...e) {
    this.pools = [];
  }
}
class DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(e) {
    return (
      (e[0] = 1),
      (e[1] = 0),
      (e[2] = 0),
      (e[3] = 0),
      (e[4] = 0),
      (e[5] = 1),
      (e[6] = 0),
      (e[7] = 0),
      (e[8] = 0),
      (e[9] = 0),
      (e[10] = 1),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      e
    );
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const e = this.pools.pop();
    return DefaultMat4Allocate.identity(e), e;
  }
  allocateByObj(e) {
    let T;
    T = this.pools.length ? this.pools.pop() : createMat4();
    for (let C = 0; C < T.length; C++) T[C] = e[C];
    return T;
  }
  free(e) {
    e && this.pools.push(e);
  }
  get length() {
    return this.pools.length;
  }
  release(...e) {
    this.pools = [];
  }
}
const matrixAllocate = new DefaultMatrixAllocate(),
  mat4Allocate = new DefaultMat4Allocate();
var __decorate$16 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$S =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$F =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
function identity(e) {
  return (
    (e[0] = 1),
    (e[1] = 0),
    (e[2] = 0),
    (e[3] = 0),
    (e[4] = 0),
    (e[5] = 1),
    (e[6] = 0),
    (e[7] = 0),
    (e[8] = 0),
    (e[9] = 0),
    (e[10] = 1),
    (e[11] = 0),
    (e[12] = 0),
    (e[13] = 0),
    (e[14] = 0),
    (e[15] = 1),
    e
  );
}
function rotateX(e, T, C) {
  const $ = Math.sin(C),
    F = Math.cos(C),
    V = T[4],
    Y = T[5],
    K = T[6],
    J = T[7],
    ee = T[8],
    te = T[9],
    ie = T[10],
    ne = T[11];
  return (
    T !== e &&
      ((e[0] = T[0]),
      (e[1] = T[1]),
      (e[2] = T[2]),
      (e[3] = T[3]),
      (e[12] = T[12]),
      (e[13] = T[13]),
      (e[14] = T[14]),
      (e[15] = T[15])),
    (e[4] = V * F + ee * $),
    (e[5] = Y * F + te * $),
    (e[6] = K * F + ie * $),
    (e[7] = J * F + ne * $),
    (e[8] = ee * F - V * $),
    (e[9] = te * F - Y * $),
    (e[10] = ie * F - K * $),
    (e[11] = ne * F - J * $),
    e
  );
}
function rotateY(e, T, C) {
  const $ = Math.sin(C),
    F = Math.cos(C),
    V = T[0],
    Y = T[1],
    K = T[2],
    J = T[3],
    ee = T[8],
    te = T[9],
    ie = T[10],
    ne = T[11];
  return (
    T !== e &&
      ((e[4] = T[4]),
      (e[5] = T[5]),
      (e[6] = T[6]),
      (e[7] = T[7]),
      (e[12] = T[12]),
      (e[13] = T[13]),
      (e[14] = T[14]),
      (e[15] = T[15])),
    (e[0] = V * F - ee * $),
    (e[1] = Y * F - te * $),
    (e[2] = K * F - ie * $),
    (e[3] = J * F - ne * $),
    (e[8] = V * $ + ee * F),
    (e[9] = Y * $ + te * F),
    (e[10] = K * $ + ie * F),
    (e[11] = J * $ + ne * F),
    e
  );
}
function rotateZ(e, T, C) {
  const $ = Math.sin(C),
    F = Math.cos(C),
    V = T[0],
    Y = T[1],
    K = T[2],
    J = T[3],
    ee = T[4],
    te = T[5],
    ie = T[6],
    ne = T[7];
  return (
    T !== e &&
      ((e[8] = T[8]),
      (e[9] = T[9]),
      (e[10] = T[10]),
      (e[11] = T[11]),
      (e[12] = T[12]),
      (e[13] = T[13]),
      (e[14] = T[14]),
      (e[15] = T[15])),
    (e[0] = V * F + ee * $),
    (e[1] = Y * F + te * $),
    (e[2] = K * F + ie * $),
    (e[3] = J * F + ne * $),
    (e[4] = ee * F - V * $),
    (e[5] = te * F - Y * $),
    (e[6] = ie * F - K * $),
    (e[7] = ne * F - J * $),
    e
  );
}
function translate(e, T, C) {
  const $ = C[0],
    F = C[1],
    V = C[2];
  let Y, K, J, ee, te, ie, ne, re, ae, oe, se, le;
  return (
    T === e
      ? ((e[12] = T[0] * $ + T[4] * F + T[8] * V + T[12]),
        (e[13] = T[1] * $ + T[5] * F + T[9] * V + T[13]),
        (e[14] = T[2] * $ + T[6] * F + T[10] * V + T[14]),
        (e[15] = T[3] * $ + T[7] * F + T[11] * V + T[15]))
      : ((Y = T[0]),
        (K = T[1]),
        (J = T[2]),
        (ee = T[3]),
        (te = T[4]),
        (ie = T[5]),
        (ne = T[6]),
        (re = T[7]),
        (ae = T[8]),
        (oe = T[9]),
        (se = T[10]),
        (le = T[11]),
        (e[0] = Y),
        (e[1] = K),
        (e[2] = J),
        (e[3] = ee),
        (e[4] = te),
        (e[5] = ie),
        (e[6] = ne),
        (e[7] = re),
        (e[8] = ae),
        (e[9] = oe),
        (e[10] = se),
        (e[11] = le),
        (e[12] = Y * $ + te * F + ae * V + T[12]),
        (e[13] = K * $ + ie * F + oe * V + T[13]),
        (e[14] = J * $ + ne * F + se * V + T[14]),
        (e[15] = ee * $ + re * F + le * V + T[15])),
    e
  );
}
function mat3Tomat4(e, T) {
  (e[0] = T.a),
    (e[1] = T.b),
    (e[2] = 0),
    (e[3] = 0),
    (e[4] = T.c),
    (e[5] = T.d),
    (e[6] = 0),
    (e[7] = 0),
    (e[8] = 0),
    (e[9] = 0),
    (e[10] = 1),
    (e[11] = 0),
    (e[12] = T.e),
    (e[13] = T.f),
    (e[14] = 0),
    (e[15] = 1);
}
function scale(e, T, C) {
  const $ = C[0],
    F = C[1],
    V = C[2];
  return (
    (e[0] = T[0] * $),
    (e[1] = T[1] * $),
    (e[2] = T[2] * $),
    (e[3] = T[3] * $),
    (e[4] = T[4] * F),
    (e[5] = T[5] * F),
    (e[6] = T[6] * F),
    (e[7] = T[7] * F),
    (e[8] = T[8] * V),
    (e[9] = T[9] * V),
    (e[10] = T[10] * V),
    (e[11] = T[11] * V),
    (e[12] = T[12]),
    (e[13] = T[13]),
    (e[14] = T[14]),
    (e[15] = T[15]),
    e
  );
}
function multiplyMat4Mat4(e, T, C) {
  const $ = T[0],
    F = T[1],
    V = T[2],
    Y = T[3],
    K = T[4],
    J = T[5],
    ee = T[6],
    te = T[7],
    ie = T[8],
    ne = T[9],
    re = T[10],
    ae = T[11],
    oe = T[12],
    se = T[13],
    le = T[14],
    de = T[15];
  let ce = C[0],
    ue = C[1],
    he = C[2],
    pe = C[3];
  return (
    (e[0] = ce * $ + ue * K + he * ie + pe * oe),
    (e[1] = ce * F + ue * J + he * ne + pe * se),
    (e[2] = ce * V + ue * ee + he * re + pe * le),
    (e[3] = ce * Y + ue * te + he * ae + pe * de),
    (ce = C[4]),
    (ue = C[5]),
    (he = C[6]),
    (pe = C[7]),
    (e[4] = ce * $ + ue * K + he * ie + pe * oe),
    (e[5] = ce * F + ue * J + he * ne + pe * se),
    (e[6] = ce * V + ue * ee + he * re + pe * le),
    (e[7] = ce * Y + ue * te + he * ae + pe * de),
    (ce = C[8]),
    (ue = C[9]),
    (he = C[10]),
    (pe = C[11]),
    (e[8] = ce * $ + ue * K + he * ie + pe * oe),
    (e[9] = ce * F + ue * J + he * ne + pe * se),
    (e[10] = ce * V + ue * ee + he * re + pe * le),
    (e[11] = ce * Y + ue * te + he * ae + pe * de),
    (ce = C[12]),
    (ue = C[13]),
    (he = C[14]),
    (pe = C[15]),
    (e[12] = ce * $ + ue * K + he * ie + pe * oe),
    (e[13] = ce * F + ue * J + he * ne + pe * se),
    (e[14] = ce * V + ue * ee + he * re + pe * le),
    (e[15] = ce * Y + ue * te + he * ae + pe * de),
    e
  );
}
function getModelMatrix(e, T, C) {
  var $;
  const {
      x: F = C.x,
      y: V = C.y,
      z: Y = C.z,
      dx: K = C.dx,
      dy: J = C.dy,
      dz: ee = C.dz,
      scaleX: te = C.scaleX,
      scaleY: ie = C.scaleY,
      scaleZ: ne = C.scaleZ,
      alpha: re = C.alpha,
      beta: ae = C.beta,
      angle: oe = C.angle,
      anchor3d: se = T.attribute.anchor,
      anchor: le,
    } = T.attribute,
    de = [0, 0, 0];
  if (se) {
    if ("string" == typeof se[0]) {
      const e = parseFloat(se[0]) / 100,
        C = T.AABBBounds;
      de[0] = C.x1 + (C.x2 - C.x1) * e;
    } else de[0] = se[0];
    if ("string" == typeof se[1]) {
      const e = parseFloat(se[1]) / 100,
        C = T.AABBBounds;
      de[1] = C.x1 + (C.x2 - C.x1) * e;
    } else de[1] = se[1];
    de[2] = null !== ($ = se[2]) && void 0 !== $ ? $ : 0;
  }
  if (
    (identity(e),
    translate(e, e, [F + K, V + J, Y + ee]),
    translate(e, e, [de[0], de[1], de[2]]),
    rotateX(e, e, ae),
    rotateY(e, e, re),
    translate(e, e, [-de[0], -de[1], de[2]]),
    scale(e, e, [te, ie, ne]),
    oe)
  ) {
    const C = mat4Allocate.allocate(),
      $ = [0, 0];
    if (le) {
      if ("string" == typeof se[0]) {
        const e = parseFloat(se[0]) / 100,
          C = T.AABBBounds;
        $[0] = C.x1 + (C.x2 - C.x1) * e;
      } else $[0] = se[0];
      if ("string" == typeof se[1]) {
        const e = parseFloat(se[1]) / 100,
          C = T.AABBBounds;
        $[1] = C.x1 + (C.x2 - C.x1) * e;
      } else $[1] = se[1];
    }
    translate(C, C, [$[0], $[1], 0]),
      rotateZ(C, C, oe),
      translate(C, C, [-$[0], -$[1], 0]),
      multiplyMat4Mat4(e, e, C);
  }
}
function shouldUseMat4(e) {
  const { alpha: T, beta: C } = e.attribute;
  return T || C;
}
let DefaultGraphicService = class {
  constructor(e) {
    (this.creator = e),
      (this.hooks = {
        onAttributeUpdate: new SyncHook(["graphic"]),
        onSetStage: new SyncHook(["graphic", "stage"]),
        onRemove: new SyncHook(["graphic"]),
        onRelease: new SyncHook(["graphic"]),
        onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
        onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
        beforeUpdateAABBBounds: new SyncHook([
          "graphic",
          "stage",
          "willUpdate",
          "aabbBounds",
        ]),
        afterUpdateAABBBounds: new SyncHook([
          "graphic",
          "stage",
          "aabbBounds",
          "globalAABBBounds",
          "selfChange",
        ]),
      }),
      (this.tempAABBBounds1 = new AABBBounds()),
      (this.tempAABBBounds2 = new AABBBounds()),
      (this._rectBoundsContribitions = [
        new DefaultOuterBorderBoundsContribution(),
      ]),
      (this._symbolBoundsContribitions = [
        new DefaultSymbolOuterBorderBoundsContribution(),
      ]),
      (this._imageBoundsContribitions = [
        new DefaultOuterBorderBoundsContribution(),
      ]),
      (this._circleBoundsContribitions = [
        new DefaultOuterBorderBoundsContribution(),
      ]),
      (this._arcBoundsContribitions = [
        new DefaultOuterBorderBoundsContribution(),
      ]),
      (this._pathBoundsContribitions = [
        new DefaultOuterBorderBoundsContribution(),
      ]);
  }
  onAttributeUpdate(e) {
    this.hooks.onAttributeUpdate.taps.length &&
      this.hooks.onAttributeUpdate.call(e);
  }
  onSetStage(e, T) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(e, T);
  }
  onRemove(e) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(e);
  }
  onRelease(e) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(e);
  }
  onAddIncremental(e, T, C) {
    this.hooks.onAddIncremental.taps.length &&
      this.hooks.onAddIncremental.call(e, T, C);
  }
  onClearIncremental(e, T) {
    this.hooks.onClearIncremental.taps.length &&
      this.hooks.onClearIncremental.call(e, T);
  }
  beforeUpdateAABBBounds(e, T, C, $) {
    this.hooks.beforeUpdateAABBBounds.taps.length &&
      this.hooks.beforeUpdateAABBBounds.call(e, T, C, $);
  }
  afterUpdateAABBBounds(e, T, C, $, F) {
    this.hooks.afterUpdateAABBBounds.taps.length &&
      this.hooks.afterUpdateAABBBounds.call(e, T, C, $, F);
  }
  updatePathProxyAABBBounds(e, T) {
    const C =
      "function" == typeof T.pathProxy ? T.pathProxy(T.attribute) : T.pathProxy;
    if (!C) return !1;
    const $ = new BoundsContext(e);
    return renderCommandList(C.commandList, $, 0, 0), !0;
  }
  updateRectAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    if (!this.updatePathProxyAABBBounds(C, $)) {
      let { width: T, height: $ } = e;
      const { x1: F, y1: V, x: Y, y: K } = e;
      (T = null != T ? T : F - Y),
        ($ = null != $ ? $ : V - K),
        (isFinite(T) || isFinite($) || isFinite(Y) || isFinite(K)) &&
          C.set(0, 0, T || 0, $ || 0);
    }
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    return (
      F.setValue(C.x1, C.y1, C.x2, C.y2),
      V.setValue(C.x1, C.y1, C.x2, C.y2),
      this._rectBoundsContribitions.length &&
        this._rectBoundsContribitions.forEach((Y) => {
          Y.updateBounds(e, T, F, $),
            C.union(F),
            F.setValue(V.x1, V.y1, V.x2, V.y2);
        }),
      this.transformAABBBounds(e, C, T, !1, $),
      C
    );
  }
  updateGroupAABBBounds(e, T, C, $) {
    const F = C;
    C = C.clone();
    const { width: V, height: Y, path: K, clip: J = T.clip, display: ee } = e;
    K && K.length
      ? K.forEach((e) => {
          C.union(e.AABBBounds);
        })
      : null != V && null != Y && C.set(0, 0, Math.max(0, V), Math.max(0, Y)),
      J ||
        $.forEachChildren((e) => {
          C.union(e.AABBBounds);
        });
    const te = this.tempAABBBounds1,
      ie = this.tempAABBBounds2;
    return (
      te.setValue(C.x1, C.y1, C.x2, C.y2),
      ie.setValue(C.x1, C.y1, C.x2, C.y2),
      this.transformAABBBounds(e, C, T, !1, $),
      F.copy(C),
      F
    );
  }
  updateGlyphAABBBounds(e, T, C, $) {
    return this._validCheck(e, T, C, $)
      ? ($.getSubGraphic().forEach((e) => {
          C.union(e.AABBBounds);
        }),
        C)
      : C;
  }
  updateHTMLTextAABBBounds(e, T, C, $) {
    const { textAlign: F, textBaseline: V } = e;
    if (null != e.forceBoundsHeight) {
      const T = isNumber$1(e.forceBoundsHeight)
          ? e.forceBoundsHeight
          : e.forceBoundsHeight(),
        $ = textLayoutOffsetY(V, T, T);
      C.set(C.x1, $, C.x2, $ + T);
    }
    if (null != e.forceBoundsWidth) {
      const T = isNumber$1(e.forceBoundsWidth)
          ? e.forceBoundsWidth
          : e.forceBoundsWidth(),
        $ = textDrawOffsetX(F, T);
      C.set($, C.y1, $ + T, C.y2);
    }
  }
  updateRichTextAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    if (!$) return C;
    const {
      width: F = T.width,
      height: V = T.height,
      maxWidth: Y = T.maxWidth,
      maxHeight: K = T.maxHeight,
      textAlign: J = T.textAlign,
      textBaseline: ee = T.textBaseline,
    } = e;
    if (F > 0 && V > 0) C.set(0, 0, F, V);
    else {
      const e = $.getFrameCache(),
        { width: T, height: J } = e.getActualSize();
      let ee = F || T || 0,
        te = V || J || 0;
      (te = "number" == typeof K && te > K ? K : te || 0),
        (ee = "number" == typeof Y && ee > Y ? Y : ee || 0),
        C.set(0, 0, ee, te);
    }
    let te = 0;
    switch (ee) {
      case "top":
        te = 0;
        break;
      case "middle":
        te = -C.height() / 2;
        break;
      case "bottom":
        te = -C.height();
    }
    let ie = 0;
    switch (J) {
      case "left":
        ie = 0;
        break;
      case "center":
        ie = -C.width() / 2;
        break;
      case "right":
        ie = -C.width();
    }
    C.translate(ie, te);
    const ne = this.tempAABBBounds1,
      re = this.tempAABBBounds2;
    return (
      ne.setValue(C.x1, C.y1, C.x2, C.y2),
      re.setValue(C.x1, C.y1, C.x2, C.y2),
      (null == e.forceBoundsHeight && null == e.forceBoundsWidth) ||
        this.updateHTMLTextAABBBounds(e, T, C),
      this.transformAABBBounds(e, C, T, !1, $),
      C
    );
  }
  updateTextAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    if (!$) return C;
    const { text: F = T.text } = $.attribute;
    Array.isArray(F)
      ? $.updateMultilineAABBBounds(F)
      : $.updateSingallineAABBBounds(F);
    const V = this.tempAABBBounds1,
      Y = this.tempAABBBounds2;
    V.setValue(C.x1, C.y1, C.x2, C.y2), Y.setValue(C.x1, C.y1, C.x2, C.y2);
    const {
      scaleX: K = T.scaleX,
      scaleY: J = T.scaleY,
      shadowBlur: ee = T.shadowBlur,
      strokeBoundsBuffer: te = T.strokeBoundsBuffer,
    } = e;
    if (ee) {
      boundStroke(V, ee / Math.abs(K + J), !0, te), C.union(V);
    }
    return (
      this.combindShadowAABBBounds(C, $),
      (null == e.forceBoundsHeight && null == e.forceBoundsWidth) ||
        this.updateHTMLTextAABBBounds(e, T, C),
      transformBoundsWithMatrix(C, C, $.transMatrix),
      C
    );
  }
  updatePathAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    this.updatePathProxyAABBBounds(C, $) ||
      this.updatePathAABBBoundsImprecise(e, T, C, $);
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    F.setValue(C.x1, C.y1, C.x2, C.y2),
      V.setValue(C.x1, C.y1, C.x2, C.y2),
      this._pathBoundsContribitions.length &&
        this._pathBoundsContribitions.forEach((Y) => {
          Y.updateBounds(e, T, F, $),
            C.union(F),
            F.setValue(V.x1, V.y1, V.x2, V.y2);
        });
    const { lineJoin: Y = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === Y, $), C;
  }
  updatePathAABBBoundsImprecise(e, T, C, $) {
    if (!$) return C;
    const F = $.getParsedPathShape();
    return C.union(F.getBounds()), C;
  }
  updatePyramid3dAABBBounds(e, T, C, $) {
    if (!$) return C;
    const F = $.stage;
    if (!F || !F.camera) return C;
    $.findFace().vertices.forEach((e) => {
      const T = e[0],
        $ = e[1];
      C.add(T, $);
    });
    const V = this.tempAABBBounds1,
      Y = this.tempAABBBounds2;
    return (
      V.setValue(C.x1, C.y1, C.x2, C.y2),
      Y.setValue(C.x1, C.y1, C.x2, C.y2),
      this.transformAABBBounds(e, C, T, !1, $),
      C
    );
  }
  updateArc3dAABBBounds(e, T, C, $) {
    if (!$) return C;
    const F = $.stage;
    if (!F || !F.camera) return C;
    const { outerRadius: V = T.outerRadius, height: Y = 0 } = e,
      K = V + Y;
    C.setValue(-K, -K, K, K);
    const J = this.tempAABBBounds1,
      ee = this.tempAABBBounds2;
    return (
      J.setValue(C.x1, C.y1, C.x2, C.y2),
      ee.setValue(C.x1, C.y1, C.x2, C.y2),
      this.transformAABBBounds(e, C, T, !1, $),
      C
    );
  }
  updatePolygonAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    this.updatePathProxyAABBBounds(C, $) ||
      this.updatePolygonAABBBoundsImprecise(e, T, C, $);
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    F.setValue(C.x1, C.y1, C.x2, C.y2), V.setValue(C.x1, C.y1, C.x2, C.y2);
    const { lineJoin: Y = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === Y, $), C;
  }
  updatePolygonAABBBoundsImprecise(e, T, C, $) {
    const { points: F = T.points } = e;
    return (
      F.forEach((e) => {
        C.add(e.x, e.y);
      }),
      C
    );
  }
  updateLineAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    this.updatePathProxyAABBBounds(C, $) ||
      (e.segments
        ? this.updateLineAABBBoundsBySegments(e, T, C, $)
        : this.updateLineAABBBoundsByPoints(e, T, C, $));
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    F.setValue(C.x1, C.y1, C.x2, C.y2), V.setValue(C.x1, C.y1, C.x2, C.y2);
    const { lineJoin: Y = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === Y, $), C;
  }
  updateLineAABBBoundsByPoints(e, T, C, $) {
    const { points: F = T.points, connectedType: V } = e,
      Y = C;
    return (
      F.forEach((e) => {
        (!1 === e.defined && "zero" !== V) || Y.add(e.x, e.y);
      }),
      Y
    );
  }
  updateLineAABBBoundsBySegments(e, T, C, $) {
    const { segments: F = T.segments, connectedType: V } = e,
      Y = C;
    return (
      F.forEach((e) => {
        e.points.forEach((e) => {
          (!1 === e.defined && "zero" !== V) || Y.add(e.x, e.y);
        });
      }),
      Y
    );
  }
  updateAreaAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    this.updatePathProxyAABBBounds(C, $) ||
      (e.segments
        ? this.updateAreaAABBBoundsBySegments(e, T, C, $)
        : this.updateAreaAABBBoundsByPoints(e, T, C, $));
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    F.setValue(C.x1, C.y1, C.x2, C.y2), V.setValue(C.x1, C.y1, C.x2, C.y2);
    const { lineJoin: Y = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === Y, $), C;
  }
  updateAreaAABBBoundsByPoints(e, T, C, $) {
    const { points: F = T.points } = e,
      V = C;
    return (
      F.forEach((e) => {
        var T, C;
        V.add(e.x, e.y),
          V.add(
            null !== (T = e.x1) && void 0 !== T ? T : e.x,
            null !== (C = e.y1) && void 0 !== C ? C : e.y
          );
      }),
      V
    );
  }
  updateAreaAABBBoundsBySegments(e, T, C, $) {
    const { segments: F = T.segments } = e,
      V = C;
    return (
      F.forEach((e) => {
        e.points.forEach((e) => {
          var T, C;
          V.add(e.x, e.y),
            V.add(
              null !== (T = e.x1) && void 0 !== T ? T : e.x,
              null !== (C = e.y1) && void 0 !== C ? C : e.y
            );
        });
      }),
      V
    );
  }
  updateCircleAABBBounds(e, T, C, $, F) {
    if (!this._validCheck(e, T, C, F)) return C;
    this.updatePathProxyAABBBounds(C, F) ||
      ($
        ? this.updateCircleAABBBoundsImprecise(e, T, C, F)
        : this.updateCircleAABBBoundsAccurate(e, T, C, F));
    const V = this.tempAABBBounds1,
      Y = this.tempAABBBounds2;
    return (
      V.setValue(C.x1, C.y1, C.x2, C.y2),
      Y.setValue(C.x1, C.y1, C.x2, C.y2),
      this._circleBoundsContribitions.length &&
        this._circleBoundsContribitions.forEach(($) => {
          $.updateBounds(e, T, V, F),
            C.union(V),
            V.setValue(Y.x1, Y.y1, Y.x2, Y.y2);
        }),
      this.transformAABBBounds(e, C, T, !1, F),
      C
    );
  }
  updateCircleAABBBoundsImprecise(e, T, C, $) {
    const { radius: F = T.radius } = e;
    return C.set(-F, -F, F, F), C;
  }
  updateCircleAABBBoundsAccurate(e, T, C, $) {
    const {
      startAngle: F = T.startAngle,
      endAngle: V = T.endAngle,
      radius: Y = T.radius,
    } = e;
    return (
      V - F > pi2 - epsilon ? C.set(-Y, -Y, Y, Y) : circleBounds(F, V, Y, C), C
    );
  }
  updateArcAABBBounds(e, T, C, $, F) {
    if (!this._validCheck(e, T, C, F)) return C;
    this.updatePathProxyAABBBounds(C, F) ||
      ($
        ? this.updateArcAABBBoundsImprecise(e, T, C, F)
        : this.updateArcAABBBoundsAccurate(e, T, C, F));
    const V = this.tempAABBBounds1,
      Y = this.tempAABBBounds2;
    V.setValue(C.x1, C.y1, C.x2, C.y2),
      Y.setValue(C.x1, C.y1, C.x2, C.y2),
      this._arcBoundsContribitions.length &&
        this._arcBoundsContribitions.forEach(($) => {
          $.updateBounds(e, T, V, F),
            C.union(V),
            V.setValue(Y.x1, Y.y1, Y.x2, Y.y2);
        });
    const { lineJoin: K = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === K, F), C;
  }
  updateArcAABBBoundsImprecise(e, T, C, $) {
    let { outerRadius: F = T.outerRadius, innerRadius: V = T.innerRadius } = e;
    const {
      outerPadding: Y = T.outerPadding,
      innerPadding: K = T.innerPadding,
    } = e;
    return (F += Y), (V -= K), F < V && (F = V), C.set(-F, -F, F, F), C;
  }
  updateArcAABBBoundsAccurate(e, T, C, $) {
    let { outerRadius: F = T.outerRadius, innerRadius: V = T.innerRadius } = e;
    const {
      outerPadding: Y = T.outerPadding,
      innerPadding: K = T.innerPadding,
    } = e;
    if (((F += Y), (V -= K), F < V)) {
      const e = F;
      (F = V), (V = e);
    }
    let { endAngle: J = T.endAngle, startAngle: ee = T.startAngle } = e;
    if (ee > J) {
      const e = ee;
      (ee = J), (J = e);
    }
    return (
      F <= epsilon
        ? C.set(0, 0, 0, 0)
        : Math.abs(J - ee) > pi2 - epsilon
        ? C.set(-F, -F, F, F)
        : (circleBounds(ee, J, F, C), circleBounds(ee, J, V, C)),
      C
    );
  }
  updateSymbolAABBBounds(e, T, C, $, F) {
    if (!this._validCheck(e, T, C, F)) return C;
    this.updatePathProxyAABBBounds(C, F) ||
      ($
        ? this.updateSymbolAABBBoundsImprecise(e, T, C, F)
        : this.updateSymbolAABBBoundsAccurate(e, T, C, F));
    const V = this.tempAABBBounds1,
      Y = this.tempAABBBounds2;
    V.setValue(C.x1, C.y1, C.x2, C.y2),
      Y.setValue(C.x1, C.y1, C.x2, C.y2),
      this._symbolBoundsContribitions.length &&
        this._symbolBoundsContribitions.forEach(($) => {
          $.updateBounds(e, T, V, F),
            C.union(V),
            V.setValue(Y.x1, Y.y1, Y.x2, Y.y2);
        });
    const { lineJoin: K = T.lineJoin } = e;
    return this.transformAABBBounds(e, C, T, "miter" === K, F), C;
  }
  updateSymbolAABBBoundsImprecise(e, T, C, $) {
    const { size: F = T.size } = e;
    if (isArray$1(F)) C.set(-F[0] / 2, -F[1] / 2, F[0] / 2, F[1] / 2);
    else {
      const e = F / 2;
      C.set(-e, -e, e, e);
    }
    return C;
  }
  updateSymbolAABBBoundsAccurate(e, T, C, $) {
    if (!$) return C;
    const { size: F = T.size } = e;
    return $.getParsedPath().bounds(F, C), C;
  }
  updateImageAABBBounds(e, T, C, $) {
    if (!this._validCheck(e, T, C, $)) return C;
    if (!this.updatePathProxyAABBBounds(C, $)) {
      const { width: $ = T.width, height: F = T.height } = e;
      C.set(0, 0, $, F);
    }
    const F = this.tempAABBBounds1,
      V = this.tempAABBBounds2;
    return (
      F.setValue(C.x1, C.y1, C.x2, C.y2),
      V.setValue(C.x1, C.y1, C.x2, C.y2),
      this._imageBoundsContribitions.length &&
        this._imageBoundsContribitions.forEach((Y) => {
          Y.updateBounds(e, T, F, $),
            C.union(F),
            F.setValue(V.x1, V.y1, V.x2, V.y2);
        }),
      this.transformAABBBounds(e, C, T, !1, $),
      C
    );
  }
  combindShadowAABBBounds(e, T) {
    if (T && T.shadowRoot) {
      const C = T.shadowRoot.AABBBounds;
      e.union(C);
    }
  }
  transformAABBBounds(e, T, C, $, F) {
    if (!T.empty()) {
      const {
          scaleX: F = C.scaleX,
          scaleY: V = C.scaleY,
          stroke: Y = C.stroke,
          shadowBlur: K = C.shadowBlur,
          lineWidth: J = C.lineWidth,
          pickStrokeBuffer: ee = C.pickStrokeBuffer,
          strokeBoundsBuffer: te = C.strokeBoundsBuffer,
        } = e,
        ie = this.tempAABBBounds1,
        ne = this.tempAABBBounds2;
      if (Y && J) {
        boundStroke(ie, (J + ee) / Math.abs(F + V), $, te),
          T.union(ie),
          ie.setValue(ne.x1, ne.y1, ne.x2, ne.y2);
      }
      if (K) {
        const {
          shadowOffsetX: $ = C.shadowOffsetX,
          shadowOffsetY: Y = C.shadowOffsetY,
        } = e;
        boundStroke(ie, (K / Math.abs(F + V)) * 2, !1, te + 1),
          ie.translate($, Y),
          T.union(ie);
      }
    }
    if ((this.combindShadowAABBBounds(T, F), T.empty())) return;
    let V = !0;
    const Y = F.transMatrix;
    F &&
      F.isContainer &&
      (V = !(
        1 === Y.a &&
        0 === Y.b &&
        0 === Y.c &&
        1 === Y.d &&
        0 === Y.e &&
        0 === Y.f
      )),
      V && transformBoundsWithMatrix(T, T, Y);
  }
  _validCheck(e, T, C, $) {
    if (!$) return !0;
    if (null != e.forceBoundsHeight || null != e.forceBoundsWidth) return !0;
    if (!$.valid) return C.clear(), !1;
    const { visible: F = T.visible } = e;
    return !!F || (C.clear(), !1);
  }
};
DefaultGraphicService = __decorate$16(
  [
    injectable(),
    __param$F(0, inject(GraphicCreator$1)),
    __metadata$S("design:paramtypes", [Object]),
  ],
  DefaultGraphicService
);
class GraphicCreator {
  constructor() {
    this.store = new Map();
  }
  RegisterGraphicCreator(e, T) {
    this.store.set(e, T), (this[e] = T);
  }
  CreateGraphic(e, T) {
    const C = this.store.get(e);
    return C ? C(T) : null;
  }
}
const graphicCreator = new GraphicCreator();
let text;
function getTextBounds(e) {
  return (
    text || (text = graphicCreator.CreateGraphic("text", {})),
    text.initAttributes(e),
    text.AABBBounds
  );
}
const result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null,
};
class BaseRender {
  init(e) {
    e && (this._renderContribitions = e.getContributions()),
      this._renderContribitions || (this._renderContribitions = []),
      this.builtinContributions &&
        this.builtinContributions.forEach((e) =>
          this._renderContribitions.push(e)
        ),
      this._renderContribitions.length &&
        (this._renderContribitions.sort((e, T) => T.order - e.order),
        (this._beforeRenderContribitions = this._renderContribitions.filter(
          (e) => e.time === BaseRenderContributionTime.beforeFillStroke
        )),
        (this._afterRenderContribitions = this._renderContribitions.filter(
          (e) => e.time === BaseRenderContributionTime.afterFillStroke
        )));
  }
  beforeRenderStep(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    this._beforeRenderContribitions &&
      this._beforeRenderContribitions.forEach((re) => {
        (re.supportedAppName &&
          e.stage &&
          e.stage.params &&
          e.stage.params.context &&
          e.stage.params.context.appName &&
          !(
            Array.isArray(re.supportedAppName)
              ? re.supportedAppName
              : [re.supportedAppName]
          ).includes(e.stage.params.context.appName)) ||
          re.drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne);
      });
  }
  afterRenderStep(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    this._afterRenderContribitions &&
      this._afterRenderContribitions.forEach((re) => {
        (re.supportedAppName &&
          e.stage &&
          e.stage.params &&
          e.stage.params.context &&
          e.stage.params.context.appName &&
          !(
            Array.isArray(re.supportedAppName)
              ? re.supportedAppName
              : [re.supportedAppName]
          ).includes(e.stage.params.context.appName)) ||
          re.drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne);
      });
  }
  valid(e, T, C, $) {
    const {
        fill: F = T.fill,
        background: V,
        stroke: Y = T.stroke,
        opacity: K = T.opacity,
        fillOpacity: J = T.fillOpacity,
        lineWidth: ee = T.lineWidth,
        strokeOpacity: te = T.strokeOpacity,
        visible: ie = T.visible,
      } = e.attribute,
      ne = fillVisible(K, J, F),
      re = strokeVisible(K, te),
      ae = runFill(F, V),
      oe = runStroke(Y, ee);
    return (
      !(!e.valid || !ie) &&
      !(!ae && !oe) &&
      !!(ne || re || C || $ || V) && {
        fVisible: ne,
        sVisible: re,
        doFill: ae,
        doStroke: oe,
      }
    );
  }
  transform(e, T, C, $ = !1) {
    const {
        x: F = T.x,
        y: V = T.y,
        z: Y = T.z,
        scaleX: K = T.scaleX,
        scaleY: J = T.scaleY,
        angle: ee = T.angle,
        postMatrix: te,
      } = e.attribute,
      ie = C.modelMatrix,
      ne = C.camera;
    (result.x = F),
      (result.y = V),
      (result.z = Y),
      (result.lastModelMatrix = ie);
    const re = ne && ($ || shouldUseMat4(e)),
      ae = re
        ? e.transMatrix.onlyTranslate() && !te
        : 1 === K && 1 === J && 0 === ee && !te;
    if (re) {
      const $ = mat4Allocate.allocate(),
        F = mat4Allocate.allocate();
      getModelMatrix(F, e, T),
        multiplyMat4Mat4($, ie || $, F),
        (result.x = 0),
        (result.y = 0),
        (result.z = 0),
        (C.modelMatrix = $),
        C.setTransform(1, 0, 0, 1, 0, 0, !0),
        mat4Allocate.free(F);
    }
    if (ae && !ie) {
      const $ = e.getOffsetXY(T);
      (result.x += $.x),
        (result.y += $.y),
        (result.z = Y),
        C.setTransformForCurrent();
    } else if (re)
      (result.x = 0),
        (result.y = 0),
        (result.z = 0),
        C.setTransform(1, 0, 0, 1, 0, 0, !0);
    else if (ne && C.project) {
      const $ = e.getOffsetXY(T);
      (result.x += $.x),
        (result.y += $.y),
        this.transformWithoutTranslate(
          C,
          result.x,
          result.y,
          result.z,
          K,
          J,
          ee
        );
    } else
      C.transformFromMatrix(e.transMatrix, !0),
        (result.x = 0),
        (result.y = 0),
        (result.z = 0);
    return result;
  }
  transformUseContext2d(e, T, C, $) {
    const F = $.camera;
    if (((this.camera = F), F)) {
      const T = e.AABBBounds,
        F = T.x2 - T.x1,
        V = T.y2 - T.y1,
        Y = $.project(0, 0, C),
        K = $.project(F, 0, C),
        J = $.project(F, V, C),
        ee = {
          x: 0,
          y: 0,
        },
        te = {
          x: F,
          y: 0,
        },
        ie = {
          x: F,
          y: V,
        };
      $.camera = null;
      const ne =
          1 /
          (ee.x * (ie.y - te.y) -
            te.x * ie.y +
            ie.x * te.y +
            (te.x - ie.x) * ee.y),
        re =
          -(
            ee.y * (J.x - K.x) -
            te.y * J.x +
            ie.y * K.x +
            (te.y - ie.y) * Y.x
          ) * ne,
        ae =
          (te.y * J.y + ee.y * (K.y - J.y) - ie.y * K.y + (ie.y - te.y) * Y.y) *
          ne,
        oe =
          (ee.x * (J.x - K.x) - te.x * J.x + ie.x * K.x + (te.x - ie.x) * Y.x) *
          ne,
        se =
          -(
            te.x * J.y +
            ee.x * (K.y - J.y) -
            ie.x * K.y +
            (ie.x - te.x) * Y.y
          ) * ne,
        le =
          (ee.x * (ie.y * K.x - te.y * J.x) +
            ee.y * (te.x * J.x - ie.x * K.x) +
            (ie.x * te.y - te.x * ie.y) * Y.x) *
          ne,
        de =
          (ee.x * (ie.y * K.y - te.y * J.y) +
            ee.y * (te.x * J.y - ie.x * K.y) +
            (ie.x * te.y - te.x * ie.y) * Y.y) *
          ne;
      $.setTransform(re, ae, oe, se, le, de, !0);
    }
  }
  restoreTransformUseContext2d(e, T, C, $) {
    this.camera && ($.camera = this.camera);
  }
  transformWithoutTranslate(e, T, C, $, F, V, Y) {
    const K = e.project(T, C, $);
    e.translate(K.x, K.y, !1),
      e.scale(F, V, !1),
      e.rotate(Y, !1),
      e.translate(-K.x, -K.y, !1),
      e.setTransformForCurrent();
  }
  _draw(e, T, C, $, F) {
    const { context: V } = $;
    if (!V) return;
    const { renderable: Y } = e.attribute;
    if (!1 === Y) return;
    V.highPerformanceSave();
    const K = this.transform(e, T, V, C),
      { x: J, y: ee, z: te, lastModelMatrix: ie } = K;
    (this.z = te),
      drawPathProxy(e, V, J, ee, $, F) ||
        (this.drawShape(e, V, J, ee, $, F),
        (this.z = 0),
        V.modelMatrix !== ie && mat4Allocate.free(V.modelMatrix),
        (V.modelMatrix = ie)),
      V.highPerformanceRestore();
  }
}
const parse = (function () {
  const e = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner:
      /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords:
      /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor:
      /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/,
  };
  let T = "";
  function C(e) {
    const C = new Error(T + ": " + e);
    throw ((C.source = T), C);
  }
  function $() {
    return (
      F("linear", e.linearGradient, V) ||
      F("radial", e.radialGradient, K) ||
      F("conic", e.conicGradient, Y)
    );
  }
  function F(T, $, F) {
    return (function ($, V) {
      const Y = le($);
      if (Y) {
        le(e.startCall) || C("Missing (");
        const $ = (function ($) {
          const V = F();
          return (
            V && (le(e.comma) || C("Missing comma before color stops")),
            {
              type: T,
              orientation: V,
              colorStops: ne(re),
            }
          );
        })();
        return le(e.endCall) || C("Missing )"), $;
      }
    })($);
  }
  function V() {
    return (
      se("directional", e.sideOrCorner, 1) || se("angular", e.angleValue, 1)
    );
  }
  function Y() {
    return se("angular", e.fromAngleValue, 1);
  }
  function K() {
    let C,
      $,
      F = J();
    return (
      F &&
        ((C = []),
        C.push(F),
        ($ = T),
        le(e.comma) && ((F = J()), F ? C.push(F) : (T = $))),
      C
    );
  }
  function J() {
    let e =
      (function () {
        const e = se("shape", /^(circle)/i, 0);
        return e && (e.style = oe() || ee()), e;
      })() ||
      (function () {
        const e = se("shape", /^(ellipse)/i, 0);
        return e && (e.style = ae() || ee()), e;
      })();
    if (e) e.at = te();
    else {
      const T = ee();
      if (T) {
        e = T;
        const C = te();
        C && (e.at = C);
      } else {
        const T = ie();
        T &&
          (e = {
            type: "default-radial",
            at: T,
          });
      }
    }
    return e;
  }
  function ee() {
    return se("extent-keyword", e.extentKeywords, 1);
  }
  function te() {
    if (se("position", /^at/, 0)) {
      const e = ie();
      return e || C("Missing positioning value"), e;
    }
  }
  function ie() {
    const e = {
      x: ae(),
      y: ae(),
    };
    if (e.x || e.y)
      return {
        type: "position",
        value: e,
      };
  }
  function ne(T) {
    let $ = T();
    const F = [];
    if ($)
      for (F.push($); le(e.comma); )
        ($ = T()), $ ? F.push($) : C("One extra comma");
    return F;
  }
  function re() {
    const T =
      se("hex", e.hexColor, 1) ||
      se("rgba", e.rgbaColor, 1) ||
      se("rgb", e.rgbColor, 1) ||
      se("literal", e.literalColor, 0);
    return T || C("Expected color definition"), (T.length = ae()), T;
  }
  function ae() {
    return (
      se("%", e.percentageValue, 1) ||
      se("position-keyword", e.positionKeywords, 1) ||
      oe()
    );
  }
  function oe() {
    return se("px", e.pixelValue, 1) || se("em", e.emValue, 1);
  }
  function se(e, T, C) {
    const $ = le(T);
    if ($)
      return {
        type: e,
        value: $[C],
      };
  }
  function le(e) {
    const C = /^[\n\r\t\s]+/.exec(T);
    C && de(C[0].length);
    const $ = e.exec(T);
    return $ && de($[0].length), $;
  }
  function de(e) {
    T = T.substr(e);
  }
  return function (e) {
    return (
      (T = e.toString()),
      (function () {
        const e = ne($);
        return T.length > 0 && C("Invalid input not EOF"), e;
      })()
    );
  };
})();
class GradientParser {
  static IsGradient(e) {
    return !("string" == typeof e && !e.includes("gradient"));
  }
  static IsGradientStr(e) {
    return "string" == typeof e && e.includes("gradient");
  }
  static Parse(e) {
    if (GradientParser.IsGradientStr(e))
      try {
        const T = parse(e)[0];
        if (T) {
          if ("linear" === T.type) return GradientParser.ParseLinear(T);
          if ("radial" === T.type) return GradientParser.ParseRadial(T);
          if ("conic" === T.type) return GradientParser.ParseConic(T);
        }
      } catch (T) {
        return e;
      }
    return e;
  }
  static ParseConic(e) {
    const { orientation: T, colorStops: C = [] } = e,
      $ = pi / 2,
      F = (parseFloat(T.value) / 180) * pi - $;
    return {
      gradient: "conical",
      x: 0.5,
      y: 0.5,
      startAngle: F,
      endAngle: F + pi2,
      stops: C.map((e) => ({
        color: e.value,
        offset: parseFloat(e.length.value) / 100,
      })),
    };
  }
  static ParseRadial(e) {
    const { colorStops: T = [] } = e;
    return {
      gradient: "radial",
      x0: 0.5,
      y0: 0.5,
      x1: 0.5,
      y1: 0.5,
      r0: 0,
      r1: 1,
      stops: T.map((e) => ({
        color: e.value,
        offset: parseFloat(e.length.value) / 100,
      })),
    };
  }
  static ParseLinear(e) {
    const { orientation: T, colorStops: C = [] } = e,
      $ = pi / 2;
    let F = "angular" === T.type ? (parseFloat(T.value) / 180) * pi : 0;
    for (; F < 0; ) F += pi2;
    for (; F > pi2; ) F -= pi2;
    let V = 0,
      Y = 0,
      K = 0,
      J = 0;
    return (
      F < $
        ? ((V = 0), (Y = 1), (K = Math.sin(F)), (J = Math.cos(F)))
        : F < pi
        ? ((V = 0), (Y = 0), (K = Math.cos(F - $)), (J = Math.sin(F - $)))
        : F < pi + $
        ? ((V = 1), (Y = 0), (K = V - Math.sin(F - pi)), (J = Math.cos(F - pi)))
        : ((V = 1),
          (K = V - Math.cos(F - $ - pi)),
          (J -= Math.sin(F - $ - pi))),
      {
        gradient: "linear",
        x0: V,
        y0: Y,
        x1: K,
        y1: J,
        stops: C.map((e) => ({
          color: e.value,
          offset: parseFloat(e.length.value) / 100,
        })),
      }
    );
  }
}
function getScaledStroke(e, T, C) {
  let $ = T;
  const { a: F, b: V, c: Y, d: K } = e.currentMatrix,
    J = Math.sign(F) * Math.sqrt(F * F + V * V),
    ee = Math.sign(K) * Math.sqrt(Y * Y + K * K);
  return J + ee === 0 ? 0 : (($ = ($ / Math.abs(J + ee)) * 2 * C), $);
}
function createColor(e, T, C, $, F) {
  if (!T || !0 === T) return "black";
  let V, Y;
  if (isArray$1(T)) for (let K = 0; K < T.length && ((Y = T[K]), !Y); K++);
  else Y = T;
  return (
    (Y = GradientParser.Parse(Y)),
    "string" == typeof Y
      ? Y
      : ("linear" === Y.gradient
          ? (V = createLinearGradient(e, Y, C, $, F))
          : "conical" === Y.gradient
          ? (V = createConicGradient(e, Y, C, $, F))
          : "radial" === Y.gradient &&
            (V = createRadialGradient(e, Y, C, $, F)),
        V || "orange")
  );
}
function createLinearGradient(e, T, C, $ = 0, F = 0) {
  var V, Y, K, J;
  const ee = C.AABBBounds;
  if (!ee) return;
  let te = ee.x2 - ee.x1,
    ie = ee.y2 - ee.y1,
    ne = ee.x1 - $,
    re = ee.y1 - F;
  if (C.attribute) {
    const { scaleX: e = 1, scaleY: T = 1 } = C.attribute;
    if (e * T == 0) return;
    (te /= e), (ie /= T), (ne /= e), (re /= T);
  }
  const ae = e.createLinearGradient(
    ne + (null !== (V = T.x0) && void 0 !== V ? V : 0) * te,
    re + (null !== (Y = T.y0) && void 0 !== Y ? Y : 0) * ie,
    ne + (null !== (K = T.x1) && void 0 !== K ? K : 1) * te,
    re + (null !== (J = T.y1) && void 0 !== J ? J : 0) * ie
  );
  return (
    T.stops.forEach((e) => {
      ae.addColorStop(e.offset, e.color);
    }),
    ae
  );
}
function createRadialGradient(e, T, C, $ = 0, F = 0) {
  var V, Y, K, J, ee, te;
  const ie = C.AABBBounds;
  if (!ie) return;
  let ne = ie.x2 - ie.x1,
    re = ie.y2 - ie.y1,
    ae = ie.x1 - $,
    oe = ie.y1 - F;
  if (C.attribute) {
    const { scaleX: e = 1, scaleY: T = 1 } = C.attribute;
    if (e * T == 0) return;
    (ae /= e), (oe /= T), (ne /= e), (re /= T);
  }
  const se = e.createRadialGradient(
    ae + (null !== (V = T.x0) && void 0 !== V ? V : 0.5) * ne,
    oe + (null !== (Y = T.y0) && void 0 !== Y ? Y : 0.5) * re,
    Math.max(ne, re) * (null !== (K = T.r0) && void 0 !== K ? K : 0),
    ae + (null !== (J = T.x1) && void 0 !== J ? J : 0.5) * ne,
    oe + (null !== (ee = T.y1) && void 0 !== ee ? ee : 0.5) * re,
    Math.max(ne, re) * (null !== (te = T.r1) && void 0 !== te ? te : 0.5)
  );
  return (
    T.stops.forEach((e) => {
      se.addColorStop(e.offset, e.color);
    }),
    se
  );
}
function createConicGradient(e, T, C, $ = 0, F = 0) {
  var V, Y;
  const K = C.AABBBounds;
  if (!K) return;
  let J = K.x2 - K.x1,
    ee = K.y2 - K.y1,
    te = K.x1 - $,
    ie = K.y1 - F;
  if (C.attribute) {
    const { scaleX: e = 1, scaleY: T = 1 } = C.attribute;
    if (e * T == 0) return;
    (J /= e), (ee /= T), (te /= e), (ie /= T);
  }
  const ne = e.createConicGradient(
    te + (null !== (V = T.x) && void 0 !== V ? V : 0) * J,
    ie + (null !== (Y = T.y) && void 0 !== Y ? Y : 0) * ee,
    T.startAngle,
    T.endAngle
  );
  return (
    T.stops.forEach((e) => {
      ne.addColorStop(e.offset, e.color);
    }),
    ne.GetPattern(J + te, ee + ie, void 0)
  );
}
var __decorate$15 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$R =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$E =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
class DefaultBaseBackgroundRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.beforeFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    var re;
    const {
      background: ae,
      backgroundOpacity: oe = null !== (re = e.attribute.fillOpacity) &&
      void 0 !== re
        ? re
        : J.backgroundOpacity,
      opacity: se = J.opacity,
      backgroundMode: le = J.backgroundMode,
      backgroundFit: de = J.backgroundFit,
    } = e.attribute;
    if (ae)
      if (e.backgroundImg && e.resources) {
        const F = e.resources.get(ae);
        if ("success" !== F.state || !F.data) return;
        if ((T.save(), e.parent && !e.transMatrix.onlyTranslate())) {
          const C = getTheme(e.parent).group,
            { scrollX: $ = C.scrollX, scrollY: F = C.scrollY } =
              e.parent.attribute;
          T.setTransformFromMatrix(e.parent.globalTransMatrix, !0),
            T.translate($, F);
        }
        T.clip();
        const V = e.AABBBounds;
        T.setCommonStyle(e, e.attribute, C, $, J),
          (T.globalAlpha = oe * se),
          this.doDrawImage(T, F.data, V, le, de),
          T.restore(),
          e.transMatrix.onlyTranslate() || T.setTransformForCurrent();
      } else
        T.highPerformanceSave(),
          T.setCommonStyle(e, e.attribute, C, $, J),
          (T.globalAlpha = oe * se),
          (T.fillStyle = ae),
          T.fill(),
          T.highPerformanceRestore();
  }
  doDrawImage(e, T, C, $, F) {
    if ("no-repeat" === $) e.drawImage(T, C.x1, C.y1, C.width(), C.height());
    else {
      const V = C.width(),
        Y = C.height();
      let K = V,
        J = Y;
      if (F && "repeat" !== $ && (T.width || T.height)) {
        const C = T.width,
          F = T.height;
        "repeat-x" === $
          ? ((K = C * (Y / F)), (J = Y))
          : "repeat-y" === $ && ((J = F * (V / C)), (K = V));
        const ee = e.dpr,
          te = canvasAllocate.allocate({
            width: K,
            height: J,
            dpr: ee,
          }),
          ie = te.getContext("2d");
        ie &&
          ((ie.inuse = !0),
          ie.clearMatrix(),
          ie.setTransformForCurrent(!0),
          ie.clearRect(0, 0, K, J),
          ie.drawImage(T, 0, 0, K, J),
          (T = te.nativeCanvas)),
          canvasAllocate.free(te);
      }
      const ee = e.dpr,
        te = e.createPattern(T, $);
      te.setTransform &&
        te.setTransform(new DOMMatrix([1 / ee, 0, 0, 1 / ee, 0, 0])),
        (e.fillStyle = te),
        e.translate(C.x1, C.y1),
        e.fillRect(0, 0, V, Y),
        e.translate(-C.x1, -C.y1);
    }
  }
}
const defaultBaseBackgroundRenderContribution =
  new DefaultBaseBackgroundRenderContribution();
let DefaultBaseInteractiveRenderContribution = class {
  constructor(e) {
    (this.subRenderContribitions = e),
      (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    this._subRenderContribitions ||
      (this._subRenderContribitions =
        this.subRenderContribitions.getContributions()),
      this._subRenderContribitions.forEach((re) => {
        re.render(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne);
      });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate$15(
  [
    injectable(),
    __param$E(0, inject(ContributionProvider)),
    __param$E(0, named(InteractiveSubRenderContribution)),
    __metadata$R("design:paramtypes", [Object]),
  ],
  DefaultBaseInteractiveRenderContribution
);
class DefaultBaseTextureRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 10);
  }
  createCommonPattern(e, T, C, $, F) {
    const V = (e - 2 * T) / 2,
      Y = $.dpr,
      K = canvasAllocate.allocate({
        width: e,
        height: e,
        dpr: Y,
      }),
      J = K.getContext("2d");
    if (!J) return null;
    (J.inuse = !0),
      J.clearMatrix(),
      J.setTransformForCurrent(!0),
      J.clearRect(0, 0, e, e),
      F(V, J);
    const ee = $.createPattern(K.nativeCanvas, "repeat");
    return (
      ee.setTransform &&
        ee.setTransform(new DOMMatrix([1 / Y, 0, 0, 1 / Y, 0, 0])),
      canvasAllocate.free(K),
      ee
    );
  }
  createCirclePattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (e, T) => {
      (T.fillStyle = C), T.arc(e, e, e, 0, pi2), T.fill();
    });
  }
  createDiamondPattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (T, $) => {
      const F = e / 2,
        V = F;
      ($.fillStyle = C),
        $.moveTo(F, V - T),
        $.lineTo(T + F, V),
        $.lineTo(F, V + T),
        $.lineTo(F - T, V),
        $.closePath(),
        $.fill();
    });
  }
  createRectPattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (e, $) => {
      const F = T,
        V = F;
      ($.fillStyle = C), $.fillRect(F, V, 2 * e, 2 * e);
    });
  }
  createVerticalLinePattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, ($, F) => {
      const V = T;
      (F.fillStyle = C), F.fillRect(V, 0, 2 * $, e);
    });
  }
  createHorizontalLinePattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, ($, F) => {
      const V = T;
      (F.fillStyle = C), F.fillRect(0, V, e, 2 * $);
    });
  }
  createBiasLRLinePattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (T, $) => {
      ($.strokeStyle = C), ($.lineWidth = T), $.moveTo(0, 0), $.lineTo(e, e);
      const F = e / 2,
        V = -F;
      $.moveTo(F, V),
        $.lineTo(F + e, V + e),
        $.moveTo(-F, -V),
        $.lineTo(-F + e, -V + e),
        $.stroke();
    });
  }
  createBiasRLLinePattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (T, $) => {
      ($.strokeStyle = C), ($.lineWidth = T), $.moveTo(e, 0), $.lineTo(0, e);
      const F = e / 2,
        V = F;
      $.moveTo(e + F, V),
        $.lineTo(F, V + e),
        $.moveTo(e - F, -V),
        $.lineTo(-F, -V + e),
        $.stroke();
    });
  }
  createGridPattern(e, T, C, $) {
    return this.createCommonPattern(e, T, C, $, (e, $) => {
      const F = T,
        V = F;
      ($.fillStyle = C), $.fillRect(F, V, e, e), $.fillRect(F + e, V + e, e, e);
    });
  }
  initTextureMap(e, T) {
    this.textureMap = new Map();
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    this.textureMap || this.initTextureMap(T, e.stage);
    const {
      texture: re = J.texture,
      textureColor: ae = J.textureColor,
      textureSize: oe = J.textureSize,
      texturePadding: se = J.texturePadding,
    } = e.attribute;
    re && this.drawTexture(re, e, T, C, $, J, ae, oe, se);
  }
  drawTexture(e, T, C, $, F, V, Y, K, J) {
    let ee = this.textureMap.get(e);
    if (!ee)
      switch (e) {
        case "circle":
          ee = this.createCirclePattern(K, J, Y, C);
          break;
        case "diamond":
          ee = this.createDiamondPattern(K, J, Y, C);
          break;
        case "rect":
          ee = this.createRectPattern(K, J, Y, C);
          break;
        case "vertical-line":
          ee = this.createVerticalLinePattern(K, J, Y, C);
          break;
        case "horizontal-line":
          ee = this.createHorizontalLinePattern(K, J, Y, C);
          break;
        case "bias-lr":
          ee = this.createBiasLRLinePattern(K, J, Y, C);
          break;
        case "bias-rl":
          ee = this.createBiasRLLinePattern(K, J, Y, C);
          break;
        case "grid":
          ee = this.createGridPattern(K, J, Y, C);
      }
    ee &&
      (C.highPerformanceSave(),
      C.setCommonStyle(T, T.attribute, $, F, V),
      (C.fillStyle = ee),
      C.fill(),
      C.highPerformanceRestore());
  }
}
const defaultBaseTextureRenderContribution =
  new DefaultBaseTextureRenderContribution();
class DefaultArcRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const { outerBorder: ne, innerBorder: re } = e.attribute,
      ae = ne && !1 !== ne.visible,
      oe = re && !1 !== re.visible;
    if (!ae && !oe) return;
    const {
      innerPadding: se = J.innerPadding,
      outerPadding: le = J.outerPadding,
      startAngle: de = J.startAngle,
      endAngle: ce = J.endAngle,
      opacity: ue = J.opacity,
      x: he = J.x,
      y: pe = J.y,
      scaleX: ge = J.scaleX,
      scaleY: fe = J.scaleY,
    } = e.attribute;
    let { innerRadius: me = J.innerRadius, outerRadius: ye = J.outerRadius } =
      e.attribute;
    (ye += le), (me -= se);
    const be = !(!ne || !ne.stroke),
      ve = !(!re || !re.stroke);
    if (ae) {
      const { distance: F = J.outerBorder.distance } = ne,
        V = getScaledStroke(T, F, T.dpr),
        Y = F / ye;
      if (
        (e.setAttributes({
          outerRadius: ye + V,
          innerRadius: me - V,
          startAngle: de - Y,
          endAngle: ce + Y,
        }),
        T.beginPath(),
        drawArcPath$1(e, T, C, $, ye + V, me - V),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, ne, J.outerBorder);
      else if (be) {
        const F = J.outerBorder.opacity;
        (J.outerBorder.opacity = ue),
          T.setStrokeStyle(e, ne, (he - C) / ge, (pe - $) / fe, J.outerBorder),
          (J.outerBorder.opacity = F),
          T.stroke();
      }
    }
    if (oe) {
      const { distance: F = J.innerBorder.distance } = re,
        V = getScaledStroke(T, F, T.dpr),
        Y = F / ye;
      if (
        (e.setAttributes({
          outerRadius: ye - V,
          innerRadius: me + V,
          startAngle: de + Y,
          endAngle: ce - Y,
        }),
        T.beginPath(),
        drawArcPath$1(e, T, C, $, ye - V, me + V),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, re, J.innerBorder);
      else if (ve) {
        const F = J.innerBorder.opacity;
        (J.innerBorder.opacity = ue),
          T.setStrokeStyle(e, re, (he - C) / ge, (pe - $) / fe, J.innerBorder),
          (J.innerBorder.opacity = F),
          T.stroke();
      }
    }
    e.setAttributes({
      outerRadius: ye,
      innerRadius: me,
      startAngle: de,
      endAngle: ce,
    });
  }
}
const defaultArcRenderContribution = new DefaultArcRenderContribution(),
  defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution,
  defaultArcBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
class DefaultCircleRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const { outerBorder: ne, innerBorder: re } = e.attribute,
      ae = ne && !1 !== ne.visible,
      oe = re && !1 !== re.visible;
    if (!ae && !oe) return;
    const {
        radius: se = J.radius,
        startAngle: le = J.startAngle,
        endAngle: de = J.endAngle,
        opacity: ce = J.opacity,
        x: ue = J.x,
        y: he = J.y,
        scaleX: pe = J.scaleX,
        scaleY: ge = J.scaleY,
      } = e.attribute,
      fe = !(!ne || !ne.stroke),
      me = !(!re || !re.stroke);
    if (ae) {
      const { distance: F = J.outerBorder.distance } = ne,
        V = getScaledStroke(T, F, T.dpr);
      if (
        (T.beginPath(),
        T.arc(C, $, se + V, le, de),
        T.closePath(),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, ne, J.outerBorder);
      else if (fe) {
        const F = J.outerBorder.opacity;
        (J.outerBorder.opacity = ce),
          T.setStrokeStyle(e, ne, (ue - C) / pe, (he - $) / ge, J.outerBorder),
          (J.outerBorder.opacity = F),
          T.stroke();
      }
    }
    if (oe) {
      const { distance: F = J.innerBorder.distance } = re,
        V = getScaledStroke(T, F, T.dpr);
      if (
        (T.beginPath(),
        T.arc(C, $, se - V, le, de),
        T.closePath(),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, re, J.innerBorder);
      else if (me) {
        const F = J.innerBorder.opacity;
        (J.innerBorder.opacity = ce),
          T.setStrokeStyle(e, re, (ue - C) / pe, (he - $) / ge, J.innerBorder),
          (J.innerBorder.opacity = F),
          T.stroke();
      }
    }
  }
}
const defaultCircleRenderContribution = new DefaultCircleRenderContribution(),
  defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution,
  defaultCircleBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
class DefaultGroupBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments),
      (this.time = BaseRenderContributionTime.beforeFillStroke);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const {
      background: ne,
      backgroundMode: re = J.backgroundMode,
      backgroundFit: ae = J.backgroundFit,
    } = e.attribute;
    if (ne)
      if (e.backgroundImg && e.resources) {
        const C = e.resources.get(ne);
        if ("success" !== C.state || !C.data) return;
        T.highPerformanceSave(),
          T.setTransformFromMatrix(e.parent.globalTransMatrix, !0);
        const $ = e.AABBBounds;
        this.doDrawImage(T, C.data, $, re, ae),
          T.highPerformanceRestore(),
          T.setTransformForCurrent();
      } else
        T.highPerformanceSave(),
          (T.fillStyle = ne),
          T.fill(),
          T.highPerformanceRestore();
  }
}
const defaultGroupBackgroundRenderContribution =
    new DefaultGroupBackgroundRenderContribution(),
  halfPi = pi / 2;
function createRectPath(e, T, C, $, F, V, Y) {
  let K;
  if (
    ($ < 0 && ((T += $), ($ = -$)),
    F < 0 && ((C += F), (F = -F)),
    isNumber$1(V, !0))
  )
    K = [(V = abs(V)), V, V, V];
  else if (Array.isArray(V)) {
    const e = V;
    let T, C;
    switch (e.length) {
      case 0:
        K = [0, 0, 0, 0];
        break;
      case 1:
        (T = abs(e[0])), (K = [T, T, T, T]);
        break;
      case 2:
      case 3:
        (T = abs(e[0])), (C = abs(e[1])), (K = [T, C, T, C]);
        break;
      default:
        (K = e),
          (K[0] = abs(K[0])),
          (K[1] = abs(K[1])),
          (K[2] = abs(K[2])),
          (K[3] = abs(K[3]));
    }
  } else K = [0, 0, 0, 0];
  if ($ < 0 || K[0] + K[1] + K[2] + K[3] < 1e-12) return e.rect(T, C, $, F);
  const [J, ee, te, ie] = [
      [T, C],
      [T + $, C],
      [T + $, C + F],
      [T, C + F],
    ],
    ne = Math.min($ / 2, F / 2),
    re = [
      Math.min(ne, K[0]),
      Math.min(ne, K[1]),
      Math.min(ne, K[2]),
      Math.min(ne, K[3]),
    ],
    ae = [J[0] + re[0], J[1]],
    oe = [J[0], J[1] + re[0]],
    se = [ee[0] - re[1], ee[1]],
    le = [ee[0], ee[1] + re[1]],
    de = [te[0] - re[2], te[1]],
    ce = [te[0], te[1] - re[2]],
    ue = [ie[0] + re[3], ie[1]],
    he = [ie[0], ie[1] - re[3]];
  if (
    (e.moveTo(ae[0], ae[1]),
    Y && Y[0] ? Y[0](ae[0], ae[1], se[0], se[1]) : e.lineTo(se[0], se[1]),
    !arrayEqual(se, le))
  ) {
    Y && Y[0] && e.moveTo(se[0], se[1]);
    const T = se[0],
      C = se[1] + re[1];
    e.arc(T, C, re[1], -halfPi, 0, !1);
  }
  if (
    (Y && Y[1] ? Y[1](le[0], le[1], ce[0], ce[1]) : e.lineTo(ce[0], ce[1]),
    !arrayEqual(de, ce))
  ) {
    const T = ce[0] - re[2],
      C = ce[1];
    Y && Y[1] && e.moveTo(ce[0], ce[1]), e.arc(T, C, re[2], 0, halfPi, !1);
  }
  if (
    (Y && Y[2] ? Y[2](de[0], de[1], ue[0], ue[1]) : e.lineTo(ue[0], ue[1]),
    !arrayEqual(ue, he))
  ) {
    const T = ue[0],
      C = ue[1] - re[3];
    Y && Y[2] && e.moveTo(ue[0], ue[1]), e.arc(T, C, re[3], halfPi, pi, !1);
  }
  if (
    (Y && Y[3] ? Y[3](he[0], he[1], oe[0], oe[1]) : e.lineTo(oe[0], oe[1]),
    !arrayEqual(ae, oe))
  ) {
    const T = ae[0],
      C = ae[1] + re[0];
    Y && Y[3] && e.moveTo(oe[0], oe[1]),
      e.arc(T, C, re[0], pi, pi + halfPi, !1);
  }
  return !Y && e.closePath(), e;
}
var __decorate$14 =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
class DefaultRectRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const { outerBorder: ne, innerBorder: re } = e.attribute,
      ae = ne && !1 !== ne.visible,
      oe = re && !1 !== re.visible;
    if (!ae && !oe) return;
    const {
      cornerRadius: se = J.cornerRadius,
      opacity: le = J.opacity,
      x: de = J.x,
      y: ce = J.y,
      scaleX: ue = J.scaleX,
      scaleY: he = J.scaleY,
      x1: pe,
      y1: ge,
    } = e.attribute;
    let { width: fe, height: me } = e.attribute;
    (fe = (null != fe ? fe : pe - C) || 0),
      (me = (null != me ? me : ge - $) || 0);
    const ye = !(!ne || !ne.stroke),
      be = !(!re || !re.stroke);
    if (ae) {
      const { distance: F = J.outerBorder.distance } = ne,
        V = getScaledStroke(T, F, T.dpr),
        Y = C - V,
        K = $ - V,
        ee = 2 * V;
      if (
        (0 === se || (isArray$1(se) && se.every((e) => 0 === e))
          ? (T.beginPath(), T.rect(Y, K, fe + ee, me + ee))
          : (T.beginPath(), createRectPath(T, Y, K, fe + ee, me + ee, se)),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, ne, J.outerBorder);
      else if (ye) {
        const F = J.outerBorder.opacity;
        (J.outerBorder.opacity = le),
          T.setStrokeStyle(e, ne, (de - C) / ue, (ce - $) / he, J.outerBorder),
          (J.outerBorder.opacity = F),
          T.stroke();
      }
    }
    if (oe) {
      const { distance: F = J.innerBorder.distance } = re,
        V = getScaledStroke(T, F, T.dpr),
        Y = C + V,
        K = $ + V,
        ee = 2 * V;
      if (
        (0 === se || (isArray$1(se) && se.every((e) => 0 === e))
          ? (T.beginPath(), T.rect(Y, K, fe - ee, me - ee))
          : (T.beginPath(), createRectPath(T, Y, K, fe - ee, me - ee, se)),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, re, J.innerBorder);
      else if (be) {
        const F = J.innerBorder.opacity;
        (J.innerBorder.opacity = le),
          T.setStrokeStyle(e, re, (de - C) / ue, (ce - $) / he, J.innerBorder),
          (J.innerBorder.opacity = F),
          T.stroke();
      }
    }
  }
}
let SplitRectBeforeRenderContribution = class {
  constructor() {
    (this.time = BaseRenderContributionTime.beforeFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    const { stroke: re = J.stroke } = e.attribute;
    Array.isArray(re) && re.some((e) => !1 === e) && (ne.doStroke = !1);
  }
};
SplitRectBeforeRenderContribution = __decorate$14(
  [injectable()],
  SplitRectBeforeRenderContribution
);
let SplitRectAfterRenderContribution = class {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const {
      x1: ne,
      y1: re,
      x: ae = J.x,
      y: oe = J.y,
      stroke: se = J.stroke,
      cornerRadius: le = J.cornerRadius,
    } = e.attribute;
    let { width: de, height: ce } = e.attribute;
    if (
      ((de = (null != de ? de : ne - ae) || 0),
      (ce = (null != ce ? ce : re - oe) || 0),
      Array.isArray(se) && se.some((e) => !1 === e))
    ) {
      if (
        (T.setStrokeStyle(e, e.attribute, C, $, J),
        !(0 === le || (isArray$1(le) && le.every((e) => 0 === e))))
      ) {
        let F,
          V = 0;
        return (
          createRectPath(
            T,
            C,
            $,
            de,
            ce,
            le,
            new Array(4).fill(0).map((Y, K) => (Y, ee, te, ie) => {
              se[K] &&
                ((V === K - 1 && se[K] === F) ||
                  (T.setStrokeStyle(
                    e,
                    Object.assign(Object.assign({}, e.attribute), {
                      stroke: se[K],
                    }),
                    C,
                    $,
                    J
                  ),
                  T.beginPath(),
                  T.moveTo(Y, ee),
                  (F = se[K])),
                (V = K),
                T.lineTo(te, ie),
                T.stroke(),
                3 === K && T.beginPath());
            })
          ),
          void T.stroke()
        );
      }
      if (
        (T.beginPath(),
        T.moveTo(C, $),
        se[0] ? T.lineTo(C + de, $) : T.moveTo(C + de, $),
        se[1] ? T.lineTo(C + de, $ + ce) : T.moveTo(C + de, $ + ce),
        se[2] ? T.lineTo(C, $ + ce) : T.moveTo(C, $ + ce),
        se[3])
      ) {
        const e = se[0] ? $ - T.lineWidth / 2 : $;
        T.lineTo(C, e);
      } else T.moveTo(C, $);
      T.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate$14(
  [injectable()],
  SplitRectAfterRenderContribution
);
const defaultRectRenderContribution = new DefaultRectRenderContribution(),
  defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution,
  defaultRectBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
class DefaultImageBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments),
      (this.time = BaseRenderContributionTime.beforeFillStroke);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const {
      background: ne,
      backgroundMode: re = J.backgroundMode,
      backgroundFit: ae = J.backgroundFit,
    } = e.attribute;
    if (ne)
      if (e.backgroundImg) {
        const C = e.resources.get(ne);
        if ("success" !== C.state || !C.data) return;
        if ((T.save(), e.parent && !e.transMatrix.onlyTranslate())) {
          const C = getTheme(e.parent).group,
            { scrollX: $ = C.scrollX, scrollY: F = C.scrollY } =
              e.parent.attribute;
          T.setTransformFromMatrix(e.parent.globalTransMatrix, !0),
            T.translate($, F);
        }
        const $ = e.AABBBounds;
        this.doDrawImage(T, C.data, $, re, ae),
          T.restore(),
          e.transMatrix.onlyTranslate() || T.setTransformForCurrent();
      } else if (isObject$1(ne)) {
        const {
          stroke: C,
          fill: $,
          lineWidth: F = 1,
          cornerRadius: V = 0,
          expandX: Y = 0,
          expandY: K = 0,
        } = ne;
        if (!C && !$) return;
        T.beginPath();
        const { x: J, y: ee, width: te, height: ie } = getActualPosition(e);
        V
          ? createRectPath(T, J - Y, ee - K, te + 2 * Y, ie + 2 * K, V)
          : T.rect(J - Y, ee - K, te + 2 * Y, ie + 2 * K),
          (T.globalAlpha = 1),
          $ && ((T.fillStyle = $), T.fill()),
          C && F > 0 && ((T.lineWidth = F), (T.strokeStyle = C), T.stroke());
      } else {
        T.beginPath();
        const F = e.AABBBounds;
        T.rect(C, $, F.width(), F.height()),
          (T.fillStyle = ne),
          (T.globalAlpha = 1),
          T.fill();
      }
  }
}
function getActualPosition(e) {
  const T = parsePadding(e.attribute.boundsPadding),
    C = e.AABBBounds;
  let $ = C.x1,
    F = C.y1,
    V = C.width(),
    Y = C.height();
  return (
    isNumber$1(T)
      ? (($ += T), (F += T), (V -= 2 * T), (Y -= 2 * T))
      : (($ += T[3]), (F += T[0]), (V -= T[1] + T[3]), (Y -= T[0] + T[2])),
    {
      x: $,
      y: F,
      width: V,
      height: Y,
    }
  );
}
class DefaultImageRenderContribution extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments),
      (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    return super.drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie);
  }
}
const defaultImageRenderContribution = new DefaultImageRenderContribution(),
  defaultImageBackgroundRenderContribution =
    new DefaultImageBackgroundRenderContribution();
class DefaultSymbolRenderContribution {
  constructor() {
    (this.time = BaseRenderContributionTime.afterFillStroke),
      (this.useStyle = !0),
      (this.order = 0);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const ne = e.getParsedPath();
    if (!ne) return;
    const { outerBorder: re, innerBorder: ae } = e.attribute,
      oe = re && !1 !== re.visible,
      se = ae && !1 !== ae.visible;
    if (!oe && !se) return;
    const {
        size: le = J.size,
        opacity: de = J.opacity,
        x: ce = J.x,
        y: ue = J.y,
        scaleX: he = J.scaleX,
        scaleY: pe = J.scaleY,
      } = e.attribute,
      ge = !(!re || !re.stroke),
      fe = !(!ae || !ae.stroke);
    if (oe) {
      const { distance: F = J.outerBorder.distance } = re,
        V = getScaledStroke(T, F, T.dpr);
      if (
        (T.beginPath(),
        !1 === ne.drawOffset(T, le, C, $, V) && T.closePath(),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, re, J.outerBorder);
      else if (ge) {
        const F = J.outerBorder.opacity;
        (J.outerBorder.opacity = de),
          T.setStrokeStyle(e, re, (ce - C) / he, (ue - $) / pe, J.outerBorder),
          (J.outerBorder.opacity = F),
          T.stroke();
      }
    }
    if (se) {
      const { distance: F = J.innerBorder.distance } = ae,
        V = getScaledStroke(T, F, T.dpr);
      if (
        (T.beginPath(),
        !1 === ne.drawOffset(T, le, C, $, -V) && T.closePath(),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        ie)
      )
        ie(T, ae, J.innerBorder);
      else if (fe) {
        const F = J.innerBorder.opacity;
        (J.innerBorder.opacity = de),
          T.setStrokeStyle(e, ae, (ce - C) / he, (ue - $) / pe, J.innerBorder),
          (J.innerBorder.opacity = F),
          T.stroke();
      }
    }
  }
}
const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution(),
  defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution,
  defaultSymbolBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
class DefaultAreaTextureRenderContribution extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments),
      (this.time = BaseRenderContributionTime.afterFillStroke);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    var re, ae, oe, se;
    this.textureMap || this.initTextureMap(T, e.stage);
    const { attribute: le = e.attribute } = ne || {},
      {
        texture: de = null !== (re = e.attribute.texture) && void 0 !== re
          ? re
          : getAttributeFromDefaultAttrList(J, "texture"),
        textureColor: ce = null !== (ae = e.attribute.textureColor) &&
        void 0 !== ae
          ? ae
          : getAttributeFromDefaultAttrList(J, "textureColor"),
        textureSize: ue = null !== (oe = e.attribute.textureSize) &&
        void 0 !== oe
          ? oe
          : getAttributeFromDefaultAttrList(J, "textureSize"),
        texturePadding: he = null !== (se = e.attribute.texturePadding) &&
        void 0 !== se
          ? se
          : getAttributeFromDefaultAttrList(J, "texturePadding"),
      } = le;
    de && this.drawTexture(de, e, T, C, $, J, ce, ue, he);
  }
}
var __decorate$13 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$Q =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$D =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasArcRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.arcRenderContribitions = e),
      (this.numberType = ARC_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultArcRenderContribution,
        defaultArcBackgroundRenderContribution,
        defaultArcTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawArcTailCapPath(e, T, C, $, F, V, Y, K) {
    const J = K - Y,
      ee = e.getParsedAngle(),
      te = ee.startAngle;
    let ie = ee.endAngle;
    ie = K;
    const ne = abs(ie - te),
      re = ie > te;
    let ae = !1;
    if (F < V) {
      const e = F;
      (F = V), (V = e);
    }
    const oe = e.getParsedCornerRadius(),
      se = isArray$1(oe),
      {
        outerDeltaAngle: le,
        innerDeltaAngle: de,
        outerStartAngle: ce,
        outerEndAngle: ue,
        innerEndAngle: he,
        innerStartAngle: pe,
      } = e.getParsePadAngle(te, ie),
      ge = se ? oe[0] : oe,
      fe = se ? oe[1] : oe,
      me = se ? oe[2] : oe,
      ye = se ? oe[3] : oe,
      be = Math.max(fe, ge),
      ve = Math.max(me, ye);
    let Te = be,
      _e = ve;
    const Ce = F * cos(ce),
      Ae = F * sin(ce),
      xe = V * cos(he),
      Se = V * sin(he);
    let Re, Me, Pe, Be;
    if (
      (ve > epsilon || be > epsilon) &&
      ((Re = F * cos(ue)),
      (Me = F * sin(ue)),
      (Pe = V * cos(pe)),
      (Be = V * sin(pe)),
      ne < pi)
    ) {
      const e = intersect(Ce, Ae, Pe, Be, Re, Me, xe, Se);
      if (e) {
        const T = Ce - e[0],
          C = Ae - e[1],
          $ = Re - e[0],
          Y = Me - e[1],
          K =
            1 /
            sin(
              acos(
                (T * $ + C * Y) / (sqrt(T * T + C * C) * sqrt($ * $ + Y * Y))
              ) / 2
            ),
          J = sqrt(e[0] * e[0] + e[1] * e[1]);
        (_e = min(ve, (V - J) / (K - 1))), (Te = min(be, (F - J) / (K + 1)));
      }
    }
    if (Te > epsilon) {
      const e = min(ge, Te),
        V = min(fe, Te),
        Y = cornerTangents(Pe, Be, Ce, Ae, F, e, Number(re)),
        K = cornerTangents(Re, Me, xe, Se, F, V, Number(re));
      if (Te < be && e === V)
        T.moveTo(C + Y.cx + Y.x01, $ + Y.cy + Y.y01),
          T.arc(
            C + Y.cx,
            $ + Y.cy,
            Te,
            atan2(Y.y01, Y.x01),
            atan2(K.y01, K.x01),
            !re
          );
      else {
        const e = ie - J - 0.03,
          Y = atan2(K.y11, K.x11);
        T.arc(C, $, F, e, Y, !re),
          V > 0 &&
            T.arc(
              C + K.cx,
              $ + K.cy,
              V,
              atan2(K.y11, K.x11),
              atan2(K.y01, K.x01),
              !re
            );
      }
    } else T.moveTo(C + Ce, $ + Ae);
    if (!(V > epsilon) || de < 0.001) T.lineTo(C + xe, $ + Se), (ae = !0);
    else if (_e > epsilon) {
      const e = min(ye, _e),
        F = min(me, _e),
        Y = cornerTangents(xe, Se, Re, Me, V, -F, Number(re)),
        K = cornerTangents(Ce, Ae, Pe, Be, V, -e, Number(re));
      if ((T.lineTo(C + Y.cx + Y.x01, $ + Y.cy + Y.y01), _e < ve && e === F)) {
        const e = atan2(K.y01, K.x01);
        T.arc(C + Y.cx, $ + Y.cy, _e, atan2(Y.y01, Y.x01), e, !re);
      } else {
        F > 0 &&
          T.arc(
            C + Y.cx,
            $ + Y.cy,
            F,
            atan2(Y.y01, Y.x01),
            atan2(Y.y11, Y.x11),
            !re
          );
        const e = atan2(Y.cy + Y.y11, Y.cx + Y.x11),
          K = ie - J - 0.03;
        T.arc(C, $, V, e, K, re);
      }
    } else T.lineTo(C + V * cos(pe), $ + V * sin(pe));
    return ae;
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e, null == V ? void 0 : V.theme).arc,
      {
        fill: ee = J.fill,
        stroke: te = J.stroke,
        x: ie = J.x,
        y: ne = J.y,
      } = e.attribute,
      re = this.valid(e, J, Y, K);
    if (!re) return;
    const { fVisible: ae, sVisible: oe, doFill: se, doStroke: le } = re,
      {
        outerPadding: de = J.outerPadding,
        innerPadding: ce = J.innerPadding,
        cap: ue = J.cap,
        forceShowCap: he = J.forceShowCap,
      } = e.attribute;
    let { outerRadius: pe = J.outerRadius, innerRadius: ge = J.innerRadius } =
      e.attribute;
    (pe += de), (ge -= ce);
    let fe = 0;
    const me = ((isBoolean$1(ue) && ue) || ue[0]) && "conical" === ee.gradient;
    if (me) {
      const { sc: T, startAngle: C, endAngle: $ } = e.getParsedAngle();
      abs($ - C) < pi2 - epsilon &&
        ((fe = T || 0), (ee.startAngle -= fe), (ee.endAngle -= fe));
    }
    let ye = !1;
    const { isFullStroke: be, stroke: ve } = parseStroke(te);
    if (
      ((se || be) &&
        (T.beginPath(),
        drawArcPath$1(e, T, C, $, pe, ge),
        (ye = !0),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
        this.beforeRenderStep(e, T, C, $, se, le, ae, oe, J, F, Y, K),
        se &&
          (Y
            ? Y(T, e.attribute, J)
            : ae &&
              (T.setCommonStyle(e, e.attribute, ie - C, ne - $, J), T.fill())),
        le &&
          be &&
          (K
            ? K(T, e.attribute, J)
            : oe &&
              (T.setStrokeStyle(e, e.attribute, ie - C, ne - $, J),
              T.stroke()))),
      !be &&
        le &&
        (T.beginPath(),
        drawArcPath$1(e, T, C, $, pe, ge, ve),
        ye || this.beforeRenderStep(e, T, C, $, se, le, ae, oe, J, F, Y, K),
        K
          ? K(T, e.attribute, J)
          : oe && (T.setStrokeStyle(e, e.attribute, C, $, J), T.stroke())),
      ((isBoolean$1(ue) && ue) || ue[1]) && he)
    ) {
      const { startAngle: V, endAngle: ee } = e.getParsedAngle();
      if (abs(ee - V) >= pi2 - epsilon) {
        T.beginPath();
        const V = Math.abs(pe - ge) / 2 / pe,
          { endAngle: ee = J.endAngle, fill: te = J.fill } = e.attribute,
          ie = ee;
        if (
          (this.drawArcTailCapPath(e, T, C, $, pe, ge, ie, ie + V),
          ye || this.beforeRenderStep(e, T, C, $, se, le, ae, oe, J, F, Y, K),
          se)
        ) {
          const F = te;
          if ("conical" === F.gradient) {
            const V = getConicGradientAt(0, 0, ee, F);
            Y ||
              (fillVisible &&
                (T.setCommonStyle(e, e.attribute, C, $, J),
                (T.fillStyle = V),
                T.fill()));
          }
        }
        le &&
          (K ||
            (oe && (T.setStrokeStyle(e, e.attribute, C, $, J), T.stroke())));
      }
    }
    this.afterRenderStep(e, T, C, $, se, le, ae, oe, J, F, Y, K),
      me && ((ee.startAngle += fe), (ee.endAngle += fe));
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).arc;
    this._draw(e, F, !1, C, $);
  }
};
DefaultCanvasArcRender = __decorate$13(
  [
    injectable(),
    __param$D(0, inject(ContributionProvider)),
    __param$D(0, named(ArcRenderContribution)),
    __metadata$Q("design:paramtypes", [Object]),
  ],
  DefaultCanvasArcRender
);
var __decorate$12 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$P =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$C =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasCircleRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.circleRenderContribitions = e),
      (this.numberType = CIRCLE_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultCircleRenderContribution,
        defaultCircleBackgroundRenderContribution,
        defaultCircleTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e, null == V ? void 0 : V.theme).circle,
      {
        radius: ee = J.radius,
        startAngle: te = J.startAngle,
        endAngle: ie = J.endAngle,
        x: ne = J.x,
        y: re = J.y,
      } = e.attribute,
      ae = this.valid(e, J, Y, K);
    if (!ae) return;
    const { fVisible: oe, sVisible: se, doFill: le, doStroke: de } = ae;
    T.beginPath(),
      T.arc(C, $, ee, te, ie),
      T.closePath(),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
      this.beforeRenderStep(e, T, C, $, le, de, oe, se, J, F, Y, K),
      le &&
        (Y
          ? Y(T, e.attribute, J)
          : oe &&
            (T.setCommonStyle(e, e.attribute, ne - C, re - $, J), T.fill())),
      de &&
        (K
          ? K(T, e.attribute, J)
          : se &&
            (T.setStrokeStyle(e, e.attribute, ne - C, re - $, J), T.stroke())),
      this.afterRenderStep(e, T, C, $, le, de, oe, se, J, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).circle;
    this._draw(e, F, !1, C, $);
  }
};
function drawSegItem(e, T, C, $) {
  if (!T.p1) return;
  const { offsetX: F = 0, offsetY: V = 0, offsetZ: Y = 0 } = $ || {};
  if (1 === C)
    T.p2 && T.p3
      ? e.bezierCurveTo(
          F + T.p1.x,
          V + T.p1.y,
          F + T.p2.x,
          V + T.p2.y,
          F + T.p3.x,
          V + T.p3.y,
          Y
        )
      : e.lineTo(F + T.p1.x, V + T.p1.y, Y);
  else if (T.p2 && T.p3) {
    const [$] = divideCubic(T, C);
    e.bezierCurveTo(
      F + $.p1.x,
      V + $.p1.y,
      F + $.p2.x,
      V + $.p2.y,
      F + $.p3.x,
      V + $.p3.y,
      Y
    );
  } else {
    const $ = T.getPointAt(C);
    e.lineTo(F + $.x, V + $.y, Y);
  }
}
function drawSegments(e, T, C, $, F) {
  var V;
  const {
    offsetX: Y = 0,
    offsetY: K = 0,
    offsetZ: J = 0,
    mode: ee = "none",
    drawConnect: te = !1,
    zeroX: ie = 0,
    zeroY: ne = 0,
  } = F || {};
  if (te && "none" === ee) return;
  if (!T) return;
  let re = !0;
  const { curves: ae } = T;
  if (C >= 1) {
    if (te) {
      let T,
        C = !0;
      ae.forEach(($, F) => {
        var V;
        let ee = $.p0;
        if ($.originP1 !== $.originP2) {
          if ((T && T.originP1 === T.originP2 && (ee = T.p0), $.defined))
            C || (e.lineTo(ee.x + Y, ee.y + K, J), (C = !C));
          else {
            const { originP1: T, originP2: F } = $;
            let te;
            if (
              (T && !1 !== T.defined
                ? (te = ee)
                : T &&
                  !1 !== F.defined &&
                  (te = null !== (V = $.p3) && void 0 !== V ? V : $.p1),
              C)
            ) {
              C = !C;
              const T = te ? te.x : $.p0.x,
                F = te ? te.y : $.p0.y;
              e.moveTo(T + Y, F + K, J);
            } else te && ((C = !C), e.lineTo(te.x + Y, te.y + K, J));
          }
          T = $;
        } else T = $;
      });
    } else
      ae.forEach((T) => {
        T.defined
          ? (re && e.moveTo(T.p0.x + Y, T.p0.y + K, J),
            drawSegItem(e, T, 1, F),
            (re = !1))
          : (re = !0);
      });
    return;
  }
  if (C <= 0) return;
  let oe;
  "x" === $
    ? (oe = Direction.ROW)
    : "y" === $
    ? (oe = Direction.COLUMN)
    : "auto" === $ && (oe = T.direction);
  const se = C * T.tryUpdateLength(oe);
  let le = 0,
    de = !0,
    ce = null;
  for (let ue = 0, he = ae.length; ue < he; ue++) {
    const T = ae[ue],
      C = T.getLength(oe),
      $ = (se - le) / C;
    if (((le += C), $ < 0)) break;
    if (te) {
      let C = T.p0;
      if (T.originP1 === T.originP2) {
        ce = T;
        continue;
      }
      if ((ce && ce.originP1 === ce.originP2 && (C = ce.p0), T.defined))
        de || (e.lineTo(C.x + Y, C.y + K, J), (de = !de));
      else {
        const { originP1: $, originP2: F } = T;
        let ee;
        if (
          ($ && !1 !== $.defined
            ? (ee = C)
            : $ &&
              !1 !== F.defined &&
              (ee = null !== (V = T.p3) && void 0 !== V ? V : T.p1),
          de)
        ) {
          de = !de;
          const C = ee ? ee.x : T.p0.x,
            $ = ee ? ee.y : T.p0.y;
          e.moveTo(C + Y, $ + K, J);
        } else ee && ((de = !de), e.lineTo(ee.x + Y, ee.y + K, J));
      }
      ce = T;
    } else {
      if (!T.defined) {
        re = !0;
        continue;
      }
      re && e.moveTo(T.p0.x + Y, T.p0.y + K, J),
        drawSegItem(e, T, min($, 1), F),
        (re = !1);
    }
  }
}
function drawIncrementalSegments(e, T, C, $) {
  const { offsetX: F = 0, offsetY: V = 0 } = $ || {},
    Y = T ? T.points[T.points.length - 1] : C.points[0];
  e.moveTo(Y.x + F, Y.y + V),
    C.points.forEach((T) => {
      !1 !== T.defined
        ? e.lineTo(T.x + F, T.y + V)
        : e.moveTo(T.x + F, T.y + V);
    });
}
function drawIncrementalAreaSegments(e, T, C, $) {
  const { offsetX: F = 0, offsetY: V = 0 } = $ || {},
    { points: Y } = C,
    K = [];
  for (let J = 0; J < Y.length; J++) Y[J].defined;
  K.push(Y),
    K.forEach((C, $) => {
      var Y, K, J, ee;
      const te = T && 0 === $ ? T.points[T.points.length - 1] : C[0];
      e.moveTo(te.x + F, te.y + V),
        C.forEach((T) => {
          !1 !== T.defined
            ? e.lineTo(T.x + F, T.y + V)
            : e.moveTo(T.x + F, T.y + V);
        });
      for (let T = C.length - 1; T >= 0; T--) {
        const $ = C[T];
        e.lineTo(
          null !== (Y = $.x1) && void 0 !== Y ? Y : $.x,
          null !== (K = $.y1) && void 0 !== K ? K : $.y
        );
      }
      e.lineTo(
        null !== (J = te.x1) && void 0 !== J ? J : te.x,
        null !== (ee = te.y1) && void 0 !== ee ? ee : te.y
      ),
        e.closePath();
    });
}
DefaultCanvasCircleRender = __decorate$12(
  [
    injectable(),
    __param$C(0, inject(ContributionProvider)),
    __param$C(0, named(CircleRenderContribution)),
    __metadata$P("design:paramtypes", [Object]),
  ],
  DefaultCanvasCircleRender
);
var __decorate$11 =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), (this.numberType = LINE_NUMBER_TYPE);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).line;
    this._draw(e, F, !1, C, $);
  }
  drawSegmentItem(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae) {
    var oe, se, le, de, ce;
    if (!T) return;
    e.beginPath();
    const ue = null !== (oe = this.z) && void 0 !== oe ? oe : 0;
    drawSegments(e.camera ? e : e.nativeContext, T, J, ee, {
      offsetX: te,
      offsetY: ie,
      offsetZ: ue,
    }),
      ne.cache &&
        !isArray$1(ne.cache) &&
        ne.cache.curves.every((e) => e.defined) &&
        ne.attribute.curveType &&
        ne.attribute.curveType.includes("Closed") &&
        e.closePath(),
      e.setShadowBlendStyle && e.setShadowBlendStyle(ne, Y, K);
    const { x: he = 0, x: pe = 0 } = Y;
    !1 !== C &&
      (re
        ? re(e, Y, K)
        : F && (e.setCommonStyle(ne, Y, he - te, pe - ie, K), e.fill())),
      !1 !== $ &&
        (ae
          ? ae(e, Y, K)
          : V && (e.setStrokeStyle(ne, Y, he - te, pe - ie, K), e.stroke()));
    let {
      connectedType: ge,
      connectedX: fe,
      connectedY: me,
      connectedStyle: ye,
    } = Y;
    if (
      (isArray$1(K)
        ? ((ge =
            null !== (se = null != ge ? ge : K[0].connectedType) &&
            void 0 !== se
              ? se
              : K[1].connectedType),
          (fe =
            null !== (le = null != fe ? fe : K[0].connectedX) && void 0 !== le
              ? le
              : K[1].connectedX),
          (me =
            null !== (de = null != me ? me : K[0].connectedY) && void 0 !== de
              ? de
              : K[1].connectedY),
          (ye =
            null !== (ce = null != ye ? ye : K[0].connectedStyle) &&
            void 0 !== ce
              ? ce
              : K[1].connectedStyle))
        : ((ge = null != ge ? ge : K.connectedType),
          (fe = null != fe ? fe : K.connectedX),
          (me = null != me ? me : K.connectedY),
          (ye = null != ye ? ye : K.connectedStyle)),
      "connect" !== ge && "zero" !== ge && (ge = "none"),
      "none" !== ge)
    ) {
      e.beginPath(),
        drawSegments(e.camera ? e : e.nativeContext, T, J, ee, {
          offsetX: te,
          offsetY: ie,
          offsetZ: ue,
          drawConnect: !0,
          mode: ge,
          zeroX: fe,
          zeroY: me,
        });
      const oe = [];
      isArray$1(K) ? K.forEach((e) => oe.push(e)) : oe.push(K),
        oe.push(Y),
        !1 !== C &&
          (re
            ? re(e, Y, K)
            : F && (e.setCommonStyle(ne, ye, he - te, pe - ie, oe), e.fill())),
        !1 !== $ &&
          (ae
            ? ae(e, Y, K)
            : V &&
              (e.setStrokeStyle(ne, ye, he - te, pe - ie, oe), e.stroke()));
    }
    return !1;
  }
  drawLinearLineHighPerformance(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    var re;
    T.beginPath();
    const ae = null !== (re = this.z) && void 0 !== re ? re : 0,
      { points: oe } = e.attribute,
      se = oe[0];
    T.moveTo(se.x + Y, se.y + K, ae);
    for (let ce = 1; ce < oe.length; ce++) {
      const e = oe[ce];
      T.lineTo(e.x + Y, e.y + K, ae);
    }
    T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J);
    const { x: le = 0, x: de = 0 } = e.attribute;
    !1 !== C &&
      (ie
        ? ie(T, e.attribute, J)
        : F && (T.setCommonStyle(e, e.attribute, le - Y, de - K, J), T.fill())),
      !1 !== $ &&
        (ne
          ? ne(T, e.attribute, J)
          : V &&
            (T.setStrokeStyle(e, e.attribute, le - Y, de - K, J), T.stroke()));
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e, null == V ? void 0 : V.theme).line,
      {
        fill: ee = J.fill,
        stroke: te = J.stroke,
        fillOpacity: ie = J.fillOpacity,
        strokeOpacity: ne = J.strokeOpacity,
        segments: re,
        points: ae,
        closePath: oe,
        curveTension: se = J.curveTension,
      } = e.attribute;
    if (!this.valid(e, J, Y, K)) return;
    let { curveType: le = J.curveType } = e.attribute;
    oe && "linear" === le && (le = "linearClosed");
    const {
      clipRange: de = J.clipRange,
      clipRangeByDimension: ce = J.clipRangeByDimension,
    } = e.attribute;
    if (1 === de && !re && !ae.some((e) => !1 === e.defined) && "linear" === le)
      return this.drawLinearLineHighPerformance(
        e,
        T,
        !!ee,
        !!te,
        ie,
        ne,
        C,
        $,
        J,
        F,
        V,
        Y,
        K
      );
    if (e.shouldUpdateShape()) {
      const { points: T, segments: C } = e.attribute,
        $ = T;
      if (C && C.length) {
        let T, $;
        if (
          ((e.cache = C.map((e, C) => {
            if (e.points.length <= 1 && 0 === C)
              return (
                e.points[0] &&
                  ($ = {
                    endX: e.points[0].x,
                    endY: e.points[0].y,
                    curves: [
                      {
                        defined: !1 !== e.points[0].defined,
                      },
                    ],
                  }),
                null
              );
            1 === C
              ? (T = {
                  x: $.endX,
                  y: $.endY,
                  defined: $.curves[$.curves.length - 1].defined,
                })
              : C > 1 &&
                ((T.x = $.endX),
                (T.y = $.endY),
                (T.defined = $.curves[$.curves.length - 1].defined));
            const F = calcLineCache$1(e.points, le, {
              startPoint: T,
              curveTension: se,
            });
            return ($ = F), F;
          }).filter((e) => !!e)),
          "linearClosed" === le)
        ) {
          let T;
          for (let C = 0; C < e.cache.length; C++) {
            const $ = e.cache[C];
            for (let e = 0; e < $.curves.length; e++)
              if ($.curves[e].defined) {
                T = $.curves[e].p0;
                break;
              }
            if (T) break;
          }
          e.cache[e.cache.length - 1] &&
            e.cache[e.cache.length - 1].lineTo(T.x, T.y, !0);
        }
      } else {
        if (!T || !T.length)
          return (e.cache = null), void e.clearUpdateShapeTag();
        e.cache = calcLineCache$1($, le, {
          curveTension: se,
        });
      }
      e.clearUpdateShapeTag();
    }
    if (Array.isArray(e.cache)) {
      const F = e.attribute.segments.filter((e) => e.points.length);
      if ((1 === F[0].points.length && F.shift(), 1 === de)) {
        let V = !1;
        e.cache.forEach((re, ae) => {
          V ||
            (V = this.drawSegmentItem(
              T,
              re,
              !!ee,
              !!te,
              ie,
              ne,
              F[ae],
              [J, e.attribute],
              de,
              ce,
              C,
              $,
              e,
              Y,
              K
            ));
        });
      } else {
        const V = e.cache.reduce((e, T) => e + T.getLength(), 0),
          re = de * V;
        let ae = 0,
          oe = !1;
        e.cache.forEach((V, se) => {
          if (oe) return;
          const le = V.getLength(),
            de = (re - ae) / le;
          (ae += le),
            de > 0 &&
              (oe = this.drawSegmentItem(
                T,
                V,
                !!ee,
                !!te,
                ie,
                ne,
                F[se],
                [J, e.attribute],
                min(de, 1),
                ce,
                C,
                $,
                e,
                Y,
                K
              ));
        });
      }
    } else
      this.drawSegmentItem(
        T,
        e.cache,
        !!ee,
        !!te,
        ie,
        ne,
        e.attribute,
        J,
        de,
        ce,
        C,
        $,
        e,
        Y,
        K
      );
  }
};
function drawAreaSegments(e, T, C, $) {
  var F;
  const { drawConnect: V = !1, mode: Y = "none" } = $ || {};
  if (V && "none" === Y) return;
  const { top: K, bottom: J } = T;
  if (K.curves.length !== J.curves.length) return;
  if (C >= 1) {
    const T = [],
      C = [];
    let F = !0;
    if (V) {
      let F,
        V,
        Y = !0;
      const ee = K.curves.length;
      K.curves.forEach((K, te) => {
        const ie = J.curves[ee - te - 1];
        let ne = K,
          re = ie;
        if (K.originP1 === K.originP2) return (F = K), void (V = ie);
        if ((F && F.originP1 === F.originP2 && ((ne = F), (re = V)), K.defined))
          Y ||
            (T.push(ne),
            C.push(re),
            drawAreaConnectBlock(e, T, C, $),
            (T.length = 0),
            (C.length = 0),
            (Y = !Y));
        else {
          const { originP1: F, originP2: V } = K;
          let J, ee;
          F && !1 !== F.defined
            ? ((J = ne), (ee = re))
            : F && !1 !== V.defined && ((J = K), (ee = ie)),
            Y
              ? ((Y = !Y), T.push(J || K), C.push(ee || ie))
              : J &&
                ((Y = !Y),
                T.push(J || K),
                C.push(ee || ie),
                drawAreaConnectBlock(e, T, C, $),
                (T.length = 0),
                (C.length = 0));
        }
        F = K;
      }),
        drawAreaConnectBlock(e, T, C, $);
    } else {
      for (let V = 0, Y = K.curves.length; V < Y; V++) {
        const ee = K.curves[V];
        F !== ee.defined
          ? (F
              ? (drawAreaBlock(e, T, C, $), (T.length = 0), (C.length = 0))
              : (T.push(ee), C.push(J.curves[Y - V - 1])),
            (F = !F))
          : F && (T.push(ee), C.push(J.curves[Y - V - 1]));
      }
      drawAreaBlock(e, T, C, $);
    }
    return;
  }
  if (C <= 0) return;
  let { direction: ee } = $ || {};
  const { curves: te } = K,
    ie =
      null !== (F = te[te.length - 1].p3) && void 0 !== F
        ? F
        : te[te.length - 1].p1,
    ne = abs(ie.x - te[0].p0.x),
    re = abs(ie.y - te[0].p0.y);
  (ee = null != ee ? ee : ne > re ? Direction.ROW : Direction.COLUMN),
    Number.isFinite(ne) || (ee = Direction.COLUMN),
    Number.isFinite(re) || (ee = Direction.ROW);
  const ae = C * (ee === Direction.ROW ? ne : re);
  let oe = 0,
    se = !0;
  const le = [],
    de = [];
  let ce,
    ue,
    he = !0;
  for (let pe = 0, ge = K.curves.length; pe < ge; pe++) {
    const T = K.curves[pe],
      C = T.getLength(ee),
      F = (ae - oe) / C;
    if (F < 0) break;
    if (((oe += C), V)) {
      const C = J.curves[ge - pe - 1];
      let F = T,
        V = C;
      if (T.originP1 === T.originP2) {
        (ce = T), (ue = C);
        continue;
      }
      if (
        (ce && ce.originP1 === ce.originP2 && ((F = ce), (V = ue)), T.defined)
      )
        he ||
          (le.push(F),
          de.push(V),
          drawAreaConnectBlock(e, le, de, $),
          (le.length = 0),
          (de.length = 0),
          (he = !he));
      else {
        const { originP1: Y, originP2: K } = T;
        let J, ee;
        Y && !1 !== Y.defined
          ? ((J = F), (ee = V))
          : Y && !1 !== K.defined && ((J = T), (ee = C)),
          he
            ? ((he = !he), le.push(J || T), de.push(ee || C))
            : J &&
              ((he = !he),
              le.push(J || T),
              de.push(ee || C),
              drawAreaConnectBlock(e, le, de, $),
              (le.length = 0),
              (de.length = 0));
      }
      ce = T;
    } else {
      let C = null,
        V = null;
      se !== T.defined
        ? (se
            ? (drawAreaBlock(e, le, de, $), (le.length = 0), (de.length = 0))
            : ((C = T), (V = J.curves[ge - pe - 1])),
          (se = !se))
        : se && ((C = T), (V = J.curves[ge - pe - 1])),
        C &&
          V &&
          (F < 1 &&
            ((C = C.p2 && C.p3 ? divideCubic(C, F)[0] : divideLinear(C, F)[0]),
            (V =
              V.p2 && V.p3
                ? divideCubic(V, 1 - F)[1]
                : divideLinear(V, 1 - F)[1])),
          (C.defined = se),
          (V.defined = se),
          le.push(C),
          de.push(V)),
        (C = null),
        (V = null);
    }
  }
  V ? drawAreaConnectBlock(e, le, de, $) : drawAreaBlock(e, le, de, $);
}
function drawAreaConnectBlock(e, T, C, $) {
  if (T.length < 2) return;
  const { offsetX: F = 0, offsetY: V = 0, offsetZ: Y = 0, mode: K } = $ || {};
  let J = T[0];
  e.moveTo(J.p0.x + F, J.p0.y + V, Y), (J = T[T.length - 1]);
  let ee = J.p3 || J.p1;
  e.lineTo(ee.x + F, ee.y + V, Y),
    (J = C[C.length - 1]),
    e.lineTo(J.p0.x + F, J.p0.y + V, Y),
    (J = C[0]),
    (ee = J.p3 || J.p1),
    e.lineTo(ee.x + F, ee.y + V, Y),
    e.closePath();
}
function drawAreaBlock(e, T, C, $) {
  const { offsetX: F = 0, offsetY: V = 0, offsetZ: Y = 0 } = $ || {};
  let K = !0;
  T.forEach((T) => {
    T.defined
      ? (K && e.moveTo(T.p0.x + F, T.p0.y + V, Y),
        drawSegItem(e, T, 1, $),
        (K = !1))
      : (K = !0);
  }),
    (K = !0);
  for (let J = C.length - 1; J >= 0; J--) {
    const T = C[J];
    T.defined
      ? (K && e.lineTo(T.p0.x + F, T.p0.y + V, Y),
        drawSegItem(e, T, 1, $),
        (K = !1))
      : (K = !0);
  }
  e.closePath();
}
DefaultCanvasLineRender = __decorate$11(
  [injectable()],
  DefaultCanvasLineRender
);
const defaultAreaTextureRenderContribution =
    new DefaultAreaTextureRenderContribution(),
  defaultAreaBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
var __decorate$10 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$O =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$B =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
function calcLineCache(e, T, C) {
  var $, F;
  switch (T) {
    case "linear":
    default:
      return genLinearSegments(e, C);
    case "basis":
      return genBasisSegments(e, C);
    case "monotoneX":
      return genMonotoneXSegments(e, C);
    case "monotoneY":
      return genMonotoneYSegments(e, C);
    case "step":
      return genStepSegments(e, 0.5, C);
    case "stepBefore":
      return genStepSegments(e, 0, C);
    case "stepAfter":
      return genStepSegments(e, 1, C);
    case "catmullRom":
      return genCatmullRomSegments(
        e,
        null !== ($ = null == C ? void 0 : C.curveTension) && void 0 !== $
          ? $
          : 0.5,
        C
      );
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(
        e,
        null !== (F = null == C ? void 0 : C.curveTension) && void 0 !== F
          ? F
          : 0.5,
        C
      );
    case "linearClosed":
      return genLinearClosedSegments(e, C);
  }
}
let DefaultCanvasAreaRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.areaRenderContribitions = e),
      (this.numberType = AREA_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultAreaTextureRenderContribution,
        defaultAreaBackgroundRenderContribution,
      ]),
      this.init(e);
  }
  drawLinearAreaHighPerformance(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne) {
    var re, ae, oe, se, le;
    const { points: de } = e.attribute;
    if (de.length < 2) return;
    T.beginPath();
    const ce = null !== (re = this.z) && void 0 !== re ? re : 0,
      ue = de[0];
    T.moveTo(ue.x + Y, ue.y + K, ce);
    for (let ge = 1; ge < de.length; ge++) {
      const e = de[ge];
      T.lineTo(e.x + Y, e.y + K, ce);
    }
    for (let ge = de.length - 1; ge >= 0; ge--) {
      const e = de[ge];
      T.lineTo(
        (null !== (ae = e.x1) && void 0 !== ae ? ae : e.x) + Y,
        (null !== (oe = e.y1) && void 0 !== oe ? oe : e.y) + K,
        ce
      );
    }
    T.closePath(),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
      this.beforeRenderStep(e, T, Y, K, !!F, !1, C, !1, J, ee, ie, null, {
        attribute: e.attribute,
      });
    const { x: he = 0, x: pe = 0 } = e.attribute;
    if (
      (!1 !== C &&
        (ie
          ? ie(T, e.attribute, J)
          : F &&
            (T.setCommonStyle(e, e.attribute, he - Y, pe - K, J), T.fill())),
      this.afterRenderStep(e, T, Y, K, !!F, !1, C, !1, J, ee, ie, null, {
        attribute: e.attribute,
      }),
      $)
    ) {
      const { stroke: C = J && J.stroke } = e.attribute;
      if (isArray$1(C) && (C[0] || C[2]) && !1 === C[1])
        if ((T.beginPath(), C[0])) {
          T.moveTo(ue.x + Y, ue.y + K, ce);
          for (let e = 1; e < de.length; e++) {
            const C = de[e];
            T.lineTo(C.x + Y, C.y + K, ce);
          }
        } else if (C[2]) {
          const e = de[de.length - 1];
          T.moveTo(e.x + Y, e.y + K, ce);
          for (let C = de.length - 2; C >= 0; C--) {
            const e = de[C];
            T.lineTo(
              (null !== (se = e.x1) && void 0 !== se ? se : e.x) + Y,
              (null !== (le = e.y1) && void 0 !== le ? le : e.y) + K,
              ce
            );
          }
        }
      ne
        ? ne(T, e.attribute, J)
        : (T.setStrokeStyle(e, e.attribute, he - Y, pe - K, J), T.stroke());
    }
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J, ee, te, ie, ne, re;
    const ae = getTheme(e, null == V ? void 0 : V.theme).area,
      {
        fill: oe = ae.fill,
        stroke: se = ae.stroke,
        fillOpacity: le = ae.fillOpacity,
        z: de = ae.z,
        strokeOpacity: ce = ae.strokeOpacity,
        curveTension: ue = ae.curveTension,
      } = e.attribute,
      he = this.valid(e, ae, Y, K);
    if (!he) return;
    const { doFill: pe } = he,
      ge = he.doStroke && he.sVisible,
      {
        clipRange: fe = ae.clipRange,
        closePath: me,
        points: ye,
        segments: be,
      } = e.attribute;
    let { curveType: ve = ae.curveType } = e.attribute;
    if (
      (me && "linear" === ve && (ve = "linearClosed"),
      1 === fe && !be && !ye.some((e) => !1 === e.defined) && "linear" === ve)
    )
      return this.drawLinearAreaHighPerformance(
        e,
        T,
        !!oe,
        ge,
        le,
        ce,
        C,
        $,
        ae,
        F,
        V,
        Y,
        K
      );
    if (e.shouldUpdateShape()) {
      if (be && be.length) {
        let T, C;
        const $ = be
          .map((e, $) => {
            if (e.points.length <= 1 && 0 === $)
              return (
                e.points[0] &&
                  (C = {
                    endX: e.points[0].x,
                    endY: e.points[0].y,
                  }),
                null
              );
            1 === $
              ? (T = {
                  x: C.endX,
                  y: C.endY,
                })
              : $ > 1 && ((T.x = C.endX), (T.y = C.endY));
            const F = calcLineCache(e.points, ve, {
              startPoint: T,
              curveTension: ue,
            });
            return (C = F), F;
          })
          .filter((e) => !!e);
        let F;
        const V = [];
        for (let e = be.length - 1; e >= 0; e--) {
          const T = be[e].points,
            C = [];
          for (let e = T.length - 1; e >= 0; e--)
            C.push({
              x: null !== (J = T[e].x1) && void 0 !== J ? J : T[e].x,
              y: null !== (ee = T[e].y1) && void 0 !== ee ? ee : T[e].y,
            });
          if (0 !== e) {
            const T = be[e - 1].points,
              $ = T[T.length - 1];
            $ &&
              C.push({
                x: null !== (te = $.x1) && void 0 !== te ? te : $.x,
                y: null !== (ie = $.y1) && void 0 !== ie ? ie : $.y,
              });
          }
          C.length > 1 &&
            ((F = calcLineCache(
              C,
              "stepBefore" === ve
                ? "stepAfter"
                : "stepAfter" === ve
                ? "stepBefore"
                : ve,
              {
                curveTension: ue,
              }
            )),
            V.unshift(F));
        }
        e.cacheArea = V.map((e, T) => ({
          top: $[T],
          bottom: e,
        }));
      } else {
        if (!ye || !ye.length)
          return (e.cacheArea = null), void e.clearUpdateShapeTag();
        {
          const T = ye,
            C = [];
          for (let e = ye.length - 1; e >= 0; e--)
            C.push({
              x: null !== (ne = ye[e].x1) && void 0 !== ne ? ne : ye[e].x,
              y: null !== (re = ye[e].y1) && void 0 !== re ? re : ye[e].y,
            });
          const $ = calcLineCache(T, ve, {
              curveTension: ue,
            }),
            F = calcLineCache(
              C,
              "stepBefore" === ve
                ? "stepAfter"
                : "stepAfter" === ve
                ? "stepBefore"
                : ve,
              {
                curveTension: ue,
              }
            );
          e.cacheArea = {
            top: $,
            bottom: F,
          };
        }
      }
      e.clearUpdateShapeTag();
    }
    if (Array.isArray(e.cacheArea)) {
      const V = e.attribute.segments.filter((e) => e.points.length);
      if ((1 === V[0].points.length && V.shift(), 1 === fe)) {
        let J = !1;
        e.cacheArea.forEach((ee, te) => {
          J ||
            (J = this.drawSegmentItem(
              T,
              ee,
              pe,
              le,
              ge,
              ce,
              V[te],
              [ae, e.attribute],
              fe,
              C,
              $,
              de,
              e,
              F,
              Y,
              K
            ));
        });
      } else {
        const J = e.cacheArea.reduce((e, T) => e + T.top.getLength(), 0),
          ee = fe * J;
        let te = 0,
          ie = !1;
        e.cacheArea.forEach((J, ne) => {
          if (ie) return;
          const re = J.top.getLength(),
            oe = (ee - te) / re;
          (te += re),
            oe > 0 &&
              (ie = this.drawSegmentItem(
                T,
                J,
                pe,
                le,
                ge,
                ce,
                V[ne],
                [ae, e.attribute],
                min(oe, 1),
                C,
                $,
                de,
                e,
                F,
                Y,
                K
              ));
        });
      }
    } else
      this.drawSegmentItem(
        T,
        e.cacheArea,
        pe,
        le,
        ge,
        ce,
        e.attribute,
        ae,
        fe,
        C,
        $,
        de,
        e,
        F,
        Y,
        K
      );
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).area;
    this._draw(e, F, !1, C, $);
  }
  drawSegmentItem(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae, oe) {
    let se = !1;
    return (
      (se =
        se ||
        this._drawSegmentItem(
          e,
          T,
          C,
          $,
          F,
          V,
          Y,
          K,
          J,
          ee,
          te,
          ie,
          ne,
          re,
          !1,
          ae,
          oe
        )),
      (se =
        se ||
        this._drawSegmentItem(
          e,
          T,
          C,
          $,
          F,
          V,
          Y,
          K,
          J,
          ee,
          te,
          ie,
          ne,
          re,
          !0,
          ae,
          oe
        )),
      se
    );
  }
  _drawSegmentItem(e, T, C, $, F, V, Y, K, J, ee, te, ie, ne, re, ae, oe, se) {
    var le, de, ce, ue;
    if (
      !(
        T &&
        T.top &&
        T.bottom &&
        T.top.curves &&
        T.top.curves.length &&
        T.bottom.curves &&
        T.bottom.curves.length
      )
    )
      return;
    let {
      connectedType: he,
      connectedX: pe,
      connectedY: ge,
      connectedStyle: fe,
    } = Y;
    const me = [];
    if (
      (ae &&
        (isArray$1(K)
          ? ((he =
              null !== (le = null != he ? he : K[0].connectedType) &&
              void 0 !== le
                ? le
                : K[1].connectedType),
            (pe =
              null !== (de = null != pe ? pe : K[0].connectedX) && void 0 !== de
                ? de
                : K[1].connectedX),
            (ge =
              null !== (ce = null != ge ? ge : K[0].connectedY) && void 0 !== ce
                ? ce
                : K[1].connectedY),
            (fe =
              null !== (ue = null != fe ? fe : K[0].connectedStyle) &&
              void 0 !== ue
                ? ue
                : K[1].connectedStyle))
          : ((he = null != he ? he : K.connectedType),
            (pe = null != pe ? pe : K.connectedX),
            (ge = null != ge ? ge : K.connectedY),
            (fe = null != fe ? fe : K.connectedStyle)),
        "connect" !== he && "zero" !== he && (he = "none"),
        isArray$1(K) ? K.forEach((e) => me.push(e)) : me.push(K),
        me.push(Y)),
      ae && "none" === he)
    )
      return !1;
    e.beginPath();
    const { points: ye, segments: be } = ne.attribute;
    let ve,
      Te,
      _e = Direction.ROW;
    if (be) {
      const e = be[be.length - 1];
      (Te = be[0].points[0]), (ve = e.points[e.points.length - 1]);
    } else (Te = ye[0]), (ve = ye[ye.length - 1]);
    const Ce = abs(ve.x - Te.x),
      Ae = abs(ve.y - Te.y);
    (_e =
      null == ve.x1
        ? Direction.ROW
        : null == ve.y1
        ? Direction.COLUMN
        : Number.isFinite(Ce + Ae)
        ? Ce > Ae
          ? Direction.ROW
          : Direction.COLUMN
        : Direction.ROW),
      drawAreaSegments(e.camera ? e : e.nativeContext, T, J, {
        offsetX: ee,
        offsetY: te,
        offsetZ: ie,
        direction: _e,
        drawConnect: ae,
        mode: he,
        zeroX: pe,
        zeroY: ge,
      }),
      this.beforeRenderStep(ne, e, ee, te, !!$, !1, C, !1, K, re, oe, null, {
        attribute: Y,
      }),
      e.setShadowBlendStyle && e.setShadowBlendStyle(ne, Y, K);
    const { x: xe = 0, x: Se = 0 } = Y;
    if (
      (!1 !== C &&
        (oe
          ? oe(e, Y, K)
          : $ &&
            (e.setCommonStyle(ne, ae ? fe : Y, xe - ee, Se - te, ae ? me : K),
            e.fill())),
      this.afterRenderStep(ne, e, ee, te, !!$, !1, C, !1, K, re, oe, null, {
        attribute: Y,
      }),
      !1 !== F)
    )
      if (se) se(e, Y, K);
      else {
        const { stroke: C = K && K[1] && K[1].stroke } = Y;
        isArray$1(C) &&
          (C[0] || C[2]) &&
          !1 === C[1] &&
          (e.beginPath(),
          drawSegments(
            e.camera ? e : e.nativeContext,
            C[0] ? T.top : T.bottom,
            J,
            _e === Direction.ROW ? "x" : "y",
            {
              offsetX: ee,
              offsetY: te,
              offsetZ: ie,
              drawConnect: ae,
              mode: he,
              zeroX: pe,
              zeroY: ge,
            }
          )),
          e.setStrokeStyle(ne, ae ? fe : Y, xe - ee, Se - te, ae ? me : K),
          e.stroke();
      }
    return !1;
  }
};
DefaultCanvasAreaRender = __decorate$10(
  [
    injectable(),
    __param$B(0, inject(ContributionProvider)),
    __param$B(0, named(AreaRenderContribution)),
    __metadata$O("design:paramtypes", [Object]),
  ],
  DefaultCanvasAreaRender
);
const defaultPathTextureRenderContribution =
    defaultBaseTextureRenderContribution,
  defaultPathBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
var __decorate$$ =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$N =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$A =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPathRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.pathRenderContribitions = e),
      (this.numberType = PATH_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultPathBackgroundRenderContribution,
        defaultPathTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J, ee, te;
    const ie =
        null !== (J = this.tempTheme) && void 0 !== J
          ? J
          : getTheme(e, null == V ? void 0 : V.theme).path,
      { x: ne = ie.x, y: re = ie.y } = e.attribute,
      ae = null !== (ee = this.z) && void 0 !== ee ? ee : 0,
      oe = this.valid(e, ie, Y, K);
    if (!oe) return;
    const { fVisible: se, sVisible: le, doFill: de, doStroke: ce } = oe;
    if ((T.beginPath(), e.pathShape))
      renderCommandList(e.pathShape.commandList, T, C, $, 1, 1, ae);
    else {
      renderCommandList(
        (null !== (te = e.attribute.path) && void 0 !== te ? te : ie.path)
          .commandList,
        T,
        C,
        $,
        1,
        1,
        ae
      );
    }
    T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ie),
      this.beforeRenderStep(e, T, C, $, de, ce, se, le, ie, F, Y, K),
      ce &&
        (K
          ? K(T, e.attribute, ie)
          : le &&
            (T.setStrokeStyle(e, e.attribute, ne - C, re - $, ie), T.stroke())),
      de &&
        (Y
          ? Y(T, e.attribute, ie)
          : se &&
            (T.setCommonStyle(e, e.attribute, ne - C, re - $, ie), T.fill())),
      this.afterRenderStep(e, T, C, $, de, ce, se, le, ie, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).path;
    (this.tempTheme = F), this._draw(e, F, !1, C, $), (this.tempTheme = null);
  }
};
DefaultCanvasPathRender = __decorate$$(
  [
    injectable(),
    __param$A(0, inject(ContributionProvider)),
    __param$A(0, named(PathRenderContribution)),
    __metadata$N("design:paramtypes", [Object]),
  ],
  DefaultCanvasPathRender
);
var __decorate$_ =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$M =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$z =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasRectRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.rectRenderContribitions = e),
      (this.type = "rect"),
      (this.numberType = RECT_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultRectRenderContribution,
        defaultRectBackgroundRenderContribution,
        defaultRectTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J;
    const ee =
        null !== (J = this.tempTheme) && void 0 !== J
          ? J
          : getTheme(e, null == V ? void 0 : V.theme).rect,
      {
        fill: te = ee.fill,
        background: ie,
        stroke: ne = ee.stroke,
        cornerRadius: re = ee.cornerRadius,
        opacity: ae = ee.opacity,
        fillOpacity: oe = ee.fillOpacity,
        lineWidth: se = ee.lineWidth,
        strokeOpacity: le = ee.strokeOpacity,
        visible: de = ee.visible,
        x1: ce,
        y1: ue,
        x: he = ee.x,
        y: pe = ee.y,
      } = e.attribute;
    let { width: ge, height: fe } = e.attribute;
    (ge = (null != ge ? ge : ce - he) || 0),
      (fe = (null != fe ? fe : ue - pe) || 0);
    const me = rectFillVisible(ae, oe, ge, fe, te),
      ye = rectStrokeVisible(ae, le, ge, fe),
      be = runFill(te, ie),
      ve = runStroke(ne, se);
    if (!e.valid || !de) return;
    if (!be && !ve) return;
    if (!(me || ye || Y || K || ie)) return;
    0 === re || (isArray$1(re) && re.every((e) => 0 === e))
      ? (T.beginPath(), T.rect(C, $, ge, fe))
      : (T.beginPath(), createRectPath(T, C, $, ge, fe, re));
    const Te = {
      doFill: be,
      doStroke: ve,
    };
    T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ee),
      this.beforeRenderStep(e, T, C, $, be, ve, me, ye, ee, F, Y, K, Te),
      Te.doFill &&
        (Y
          ? Y(T, e.attribute, ee)
          : me &&
            (T.setCommonStyle(e, e.attribute, he - C, pe - $, ee), T.fill())),
      Te.doStroke &&
        (K
          ? K(T, e.attribute, ee)
          : ye &&
            (T.setStrokeStyle(e, e.attribute, he - C, pe - $, ee), T.stroke())),
      this.afterRenderStep(e, T, C, $, be, ve, me, ye, ee, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).rect;
    (this.tempTheme = F), this._draw(e, F, !1, C, $), (this.tempTheme = null);
  }
};
DefaultCanvasRectRender = __decorate$_(
  [
    injectable(),
    __param$z(0, inject(ContributionProvider)),
    __param$z(0, named(RectRenderContribution)),
    __metadata$M("design:paramtypes", [Object]),
  ],
  DefaultCanvasRectRender
);
var __decorate$Z =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$L =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$y =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.symbolRenderContribitions = e),
      (this.numberType = SYMBOL_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultSymbolRenderContribution,
        defaultSymbolBackgroundRenderContribution,
        defaultSymbolTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J;
    const ee = getTheme(e, null == V ? void 0 : V.theme).symbol,
      {
        size: te = ee.size,
        x: ie = ee.x,
        y: ne = ee.y,
        scaleX: re = ee.scaleX,
        scaleY: ae = ee.scaleY,
      } = e.attribute,
      oe = this.valid(e, ee, Y, K);
    if (!oe) return;
    const { fVisible: se, sVisible: le, doFill: de, doStroke: ce } = oe,
      ue = e.getParsedPath();
    if (!ue) return;
    const { keepDirIn3d: he = ee.keepDirIn3d } = e.attribute,
      pe = null !== (J = this.z) && void 0 !== J ? J : 0;
    if ((T.beginPath(), he && T.camera && T.project)) {
      const F = T.project(C, $, pe),
        V = T.camera;
      (T.camera = null),
        !1 ===
          ue.draw(
            T,
            isArray$1(te) ? [te[0] * re, te[1] * ae] : te * re,
            F.x,
            F.y,
            void 0,
            (F, V) => {
              var J, te, oe;
              if (e._parsedPath.svgCache) {
                const T = Object.assign({}, V);
                (T.fill =
                  null !== (J = V.fill) && void 0 !== J ? J : e.attribute.fill),
                  (T.opacity =
                    null !== (te = V.fill) && void 0 !== te
                      ? te
                      : e.attribute.opacity),
                  (T.fillOpacity = e.attribute.fillOpacity),
                  (T.stroke =
                    null !== (oe = V.stroke) && void 0 !== oe
                      ? oe
                      : e.attribute.stroke),
                  (V = T);
              }
              V.fill &&
                (Y
                  ? Y(T, e.attribute, ee)
                  : (T.setCommonStyle(e, V, ie - C, ne - $, ee), T.fill())),
                V.stroke &&
                  (K
                    ? K(T, e.attribute, ee)
                    : (T.setStrokeStyle(e, V, (ie - C) / re, (ne - $) / ae, ee),
                      T.stroke()));
            }
          ) && T.closePath(),
        (T.camera = V);
    } else
      !1 ===
        ue.draw(T, te, C, $, pe, (F, V) => {
          var J, te, oe;
          if (e._parsedPath.svgCache) {
            const T = Object.assign({}, V);
            (T.fill =
              null !== (J = V.fill) && void 0 !== J ? J : e.attribute.fill),
              (T.opacity =
                null !== (te = V.opacity) && void 0 !== te
                  ? te
                  : e.attribute.opacity),
              (T.fillOpacity = e.attribute.fillOpacity),
              (T.stroke =
                null !== (oe = V.stroke) && void 0 !== oe
                  ? oe
                  : e.attribute.stroke),
              (V = T);
          }
          V.fill &&
            (Y
              ? Y(T, e.attribute, ee)
              : (T.setCommonStyle(e, V, ie - C, ne - $, ee), T.fill())),
            V.stroke &&
              (K
                ? K(T, e.attribute, ee)
                : (T.setStrokeStyle(e, V, (ie - C) / re, (ne - $) / ae, ee),
                  T.stroke()));
        }) && T.closePath();
    T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ee),
      this.beforeRenderStep(e, T, C, $, de, ce, se, le, ee, F, Y, K),
      de &&
        !ue.isSvg &&
        (Y
          ? Y(T, e.attribute, ee)
          : se &&
            (T.setCommonStyle(e, e.attribute, ie - C, ne - $, ee), T.fill())),
      ce &&
        !ue.isSvg &&
        (K
          ? K(T, e.attribute, ee)
          : le &&
            (T.setStrokeStyle(e, e.attribute, (ie - C) / re, (ne - $) / ae, ee),
            T.stroke())),
      this.afterRenderStep(e, T, C, $, de, ce, se, le, ee, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).symbol;
    this._draw(e, F, !1, C, $);
  }
};
DefaultCanvasSymbolRender = __decorate$Z(
  [
    injectable(),
    __param$y(0, inject(ContributionProvider)),
    __param$y(0, named(SymbolRenderContribution)),
    __metadata$L("design:paramtypes", [Object]),
  ],
  DefaultCanvasSymbolRender
);
class DefaultBoundsAllocate {
  constructor() {
    this.pools = [];
    for (let e = 0; e < 10; e++) this.pools.push(new AABBBounds());
  }
  allocate(e, T, C, $) {
    if (!this.pools.length) return new AABBBounds().setValue(e, T, C, $);
    const F = this.pools.pop();
    return (F.x1 = e), (F.y1 = T), (F.x2 = C), (F.y2 = $), F;
  }
  allocateByObj(e) {
    if (!this.pools.length) return new AABBBounds(e);
    const T = this.pools.pop();
    return (T.x1 = e.x1), (T.y1 = e.y1), (T.x2 = e.x2), (T.y2 = e.y2), T;
  }
  free(e) {
    this.pools.push(e);
  }
  get length() {
    return this.pools.length;
  }
  release(...e) {
    this.pools = [];
  }
}
const boundsAllocate = new DefaultBoundsAllocate();
class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments),
      (this.time = BaseRenderContributionTime.beforeFillStroke);
  }
  drawShape(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    var ne, re, ae, oe, se, le, de, ce, ue, he;
    const {
      backgroundMode: pe = J.backgroundMode,
      backgroundFit: ge = J.backgroundFit,
    } = e.attribute;
    let fe,
      { background: me } = e.attribute;
    if (!me) return;
    const ye = () => {
      "richtext" === e.type &&
        (T.restore(), T.save(), fe && T.setTransformFromMatrix(fe, !0, 1));
    };
    let be;
    "richtext" === e.type &&
      ((fe = T.currentMatrix.clone()),
      T.restore(),
      T.save(),
      T.setTransformForCurrent());
    const ve = isObject$1(me) && me.background,
      Te = e.transMatrix.onlyTranslate();
    if (ve) {
      const T = e.AABBBounds,
        C =
          (null !== (ne = me.x) && void 0 !== ne ? ne : T.x1) +
          (null !== (re = me.dx) && void 0 !== re ? re : 0),
        $ =
          (null !== (ae = me.y) && void 0 !== ae ? ae : T.y1) +
          (null !== (oe = me.dy) && void 0 !== oe ? oe : 0),
        F = null !== (se = me.width) && void 0 !== se ? se : T.width(),
        V = null !== (le = me.height) && void 0 !== le ? le : T.height();
      if (
        ((be = boundsAllocate.allocate(C, $, C + F, $ + V)),
        (me = me.background),
        !Te)
      ) {
        const e = be.width(),
          T = be.height();
        be.set(
          (null !== (de = me.x) && void 0 !== de ? de : 0) +
            (null !== (ce = me.dx) && void 0 !== ce ? ce : 0),
          (null !== (ue = me.y) && void 0 !== ue ? ue : 0) +
            (null !== (he = me.dy) && void 0 !== he ? he : 0),
          e,
          T
        );
      }
    } else
      (be = e.AABBBounds),
        Te ||
          (be = getTextBounds(
            Object.assign(Object.assign({}, e.attribute), {
              angle: 0,
              scaleX: 1,
              scaleY: 1,
              x: 0,
              y: 0,
              dx: 0,
              dy: 0,
            })
          ).clone());
    if (e.backgroundImg && e.resources) {
      const F = e.resources.get(me);
      if ("success" !== F.state || !F.data) return void ye();
      T.highPerformanceSave(),
        Te && T.setTransformFromMatrix(e.parent.globalTransMatrix, !0),
        T.setCommonStyle(e, e.attribute, C, $, J),
        this.doDrawImage(T, F.data, be, pe, ge),
        T.highPerformanceRestore(),
        T.setTransformForCurrent();
    } else {
      const { backgroundCornerRadius: F } = e.attribute;
      T.highPerformanceSave(),
        T.setCommonStyle(e, e.attribute, C, $, J),
        (T.fillStyle = me),
        F
          ? (createRectPath(T, be.x1, be.y1, be.width(), be.height(), F),
            T.fill())
          : T.fillRect(be.x1, be.y1, be.width(), be.height()),
        T.highPerformanceRestore();
    }
    ve && boundsAllocate.free(be), ye();
  }
}
const defaultTextBackgroundRenderContribution =
  new DefaultTextBackgroundRenderContribution();
var __decorate$Y =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$K =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$x =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasTextRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.textRenderContribitions = e),
      (this.numberType = TEXT_NUMBER_TYPE),
      (this.builtinContributions = [defaultTextBackgroundRenderContribution]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J, ee, te;
    const ie = getTheme(e, null == V ? void 0 : V.theme).text,
      {
        text: ne,
        underline: re = ie.underline,
        lineThrough: ae = ie.lineThrough,
        keepDirIn3d: oe = ie.keepDirIn3d,
        direction: se = ie.direction,
        whiteSpace: le = ie.whiteSpace,
        fontSize: de = ie.fontSize,
        verticalMode: ce = ie.verticalMode,
        x: ue = ie.x,
        y: he = ie.y,
      } = e.attribute;
    let { textAlign: pe = ie.textAlign, textBaseline: ge = ie.textBaseline } =
      e.attribute;
    if (!ce && "vertical" === se) {
      const T = pe;
      (pe =
        null !== (J = e.getBaselineMapAlign()[ge]) && void 0 !== J
          ? J
          : "left"),
        (ge =
          null !== (ee = e.getAlignMapBaseline()[T]) && void 0 !== ee
            ? ee
            : "top");
    }
    const fe =
        null !== (te = calculateLineHeight(e.attribute.lineHeight, de)) &&
        void 0 !== te
          ? te
          : de,
      me = this.valid(e, ie, Y, K);
    if (!me) return;
    const { fVisible: ye, sVisible: be, doFill: ve, doStroke: Te } = me,
      _e = !oe,
      Ce = this.z || 0;
    T.beginPath(),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ie),
      this.beforeRenderStep(e, T, C, $, ve, Te, ye, be, ie, F, Y, K),
      _e && this.transformUseContext2d(e, ie, Ce, T);
    const Ae = (F, V, J, ee) => {
      let te = C + V;
      const ne = $ + J;
      if (ee) {
        T.highPerformanceSave(), (te += de);
        const e = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        e.rotateByCenter(Math.PI / 2, te, ne),
          T.transformFromMatrix(e, !0),
          matrixAllocate.free(e);
      }
      Te &&
        (K
          ? K(T, e.attribute, ie)
          : be &&
            (T.setStrokeStyle(e, e.attribute, ue - C, he - $, ie),
            T.strokeText(F, te, ne, Ce))),
        ve &&
          (Y
            ? Y(T, e.attribute, ie)
            : ye &&
              (T.setCommonStyle(e, e.attribute, ue - C, he - $, ie),
              T.fillText(F, te, ne, Ce),
              this.drawUnderLine(re, ae, e, te, ne, Ce, ie, T))),
        ee && (T.highPerformanceRestore(), T.setTransformForCurrent());
    };
    if (e.isMultiLine)
      if (
        (T.setTextStyleWithoutAlignBaseline(e.attribute, ie, Ce),
        "horizontal" === se)
      ) {
        const { multilineLayout: F } = e;
        if (!F) return void T.highPerformanceRestore();
        const { xOffset: V, yOffset: J } = F.bbox;
        Te &&
          (K
            ? K(T, e.attribute, ie)
            : be &&
              (T.setStrokeStyle(e, e.attribute, ue - C, he - $, ie),
              F.lines.forEach((e) => {
                T.strokeText(
                  e.str,
                  (e.leftOffset || 0) + V + C,
                  (e.topOffset || 0) + J + $,
                  Ce
                );
              }))),
          ve &&
            (Y
              ? Y(T, e.attribute, ie)
              : ye &&
                (T.setCommonStyle(e, e.attribute, ue - C, he - $, ie),
                F.lines.forEach((F) => {
                  T.fillText(
                    F.str,
                    (F.leftOffset || 0) + V + C,
                    (F.topOffset || 0) + J + $,
                    Ce
                  ),
                    this.drawMultiUnderLine(
                      re,
                      ae,
                      e,
                      (F.leftOffset || 0) + V + C,
                      (F.topOffset || 0) +
                        J +
                        $ -
                        textDrawOffsetY("bottom", de) -
                        0.05 * de,
                      Ce,
                      F.width,
                      ie,
                      T
                    );
                })));
      } else {
        e.tryUpdateAABBBounds();
        const C = e.cache,
          { verticalList: $ } = C;
        (T.textAlign = "left"), (T.textBaseline = "top");
        const F = fe * $.length;
        let V = 0;
        $.forEach((e) => {
          const T = e.reduce((e, T) => e + (T.width || 0), 0);
          V = max(T, V);
        });
        let Y = 0,
          K = 0;
        "bottom" === ge ? (K = -F) : "middle" === ge && (K = -F / 2),
          "center" === pe ? (Y -= V / 2) : "right" === pe && (Y -= V),
          $.forEach((e, T) => {
            const C = e.reduce((e, T) => e + (T.width || 0), 0),
              $ = V - C;
            let J = Y;
            "center" === pe ? (J += $ / 2) : "right" === pe && (J += $),
              e.forEach((e) => {
                const { text: C, width: $, direction: V } = e;
                Ae(C, F - (T + 1) * fe + K, J, V), (J += $);
              });
          });
      }
    else if ("horizontal" === se) {
      T.setTextStyle(e.attribute, ie, Ce);
      const C = e.clipedText;
      let $ = 0;
      fe !== de &&
        ("top" === ge
          ? ($ = (fe - de) / 2)
          : "middle" === ge || ("bottom" === ge && ($ = -(fe - de) / 2))),
        Ae(C, 0, $, 0);
    } else {
      e.tryUpdateAABBBounds();
      const C = e.cache;
      if (C) {
        T.setTextStyleWithoutAlignBaseline(e.attribute, ie, Ce);
        const { verticalList: $ } = C;
        let F = 0;
        const V = $[0].reduce((e, T) => e + (T.width || 0), 0);
        let Y = 0;
        "bottom" === ge ? (Y = -fe) : "middle" === ge && (Y = -fe / 2),
          "center" === pe ? (F -= V / 2) : "right" === pe && (F -= V),
          (T.textAlign = "left"),
          (T.textBaseline = "top"),
          $[0].forEach((e) => {
            const { text: T, width: C, direction: $ } = e;
            Ae(T, Y, F, $), (F += C);
          });
      }
    }
    _e && this.restoreTransformUseContext2d(e, ie, Ce, T),
      this.afterRenderStep(e, T, C, $, ve, Te, ye, be, ie, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).text,
      { keepDirIn3d: V = F.keepDirIn3d } = e.attribute,
      Y = !V;
    this._draw(e, F, Y, C, $);
  }
  drawUnderLine(e, T, C, $, F, V, Y, K) {
    if (T + e <= 0) return;
    const {
        textAlign: J = Y.textAlign,
        textBaseline: ee = Y.textBaseline,
        fontSize: te = Y.fontSize,
        fill: ie = Y.fill,
        opacity: ne = Y.opacity,
        underlineOffset: re = Y.underlineOffset,
        underlineDash: ae = Y.underlineDash,
        fillOpacity: oe = Y.fillOpacity,
      } = C.attribute,
      se = C.clipedWidth,
      le = textDrawOffsetX(J, se),
      de = textLayoutOffsetY(ee, te, te),
      ce = {
        lineWidth: 0,
        stroke: ie,
        opacity: ne,
        strokeOpacity: oe,
      };
    if (e) {
      (ce.lineWidth = e),
        K.setStrokeStyle(C, ce, $, F, Y),
        ae && K.setLineDash(ae),
        K.beginPath();
      const T = F + de + te + re;
      K.moveTo($ + le, T, V), K.lineTo($ + le + se, T, V), K.stroke();
    }
    if (T) {
      (ce.lineWidth = T), K.setStrokeStyle(C, ce, $, F, Y), K.beginPath();
      const e = F + de + te / 2;
      K.moveTo($ + le, e, V), K.lineTo($ + le + se, e, V), K.stroke();
    }
  }
  drawMultiUnderLine(e, T, C, $, F, V, Y, K, J) {
    if (T + e <= 0) return;
    const {
        fontSize: ee = K.fontSize,
        fill: te = K.fill,
        opacity: ie = K.opacity,
        underlineOffset: ne = K.underlineOffset,
        underlineDash: re = K.underlineDash,
        fillOpacity: ae = K.fillOpacity,
      } = C.attribute,
      oe = textLayoutOffsetY("alphabetic", ee, ee),
      se = {
        lineWidth: 0,
        stroke: te,
        opacity: ie,
        strokeOpacity: ae,
      };
    let le = -3;
    if (e) {
      (se.lineWidth = e),
        J.setStrokeStyle(C, se, $, F, K),
        re && J.setLineDash(re),
        J.beginPath();
      const T = F + oe + ee + le + ne;
      J.moveTo($ + 0, T, V), J.lineTo($ + 0 + Y, T, V), J.stroke();
    }
    if (((le = -1), T)) {
      (se.lineWidth = T), J.setStrokeStyle(C, se, $, F, K), J.beginPath();
      const e = F + oe + ee / 2 + le;
      J.moveTo($ + 0, e, V), J.lineTo($ + 0 + Y, e, V), J.stroke();
    }
  }
};
function drawPolygon(e, T, C, $) {
  e.moveTo(T[0].x + C, T[0].y + $);
  for (let F = 1; F < T.length; F++) e.lineTo(T[F].x + C, T[F].y + $);
}
function drawRoundedPolygon(e, T, C, $, F, V = !0) {
  var Y;
  if (T.length < 3) return void drawPolygon(e, T, C, $);
  let K = 0,
    J = T.length - 1;
  V || ((K += 1), (J -= 1), e.moveTo(T[0].x + C, T[0].y + $));
  for (let ee = K; ee <= J; ee++) {
    const V = T[0 === ee ? J : (ee - 1) % T.length],
      K = T[ee % T.length],
      te = T[(ee + 1) % T.length],
      ie = K.x - V.x,
      ne = K.y - V.y,
      re = K.x - te.x,
      ae = K.y - te.y,
      oe = (Math.atan2(ne, ie) - Math.atan2(ae, re)) / 2,
      se = Math.abs(Math.tan(oe));
    let le = Array.isArray(F)
        ? null !== (Y = F[ee % T.length]) && void 0 !== Y
          ? Y
          : 0
        : F,
      de = le / se;
    const ce = getLength(ie, ne),
      ue = getLength(re, ae),
      he = Math.min(ce, ue);
    de > he && ((de = he), (le = he * se));
    const pe = getProportionPoint(K, de, ce, ie, ne),
      ge = getProportionPoint(K, de, ue, re, ae),
      fe = 2 * K.x - pe.x - ge.x,
      me = 2 * K.y - pe.y - ge.y,
      ye = getLength(fe, me),
      be = getProportionPoint(K, getLength(de, le), ye, fe, me);
    let ve = Math.atan2(pe.y - be.y, pe.x - be.x);
    const Te = Math.atan2(ge.y - be.y, ge.x - be.x);
    let _e = Te - ve;
    _e < 0 && ((ve = Te), (_e = -_e)),
      _e > Math.PI && (_e -= Math.PI),
      0 === ee ? e.moveTo(pe.x + C, pe.y + $) : e.lineTo(pe.x + C, pe.y + $),
      _e && e.arcTo(K.x + C, K.y + $, ge.x + C, ge.y + $, le),
      e.lineTo(ge.x + C, ge.y + $);
  }
  V || e.lineTo(T[J + 1].x + C, T[J + 1].y + $);
}
function getLength(e, T) {
  return Math.sqrt(e * e + T * T);
}
function getProportionPoint(e, T, C, $, F) {
  const V = T / C;
  return {
    x: e.x - $ * V,
    y: e.y - F * V,
  };
}
DefaultCanvasTextRender = __decorate$Y(
  [
    injectable(),
    __param$x(0, inject(ContributionProvider)),
    __param$x(0, named(TextRenderContribution)),
    __metadata$K("design:paramtypes", [Object]),
  ],
  DefaultCanvasTextRender
);
const defaultPolygonTextureRenderContribution =
    defaultBaseTextureRenderContribution,
  defaultPolygonBackgroundRenderContribution =
    defaultBaseBackgroundRenderContribution;
var __decorate$X =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$J =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$w =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.polygonRenderContribitions = e),
      (this.numberType = POLYGON_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultPolygonBackgroundRenderContribution,
        defaultPolygonTextureRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e, null == V ? void 0 : V.theme).polygon,
      {
        points: ee = J.points,
        cornerRadius: te = J.cornerRadius,
        x: ie = J.x,
        y: ne = J.y,
        closePath: re = J.closePath,
      } = e.attribute,
      ae = this.valid(e, J, Y, K);
    if (!ae) return;
    const { fVisible: oe, sVisible: se, doFill: le, doStroke: de } = ae;
    T.beginPath(),
      te <= 0 || (isArray$1(te) && te.every((e) => 0 === e))
        ? drawPolygon(T.camera ? T : T.nativeContext, ee, C, $)
        : drawRoundedPolygon(T.camera ? T : T.nativeContext, ee, C, $, te, re),
      re && T.closePath(),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
      this.beforeRenderStep(e, T, C, $, le, de, oe, se, J, F, Y, K),
      le &&
        (Y
          ? Y(T, e.attribute, J)
          : oe &&
            (T.setCommonStyle(e, e.attribute, ie - C, ne - $, J), T.fill())),
      de &&
        (K
          ? K(T, e.attribute, J)
          : se &&
            (T.setStrokeStyle(e, e.attribute, ie - C, ne - $, J), T.stroke())),
      this.afterRenderStep(e, T, C, $, le, de, oe, se, J, F, Y, K);
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).polygon;
    this._draw(e, F, !1, C, $);
  }
};
DefaultCanvasPolygonRender = __decorate$X(
  [
    injectable(),
    __param$w(0, inject(ContributionProvider)),
    __param$w(0, named(PolygonRenderContribution)),
    __metadata$J("design:paramtypes", [Object]),
  ],
  DefaultCanvasPolygonRender
);
var __decorate$W =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$I =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$v =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasGroupRender = class {
  constructor(e) {
    (this.groupRenderContribitions = e), (this.numberType = GROUP_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e, null == V ? void 0 : V.theme).group,
      {
        fill: ee = J.fill,
        background: te,
        stroke: ie = J.stroke,
        opacity: ne = J.opacity,
        width: re = J.width,
        height: ae = J.height,
        clip: oe = J.clip,
        fillOpacity: se = J.fillOpacity,
        strokeOpacity: le = J.strokeOpacity,
        cornerRadius: de = J.cornerRadius,
        path: ce = J.path,
        lineWidth: ue = J.lineWidth,
        visible: he = J.visible,
      } = e.attribute,
      pe = rectFillVisible(ne, se, re, ae, ee),
      ge = rectStrokeVisible(ne, le, re, ae),
      fe = runFill(ee, te),
      me = runStroke(ie, ue);
    if (!e.valid || !he) return;
    if (!oe) {
      if (!fe && !me) return;
      if (!(pe || ge || Y || K || te)) return;
    }
    if (ce && ce.length && F.drawContribution) {
      const e = T.disableFill,
        C = T.disableStroke,
        $ = T.disableBeginPath;
      (T.disableFill = !0),
        (T.disableStroke = !0),
        (T.disableBeginPath = !0),
        ce.forEach((e) => {
          F.drawContribution
            .getRenderContribution(e)
            .draw(e, F.renderService, F, V);
        }),
        (T.disableFill = e),
        (T.disableStroke = C),
        (T.disableBeginPath = $);
    } else
      0 === de || (isArray$1(de) && de.every((e) => 0 === e))
        ? (T.beginPath(), T.rect(C, $, re, ae))
        : (T.beginPath(), createRectPath(T, C, $, re, ae, de));
    this._groupRenderContribitions ||
      ((this._groupRenderContribitions =
        this.groupRenderContribitions.getContributions() || []),
      this._groupRenderContribitions.push(
        defaultGroupBackgroundRenderContribution
      ));
    const ye = {
      doFill: fe,
      doStroke: me,
    };
    this._groupRenderContribitions.forEach((V) => {
      V.time === BaseRenderContributionTime.beforeFillStroke &&
        V.drawShape(e, T, C, $, fe, me, pe, ge, J, F, Y, K, ye);
    }),
      oe && T.clip(),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, J),
      ye.doFill &&
        (Y
          ? Y(T, e.attribute, J)
          : pe && (T.setCommonStyle(e, e.attribute, C, $, J), T.fill())),
      ye.doStroke &&
        (K
          ? K(T, e.attribute, J)
          : ge && (T.setStrokeStyle(e, e.attribute, C, $, J), T.stroke())),
      this._groupRenderContribitions.forEach((V) => {
        V.time === BaseRenderContributionTime.afterFillStroke &&
          V.drawShape(e, T, C, $, fe, me, pe, ge, J, F, Y, K);
      });
  }
  draw(e, T, C, $) {
    const { context: F } = C;
    if (!F) return;
    const { clip: V, baseOpacity: Y = 1 } = e.attribute;
    V ? F.save() : F.highPerformanceSave();
    const K = F.baseGlobalAlpha;
    F.baseGlobalAlpha *= Y;
    const J = getTheme(e, null == $ ? void 0 : $.theme).group,
      ee = F.modelMatrix;
    if (F.camera) {
      const T = mat4Allocate.allocate(),
        C = mat4Allocate.allocate();
      getModelMatrix(C, e, J),
        multiplyMat4Mat4(T, ee || T, C),
        (F.modelMatrix = T),
        mat4Allocate.free(C),
        F.setTransform(1, 0, 0, 1, 0, 0, !0);
    } else F.transformFromMatrix(e.transMatrix, !0);
    F.beginPath(),
      $.skipDraw
        ? this.drawShape(
            e,
            F,
            0,
            0,
            C,
            $,
            () => !1,
            () => !1
          )
        : this.drawShape(e, F, 0, 0, C);
    const { scrollX: te = J.scrollX, scrollY: ie = J.scrollY } = e.attribute;
    let ne;
    (te || ie) && F.translate(te, ie),
      $ && $.drawingCb && (ne = $.drawingCb()),
      F.modelMatrix !== ee && mat4Allocate.free(F.modelMatrix),
      (F.modelMatrix = ee),
      (F.baseGlobalAlpha = K),
      ne && ne.then
        ? ne.then(() => {
            V ? F.restore() : F.highPerformanceRestore();
          })
        : V
        ? F.restore()
        : F.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate$W(
  [
    injectable(),
    __param$v(0, inject(ContributionProvider)),
    __param$v(0, named(GroupRenderContribution)),
    __metadata$I("design:paramtypes", [Object]),
  ],
  DefaultCanvasGroupRender
);
var __decorate$V =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$H =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$u =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
const repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
let DefaultCanvasImageRender = class extends BaseRender {
  constructor(e) {
    super(),
      (this.imageRenderContribitions = e),
      (this.numberType = IMAGE_NUMBER_TYPE),
      (this.builtinContributions = [
        defaultImageRenderContribution,
        defaultImageBackgroundRenderContribution,
      ]),
      this.init(e);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    const J = getTheme(e).image,
      {
        width: ee = J.width,
        height: te = J.height,
        repeatX: ie = J.repeatX,
        repeatY: ne = J.repeatY,
        x: re = J.x,
        y: ae = J.y,
        cornerRadius: oe = J.cornerRadius,
        image: se,
      } = e.attribute,
      le = this.valid(e, J, Y);
    if (!le) return;
    const { fVisible: de, sVisible: ce, doFill: ue, doStroke: he } = le;
    if (
      (T.setShadowBlendStyle && T.setShadowBlendStyle(e, J),
      this.beforeRenderStep(e, T, C, $, ue, !1, de, !1, J, F, Y),
      ue)
    )
      if (Y) Y(T, e.attribute, J);
      else if (de) {
        if (!se || !e.resources) return;
        const F = e.resources.get(se);
        if ("success" !== F.state) return;
        let V = !1;
        0 === oe ||
          (isArray$1(oe) && oe.every((e) => 0 === e)) ||
          (T.beginPath(),
          createRectPath(T, C, $, ee, te, oe),
          T.save(),
          T.clip(),
          (V = !0)),
          T.setCommonStyle(e, e.attribute, C, $, J);
        let Y = 0;
        if (("repeat" === ie && (Y |= 1), "repeat" === ne && (Y |= 2), Y)) {
          const e = T.createPattern(F.data, repeatStr[Y]);
          (T.fillStyle = e),
            T.translate(C, $, !0),
            T.fillRect(0, 0, ee, te),
            T.translate(-C, -$, !0);
        } else T.drawImage(F.data, C, $, ee, te);
        V && T.restore();
      }
    he &&
      (K
        ? K(T, e.attribute, J)
        : ce &&
          (T.setStrokeStyle(e, e.attribute, re - C, ae - $, J), T.stroke())),
      this.afterRenderStep(e, T, C, $, ue, !1, de, !1, J, F, Y);
  }
  draw(e, T, C) {
    const { image: $ } = e.attribute;
    if (!$ || !e.resources) return;
    const F = e.resources.get($);
    if ("loading" === F.state && isString$1($))
      return void ResourceLoader.improveImageLoading($);
    if ("success" !== F.state) return;
    const { context: V } = T.drawParams;
    if (!V) return;
    const Y = getTheme(e).image;
    this._draw(e, Y, !1, C);
  }
};
DefaultCanvasImageRender = __decorate$V(
  [
    injectable(),
    __param$u(0, inject(ContributionProvider)),
    __param$u(0, named(ImageRenderContribution)),
    __metadata$H("design:paramtypes", [Object]),
  ],
  DefaultCanvasImageRender
);
const IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution"),
  ArcRender = Symbol.for("ArcRender"),
  Arc3dRender = Symbol.for("Arc3dRender"),
  AreaRender = Symbol.for("AreaRender"),
  CircleRender = Symbol.for("CircleRender"),
  GraphicRender = Symbol.for("GraphicRender"),
  GroupRender = Symbol.for("GroupRender"),
  LineRender = Symbol.for("LineRender"),
  PathRender = Symbol.for("PathRender"),
  PolygonRender = Symbol.for("PolygonRender"),
  RectRender = Symbol.for("RectRender"),
  Rect3DRender = Symbol.for("Rect3DRender"),
  SymbolRender = Symbol.for("SymbolRender"),
  TextRender = Symbol.for("TextRender"),
  RichTextRender = Symbol.for("RichTextRender"),
  Pyramid3dRender = Symbol.for("Pyramid3dRender"),
  GlyphRender = Symbol.for("GlyphRender"),
  ImageRender = Symbol.for("ImageRender"),
  DrawContribution = Symbol.for("DrawContribution");
var __decorate$U =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$G =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
const DrawItemInterceptor = Symbol.for("DrawItemInterceptor"),
  tempDirtyBounds = new AABBBounds(),
  tempBackupDirtyBounds = new AABBBounds();
class ShadowRootDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(e, T, C, $, F) {
    return (
      (null == e.attribute.shadowRootIdx &&
        e.shadowRoot &&
        e.shadowRoot.attribute.shadowRootIdx < 0) ||
        ((e.attribute.shadowRootIdx > 0 ||
          !e.attribute.shadowRootIdx ||
          (e.shadowRoot && e.shadowRoot.attribute.shadowRootIdx > 0)) &&
          this.drawItem(e, T, C, $, F)),
      !1
    );
  }
  beforeDrawItem(e, T, C, $, F) {
    return (
      (null == e.attribute.shadowRootIdx &&
        e.shadowRoot &&
        e.shadowRoot.attribute.shadowRootIdx > 0) ||
        ((e.attribute.shadowRootIdx < 0 ||
          (e.shadowRoot && e.shadowRoot.attribute.shadowRootIdx < 0)) &&
          this.drawItem(e, T, C, $, F)),
      !1
    );
  }
  drawItem(e, T, C, $, F) {
    if (!e.shadowRoot) return !1;
    const { context: V } = C;
    if (
      (V.highPerformanceSave(),
      V.transformFromMatrix(e.transMatrix, !0),
      $.dirtyBounds && $.backupDirtyBounds)
    ) {
      tempDirtyBounds.copy($.dirtyBounds),
        tempBackupDirtyBounds.copy($.backupDirtyBounds);
      const T = e.globalTransMatrix.getInverse();
      $.dirtyBounds.copy($.backupDirtyBounds).transformWithMatrix(T),
        $.backupDirtyBounds.copy($.dirtyBounds);
    }
    return (
      $.renderGroup(e.shadowRoot, C, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)),
      V.highPerformanceRestore(),
      $.dirtyBounds &&
        $.backupDirtyBounds &&
        ($.dirtyBounds.copy(tempDirtyBounds),
        $.backupDirtyBounds.copy(tempBackupDirtyBounds)),
      !0
    );
  }
}
class DebugDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(e, T, C, $, F) {
    return e.attribute._debug_bounds && this.drawItem(e, T, C, $, F), !1;
  }
  drawItem(e, T, C, $, F) {
    if (!e.attribute._debug_bounds) return !1;
    const { context: V } = C;
    V.highPerformanceSave(),
      e.parent && V.setTransformFromMatrix(e.parent.globalTransMatrix, !0),
      e.glyphHost &&
        e.glyphHost.parent &&
        V.setTransformFromMatrix(e.glyphHost.parent.globalTransMatrix, !0);
    const Y = e.AABBBounds;
    return (
      !0 !== e.attribute._debug_bounds && e.attribute._debug_bounds(V, e),
      V.strokeRect(Y.x1, Y.y1, Y.width(), Y.height()),
      V.highPerformanceRestore(),
      !0
    );
  }
}
let CommonDrawItemInterceptorContribution = class {
  constructor() {
    (this.order = 1),
      (this.interceptors = [
        new ShadowRootDrawItemInterceptorContribution(),
        new Canvas3DDrawItemInterceptor(),
        new InteractiveDrawItemInterceptorContribution(),
        new DebugDrawItemInterceptorContribution(),
      ]);
  }
  afterDrawItem(e, T, C, $, F) {
    for (let V = 0; V < this.interceptors.length; V++)
      if (
        this.interceptors[V].afterDrawItem &&
        this.interceptors[V].afterDrawItem(e, T, C, $, F)
      )
        return !0;
    return !1;
  }
  beforeDrawItem(e, T, C, $, F) {
    if (
      (!e.in3dMode || C.in3dInterceptor) &&
      !e.shadowRoot &&
      !(e.baseGraphic || e.attribute.globalZIndex || e.interactiveGraphic)
    )
      return !1;
    for (let V = 0; V < this.interceptors.length; V++)
      if (
        this.interceptors[V].beforeDrawItem &&
        this.interceptors[V].beforeDrawItem(e, T, C, $, F)
      )
        return !0;
    return !1;
  }
};
CommonDrawItemInterceptorContribution = __decorate$U(
  [injectable(), __metadata$G("design:paramtypes", [])],
  CommonDrawItemInterceptorContribution
);
class InteractiveDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(e, T, C, $, F) {
    return (
      !this.processing &&
      (e.baseGraphic
        ? this.beforeDrawInteractive(e, T, C, $, F)
        : this.beforeSetInteractive(e, T, C, $, F))
    );
  }
  beforeSetInteractive(e, T, C, $, F) {
    let V = e.interactiveGraphic;
    if (e.attribute.globalZIndex) {
      V || ((V = e.clone()), (e.interactiveGraphic = V), (V.baseGraphic = e)),
        V.setAttributes(
          {
            globalZIndex: 0,
            zIndex: e.attribute.globalZIndex,
          },
          !1,
          {
            skipUpdateCallback: !0,
          }
        ),
        C.stage.tryInitInteractiveLayer();
      const T = C.stage.getLayer("_builtin_interactive");
      return T && this.getShadowRoot(T).add(V), !0;
    }
    if (V) {
      C.stage.tryInitInteractiveLayer();
      const T = C.stage.getLayer("_builtin_interactive");
      T && this.getShadowRoot(T).removeChild(V),
        (e.interactiveGraphic = null),
        (V.baseGraphic = null);
    }
    return !1;
  }
  beforeDrawInteractive(e, T, C, $, F) {
    const V = e.baseGraphic;
    if (!V.stage) {
      const T = C.stage.getLayer("_builtin_interactive");
      return T && this.getShadowRoot(T).removeChild(e), !0;
    }
    if (V) {
      this.processing = !0;
      const { context: e } = C;
      return (
        e.highPerformanceSave(),
        e.setTransformFromMatrix(V.parent.globalTransMatrix, !0),
        V.isContainer
          ? $.renderGroup(V, C, V.parent.globalTransMatrix)
          : $.renderItem(V, C),
        e.highPerformanceRestore(),
        (this.processing = !1),
        !0
      );
    }
    return !1;
  }
  getShadowRoot(e) {
    var T;
    let C = e.getElementById("_interactive_group");
    return (
      C ||
        ((C = graphicCreator.CreateGraphic("group", {})),
        (C.id = "_interactive_group"),
        e.add(C)),
      null !== (T = C.shadowRoot) && void 0 !== T ? T : C.attachShadow()
    );
  }
}
class Canvas3DDrawItemInterceptor {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(e, T, C, $, F) {
    if (!e.in3dMode || C.in3dInterceptor) return !1;
    C.in3dInterceptor = !0;
    const { context: V, stage: Y } = T.drawParams;
    V.canvas, V.save(), this.initCanvasCtx(V), (V.camera = Y.camera);
    const K = V.currentMatrix;
    (K.a /= V.dpr),
      (K.b /= V.dpr),
      (K.c /= V.dpr),
      (K.d /= V.dpr),
      (K.e /= V.dpr),
      (K.f /= V.dpr);
    const J = mat4Allocate.allocate();
    mat3Tomat4(J, K);
    const ee = V.modelMatrix;
    if (ee) {
      if (J) {
        const e = mat4Allocate.allocate();
        V.modelMatrix = multiplyMat4Mat4(e, ee, J);
      }
    } else V.modelMatrix = J;
    if ((V.setTransform(1, 0, 0, 1, 0, 0, !0), e.isContainer)) {
      let T = !1,
        F = !1;
      if (
        (e.forEachChildren(
          (e) => ((T = e.numberType === ARC3D_NUMBER_TYPE), !T)
        ),
        e.forEachChildren((e) => ((F = !!e.findFace), !F)),
        T)
      ) {
        const T = e.getChildren(),
          F = [...T];
        F.sort((e, T) => {
          var C, $, F, V;
          let Y =
              ((null !== (C = e.attribute.startAngle) && void 0 !== C ? C : 0) +
                (null !== ($ = e.attribute.endAngle) && void 0 !== $ ? $ : 0)) /
              2,
            K =
              ((null !== (F = T.attribute.startAngle) && void 0 !== F ? F : 0) +
                (null !== (V = T.attribute.endAngle) && void 0 !== V ? V : 0)) /
              2;
          for (; Y < 0; ) Y += pi2;
          for (; K < 0; ) K += pi2;
          return K - Y;
        }),
          F.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          e.removeAllChild(),
          e.update(),
          F.forEach((T) => {
            e.appendChild(T);
          });
        const V = e.parent.globalTransMatrix;
        (C.hack_pieFace = "outside"),
          $.renderGroup(e, C, V),
          (C.hack_pieFace = "inside"),
          $.renderGroup(e, C, V),
          (C.hack_pieFace = "top"),
          $.renderGroup(e, C, V),
          e.removeAllChild(),
          T.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          T.forEach((T) => {
            e.appendChild(T);
          });
      } else if (F) {
        const T = e.getChildren(),
          F = T.map((e) => ({
            ave_z: e
              .findFace()
              .vertices.map((T) => {
                var C;
                return V.view(
                  T[0],
                  T[1],
                  null !== (C = T[2] + e.attribute.z) && void 0 !== C ? C : 0
                )[2];
              })
              .reduce((e, T) => e + T, 0),
            g: e,
          }));
        F.sort((e, T) => T.ave_z - e.ave_z),
          e.removeAllChild(),
          F.forEach((e) => {
            (e.g._next = null), (e.g._prev = null);
          }),
          e.update(),
          F.forEach((T) => {
            e.add(T.g);
          }),
          $.renderGroup(e, C, e.parent.globalTransMatrix, !0),
          e.removeAllChild(),
          T.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          e.update(),
          T.forEach((T) => {
            e.add(T);
          });
      } else $.renderGroup(e, C, e.parent.globalTransMatrix);
    } else $.renderItem(e, C);
    return (
      (V.camera = null),
      V.restore(),
      V.modelMatrix !== ee && mat4Allocate.free(V.modelMatrix),
      (V.modelMatrix = ee),
      (C.in3dInterceptor = !1),
      !0
    );
  }
  initCanvasCtx(e) {
    e.setTransformForCurrent();
  }
}
var __decorate$T =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$F =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$t =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
const RenderService = Symbol.for("RenderService");
let DefaultRenderService = class {
  constructor(e) {
    this.drawContribution = e;
  }
  prepare(e) {
    e &&
      this.renderTreeRoots.forEach((T) => {
        this._prepare(T, e);
      });
  }
  _prepare(e, T) {
    e.forEachChildren((e) => {
      this._prepare(e, T);
    }),
      e.update({
        bounds: T,
        trans: !0,
      });
  }
  prepareRenderList() {}
  beforeDraw(e) {}
  draw(e) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(e) {
    this.drawContribution.afterDraw &&
      this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  render(e, T) {
    (this.renderTreeRoots = e), (this.drawParams = T);
    const C = T.updateBounds;
    this.prepare(C),
      this.prepareRenderList(),
      this.beforeDraw(T),
      this.draw(T),
      this.afterDraw(T),
      (this.drawParams = null);
  }
};
DefaultRenderService = __decorate$T(
  [
    injectable(),
    __param$t(0, inject(DrawContribution)),
    __metadata$F("design:paramtypes", [Object]),
  ],
  DefaultRenderService
);
const renderModule$1 = new ContainerModule((e) => {
    e(RenderService).to(DefaultRenderService);
  }),
  PickerService = Symbol.for("PickerService"),
  GlobalPickerService = Symbol.for("GlobalPickerService");
var __decorate$S =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
const PickItemInterceptor = Symbol.for("PickItemInterceptor");
let ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(e, T, C, $, F) {
    return e.attribute.shadowRootIdx > 0 || !e.attribute.shadowRootIdx
      ? this._pickItem(e, T, C, $, F)
      : null;
  }
  beforePickItem(e, T, C, $, F) {
    return e.attribute.shadowRootIdx < 0 ? this._pickItem(e, T, C, $, F) : null;
  }
  _pickItem(e, T, C, $, F) {
    var V;
    if (!e.shadowRoot) return null;
    const { parentMatrix: Y } = F || {};
    if (!Y) return null;
    const K = T.pickContext;
    K.highPerformanceSave();
    const J = null === (V = getTheme(e)) || void 0 === V ? void 0 : V[e.type],
      { shadowPickMode: ee = null == J ? void 0 : J.shadowPickMode } =
        e.attribute,
      te = e.shadowRoot,
      ie = matrixAllocate.allocateByObj(Y),
      ne = new Point(
        ie.a * C.x + ie.c * C.y + ie.e,
        ie.b * C.x + ie.d * C.y + ie.f
      ),
      re = T.pickGroup(te, ne, ie, $);
    return (
      K.highPerformanceRestore(),
      !re.graphic && re.group && "full" === ee && (re.graphic = re.group),
      re
    );
  }
};
ShadowRootPickItemInterceptorContribution = __decorate$S(
  [injectable()],
  ShadowRootPickItemInterceptorContribution
);
let InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(e, T, C, $, F) {
    const V = e.baseGraphic;
    if (V && V.parent) {
      const e = new Point(C.x, C.y),
        F = T.pickContext;
      F.highPerformanceSave();
      const Y = V.parent.globalTransMatrix;
      Y.transformPoint(e, e);
      const K = V.isContainer
        ? T.pickGroup(V, e.clone(), Y, $)
        : T.pickItem(V, e.clone(), Y, $);
      return F.highPerformanceRestore(), K;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate$S(
  [injectable()],
  InteractivePickItemInterceptorContribution
);
let Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(e, T, C, $, F) {
    if (!e.in3dMode || $.in3dInterceptor) return null;
    const V = T.pickContext,
      Y = e.stage;
    if (!V || !Y) return null;
    if (
      (($.in3dInterceptor = !0),
      V.save(),
      this.initCanvasCtx(V),
      (V.camera = Y.camera),
      e.isContainer)
    ) {
      let Y,
        K = !1,
        J = !1;
      if (
        (e.forEachChildren(
          (e) => ((K = e.numberType === ARC3D_NUMBER_TYPE), !K)
        ),
        e.forEachChildren((e) => ((J = !!e.findFace), !J)),
        K)
      ) {
        const V = e.getChildren(),
          K = [...V];
        K.sort((e, T) => {
          var C, $, F, V;
          let Y =
              (null !==
                ($ =
                  null !== (C = e.attribute.startAngle) && void 0 !== C
                    ? C
                    : 0 + e.attribute.endAngle) && void 0 !== $
                ? $
                : 0) / 2,
            K =
              (null !==
                (V =
                  null !== (F = T.attribute.startAngle) && void 0 !== F
                    ? F
                    : 0 + T.attribute.endAngle) && void 0 !== V
                ? V
                : 0) / 2;
          for (; Y < 0; ) Y += pi2;
          for (; K < 0; ) K += pi2;
          return K - Y;
        }),
          K.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          e.removeAllChild(),
          e.update(),
          K.forEach((T) => {
            e.appendChild(T);
          }),
          ($.hack_pieFace = "outside"),
          (Y = T.pickGroup(e, C, F.parentMatrix, $)),
          Y.graphic ||
            (($.hack_pieFace = "inside"),
            (Y = T.pickGroup(e, C, F.parentMatrix, $))),
          Y.graphic ||
            (($.hack_pieFace = "top"),
            (Y = T.pickGroup(e, C, F.parentMatrix, $))),
          e.removeAllChild(),
          V.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          V.forEach((T) => {
            e.appendChild(T);
          });
      } else if (J) {
        const K = e.getChildren(),
          J = K.map((e) => ({
            ave_z: e
              .findFace()
              .vertices.map((T) => {
                var C;
                return V.view(
                  T[0],
                  T[1],
                  null !== (C = T[2] + e.attribute.z) && void 0 !== C ? C : 0
                )[2];
              })
              .reduce((e, T) => e + T, 0),
            g: e,
          }));
        J.sort((e, T) => T.ave_z - e.ave_z),
          e.removeAllChild(),
          J.forEach((e) => {
            (e.g._next = null), (e.g._prev = null);
          }),
          e.update(),
          J.forEach((T) => {
            e.add(T.g);
          }),
          (Y = T.pickGroup(e, C, F.parentMatrix, $)),
          e.removeAllChild(),
          K.forEach((e) => {
            (e._next = null), (e._prev = null);
          }),
          e.update(),
          K.forEach((T) => {
            e.add(T);
          });
      } else Y = T.pickGroup(e, C, F.parentMatrix, $);
      return (V.camera = null), ($.in3dInterceptor = !1), V.restore(), Y;
    }
    return V.restore(), null;
  }
  initCanvasCtx(e) {
    e.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate$S(
  [injectable()],
  Canvas3DPickItemInterceptor
);
const pickModule = new ContainerModule((e, T, C) => {
    C(PickerService) ||
      (e(GlobalPickerService).toSelf(),
      e(PickerService).toService(GlobalPickerService)),
      e(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(),
      e(PickItemInterceptor).toService(Canvas3DPickItemInterceptor),
      e(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(),
      e(PickItemInterceptor).toService(
        ShadowRootPickItemInterceptorContribution
      ),
      e(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(),
      e(PickItemInterceptor).toService(
        InteractivePickItemInterceptorContribution
      ),
      bindContributionProvider(e, PickItemInterceptor);
  }),
  graphicModule = new ContainerModule((e) => {
    e(GraphicService).to(DefaultGraphicService).inSingletonScope(),
      e(GraphicCreator$1).toConstantValue(graphicCreator);
  }),
  AutoEnablePlugins = Symbol.for("AutoEnablePlugins"),
  PluginService = Symbol.for("PluginService");
var __decorate$R =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$E =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$s =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultPluginService = class {
  constructor(e) {
    (this.autoEnablePlugins = e),
      (this.onStartupFinishedPlugin = []),
      (this.onRegisterPlugin = []),
      (this.actived = !1);
  }
  active(e, T) {
    (this.stage = e), (this.actived = !0);
    const { pluginList: C } = T;
    C &&
      container.isBound(AutoEnablePlugins) &&
      this.autoEnablePlugins.getContributions().forEach((e) => {
        C.includes(e.name) && this.register(e);
      });
  }
  findPluginsByName(e) {
    const T = [];
    return (
      this.onStartupFinishedPlugin.forEach((C) => {
        C.name === e && T.push(C);
      }),
      this.onRegisterPlugin.forEach((C) => {
        C.name === e && T.push(C);
      }),
      T
    );
  }
  register(e) {
    "onStartupFinished" === e.activeEvent
      ? this.onStartupFinishedPlugin.push(e)
      : "onRegister" === e.activeEvent &&
        (this.onRegisterPlugin.push(e), e.activate(this));
  }
  unRegister(e) {
    "onStartupFinished" === e.activeEvent
      ? this.onStartupFinishedPlugin.splice(
          this.onStartupFinishedPlugin.indexOf(e),
          1
        )
      : "onRegister" === e.activeEvent &&
        this.onRegisterPlugin.splice(
          this.onStartupFinishedPlugin.indexOf(e),
          1
        ),
      e.deactivate(this);
  }
  release(...e) {
    this.onStartupFinishedPlugin.forEach((e) => {
      e.deactivate(this);
    }),
      (this.onStartupFinishedPlugin = []),
      this.onRegisterPlugin.forEach((e) => {
        e.deactivate(this);
      }),
      (this.onRegisterPlugin = []);
  }
};
DefaultPluginService = __decorate$R(
  [
    injectable(),
    __param$s(0, inject(ContributionProvider)),
    __param$s(0, named(AutoEnablePlugins)),
    __metadata$E("design:paramtypes", [Object]),
  ],
  DefaultPluginService
);
const pluginModule = new ContainerModule((e) => {
    e(PluginService).to(DefaultPluginService),
      bindContributionProviderNoSingletonScope(e, AutoEnablePlugins);
  }),
  envModules = new ContainerModule((e) => {
    bindContributionProvider(e, EnvContribution);
  }),
  textMeasureModules = new ContainerModule((e) => {
    e(TextMeasureContribution)
      .to(DefaultTextMeasureContribution)
      .inSingletonScope(),
      bindContributionProvider(e, TextMeasureContribution);
  });
var __decorate$Q =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$D =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let CanvasLayerHandlerContribution = class {
  constructor() {
    (this.type = "static"),
      (this.offscreen = !1),
      (this.global = application.global);
  }
  setDpr(e) {
    this.canvas.dpr = e;
  }
  init(e, T, C) {
    if (((this.layer = e), (this.window = T), C.main))
      (this.main = !0),
        (this.context = T.getContext()),
        (this.canvas = this.context.getCanvas());
    else {
      let e;
      (this.main = !1),
        C.canvasId && (e = this.global.getElementById(C.canvasId)),
        e ||
          (e = this.global.createCanvas({
            width: T.width,
            height: T.height,
          })),
        e.style && (e.style["pointer-events"] = "none");
      const $ = T.getContext().getCanvas().nativeCanvas,
        F = wrapCanvas({
          nativeCanvas: e,
          width: T.width,
          height: T.height,
          dpr: T.dpr,
          id: C.canvasId,
          canvasControled: !0,
          container: T.getContainer(),
          x: $.offsetLeft,
          y: $.offsetTop,
        });
      F.applyPosition(), (this.canvas = F), (this.context = F.getContext());
    }
  }
  resize(e, T) {
    this.canvas.resize(e, T);
  }
  resizeView(e, T) {}
  render(e, T, C) {
    var $;
    if (!this.main) {
      const e = this.window.getContext().getCanvas().nativeCanvas;
      !e ||
        (this.canvas.x === e.offsetLeft && this.canvas.y === e.offsetTop) ||
        ((this.canvas.x = e.offsetLeft),
        (this.canvas.y = e.offsetTop),
        this.canvas.applyPosition());
    }
    T.renderService.render(
      e,
      Object.assign(
        Object.assign(
          {
            context: this.context,
            clear: null !== ($ = T.background) && void 0 !== $ ? $ : "#ffffff",
          },
          T
        ),
        C
      )
    );
  }
  merge(e) {
    e.forEach((e) => {
      const T = e.getContext().canvas.nativeCanvas;
      this.context.drawImage(T, 0, 0);
    });
  }
  prepare(e, T) {}
  drawTo(e, T, C) {
    var $;
    const F = e.getContext();
    C.renderService.render(
      T,
      Object.assign(
        Object.assign(
          {
            context: F,
          },
          C
        ),
        {
          clear: C.clear
            ? null !== ($ = C.background) && void 0 !== $
              ? $
              : "#fff"
            : void 0,
        }
      )
    );
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate$Q(
  [injectable(), __metadata$D("design:paramtypes", [])],
  CanvasLayerHandlerContribution
);
var __decorate$P =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$C =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let EmptyLayerHandlerContribution = class {
  constructor() {
    (this.offscreen = !1),
      (this.type = "virtual"),
      (this.global = application.global);
  }
  setDpr(e) {}
  init(e, T, C) {
    if (((this.layer = e), (this.window = T), C.main))
      throw new Error("virtual layermain layer");
    (this.main = !1), (this.canvas = null), (this.context = null);
  }
  resize(e, T) {}
  resizeView(e, T) {}
  render(e, T, C) {
    this.mainHandler.render(
      e,
      T,
      Object.assign(Object.assign({}, C), {
        clear: !1,
      })
    );
  }
  merge(e) {}
  prepare(e, T) {}
  drawTo(e, T, C) {
    var $;
    const F = e.getContext();
    C.renderService.render(
      T,
      Object.assign(
        Object.assign(
          {
            context: F,
          },
          C
        ),
        {
          clear: C.clear
            ? null !== ($ = C.background) && void 0 !== $
              ? $
              : "#fff"
            : void 0,
        }
      )
    );
  }
  getContext() {
    return null;
  }
  release() {}
};
EmptyLayerHandlerContribution = __decorate$P(
  [injectable(), __metadata$C("design:paramtypes", [])],
  EmptyLayerHandlerContribution
);
var __decorate$O =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$B =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let OffscreenLayerHandlerContribution = class {
  constructor() {
    (this.offscreen = !0),
      (this.type = "dynamic"),
      (this.global = application.global);
  }
  setDpr(e) {
    this.canvas.dpr = e;
  }
  init(e, T, C) {
    this.layer = e;
    const $ = wrapCanvas({
      nativeCanvas: this.global.createOffscreenCanvas({
        width: C.width,
        height: C.height,
        dpr: T.dpr,
      }),
      width: C.width,
      height: C.height,
      dpr: T.dpr,
      canvasControled: !0,
    });
    (this.canvas = $), (this.context = $.getContext());
  }
  resize(e, T) {
    this.canvas.resize(e, T);
  }
  resizeView(e, T) {
    this.canvas.resize(e, T);
  }
  render(e, T) {
    var C;
    T.renderService.render(
      e,
      Object.assign(
        Object.assign(
          {
            context: this.context,
            viewBox: T.stage.window.getViewBox(),
            transMatrix: T.stage.window.getViewBoxTransform(),
          },
          T
        ),
        {
          clear: null !== (C = T.background) && void 0 !== C ? C : "#ffffff",
        }
      )
    );
  }
  prepare(e, T) {}
  release() {
    this.canvas.release();
  }
  getContext() {
    return this.context;
  }
  drawTo(e, T, C) {
    const $ = e.getContext(),
      F = e.dpr,
      { viewBox: V } = C,
      Y = V.x1,
      K = V.y1,
      J = V.width(),
      ee = V.height();
    $.nativeContext.save(),
      $.nativeContext.setTransform(F, 0, 0, F, 0, 0),
      C.clear && $.clearRect(Y, K, J, ee),
      $.drawImage(
        this.canvas.nativeCanvas,
        0,
        0,
        this.canvas.width,
        this.canvas.height,
        Y,
        K,
        J,
        ee
      ),
      $.nativeContext.restore();
  }
  merge(e) {}
};
OffscreenLayerHandlerContribution = __decorate$O(
  [injectable(), __metadata$B("design:paramtypes", [])],
  OffscreenLayerHandlerContribution
);
const layerHandlerModules = new ContainerModule((e) => {
  e(CanvasLayerHandlerContribution).toSelf(),
    e(OffscreenLayerHandlerContribution).toSelf(),
    e(EmptyLayerHandlerContribution).toSelf(),
    e(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution),
    e(DynamicLayerHandlerContribution).toService(
      OffscreenLayerHandlerContribution
    ),
    e(VirtualLayerHandlerContribution).toService(EmptyLayerHandlerContribution);
});
function load$1(e) {
  e.load(envModules), e.load(textMeasureModules), e.load(layerHandlerModules);
}
var __awaiter$1 =
  (globalThis && globalThis.__awaiter) ||
  function (e, T, C, $) {
    return new (C || (C = Promise))(function (F, V) {
      function Y(e) {
        try {
          J($.next(e));
        } catch (T) {
          V(T);
        }
      }
      function K(e) {
        try {
          J($.throw(e));
        } catch (T) {
          V(T);
        }
      }
      function J(e) {
        var T;
        e.done
          ? F(e.value)
          : ((T = e.value),
            T instanceof C
              ? T
              : new C(function (e) {
                  e(T);
                })).then(Y, K);
      }
      J(($ = $.apply(e, T || [])).next());
    });
  };
function foreach(e, T, C, $ = !1, F = !1) {
  const V = {},
    Y = [];
  let K = !1;
  if (F) K = !0;
  else {
    let C;
    e.forEachChildren((e, $) => {
      const { zIndex: F = T } = e.attribute;
      if (0 === $) C = F;
      else if (C !== F) return (K = !0), !0;
      return !1;
    }, $);
  }
  if (K) {
    e.forEachChildren((e) => {
      const { zIndex: C = T } = e.attribute;
      V[C] ? V[C].push(e) : ((V[C] = [e]), Y.push(C));
    }, $),
      Y.sort((e, T) => ($ ? T - e : e - T));
    let K = !1;
    for (let e = 0; e < Y.length && !K; e++) {
      const T = Y[e],
        J = V[T];
      F &&
        J.sort((e, T) => {
          var C, F;
          return (
            ($ ? -1 : 1) *
            ((null !== (C = T.attribute.z) && void 0 !== C ? C : 0) -
              (null !== (F = e.attribute.z) && void 0 !== F ? F : 0))
          );
        });
      for (let e = 0; e < J.length; e++)
        if (C(J[e], e)) {
          K = !0;
          break;
        }
    }
  } else e.forEachChildren(C, $);
}
function foreachAsync(e, T, C, $ = !1) {
  return __awaiter$1(this, void 0, void 0, function* () {
    yield e.forEachChildrenAsync(C, $);
  });
}
function findNextGraphic(e, T, C, $ = !1) {
  const F = {},
    V = [];
  let Y = !1;
  e.forEachChildren((e, T) => {
    const { zIndex: $ = C } = e.attribute;
    if (0 === T);
    else if (void 0 !== $) return (Y = !0), !0;
    return !1;
  }, $);
  let K = null,
    J = !1;
  if (Y) {
    e.forEachChildren((e) => {
      const { zIndex: T = C } = e.attribute;
      F[T] ? F[T].push(e) : ((F[T] = [e]), V.push(T));
    }, $),
      V.sort((e, T) => ($ ? T - e : e - T));
    let Y = !1;
    for (let e = 0; e < V.length && !Y; e++) {
      const C = V[e],
        $ = F[C];
      for (let e = 0; e < $.length; e++) {
        if (J) {
          (Y = !0), (K = $[e]);
          break;
        }
        $[e]._uid !== T || (J = !0);
      }
    }
  } else
    e.forEachChildren(
      (e) => (J ? ((K = e), !0) : (e._uid === T && (J = !0), !1)),
      $
    );
  return K;
}
var __decorate$N =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$A =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$r =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultDrawContribution = class {
  constructor(e, T) {
    (this.contributions = e),
      (this.drawItemInterceptorContributions = T),
      (this.currentRenderMap = new Map()),
      (this.defaultRenderMap = new Map()),
      (this.styleRenderMap = new Map()),
      (this.dirtyBounds = new Bounds()),
      (this.backupDirtyBounds = new Bounds()),
      (this.global = application.global),
      (this.layerService = application.layerService),
      this.init();
  }
  init() {
    this.contributions.forEach((e) => {
      if (e.style) {
        const T = this.styleRenderMap.get(e.style) || new Map();
        T.set(e.numberType, e), this.styleRenderMap.set(e.style, T);
      } else this.defaultRenderMap.set(e.numberType, e);
    }),
      (this.InterceptorContributions = this.drawItemInterceptorContributions
        .getContributions()
        .sort((e, T) => e.order - T.order));
  }
  prepareForDraw(e, T) {
    T.updateBounds
      ? (this.useDirtyBounds = !0)
      : (this.useDirtyBounds =
          !T.stage.params.optimize.disableCheckGraphicWidthOutRange);
  }
  draw(e, T) {
    this.prepareForDraw(e, T),
      (T.drawContribution = this),
      (this.currentRenderMap =
        this.styleRenderMap.get(T.renderStyle) || this.defaultRenderMap),
      (this.currentRenderService = e);
    const { context: C, stage: $, viewBox: F, transMatrix: V } = T;
    if (!C) return;
    const Y = this.dirtyBounds.setValue(0, 0, F.width(), F.height());
    if ($.dirtyBounds && !$.dirtyBounds.empty()) {
      const e = getRectIntersect(Y, $.dirtyBounds, !1);
      (Y.x1 = Math.floor(e.x1)),
        (Y.y1 = Math.floor(e.y1)),
        (Y.x2 = Math.ceil(e.x2)),
        (Y.y2 = Math.ceil(e.y2));
    }
    const K = C.dpr % 1;
    (K || 0.5 !== K) &&
      ((Y.x1 = Math.floor(Y.x1 * C.dpr) / C.dpr),
      (Y.y1 = Math.floor(Y.y1 * C.dpr) / C.dpr),
      (Y.x2 = Math.ceil(Y.x2 * C.dpr) / C.dpr),
      (Y.y2 = Math.ceil(Y.y2 * C.dpr) / C.dpr)),
      this.backupDirtyBounds.copy(Y),
      (C.inuse = !0),
      C.setClearMatrix(V.a, V.b, V.c, V.d, V.e, V.f),
      C.clearMatrix(),
      C.setTransformForCurrent(!0),
      C.translate(F.x1, F.y1, !0),
      C.beginPath(),
      C.rect(Y.x1, Y.y1, Y.width(), Y.height()),
      C.clip(),
      $.camera &&
        (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
        this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)),
      this.clearScreen(e, C, T),
      C.save(),
      e.renderTreeRoots
        .sort((e, T) => {
          var C, $;
          return (
            (null !== (C = e.attribute.zIndex) && void 0 !== C
              ? C
              : DefaultAttribute.zIndex) -
            (null !== ($ = T.attribute.zIndex) && void 0 !== $
              ? $
              : DefaultAttribute.zIndex)
          );
        })
        .forEach((e) => {
          e.isContainer
            ? this.renderGroup(e, T, matrixAllocate.allocate(1, 0, 0, 1, 0, 0))
            : this.renderItem(e, T);
        }),
      C.restore(),
      C.setClearMatrix(1, 0, 0, 1, 0, 0),
      (C.inuse = !1),
      C.draw();
  }
  doRegister() {
    throw new Error("");
  }
  _findNextGraphic(e) {
    let T = e.parent,
      C = e._uid;
    for (; T; ) {
      const e = findNextGraphic(T, C, DefaultAttribute.zIndex);
      if (e) return e;
      (C = T._uid), (T = T.parent);
    }
    return null;
  }
  renderGroup(e, T, C, $) {
    if (T.break || !1 === e.attribute.visibleAll) return;
    if (e.incremental && (null == T.startAtId || T.startAtId === e._uid))
      return (T.break = !0), void this._increaseRender(e, T);
    if (
      this.useDirtyBounds &&
      !isRectIntersect(e.AABBBounds, this.dirtyBounds, !1)
    )
      return;
    let F,
      V = C;
    if (this.useDirtyBounds) {
      F = boundsAllocate.allocateByObj(this.dirtyBounds);
      const T = e.transMatrix;
      (V = matrixAllocate
        .allocateByObj(C)
        .multiply(T.a, T.b, T.c, T.d, T.e, T.f)),
        this.dirtyBounds
          .copy(this.backupDirtyBounds)
          .transformWithMatrix(V.getInverse());
    }
    this.renderItem(e, T, {
      drawingCb: () => {
        var C;
        $
          ? e.forEachChildren((e) => {
              T.break ||
                (e.isContainer
                  ? this.renderGroup(e, T, V)
                  : this.renderItem(e, T));
            })
          : foreach(
              e,
              DefaultAttribute.zIndex,
              (e) => {
                T.break ||
                  (e.isContainer
                    ? this.renderGroup(e, T, V)
                    : this.renderItem(e, T));
              },
              !1,
              !!(null === (C = T.context) || void 0 === C ? void 0 : C.camera)
            );
      },
    }),
      this.useDirtyBounds &&
        (this.dirtyBounds.copy(F),
        boundsAllocate.free(F),
        matrixAllocate.free(V));
  }
  _increaseRender(e, T) {
    const { layer: C, stage: $ } = T,
      { subLayers: F } = C;
    let V = F.get(e._uid);
    V ||
      ((V = {
        layer: this.layerService.createLayer($),
        zIndex: F.size,
        group: e,
      }),
      F.set(e._uid, V));
    const Y = V.layer.getNativeHandler().getContext(),
      K = V.drawContribution || container.get(IncrementalDrawContribution);
    K.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
      K.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0),
      K.draw(
        this.currentRenderService,
        Object.assign(Object.assign({}, T), {
          drawContribution: K,
          clear: "transparent",
          layer: V.layer,
          context: Y,
          startAtId: e._uid,
          break: !1,
        })
      ),
      (V.drawContribution = K);
    const J = this._findNextGraphic(e);
    if (J)
      if (J.isContainer && J.incremental) this._increaseRender(J, T);
      else {
        let e = F.get(J._uid);
        e ||
          ((e = {
            layer: this.layerService.createLayer($),
            zIndex: F.size,
          }),
          F.set(J._uid, e));
        const C = e.layer.getNativeHandler().getContext();
        this.draw(
          this.currentRenderService,
          Object.assign(Object.assign({}, T), {
            drawContribution: K,
            clear: "transparent",
            layer: e.layer,
            context: C,
            startAtId: J._uid,
            break: !1,
          })
        );
      }
  }
  getRenderContribution(e) {
    let T;
    return (
      T || (T = this.selectRenderByNumberType(e.numberType, e)),
      T || (T = this.selectRenderByType(e.type)),
      T
    );
  }
  renderItem(e, T, C) {
    if (this.InterceptorContributions.length)
      for (let K = 0; K < this.InterceptorContributions.length; K++) {
        const $ = this.InterceptorContributions[K];
        if (
          $.beforeDrawItem &&
          $.beforeDrawItem(e, this.currentRenderService, T, this, C)
        )
          return;
      }
    const $ = this.getRenderContribution(e);
    if (!$) return;
    let F,
      V = !1;
    if (e.parent) {
      const { scrollX: T = 0, scrollY: C = 0 } = e.parent.attribute;
      if (((V = !(!T && !C)), V)) {
        F = this.dirtyBounds.clone();
        const $ = e.globalTransMatrix.getInverse();
        this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix($),
          this.dirtyBounds.translate(-T, -C);
      }
    }
    if (
      this.useDirtyBounds &&
      !e.isContainer &&
      !isRectIntersect(e.AABBBounds, this.dirtyBounds, !1)
    )
      return void (V && this.dirtyBounds.copy(F));
    const Y = null != T.startAtId && e._uid !== T.startAtId;
    if (
      (e._uid === T.startAtId && (T.startAtId = null),
      C && (C.skipDraw = Y),
      Y
        ? e.isContainer && $.draw(e, this.currentRenderService, T, C)
        : $.draw(e, this.currentRenderService, T, C),
      V && this.dirtyBounds.copy(F),
      this.InterceptorContributions.length)
    )
      for (let K = 0; K < this.InterceptorContributions.length; K++) {
        const C = this.InterceptorContributions[K];
        if (
          C.afterDrawItem &&
          C.afterDrawItem(e, this.currentRenderService, T, this)
        )
          return;
      }
  }
  selectRenderByType(e) {
    return Logger.getInstance().warn(""), null;
  }
  selectRenderByNumberType(e, T) {
    let C;
    if (T.attribute.renderStyle) {
      const $ = this.styleRenderMap.get(T.attribute.renderStyle);
      C = $ && $.get(e);
    }
    return C || this.currentRenderMap.get(e) || this.defaultRenderMap.get(e);
  }
  clearScreen(e, T, C) {
    var $, F;
    const { clear: V, viewBox: Y } = C,
      K = Y.width(),
      J = Y.height();
    if (V) {
      T.clearRect(0, 0, K, J);
      const C = null === ($ = e.drawParams) || void 0 === $ ? void 0 : $.stage;
      if (
        (C &&
          (T.globalAlpha =
            null !== (F = C.attribute.opacity) && void 0 !== F ? F : 1),
        C && C.backgroundImg && C.resources)
      ) {
        const e = C.resources.get(V);
        e && "success" === e.state && e.data && T.drawImage(e.data, 0, 0, K, J);
      } else
        (T.fillStyle = createColor(
          T,
          V,
          {
            AABBBounds: {
              x1: 0,
              y1: 0,
              x2: 0 + K,
              y2: 0 + J,
            },
          },
          0,
          0
        )),
          T.fillRect(0, 0, K, J);
    }
  }
  afterDraw(e, T) {}
};
DefaultDrawContribution = __decorate$N(
  [
    injectable(),
    __param$r(0, multiInject(GraphicRender)),
    __param$r(1, inject(ContributionProvider)),
    __param$r(1, named(DrawItemInterceptor)),
    __metadata$A("design:paramtypes", [Array, Object]),
  ],
  DefaultDrawContribution
);
var __decorate$M =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), (this.numberType = LINE_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    if (e.incremental && F.multiGraphicOptions) {
      const { startAtIdx: T, length: V } = F.multiGraphicOptions,
        { segments: J = [] } = e.attribute;
      if (T > J.length) return;
      const ee = getTheme(e).line,
        {
          fill: te = ee.fill,
          stroke: ie = ee.stroke,
          opacity: ne = ee.opacity,
          fillOpacity: re = ee.fillOpacity,
          strokeOpacity: ae = ee.strokeOpacity,
          lineWidth: oe = ee.lineWidth,
          visible: se = ee.visible,
        } = e.attribute,
        le = fillVisible(ne, re, te),
        de = strokeVisible(ne, ae),
        ce = runFill(te),
        ue = runStroke(ie, oe);
      if (!e.valid || !se) return;
      if (!ce && !ue) return;
      if (!(le || de || Y || K)) return;
      const { context: he } = F;
      for (let F = T; F < T + V; F++)
        this.drawIncreaseSegment(
          e,
          he,
          J[F - 1],
          J[F],
          e.attribute.segments[F],
          [ee, e.attribute],
          C,
          $
        );
    } else super.drawShape(e, T, C, $, F, V, Y, K);
  }
  drawIncreaseSegment(e, T, C, $, F, V, Y, K) {
    $ &&
      (T.beginPath(),
      drawIncrementalSegments(T.nativeContext, C, $, {
        offsetX: Y,
        offsetY: K,
      }),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, F, V),
      T.setStrokeStyle(e, F, Y, K, V),
      T.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate$M(
  [injectable()],
  DefaultIncrementalCanvasLineRender
);
var __decorate$L =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), (this.numberType = AREA_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y) {
    if (e.incremental && F.multiGraphicOptions) {
      const { startAtIdx: V, length: K } = F.multiGraphicOptions,
        { segments: J = [] } = e.attribute;
      if (V > J.length) return;
      const ee = getTheme(e).area,
        {
          fill: te = ee.fill,
          fillOpacity: ie = ee.fillOpacity,
          opacity: ne = ee.opacity,
          visible: re = ee.visible,
        } = e.attribute,
        ae = fillVisible(ne, ie, te),
        oe = runFill(te);
      if (!e.valid || !re) return;
      if (!oe) return;
      if (!ae && !Y) return;
      for (let F = V; F < V + K; F++)
        this.drawIncreaseSegment(
          e,
          T,
          J[F - 1],
          J[F],
          e.attribute.segments[F],
          [ee, e.attribute],
          C,
          $
        );
    } else super.drawShape(e, T, C, $, F, V, Y);
  }
  drawIncreaseSegment(e, T, C, $, F, V, Y, K) {
    $ &&
      (T.beginPath(),
      drawIncrementalAreaSegments(T.camera ? T : T.nativeContext, C, $, {
        offsetX: Y,
        offsetY: K,
      }),
      T.setShadowBlendStyle && T.setShadowBlendStyle(e, F, V),
      T.setCommonStyle(e, F, Y, K, V),
      T.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate$L(
  [injectable()],
  DefaultIncrementalCanvasAreaRender
);
var STATUS,
  __decorate$K =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$z =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$q =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    },
  __awaiter =
    (globalThis && globalThis.__awaiter) ||
    function (e, T, C, $) {
      return new (C || (C = Promise))(function (F, V) {
        function Y(e) {
          try {
            J($.next(e));
          } catch (T) {
            V(T);
          }
        }
        function K(e) {
          try {
            J($.throw(e));
          } catch (T) {
            V(T);
          }
        }
        function J(e) {
          var T;
          e.done
            ? F(e.value)
            : ((T = e.value),
              T instanceof C
                ? T
                : new C(function (e) {
                    e(T);
                  })).then(Y, K);
        }
        J(($ = $.apply(e, T || [])).next());
      });
    },
  STATUS2;
(STATUS2 = STATUS || (STATUS = {})),
  (STATUS2[(STATUS2.NORMAL = 0)] = "NORMAL"),
  (STATUS2[(STATUS2.STOP = 1)] = "STOP");
let DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(e, T, C, $) {
    super(e, $),
      (this.contributions = e),
      (this.lineRender = T),
      (this.areaRender = C),
      (this.drawItemInterceptorContributions = $),
      (this.rendering = !1),
      (this.currFrameStartAt = 0),
      (this.currentIdx = 0),
      (this.status = STATUS.NORMAL),
      (this.checkingForDrawPromise = null),
      (this.hooks = {
        completeDraw: new SyncHook([]),
      }),
      this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender),
      this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(e, T) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      (this.lastRenderService = e),
        (this.lastDrawContext = T),
        (this.checkingForDrawPromise = this.checkForDraw(T));
      const C = yield this.checkingForDrawPromise;
      if (((this.checkingForDrawPromise = null), C)) return;
      this.currentRenderService = e;
      const { context: $, viewBox: F } = T;
      $ &&
        (($.inuse = !0),
        $.clearMatrix(),
        $.setTransformForCurrent(!0),
        $.save(),
        T.restartIncremental &&
          this.clearScreen(this.currentRenderService, $, T),
        $.translate(F.x1, F.y1, !0),
        $.save(),
        e.renderTreeRoots
          .sort((e, T) => {
            var C, $;
            return (
              (null !== (C = e.attribute.zIndex) && void 0 !== C
                ? C
                : DefaultAttribute.zIndex) -
              (null !== ($ = T.attribute.zIndex) && void 0 !== $
                ? $
                : DefaultAttribute.zIndex)
            );
          })
          .forEach((e) => {
            this.renderGroup(e, T);
          }),
        this.hooks.completeDraw.tap("top-draw", () => {
          $.restore(),
            $.restore(),
            $.draw(),
            ($.inuse = !1),
            (this.rendering = !1);
        }));
    });
  }
  _increaseRender(e, T) {
    return __awaiter(this, void 0, void 0, function* () {
      (this.rendering = !0), yield this._renderIncrementalGroup(e, T);
    });
  }
  _renderIncrementalGroup(e, T) {
    return __awaiter(this, void 0, void 0, function* () {
      (this.count = e.count),
        yield new Promise((C) => {
          this.renderItem(e, T, {
            drawingCb: () =>
              __awaiter(this, void 0, void 0, function* () {
                if (2 !== e.count)
                  yield foreachAsync(e, DefaultAttribute.zIndex, (C, $) => {
                    if (this.status === STATUS.STOP) return !0;
                    if (C.isContainer) return !1;
                    if ($ < this.currentIdx) return !1;
                    const F = this.currFrameStartAt + e.incremental;
                    return (
                      $ < F &&
                        ((this.currentIdx = $ + 1), this.renderItem(C, T)),
                      $ === F - 1 &&
                        ((this.currFrameStartAt = this.currentIdx),
                        this.waitToNextFrame())
                    );
                  }),
                    C(!1);
                else {
                  const $ = e.getChildAt(0);
                  if ($.incremental && $.attribute.segments)
                    for (
                      $.incrementalAt || ($.incrementalAt = 0);
                      $.incrementalAt < $.attribute.segments.length;

                    )
                      (T.multiGraphicOptions = {
                        startAtIdx: $.incrementalAt,
                        length: $.incremental,
                      }),
                        this.renderItem($, T),
                        ($.incrementalAt += $.incremental),
                        yield this.waitToNextFrame();
                  else this.renderItem($, T);
                  C(!1);
                }
              }),
          });
        }),
        this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((e) => {
        this.global.getRequestAnimationFrame()(() => {
          e(!1);
        });
      });
    });
  }
  checkForDraw(e) {
    return __awaiter(this, void 0, void 0, function* () {
      let T = this.rendering;
      return (
        e.restartIncremental &&
          ((T = !1), yield this.forceStop(), this.resetToInit()),
        T
      );
    });
  }
  forceStop() {
    return __awaiter(this, void 0, void 0, function* () {
      this.rendering &&
        ((this.status = STATUS.STOP),
        yield new Promise((e) => {
          this.hooks.completeDraw.tap("stopCb", () => {
            (this.status = STATUS.NORMAL),
              (this.hooks.completeDraw.taps =
                this.hooks.completeDraw.taps.filter(
                  (e) => "stopCb" !== e.name
                )),
              e(!1);
          });
        }));
    });
  }
  resetToInit() {
    (this.currFrameStartAt = 0), (this.currentIdx = 0);
  }
  renderGroup(e, T) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!T.break && !1 !== e.attribute.visibleAll)
        return e.incremental && T.startAtId === e._uid
          ? (yield this._increaseRender(e, T), void (T.break = !0))
          : void (yield new Promise((C) => {
              this.renderItem(e, T, {
                drawingCb: () =>
                  __awaiter(this, void 0, void 0, function* () {
                    yield foreachAsync(e, DefaultAttribute.zIndex, (e) =>
                      __awaiter(this, void 0, void 0, function* () {
                        T.break ||
                          (e.isContainer && (yield this.renderGroup(e, T)));
                      })
                    ),
                      C(!1);
                  }),
              });
            }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate$K(
  [
    injectable(),
    __param$q(0, multiInject(GraphicRender)),
    __param$q(1, inject(DefaultIncrementalCanvasLineRender)),
    __param$q(2, inject(DefaultIncrementalCanvasAreaRender)),
    __param$q(3, inject(ContributionProvider)),
    __param$q(3, named(DrawItemInterceptor)),
    __metadata$z("design:paramtypes", [Array, Object, Object, Object]),
  ],
  DefaultIncrementalDrawContribution
);
const renderModule = new ContainerModule((e) => {
  e(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(),
    e(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(),
    e(DrawContribution).to(DefaultDrawContribution),
    e(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution),
    e(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(),
    e(GraphicRender).toService(GroupRender),
    bindContributionProvider(e, GroupRenderContribution),
    e(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(),
    bindContributionProvider(e, InteractiveSubRenderContribution),
    bindContributionProvider(e, GraphicRender),
    e(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(),
    e(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution),
    bindContributionProvider(e, DrawItemInterceptor);
});
function load(e) {
  e.load(renderModule);
}
function preLoadAllModule() {
  preLoadAllModule.__loaded ||
    ((preLoadAllModule.__loaded = !0),
    container.load(coreModule),
    container.load(graphicModule),
    container.load(renderModule$1),
    container.load(pickModule),
    container.load(pluginModule),
    load$1(container),
    load(container));
}
(preLoadAllModule.__loaded = !1), preLoadAllModule();
const vglobal = container.get(VGlobal);
application.global = vglobal;
const graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
const transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
const graphicService = container.get(GraphicService);
application.graphicService = graphicService;
const layerService = container.get(LayerService);
function transformMat4(e, T, C) {
  const $ = T[0],
    F = T[1],
    V = T[2];
  let Y = C[3] * $ + C[7] * F + C[11] * V + C[15];
  return (
    (Y = Y || 1),
    (e[0] = (C[0] * $ + C[4] * F + C[8] * V + C[12]) / Y),
    (e[1] = (C[1] * $ + C[5] * F + C[9] * V + C[13]) / Y),
    (e[2] = (C[2] * $ + C[6] * F + C[10] * V + C[14]) / Y),
    e
  );
}
let _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv)
    try {
      const e = document.createElement("canvas"),
        T = e.getContext("2d");
      (_isBrowserEnv = !!(
        window &&
        e.getBoundingClientRect &&
        requestAnimationFrame &&
        window.devicePixelRatio &&
        T &&
        T.isPointInPath &&
        T.isPointInStroke
      )),
        _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
    } catch (e) {
      _isBrowserEnv = !1;
    }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const e = application.global && application.global.env;
  return e ? "browser" === e : _isBrowserEnv;
}
function isNodeEnv() {
  initIsBrowserEnv();
  const e = application.global && application.global.env;
  return e ? "node" === e : !_isBrowserEnv;
}
application.layerService = layerService;
var __decorate$J =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$y =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
const DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1,
};
let BaseCanvas = class {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(e) {
    (this._pixelWidth = e), (this._displayWidth = e / (this._dpr || 1));
  }
  get height() {
    return this._pixelHeight;
  }
  set height(e) {
    (this._pixelHeight = e), (this._displayHeight = e / (this._dpr || 1));
  }
  getContext(e) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(e) {
    (this._visiable = e), e ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(e) {
    (this._dpr = e), this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(e) {
    var T;
    const {
      nativeCanvas: C,
      width: $ = DefaultConfig.WIDTH,
      height: F = DefaultConfig.HEIGHT,
      dpr: V = DefaultConfig.DPR,
      x: Y,
      y: K,
      id: J,
      canvasControled: ee = !0,
    } = e;
    (this._x = null != Y ? Y : 0),
      (this._y = null != K ? K : 0),
      (this._pixelWidth = $ * V),
      (this._pixelHeight = F * V),
      (this._visiable = !1 !== e.visiable),
      (this.controled = ee),
      (this._displayWidth = $),
      (this._displayHeight = F),
      (this._dpr = V),
      (this._nativeCanvas = C),
      (this._id = null !== (T = C.id) && void 0 !== T ? T : J),
      J && (C.id = J),
      this.init(e);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {}
  show() {}
  applyPosition() {}
  resetStyle(e) {}
  resize(e, T) {}
  toDataURL(e, T) {
    return "";
  }
  readPixels(e, T, C, $) {
    return this._context.getImageData(e, T, C, $);
  }
  convertToBlob(e) {
    throw new Error("");
  }
  transferToImageBitmap() {
    throw new Error("");
  }
  release(...e) {
    this.controled &&
      this._nativeCanvas.parentElement &&
      this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
};
(BaseCanvas.env = "browser"),
  (BaseCanvas = __decorate$J(
    [injectable(), __metadata$y("design:paramtypes", [Object])],
    BaseCanvas
  ));
var __decorate$I =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let BaseEnvContribution = class {
  configure(e, ...T) {
    e.env === this.type && e.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(e) {
    return new AABBBounds();
  }
  removeDom(e) {
    return !1;
  }
  createDom(e) {
    return null;
  }
  updateDom(e, T) {
    return !1;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(e) {
    return document.getElementById(e);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(e) {
    const T = fetch(e).then((e) => e.json());
    return (
      T.then((e) => ({
        data: e,
        state: "success",
      })).catch(() => ({
        data: null,
        state: "fail",
      })),
      T
    );
  }
  loadArrayBuffer(e) {
    return fetch(e)
      .then((e) => e.arrayBuffer())
      .then((e) => ({
        data: e,
        loadState: "success",
      }))
      .catch(() => ({
        data: null,
        loadState: "fail",
      }));
  }
  loadBlob(e) {
    return fetch(e)
      .then((e) => e.blob())
      .then((e) => ({
        data: e,
        loadState: "success",
      }))
      .catch(() => ({
        data: null,
        loadState: "fail",
      }));
  }
  getElementTop(e, T) {
    return 0;
  }
  getElementLeft(e, T) {
    return 0;
  }
  getElementTopLeft(e, T) {
    return {
      top: 0,
      left: 0,
    };
  }
};
BaseEnvContribution = __decorate$I([injectable()], BaseEnvContribution);
var __decorate$H =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$x =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let BaseWindowHandlerContribution = class {
  constructor() {
    (this._uid = Generator.GenAutoIncrementId()),
      (this.viewBox = new AABBBounds()),
      (this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0));
  }
  onChange(e) {
    this._onChangeCb = e;
  }
  configure(e, T) {
    T.env === this.type && e.setWindowHandler(this);
  }
  release(...e) {
    this.releaseWindow();
  }
  isVisible(e) {
    return !0;
  }
  onVisibleChange(e) {}
  getTopLeft(e) {
    return {
      top: 0,
      left: 0,
    };
  }
  setViewBox(e) {
    this.viewBox.setValue(e.x1, e.y1, e.x2, e.y2);
  }
  getViewBox() {
    return this.viewBox;
  }
  setViewBoxTransform(e, T, C, $, F, V) {
    this.modelMatrix.setValue(e, T, C, $, F, V);
  }
  getViewBoxTransform() {
    return this.modelMatrix;
  }
};
BaseWindowHandlerContribution = __decorate$H(
  [injectable(), __metadata$x("design:paramtypes", [])],
  BaseWindowHandlerContribution
);
var __decorate$G =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$w =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$p =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultPickService = class {
  constructor(e) {
    (this.pickItemInterceptorContributions = e),
      (this.type = "default"),
      (this.global = application.global);
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions
      .getContributions()
      .sort((e, T) => e.order - T.order);
  }
  pick(e, T, C) {
    let $ = {
      graphic: null,
      group: null,
    };
    C.pickerService = this;
    const F = C.bounds.width(),
      V = C.bounds.height();
    if (!new AABBBounds().setValue(0, 0, F, V).containsPoint(T)) return $;
    this.pickContext && (this.pickContext.inuse = !0),
      (C.pickContext = this.pickContext),
      this.pickContext && this.pickContext.clearMatrix(!0, 1);
    const Y = new Matrix(1, 0, 0, 1, 0, 0);
    let K;
    for (
      let J = e.length - 1;
      J >= 0 &&
      (($ = e[J].isContainer
        ? this.pickGroup(e[J], T, Y, C)
        : this.pickItem(e[J], T, Y, C)),
      !$.graphic);
      J--
    )
      K || (K = $.group);
    if (
      ($.graphic || ($.group = K),
      this.pickContext && (this.pickContext.inuse = !1),
      $.graphic)
    ) {
      let e = $.graphic;
      for (; e.parent; ) e = e.parent;
      e.shadowHost &&
        (($.params = {
          shadowTarget: $.graphic,
        }),
        ($.graphic = e.shadowHost));
    }
    return $;
  }
  containsPoint(e, T, C) {
    var $;
    return !!(null ===
      ($ = this.pickItem(
        e,
        T,
        null,
        null != C
          ? C
          : {
              pickContext: this.pickContext,
              pickerService: this,
            }
      )) || void 0 === $
      ? void 0
      : $.graphic);
  }
  pickGroup(e, T, C, $) {
    let F = {
      group: null,
      graphic: null,
    };
    if (!1 === e.attribute.visibleAll) return F;
    const V = $.pickContext,
      Y = V.modelMatrix;
    if (V.camera) {
      const T = e.transMatrix,
        C = mat4Allocate.allocate();
      if ((mat3Tomat4(C, T), Y)) {
        if (C) {
          const e = mat4Allocate.allocate();
          (V.modelMatrix = multiplyMat4Mat4(e, Y, C)), mat4Allocate.free(C);
        }
      } else mat3Tomat4(C, e.globalTransMatrix), (V.modelMatrix = C);
    }
    if (this.InterceptorContributions.length)
      for (let re = 0; re < this.InterceptorContributions.length; re++) {
        const F = this.InterceptorContributions[re];
        if (F.beforePickItem) {
          const K = F.beforePickItem(e, this, T, $, {
            parentMatrix: C,
          });
          if (K)
            return (
              V.modelMatrix !== Y && mat4Allocate.free(V.modelMatrix),
              (V.modelMatrix = Y),
              K
            );
        }
      }
    const K = e.transMatrix,
      J = matrixAllocate.allocateByObj(C),
      ee = new Point(T.x, T.y);
    J.transformPoint(ee, ee);
    const te = e.AABBBounds.containsPoint(ee);
    if (!te && !e.stage.camera) return F;
    const ie = this.pickItem(e, ee.clone(), C, $);
    ie && ie.graphic && ((F.graphic = ie.graphic), (F.params = ie.params));
    const ne = !1 !== e.attribute.pickable && te;
    return (
      J.multiply(K.a, K.b, K.c, K.d, K.e, K.f),
      !1 === e.attribute.childrenPickable ||
        (ie && ie.graphic) ||
        foreach(
          e,
          DefaultAttribute.zIndex,
          (V) => {
            if (V.isContainer) {
              const C = new Point(T.x, T.y),
                Y = getTheme(e).group,
                { scrollX: K = Y.scrollX, scrollY: ee = Y.scrollY } =
                  e.attribute;
              (C.x -= K), (C.y -= ee), (F = this.pickGroup(V, C, J, $));
            } else {
              const Y = new Point(T.x, T.y);
              J.transformPoint(Y, Y);
              const K = getTheme(e).group,
                { scrollX: ee = K.scrollX, scrollY: te = K.scrollY } =
                  e.attribute;
              (Y.x -= ee), (Y.y -= te);
              const ie = this.pickItem(V, Y, C, $);
              ie &&
                ie.graphic &&
                ((F.graphic = ie.graphic), (F.params = ie.params));
            }
            return !!F.graphic || !!F.group;
          },
          !0,
          !!V.camera
        ),
      V.modelMatrix !== Y && mat4Allocate.free(V.modelMatrix),
      (V.modelMatrix = Y),
      F.graphic || F.group || !ne || e.stage.camera || (F.group = e),
      matrixAllocate.free(J),
      F
    );
  }
  selectPicker(e) {
    return this.pickerMap.get(e.numberType) || null;
  }
};
DefaultPickService = __decorate$G(
  [
    injectable(),
    __param$p(0, inject(ContributionProvider)),
    __param$p(0, named(PickItemInterceptor)),
    __metadata$w("design:paramtypes", [Object]),
  ],
  DefaultPickService
);
let loadArcModule = !1;
const arcModule = new ContainerModule((e) => {
  loadArcModule ||
    ((loadArcModule = !0),
    e(DefaultCanvasArcRender).toSelf().inSingletonScope(),
    e(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(),
    e(GraphicRender).toService(ArcRender),
    e(ArcRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, ArcRenderContribution));
});
let loadRectModule = !1;
const rectModule = new ContainerModule((e) => {
  loadRectModule ||
    ((loadRectModule = !0),
    e(DefaultCanvasRectRender).toSelf().inSingletonScope(),
    e(RectRender).to(DefaultCanvasRectRender).inSingletonScope(),
    e(GraphicRender).toService(RectRender),
    e(SplitRectAfterRenderContribution).toSelf(),
    e(SplitRectBeforeRenderContribution).toSelf(),
    e(RectRenderContribution).toService(SplitRectAfterRenderContribution),
    e(RectRenderContribution).toService(SplitRectBeforeRenderContribution),
    e(RectRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, RectRenderContribution));
});
let loadLineModule = !1;
const lineModule = new ContainerModule((e) => {
  loadLineModule ||
    ((loadLineModule = !0),
    e(DefaultCanvasLineRender).toSelf().inSingletonScope(),
    e(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(),
    e(LineRender).to(DefaultCanvasLineRender).inSingletonScope(),
    e(GraphicRender).toService(LineRender));
});
let loadAreaModule = !1;
const areaModule = new ContainerModule((e) => {
  loadAreaModule ||
    ((loadAreaModule = !0),
    e(DefaultCanvasAreaRender).toSelf().inSingletonScope(),
    e(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(),
    e(GraphicRender).toService(AreaRender),
    e(AreaRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, AreaRenderContribution),
    e(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});
let loadSymbolModule = !1;
const symbolModule = new ContainerModule((e) => {
  loadSymbolModule ||
    ((loadSymbolModule = !0),
    e(DefaultCanvasSymbolRender).toSelf().inSingletonScope(),
    e(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(),
    e(GraphicRender).toService(SymbolRender),
    e(SymbolRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, SymbolRenderContribution));
});
let loadCircleModule = !1;
const circleModule = new ContainerModule((e) => {
  loadCircleModule ||
    ((loadCircleModule = !0),
    e(DefaultCanvasCircleRender).toSelf().inSingletonScope(),
    e(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(),
    e(GraphicRender).toService(CircleRender),
    e(CircleRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, CircleRenderContribution));
});
let loadTextModule = !1;
const textModule = new ContainerModule((e) => {
  loadTextModule ||
    ((loadTextModule = !0),
    e(TextRender).to(DefaultCanvasTextRender).inSingletonScope(),
    e(GraphicRender).toService(TextRender),
    e(TextRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, TextRenderContribution));
});
let loadPathModule = !1;
const pathModule = new ContainerModule((e) => {
  loadPathModule ||
    ((loadPathModule = !0),
    e(DefaultCanvasPathRender).toSelf().inSingletonScope(),
    e(PathRender).to(DefaultCanvasPathRender).inSingletonScope(),
    e(GraphicRender).toService(PathRender),
    e(PathRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, PathRenderContribution));
});
let loadPolygonModule = !1;
const polygonModule = new ContainerModule((e) => {
  loadPolygonModule ||
    ((loadPolygonModule = !0),
    e(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(),
    e(GraphicRender).toService(PolygonRender),
    e(PolygonRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, PolygonRenderContribution));
});
var __decorate$F =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    F.drawContribution &&
      e.getSubGraphic().forEach((e) => {
        const J = F.drawContribution.getRenderContribution(e);
        J && J.drawShape && J.drawShape(e, T, C, $, F, V, Y, K);
      });
  }
  draw(e, T, C, $) {
    const { context: F } = C;
    if (!F) return;
    if ((F.highPerformanceSave(), !C.drawContribution)) return;
    const V = getTheme(e),
      Y = e.getSubGraphic();
    Y.length &&
      Y.forEach((e) => {
        C.drawContribution.renderItem(e, C, {
          theme: V,
        });
      }),
      F.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate$F(
  [injectable()],
  DefaultCanvasGlyphRender
);
let loadGlyphModule = !1;
const glyphModule = new ContainerModule((e) => {
  loadGlyphModule ||
    ((loadGlyphModule = !0),
    e(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(),
    e(GraphicRender).toService(GlyphRender));
});
var __decorate$E =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$v =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(),
      (this.numberType = RICHTEXT_NUMBER_TYPE),
      (this.builtinContributions = [defaultTextBackgroundRenderContribution]),
      this.init();
  }
  drawShape(e, T, C, $, F) {
    const V = getTheme(e).richtext,
      {
        strokeOpacity: Y = V.strokeOpacity,
        opacity: K = V.opacity,
        fillOpacity: J = V.fillOpacity,
        visible: ee = V.visible,
      } = e.attribute;
    if (!e.valid || !ee) return;
    const te = fillVisible(K, J, !0),
      ie = fillVisible(K, Y, !0);
    te &&
      (T.translate(C, $),
      this.beforeRenderStep(e, T, C, $, te, ie, te, ie, V, F),
      e.getFrameCache().draw(T, this.drawIcon),
      this.afterRenderStep(e, T, C, $, te, ie, te, ie, V, F));
  }
  drawIcon(e, T, C, $, F) {
    var V;
    const Y = getTheme(e).richtextIcon,
      {
        width: K = Y.width,
        height: J = Y.height,
        opacity: ee = Y.opacity,
        image: te,
        backgroundFill: ie = Y.backgroundFill,
        backgroundFillOpacity: ne = Y.backgroundFillOpacity,
        backgroundStroke: re = Y.backgroundStroke,
        backgroundStrokeOpacity: ae = Y.backgroundStrokeOpacity,
        backgroundRadius: oe = Y.backgroundRadius,
        margin: se,
      } = e.attribute,
      { backgroundWidth: le = K, backgroundHeight: de = J } = e.attribute;
    if (
      (se && ((C += e._marginArray[3]), ($ += e._marginArray[0])), e._hovered)
    ) {
      const e = (le - K) / 2,
        F = (de - J) / 2;
      0 === oe
        ? (T.beginPath(), T.rect(C - e, $ - F, le, de))
        : (T.beginPath(), createRectPath(T, C - e, $ - F, le, de, oe)),
        ie && ((T.globalAlpha = ne), (T.fillStyle = ie), T.fill()),
        re && ((T.globalAlpha = ae), (T.strokeStyle = re), T.stroke());
    }
    const ce =
      te &&
      (null === (V = null == e ? void 0 : e.resources) || void 0 === V
        ? void 0
        : V.get(te));
    ce &&
      "success" === ce.state &&
      ((T.globalAlpha = ee), T.drawImage(ce.data, C, $, K, J));
  }
  draw(e, T, C) {
    const $ = getTheme(e).richtext;
    this._draw(e, $, !1, C);
  }
};
DefaultCanvasRichTextRender = __decorate$E(
  [injectable(), __metadata$v("design:paramtypes", [])],
  DefaultCanvasRichTextRender
);
let loadRichtextModule = !1;
const richtextModule = new ContainerModule((e) => {
  loadRichtextModule ||
    ((loadRichtextModule = !0),
    e(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(),
    e(GraphicRender).toService(RichTextRender));
});
let loadImageModule = !1;
const imageModule = new ContainerModule((e) => {
  loadImageModule ||
    ((loadImageModule = !0),
    e(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(),
    e(GraphicRender).toService(ImageRender),
    e(ImageRenderContribution).toService(
      DefaultBaseInteractiveRenderContribution
    ),
    bindContributionProvider(e, ImageRenderContribution));
});
var __decorate$D =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasRect3dRender = class extends BaseRender {
  constructor() {
    super(...arguments),
      (this.type = "rect3d"),
      (this.numberType = RECT3D_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J;
    const ee = getTheme(e, null == V ? void 0 : V.theme).rect,
      {
        fill: te = ee.fill,
        stroke: ie = ee.stroke,
        x1: ne,
        y1: re,
        x: ae,
        y: oe,
        opacity: se = ee.opacity,
        fillOpacity: le = ee.fillOpacity,
        lineWidth: de = ee.lineWidth,
        strokeOpacity: ce = ee.strokeOpacity,
        visible: ue = ee.visible,
      } = e.attribute;
    let { width: he, height: pe } = e.attribute;
    (he = (null != he ? he : ne - ae) || 0),
      (pe = (null != pe ? pe : re - oe) || 0);
    const ge = null !== (J = this.z) && void 0 !== J ? J : 0,
      fe = rectFillVisible(se, le, he, pe, te),
      me = rectStrokeVisible(se, ce, he, pe),
      ye = runFill(te),
      be = runStroke(ie, de);
    if (!e.valid || !ue) return;
    if (!ye && !be) return;
    if (!(fe || me || Y || K)) return;
    const { light: ve, camera: Te } = F.stage || {},
      _e = e.findFace();
    if (!1 !== te) {
      T.setCommonStyle(e, e.attribute, C, $, ee);
      let F = te;
      "string" != typeof F && (F = "black"),
        this.fill(C, $, ge, _e, F, T, ve, Y);
    }
    !1 !== ie &&
      (T.setStrokeStyle(e, e.attribute, C, $, ee),
      this.stroke(C, $, ge, _e, T));
  }
  stroke(e, T, C, $, F) {
    const V = $.vertices;
    $.edges.forEach(($) => {
      const Y = V[$[0]],
        K = {
          x: e + Y[0],
          y: T + Y[1],
          z: C + Y[2],
        },
        J = V[$[1]],
        ee = {
          x: e + J[0],
          y: T + J[1],
          z: C + J[2],
        };
      F.beginPath(),
        F.moveTo(K.x, K.y, K.z),
        F.lineTo(ee.x, ee.y, ee.z),
        F.stroke();
    });
  }
  fill(e, T, C, $, F, V, Y, K) {
    const J = ColorStore.Get(F, ColorType.Color255),
      ee = $.vertices,
      te = ee.map((e) => V.view(e[0], e[1], e[2])[2]),
      ie = [];
    $.polygons.forEach((e, T) => {
      ie.push({
        faceIdx: T,
        polygon: e,
      });
      const { polygon: C, normal: $ } = e,
        F = te[C[0]],
        V = te[C[1]],
        Y = te[C[2]],
        K = te[C[3]];
      e.ave_z = F + V + Y + K;
    }),
      ie.sort((e, T) => T.polygon.ave_z - e.polygon.ave_z),
      ie.forEach(($) => {
        const { polygon: te, normal: ie } = $.polygon,
          ne = ee[te[0]],
          re = ee[te[1]],
          ae = ee[te[2]],
          oe = ee[te[3]],
          se = {
            x: e + ne[0],
            y: T + ne[1],
            z: C + ne[2],
          },
          le = {
            x: e + re[0],
            y: T + re[1],
            z: C + re[2],
          },
          de = {
            x: e + ae[0],
            y: T + ae[1],
            z: C + ae[2],
          },
          ce = {
            x: e + oe[0],
            y: T + oe[1],
            z: C + oe[2],
          };
        V.beginPath(),
          V.moveTo(se.x, se.y, se.z),
          V.lineTo(le.x, le.y, le.z),
          V.lineTo(de.x, de.y, de.z),
          V.lineTo(ce.x, ce.y, ce.z),
          V.closePath(),
          K
            ? K(V, null, null)
            : ((V.fillStyle = Y ? Y.computeColor(ie, J) : F), V.fill());
      });
  }
  draw(e, T, C) {
    const $ = getTheme(e).rect;
    this._draw(e, $, !1, C);
  }
};
DefaultCanvasRect3dRender = __decorate$D(
  [injectable()],
  DefaultCanvasRect3dRender
);
let loadRect3dModule = !1;
const rect3dModule = new ContainerModule((e) => {
  loadRect3dModule ||
    ((loadRect3dModule = !0),
    e(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(),
    e(GraphicRender).toService(Rect3DRender));
});
var __decorate$C =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
function drawArcPath(e, T, C, $, F, V, Y) {
  const { startAngle: K, endAngle: J } = e.getParsedAngle(),
    ee = abs(J - K),
    te = J > K;
  let ie = !1;
  if (V < Y) {
    const e = V;
    (V = Y), (Y = e);
  }
  if (V <= epsilon) T.moveTo(C, $, F);
  else if (ee >= pi2 - epsilon)
    T.moveTo(C + V * cos(K), $ + V * sin(K), F),
      T.arc(C, $, V, K, J, !te, F),
      Y > epsilon &&
        (T.moveTo(C + Y * cos(J), $ + Y * sin(J), F),
        T.arc(C, $, Y, J, K, te, F));
  else {
    const {
        outerDeltaAngle: ee,
        innerDeltaAngle: ne,
        outerStartAngle: re,
        outerEndAngle: ae,
        innerEndAngle: oe,
        innerStartAngle: se,
      } = e.getParsePadAngle(K, J),
      le = V * cos(re),
      de = V * sin(re),
      ce = Y * cos(oe),
      ue = Y * sin(oe);
    ee < 0.001
      ? (ie = !0)
      : (T.moveTo(C + le, $ + de, F), T.arc(C, $, V, re, ae, !te, F)),
      !(Y > epsilon) || ne < 0.001
        ? (T.lineTo(C + ce, $ + ue, F), (ie = !0))
        : (T.lineTo(C + ce, $ + ue, F), T.arc(C, $, Y, oe, se, te, F));
  }
  return T.closePath(), ie;
}
function drawInnerOuterArcPath(e, T, C, $, F, V, Y, K) {
  const { startAngle: J, endAngle: ee } = e.getParsedAngle(),
    te = abs(ee - J),
    ie = ee > J;
  let ne = !1;
  if (Y <= epsilon) T.moveTo(C, $, F);
  else if (te >= pi2 - epsilon)
    T.moveTo(C + Y * cos(J), $ + Y * sin(J), F),
      T.arc(C, $, Y, J, ee, !ie, F),
      T.lineTo(C + Y * cos(ee), $ + Y * sin(ee), V),
      T.arc(C, $, Y, ee, J, ie, V);
  else {
    const {
        innerouterDeltaAngle: e,
        innerouterStartAngle: te,
        innerouterEndAngle: re,
      } = K(J, ee),
      ae = Y * cos(te),
      oe = Y * sin(te),
      se = Y * cos(re),
      le = Y * sin(re);
    e < 0.001
      ? (ne = !0)
      : (T.moveTo(C + ae, $ + oe, F),
        T.arc(C, $, Y, te, re, !ie, F),
        T.lineTo(C + se, $ + le, V),
        T.arc(C, $, Y, re, te, ie, V));
  }
  return T.closePath(), ne;
}
let DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), (this.numberType = ARC3D_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J;
    const ee = getTheme(e, null == V ? void 0 : V.theme).arc,
      { fill: te = ee.fill } = e.attribute,
      ie = this.valid(e, ee, Y, K);
    if (!ie) return;
    const { fVisible: ne, sVisible: re, doFill: ae, doStroke: oe } = ie,
      se = null !== (J = this.z) && void 0 !== J ? J : 0,
      {
        outerPadding: le = ee.outerPadding,
        innerPadding: de = ee.innerPadding,
        height: ce = 10,
      } = e.attribute;
    let { outerRadius: ue = ee.outerRadius, innerRadius: he = ee.innerRadius } =
      e.attribute;
    (ue += le), (he -= de);
    const pe = ColorStore.Get(te, ColorType.Color255),
      { light: ge } = F.stage || {},
      fe = F.hack_pieFace,
      me = {
        top: se,
        bottom: se + ce,
      },
      ye = {
        top: [0, 1, 0],
        bottom: [0, -1, 0],
        outside: [1, 0, -1],
        inside: [1, 0, -1],
      };
    "bottom" === fe || "top" === fe
      ? (T.beginPath(),
        drawArcPath(e, T, C, $, me[fe], ue, he),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ee),
        ae &&
          (Y
            ? Y(T, e.attribute, ee)
            : ne &&
              (T.setCommonStyle(e, e.attribute, C, $, ee),
              (T.fillStyle = ge ? ge.computeColor(ye[fe], pe) : te),
              T.fill())),
        oe &&
          (K
            ? K(T, e.attribute, ee)
            : re && (T.setStrokeStyle(e, e.attribute, C, $, ee), T.stroke())))
      : ("outside" !== fe && "inside" !== fe) ||
        ("inside" === fe &&
          (T.save(),
          T.beginPath(),
          T.arc(C, $, he, 0, pi2, !0, me.top),
          T.clip()),
        T.beginPath(),
        drawInnerOuterArcPath(
          e,
          T,
          C,
          $,
          me.top,
          me.bottom,
          "outside" === fe ? ue : he,
          (T, C) => {
            const {
              outerDeltaAngle: $,
              innerDeltaAngle: F,
              outerStartAngle: V,
              outerEndAngle: Y,
              innerEndAngle: K,
              innerStartAngle: J,
            } = e.getParsePadAngle(T, C);
            return "outside" === fe
              ? {
                  innerouterDeltaAngle: $,
                  innerouterEndAngle: Y,
                  innerouterStartAngle: V,
                }
              : {
                  innerouterDeltaAngle: F,
                  innerouterEndAngle: K,
                  innerouterStartAngle: J,
                };
          }
        ),
        T.setShadowBlendStyle && T.setShadowBlendStyle(e, e.attribute, ee),
        ae &&
          (Y
            ? Y(T, e.attribute, ee)
            : ne &&
              (T.setCommonStyle(e, e.attribute, C, $, ee),
              (T.fillStyle = ge ? ge.computeColor(ye[fe], pe) : te),
              T.fill())),
        oe &&
          (K
            ? K(T, e.attribute, ee)
            : re && (T.setStrokeStyle(e, e.attribute, C, $, ee), T.stroke())),
        "inside" === fe && T.restore());
  }
  draw(e, T, C, $) {
    const F = getTheme(e, null == $ ? void 0 : $.theme).arc;
    this._draw(e, F, !1, C, $);
  }
};
DefaultCanvasArc3DRender = __decorate$C(
  [injectable()],
  DefaultCanvasArc3DRender
);
let loadArc3dModule = !1;
const arc3dModule = new ContainerModule((e) => {
  loadArc3dModule ||
    ((loadArc3dModule = !0),
    e(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(),
    e(GraphicRender).toService(Arc3dRender));
});
var __decorate$B =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasPyramid3dRender = class extends BaseRender {
  constructor() {
    super(...arguments),
      (this.type = "pyramid3d"),
      (this.numberType = PYRAMID3D_NUMBER_TYPE);
  }
  drawShape(e, T, C, $, F, V, Y, K) {
    var J;
    const ee = getTheme(e, null == V ? void 0 : V.theme).polygon,
      {
        fill: te = ee.fill,
        stroke: ie = ee.stroke,
        face: ne = [!0, !0, !0, !0, !0, !0],
      } = e.attribute,
      re = null !== (J = this.z) && void 0 !== J ? J : 0;
    if (!this.valid(e, ee, Y, K)) return;
    const { light: ae, camera: oe } = F.stage || {},
      se = e.findFace();
    if (!1 !== te) {
      T.setCommonStyle(e, e.attribute, C, $, ee);
      let F = te;
      "string" != typeof F && (F = "black"),
        this.fill(C, $, re, se, ne, F, T, ae, oe, e, ee, Y);
    }
    !1 !== ie &&
      (T.setStrokeStyle(e, e.attribute, C, $, ee),
      this.stroke(C, $, re, se, T));
  }
  stroke(e, T, C, $, F) {
    const V = $.vertices;
    $.edges.forEach(($) => {
      const Y = V[$[0]],
        K = V[$[1]],
        J = {
          x: e + Y[0],
          y: T + Y[1],
          z: C + Y[2],
        },
        ee = {
          x: e + K[0],
          y: T + K[1],
          z: C + K[2],
        };
      F.beginPath(),
        F.moveTo(J.x, J.y, J.z),
        F.lineTo(ee.x, ee.y, ee.z),
        F.stroke();
    });
  }
  fill(e, T, C, $, F, V, Y, K, J, ee, te, ie) {
    const ne = ColorStore.Get(V, ColorType.Color255),
      re = $.vertices,
      ae = re.map((e) => Y.view(e[0], e[1], e[2])[2]),
      oe = [];
    $.polygons.forEach((e, T) => {
      if (!F[T]) return;
      oe.push({
        faceIdx: T,
        polygon: e,
      });
      const { polygon: C, normal: $ } = e,
        V = ae[C[0]],
        Y = ae[C[1]],
        K = ae[C[2]],
        J = ae[C[3]];
      e.ave_z = V + Y + K + J;
    }),
      oe.sort((e, T) => T.polygon.ave_z - e.polygon.ave_z),
      oe.forEach(($) => {
        const { polygon: F, normal: J } = $.polygon,
          ae = re[F[0]],
          oe = re[F[1]],
          se = re[F[2]],
          le = re[F[3]],
          de = {
            x: e + ae[0],
            y: T + ae[1],
            z: C + ae[2],
          },
          ce = {
            x: e + oe[0],
            y: T + oe[1],
            z: C + oe[2],
          },
          ue = {
            x: e + se[0],
            y: T + se[1],
            z: C + se[2],
          },
          he = {
            x: e + le[0],
            y: T + le[1],
            z: C + le[2],
          };
        Y.beginPath(),
          Y.moveTo(de.x, de.y, de.z),
          Y.lineTo(ce.x, ce.y, ce.z),
          Y.lineTo(ue.x, ue.y, ue.z),
          Y.lineTo(he.x, he.y, he.z),
          Y.closePath(),
          ie
            ? ie(Y, ee.attribute, te)
            : ((Y.fillStyle = K ? K.computeColor(J, ne) : V), Y.fill());
      });
  }
  draw(e, T, C) {
    const $ = getTheme(e).polygon;
    this._draw(e, $, !1, C);
  }
};
DefaultCanvasPyramid3dRender = __decorate$B(
  [injectable()],
  DefaultCanvasPyramid3dRender
);
let loadPyramid3dModule = !1;
const pyramid3dModule = new ContainerModule((e) => {
  loadPyramid3dModule ||
    ((loadPyramid3dModule = !0),
    e(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(),
    e(GraphicRender).toService(Pyramid3dRender));
});
function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}
function registerArc3dGraphic() {
  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
}
function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}
function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}
function registerGlyphGraphic() {
  graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
}
function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}
function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}
function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}
function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}
function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}
function registerPyramid3dGraphic() {
  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
}
function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}
function registerRect3dGraphic() {
  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
}
function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}
function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}
function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}
function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}
function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}
const MathPickerContribution = Symbol.for("MathPickerContribution"),
  MathArcPicker = Symbol.for("MathArcPicker"),
  MathAreaPicker = Symbol.for("MathAreaPicker"),
  MathCirclePicker = Symbol.for("MathCirclePicker"),
  MathImagePicker = Symbol.for("MathImagePicker"),
  MathLinePicker = Symbol.for("MathLinePicker"),
  MathPathPicker = Symbol.for("MathPathPicker"),
  MathRectPicker = Symbol.for("MathRectPicker"),
  MathSymbolPicker = Symbol.for("MathSymbolPicker"),
  MathTextPicker = Symbol.for("MathTextPicker"),
  MathPolygonPicker = Symbol.for("MathPolygonPicker"),
  MathGlyphPicker = Symbol.for("MathGlyphPicker"),
  CanvasArcPicker = Symbol.for("CanvasArcPicker"),
  CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker"),
  CanvasAreaPicker = Symbol.for("CanvasAreaPicker"),
  CanvasCirclePicker = Symbol.for("CanvasCirclePicker"),
  CanvasImagePicker = Symbol.for("CanvasImagePicker"),
  CanvasLinePicker = Symbol.for("CanvasLinePicker"),
  CanvasPathPicker = Symbol.for("CanvasPathPicker"),
  CanvasRectPicker = Symbol.for("CanvasRectPicker"),
  CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker"),
  CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker"),
  CanvasTextPicker = Symbol.for("CanvasTextPicker"),
  CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker"),
  CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker"),
  CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker"),
  CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker"),
  CanvasGroupPicker = Symbol.for("CanvasGroupPicker"),
  CanvasPickerContribution = Symbol.for("CanvasPickerContribution");
var __decorate$A =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$u =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
const outP = [0, 0, 0],
  addArcToBezierPath = (e, T, C, $, F, V, Y, K) => {
    if (K) for (; C > T; ) C -= pi2;
    else for (; C < T; ) C += pi2;
    const J = (pi / 3) * (C > T ? 1 : -1);
    let ee = T,
      te = ee;
    for (; te !== C; ) {
      te = J > 0 ? Math.min(te + J, C) : Math.max(te + J, C);
      const T = Math.abs(te - ee),
        K = (4 * Math.tan(T / 4)) / 3,
        ie = te < ee ? -1 : 1,
        ne = Math.cos(ee),
        re = Math.sin(ee),
        ae = Math.cos(te),
        oe = Math.sin(te),
        se = ne * V + $,
        le = re * Y + F,
        de = ae * V + $,
        ce = oe * Y + F,
        ue = V * K * ie,
        he = Y * K * ie;
      e.push([se - ue * re, le + he * ne, de + ue * oe, ce - he * ae, de, ce]),
        (ee = te);
    }
  };
let BrowserContext2d = class {
  set fillStyle(e) {
    this.nativeContext.fillStyle = e;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(e) {
    this.nativeContext.font = e;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(e) {
    this.nativeContext.globalAlpha = e * this.baseGlobalAlpha;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(e) {
    this.nativeContext.lineCap = e;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(e) {
    this.nativeContext.lineDashOffset = e;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(e) {
    this.nativeContext.lineJoin = e;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(e) {
    this.nativeContext.lineWidth = e;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(e) {
    this.nativeContext.miterLimit = e;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(e) {
    this.nativeContext.shadowBlur = e;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(e) {
    this.nativeContext.shadowColor = e;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(e) {
    this.nativeContext.shadowOffsetX = e;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(e) {
    this.nativeContext.shadowOffsetY = e;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(e) {
    this.nativeContext.strokeStyle = e;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(e) {
    this.nativeContext.textAlign = e;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(e) {
    this.nativeContext.textBaseline = e;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(e) {
    e !== !!this._inuse &&
      ((this._inuse = e),
      e
        ? (this.nativeContext.save(), this.reset())
        : this.nativeContext.restore());
  }
  constructor(e, T) {
    (this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1,
    })),
      (this.strokeAttributes = Object.assign(
        Object.assign({}, DefaultStrokeStyle),
        {
          opacity: 1,
        }
      )),
      (this.textAttributes = Object.assign(
        Object.assign({}, DefaultTextStyle),
        {
          opacity: 1,
        }
      )),
      (this._clearShadowStyle = !1),
      (this._clearFilterStyle = !1),
      (this._clearGlobalCompositeOperationStyle = !1);
    const C = e.nativeCanvas.getContext("2d");
    if (!C) throw new Error("2d");
    (this.nativeContext = C),
      (this.canvas = e),
      (this.matrix = new Matrix(1, 0, 0, 1, 0, 0)),
      (this.stack = []),
      (this.dpr = T),
      (this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0)),
      (this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0)),
      (this.baseGlobalAlpha = 1);
  }
  reset() {
    this.stack.length &&
      Logger.getInstance().warn("bugmatrix"),
      this.matrix.setValue(1, 0, 0, 1, 0, 0),
      (this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0)),
      (this.stack.length = 0),
      this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent(e = !1) {
    (!e && this.applyedMatrix.equalToMatrix(this.matrix)) ||
      (this.applyedMatrix.setValue(
        this.matrix.a,
        this.matrix.b,
        this.matrix.c,
        this.matrix.d,
        this.matrix.e,
        this.matrix.f
      ),
      this.nativeContext.setTransform(
        this.matrix.a,
        this.matrix.b,
        this.matrix.c,
        this.matrix.d,
        this.matrix.e,
        this.matrix.f
      ));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(e) {
    return matrixAllocate.allocateByObj(e);
  }
  clear() {
    this.save(),
      this.resetTransform(),
      this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height),
      this.restore();
  }
  restore() {
    this.nativeContext.restore(),
      this.stack.length > 0 &&
        (matrixAllocate.free(this.matrix),
        (this.matrix = this.stack.pop()),
        this.setTransformForCurrent(!0));
  }
  highPerformanceRestore() {
    this.stack.length > 0 &&
      (matrixAllocate.free(this.matrix), (this.matrix = this.stack.pop()));
  }
  rotate(e, T = !0) {
    this.matrix.rotate(e), T && this.setTransformForCurrent();
  }
  save() {
    const e = this.cloneMatrix(this.matrix);
    this.stack.push(e), this.nativeContext.save();
  }
  highPerformanceSave() {
    const e = this.cloneMatrix(this.matrix);
    this.stack.push(e);
  }
  scale(e, T, C = !0) {
    this.matrix.scale(e, T), C && this.setTransformForCurrent();
  }
  setScale(e, T, C = !0) {
    this.matrix.setScale(e, T), C && this.setTransformForCurrent();
  }
  scalePoint(e, T, C, $, F = !0) {
    this.translate(C, $, !1),
      this.scale(e, T, !1),
      this.translate(-C, -$, !1),
      F && this.setTransformForCurrent();
  }
  setTransform(e, T, C, $, F, V, Y = !0, K = this.dpr) {
    this.matrix.setValue(K * e, K * T, K * C, K * $, K * F, K * V),
      Y && this.setTransformForCurrent();
  }
  setTransformFromMatrix(e, T = !0, C = this.dpr) {
    this.matrix.setValue(e.a * C, e.b * C, e.c * C, e.d * C, e.e * C, e.f * C),
      T && this.setTransformForCurrent();
  }
  resetTransform(e = !0, T = this.dpr) {
    this.setTransform(T, 0, 0, T, 0, 0), e && this.setTransformForCurrent();
  }
  transform(e, T, C, $, F, V, Y = !0) {
    this.matrix.multiply(e, T, C, $, F, V), Y && this.setTransformForCurrent();
  }
  transformFromMatrix(e, T) {
    this.matrix.multiply(e.a, e.b, e.c, e.d, e.e, e.f),
      T && this.setTransformForCurrent();
  }
  translate(e, T, C = !0) {
    this.matrix.translate(e, T), C && this.setTransformForCurrent();
  }
  rotateDegrees(e, T = !0) {
    const C = (e * Math.PI) / 180;
    this.rotate(C, T);
  }
  rotateAbout(e, T, C, $ = !0) {
    this.translate(T, C, !1),
      this.rotate(e, !1),
      this.translate(-T, -C, !1),
      $ && this.setTransformForCurrent();
  }
  rotateDegreesAbout(e, T, C, $ = !0) {
    this.translate(T, C, !1),
      this.rotateDegrees(e, !1),
      this.translate(-T, -C, !1),
      $ && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(e, T) {
    e
      ? "string" == typeof e
        ? this.nativeContext.clip(e)
        : this.nativeContext.clip(e, T)
      : this.nativeContext.clip();
  }
  arc(e, T, C, $, F, V, Y) {
    if (((Y = Y || 0), this.camera)) {
      const K = [];
      addArcToBezierPath(K, $, F, e, T, C, C, V);
      for (let e = 0; e < K.length; ++e) {
        const T = K[e];
        this.bezierCurveTo(T[0], T[1], T[2], T[3], T[4], T[5], Y);
      }
    } else this.nativeContext.arc(e, T, C, $, F, V);
  }
  arcTo(e, T, C, $, F) {
    this.nativeContext.arcTo(e, T, C, $, F);
  }
  bezierCurveTo(e, T, C, $, F, V, Y) {
    if (((Y = Y || 0), this.camera)) {
      let K = Y,
        J = Y;
      this.modelMatrix &&
        (transformMat4(outP, [e, T, Y], this.modelMatrix),
        (e = outP[0]),
        (T = outP[1]),
        (K = outP[2]),
        transformMat4(outP, [C, $, Y], this.modelMatrix),
        (C = outP[0]),
        ($ = outP[1]),
        (J = outP[2]),
        transformMat4(outP, [F, V, Y], this.modelMatrix),
        (F = outP[0]),
        (V = outP[1]),
        (Y = outP[2]));
      let ee = this.camera.vp(F, V, Y);
      (F = ee.x),
        (V = ee.y),
        (ee = this.camera.vp(e, T, K)),
        (e = ee.x),
        (T = ee.y),
        (ee = this.camera.vp(C, $, J)),
        (C = ee.x),
        ($ = ee.y);
    }
    this.nativeContext.bezierCurveTo(e, T, C, $, F, V);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(e, T, C, $, F, V, Y, K) {
    null == K
      ? this.nativeContext.ellipse(e, T, C, $, F, V, Y)
      : this.nativeContext.ellipse(e, T, C, $, F, V, Y, K);
  }
  lineTo(e, T, C) {
    if (((C = C || 0), this.camera)) {
      this.modelMatrix &&
        (transformMat4(outP, [e, T, C], this.modelMatrix),
        (e = outP[0]),
        (T = outP[1]),
        (C = outP[2]));
      const $ = this.camera.vp(e, T, C);
      (e = $.x), (T = $.y);
    }
    this.nativeContext.lineTo(e, T);
  }
  moveTo(e, T, C) {
    if (((C = C || 0), this.camera)) {
      this.modelMatrix &&
        (transformMat4(outP, [e, T, C], this.modelMatrix),
        (e = outP[0]),
        (T = outP[1]),
        (C = outP[2]));
      const $ = this.camera.vp(e, T, C);
      (e = $.x), (T = $.y);
    }
    this.nativeContext.moveTo(e, T);
  }
  quadraticCurveTo(e, T, C, $, F) {
    if (((F = F || 0), this.camera)) {
      let V = F;
      this.modelMatrix &&
        (transformMat4(outP, [e, T, F], this.modelMatrix),
        (e = outP[0]),
        (T = outP[1]),
        (V = outP[2]),
        transformMat4(outP, [C, $, F], this.modelMatrix),
        (C = outP[0]),
        ($ = outP[1]),
        (F = outP[2]));
      let Y = this.camera.vp(C, $, F);
      (C = Y.x), ($ = Y.y), (Y = this.camera.vp(e, T, V)), (e = Y.x), (T = Y.y);
    }
    this.nativeContext.quadraticCurveTo(e, T, C, $);
  }
  rect(e, T, C, $, F) {
    (F = F || 0),
      this.camera
        ? (this.moveTo(e, T, F),
          this.lineTo(e + C, T, F),
          this.lineTo(e + C, T + $, F),
          this.lineTo(e, T + $, F),
          this.closePath())
        : this.nativeContext.rect(e, T, C, $);
  }
  createImageData() {
    const e = arguments;
    return 2 === e.length
      ? this.nativeContext.createImageData(e[0], e[1])
      : 1 === e.length
      ? this.nativeContext.createImageData(e[0])
      : null;
  }
  createLinearGradient(e, T, C, $) {
    return this.nativeContext.createLinearGradient(e, T, C, $);
  }
  createPattern(e, T) {
    return 0 === e.width || 0 === e.height
      ? null
      : this.nativeContext.createPattern(e, T);
  }
  createRadialGradient(e, T, C, $, F, V) {
    return this.nativeContext.createRadialGradient(e, T, C, $, F, V);
  }
  createConicGradient(e, T, C, $) {
    let F,
      V = !1;
    const Y = this;
    return {
      stops: [],
      addColorStop(e, T) {
        this.stops.push([e, T]), (V = !0);
      },
      GetPattern(K, J, ee) {
        return (
          V &&
            (ee || (ee = $ - C),
            (F = createConicalGradient(Y, this.stops, e, T, ee, C, $, K, J)),
            (V = !1)),
          F
        );
      },
    };
  }
  fill(e, T) {
    this.disableFill ||
      (e ? this.nativeContext.fill(e) : this.nativeContext.fill());
  }
  fillRect(e, T, C, $) {
    this.nativeContext.fillRect(e, T, C, $);
  }
  clearRect(e, T, C, $) {
    this.nativeContext.clearRect(e, T, C, $);
  }
  project(e, T, C) {
    if (((C = C || 0), this.camera)) {
      this.modelMatrix &&
        (transformMat4(outP, [e, T, C], this.modelMatrix),
        (e = outP[0]),
        (T = outP[1]),
        (C = outP[2]));
      const $ = this.camera.vp(e, T, C);
      (e = $.x), (T = $.y);
    }
    return {
      x: e,
      y: T,
    };
  }
  view(e, T, C) {
    return (
      (C = C || 0),
      this.camera
        ? (this.modelMatrix &&
            (transformMat4(outP, [e, T, C], this.modelMatrix),
            (e = outP[0]),
            (T = outP[1]),
            (C = outP[2])),
          this.camera.view(e, T, C))
        : [e, T, C]
    );
  }
  fillText(e, T, C, $) {
    if ((($ = $ || 0), this.camera)) {
      this.modelMatrix &&
        (transformMat4(outP, [T, C, $], this.modelMatrix),
        (T = outP[0]),
        (C = outP[1]),
        ($ = outP[2]));
      const e = this.camera.vp(T, C, $);
      (T = e.x), (C = e.y);
    }
    this.nativeContext.fillText(e, T, C);
  }
  getImageData(e, T, C, $) {
    return this.nativeContext.getImageData(e, T, C, $);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(e, T) {
    return this.nativeContext.isPointInPath(e, T);
  }
  isPointInStroke(e, T) {
    return this.nativeContext.isPointInStroke(e, T);
  }
  measureText(e, T = application.global.measureTextMethod) {
    var C, $;
    if (!T || "native" === T) return this.nativeContext.measureText(e);
    this.mathTextMeasure ||
      (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance(
        {},
        {},
        () => this.canvas.nativeCanvas
      ));
    const F =
        null !== (C = this.fontFamily) && void 0 !== C
          ? C
          : DefaultTextStyle.fontFamily,
      V =
        null !== ($ = this.fontSize) && void 0 !== $
          ? $
          : DefaultTextStyle.fontSize;
    return (
      (this.mathTextMeasure.textSpec.fontFamily === F &&
        this.mathTextMeasure.textSpec.fontSize === V) ||
        ((this.mathTextMeasure.textSpec.fontFamily = F),
        (this.mathTextMeasure.textSpec.fontSize = V),
        (this.mathTextMeasure._numberCharSize = null),
        (this.mathTextMeasure._fullCharSize = null),
        (this.mathTextMeasure._letterCharSize = null),
        (this.mathTextMeasure._specialCharSizeMap = {})),
      this.mathTextMeasure.measure(e, T)
    );
  }
  putImageData(e, T, C) {
    this.nativeContext.putImageData(e, T, C);
  }
  setLineDash(e) {
    const T = arguments,
      C = this.nativeContext;
    this.nativeContext.setLineDash
      ? T[0] && C.setLineDash(T[0])
      : "mozDash" in C
      ? (C.mozDash = T[0])
      : "webkitLineDash" in C && (C.webkitLineDash = T[0]);
  }
  stroke(e) {
    this.disableStroke ||
      (e ? this.nativeContext.stroke(e) : this.nativeContext.stroke());
  }
  strokeRect(e, T, C, $) {
    this.nativeContext.strokeRect(e, T, C, $);
  }
  strokeText(e, T, C, $) {
    if ((($ = $ || 0), this.camera)) {
      this.modelMatrix &&
        (transformMat4(outP, [T, C, $], this.modelMatrix),
        (T = outP[0]),
        (C = outP[1]),
        ($ = outP[2]));
      const e = this.camera.vp(T, C, $);
      (T = e.x), (C = e.y);
    }
    this.nativeContext.strokeText(e, T, C);
  }
  drawImage() {
    const e = this.nativeContext,
      T = arguments;
    3 === T.length
      ? e.drawImage(T[0], T[1], T[2])
      : 5 === T.length
      ? e.drawImage(T[0], T[1], T[2], T[3], T[4])
      : 9 === T.length &&
        e.drawImage(T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], T[8]);
  }
  setCommonStyle(e, T, C, $, F) {
    if (Array.isArray(F)) {
      if (F.length <= 1) return this._setCommonStyle(e, T, C, $, F[0]);
      const V = Object.create(F[0]);
      return (
        F.forEach((e, T) => {
          0 !== T && Object.assign(V, e);
        }),
        this._setCommonStyle(e, T, C, $, V)
      );
    }
    return this._setCommonStyle(e, T, C, $, F);
  }
  _setCommonStyle(e, T, C, $, F) {
    const V = this.nativeContext;
    F || (F = this.fillAttributes);
    const {
      fillOpacity: Y = F.fillOpacity,
      opacity: K = F.opacity,
      fill: J = F.fill,
    } = T;
    (V.globalAlpha = Y * K * this.baseGlobalAlpha),
      Y > 1e-12 && K > 1e-12 && (V.fillStyle = createColor(this, J, e, C, $));
  }
  setShadowBlendStyle(e, T, C) {
    if (Array.isArray(C)) {
      if (C.length <= 1) return this._setShadowBlendStyle(e, C[0]);
      const $ = Object.create(C[0]);
      return (
        C.forEach((e, T) => {
          0 !== T && Object.assign($, e);
        }),
        this._setShadowBlendStyle(e, T, $)
      );
    }
    return this._setShadowBlendStyle(e, T, C);
  }
  _setShadowBlendStyle(e, T, C) {
    const $ = this.nativeContext;
    C || (C = this.fillAttributes);
    const {
      opacity: F = C.opacity,
      shadowBlur: V = C.shadowBlur,
      shadowColor: Y = C.shadowColor,
      shadowOffsetX: K = C.shadowOffsetX,
      shadowOffsetY: J = C.shadowOffsetY,
      blur: ee = C.blur,
      globalCompositeOperation: te = C.globalCompositeOperation,
    } = T;
    F <= 1e-12 ||
      (V || K || J
        ? (($.shadowBlur = V * this.dpr),
          ($.shadowColor = Y),
          ($.shadowOffsetX = K * this.dpr),
          ($.shadowOffsetY = J * this.dpr),
          (this._clearShadowStyle = !0))
        : this._clearShadowStyle &&
          (($.shadowBlur = 0), ($.shadowOffsetX = 0), ($.shadowOffsetY = 0)),
      ee
        ? (($.filter = `blur(${ee}px)`), (this._clearFilterStyle = !0))
        : this._clearFilterStyle &&
          (($.filter = "blur(0px)"), (this._clearFilterStyle = !1)),
      te
        ? (($.globalCompositeOperation = te),
          (this._clearGlobalCompositeOperationStyle = !0))
        : this._clearGlobalCompositeOperationStyle &&
          (($.globalCompositeOperation = "source-over"),
          (this._clearGlobalCompositeOperationStyle = !1)));
  }
  setStrokeStyle(e, T, C, $, F) {
    if (Array.isArray(F)) {
      if (F.length <= 1) return this._setStrokeStyle(e, T, C, $, F[0]);
      const V = Object.create(F[0]);
      return (
        F.forEach((e, T) => {
          0 !== T && Object.assign(V, e);
        }),
        this._setStrokeStyle(e, T, C, $, V)
      );
    }
    return this._setStrokeStyle(e, T, C, $, F);
  }
  _setStrokeStyle(e, T, C, $, F) {
    const V = this.nativeContext;
    F || (F = this.strokeAttributes);
    const { strokeOpacity: Y = F.strokeOpacity, opacity: K = F.opacity } = T;
    if (
      ((V.globalAlpha = Y * K * this.baseGlobalAlpha), Y > 1e-12 && K > 1e-12)
    ) {
      const {
        lineWidth: Y = F.lineWidth,
        stroke: K = F.stroke,
        lineJoin: J = F.lineJoin,
        lineDash: ee = F.lineDash,
        lineCap: te = F.lineCap,
        miterLimit: ie = F.miterLimit,
      } = T;
      (V.lineWidth = getScaledStroke(this, Y, this.dpr)),
        (V.strokeStyle = createColor(this, K, e, C, $)),
        (V.lineJoin = J),
        ee && V.setLineDash(ee),
        (V.lineCap = te),
        (V.miterLimit = ie);
    }
  }
  setTextStyleWithoutAlignBaseline(e, T, C) {
    const $ = this.nativeContext;
    T || (T = this.textAttributes);
    const { scaleIn3d: F = T.scaleIn3d } = e;
    e.font
      ? ($.font = e.font)
      : ($.font = getContextFont(
          e,
          T,
          F && this.camera && this.camera.getProjectionScale(C)
        ));
    const { fontFamily: V = T.fontFamily, fontSize: Y = T.fontSize } = e;
    (this.fontFamily = V),
      (this.fontSize = Y),
      ($.textAlign = "left"),
      ($.textBaseline = "alphabetic");
  }
  setTextStyle(e, T, C) {
    var $, F;
    const V = this.nativeContext;
    T || (T = this.textAttributes),
      e.font
        ? (V.font = e.font)
        : (V.font = getContextFont(
            e,
            T,
            this.camera && this.camera.getProjectionScale(C)
          ));
    const { fontFamily: Y = T.fontFamily, fontSize: K = T.fontSize } = e;
    (this.fontFamily = Y),
      (this.fontSize = K),
      (V.textAlign =
        null !== ($ = e.textAlign) && void 0 !== $ ? $ : T.textAlign),
      (V.textBaseline =
        null !== (F = e.textBaseline) && void 0 !== F ? F : T.textBaseline);
  }
  draw() {}
  clearMatrix(e = !0, T = this.dpr) {
    this.setTransformFromMatrix(this._clearMatrix, e, T);
  }
  setClearMatrix(e, T, C, $, F, V) {
    this._clearMatrix.setValue(e, T, C, $, F, V);
  }
  onlyTranslate(e = this.dpr) {
    return (
      this.matrix.a === e &&
      0 === this.matrix.b &&
      0 === this.matrix.c &&
      this.matrix.d === e
    );
  }
  release(...e) {
    this.stack.forEach((e) => matrixAllocate.free(e)), (this.stack.length = 0);
  }
};
(BrowserContext2d.env = "browser"),
  (BrowserContext2d = __decorate$A(
    [injectable(), __metadata$u("design:paramtypes", [Object, Number])],
    BrowserContext2d
  ));
var __decorate$z =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$t =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let BrowserCanvas = class extends BaseCanvas {
  constructor(e) {
    super(e);
  }
  init(e) {
    const { container: T } = e;
    if ("string" == typeof T) {
      const e = application.global.getElementById(T);
      e && (this._container = e);
    } else this._container = T;
    (this._context = new BrowserContext2d(this, this._dpr)), this.initStyle();
  }
  initStyle() {
    if (!this.controled) return;
    const { nativeCanvas: e } = this;
    (e.width = this._pixelWidth),
      (e.height = this._pixelHeight),
      !e.style ||
        this.setCanvasStyle(
          e,
          this._x,
          this._y,
          this._displayWidth,
          this._displayHeight
        ),
      this._container && this._container.appendChild(e),
      this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const e = this._nativeCanvas;
    (e.style.position = "absolute"),
      (e.style.top = `${this._y}px`),
      (e.style.left = `${this._x}px`);
  }
  resetStyle(e) {
    if (!this.controled) return;
    const {
        width: T = this._displayWidth,
        height: C = this._displayHeight,
        dpr: $ = this._dpr,
        x: F = this._x,
        y: V = this._y,
      } = e,
      { nativeCanvas: Y } = this;
    (Y.width = T * $),
      (Y.height = C * $),
      !Y.style || this.setCanvasStyle(Y, F, V, T, C),
      e.id && (Y.id = e.id),
      this.visiable || this.hide();
  }
  setCanvasStyle(e, T, C, $, F) {
    this.controled && ((e.style.width = `${$}px`), (e.style.height = `${F}px`));
  }
  toDataURL(e, T) {
    return "image/jpeg" === e
      ? this._nativeCanvas.toDataURL(e, T)
      : "image/png" === e
      ? this._nativeCanvas.toDataURL(e)
      : this._nativeCanvas.toDataURL(e, T);
  }
  resize(e, T) {
    this.controled &&
      ((this._pixelWidth = e * this._dpr),
      (this._pixelHeight = T * this._dpr),
      (this._displayWidth = e),
      (this._displayHeight = T),
      this._nativeCanvas.style &&
        ((this._nativeCanvas.style.width = `${e}px`),
        (this._nativeCanvas.style.height = `${T}px`)),
      (this._nativeCanvas.width = this._pixelWidth),
      (this._nativeCanvas.height = this._pixelHeight),
      (this._context.dpr = this._dpr));
  }
};
function createModule(e, T) {
  return new ContainerModule((C) => {
    C(CanvasFactory)
      .toDynamicValue(() => (T) => new e(T))
      .whenTargetNamed(e.env),
      C(Context2dFactory)
        .toDynamicValue(() => (e, C) => new T(e, C))
        .whenTargetNamed(T.env);
  });
}
(BrowserCanvas.env = "browser"),
  (BrowserCanvas = __decorate$z(
    [injectable(), __metadata$t("design:paramtypes", [Object])],
    BrowserCanvas
  ));
const browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);
var __decorate$y =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$s =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$o =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(e, T, C) {
    super(C),
      (this.contributions = e),
      (this.drawContribution = T),
      (this.pickItemInterceptorContributions = C),
      this.global.hooks.onSetEnv.tap("canvas-picker-service", (e, T, C) => {
        this.configure(C, T);
      }),
      this.configure(this.global, this.global.env),
      (this.pickerMap = new Map()),
      this.init();
  }
  init() {
    this.contributions.getContributions().forEach((e) => {
      this.pickerMap.set(e.numberType, e);
    }),
      super._init();
  }
  configure(e, T) {
    (this.pickCanvas = canvasAllocate.shareCanvas()),
      (this.pickContext = this.pickCanvas.getContext("2d"));
  }
  pickItem(e, T, C, $) {
    if (!1 === e.attribute.pickable) return null;
    if (this.InterceptorContributions.length)
      for (let J = 0; J < this.InterceptorContributions.length; J++) {
        const F = this.InterceptorContributions[J];
        if (F.beforePickItem) {
          const V = F.beforePickItem(e, this, T, $, {
            parentMatrix: C,
          });
          if (V) return V;
        }
      }
    const F = this.pickerMap.get(e.numberType);
    if (!F) return null;
    const V = F.contains(e, T, $),
      Y = V ? e : null,
      K = {
        graphic: Y,
        params: V,
      };
    if (Y) return K;
    if (this.InterceptorContributions.length)
      for (let J = 0; J < this.InterceptorContributions.length; J++) {
        const F = this.InterceptorContributions[J];
        if (F.afterPickItem) {
          const V = F.afterPickItem(e, this, T, $, {
            parentMatrix: C,
          });
          if (V) return V;
        }
      }
    return K;
  }
};
DefaultCanvasPickerService = __decorate$y(
  [
    injectable(),
    __param$o(0, inject(ContributionProvider)),
    __param$o(0, named(CanvasPickerContribution)),
    __param$o(1, inject(DrawContribution)),
    __param$o(2, inject(ContributionProvider)),
    __param$o(2, named(PickItemInterceptor)),
    __metadata$s("design:paramtypes", [Object, Object, Object]),
  ],
  DefaultCanvasPickerService
);
var __decorate$x =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasGroupPicker = class {
  constructor() {
    (this.type = "group"), (this.numberType = GROUP_NUMBER_TYPE);
  }
  contains(e, T, C) {
    return !1;
  }
};
DefaultCanvasGroupPicker = __decorate$x(
  [injectable()],
  DefaultCanvasGroupPicker
);
const m = new ContainerModule((e, T, C, $) => {
  m.__vloaded ||
    ((m.__vloaded = !0),
    e(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasGroupPicker),
    bindContributionProvider(e, CanvasPickerContribution));
});
m.__vloaded = !1;
const canvasModule = m,
  canvasPickerModule = new ContainerModule((e, T, C, $) => {
    C(DefaultCanvasPickerService) ||
      e(DefaultCanvasPickerService).toSelf().inSingletonScope(),
      C(PickerService)
        ? $(PickerService).toService(DefaultCanvasPickerService)
        : e(PickerService).toService(DefaultCanvasPickerService);
  });
function loadCanvasPicker(e) {
  e.load(canvasModule), e.load(canvasPickerModule);
}
var BrowserWindowHandlerContribution_1,
  __decorate$w =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$r =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let BrowserWindowHandlerContribution =
  (BrowserWindowHandlerContribution_1 = class extends (
    BaseWindowHandlerContribution
  ) {
    get container() {
      return this.canvas.nativeCanvas.parentElement;
    }
    static GenerateCanvasId() {
      return `${
        BrowserWindowHandlerContribution_1.idprefix
      }_${BrowserWindowHandlerContribution_1.prefix_count++}`;
    }
    constructor() {
      super(),
        (this.type = "browser"),
        (this._canvasIsIntersecting = !0),
        (this.global = application.global),
        (this.viewBox = new AABBBounds()),
        (this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0));
    }
    getTitle() {
      return this.canvas.id && this.canvas.id.toString();
    }
    getWH() {
      return {
        width: this.canvas.width / (this.canvas.dpr || 1),
        height: this.canvas.height / (this.canvas.dpr || 1),
      };
    }
    getXY() {
      return this.canvas.nativeCanvas.getBoundingClientRect();
    }
    createWindow(e) {
      e.canvas ? this.createWindowByCanvas(e) : this.createWindowByConfig(e),
        this.postInit();
    }
    postInit() {
      if (this.global.optimizeVisible)
        try {
          this.observerCanvas();
        } catch (e) {
          console.error("IntersectionObserver");
        }
    }
    isElementVisible(e) {
      const T = e.getBoundingClientRect(),
        C = window.innerWidth || document.documentElement.clientWidth,
        $ = window.innerHeight || document.documentElement.clientHeight;
      return !(T.right < 0 || T.bottom < 0 || T.left > C || T.top > $);
    }
    observerCanvas() {
      this._canvasIsIntersecting = this.isElementVisible(
        this.canvas.nativeCanvas
      );
      const e = new IntersectionObserver((e, T) => {
        e.forEach((e) => {
          this._canvasIsIntersecting !== e.isIntersecting
            ? ((this._canvasIsIntersecting = e.isIntersecting),
              this._onVisibleChangeCb &&
                this._onVisibleChangeCb(e.isIntersecting))
            : (this._canvasIsIntersecting = e.isIntersecting);
        });
      });
      e && e.observe(this.canvas.nativeCanvas);
    }
    createWindowByConfig(e) {
      const T = this.global.createCanvas({
        width: e.width,
        height: e.height,
      });
      let C;
      if (
        ((C =
          "string" == typeof e.container
            ? this.global.getElementById(e.container)
            : e.container
            ? e.container
            : this.global.getRootElement()),
        !C)
      )
        throw new Error("containerId");
      e.offscreen ? (C = null) : C.appendChild(T);
      const $ = {
        width: e.width,
        height: e.height,
        dpr: e.dpr,
        nativeCanvas: T,
        container: C,
        id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
        canvasControled: !0,
      };
      this.canvas = new BrowserCanvas($);
    }
    createWindowByCanvas(e) {
      var T;
      let C;
      if ("string" == typeof e.canvas) {
        if (((C = this.global.getElementById(e.canvas)), !C))
          throw new Error("canvasId canvasdom");
      } else C = e.canvas;
      if (!C) throw new Error("canvas");
      let $ = e.width,
        F = e.height;
      if (null == $ || null == F || !e.canvasControled) {
        const e = C.getBoundingClientRect();
        ($ = e.width), (F = e.height);
      }
      let V = e.dpr;
      null == V &&
        (V =
          null !== (T = C.getContext("2d").pixelRatio) && void 0 !== T
            ? T
            : C.width / $),
        (this.canvas = new BrowserCanvas({
          width: $,
          height: F,
          dpr: V,
          nativeCanvas: C,
          canvasControled: e.canvasControled,
        }));
    }
    releaseWindow() {
      this.canvas.release();
    }
    resizeWindow(e, T) {
      this.canvas.resize(e, T);
    }
    setDpr(e) {
      this.canvas.dpr = e;
    }
    getContext() {
      return this.canvas.getContext();
    }
    getNativeHandler() {
      return this.canvas;
    }
    getDpr() {
      return this.canvas.dpr;
    }
    addEventListener(e, T, C) {
      return this.canvas.nativeCanvas.addEventListener(e, T, C);
    }
    removeEventListener(e, T, C) {
      return this.canvas.nativeCanvas.removeEventListener(e, T, C);
    }
    dispatchEvent(e) {
      return this.canvas.nativeCanvas.dispatchEvent(e);
    }
    getStyle() {
      var e;
      return null !== (e = this.canvas.nativeCanvas.style) && void 0 !== e
        ? e
        : {};
    }
    setStyle(e) {
      this.canvas.nativeCanvas.style = e;
    }
    getBoundingClientRect() {
      const e = this.canvas.nativeCanvas,
        T = this.getWH();
      return e.parentElement
        ? this.canvas.nativeCanvas.getBoundingClientRect()
        : {
            x: 0,
            y: 0,
            width: T.width,
            height: T.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
          };
    }
    clearViewBox(e) {
      const T = this.viewBox,
        C = this.getContext(),
        $ = this.getDpr();
      C.nativeContext.save(),
        C.nativeContext.setTransform($, 0, 0, $, 0, 0),
        C.clearRect(T.x1, T.y1, T.x2 - T.x1, T.y2 - T.y1),
        e &&
          ((C.fillStyle = e), C.fillRect(T.x1, T.y1, T.x2 - T.x1, T.y2 - T.y1)),
        C.nativeContext.restore();
    }
    isVisible(e) {
      return this._canvasIsIntersecting;
    }
    onVisibleChange(e) {
      this._onVisibleChangeCb = e;
    }
    getTopLeft(e) {
      return this.global.getElementTopLeft(this.canvas.nativeCanvas, e);
    }
  });
(BrowserWindowHandlerContribution.env = "browser"),
  (BrowserWindowHandlerContribution.idprefix = "visactor_window"),
  (BrowserWindowHandlerContribution.prefix_count = 0),
  (BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 =
    __decorate$w(
      [injectable(), __metadata$r("design:paramtypes", [])],
      BrowserWindowHandlerContribution
    ));
const browserWindowModule = new ContainerModule((e) => {
  e(BrowserWindowHandlerContribution).toSelf(),
    e(WindowHandlerContribution)
      .toDynamicValue((e) => e.container.get(BrowserWindowHandlerContribution))
      .whenTargetNamed(BrowserWindowHandlerContribution.env);
});
var __decorate$v =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$q =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
class DynamicB {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(e) {
    this.dom = e;
  }
}
function createImageElement(e, T = !1) {
  const C = document.createElement("img");
  if (((C.crossOrigin = "anonymous"), T)) {
    const T = new Blob([e], {
      type: "image/svg+xml",
    });
    e = window.URL.createObjectURL(T);
  }
  return (
    (C.src = e),
    C.complete
      ? Promise.resolve(C)
      : new Promise((e, T) => {
          (C.onload = () => {
            e(C);
          }),
            (C.onerror = () => {
              T(new Error(""));
            });
        })
  );
}
let BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), (this.type = "browser"), (this.supportEvent = !0);
    try {
      (this.supportsTouchEvents = "ontouchstart" in globalThis),
        (this.supportsPointerEvents = !!globalThis.PointerEvent),
        (this.supportsMouseEvents = !!globalThis.MouseEvent);
    } catch (e) {
      (this.supportsTouchEvents = !1),
        (this.supportsPointerEvents = !1),
        (this.supportsPointerEvents = !1);
    }
    this.applyStyles = !0;
  }
  mapToCanvasPoint(e, T) {
    var C, $;
    let F = 0,
      V = 0,
      Y = 0,
      K = 0;
    if (e.changedTouches) {
      const T = null !== (C = e.changedTouches[0]) && void 0 !== C ? C : {};
      (F = T.clientX || 0), (V = T.clientY || 0), (Y = F), (K = V);
    } else
      (F = e.clientX || 0),
        (V = e.clientY || 0),
        (Y = e.offsetX || 0),
        (K = e.offsetY || 0);
    if (T) {
      const e = F,
        C = V,
        Y = T.getBoundingClientRect(),
        K =
          null === ($ = T.getNativeHandler) || void 0 === $
            ? void 0
            : $.call(T).nativeCanvas;
      let J, ee;
      return (
        K && ((J = Y.width / K.offsetWidth), (ee = Y.height / K.offsetHeight)),
        {
          x: (e - Y.left) / (isValidNumber$1(J) ? J : 1),
          y: (C - Y.top) / (isValidNumber$1(ee) ? ee : 1),
        }
      );
    }
    return {
      x: Y,
      y: K,
    };
  }
  getNativeAABBBounds(e) {
    let T = e;
    if (
      ("string" == typeof e &&
        ((T = new DOMParser().parseFromString(e, "text/html").firstChild),
        T.lastChild && (T = T.lastChild.firstChild)),
      T.getBoundingClientRect)
    ) {
      const e = T.getBoundingClientRect();
      return new DynamicB(e);
    }
    return new AABBBounds();
  }
  removeDom(e) {
    return e.parentElement.removeChild(e), !0;
  }
  updateDom(e, T) {
    const { width: C, height: $, style: F } = T;
    return (
      F &&
        (isString$1(F)
          ? e.setAttribute("style", F)
          : Object.keys(F).forEach((T) => {
              e.style[T] = F[T];
            })),
      null != C && (e.style.width = `${C}px`),
      null != $ && (e.style.height = `${$}px`),
      !0
    );
  }
  createDom(e) {
    const { tagName: T = "div", parent: C } = e,
      $ = document.createElement(T);
    if ((this.updateDom($, e), C)) {
      const e = isString$1(C) ? this.getElementById(C) : C;
      e && e.appendChild && e.appendChild($);
    }
    return $;
  }
  loadImage(e) {
    return createImageElement(e, !1)
      .then((e) => ({
        data: e,
        loadState: "success",
      }))
      .catch(() => ({
        data: null,
        loadState: "fail",
      }));
  }
  loadSvg(e) {
    return createImageElement(e, !0)
      .then((e) => ({
        data: e,
        loadState: "success",
      }))
      .catch(() => ({
        data: null,
        loadState: "fail",
      }));
  }
  createCanvas(e) {
    var T, C;
    const $ = document.createElement("canvas");
    e.id &&
      ($.id =
        null !== (T = e.id) && void 0 !== T
          ? T
          : Generator.GenAutoIncrementId().toString());
    const F =
      null !== (C = e.dpr) && void 0 !== C ? C : window.devicePixelRatio;
    return (
      e.width &&
        e.height &&
        (($.style.width = `${e.width}px`),
        ($.style.height = `${e.height}px`),
        ($.width = e.width * F),
        ($.height = e.height * F)),
      $
    );
  }
  createOffscreenCanvas(e) {
    var T;
    const C =
      null !== (T = e.dpr) && void 0 !== T ? T : window.devicePixelRatio;
    return new OffscreenCanvas(e.width * C, e.height * C);
  }
  releaseCanvas(e) {
    let T;
    (T = "string" == typeof e ? document.getElementById(e) : e),
      T && T.parentElement && T.parentElement.removeChild(T);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(e, T, C) {
    return document.addEventListener(e, T, C);
  }
  removeEventListener(e, T, C) {
    return document.removeEventListener(e, T, C);
  }
  dispatchEvent(e) {
    return document.dispatchEvent(e);
  }
  getElementById(e) {
    return document.getElementById(e);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release(...e) {}
  getElementTop(e, T) {
    let C = e.offsetTop,
      $ = e.offsetParent;
    for (; null !== $; ) (C += $.offsetTop), ($ = $.offsetParent);
    return C;
  }
  getElementLeft(e, T) {
    let C = e.offsetLeft,
      $ = e.offsetParent;
    for (; null !== $; ) (C += $.offsetLeft), ($ = $.offsetParent);
    return C;
  }
  getElementTopLeft(e, T) {
    let C = e.offsetTop,
      $ = e.offsetLeft,
      F = e.offsetParent;
    for (; null !== F; )
      (C += F.offsetTop), ($ += F.offsetLeft), (F = F.offsetParent);
    return {
      top: C,
      left: $,
    };
  }
};
BrowserEnvContribution = __decorate$v(
  [injectable(), __metadata$q("design:paramtypes", [])],
  BrowserEnvContribution
);
const browserEnvModule = new ContainerModule((e) => {
  browserEnvModule.isBrowserBound ||
    ((browserEnvModule.isBrowserBound = !0),
    e(BrowserEnvContribution).toSelf().inSingletonScope(),
    e(EnvContribution).toService(BrowserEnvContribution));
});
function loadBrowserEnv(e, T = !0) {
  loadBrowserEnv.__loaded ||
    ((loadBrowserEnv.__loaded = !0),
    e.load(browserEnvModule),
    e.load(browserCanvasModule),
    e.load(browserWindowModule),
    T && loadCanvasPicker(e));
}
(browserEnvModule.isBrowserBound = !1), (loadBrowserEnv.__loaded = !1);
var __decorate$u =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$p =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$n =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathArcPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "arc"),
      (this.numberType = ARC_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).arc;
    $.highPerformanceSave();
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (e.transMatrix.onlyTranslate()) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathArcPicker = __decorate$u(
  [
    injectable(),
    __param$n(0, inject(ArcRender)),
    __metadata$p("design:paramtypes", [Object]),
  ],
  DefaultMathArcPicker
);
let loadArcPick$1 = !1;
const arcMathPickModule = new ContainerModule((e, T, C, $) => {
  loadArcPick$1 ||
    ((loadArcPick$1 = !0),
    e(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathArcPicker));
});
var __decorate$t =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$o =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$m =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathAreaPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "area"),
      (this.numberType = AREA_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).area;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e) => !!K || ((K = e.isPointInPath(T.x, T.y)), K)
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathAreaPicker = __decorate$t(
  [
    injectable(),
    __param$m(0, inject(AreaRender)),
    __metadata$o("design:paramtypes", [Object]),
  ],
  DefaultMathAreaPicker
);
let loadAreaPick$1 = !1;
const areaMathPickModule = new ContainerModule((e, T, C, $) => {
  loadAreaPick$1 ||
    ((loadAreaPick$1 = !0),
    e(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathAreaPicker));
});
var __decorate$s =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$n =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$l =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathCirclePicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "circle"),
      (this.numberType = CIRCLE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).circle;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathCirclePicker = __decorate$s(
  [
    injectable(),
    __param$l(0, inject(CircleRender)),
    __metadata$n("design:paramtypes", [Object]),
  ],
  DefaultMathCirclePicker
);
let loadCirclePick$1 = !1;
const circleMathPickModule = new ContainerModule((e, T, C, $) => {
  loadCirclePick$1 ||
    ((loadCirclePick$1 = !0),
    e(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathCirclePicker));
});
var __decorate$r =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$m =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$k =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathGlyphPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "glyph"),
      (this.numberType = GLYPH_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = null == C ? void 0 : C.pickerService;
    if (F) {
      let $ = !1;
      return (
        e.getSubGraphic().forEach((e) => {
          $ || ($ = !!F.pickItem(e, T, null, C));
        }),
        $
      );
    }
    return !1;
  }
};
DefaultMathGlyphPicker = __decorate$r(
  [
    injectable(),
    __param$k(0, inject(GlyphRender)),
    __metadata$m("design:paramtypes", [Object]),
  ],
  DefaultMathGlyphPicker
);
let loadGlyphPick$1 = !1;
const glyphMathPickModule = new ContainerModule((e, T, C, $) => {
  loadGlyphPick$1 ||
    ((loadGlyphPick$1 = !0),
    e(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(),
    e(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});
var __decorate$q =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultMathImagePicker = class {
  constructor() {
    (this.type = "image"), (this.numberType = IMAGE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    return !!$ && !!e.AABBBounds.containsPoint(T);
  }
};
DefaultMathImagePicker = __decorate$q([injectable()], DefaultMathImagePicker);
let loadImagePick$1 = !1;
const imageMathPickModule = new ContainerModule((e, T, C, $) => {
  loadImagePick$1 ||
    ((loadImagePick$1 = !0),
    e(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(),
    e(DefaultMathImagePicker).toService(MathImagePicker));
});
var __decorate$p =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$l =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$j =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathLinePicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "line"),
      (this.numberType = LINE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).line;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathLinePicker = __decorate$p(
  [
    injectable(),
    __param$j(0, inject(LineRender)),
    __metadata$l("design:paramtypes", [Object]),
  ],
  DefaultMathLinePicker
);
let loadLinePick$1 = !1;
const lineMathPickModule = new ContainerModule((e, T, C, $) => {
  loadLinePick$1 ||
    ((loadLinePick$1 = !0),
    e(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathLinePicker));
});
var __decorate$o =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$k =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$i =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathPolygonPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "polygon"),
      (this.numberType = POLYGON_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.contains(T.x, T.y)) return !1;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).polygon;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathPolygonPicker = __decorate$o(
  [
    injectable(),
    __param$i(0, inject(PolygonRender)),
    __metadata$k("design:paramtypes", [Object]),
  ],
  DefaultMathPolygonPicker
);
let loadPolygonPick$1 = !1;
const polygonMathPickModule = new ContainerModule((e, T, C, $) => {
  loadPolygonPick$1 ||
    ((loadPolygonPick$1 = !0),
    e(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathPolygonPicker));
});
var __decorate$n =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$j =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$h =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathPathPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "path"),
      (this.numberType = PATH_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).path;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathPathPicker = __decorate$n(
  [
    injectable(),
    __param$h(0, inject(PathRender)),
    __metadata$j("design:paramtypes", [Object]),
  ],
  DefaultMathPathPicker
);
let loadPathPick$1 = !1;
const pathMathPickModule = new ContainerModule((e, T, C, $) => {
  loadPathPick$1 ||
    ((loadPathPick$1 = !0),
    e(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathPathPicker));
});
var __decorate$m =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$i =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$g =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
const _bounds$1 = new AABBBounds();
let DefaultMathRectPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "rect"),
      (this.numberType = RECT_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).rect,
      { cornerRadius: V = F.cornerRadius } = e.attribute;
    let { x: Y = F.x, y: K = F.y } = e.attribute;
    $.highPerformanceSave();
    let J = !0;
    if (e.transMatrix.onlyTranslate()) {
      const T = e.getOffsetXY(F);
      (Y += T.x), (K += T.y), $.setTransformForCurrent();
    } else (Y = 0), (K = 0), (J = !1), $.transformFromMatrix(e.transMatrix, !0);
    let ee = !0;
    if (
      !J ||
      (isNumber$1(V, !0) && 0 !== V) ||
      (isArray$1(V) && V.some((e) => 0 !== e))
    )
      (ee = !1),
        this.canvasRenderer.drawShape(
          e,
          $,
          Y,
          K,
          {},
          null,
          (e, C, $) => !!ee || ((ee = e.isPointInPath(T.x, T.y)), ee),
          (e, C, F) => {
            if (ee) return !0;
            const V = C.lineWidth || F.lineWidth,
              Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
            return (
              ($.lineWidth = V + Y), (ee = e.isPointInStroke(T.x, T.y)), ee
            );
          }
        );
    else if (ee) {
      const {
        fill: C = F.fill,
        stroke: $ = F.stroke,
        lineWidth: V = F.lineWidth,
      } = e.attribute;
      if (C) ee = !0;
      else if ($) {
        const C = e.AABBBounds;
        _bounds$1.setValue(C.x1, C.y1, C.x2, C.y2),
          _bounds$1.expand(-V / 2),
          (ee = !_bounds$1.containsPoint(T));
      }
    }
    return $.highPerformanceRestore(), ee;
  }
};
DefaultMathRectPicker = __decorate$m(
  [
    injectable(),
    __param$g(0, inject(RectRender)),
    __metadata$i("design:paramtypes", [Object]),
  ],
  DefaultMathRectPicker
);
let loadRectPick$1 = !1;
const rectMathPickModule = new ContainerModule((e, T, C, $) => {
  loadRectPick$1 ||
    ((loadRectPick$1 = !0),
    e(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathRectPicker));
});
let loadRichTextPick = !1;
const richTextMathPickModule = new ContainerModule((e, T, C, $) => {
  loadRichTextPick ||
    ((loadRichTextPick = !0),
    e(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(),
    e(DefaultMathImagePicker).toService(MathImagePicker));
});
var __decorate$l =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$h =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$f =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultMathSymbolPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "symbol"),
      (this.numberType = SYMBOL_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).symbol;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return ($.lineWidth = V + Y), (K = e.isPointInStroke(T.x, T.y)), K;
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultMathSymbolPicker = __decorate$l(
  [
    injectable(),
    __param$f(0, inject(SymbolRender)),
    __metadata$h("design:paramtypes", [Object]),
  ],
  DefaultMathSymbolPicker
);
let loadSymbolPick$1 = !1;
const symbolMathPickModule = new ContainerModule((e, T, C, $) => {
  loadSymbolPick$1 ||
    ((loadSymbolPick$1 = !0),
    e(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathSymbolPicker));
});
var __decorate$k =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultMathTextPicker = class {
  constructor() {
    (this.type = "text"), (this.numberType = TEXT_NUMBER_TYPE);
  }
  contains(e, T, C) {
    return !!e.AABBBounds.containsPoint(T);
  }
};
DefaultMathTextPicker = __decorate$k([injectable()], DefaultMathTextPicker);
let loadTextPick$1 = !1;
const textMathPickModule = new ContainerModule((e, T, C, $) => {
  loadTextPick$1 ||
    ((loadTextPick$1 = !0),
    e(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(),
    e(MathPickerContribution).toService(MathTextPicker));
});
var __decorate$j =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$g =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let NodeContext2d = class extends BrowserContext2d {
  constructor(e, T) {
    super(e, T);
    const C = e.nativeCanvas.getContext("2d");
    if (!C) throw new Error("2d");
    (this.nativeContext = C),
      (this.canvas = e),
      (this.matrix = new Matrix(1, 0, 0, 1, 0, 0)),
      (this.stack = []),
      (this.dpr = null != T ? T : 1);
  }
  release(...e) {}
};
(NodeContext2d.env = "node"),
  (NodeContext2d = __decorate$j(
    [injectable(), __metadata$g("design:paramtypes", [Object, Number])],
    NodeContext2d
  ));
var __decorate$i =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$f =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    };
let NodeCanvas = class extends BaseCanvas {
  constructor(e) {
    super(e);
  }
  init() {
    (this._context = new NodeContext2d(this, this._dpr)),
      (this.nativeCanvas.width = this._pixelWidth),
      (this.nativeCanvas.height = this._pixelHeight);
  }
  release(...e) {
    this._nativeCanvas.release &&
      isFunction$1(this._nativeCanvas.release) &&
      this._nativeCanvas.release();
  }
};
(NodeCanvas.env = "node"),
  (NodeCanvas = __decorate$i(
    [injectable(), __metadata$f("design:paramtypes", [Object])],
    NodeCanvas
  ));
const nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);
var __decorate$h =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$e =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$e =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(e) {
    super(), (this.global = e), (this.type = "node");
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight,
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0,
    };
  }
  createWindow(e) {
    e.canvas ? this.createWindowByCanvas(e) : this.createWindowByConfig(e);
  }
  createWindowByConfig(e) {
    const T = this.global.createCanvas({
        width: e.width,
        height: e.height,
      }),
      C = {
        width: e.width,
        height: e.height,
        dpr: e.dpr,
        nativeCanvas: T,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !0,
      };
    this.canvas = new NodeCanvas(C);
  }
  createWindowByCanvas(e) {
    const T = e.canvas;
    let C = e.width,
      $ = e.height;
    (null != C && null != $ && e.canvasControled) ||
      ((C = T.width), ($ = T.height)),
      (this.canvas = new NodeCanvas({
        width: C,
        height: $,
        dpr: 1,
        nativeCanvas: T,
        canvasControled: e.canvasControled,
      }));
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(e, T) {
    this.canvas.resize(e, T);
  }
  setDpr(e) {
    this.canvas.dpr = e;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer(e = "image/png") {
    return this.canvas.nativeCanvas.toBuffer(e);
  }
  addEventListener(e, T, C) {}
  dispatchEvent(e) {
    return !0;
  }
  removeEventListener(e, T, C) {}
  getStyle() {}
  setStyle(e) {}
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(e) {}
};
(NodeWindowHandlerContribution.env = "node"),
  (NodeWindowHandlerContribution = __decorate$h(
    [
      injectable(),
      __param$e(0, inject(VGlobal)),
      __metadata$e("design:paramtypes", [Object]),
    ],
    NodeWindowHandlerContribution
  ));
const nodeWindowModule = new ContainerModule((e) => {
  e(NodeWindowHandlerContribution).toSelf(),
    e(WindowHandlerContribution)
      .toDynamicValue((e) => e.container.get(NodeWindowHandlerContribution))
      .whenTargetNamed(NodeWindowHandlerContribution.env);
});
var __decorate$g =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments),
      (this.type = "node"),
      (this._lastTime = 0),
      (this.supportEvent = !1);
  }
  configure(e, T) {
    e.env === this.type && (e.setActiveEnvContribution(this), (this.pkg = T));
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(e) {
    const T = fetch(e).then((e) => e.json());
    return (
      T.then((e) => ({
        data: e,
        state: "success",
      })).catch(() => ({
        data: null,
        state: "fail",
      })),
      T
    );
  }
  loadArrayBuffer(e) {
    return fetch(e)
      .then((e) => e.arrayBuffer())
      .then((e) => ({
        data: e,
        loadState: "success",
      }))
      .catch(() => ({
        data: null,
        loadState: "fail",
      }));
  }
  loadImage(e) {
    const { loadImage: T } = this.pkg;
    return T
      ? T(e)
          .then((e) => ({
            loadState: e ? "success" : "fail",
            data: e,
          }))
          .catch(() => ({
            loadState: "fail",
            data: null,
          }))
      : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(e) {
    const T = this.pkg.Resvg;
    if (!T)
      return Promise.reject(
        new Error("@resvg/resvg-js svgParser could not be found!")
      );
    const C = new T(e).render().asPng();
    return this.loadImage(C);
  }
  createCanvas(e) {
    return this.pkg.createCanvas(e.width, e.height);
  }
  releaseCanvas(e) {}
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function (e) {
      return rafBasedSto.call(e);
    };
  }
  getCancelAnimationFrame() {
    return (e) => {
      rafBasedSto.clear(e);
    };
  }
  addEventListener(e, T, C) {}
  removeEventListener(e, T, C) {}
  getElementById(e) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(e) {}
  release(...e) {}
  createOffscreenCanvas(e) {}
};
NodeEnvContribution = __decorate$g([injectable()], NodeEnvContribution);
const nodeEnvModule = new ContainerModule((e) => {
  nodeEnvModule.isNodeBound ||
    ((nodeEnvModule.isNodeBound = !0),
    e(NodeEnvContribution).toSelf().inSingletonScope(),
    e(EnvContribution).toService(NodeEnvContribution));
});
function loadNodeEnv(e, T = !0) {
  loadNodeEnv.__loaded ||
    ((loadNodeEnv.__loaded = !0),
    e.load(nodeEnvModule),
    e.load(nodeCanvasModule),
    e.load(nodeWindowModule));
}
(nodeEnvModule.isNodeBound = !1), (loadNodeEnv.__loaded = !1);
var __decorate$f =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$d =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$d =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasArcPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "arc"),
      (this.numberType = ARC_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).arc;
    $.highPerformanceSave();
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (e.transMatrix.onlyTranslate()) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, V + Y, $.dpr)),
            (K = e.isPointInStroke(T.x, T.y)),
            K
          );
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultCanvasArcPicker = __decorate$f(
  [
    injectable(),
    __param$d(0, inject(ArcRender)),
    __metadata$d("design:paramtypes", [Object]),
  ],
  DefaultCanvasArcPicker
);
let loadArcPick = !1;
const arcCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadArcPick ||
    ((loadArcPick = !0),
    e(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasArcPicker));
});
var __decorate$e =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$c =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$c =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
const _bounds = new AABBBounds();
let DefaultCanvasRectPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "rect"),
      (this.numberType = RECT_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).rect,
      { cornerRadius: V = F.cornerRadius } = e.attribute;
    let { x: Y = F.x, y: K = F.y } = e.attribute;
    $.highPerformanceSave();
    let J = !0;
    if (e.transMatrix.onlyTranslate()) {
      const T = e.getOffsetXY(F);
      (Y += T.x), (K += T.y), $.setTransformForCurrent();
    } else (Y = 0), (K = 0), (J = !1), $.transformFromMatrix(e.transMatrix, !0);
    let ee = !0;
    if (
      !J ||
      e.shadowRoot ||
      (isNumber$1(V, !0) && 0 !== V) ||
      (isArray$1(V) && V.some((e) => 0 !== e))
    )
      (ee = !1),
        this.canvasRenderer.drawShape(
          e,
          $,
          Y,
          K,
          {},
          null,
          (e, C, $) => !!ee || ((ee = e.isPointInPath(T.x, T.y)), ee),
          (e, C, F) => {
            if (ee) return !0;
            const V = C.lineWidth || F.lineWidth,
              Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
            return (
              ($.lineWidth = getScaledStroke($, V + Y, $.dpr)),
              (ee = e.isPointInStroke(T.x, T.y)),
              ee
            );
          }
        );
    else {
      const {
        fill: C = F.fill,
        stroke: $ = F.stroke,
        lineWidth: V = F.lineWidth,
      } = e.attribute;
      if (C) ee = !0;
      else if ($) {
        const C = e.AABBBounds;
        _bounds.setValue(C.x1, C.y1, C.x2, C.y2),
          _bounds.expand(-V / 2),
          (ee = !_bounds.containsPoint(T));
      }
    }
    return $.highPerformanceRestore(), ee;
  }
};
DefaultCanvasRectPicker = __decorate$e(
  [
    injectable(),
    __param$c(0, inject(RectRender)),
    __metadata$c("design:paramtypes", [Object]),
  ],
  DefaultCanvasRectPicker
);
let loadRectPick = !1;
const rectCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadRectPick ||
    ((loadRectPick = !0),
    e(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasRectPicker));
});
var __decorate$d =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let BasePicker = class extends BaseRender {};
BasePicker = __decorate$d([injectable()], BasePicker);
var __decorate$c =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$b =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$b =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasLinePicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "line"),
      (this.numberType = LINE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    $.highPerformanceSave();
    const F = getTheme(e).line,
      V = this.transform(e, F, $),
      { x: Y, y: K, z: J, lastModelMatrix: ee } = V;
    let te = T;
    if ($.camera) {
      te = T.clone();
      const C = e.parent.globalTransMatrix;
      (te.x = C.a * T.x + C.c * T.y + C.e),
        (te.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = J;
    let ie = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        Y,
        K,
        {},
        null,
        (e) => !!ie || ((ie = e.isPointInPath(te.x, te.y)), ie),
        (e, T, C) => {
          if (ie) return !0;
          const F = T.lineWidth || C.lineWidth,
            V = T.pickStrokeBuffer || C.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, F + V, $.dpr)),
            (ie = e.isPointInStroke(te.x, te.y)),
            ie
          );
        }
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ee && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ee),
      $.highPerformanceRestore(),
      ie
    );
  }
};
DefaultCanvasLinePicker = __decorate$c(
  [
    injectable(),
    __param$b(0, inject(LineRender)),
    __metadata$b("design:paramtypes", [Object]),
  ],
  DefaultCanvasLinePicker
);
let loadLinePick = !1;
const lineCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadLinePick ||
    ((loadLinePick = !0),
    e(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasLinePicker));
});
var __decorate$b =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$a =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$a =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasAreaPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "area"),
      (this.numberType = AREA_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).area;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    const {
      fillPickable: K = F.fillPickable,
      strokePickable: J = F.strokePickable,
    } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let ee = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e) => !!ee || (!!K && ((ee = e.isPointInPath(T.x, T.y)), ee)),
        (e, C, F) => {
          if (ee) return !0;
          if (!J) return !1;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, V + Y, $.dpr)),
            (ee = e.isPointInStroke(T.x, T.y)),
            ee
          );
        }
      ),
      $.highPerformanceRestore(),
      ee
    );
  }
};
DefaultCanvasAreaPicker = __decorate$b(
  [
    injectable(),
    __param$a(0, inject(AreaRender)),
    __metadata$a("design:paramtypes", [Object]),
  ],
  DefaultCanvasAreaPicker
);
let loadAreaPick = !1;
const areaCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadAreaPick ||
    ((loadAreaPick = !0),
    e(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasAreaPicker));
});
var __decorate$a =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$9 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$9 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasSymbolPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "symbol"),
      (this.numberType = SYMBOL_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = e.getParsedPath();
    if (!$.camera) {
      if (!e.AABBBounds.containsPoint(T)) return !1;
      if (F.isSvg || "imprecise" === e.attribute.pickMode) return !0;
    }
    $.highPerformanceSave();
    const V = getTheme(e).symbol,
      Y = this.transform(e, V, $),
      { x: K, y: J, z: ee, lastModelMatrix: te } = Y;
    let ie = T;
    if ($.camera) {
      ie = T.clone();
      const C = e.parent.globalTransMatrix;
      (ie.x = C.a * T.x + C.c * T.y + C.e),
        (ie.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = ee;
    let ne = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        K,
        J,
        {},
        null,
        (e, T, C) => !!ne || ((ne = e.isPointInPath(ie.x, ie.y)), ne),
        (e, T, C) => {
          if (ne) return !0;
          const F = T.lineWidth || C.lineWidth,
            V = T.pickStrokeBuffer || C.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, F + V, $.dpr)),
            (ne = e.isPointInStroke(ie.x, ie.y)),
            ne
          );
        }
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== te && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = te),
      $.highPerformanceRestore(),
      ne
    );
  }
};
DefaultCanvasSymbolPicker = __decorate$a(
  [
    injectable(),
    __param$9(0, inject(SymbolRender)),
    __metadata$9("design:paramtypes", [Object]),
  ],
  DefaultCanvasSymbolPicker
);
let loadSymbolPick = !1;
const symbolCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadSymbolPick ||
    ((loadSymbolPick = !0),
    e(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasSymbolPicker));
});
var __decorate$9 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$8 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$8 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasCirclePicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "circle"),
      (this.numberType = CIRCLE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).circle;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, V + Y, $.dpr)),
            (K = e.isPointInStroke(T.x, T.y)),
            K
          );
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultCanvasCirclePicker = __decorate$9(
  [
    injectable(),
    __param$8(0, inject(CircleRender)),
    __metadata$8("design:paramtypes", [Object]),
  ],
  DefaultCanvasCirclePicker
);
let loadCirclePick = !1;
const circleCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadCirclePick ||
    ((loadCirclePick = !0),
    e(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasCirclePicker));
});
var __decorate$8 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$7 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$7 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasTextPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "text"),
      (this.numberType = TEXT_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = e.AABBBounds;
    if (!$.camera) return !!F.containsPoint(T);
    $.highPerformanceSave();
    const V = getTheme(e).text,
      { keepDirIn3d: Y = V.keepDirIn3d } = e.attribute,
      K = !Y,
      J = this.transform(e, V, $, K),
      { x: ee, y: te, z: ie, lastModelMatrix: ne } = J;
    this.canvasRenderer.z = ie;
    let re = T;
    if ($.camera) {
      re = T.clone();
      const C = e.parent.globalTransMatrix;
      (re.x = C.a * T.x + C.c * T.y + C.e),
        (re.y = C.b * T.x + C.d * T.y + C.f);
    }
    let ae = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        ee,
        te,
        {},
        null,
        (T, C, $) => {
          if (ae) return !0;
          const {
              fontSize: F = V.fontSize,
              textBaseline: Y = V.textBaseline,
              textAlign: K = V.textAlign,
            } = e.attribute,
            J = e.AABBBounds,
            ne = J.height(),
            oe = J.width(),
            se = textLayoutOffsetY(Y, ne, F),
            le = textDrawOffsetX(K, oe);
          return (
            T.rect(le + ee, se + te, oe, ne, ie),
            (ae = T.isPointInPath(re.x, re.y)),
            ae
          );
        },
        (e, T, C) => ae
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ne && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ne),
      $.highPerformanceRestore(),
      ae
    );
  }
};
DefaultCanvasTextPicker = __decorate$8(
  [
    injectable(),
    __param$7(0, inject(TextRender)),
    __metadata$7("design:paramtypes", [Object]),
  ],
  DefaultCanvasTextPicker
);
let loadTextPick = !1;
const textCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadTextPick ||
    ((loadTextPick = !0),
    e(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasTextPicker));
});
var __decorate$7 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$6 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$6 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPathPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "path"),
      (this.numberType = PATH_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).path;
    $.highPerformanceSave();
    const V = this.transform(e, F, $),
      { x: Y, y: K, z: J, lastModelMatrix: ee } = V;
    let te = T;
    if ($.camera) {
      te = T.clone();
      const C = e.parent.globalTransMatrix;
      (te.x = C.a * T.x + C.c * T.y + C.e),
        (te.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = J;
    let ie = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        Y,
        K,
        {},
        null,
        (e, T, C) => !!ie || ((ie = e.isPointInPath(te.x, te.y)), ie),
        (e, T, C) => {
          if (ie) return !0;
          const F = T.lineWidth || C.lineWidth,
            V = T.pickStrokeBuffer || C.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, F + V, $.dpr)),
            (ie = e.isPointInStroke(te.x, te.y)),
            ie
          );
        }
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ee && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ee),
      $.highPerformanceRestore(),
      ie
    );
  }
};
DefaultCanvasPathPicker = __decorate$7(
  [
    injectable(),
    __param$6(0, inject(PathRender)),
    __metadata$6("design:paramtypes", [Object]),
  ],
  DefaultCanvasPathPicker
);
let loadPathPick = !1;
const pathCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadPathPick ||
    ((loadPathPick = !0),
    e(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasPathPicker));
});
var __decorate$6 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$5 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$5 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPolygonPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "polygon"),
      (this.numberType = POLYGON_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.contains(T.x, T.y)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).polygon;
    let { x: V = F.x, y: Y = F.y } = e.attribute;
    if (($.highPerformanceSave(), e.transMatrix.onlyTranslate())) {
      const T = e.getOffsetXY(F);
      (V += T.x), (Y += T.y), $.setTransformForCurrent();
    } else (V = 0), (Y = 0), $.transformFromMatrix(e.transMatrix, !0);
    let K = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        V,
        Y,
        {},
        null,
        (e, C, $) => !!K || ((K = e.isPointInPath(T.x, T.y)), K),
        (e, C, F) => {
          if (K) return !0;
          const V = C.lineWidth || F.lineWidth,
            Y = C.pickStrokeBuffer || F.pickStrokeBuffer;
          return (
            ($.lineWidth = getScaledStroke($, V + Y, $.dpr)),
            (K = e.isPointInStroke(T.x, T.y)),
            K
          );
        }
      ),
      $.highPerformanceRestore(),
      K
    );
  }
};
DefaultCanvasPolygonPicker = __decorate$6(
  [
    injectable(),
    __param$5(0, inject(PolygonRender)),
    __metadata$5("design:paramtypes", [Object]),
  ],
  DefaultCanvasPolygonPicker
);
let loadPolygonPick = !1;
const polygonCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadPolygonPick ||
    ((loadPolygonPick = !0),
    e(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasPolygonPicker));
});
var __decorate$5 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$4 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$4 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasGlyphPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "glyph"),
      (this.numberType = GLYPH_NUMBER_TYPE);
  }
  contains(e, T, C) {
    if (!e.AABBBounds.containsPoint(T)) return !1;
    if ("imprecise" === e.attribute.pickMode) return !0;
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = null == C ? void 0 : C.pickerService;
    if (F) {
      let $ = !1;
      return (
        e.getSubGraphic().forEach((e) => {
          if ($) return;
          const V = F.pickItem(e, T, null, C);
          $ = !(!V || !V.graphic);
        }),
        $
      );
    }
    return !1;
  }
};
DefaultCanvasGlyphPicker = __decorate$5(
  [
    injectable(),
    __param$4(0, inject(GlyphRender)),
    __metadata$4("design:paramtypes", [Object]),
  ],
  DefaultCanvasGlyphPicker
);
let loadGlyphPick = !1;
const glyphCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadGlyphPick ||
    ((loadGlyphPick = !0),
    e(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasGlyphPicker));
});
var __decorate$4 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$3 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$3 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasRichTextPicker = class {
  constructor(e) {
    (this.canvasRenderer = e),
      (this.type = "richtext"),
      (this.numberType = RICHTEXT_NUMBER_TYPE);
  }
  contains(e, T, C) {
    return !!e.AABBBounds.containsPoint(T);
  }
};
DefaultCanvasRichTextPicker = __decorate$4(
  [
    injectable(),
    __param$3(0, inject(RichTextRender)),
    __metadata$3("design:paramtypes", [Object]),
  ],
  DefaultCanvasRichTextPicker
);
let loadRichtextPick = !1;
const richtextCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadRichtextPick ||
    ((loadRichtextPick = !0),
    e(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasRichTextPicker));
});
var __decorate$3 =
  (globalThis && globalThis.__decorate) ||
  function (e, T, C, $) {
    var F,
      V = arguments.length,
      Y =
        V < 3
          ? T
          : null === $
          ? ($ = Object.getOwnPropertyDescriptor(T, C))
          : $;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      Y = Reflect.decorate(e, T, C, $);
    else
      for (var K = e.length - 1; K >= 0; K--)
        (F = e[K]) && (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
    return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
  };
let DefaultCanvasImagePicker = class {
  constructor() {
    (this.type = "image"), (this.numberType = IMAGE_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    return !!$ && !!e.AABBBounds.containsPoint(T);
  }
};
DefaultCanvasImagePicker = __decorate$3(
  [injectable()],
  DefaultCanvasImagePicker
);
let loadImagePick = !1;
const imageCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadImagePick ||
    ((loadImagePick = !0),
    e(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasImagePicker));
});
var __decorate$2 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$2 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$2 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
new AABBBounds();
let DefaultCanvasRect3dPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "rect3d"),
      (this.numberType = RECT3D_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).rect;
    $.highPerformanceSave();
    const V = this.transform(e, F, $),
      { x: Y, y: K, z: J, lastModelMatrix: ee } = V;
    let te = T;
    if ($.camera) {
      te = T.clone();
      const C = e.parent.globalTransMatrix;
      (te.x = C.a * T.x + C.c * T.y + C.e),
        (te.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = J;
    let ie = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        Y,
        K,
        C,
        null,
        (e, T, C) => !!ie || ((ie = e.isPointInPath(te.x, te.y)), ie)
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ee && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ee),
      $.highPerformanceRestore(),
      ie
    );
  }
};
DefaultCanvasRect3dPicker = __decorate$2(
  [
    injectable(),
    __param$2(0, inject(Rect3DRender)),
    __metadata$2("design:paramtypes", [Object]),
  ],
  DefaultCanvasRect3dPicker
);
let loadRect3dPick = !1;
const rect3dCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadRect3dPick ||
    ((loadRect3dPick = !0),
    e(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasRect3dPicker));
});
var __decorate$1 =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata$1 =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param$1 =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasArc3dPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "arc3d"),
      (this.numberType = ARC3D_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).arc;
    $.highPerformanceSave();
    const V = this.transform(e, F, $),
      { x: Y, y: K, z: J, lastModelMatrix: ee } = V;
    let te = T;
    if ($.camera) {
      te = T.clone();
      const C = e.parent.globalTransMatrix;
      (te.x = C.a * T.x + C.c * T.y + C.e),
        (te.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = J;
    let ie = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        Y,
        K,
        C,
        null,
        (e, T, C) => !!ie || ((ie = e.isPointInPath(te.x, te.y)), ie)
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ee && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ee),
      $.highPerformanceRestore(),
      ie
    );
  }
};
DefaultCanvasArc3dPicker = __decorate$1(
  [
    injectable(),
    __param$1(0, inject(Arc3dRender)),
    __metadata$1("design:paramtypes", [Object]),
  ],
  DefaultCanvasArc3dPicker
);
let loadArc3dPick = !1;
const arc3dCanvasPickModule = new ContainerModule((e, T, C, $) => {
  loadArc3dPick ||
    ((loadArc3dPick = !0),
    e(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(),
    e(CanvasPickerContribution).toService(CanvasArc3dPicker));
});
var __decorate =
    (globalThis && globalThis.__decorate) ||
    function (e, T, C, $) {
      var F,
        V = arguments.length,
        Y =
          V < 3
            ? T
            : null === $
            ? ($ = Object.getOwnPropertyDescriptor(T, C))
            : $;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        Y = Reflect.decorate(e, T, C, $);
      else
        for (var K = e.length - 1; K >= 0; K--)
          (F = e[K]) &&
            (Y = (V < 3 ? F(Y) : V > 3 ? F(T, C, Y) : F(T, C)) || Y);
      return V > 3 && Y && Object.defineProperty(T, C, Y), Y;
    },
  __metadata =
    (globalThis && globalThis.__metadata) ||
    function (e, T) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(e, T);
    },
  __param =
    (globalThis && globalThis.__param) ||
    function (e, T) {
      return function (C, $) {
        T(C, $, e);
      };
    };
let DefaultCanvasPyramid3dPicker = class extends BasePicker {
  constructor(e) {
    super(),
      (this.canvasRenderer = e),
      (this.type = "pyramid3d"),
      (this.numberType = PYRAMID3D_NUMBER_TYPE);
  }
  contains(e, T, C) {
    const { pickContext: $ } = null != C ? C : {};
    if (!$) return !1;
    const F = getTheme(e).polygon;
    $.highPerformanceSave();
    const V = this.transform(e, F, $),
      { x: Y, y: K, z: J, lastModelMatrix: ee } = V;
    let te = T;
    if ($.camera) {
      te = T.clone();
      const C = e.parent.globalTransMatrix;
      (te.x = C.a * T.x + C.c * T.y + C.e),
        (te.y = C.b * T.x + C.d * T.y + C.f);
    }
    this.canvasRenderer.z = J;
    let ie = !1;
    return (
      this.canvasRenderer.drawShape(
        e,
        $,
        Y,
        K,
        {},
        null,
        (e, T, C) => !!ie || ((ie = e.isPointInPath(te.x, te.y)), ie),
        (e, T, C) => !1
      ),
      (this.canvasRenderer.z = 0),
      $.modelMatrix !== ee && mat4Allocate.free($.modelMatrix),
      ($.modelMatrix = ee),
      $.highPerformanceRestore(),
      ie
    );
  }
};
DefaultCanvasPyramid3dPicker = __decorate(
  [
    injectable(),
    __param(0, inject(Pyramid3dRender)),
    __metadata("design:paramtypes", [Object]),
  ],
  DefaultCanvasPyramid3dPicker
);
let loadPyramid3dPick = !1;
const pyramid3dCanvasPickModule = new ContainerModule((e, T, C, $) => {
    loadPyramid3dPick ||
      ((loadPyramid3dPick = !0),
      e(CanvasPyramid3dPicker)
        .to(DefaultCanvasPyramid3dPicker)
        .inSingletonScope(),
      e(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
  }),
  browser = isBrowserEnv();
function _registerArc() {
  _registerArc.__loaded ||
    ((_registerArc.__loaded = !0),
    registerArcGraphic(),
    container.load(arcModule),
    container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = !1;
const registerArc = _registerArc;
function _registerArc3d() {
  _registerArc3d.__loaded ||
    ((_registerArc3d.__loaded = !0),
    registerArc3dGraphic(),
    container.load(arc3dModule),
    container.load(arc3dCanvasPickModule));
}
_registerArc3d.__loaded = !1;
const registerArc3d = _registerArc3d;
function _registerArea() {
  _registerArea.__loaded ||
    ((_registerArea.__loaded = !0),
    registerAreaGraphic(),
    container.load(areaModule),
    container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = !1;
const registerArea = _registerArea;
function _registerCircle() {
  _registerCircle.__loaded ||
    ((_registerCircle.__loaded = !0),
    registerCircleGraphic(),
    container.load(circleModule),
    container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = !1;
const registerCircle = _registerCircle;
function _registerGlyph() {
  _registerGlyph.__loaded ||
    ((_registerGlyph.__loaded = !0),
    registerGlyphGraphic(),
    container.load(glyphModule),
    container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
}
_registerGlyph.__loaded = !1;
const registerGlyph = _registerGlyph;
function _registerGroup() {
  _registerGroup.__loaded ||
    ((_registerGroup.__loaded = !0), registerGroupGraphic());
}
_registerGroup.__loaded = !1;
const registerGroup = _registerGroup;
function _registerImage() {
  _registerImage.__loaded ||
    ((_registerImage.__loaded = !0),
    registerImageGraphic(),
    container.load(imageModule),
    container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = !1;
const registerImage = _registerImage;
function _registerLine() {
  _registerLine.__loaded ||
    ((_registerLine.__loaded = !0),
    registerLineGraphic(),
    container.load(lineModule),
    container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = !1;
const registerLine = _registerLine;
function _registerPath() {
  _registerPath.__loaded ||
    ((_registerPath.__loaded = !0),
    registerPathGraphic(),
    container.load(pathModule),
    container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = !1;
const registerPath = _registerPath;
function _registerPolygon() {
  _registerPolygon.__loaded ||
    ((_registerPolygon.__loaded = !0),
    registerPolygonGraphic(),
    container.load(polygonModule),
    container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = !1;
const registerPolygon = _registerPolygon;
function _registerPyramid3d() {
  _registerPyramid3d.__loaded ||
    ((_registerPyramid3d.__loaded = !0),
    registerPyramid3dGraphic(),
    container.load(pyramid3dModule),
    container.load(pyramid3dCanvasPickModule));
}
_registerPyramid3d.__loaded = !1;
const registerPyramid3d = _registerPyramid3d;
function _registerRect() {
  _registerRect.__loaded ||
    ((_registerRect.__loaded = !0),
    registerRectGraphic(),
    container.load(rectModule),
    container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = !1;
const registerRect = _registerRect;
function _registerRect3d() {
  _registerRect3d.__loaded ||
    ((_registerRect3d.__loaded = !0),
    registerRect3dGraphic(),
    container.load(rect3dModule),
    container.load(rect3dCanvasPickModule));
}
_registerRect3d.__loaded = !1;
const registerRect3d = _registerRect3d;
function _registerRichtext() {
  _registerRichtext.__loaded ||
    ((_registerRichtext.__loaded = !0),
    registerRichtextGraphic(),
    container.load(richtextModule),
    container.load(
      browser ? richtextCanvasPickModule : richTextMathPickModule
    ));
}
_registerRichtext.__loaded = !1;
const registerRichtext = _registerRichtext;
function _registerShadowRoot() {
  _registerShadowRoot.__loaded ||
    ((_registerShadowRoot.__loaded = !0), registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = !1;
const registerShadowRoot = _registerShadowRoot;
function _registerSymbol() {
  _registerSymbol.__loaded ||
    ((_registerSymbol.__loaded = !0),
    registerSymbolGraphic(),
    container.load(symbolModule),
    container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = !1;
const registerSymbol = _registerSymbol;
function _registerText() {
  _registerText.__loaded ||
    ((_registerText.__loaded = !0),
    registerTextGraphic(),
    container.load(textModule),
    container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = !1;
const registerText = _registerText;
function _registerWrapText() {
  _registerWrapText.__loaded ||
    ((_registerWrapText.__loaded = !0), registerWrapTextGraphic());
}
_registerWrapText.__loaded = !1;
const registerWrapText = _registerWrapText;
preLoadAllModule(),
  isBrowserEnv()
    ? loadBrowserEnv(container)
    : isNodeEnv() && loadNodeEnv(container),
  registerArc(),
  registerArc3d(),
  registerArea(),
  registerCircle(),
  registerGlyph(),
  registerGroup(),
  registerImage(),
  registerLine(),
  registerPath(),
  registerPolygon(),
  registerPyramid3d(),
  registerRect(),
  registerRect3d(),
  registerRichtext(),
  registerShadowRoot(),
  registerSymbol(),
  registerText(),
  registerWrapText();
const lineNumber = (e, T) => {
    var C, $, F, V, Y, K;
    const J = {
        ...e,
      },
      { vizData: ee, wholeData: te, containerSize: ie } = T,
      { displayConf: ne } = ee,
      { columns: re, records: ae } = J;
    if (re && ae && ne.lineNumber) {
      const {
        transpose: e,
        pagination: ee = !1,
        lineNumberHeader: oe = "",
        lineNumberFont: se,
        lineNumberFontWeight: le,
        lineNumberColor: de,
        lineNumberFontSize: ce,
        lineNumberIcon: ue = TableIconType.FLAG,
        lineNumberIconSize: he = 22,
        lineNumberIconColor: pe = "#EEB641",
        pageSize: ge = 10,
      } = ne;
      let fe = 0;
      if (ee) {
        const e = null != (C = null == T ? void 0 : T.page) ? C : 1;
        fe = ee ? (e - 1) * ge : 0;
      }
      const me = (ie.height / ge) * 0.9,
        ye = Math.min(he, me),
        be = {
          field: LINE_NUMBER_COL_NAME,
          title: intl.i18n`${oe}`,
          width: e
            ? null !=
              (V =
                null ==
                (F =
                  null == ($ = null == ne ? void 0 : ne.columnWidth)
                    ? void 0
                    : $.find((e) => "transpose" === e.key))
                  ? void 0
                  : F.value)
              ? V
              : "auto"
            : ("standard" === ne.display
                ? "auto"
                : null ==
                  (K =
                    null == (Y = null == ne ? void 0 : ne.columnWidth)
                      ? void 0
                      : Y.find((e) => e.key === LINE_NUMBER_COL_NAME))
                ? void 0
                : K.value) || `${LINE_NUMBER_WIDTH_PERCENT}%`,
          style: {
            fontFamily: se,
            fontWeight: le,
            fontSize: ce,
            color: de,
          },
          customLayout: (e) => {
            const { table: T, row: C, col: $, rect: F } = e,
              V = T.getCellOriginRecord($, C),
              { height: Y, width: K } = null != F ? F : T.getCellRect($, C),
              J = new Group$1({
                height: Y,
                width: K,
              });
            if (!0 === V[EMPTY_LINE_TAG])
              return {
                rootContainer: J,
                renderDefault: !1,
              };
            const ee = new Group$1({
              height: Y,
              width: K,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flexWrap: "nowrap",
              clip: !0,
            });
            J.add(ee);
            const te = new Group$1({
              height: ye,
              width: ye,
              clip: !0,
            });
            ee.add(te);
            const ie = createSymbol({
              size: ye,
              symbolType: V[LINE_NUMBER_ICON],
              fill: pe,
              dx: ye * iconOffset[ue],
              dy: ye * iconOffset[ue],
            });
            te.add(ie);
            const ne = new Group$1({
              height: Y,
              width: K,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flexWrap: "nowrap",
              clip: !0,
            });
            J.add(ne);
            const re = new Text$1({
              text: V[LINE_NUMBER_COL_NAME],
              fontFamily: se,
              fontWeight: le,
              fontSize: Number(ce),
              fill: de,
              textBaseline: "top",
              textAlign: "left",
            });
            return (
              ne.add(re),
              {
                rootContainer: J,
                renderDefault: !1,
              }
            );
          },
        };
      (J.columns = [be, ...re]),
        (J.records = ae.map((e, T) =>
          !0 == !e[EMPTY_LINE_TAG]
            ? {
                ...e,
                [LINE_NUMBER_COL_NAME]: T + fe + 1,
                [LINE_NUMBER_ICON]: iconSource[ue],
              }
            : e
        )),
        te.forEach((e, T) => {
          !0 == !e[EMPTY_LINE_TAG] &&
            ((e[LINE_NUMBER_COL_NAME] = T + fe + 1),
            (e[LINE_NUMBER_ICON] = iconSource[ue]));
        });
    }
    return J;
  },
  measureFirst = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      { displayConf: Y } = V,
      { columns: K } = F;
    if (K && Y.measureFirst) {
      const e = (
          null != ($ = null == (C = V.cells[0]) ? void 0 : C.column) ? $ : []
        ).filter((e) => {
          var T;
          return (
            (null == (T = V.fieldMap[e]) ? void 0 : T.location) ===
            Location.DIMENSION
          );
        }),
        T = [],
        Y = [];
      K.forEach((C) => {
        e.some((e) => e === C.field) ? T.push(C) : Y.push(C);
      }),
        (F.columns = [...Y, ...T]);
    }
    return F;
  };
var ColumnResizeMode = ((e) => (
  (e.ALL = "all"),
  (e.NONE = "none"),
  (e.HEADER = "header"),
  (e.BODY = "body"),
  e
))(ColumnResizeMode || {});
const initBasicInfo = (e, T) => {
    const C = {
      ...e,
    };
    return (
      C.columns && (C.columns = completedColumns(C.columns, T)),
      completedBasicOption(C, T)
    );
  },
  completedColumns = (e, T) => {
    const { vizData: C } = T,
      { fieldMap: $ } = C,
      { displayConf: F } = C,
      V = (e) => {
        const { field: T } = e,
          C = ((e) => {
            const { field: T } = e,
              C = $[T];
            return (null == C ? void 0 : C.role) === Role.DIMENSION;
          })(e);
        return C || T === LINE_NUMBER_COL_NAME
          ? F.alignDimension
          : F.alignMeasure;
      },
      { transpose: Y, display: K, lineNumber: J } = F,
      ee = [
        {
          key: "default",
          value: (J ? 100 - LINE_NUMBER_WIDTH_PERCENT : 100) / e.length + "%",
        },
        {
          key: LINE_NUMBER_COL_NAME,
          value: `${LINE_NUMBER_WIDTH_PERCENT}%`,
        },
      ],
      te = keyValuePairsToColumnWidthDict(
        null != ee ? ee : [...defaultConfig.columnWidth]
      );
    return e.map((e, T) => {
      var C, $;
      const { field: F } = e,
        J = V(e);
      return (
        (e.style = {
          ...(null != (C = e.style) ? C : {}),
          textAlign: J,
        }),
        (e.headerStyle = {
          ...(null != ($ = e.headerStyle) ? $ : {}),
          textAlign: J,
        }),
        Y ||
          (e.width =
            ("standard" === K ? "auto" : te[F]) || te.default || "auto"),
        e
      );
    });
  },
  completedBasicOption = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      {
        display: F,
        autoWrap: V = !1,
        columnWidth: Y,
        transpose: K = !1,
        pageSize: J,
        pagination: ee,
      } = $,
      te = keyValuePairsToColumnWidthDict(
        null != Y ? Y : [...defaultConfig.columnWidth]
      ),
      ie = K
        ? "adaptive" === F
          ? "adaptive"
          : "autoWidth"
        : "custom" === F
        ? "standard"
        : F,
      ne = K
        ? "adaptive" === F
          ? "adaptive"
          : "autoWidth"
        : "custom" === F
        ? "standard"
        : F;
    return {
      ...e,
      transpose: K,
      widthMode: ie,
      autoFillWidth: !(!K || "autoWidth" !== ie) || void 0,
      columnWidthComputeMode: K && "autoWidth" === ie ? "only-body" : void 0,
      columnResizeMode: K ? ColumnResizeMode.HEADER : ColumnResizeMode.ALL,
      heightMode: ne,
      heightAdaptiveMode: "all",
      autoFillHeight: !0,
      autoWrapText: V,
      maxCharactersNumber: 256,
      defaultHeaderColWidth: (K && (te.transpose || te.default)) || "auto",
      keyboardOptions: {
        selectAllOnCtrlA: !0,
        copySelected: !1,
      },
      menu: {
        renderMode: "html",
      },
      pagination: ee
        ? {
            currentPage: 0,
            perPageCount: J,
          }
        : void 0,
      customConfig: {
        _disableColumnAndRowSizeRound: !0,
        imageMargin: 4,
        multilinesForXTable: !0,
        shrinkSparklineFirst: !0,
        limitContentHeight: !V,
      },
    };
  },
  DEFAULT_LINE_COLOR = "rgba(46, 98, 241, 1)",
  DEFAULT_MAX_MARK_COUNT = 100,
  DEFAULT_SUB_TITLE_COLOR = "rgba(20, 20, 20, 0.45)",
  TREND_TABLE_LINEDATA = "__BYTECHARTS_TRENDTABLE_MINI_CHART_LINEDATA",
  TREND_TABLE_MINI_CHART_INDICATOR_NAME = "__BYTECHARTS_TRENDTABLE_MINI_CHART",
  getSparklineSpec = (e) => {
    const {
      xField: T,
      yField: C,
      lineColor: $,
      symbol: F = "all",
      enableSmooth: V = !1,
    } = e;
    return (e) => {
      const { row: Y, col: K, table: J } = e,
        ee = getOriginRecord(J, K, Y);
      return {
        type: "line",
        xField: T,
        yField: C,
        pointShowRule: F === LineSymbol.CIRCLE ? "all" : "isolatedPoint",
        line: {
          visible: !0,
          style: {
            stroke: $,
            strokeWidth: isCombined(ee) ? 3 : 2,
          },
        },
        point: {
          visible: !0,
          hover: {
            stroke: "white",
            strokeWidth: 1,
            fill: $,
            shape: "circle",
            size: 4,
          },
          style: {
            stroke: "white",
            strokeWidth: 1,
            fill: $,
            shape: "circle",
            size: 3,
          },
        },
        crosshair: {
          style: {
            stroke: "rgba(209, 213, 218, 1)",
            strokeWidth: 2,
          },
        },
        smooth: V ? "monotone" : void 0,
      };
    };
  },
  getTextProps = (e) => ({
    fontSize: null == e ? void 0 : e.fontSize,
    fontFamily: null == e ? void 0 : e.fontFamily,
    fontStyle: null == e ? void 0 : e.fontStyle,
    fontWeight: null == e ? void 0 : e.fontWeight,
  }),
  listTableMiniChart = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $ } = T,
      { displayConf: F } = $,
      { fieldMap: V } = $,
      { hideHeader: Y } = F,
      { alignMeasure: K } = F,
      { records: J } = C,
      ee = !Y;
    return C.columns && J
      ? ((C.columns = C.columns.map((e) => {
          var T, C, Y, te, ie, ne;
          const re = {
              ...e,
            },
            { field: ae } = re,
            oe = V[ae].miniChart,
            se = V[ae].alias;
          if (!V[ae] || !oe) return re;
          const le = oe.dimensions[0],
            de = oe.measures[0],
            ce = {
              ...F,
              ...(null !=
              (C = null == (T = $.fieldMap[ae]) ? void 0 : T.headerStyle)
                ? C
                : {}),
            },
            { columnWidth: ue } = F,
            he = getHeaderStyle(ce),
            pe = getSubHeaderStyle(ce);
          let ge = "",
            fe = "";
          J.forEach((e) => {
            var T;
            (null == (T = e[ae]) ? void 0 : T.length)
              ? (e[ae].length - DEFAULT_MAX_MARK_COUNT >= 0 &&
                  (e[ae] = e[ae].slice(
                    e[ae].length - DEFAULT_MAX_MARK_COUNT,
                    e[ae].length
                  )),
                (ge = e[ae][0][le]),
                (fe = e[ae][e[ae].length - 1][le]))
              : (e[ae] = []);
          }),
            (re.title = se),
            (re.cellType = ColumnType.Sparkline);
          const me =
              null !=
              (te =
                null == (Y = null == oe ? void 0 : oe.style)
                  ? void 0
                  : Y.lineColor)
                ? te
                : DEFAULT_LINE_COLOR,
            ye = keyValuePairsToColumnWidthDict(
              null != ue ? ue : [...defaultConfig.columnWidth]
            );
          re.headerCustomRender = (e) => {
            var T, C, $, Y, J, ee;
            const { table: te, rect: ie } = e,
              { width: ne = 0 } = null != ie ? ie : {},
              [re, oe, se, de] = getTableCellPadding(F),
              ue =
                null != (C = null == (T = V[ae]) ? void 0 : T.alias) ? C : "",
              me = `${null != ($ = V[le].alias) ? $ : ""}: ${ge}-${fe}`,
              be = getMaxTextWidth(te, [
                {
                  text: null != ue ? ue : "",
                  attribute: getTextProps(he),
                },
                {
                  text: null != me ? me : "",
                  attribute: getTextProps(pe),
                },
              ]);
            let ve = -1;
            const Te = F.autoWrap;
            ve =
              "standard" === F.display ||
              ("auto" === ye[ae] && "adaptive" !== F.display)
                ? be
                : ne - de - oe;
            const _e = [];
            let Ce = re;
            const Ae = {
                type: "text",
                fill: ce.headerFontColor,
                fontSize: null == he ? void 0 : he.fontSize,
                fontFamily: null == he ? void 0 : he.fontFamily,
                fontStyle: null == he ? void 0 : he.fontStyle,
                fontWeight: "bold",
                textBaseline: "top",
                textAlign: "auto" === K ? "left" : K,
                maxLineWidth: ve,
                lineHeight:
                  (null != (Y = null == he ? void 0 : he.fontSize) ? Y : 12) +
                  2,
                text: Te ? [ue] : ue,
                wrap: Te,
                underline: ce.headerFontUnderline,
                wordBreak: "break-word",
              },
              xe = {
                type: "text",
                color:
                  null != (J = ce.headerSubTitleFontColor)
                    ? J
                    : DEFAULT_SUB_TITLE_COLOR,
                fontSize: null == pe ? void 0 : pe.fontSize,
                fontFamily: null == pe ? void 0 : pe.fontFamily,
                fontStyle: null == pe ? void 0 : pe.fontStyle,
                textAlign: "auto" === K ? "left" : K,
                textBaseline: "top",
                maxLineWidth: ve,
                lineHeight:
                  null != (ee = null == pe ? void 0 : pe.fontSize) ? ee : 12,
                text: Te ? [me] : me,
                wrap: Te,
                wordBreak: "break-word",
              },
              Se = {
                ...te.measureTextBounds(Ae),
              },
              Re = {
                ...te.measureTextBounds(xe),
              };
            return (
              _e.push({
                ...Ae,
                x: getTextX(F, ve, de),
                y: Ce,
              }),
              (Ce += Se.y2 - Se.y1),
              (Ce += 6),
              _e.push({
                ...xe,
                x: getTextX(F, ve, de),
                y: Ce,
              }),
              (Ce += Re.y2 - Re.y1),
              {
                elements: _e,
                expectedHeight: Math.ceil(Ce + se),
                expectedWidth: Math.ceil(be + de + oe),
              }
            );
          };
          const be = getSparklineSpec({
            lineColor: me,
            enableSmooth: null == (ie = oe.style) ? void 0 : ie.smooth,
            symbol: null == (ne = oe.style) ? void 0 : ne.symbol,
            xField: le.toString(),
            yField: de.toString(),
          });
          return (
            (re.sparklineSpec = be),
            "auto" !== re.width || ee || (re.width = "200"),
            re
          );
        })),
        C)
      : C;
  },
  getTextX = (e, T, C) =>
    "left" === e.alignMeasure
      ? C
      : "center" === e.alignMeasure
      ? C + T / 2
      : C + T,
  getMaxTextWidth = (e, T) => {
    const C = T.map((T) => e.measureText(T.text, T.attribute).width);
    return Math.max(...C);
  },
  OKRMiniChart = (e, T) => {
    var C, $, F, V, Y, K, J;
    const { vizData: ee } = T,
      { displayConf: te } = ee,
      { cells: ie } = ee,
      { miniChart: ne, headerHorizontal: re } = te;
    if (!(null == ne ? void 0 : ne.enabled)) return e;
    const ae =
        (null == (C = null == ne ? void 0 : ne.style) ? void 0 : C.lineColor) ||
        DEFAULT_LINE_COLOR,
      { columnTree: oe, indicators: se } = e,
      le = oe.map((e) =>
        "mini_chart" === e.value
          ? {
              ...e,
              children: [
                {
                  indicatorKey: "OKR_TABLE_MINI_CHART_LINE_DATA",
                },
              ],
            }
          : e
      ),
      de =
        null ==
        ($ = Object.values(ee.fieldMap).find(
          (e) => e.location === Location.COLUMN
        ))
          ? void 0
          : $.id,
      ce = getPivotTableCellPadding(te),
      ue = {
        cellType: "sparkline",
        indicatorKey: "OKR_TABLE_MINI_CHART_LINE_DATA",
        width: re ? "auto" : "255px",
        maxWidth: "255px",
        pointShowRule: "none",
        smooth: !0,
        style: {
          lineHeight: 40 - ce[0] - ce[2],
        },
        title: null != (F = null == ne ? void 0 : ne.chartName) ? F : "",
        sparklineSpec: {
          type: "line",
          xField: de,
          yField:
            null == (Y = null == (V = ie[0]) ? void 0 : V.foldInfo)
              ? void 0
              : Y.value,
          pointShowRule:
            (null == (K = null == ne ? void 0 : ne.style)
              ? void 0
              : K.symbol) === LineSymbol.CIRCLE
              ? "all"
              : "isolatedPoint",
          line: {
            visible: !0,
            style: {
              stroke: ae,
              strokeWidth: 2,
            },
          },
          smooth: (
            null == (J = null == ne ? void 0 : ne.style) ? void 0 : J.smooth
          )
            ? "monotone"
            : void 0,
          point: {
            visible: !0,
            style: {
              stroke: "white",
              strokeWidth: 1,
              fill: ae,
              shape: "circle",
              size: 3,
            },
            hover: {
              fill: ae,
              size: 4,
            },
          },
          crosshair: {
            style: {
              stroke: "rgba(209, 213, 218, 1)",
              strokeWidth: 2,
            },
          },
        },
      };
    return {
      ...e,
      columnTree: le,
      indicators: [...se, ue],
    };
  },
  checkEnablePresetsByVizData = (e) => {
    var T, C;
    return null == (C = null == (T = e.displayConf) ? void 0 : T.periodCompare)
      ? void 0
      : C.usePeriod;
  },
  getLastDateValues = (e) => {
    var T;
    const { dateInfo: C } = null != (T = e.other) ? T : {};
    let $ = [];
    return (
      C &&
        ($ = Object.values(C)
          .map((e) => lodash.exports.last(e || []))
          .filter(Boolean)),
      $
    );
  },
  generateBorderLineByValue = (e, T) =>
    (null == e ? void 0 : e.length) && T
      ? (null == e ? void 0 : e.includes(T))
        ? [0, 1, 1, 0]
        : [0, 0, 1, 0]
      : [1, 1, 1, 1],
  getDefaultRatioFormat = (e) => {
    var T;
    return {
      type:
        "ratio" ===
        (null == (T = e.displayConf.periodCompare) ? void 0 : T.calculateType)
          ? FormatType.PERCENT
          : FormatType.DIGIT,
      precision: 2,
      precisionType: PrecisionType.DECIMAL_DIGITS,
    };
  },
  getPeriodCondition = (e) => {
    const { periodCompare: T } = e.displayConf;
    if (null == T ? void 0 : T.usePeriod) {
      return PeriodConditionList.find((e) => e.key === T.conditionalFormat);
    }
    return null;
  },
  getConditionIndexByValue = (e) => (e ? (e > 0 ? 0 : e < 0 ? 2 : 0) : 1),
  getDimDateUniqueId = (e) => {
    var T, C;
    const { column: $ } =
      (null == (T = null == e ? void 0 : e.cells) ? void 0 : T[0]) || [];
    return null != (C = null == $ ? void 0 : $[0]) ? C : "";
  },
  trendMiniChart = (e, T) => {
    var C, $, F, V, Y, K, J;
    const { vizData: ee } = T,
      { displayConf: te } = ee,
      { miniChart: ie, alignDimensionColumn: ne, headerHorizontal: re } = te;
    if (!(null == ie ? void 0 : ie.enabled)) return e;
    const ae = {
        ...e,
      },
      { fieldMap: oe, other: se, cells: le } = ee,
      de = getDimDateUniqueId(ee),
      ce =
        (null == (C = null == ie ? void 0 : ie.style) ? void 0 : C.lineColor) ||
        DEFAULT_LINE_COLOR;
    ae.columns =
      null == ($ = ae.columns)
        ? void 0
        : $.map((e) => {
            if ("string" == typeof e) return e;
            const T = {
              ...e,
            };
            return (
              T.dimensionKey !== de ||
                (T.headerCustomRender = (e) => {
                  var T, C, $, F;
                  const { table: V, rect: Y, dataValue: K } = e,
                    { width: J = 0 } = null != Y ? Y : {};
                  if (K !== TREND_TABLE_MINI_CHART_INDICATOR_NAME)
                    return {
                      elements: [],
                      renderDefault: !0,
                    };
                  let re = -1;
                  const ae = {
                      headerFontBold: !0,
                      headerSubTitleFontBold: !1,
                      headerSubTitleFontSize: 12,
                      ...ee.displayConf,
                      ...(null !=
                      (C =
                        null == (T = ee.fieldMap[de]) ? void 0 : T.headerStyle)
                        ? C
                        : {}),
                    },
                    le = getHeaderStyle(ae),
                    ce = getSubHeaderStyle(ae),
                    ue = (null == se ? void 0 : se.miniChartDateRange) || [],
                    he = ue[0],
                    pe = lodash.exports.last(ue),
                    [ge, fe, me, ye] = getPivotTableCellPadding(te),
                    be = `${null != ($ = oe[de].alias) ? $ : ""}: ${he || ""}-${
                      pe || he || ""
                    }`,
                    ve =
                      null != (F = null == ie ? void 0 : ie.chartName) ? F : "",
                    Te = [ve],
                    _e = [be];
                  re = Math.max(
                    re,
                    V.measureText(ve, getTextProps(le)).width,
                    V.measureText(be, getTextProps(ce)).width
                  );
                  const Ce = [],
                    Ae = (e) =>
                      "left" === ne
                        ? ye
                        : "right" === ne
                        ? J - e - fe
                        : (J - e) / 2;
                  let xe = ge;
                  return (
                    Te.forEach((e) => {
                      const T = V.measureText(e, getTextProps(le)),
                        C = {
                          type: "text",
                          fill: ae.headerFontColor,
                          fontSize: null == le ? void 0 : le.fontSize,
                          fontFamily: null == le ? void 0 : le.fontFamily,
                          fontStyle: null == le ? void 0 : le.fontStyle,
                          fontWeight: "bold",
                          textBaseline: "top",
                          text: e,
                          x: Ae(T.width),
                          y: xe,
                        };
                      Ce.push(C), (xe += T.height + 6);
                    }),
                    _e.forEach((e) => {
                      var T;
                      const C = V.measureText(
                          e,
                          getTextProps({
                            ...ce,
                          })
                        ),
                        $ = {
                          type: "text",
                          fill:
                            null != (T = ae.headerSubTitleFontColor)
                              ? T
                              : DEFAULT_SUB_TITLE_COLOR,
                          fontSize: null == ce ? void 0 : ce.fontSize,
                          fontFamily: null == ce ? void 0 : ce.fontFamily,
                          fontStyle: null == ce ? void 0 : ce.fontStyle,
                          fontWeight: "bold",
                          textBaseline: "top",
                          text: e,
                          x: Ae(C.width),
                          y: xe,
                        };
                      Ce.push($), (xe += C.height + 6 - 2);
                    }),
                    {
                      elements: Ce,
                      expectedHeight: Math.ceil(xe - 6 + me),
                      expectedWidth: Math.ceil(Math.max(re + ye + fe, 255)),
                    }
                  );
                }),
              T
            );
          });
    const ue = {
      cellType: ColumnType.Sparkline,
      indicatorKey: TREND_TABLE_LINEDATA,
      title: null == ie ? void 0 : ie.chartName,
      disableColumnResize: !0,
      width: re ? "auto" : "255px",
      maxWidth: "255px",
      style: {
        padding: [10, 16, 10, 16],
      },
      sparklineSpec: {
        type: "line",
        xField: de,
        yField:
          null == (V = null == (F = le[0]) ? void 0 : F.foldInfo)
            ? void 0
            : V.key,
        pointShowRule:
          (null == (Y = null == ie ? void 0 : ie.style) ? void 0 : Y.symbol) ===
          LineSymbol.CIRCLE
            ? "all"
            : "isolatedPoint",
        smooth: !!(null == (K = null == ie ? void 0 : ie.style)
          ? void 0
          : K.smooth),
        line: {
          visible: !0,
          style: {
            stroke: ce,
            strokeWidth: 2,
          },
        },
        point: {
          visible: !0,
          style: {
            stroke: "white",
            strokeWidth: 1,
            fill: ce,
            shape: "circle",
            size: 3,
          },
          hover: {
            shape: "circle",
            fill: ce,
            size: 4,
          },
        },
        crosshair: {
          style: {
            stroke: "rgba(209, 213, 218, 1)",
            strokeWidth: 2,
          },
        },
      },
    };
    return null == (J = ae.indicators) || J.push(ue), ae;
  },
  miniChart = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? isOKRTable(T.vizData)
        ? OKRMiniChart(e, T)
        : isTrendTable(T.vizData)
        ? trendMiniChart(e, T)
        : e
      : listTableMiniChart(e, T);
var TableColumnDataType = ((e) => (
  (e.DIMENSION = "dimension"),
  (e.MEASURE = "measure"),
  (e.LINE_NUMBER = "line_number"),
  (e.RAW = "raw"),
  (e.AGGR = "aggr"),
  (e.PERIODCMP = "period_compare"),
  (e.COMPARE = "compare"),
  (e.PERCENT = "percent"),
  (e.PLACEHOLDER = "placeholder"),
  (e.CALCULATION = "calc"),
  (e.FORECAST = "forecast"),
  e
))(TableColumnDataType || {});
const popupMenu = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      { headerMenu: F, sortable: V, fixedIndex: Y, transpose: K } = $,
      J =
        !1 !== F
          ? completedSort(
              {
                ...e,
              },
              T
            )
          : {
              ...e,
            };
    return (
      V && (J.sortState = sortState(C)),
      (J.frozenColCount = void 0 !== Y && Y >= 0 ? (K ? 0 : Y + 1) : 0),
      J
    );
  },
  completedSort = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      { displayConf: Y } = V,
      { fieldMap: K } = V,
      { fixedIndex: J } = Y,
      ee = V.sort,
      te = null != (C = e.columns) ? C : [];
    te.forEach((e) => {
      var T, C;
      const { field: $ } = e,
        F = [],
        Y = K[$],
        J = (null != (T = Y.sourceType) ? T : Y.location === Location.DIMENSION)
          ? TableColumnDataType.DIMENSION
          : TableColumnDataType.MEASURE;
      if (LINE_NUMBER_COL_NAME === $) F.push(headerMenuItemKey.MENU_FROZEN_COL);
      else {
        (null == (C = V.other) ? void 0 : C.disableSort) ||
          void 0 === J ||
          TableColumnDataType.CALCULATION === J ||
          Y.disableSort ||
          Y.disabledChartSortByServerDataSetsConfigure ||
          F.push(
            headerMenuItemKey.MENU_SORT_DESC,
            headerMenuItemKey.MENU_SORT_ASC
          ),
          F.push(headerMenuItemKey.MENU_FROZEN_COL);
        const { customMenu: e = [] } = Y;
        e && F.push(...e);
      }
      e.dropDownMenu = getDropDownMenu$1(V, F);
    });
    const ie = [];
    return (
      ee &&
        ee.length > 0 &&
        te.forEach((e) => {
          const { field: T } = e,
            C = ee.find((e) => e.id === T);
          C &&
            [Order.ASC, Order.DESC].includes(C.order) &&
            ie.push({
              menuKey:
                C.order === Order.ASC
                  ? headerMenuItemKey.MENU_SORT_ASC
                  : headerMenuItemKey.MENU_SORT_DESC,
              field: e.field,
            });
        }),
      void 0 !== J &&
        J >= 0 &&
        (null == ($ = te[J]) ? void 0 : $.field) &&
        ie.push({
          menuKey: headerMenuItemKey.MENU_FROZEN_COL,
          field: null == (F = te[J]) ? void 0 : F.field,
        }),
      (e.menu = {
        ...e.menu,
        dropDownMenuHighlight: ie,
      }),
      e
    );
  },
  getDropDownMenu$1 = (e, T) => {
    const { displayConf: C } = e;
    return T.map((e) => {
      var T, $;
      return e === headerMenuItemKey.MENU_SORT_ASC
        ? {
            text: intl.i18n``,
            menuKey: e,
            icon: {
              svg: IconSortAsc({
                width: "15",
                height: "15",
                color: "currentColor",
              }),
            },
            selectedIcon: {
              svg: IconSortAsc({
                width: "15",
                height: "15",
                color: "currentColor",
              }),
            },
            stateIcon: {
              svg: IconHeaderSortAsc({
                width: 1.5 * C.headerFontSize,
                height: 1.5 * C.headerFontSize,
                color: null != (T = C.headerFontColor) ? T : "currentColor",
              }),
              width: 1.5 * C.headerFontSize,
              height: 1.5 * C.headerFontSize,
            },
          }
        : e === headerMenuItemKey.MENU_SORT_DESC
        ? {
            text: intl.i18n``,
            menuKey: e,
            icon: {
              svg: IconSortDesc({
                width: "15",
                height: "15",
                color: "currentColor",
              }),
            },
            selectedIcon: {
              svg: IconSortDesc({
                width: "15",
                height: "15",
                color: "currentColor",
              }),
            },
            stateIcon: {
              svg: IconHeaderSortDesc({
                width: 1.5 * C.headerFontSize,
                height: 1.5 * C.headerFontSize,
                color: null != ($ = C.headerFontColor) ? $ : "currentColor",
              }),
              width: 1.5 * C.headerFontSize,
              height: 1.5 * C.headerFontSize,
            },
          }
        : e === headerMenuItemKey.MENU_FROZEN_COL
        ? {
            text: intl.i18n``,
            menuKey: headerMenuItemKey.MENU_FROZEN_COL,
            icon: {
              svg: IconFrozenCol({
                width: "16",
                height: "16",
                color: "currentColor",
              }),
            },
            selectedIcon: {
              svg: IconFrozenCol({
                width: "16",
                height: "16",
                color: "currentColor",
              }),
            },
          }
        : e === headerMenuItemKey.MENU_DIMMET_INFO
        ? {
            text: intl.i18n``,
            menuKey: headerMenuItemKey.MENU_DIMMET_INFO,
          }
        : e === headerMenuItemKey.MENU_NUM_FORMAT
        ? {
            text: intl.i18n``,
            menuKey: headerMenuItemKey.MENU_NUM_FORMAT,
          }
        : e === headerMenuItemKey.MENU_VISUAL_STYLE
        ? {
            text: intl.i18n``,
            menuKey: headerMenuItemKey.MENU_VISUAL_STYLE,
          }
        : {};
    });
  },
  sortState = (e) => {
    if (!e.sort || 0 === e.sort.length) return [];
    const T = e.sort,
      C = [];
    return (
      T.forEach((e) => {
        var T, $;
        const F = [Order.ASC, Order.DESC].includes(e.order) ? e.order : null;
        F &&
          C.push({
            order: F,
            field:
              null != ($ = e.id) ? $ : null == (T = e.path) ? void 0 : T.field,
          });
      }),
      C
    );
  },
  listTableStratify = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      { displayConf: Y } = V,
      { fieldGroups: K, locationMap: J } = V,
      { dimension: ee = [], measure: te = [] } = J,
      { columns: ie } = F;
    if (
      !0 !== Y.fieldTree ||
      lodash.exports.isNil(K) ||
      lodash.exports.isNil(ie) ||
      0 === K.length ||
      0 === (null == ie ? void 0 : ie.length) ||
      0 === (null == te ? void 0 : te.length)
    )
      return e;
    const ne =
        null != (C = ie.filter((e) => -1 !== ee.indexOf(e.field))) ? C : [],
      re = null != ($ = ie.filter((e) => -1 !== te.indexOf(e.field))) ? $ : [],
      ae = getGroupStyle(Y),
      oe = (e) =>
        e
          .map((e) =>
            !0 !== e.isGroup
              ? re.find((T) => T.field === e.field)
              : {
                  field: e.field,
                  title: e.title,
                  columns: oe(e.children),
                  headerStyle: ae,
                }
          )
          .filter(Boolean);
    return (F.columns = [...ne, ...oe(null != K ? K : [])]), F;
  },
  getGroupStyle = (e) => {
    const T = e.alignMeasure;
    return {
      ...getHeaderStyle(e),
      textAlign: T,
    };
  },
  OKRPosition = "rowTree",
  getColumnOrRowsGroups$1 = (e, T, C, $, F, V, Y) => {
    const { columnTree: K, rowTree: J } = e;
    let ee;
    loopLayoutColumnsOrRows(
      "columnTree" === V ? K : J,
      (e, T, C) =>
        !(ee || !C.length || !C.every((e) => e.dimensionKey === F)) &&
        ((ee = e.children), !0)
    );
    const te = (e, $) =>
      e.map((e) => {
        if (!1 === e.isGroup) {
          const C = [...T].find((T) => T.indicatorKey === e.field);
          return {
            dimensionKey: F,
            value: null == C ? void 0 : C.value,
            children: ee,
          };
        }
        {
          const T = te(e.children, $ + 1);
          return {
            dimensionKey: C.get($),
            value: e.title,
            children: T.filter((e) => lodash.exports.isNil(e.indicatorKey)),
            indicatorKey: void 0,
            hierarchyState: e.autoExpand ? "expand" : "collapse",
          };
        }
      });
    return te($, 0);
  },
  completeLayoutColumnsOrRows$1 = (e, T, C, $, F, V) => {
    const Y = getColumnOrRowsGroups$1(e, T, C, $, F, OKRPosition);
    let K = lodash.exports.cloneDeep(e[OKRPosition]);
    return (
      K.every((e) => e.dimensionKey === F)
        ? (K = Y)
        : loopLayoutColumnsOrRows(
            K,
            (e) =>
              !(
                !Array.isArray(e.children) ||
                !e.children.every((e) => e.dimensionKey === F)
              ) && ((e.children = Y), !0)
          ),
      {
        [OKRPosition]: K,
      }
    );
  },
  OKRStratify = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      { fieldGroups: Y, cells: K } = V,
      { displayConf: J } = V,
      { fieldTree: ee, rowHeaderWidth: te } = J,
      { records: ie } = F,
      ne = K[0],
      { foldInfo: re } = ne;
    if (
      !0 !== ee ||
      lodash.exports.isNil(ie) ||
      lodash.exports.isNil(Y) ||
      0 === Y.length
    )
      return F;
    const ae = "rows",
      oe = "rowTree",
      se = getFields(V, Location.MEASURE, isRenderField).map((e) => {
        var T, C;
        return {
          indicatorKey: e,
          value:
            null != (C = null == (T = V.fieldMap[e]) ? void 0 : T.alias)
              ? C
              : "",
        };
      }),
      le = getFieldGroupLevelDimensions(Y),
      de = completeDimensions(
        le,
        F[ae],
        te,
        null == re ? void 0 : re.key,
        !1,
        !0
      ),
      ce = completeRecords(le, Y, ie, null == re ? void 0 : re.key),
      ue = completeLayoutColumnsOrRows$1(
        e,
        se,
        le,
        Y,
        null != ($ = null == re ? void 0 : re.key)
          ? $
          : null == (C = ne.value)
          ? void 0
          : C[0],
        null == T ? void 0 : T.isInitial
      );
    return {
      ...e,
      [ae]: de,
      [oe]: ue[oe],
      records: ce,
    };
  },
  pivotTableStratify = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      { fieldGroups: Y, cells: K } = V,
      { displayConf: J } = V,
      { fieldTree: ee, rowHeaderWidth: te } = J,
      { records: ie } = F,
      ne = K[0],
      { foldInfo: re } = ne;
    if (
      !0 !== ee ||
      lodash.exports.isNil(ie) ||
      lodash.exports.isNil(Y) ||
      0 === Y.length
    )
      return F;
    const ae = getMeasurePosition(V),
      oe = "rows" === ae ? "rowTree" : "columnTree",
      se = getFieldGroupLevelDimensions(Y),
      le = completeRecords(se, Y, ie, null == re ? void 0 : re.key),
      de = completeDimensions(se, F[ae], te, null == re ? void 0 : re.key),
      ce = completeTree(
        F,
        se,
        Y,
        null != ($ = null == re ? void 0 : re.key)
          ? $
          : null == (C = ne.value)
          ? void 0
          : C[0],
        oe
      );
    return (
      (F.records = le),
      (F[ae] = de),
      (F[oe] = ce),
      (F.defaultHeaderColWidth = null != te ? te : "auto"),
      F
    );
  },
  TrendPosition = "rowTree",
  getColumnOrRowsGroups = (e, T, C, $, F, V, Y) => {
    const { columnTree: K, rowTree: J } = e;
    let ee;
    loopLayoutColumnsOrRows(
      "columnTree" === V ? K : J,
      (e, T, C) =>
        !(ee || !C.length || !C.every((e) => e.dimensionKey === F)) &&
        ((ee = e.children), !0)
    );
    const te = (e, $) =>
      e.map((e) => {
        if (!1 === e.isGroup) {
          const C = [...T].find((T) => T.indicatorKey === e.field);
          return {
            dimensionKey: F,
            value: null == C ? void 0 : C.value,
            children: ee,
          };
        }
        {
          const T = te(e.children, $ + 1);
          return {
            dimensionKey: C.get($),
            value: e.title,
            children: T.filter((e) => lodash.exports.isNil(e.indicatorKey)),
            indicatorKey: void 0,
            hierarchyState: e.autoExpand ? "expand" : "collapse",
          };
        }
      });
    return te($, 0);
  },
  completeLayoutColumnsOrRows = (e, T, C, $, F, V) => {
    const Y = getColumnOrRowsGroups(e, T, C, $, F, TrendPosition);
    let K = lodash.exports.cloneDeep(e[TrendPosition]);
    return (
      K.every((e) => e.dimensionKey === F)
        ? (K = Y)
        : loopLayoutColumnsOrRows(
            K,
            (e) =>
              !(
                !Array.isArray(e.children) ||
                !e.children.every((e) => e.dimensionKey === F)
              ) && ((e.children = Y), !0)
          ),
      {
        [TrendPosition]: K,
      }
    );
  },
  trendTableStratify = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      { fieldGroups: Y, cells: K } = V,
      { displayConf: J } = V,
      { fieldTree: ee, rowHeaderWidth: te } = J,
      { records: ie } = F,
      ne = K[0],
      { foldInfo: re } = ne;
    if (
      !0 !== ee ||
      lodash.exports.isNil(ie) ||
      lodash.exports.isNil(Y) ||
      0 === Y.length
    )
      return F;
    const ae = "rows",
      oe = "rowTree",
      se = getFields(V, Location.MEASURE, isRenderField).map((e) => {
        var T, C;
        return {
          indicatorKey: e,
          value:
            null != (C = null == (T = V.fieldMap[e]) ? void 0 : T.alias)
              ? C
              : "",
        };
      }),
      le = getFieldGroupLevelDimensions(Y),
      de = completeDimensions(
        le,
        F[ae],
        te,
        null == re ? void 0 : re.key,
        !0,
        !1
      ),
      ce = completeRecords(le, Y, ie, null == re ? void 0 : re.key),
      ue = completeLayoutColumnsOrRows(
        e,
        se,
        le,
        Y,
        null != ($ = null == re ? void 0 : re.key)
          ? $
          : null == (C = ne.value)
          ? void 0
          : C[0],
        null == T ? void 0 : T.isInitial
      );
    return {
      ...e,
      [ae]: de,
      [oe]: ue[oe],
      records: ce,
    };
  },
  stratify = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? isOKRTable(T.vizData)
        ? OKRStratify(e, T)
        : isTrendTable(T.vizData)
        ? trendTableStratify(e, T)
        : pivotTableStratify(e, T)
      : listTableStratify(e, T),
  textContent = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? pivotTableTextContext(e, T)
      : listTableTextContent(e, T),
  listTableTextContent = (e, T) => {
    const C = {
        ...e,
      },
      { vizData: $ } = T,
      { displayConf: F } = $,
      { alignMeasure: V } = F,
      { columns: Y } = e;
    return (
      (C.columns = Y.map((e) => {
        const T = {
            ...e,
          },
          { field: C } = T,
          F = $.fieldMap[C];
        if (F && F.contentFormat) {
          const { contentType: e } = F.contentFormat;
          switch (e) {
            case ContentType.IMG:
              (T.cellType = ColumnType.Image), (T.keepAspectRatio = !0);
              break;
            case ContentType.VIDEO:
              (T.cellType = ColumnType.Video), (T.keepAspectRatio = !0);
              break;
            case ContentType.GOTO:
              (T.cellType = ColumnType.Link),
                (T.linkDetect = !1),
                (T.linkJump = !1);
              break;
            case ContentType.LINK:
              (T.cellType = ColumnType.Link),
                (T.linkDetect = !0),
                (T.linkJump = !0);
              break;
            case ContentType.TEMPLATE_LINK:
              (T.cellType = ColumnType.Link),
                (T.linkJump = !1),
                (T.linkDetect = !1);
              break;
            case ContentType.CONTENT:
              break;
            case ContentType.CONFIDENCE_INTERVAL: {
              const e = (e) => {
                var T;
                const C =
                  null != (T = null == e ? void 0 : e.split("/")) ? T : [];
                let $ = parseFloat(C[0]),
                  F = parseFloat(C[1]);
                return ($ = isNaN($) ? 0 : $), (F = isNaN(F) ? 0 : F), [$, F];
              };
              (T.fieldFormat = (T) => {
                const $ = e(T[C]),
                  F = (e) => {
                    const T = parseFloat(e);
                    return isNaN(T) ? e : `${(100 * T).toFixed(2)}%`;
                  };
                return `[${F($[0])}, ${F($[1])}]`;
              }),
                (T.style = {
                  ...T.style,
                  textAlign: V,
                  bgColor: (T) => {
                    const { dataValue: C } = T,
                      $ = e(C);
                    let F;
                    return (
                      $[0] > 0 && (F = "#e0f7c987"),
                      $[1] < 0 && (F = "#f5d5d38c"),
                      F
                    );
                  },
                });
              break;
            }
            case ContentType.TEXT:
          }
        }
        return T;
      })),
      C
    );
  },
  pivotTableTextContext = (e, T) => {
    var C, $;
    const F = {
        ...e,
      },
      { vizData: V } = T,
      Y = (e) => {
        const T = {
            ...e,
          },
          C = V.fieldMap[T.dimensionKey];
        if (C && C.contentFormat) {
          const { contentType: e } = C.contentFormat;
          switch (e) {
            case ContentType.IMG:
              (T.headerType = "image"),
                (T.keepAspectRatio = !0),
                (T.imageAutoSizing = !1);
              break;
            case ContentType.VIDEO:
              (T.headerType = "video"),
                (T.keepAspectRatio = !0),
                (T.imageAutoSizing = !1);
              break;
            case ContentType.GOTO:
              (T.headerType = "link"), (T.linkDetect = !1), (T.linkJump = !1);
              break;
            case ContentType.LINK:
              (T.headerType = "link"), (T.linkDetect = !0), (T.linkJump = !1);
              break;
            case ContentType.TEMPLATE_LINK:
              (T.headerType = "link"), (T.linkJump = !1), (T.linkDetect = !1);
            case ContentType.TEXT:
          }
        }
        return T;
      };
    return (
      (F.rows = null == (C = F.rows) ? void 0 : C.map(Y)),
      (F.columns = null == ($ = F.columns) ? void 0 : $.map(Y)),
      F
    );
  },
  buildScrollStyle = (e) => {
    const { displayConf: T } = e,
      { scrollSliderColor: C } = T;
    return {
      scrollSliderColor: C,
      visible: "focus",
      width: 7,
      hoverOn: !0,
    };
  },
  buildSelectStyle = (e) => {
    const { displayConf: T } = e,
      {
        headerFocusBorderColor: C = "#3073F2",
        bodyClickCellBgColor: $ = "rgba(186, 215, 255, 0.2)",
      } = T;
    return {
      cellBorderColor: C,
      cellBorderLineWidth: 2,
      cellBgColor: chroma($).alpha(0.2).hex(),
    };
  },
  buildUnderlayBackgroundColor = () => TRANSPARENT_COLOR$1,
  listTableTheme = (e, T) => {
    var C, $, F, V, Y, K, J, ee, te, ie, ne;
    const re = {
        ...e,
      },
      { vizData: ae } = T,
      { displayConf: oe } = ae,
      { transpose: se = !1, hoverHighlight: le = "row" } = oe,
      de = getTableCellPadding(oe),
      ce = getTableCellBorderColor(oe),
      ue = getTableCellBorderLineWidth(oe),
      he = getTableCellBorderLineDash(oe),
      pe = {
        borderColor: oe.gridLineFrame
          ? null != (C = oe.gridLineFrameColor)
            ? C
            : oe.gridLineColor
          : void 0,
        borderLineWidth: oe.gridLineFrame ? oe.gridLineFrameWidth : 0,
        borderLineDash: oe.gridLineFrame
          ? null == ($ = lineDashMap[oe.gridLineFrameStyle])
            ? void 0
            : $.map((e) => e * oe.gridLineFrameWidth)
          : void 0,
        cornerRadius: null == oe ? void 0 : oe.roundCornerRadius,
      },
      ge = {
        borderColor: [null, ce[1], ce[2], ce[3]],
        borderLineWidth: [null, ue[1], ue[2], ue[3]],
        borderLineDash: [null, he[1], he[2], he[3]],
        padding: de,
        hover: {
          cellBgColor:
            null != (F = null == oe ? void 0 : oe.headerHoverCellBgColor)
              ? F
              : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        frameStyle: {
          borderColor: se
            ? [null, ce[1], null, null]
            : [null, null, ce[2], null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle(oe, null == (V = e.theme) ? void 0 : V.headerStyle),
      },
      fe = {
        borderColor: ce,
        borderLineWidth: ue,
        borderLineDash: he,
        padding: de,
        hover: {
          cellBgColor:
            null != (Y = null == oe ? void 0 : oe.bodyClickCellBgColor)
              ? Y
              : "rgba(186, 215, 255, 0.7)",
          inlineRowBgColor:
            null != (K = null == oe ? void 0 : oe.bodyInlineBgColor)
              ? K
              : "rgba(186, 215, 255, 0.3)",
          inlineColumnBgColor:
            null != (J = null == oe ? void 0 : oe.bodyInlineBgColor)
              ? J
              : "rgba(186, 215, 255, 0.3)",
        },
        ...getBodyStyle(oe, null == (ee = e.theme) ? void 0 : ee.bodyStyle),
      },
      me = {
        shadow:
          null == (te = oe.gridLineVertical) || te
            ? {
                width: oe.gridLineVerticalWidth + 2,
                startColor: "rgba(225, 228, 232, 0.6)",
                endColor: "rgba(225, 228, 232, 0.6)",
              }
            : {
                width: 0,
                startColor: TRANSPARENT_COLOR$1,
                endColor: TRANSPARENT_COLOR$1,
              },
      };
    return (
      (re.theme = {
        ...(null != (ie = re.theme) ? ie : {}),
        underlayBackgroundColor: buildUnderlayBackgroundColor(),
        scrollStyle: buildScrollStyle(ae),
        selectionStyle: buildSelectStyle(ae),
        frameStyle: pe,
        headerStyle: ge,
        rowHeaderStyle: ge,
        bodyStyle: fe,
        frozenColumnLine: me,
      }),
      (re.columns =
        null == (ne = re.columns)
          ? void 0
          : ne.map((e) => {
              var T, C, $, F, V, Y, K, J, ee;
              const te = {
                  ...e,
                },
                { field: ie } = te,
                ne = {
                  ...oe,
                  ...(null !=
                  (C = null == (T = ae.fieldMap[ie]) ? void 0 : T.headerStyle)
                    ? C
                    : {}),
                };
              return (
                (te.style = {
                  ...(null != ($ = te.style) ? $ : {}),
                  ...fe,
                  ...getBodyStyle(ne, te.style),
                }),
                (te.headerStyle = {
                  ...(null != (F = te.headerStyle) ? F : {}),
                  ...ge,
                  ...getHeaderStyle(ne, te.headerStyle),
                }),
                (null == (V = ae.fieldMap[ie]) ? void 0 : V.style) &&
                  ((te.style = {
                    ...(null != (Y = te.style) ? Y : {}),
                    ...(null == (K = ae.fieldMap[ie]) ? void 0 : K.style),
                  }),
                  (te.headerStyle = {
                    ...(null != (J = te.headerStyle) ? J : {}),
                    ...(null == (ee = ae.fieldMap[ie])
                      ? void 0
                      : ee.headerStyle),
                  })),
                te
              );
            })),
      (re.showHeader = !oe.hideHeader),
      (re.hover = {
        highlightMode: le,
      }),
      (re.select = {
        highlightMode: "cell",
        headerSelectMode: "inline",
      }),
      re
    );
  },
  buildTooltipStyle = () => ({
    bgColor: "#FFFFFF",
    color: "#000000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif",
  }),
  okrTableTheme = (e, T) => ({
    ...e,
    ...getTableConfig(e, T),
  }),
  getTableConfig = (e, { vizData: T }) => {
    var C;
    const $ = T.displayConf,
      {
        alignDimensionColumn: F,
        alignDimensionRow: V,
        alignMeasure: Y,
        expansionType: K,
        gridLine: J,
        tableStyle: ee,
        roundCornerRadius: te,
        scrollSliderColor: ie,
        headerHoverCellBgColor: ne,
        bodyHoverCellBgColor: re,
        bodyInlineBgColor: ae,
      } = $,
      oe = getPivotTableCellPadding($),
      se =
        null != (C = null == $ ? void 0 : $.borderColor)
          ? C
          : "rgb(224, 224, 224)",
      le = {
        color: "#1B1F23",
        highlightColor: "#1E54C9",
        font: `normal normal normal 12px ${FONT_FAMILY}`,
        highlightFont: `normal normal bold 12px ${FONT_FAMILY}`,
      },
      de = J
        ? {
            borderColor: se,
            borderLineWidth: 0,
            roundCornerRadius: te,
          }
        : void 0,
      ce = se,
      ue = "simple" === ee ? null : se,
      he = {
        borderColor: ["simple" === ee ? null : ce, ue],
        borderLineWidth: [1, 1, 3, 1],
        padding: oe,
        textAlign: "auto" === F ? "center" : F,
        hover: {
          cellBgColor: null != ne ? ne : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        ...getHeaderStyle({
          ...$,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      pe = {
        borderColor: [ce, ue],
        borderLineWidth: [1, 3, 1, 1],
        padding: oe,
        textAlign: "tree" === K || "auto" === V ? "left" : V,
        hover: {
          cellBgColor: null != ne ? ne : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        ...getHeaderStyle({
          ...$,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      ge = {
        borderColor: [ce, ue],
        borderLineWidth: "simple" === ee ? 0 : [1, 3, 3, 1],
        padding: oe,
        textAlign: "tree" === K || "auto" === V ? "left" : V,
        hover: {
          cellBgColor: null != ne ? ne : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        ...getHeaderStyle({
          ...$,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      fe = {
        headerStyle: he,
        bodyStyle: {
          borderColor: [ce, ue],
          borderLineWidth: 1,
          padding: oe,
          textAlign: Y,
          hover: {
            cellBgColor: null != re ? re : "rgba(186, 215, 255, 0.7)",
            inlineRowBgColor: null != ae ? ae : "rgba(186, 215, 255, 0.3)",
            inlineColumnBgColor: null != ae ? ae : "rgba(186, 215, 255, 0.3)",
          },
          ...getBodyStyle($),
        },
        rowHeaderStyle: pe,
        cornerHeaderStyle: ge,
        menuStyle: le,
        underlayBackgroundColor: TRANSPARENT_COLOR$1,
        frameStyle: de,
        scrollStyle: {
          scrollSliderColor: ie,
          visible: "focus",
          width: 7,
          hoverOn: !0,
        },
        selectionStyle: buildSelectStyle(T),
        tooltipStyle: buildTooltipStyle(),
      },
      { hoverHighlight: me = "cross" } = $;
    return {
      theme: fe,
      tooltip: {
        isShowOverflowTextTooltip: !0,
      },
      hover: {
        highlightMode: me,
      },
      click: {
        highlightMode: "cell",
        headerSelectMode: "inline",
      },
    };
  },
  hackStyleForXTable = (e) =>
    e
      ? {}
      : {
          cellInnerBorder: !1,
          cellBorderClipDirection: "bottom-right",
          _contentOffset: 1,
        },
  pivotTableTheme = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { displayConf: V } = F,
      Y = {
        ...e,
      },
      {
        alignDimensionColumn: K,
        alignDimensionRow: J,
        alignMeasure: ee,
        expansionType: te,
        gridLine: ie,
        tableStyle: ne,
        roundCornerRadius: re,
        headerHoverCellBgColor: ae,
        bodyHoverCellBgColor: oe,
        bodyInlineBgColor: se,
        hoverHighlight: le = "cross",
      } = V,
      de = getPivotTableCellPadding(V),
      ce =
        null != (C = null == V ? void 0 : V.borderColor)
          ? C
          : "rgb(224, 224, 224)",
      ue = ie
        ? {
            borderColor: ce,
            borderLineWidth: 1,
            cornerRadius: null != re ? re : 0,
          }
        : void 0,
      he = ce,
      pe = "simple" === ne ? null : ce,
      ge = {
        borderColor: ["simple" === ne ? null : he, pe],
        borderLineWidth: 1,
        padding: de,
        textAlign: "auto" === K ? "center" : K,
        hover: {
          cellBgColor: null != ae ? ae : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: ae,
        },
        frameStyle: {
          borderColor: [null, null, ce, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      fe = {
        borderColor: [he, pe],
        borderLineWidth: 1,
        padding: de,
        textAlign: "tree" === te || "auto" === J ? "left" : J,
        hover: {
          cellBgColor: null != ae ? ae : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: ae,
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        frameStyle: {
          borderColor: [null, ce, null, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      me = {
        borderColor: [he, pe],
        borderLineWidth: 1,
        padding: de,
        textAlign: "tree" === te || "auto" === J ? "left" : J,
        hover: {
          cellBgColor: null != ae ? ae : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        frameStyle: {
          borderColor: [null, ce, ce, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      ye = {
        borderColor: [he, pe],
        borderLineWidth: 1,
        padding: de,
        textAlign: "auto" === ee ? "left" : ee,
        hover: {
          cellBgColor: null != oe ? oe : "rgba(186, 215, 255, 0.7)",
          inlineRowBgColor: null != se ? se : "rgba(186, 215, 255, 0.3)",
          inlineColumnBgColor: null != se ? se : "rgba(186, 215, 255, 0.3)",
        },
        ...getBodyStyle(V),
      };
    return (
      (Y.theme = {
        ...(null != ($ = Y.theme) ? $ : {}),
        underlayBackgroundColor: buildUnderlayBackgroundColor(),
        scrollStyle: buildScrollStyle(F),
        selectionStyle: buildSelectStyle(F),
        tooltipStyle: buildTooltipStyle(),
        frameStyle: ue,
        headerStyle: ge,
        rowHeaderStyle: fe,
        cornerHeaderStyle: me,
        bodyStyle: ye,
        ...hackStyleForXTable(!1),
      }),
      (Y.tooltip = {
        isShowOverflowTextTooltip: !0,
      }),
      (Y.hover = {
        highlightMode: le,
      }),
      (Y.select = {
        highlightMode: "cell",
        headerSelectMode: "inline",
      }),
      Y
    );
  },
  trendTableTheme = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { displayConf: V } = F,
      Y = {
        ...e,
      },
      {
        alignDimensionColumn: K,
        alignDimensionRow: J,
        expansionType: ee,
        gridLine: te,
        tableStyle: ie,
        roundCornerRadius: ne,
        headerHoverCellBgColor: re,
        bodyHoverCellBgColor: ae,
        bodyInlineBgColor: oe,
        hoverHighlight: se = "cross",
      } = V,
      le = getPivotTableCellPadding(V),
      de =
        null != (C = null == V ? void 0 : V.borderColor)
          ? C
          : "rgb(224, 224, 224)",
      ce = te
        ? {
            borderColor: de,
            borderLineWidth: 1,
            cornerRadius: null != ne ? ne : 0,
          }
        : void 0,
      ue = de,
      he = "simple" === ie ? null : de,
      pe = {
        borderColor: ["simple" === ie ? null : ue, he],
        borderLineWidth: 1,
        padding: le,
        textAlign: "auto" === K ? "center" : K,
        hover: {
          cellBgColor: null != re ? re : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: re,
        },
        frameStyle: {
          borderColor: [null, null, de, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      ge = {
        borderColor: [ue, he],
        borderLineWidth: 1,
        padding: le,
        textAlign: "tree" === ee || "auto" === J ? "left" : J,
        hover: {
          cellBgColor: null != re ? re : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: re,
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        frameStyle: {
          borderColor: [null, de, null, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      fe = {
        borderColor: [ue, he],
        borderLineWidth: 1,
        padding: le,
        textAlign: "tree" === ee || "auto" === J ? "left" : J,
        hover: {
          cellBgColor: null != re ? re : "rgba(0, 100, 250, 0.16)",
          inlineRowBgColor: "rgba(255, 255, 255, 0)",
          inlineColumnBgColor: "rgba(255, 255, 255, 0)",
        },
        frameStyle: {
          borderColor: [null, de, de, null],
          borderLineWidth: 2,
        },
        ...getHeaderStyle({
          ...V,
          headerFontBold: !0,
          headerFontItalic: !1,
        }),
      },
      me = {
        borderColor: [ue, he],
        borderLineWidth: 1,
        padding: le,
        hover: {
          cellBgColor: null != ae ? ae : "rgba(186, 215, 255, 0.7)",
          inlineRowBgColor: null != oe ? oe : "rgba(186, 215, 255, 0.3)",
          inlineColumnBgColor: null != oe ? oe : "rgba(186, 215, 255, 0.3)",
        },
        ...getBodyStyle(V),
      };
    return (
      (Y.theme = {
        ...(null != ($ = Y.theme) ? $ : {}),
        underlayBackgroundColor: buildUnderlayBackgroundColor(),
        scrollStyle: buildScrollStyle(F),
        selectionStyle: buildSelectStyle(F),
        tooltipStyle: buildTooltipStyle(),
        frameStyle: ce,
        headerStyle: pe,
        rowHeaderStyle: ge,
        cornerHeaderStyle: fe,
        bodyStyle: me,
        ...hackStyleForXTable(!1),
      }),
      (Y.tooltip = {
        isShowOverflowTextTooltip: !0,
      }),
      (Y.hover = {
        highlightMode: se,
      }),
      (Y.select = {
        highlightMode: "cell",
        headerSelectMode: "inline",
      }),
      Y
    );
  },
  theme = (e, T) =>
    isPivotLikeTable(T.vizData)
      ? isOKRTable(T.vizData)
        ? okrTableTheme(e, T)
        : isTrendTable(T.vizData)
        ? trendTableTheme(e, T)
        : pivotTableTheme(e, T)
      : listTableTheme(e, T),
  initOKRColumns = (e, T) => {
    var C, $;
    const { vizData: F, VTable: V } = T,
      { cells: Y } = F,
      K = Y[0],
      { displayConf: J } = F,
      { other: ee, fieldMap: te } = F,
      {
        alignDimensionColumn: ie,
        headerFontColor: ne,
        tableColumns: re,
        deadlineConfig: ae,
        miniChart: oe,
        headerSubTitleFontColor: se,
      } = J,
      le = getPivotTableCellPadding(J),
      { values: de } = re,
      ce = {
        left: "flex-start",
        center: "center",
        right: "flex-end",
      },
      ue =
        null ==
        (C = Object.values(te).find((e) => e.location === Location.COLUMN))
          ? void 0
          : C.id;
    return {
      ...e,
      columns: [...(null != ($ = K.column) ? $ : [])].map((e) => ({
        dimensionKey: e,
        headerCustomLayout: (e) => {
          var T, C;
          const { table: $, row: F, col: Y, rect: K, dataValue: J } = e,
            { height: re, width: he } = null != K ? K : $.getCellRect(Y, F),
            pe = new V.CustomLayout.Group({
              height: re,
              width: he,
              display: "flex",
              flexDirection: "column",
              flexWrap: "nowrap",
              justifyContent: "space-around",
              alignItems: ce[ie],
            }),
            ge = he - le[1] - le[3],
            fe = ge > 0,
            me = de.find((e) => e.id === J);
          if (me) {
            const e = !!(null == me ? void 0 : me.description),
              T = new V.CustomLayout.Text({
                text: getColumnTitle(me),
                fontSize: 12,
                lineHeight: 18,
                fontFamily: FONT_FAMILY,
                textBaseline: "top",
                fontWeight: "bold",
                fill: ne,
                underline: e ? 1 : void 0,
                maxLineWidth: fe ? ge : void 0,
              }),
              C = new V.CustomLayout.Text({
                text: getColumnDate(ae, me),
                fontSize: 12,
                lineHeight: 18,
                fontFamily: FONT_FAMILY,
                textBaseline: "top",
                fontWeight: "bold",
                fill: null != se ? se : DEFAULT_SUB_TITLE_COLOR,
                maxLineWidth: fe ? ge : void 0,
              });
            return (
              pe.add(T),
              pe.add(C),
              {
                rootContainer: pe,
                renderDefault: !1,
                enableCellPadding: !0,
              }
            );
          }
          if ("mini_chart" === J) {
            const e = new V.CustomLayout.Text({
                text: null == oe ? void 0 : oe.chartName,
                fontSize: 12,
                lineHeight: 18,
                fontFamily: FONT_FAMILY,
                textBaseline: "top",
                fontWeight: "bold",
                fill: ne,
              }),
              $ = (null == ee ? void 0 : ee.miniChartDateRange) || [],
              F = $[0],
              Y = lodash.exports.last($),
              K = new V.CustomLayout.Text({
                text: `${
                  null !=
                  (C =
                    null == (T = te[null != ue ? ue : ""]) ? void 0 : T.alias)
                    ? C
                    : ""
                }: ${F}-${Y}`,
                fontSize: 12,
                lineHeight: 18,
                fontFamily: FONT_FAMILY,
                textBaseline: "top",
                fontWeight: "bold",
                fill: null != se ? se : DEFAULT_SUB_TITLE_COLOR,
              });
            return (
              pe.add(e),
              pe.add(K),
              {
                rootContainer: pe,
                renderDefault: !1,
                enableCellPadding: !0,
              }
            );
          }
          return {
            rootContainer: pe,
            renderDefault: !1,
            enableCellPadding: !0,
          };
        },
      })),
    };
  },
  getColumnTitle = (e) => {
    var T;
    return null != (T = null == e ? void 0 : e.name) ? T : e.defaultName;
  },
  getColumnDate = (e, T) => {
    const C =
      "absolute" === e.defaultType
        ? hooks(e.absoluteTime)
        : hooks().subtract(e.relativeValue, "days");
    return T ? getAccDate(C, T) : "";
  },
  dateToString = (e, T, C) =>
    e && T
      ? [
          e.format(null != C ? C : "MM.DD"),
          T.format(null != C ? C : "MM.DD"),
        ].join(" - ")
      : e.format(null != C ? C : "MM.DD"),
  getAccDate = (e, T) => {
    const { dateUnit: C, type: $, periodType: F } = T,
      V = e.clone();
    if ("day" === C) {
      if ("measureValue" === $) return dateToString(V);
      if ("period" === $ && F === OKRTableColumnPeriodType.RelativeRatio)
        return dateToString(V.subtract(1, "day"));
      if ("period" === $ && F === OKRTableColumnPeriodType.LastweekRatio)
        return dateToString(V.subtract(1, "week"));
      if ("period" === $ && F === OKRTableColumnPeriodType.LastyearRatio)
        return dateToString(V.subtract(1, "year"), void 0, "YYYY.MM.DD");
    }
    if ("day7" === C) {
      if ("measureValue" === $) return dateToString(V.subtract(6, "days"), e);
      if ("period" === $ && F === OKRTableColumnPeriodType.RelativeRatio)
        return dateToString(V.subtract(13, "days"), e.subtract(7, "days"));
      if ("period" === $ && F === OKRTableColumnPeriodType.LastyearRatio)
        return dateToString(
          V.subtract(1, "year").subtract(6, "days"),
          e.subtract(1, "year"),
          "YYYY.MM.DD"
        );
    }
    if ("month" === C) {
      if ("measureValue" === $) return dateToString(V.startOf("month"), e);
      if ("period" === $ && "relativeRatio" === F)
        return dateToString(
          V.subtract(1, "month").startOf("month"),
          e.subtract(1, "month")
        );
      if ("period" === $ && "lastyearRatio" === F)
        return dateToString(
          V.subtract(1, "year").startOf("month"),
          e.subtract(1, "year"),
          "YYYY.MM.DD"
        );
      if ("goalValue" === $ || "goalProgress" === $)
        return dateToString(V.startOf("month"), void 0, "MM");
    }
    if ("quarter" === C) {
      if ("measureValue" === $) return dateToString(V.startOf("quarter"), e);
      if ("period" === $ && "relativeRatio" === F)
        return dateToString(
          V.subtract(1, "quarter").startOf("quarter"),
          e.subtract(1, "quarter")
        );
      if ("period" === $ && "lastyearRatio" === F)
        return dateToString(
          V.subtract(1, "year").startOf("quarter"),
          e.subtract(1, "year"),
          "YYYY.MM.DD"
        );
      if ("goalValue" === $ || "goalProgress" === $)
        return dateToString(V.startOf("quarter"), void 0, "[Q]Q");
    }
    if ("year" === C) {
      if ("measureValue" === $) return dateToString(V.startOf("year"), e);
      if ("period" === $ && "relativeRatio" === F)
        return dateToString(
          V.subtract(1, "year").startOf("year"),
          e.subtract(1, "year"),
          "YYYY.MM.DD"
        );
      if ("goalValue" === $ || "goalProgress" === $)
        return dateToString(V.startOf("year"), void 0, "YYYY");
    }
    return "";
  },
  initOKRIndicators = (e, { vizData: T }) => {
    var C;
    const { cells: $ } = T,
      F = $[0],
      { foldInfo: V } = F,
      Y = null == V ? void 0 : V.id,
      { okrInfo: K = {} } = T.other,
      { displayConf: J } = T,
      {
        display: ee,
        customColWidth: te,
        sortable: ie,
        bodyFontColor: ne,
        periodCompare: re = [],
      } = J;
    return {
      ...e,
      indicators: [...(null != (C = F.value) ? C : [])].map((e) => ({
        indicatorKey: e,
        showSort: ie,
        width: "custom" === ee && null != te ? te : "auto",
        format: (e, C, $, F) => {
          const V = getOriginRecord(F, C, $),
            J = getColumnOriginUniqueIdFromCellRecord(V),
            ee = ((e, C) => {
              var $;
              if (!e || !Y) return;
              const F = e[Y],
                V = getColumnFromRecord(T, e);
              if ("period" === (null == V ? void 0 : V.type)) {
                if (
                  "diff" ===
                  (null == ($ = re.find((e) => String(e.uniqueId) === C))
                    ? void 0
                    : $.calculateType)
                )
                  return;
                return {
                  type: "percent",
                  precision: 2,
                  precisionType: "decimalDigits",
                };
              }
              if (
                ("goalProgress" === (null == V ? void 0 : V.type) ||
                  "goalValue" === (null == V ? void 0 : V.type)) &&
                K &&
                Y &&
                e &&
                e[Y]
              ) {
                const e = K.dataFormatMap;
                return null == e ? void 0 : e[F];
              }
            })(V, J),
            te = getFormatter(J, T, ee);
          return null == te ? void 0 : te(e);
        },
        style: {
          color: (e) => {
            const { col: C, row: $, dataValue: F, table: V } = e,
              Y = getOriginRecord(V, C, $),
              K = getColumnFromRecord(T, Y);
            if (Y && K && "period" === K.type) {
              const e = getColumnOriginUniqueIdFromCellRecord(Y),
                C = getPeriodCondition$1(T, e);
              if (C)
                return generatePeriodConditionColor$1(
                  C,
                  lodash.exports.toNumber(F)
                );
            }
            return ne;
          },
        },
        icon: (e) => {
          const { col: C, row: $, dataValue: F, table: V } = e,
            Y = getOriginRecord(V, C, $),
            K = getColumnFromRecord(T, Y);
          if (K && "period" === K.type) {
            const e = getColumnOriginUniqueIdFromCellRecord(Y),
              C = getPeriodCondition$1(T, e);
            if (C)
              return generatePeriodConditionIcon$1(
                C,
                lodash.exports.toNumber(F)
              );
          }
        },
      })),
    };
  },
  initOKRRows = (e, { vizData: T }) => {
    var C;
    const { cells: $, fieldMap: F } = T,
      V = $[0],
      { displayConf: Y } = T,
      { rowHeaderWidth: K } = Y,
      J = [...(null != (C = V.row) ? C : [])].map((e) => {
        var T, C;
        return {
          dimensionKey: e,
          dimensionTitle:
            null != (C = null == (T = F[e]) ? void 0 : T.alias) ? C : "",
        };
      });
    return (
      (e.defaultHeaderColWidth = null != K ? K : "auto"),
      {
        ...e,
        rows: J,
      }
    );
  },
  initOKRTree = (e, { vizData: T }) => {
    const { columns: C, rows: $ } = genPivotTree$1(T);
    return {
      ...e,
      hideIndicatorName: !0,
      rowTree: $,
      columnTree: C,
    };
  },
  CONST_HEADER$1 = {
    dimensionKey: 0,
    value: "",
  },
  genPivotTree$1 = (e) => {
    const { colPivotTree: T, rowPivotTree: C } = e,
      { column: $ = [], row: F = [], value: V = [] } = e.cells[0],
      Y = getHeadNode$2(T, e, null != $ ? $ : []),
      K = getHeadNode$2(C, e, null != F ? F : []);
    return (
      competeMeasureDimension$1(V[0], Y),
      {
        columns: Y.length > 0 ? Y : [CONST_HEADER$1],
        rows: K.length > 0 ? K : [CONST_HEADER$1],
      }
    );
  },
  getHeadNode$2 = (e, T, C, $ = 0) => {
    var F;
    if (lodash.exports.isNil(e) || lodash.exports.isEmpty(e)) return [];
    return null !=
      (F =
        null == e
          ? void 0
          : e.values.map(({ field: F, value: V, child: Y }) => {
              const K = getHeadNode$2(Y, T, C, $ + 1);
              return {
                dimensionKey: null == e ? void 0 : e.field.toString(),
                value: V,
                children: K.length > 0 ? lodash.exports.cloneDeep(K) : void 0,
              };
            }))
      ? F
      : [];
  },
  competeMeasureDimension$1 = (e, T) => {
    T.forEach((T) => {
      T.children
        ? competeMeasureDimension$1(e, T.children)
        : ((T.children = []),
          T.children.push({
            indicatorKey: e,
          }));
    });
  },
  disablePivotDataConfig = (e, T) => {
    const C = {
      ...e,
      dataConfig: {
        aggregationRules: [],
      },
    };
    return (
      (C.dataConfig.aggregationRules = e.indicators.map((e) => {
        const { indicatorKey: C } = e;
        return {
          indicatorKey: C,
          field: C,
          aggregationType: T.VTable.TYPES.AggregationType.NONE,
        };
      })),
      C
    );
  },
  initDimensions = (e, T) => {
    var C, $, F, V;
    const { vizData: Y } = T,
      K = {
        ...e,
      },
      { cells: J } = Y,
      ee = J[0],
      te = getFields(Y, Location.MEASURE, isRenderField),
      ie = [
        ...(null != (C = ee.row) ? C : []),
        ...(null != ($ = ee.column) ? $ : []),
      ];
    1 === te.length && ie.push(...te);
    const ne = [...(null != (F = ee.row) ? F : [])],
      re = [...(null != (V = ee.column) ? V : [])];
    return (
      (K.rows = ne.map((e, T) => {
        const C = getDimensionTitle({
          key: e,
          vizData: Y,
          isCorner: 0 === T,
        });
        return createDimensionByKey({
          key: e,
          vizData: Y,
          title: C,
        });
      })),
      (K.columns = re.map((e, T) => {
        const C = getDimensionTitle({
          key: e,
          vizData: Y,
          isCorner: 0 === T,
        });
        return createDimensionByKey({
          key: e,
          vizData: Y,
          title: C,
        });
      })),
      K
    );
  },
  createDimensionByKey = ({ key: e, vizData: T, title: C }) => {
    const $ = getFormatter(e, T);
    return {
      dimensionKey: e,
      title: null != C ? C : "",
      headerFormat: $ ? (e) => $(e) : void 0,
    };
  },
  getDimensionTitle = ({ key: e, vizData: T, isCorner: C }) => {
    var $, F;
    const { fieldMap: V, cells: Y } = T,
      { displayConf: K } = T,
      { expansionLabel: J, expansionType: ee } = K;
    if (C && ee && "tree" === ee) {
      if (J && "" !== J) return J;
      return [...(null != ($ = Y[0].row) ? $ : [])]
        .map((e) => {
          var T, C;
          return null != (C = null == (T = V[e]) ? void 0 : T.alias) ? C : "";
        })
        .join("/");
    }
    return null == (F = V[e]) ? void 0 : F.alias;
  },
  initDimensionStyle = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { displayConf: V } = F,
      { column: Y = [] } = F.cells[0],
      K = {
        ...e,
      },
      {
        alignMeasure: J,
        alignDimensionColumn: ee,
        rowHeaderWidth: te,
        sortable: ie,
      } = V,
      ne = (e) => {
        var T;
        if ("string" == typeof e) return e;
        const C = {
            ...e,
          },
          $ = F.fieldMap[C.dimensionKey];
        return (
          (C.headerStyle = {
            textStick: !0,
            textStickBaseOnAlign: !0,
          }),
          C.dimensionKey === Y[Y.length - 1] &&
            (C.headerStyle.textAlign =
              "auto" === ee ? ("auto" === J ? "left" : J) : ee),
          (C.headerStyle = {
            ...C.headerStyle,
            ...(null != (T = null == $ ? void 0 : $.headerStyle) ? T : {}),
          }),
          (C.showSort = ie && !F.fieldMap[C.dimensionKey].disableSort),
          C
        );
      };
    return (
      (K.rows = null == (C = K.rows) ? void 0 : C.map(ne)),
      (K.columns = null == ($ = K.columns) ? void 0 : $.map(ne)),
      (K.defaultHeaderColWidth = null != te ? te : "auto"),
      K
    );
  },
  getIndicatorDimension = (e) => {
    var T;
    const { foldInfo: C } = e.cells[0];
    return null != (T = null == C ? void 0 : C.key) ? T : "";
  },
  initIndicators = (e, T) => {
    var C, $;
    const { vizData: F } = T,
      { fieldMap: V } = F,
      Y = [];
    getFields(F, Location.MEASURE, isRenderField).forEach((e) => {
      const T = getFormatter(e, F),
        C = {
          indicatorKey: e,
          title: V[e].alias,
          format: T ? (e) => T(e) : void 0,
        };
      Y.push(C);
    });
    const K = getIndicatorDimension(F),
      J = isIndicatorInColumn(F);
    return {
      ...e,
      indicators: Y,
      indicatorsAsCol: J,
      indicatorTitle:
        null != ($ = null == (C = F.fieldMap[K]) ? void 0 : C.alias) ? $ : "",
      hideIndicatorName: isHideIndicatorName(F, J),
    };
  },
  isHideIndicatorName = (e, T) => {
    const { column: C = [], row: $ = [] } = e.cells[0],
      { displayConf: F } = e,
      { headerVertical: V, headerHorizontal: Y } = F,
      K = getFields(e, Location.MEASURE, isRenderField);
    if (!1 === Y && !1 === V) return !0;
    if (!1 === Y) {
      if (!0 === T) return !0;
    } else if (!1 === V && !1 === T) return !0;
    return 1 === K.length && C.length >= 1 && $.length >= 1;
  },
  isIndicatorInColumn = (e) => {
    const { cells: T } = e,
      C = T[0],
      $ = getFields(e, Location.MEASURE, isRenderField);
    if (1 === $.length) {
      const { row: e, column: T } = C;
      return (
        (0 === (null == e ? void 0 : e.length) &&
          0 === (null == T ? void 0 : T.length)) ||
        (0 !== (null == e ? void 0 : e.length) && (null == T || T.length, !0))
      );
    }
    if ($.length > 1 && C) {
      const { column: e, foldInfo: T } = C;
      return !!(null == e
        ? void 0
        : e.some((e) => e === (null == T ? void 0 : T.key)));
    }
    return !1;
  },
  initIndicatorStyle = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $,
      { customColWidth: V, display: Y, sortable: K } = F,
      J = {
        ...e,
      };
    return (
      (J.indicators =
        null == (C = J.indicators)
          ? void 0
          : C.map((e) => {
              if ("string" == typeof e) return e;
              const T = {
                  ...e,
                },
                C = $.fieldMap[e.indicatorKey];
              return (
                void 0 !== (null == C ? void 0 : C.disableSort) &&
                  (T.showSort = K && !C.disableSort),
                (null == C ? void 0 : C.style) && (T.style = C.style),
                (null == C ? void 0 : C.headerStyle) &&
                  (T.headerStyle = C.headerStyle),
                (T.width = "custom" === Y && null != V ? V : "auto"),
                (T.showSort = K && !$.fieldMap[T.indicatorKey].disableSort),
                T
              );
            })),
      J
    );
  },
  initPivotCombined = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { displayConf: F } = $,
      V = {
        ...e,
      },
      { expansionType: Y } = F;
    if (
      lodash.exports.isNil($.combined) ||
      (null == (C = $.combined) ? void 0 : C.elementType) ===
        CombinedElementType.OUTSIDE ||
      "tree" !== Y
    )
      return V;
    const K = $.combined,
      { hasColSubSum: J, rowDimensions: ee = [] } = K,
      { row: te } = $.cells[0],
      ie = V.records.filter((e) => !isCombined(e)),
      ne = V.records.filter((e) => isCombined(e)),
      re = gerColSubSunName(ne, K, J),
      ae = restructure(ne, te, ee, re);
    return (V.records = [...ae, ...ie]), T && (T.colSubSumName = re), V;
  },
  restructure = (e, T = [], C, $) =>
    e.map((e) => {
      const F = {
        ...e,
      };
      if (isPivotCombined(F.combined)) {
        if (F.combined.col[0]) {
          const e = String(F.combined.col[0]);
          -1 !== C.indexOf(e) && delete F[e];
          T.slice(T.indexOf(e)).forEach((e) => {
            " " === F[e] && delete F[e];
          });
        }
      } else
        $ &&
          (C.forEach((e) => {
            F[e] === $ && delete F[e];
          }),
          T.forEach((e) => {
            " " === F[e] && delete F[e];
          }));
      return F;
    }),
  gerColSubSunName = (e, T, C) => {
    var $;
    if (!1 === C) return "";
    const F = null == ($ = calcCombinedLabel(T)) ? void 0 : $.subSumLabel;
    if (F) return F;
    const { rowDimensions: V } = T;
    if (0 === V.length) return "";
    const Y = e.find((e) => " " !== e[V[0]]);
    return Y ? Y[V[0]] : "";
  },
  initPivotLayout = (e, T) => {
    const { vizData: C } = T,
      $ = generateBasicLayout(e, T);
    if (isPivotTable(C)) {
      const { displayConf: e } = C,
        { expansionType: T, expansionLevel: F, fieldTree: V } = e,
        { row: Y = [] } = C.cells[0],
        K = getIndicatorDimension(C);
      return (
        "tree" === T &&
          (($.rowHierarchyType = T),
          (!0 === V || 0 === Y.length || Y.includes(K)) &&
            ($.rowHierarchyType = "grid")),
        $.rowHierarchyType &&
          "tree" === $.rowHierarchyType &&
          F &&
          ($.rowExpandLevel = F),
        $
      );
    }
    if (isTrendTable(C)) {
      const { expansionType: e, expansionLevel: T } = C.displayConf;
      return (
        "tree" === e &&
          (($.rowHierarchyType = e), ($.corner.titleOnDimension = "none")),
        $.rowHierarchyType &&
          "tree" === $.rowHierarchyType &&
          T &&
          ($.rowExpandLevel = T),
        $
      );
    }
    if (isOKRTable(C)) {
      const { displayConf: e } = C,
        { expansionType: T, expansionLevel: F } = e;
      return ($.rowHierarchyType = T), ($.rowExpandLevel = F), $;
    }
    return $;
  },
  generateBasicLayout = (e, T) => {
    const { vizData: C } = T,
      $ = {
        ...e,
        rows: [],
        columns: [],
        indicators: [],
        rowTree: [],
        columnTree: [],
        rowHierarchyType: "grid",
        rowHierarchyIndent: 17,
        rowHierarchyTextStartAlignment: !0,
        rowExpandLevel: 1,
        showColumnHeader: !0,
        showRowHeader: !0,
        corner: {
          titleOnDimension: "row",
          headerStyle: {},
        },
      },
      { headerHorizontal: F, headerVertical: V } = C.displayConf,
      { row: Y = [] } = C.cells[0];
    return (
      ($.showColumnHeader = F),
      ($.showRowHeader = V),
      ($.corner = {
        ...$.corner,
        titleOnDimension:
          (null == Y ? void 0 : Y.length) >= 1 ? "row" : "column",
      }),
      $
    );
  },
  initPivotOption = (e, T) => {
    const { vizData: C } = T,
      { display: $, autoWrap: F } = C.displayConf;
    return {
      widthMode: "custom" === $ ? "standard" : $,
      columnResizeMode: "adaptive" === $ ? "none" : "all",
      heightMode: "autoHeight",
      autoWrapText: null != F && F,
      maxCharactersNumber: 256,
      keyboardOptions: {
        selectAllOnCtrlA: !0,
        copySelected: !1,
      },
      columnResizeType: "all",
      menu: {
        renderMode: "html",
      },
      records: C.datasets.flat(3),
      widthAdaptiveMode: "all",
      customConfig: {
        imageMargin: 4,
        multilinesForXTable: !0,
      },
      columnWidthConfig: [],
    };
  },
  initPivotTree = (e, T) => {
    var C;
    const { vizData: $ } = T,
      { columnTree: F, rowTree: V } = genPivotTree($),
      Y = {
        ...e,
        rowTree: V,
        columnTree: F,
      };
    return (
      "tree" === Y.rowHierarchyType &&
        T &&
        (Y.rowTree = deleteEmptyValueForTreeExpansion(
          null != (C = Y.rowTree) ? C : [],
          T
        )),
      Y
    );
  },
  genPivotTree = (e) => {
    const { colPivotTree: T, rowPivotTree: C, fieldMap: $ } = e,
      { column: F = [], row: V = [] } = e.cells[0],
      Y = {
        dimensionKey: 0,
        value: "",
      },
      K = getFields(e, Location.MEASURE, isRenderField),
      J = getHeadNode$1(T, e, null != F ? F : []),
      ee = getHeadNode$1(C, e, null != V ? V : []);
    return (
      1 === K.length
        ? (null == F ? void 0 : F.length) >= 1 &&
          !((null == V ? void 0 : V.length) >= 1)
          ? competeMeasureDimension($, K[0], ee)
          : competeMeasureDimension($, K[0], J)
        : 0 === J.length
        ? J.push({
            dimensionKey: " ",
            value: "",
          })
        : 0 === ee.length &&
          ee.push({
            dimensionKey: " ",
            value: "",
          }),
      {
        columnTree: J.length > 0 ? J : [Y],
        rowTree: ee.length > 0 ? ee : [Y],
      }
    );
  },
  competeMeasureDimension = (e, T, C) => {
    0 !== C.length
      ? C.forEach((C) => {
          C.children
            ? competeMeasureDimension(e, T, C.children)
            : ((C.children = []),
              C.children.push({
                dimensionKey: T,
                value: e[T].alias,
                indicatorKey: T,
              }));
        })
      : C.push({
          dimensionKey: T,
          value: e[T].alias,
          indicatorKey: T,
        });
  },
  getHeadNode$1 = (e, T, C, $ = 0) => {
    var F;
    if (lodash.exports.isNil(e) || lodash.exports.isEmpty(e)) return [];
    const { cells: V } = T,
      { foldInfo: Y } = V[0],
      K = null == Y ? void 0 : Y.foldMap;
    return null !=
      (F =
        null == e
          ? void 0
          : e.values.map(({ field: F, value: V, child: J }) => {
              const ee = getHeadNode$1(J, T, C, $ + 1);
              if (
                (null == e ? void 0 : e.field.toString()) ===
                (null == Y ? void 0 : Y.key)
              ) {
                return {
                  indicatorKey:
                    null != F ? F : lodash.exports.findKey(K, (e) => V === e),
                  value: V,
                  children:
                    ee.length > 0 ? lodash.exports.cloneDeep(ee) : void 0,
                };
              }
              return {
                dimensionKey: null == e ? void 0 : e.field.toString(),
                value: V,
                children: ee.length > 0 ? lodash.exports.cloneDeep(ee) : void 0,
              };
            }))
      ? F
      : [];
  },
  deleteEmptyValueForTreeExpansion = (e, T) => {
    const { colSubSumName: C } = T,
      $ = (e) => {
        if (" " === e.value || e.value === C) return null;
        if (Array.isArray(e.children)) {
          const T = [];
          e.children.forEach((e) => {
            const C = $(e);
            null !== C && T.push(C);
          }),
            (e.children = T.length ? T : null);
        }
        return e;
      };
    return e.forEach($), e;
  },
  pivotDrillMenu = (e, T) => {
    var C, $, F, V;
    const { vizData: Y } = T,
      { displayConf: K } = Y,
      J = {
        ...e,
      },
      { expansionType: ee } = K,
      { fieldMap: te } = Y,
      ie = (e) => {
        var T, C;
        if ("string" == typeof e) return e;
        const $ = {
            ...e,
          },
          F = $.dimensionKey,
          V =
            (null == (T = null == te ? void 0 : te[F])
              ? void 0
              : T.drillStatus) === PillDrillStatus.DRILLABLE;
        $.drillDown = V;
        const Y =
          (null == (C = null == te ? void 0 : te[F])
            ? void 0
            : C.drillStatus) === PillDrillStatus.DRILLED;
        return ($.drillUp = Y), $;
      };
    return (
      (null == ($ = null == (C = Y.other) ? void 0 : C.disabledDrills)
        ? void 0
        : $.includes(DrillType.DimenisionDrill)) ||
        ((J.columns = null == (F = J.columns) ? void 0 : F.map(ie)),
        "tree" !== ee && (J.rows = null == (V = J.rows) ? void 0 : V.map(ie))),
      J
    );
  },
  pivotPopupMenu = (e, T) => {
    const { vizData: C } = T,
      { displayConf: $ } = C,
      F = {
        ...e,
      },
      { headerMenu: V, sortable: Y } = $;
    return (
      !1 !== V &&
        ((F.rows = createDimensionPopupMenu(F.rows, C)),
        (F.columns = createDimensionPopupMenu(F.columns, C)),
        (F.indicators = createIndicatorPopupMenu(F.indicators, C))),
      !1 !== V &&
        (F.menu = {
          ...F.menu,
          dropDownMenuHighlight: menuHighlight(C),
        }),
      Y && (F.pivotSortState = pivotSortState(C)),
      F
    );
  },
  createDimensionPopupMenu = (e, T) => {
    const { fieldMap: C, sort: $, locationMap: F } = T,
      { column: V = [], row: Y = [] } = T.cells[0],
      K = getIndicatorDimension(T),
      J = getFields(T, Location.MEASURE, isRenderField);
    return F.measure.every(
      (e) =>
        !((e) => {
          var T;
          return !!(null == (T = C[e]) ? void 0 : T.display);
        })(e)
    )
      ? e
      : e.map((e) => {
          var F, ee, te, ie, ne;
          const re = {
              ...e,
            },
            ae = [],
            { dimensionKey: oe } = re,
            se = C[oe].disabledChartSortByServerDataSetsConfigure;
          !se &&
            !(null == (F = T.other) ? void 0 : F.disableSort) &&
            V.length >= 1 &&
            Y.length >= 1 &&
            ((1 === J.length &&
              (oe === V[V.length - 1] || oe === Y[Y.length - 1])) ||
              (oe === V[V.length - 1] && V.indexOf(K) >= 0) ||
              (oe === Y[Y.length - 1] && Y.indexOf(K) >= 0)) &&
            ae.push(
              headerMenuItemKey.MENU_SORT_DESC,
              headerMenuItemKey.MENU_SORT_ASC
            ),
            se ||
              (null == (ee = T.other) ? void 0 : ee.disableSort) ||
              (0 !== (null != (te = null == V ? void 0 : V.length) ? te : 0) &&
                0 !== (null != (ie = Y.length) ? ie : 0)) ||
              1 !== J.length ||
              oe !== J[0] ||
              ae.push(
                headerMenuItemKey.MENU_SORT_DESC,
                headerMenuItemKey.MENU_SORT_ASC
              );
          const { customMenu: le } =
            (null == (ne = T.fieldMap) ? void 0 : ne[oe]) || {};
          if (
            (le && ae.push(...le),
            ae && ae.length >= 1 && (re.dropDownMenu = getDropDownMenu(T, ae)),
            !se && (Y.indexOf(oe) >= 0 || V.indexOf(oe) >= 0))
          ) {
            re.cornerDropDownMenu = [];
            const e = {
              text: intl.i18n``,
              type: "title",
            };
            re.cornerDropDownMenu.push(e);
            const F = {
              text: re.title,
              children: getDropDownMenu(T, [
                headerMenuItemKey.MENU_SORT_DESC,
                headerMenuItemKey.MENU_SORT_ASC,
              ]),
            };
            if (
              (re.cornerDropDownMenu.push(F),
              null == J ||
                J.forEach((e) => {
                  var $;
                  const F = {
                    text: C[e].alias,
                    children: getDropDownMenu(T, [
                      `${headerMenuItemKey.MENU_SORT_DESC}#${e}`,
                      `${headerMenuItemKey.MENU_SORT_ASC}#${e}`,
                    ]),
                  };
                  null == ($ = null == re ? void 0 : re.cornerDropDownMenu) ||
                    $.push(F);
                }),
              $ && $.length > 0)
            ) {
              $.find(
                (e) =>
                  (e.id === e.depend || !e.filter || 0 === e.filter.length) &&
                  e.id === re.dimensionKey
              ) &&
                (re.cornerDropDownMenu.push({
                  type: "split",
                }),
                re.cornerDropDownMenu.push({
                  text: intl.i18n``,
                  menuKey: headerMenuItemKey.MENU_SORT_CANCEL,
                }));
            }
          }
          return re;
        });
  },
  getDropDownMenu = (e, T) => {
    const C = e.displayConf,
      $ = [];
    return (
      T.forEach((e) => {
        var T, F;
        e.includes(headerMenuItemKey.MENU_SORT_ASC)
          ? $.push({
              text: intl.i18n``,
              menuKey: e,
              icon: {
                svg: IconSortAsc({
                  width: "15",
                  height: "15",
                  color: "currentColor",
                }),
              },
              selectedIcon: {
                svg: IconSortAsc({
                  width: "15",
                  height: "15",
                  color: "currentColor",
                }),
              },
              stateIcon: {
                svg: IconHeaderSortAsc({
                  width: 1.5 * C.headerFontSize,
                  height: 1.5 * C.headerFontSize,
                  color: null != (T = C.headerFontColor) ? T : "currentColor",
                }),
                width: 1.5 * C.headerFontSize,
                height: 1.5 * C.headerFontSize,
              },
            })
          : e.includes(headerMenuItemKey.MENU_SORT_DESC)
          ? $.push({
              text: intl.i18n``,
              menuKey: e,
              icon: {
                svg: IconSortDesc({
                  width: "15",
                  height: "15",
                  color: "currentColor",
                }),
              },
              selectedIcon: {
                svg: IconSortDesc({
                  width: "15",
                  height: "15",
                  color: "currentColor",
                }),
              },
              stateIcon: {
                svg: IconHeaderSortDesc({
                  width: 1.5 * C.headerFontSize,
                  height: 1.5 * C.headerFontSize,
                  color: null != (F = C.headerFontColor) ? F : "currentColor",
                }),
                width: 1.5 * C.headerFontSize,
                height: 1.5 * C.headerFontSize,
              },
            })
          : e.includes(headerMenuItemKey.MENU_FROZEN_COL)
          ? $.push({
              text: intl.i18n``,
              menuKey: headerMenuItemKey.MENU_FROZEN_COL,
              icon: {
                svg: IconFrozenCol({
                  width: "16",
                  height: "16",
                  color: "currentColor",
                }),
              },
              selectedIcon: {
                svg: IconFrozenCol({
                  width: "16",
                  height: "16",
                  color: "currentColor",
                }),
              },
            })
          : e.includes(headerMenuItemKey.MENU_DIMMET_INFO)
          ? $.push({
              text: intl.i18n``,
              menuKey: headerMenuItemKey.MENU_DIMMET_INFO,
            })
          : e.includes(headerMenuItemKey.MENU_NUM_FORMAT)
          ? $.push({
              text: intl.i18n``,
              menuKey: headerMenuItemKey.MENU_NUM_FORMAT,
            })
          : e.includes(headerMenuItemKey.MENU_VISUAL_STYLE) &&
            $.push({
              text: intl.i18n``,
              menuKey: headerMenuItemKey.MENU_VISUAL_STYLE,
            });
      }),
      $
    );
  },
  createIndicatorPopupMenu = (e, T) => {
    const { fieldMap: C, locationMap: $ } = T,
      { column: F = [], row: V = [] } = T.cells[0],
      Y = getFields(T, Location.MEASURE, isRenderField);
    if (
      $.measure.every(
        (e) =>
          !((e) => {
            var T;
            return !!(null == (T = C[e]) ? void 0 : T.display);
          })(e)
      )
    )
      return e;
    const K = getIndicatorDimension(T),
      J = K ? T.fieldMap[K] : void 0;
    return e.map((e) => {
      var $, ee, te, ie;
      const ne = {
          ...e,
        },
        re = [],
        { indicatorKey: ae } = ne,
        oe = C[ae].disabledChartSortByServerDataSetsConfigure;
      if (
        (!oe &&
          !(null == ($ = T.other) ? void 0 : $.disableSort) &&
          F.length >= 1 &&
          V.length >= 1 &&
          ((1 === Y.length &&
            (K === F[F.length - 1] || K === V[V.length - 1])) ||
            (K === F[F.length - 1] && F.indexOf(K) >= 0) ||
            (K === V[V.length - 1] && V.indexOf(K) >= 0)) &&
          re.push(
            headerMenuItemKey.MENU_SORT_DESC,
            headerMenuItemKey.MENU_SORT_ASC
          ),
        oe ||
          (null == (ee = T.other) ? void 0 : ee.disableSort) ||
          (0 !== (null != (te = null == F ? void 0 : F.length) ? te : 0) &&
            0 !== (null != (ie = V.length) ? ie : 0)) ||
          1 !== Y.length ||
          ae !== Y[0] ||
          re.push(
            headerMenuItemKey.MENU_SORT_DESC,
            headerMenuItemKey.MENU_SORT_ASC
          ),
        J)
      ) {
        const { customMenu: e } = J;
        e && re.push(...e);
      }
      return (
        re && re.length >= 1 && (ne.dropDownMenu = getDropDownMenu(T, re)), ne
      );
    });
  },
  menuHighlight = (e) => {
    const { cells: T, fieldMap: C, sort: $ } = e;
    if (!$ || lodash.exports.isEmpty($)) return [];
    const F = T[0],
      V = [];
    return (
      $.forEach((e) => {
        var T, $, Y, K;
        if (![Order.ASC, Order.DESC].includes(e.order)) return;
        let J =
            e.order === Order.ASC
              ? headerMenuItemKey.MENU_SORT_ASC
              : e.order === Order.DESC
              ? headerMenuItemKey.MENU_SORT_DESC
              : null,
          ee = [];
        if (e.id === e.depend)
          ee = [
            {
              dimensionKey: e.id,
            },
          ];
        else if (e.filter && 0 !== e.filter.length) {
          if (e.depend && e.filter)
            if (F && F.foldInfo) {
              ee = (
                (null == (T = F.column) ? void 0 : T.includes(F.foldInfo.key))
                  ? F.column
                  : null != ($ = F.row)
                  ? $
                  : []
              ).map((T) => {
                var $, V;
                if (T === F.foldInfo.key) {
                  const T = e.depend;
                  return {
                    indicatorKey: T,
                    value: C[T].alias,
                  };
                }
                return {
                  dimensionKey: T,
                  value:
                    null ==
                    (V =
                      null == ($ = e.filter)
                        ? void 0
                        : $.find((e) => e.id === T))
                      ? void 0
                      : V.val,
                };
              });
            } else
              ee =
                null !=
                (K =
                  null == (Y = e.filter)
                    ? void 0
                    : Y.map(({ id: e, val: T }) => ({
                        dimensionKey: e,
                        value: T,
                      })))
                  ? K
                  : [];
        } else
          (J = `${J}#${e.depend}`),
            (ee = [
              {
                dimensionKey: e.id,
              },
            ]);
        V.push({
          menuKey: J,
          field: ee,
        });
      }),
      V
    );
  },
  pivotSortState = (e) => {
    const { cells: T, fieldMap: C, sort: $ } = e;
    if (!$ || lodash.exports.isEmpty($)) return [];
    const F = T[0],
      V = [];
    return (
      $.forEach((e) => {
        var T, $, Y, K, J, ee, te, ie;
        const ne = [Order.ASC, Order.DESC].includes(e.order) ? e.order : null;
        let re = [];
        if (e.depend && e.filter)
          if (
            ((re =
              null !=
              ($ =
                null == (T = e.filter)
                  ? void 0
                  : T.map(({ id: e, val: T }) => ({
                      dimensionKey: e,
                      value: T,
                    })))
                ? $
                : []),
            F && F.foldInfo)
          ) {
            re = (
              (null == (Y = F.column) ? void 0 : Y.includes(F.foldInfo.key))
                ? F.column
                : null != (K = F.row)
                ? K
                : []
            ).map((T) => {
              var $, V;
              if (T === F.foldInfo.key) {
                const T = e.depend;
                return {
                  indicatorKey: T,
                  value: C[T].alias,
                };
              }
              return {
                dimensionKey: T,
                value:
                  null ==
                  (V =
                    null == ($ = e.filter) ? void 0 : $.find((e) => e.id === T))
                    ? void 0
                    : V.val,
              };
            });
          } else
            re =
              null !=
              (ee =
                null == (J = e.filter)
                  ? void 0
                  : J.map(({ id: e, val: T }) => ({
                      dimensionKey: e,
                      value: T,
                    })))
                ? ee
                : [];
        ne &&
          V.push({
            order: ne,
            dimensions:
              null != (ie = null == (te = e.path) ? void 0 : te.field)
                ? ie
                : re,
          });
      }),
      V
    );
  },
  initTrendDimensions = (e, T) => {
    const { vizData: C } = T,
      $ = {
        ...e,
      },
      { cells: F, fieldMap: V } = C,
      Y = F[0],
      { foldInfo: K, column: J = [], row: ee = [] } = Y,
      te = getFields(C, Location.MEASURE, isRenderField),
      ie = ee.filter((e) => !te.includes(e)),
      ne = [],
      re = [],
      ae = [...(null != J ? J : [])];
    return (
      [...(null != ie ? ie : [])].forEach((e) => {
        var T, $;
        const F = {
            dimensionKey: e,
            title:
              null != ($ = null == (T = V[e]) ? void 0 : T.alias)
                ? $
                : e === (null == K ? void 0 : K.key)
                ? intl.i18n``
                : "",
          },
          Y = getFormatter(e, C);
        Y && (F.headerFormat = (e) => Y(e)), ne.push(F);
      }),
      ae.forEach((e) => {
        var T;
        const $ = {
            dimensionKey: e,
            title: null == (T = V[e]) ? void 0 : T.alias,
          },
          F = getFormatter(e, C);
        F && ($.headerFormat = (e) => F(e)), re.push($);
      }),
      ($.indicators = generateHiddenIndicators(C)),
      ($.rows = ne),
      ($.columns = re),
      $
    );
  },
  generateHiddenIndicators = (e) => {
    var T, C, $;
    const { foldInfo: F } = e.cells[0],
      V = [
        {
          indicatorKey: null == F ? void 0 : F.value,
          value: TREND_TABLE_MEASURE_FOLD_ID,
        },
      ];
    return (
      checkEnablePresetsByVizData(e) &&
        V.push({
          indicatorKey: null == F ? void 0 : F.valueMulti,
          value:
            null !=
            ($ =
              null == (C = null == F ? void 0 : F.foldMap)
                ? void 0
                : C[null != (T = null == F ? void 0 : F.valueMulti) ? T : ""])
              ? $
              : "",
        }),
      V.map(({ indicatorKey: T, value: C }) => ({
        indicatorKey: T,
        title: C,
        format: (C, $, V, Y) => {
          if (!C || void 0 === $ || void 0 === V) return "";
          const K = getOriginRecord(Y, $, V);
          let J = K[F.id],
            ee = null == K ? void 0 : K[T];
          if (
            T === (null == F ? void 0 : F.valueMulti) &&
            ((ee = Math.abs(K[null == F ? void 0 : F.valueMulti])),
            (J = K[F.idMulti]),
            !ee)
          )
            return "";
          const te = getFormatter(
            J,
            e,
            T === (null == F ? void 0 : F.valueMulti)
              ? getDefaultRatioFormat(e)
              : void 0
          );
          return te ? te(ee) : ee;
        },
      }))
    );
  },
  initTrendDimensionStyle = (e, T) => {
    var C, $, F;
    const { vizData: V } = T,
      { column: Y = [], foldInfo: K, row: J = [] } = V.cells[0],
      ee = {
        ...e,
      },
      {
        customColWidth: te,
        display: ie,
        alignDimensionColumn: ne,
        rowHeaderWidth: re,
        alignMeasure: ae,
      } = V.displayConf,
      oe = getLastDateValues(V),
      se = checkEnablePresetsByVizData(V),
      le = getPivotTableCellPadding(V.displayConf),
      de = (e) => {
        var T, C;
        if ("string" == typeof e) return e;
        const $ = {
            ...e,
          },
          { dimensionKey: F } = $;
        $.headerStyle = {
          textStick: !0,
          textStickBaseOnAlign: !0,
        };
        const K = V.fieldMap[F];
        return (
          F === Y[Y.length - 1] &&
            (($.headerStyle.textAlign =
              "auto" === ne ? (se ? "center" : "right") : ne),
            ($.headerStyle.borderLineWidth = (e) => {
              const { value: T } = e;
              return generateBorderLineByValue(oe, T);
            })),
          ($.headerStyle = {
            ...$.headerStyle,
            ...(null != (T = null == K ? void 0 : K.headerStyle) ? T : {}),
          }),
          J.indexOf(F) >= 0 &&
            ($.width =
              null != (C = null == re ? void 0 : re[J.indexOf(F)])
                ? C
                : "auto"),
          $
        );
      };
    return (
      (ee.rows = null == (C = ee.rows) ? void 0 : C.map(de)),
      (ee.columns = null == ($ = ee.columns) ? void 0 : $.map(de)),
      (ee.indicators =
        null == (F = ee.indicators)
          ? void 0
          : F.map((e) => {
              var T, C;
              if ("string" == typeof e) return e;
              const $ = {
                ...e,
              };
              let F = V.fieldMap[$.indicatorKey];
              if (
                (($.width = "custom" === ie && null != te ? te : "auto"),
                $.indicatorKey === (null == K ? void 0 : K.valueMulti))
              ) {
                const e = getPeriodCondition(V),
                  { color: C = "#000" } =
                    null != (T = null == $ ? void 0 : $.style) ? T : {},
                  { icon: F } = $,
                  Y = (e) => ("function" == typeof C ? C(e) : C),
                  K = (e) => ("function" == typeof F ? F(e) : F);
                ($.style = {
                  textAlign: "auto" === ae ? "left" : ae,
                  padding:
                    "auto" === ae ? [le[0], 0, le[2], TREND_CELL_PADDING] : le,
                  borderLineWidth: (e) => {
                    var T, C;
                    const { cellHeaderPaths: $ } = e;
                    return generateBorderLineByValue(
                      oe,
                      null ==
                        (C =
                          null == (T = null == $ ? void 0 : $.colHeaderPaths)
                            ? void 0
                            : T[0])
                        ? void 0
                        : C.value
                    );
                  },
                  color: (T) => {
                    var C;
                    const { dataValue: $ } = T;
                    return e
                      ? null !=
                        (C = generatePeriodConditionColor(
                          e,
                          lodash.exports.toNumber($)
                        ))
                        ? C
                        : Y(T)
                      : lodash.exports.toNumber($) > 0
                      ? "red"
                      : "green";
                  },
                }),
                  ($.icon = (T) => {
                    var C, $;
                    const { dataValue: F } = T,
                      { cellHeaderPaths: V } = T;
                    return e &&
                      (F ||
                        (null ==
                        (C = lodash.exports.last(
                          null == V ? void 0 : V.rowHeaderPaths
                        ))
                          ? void 0
                          : C.dimensionKey) === lodash.exports.last(J)) &&
                      null !=
                        ($ = generatePeriodConditionIcon(
                          e,
                          lodash.exports.toNumber(F)
                        ))
                      ? $
                      : K(T);
                  });
              } else {
                if ($.indicatorKey === TREND_TABLE_MEASURE_FOLD_ID) {
                  const e =
                    null == (C = null == K ? void 0 : K.foldMap)
                      ? void 0
                      : C[TREND_TABLE_MEASURE_FOLD_ID];
                  F = V.fieldMap[e];
                }
                (null == F ? void 0 : F.style) && ($.style = F.style),
                  (null == F ? void 0 : F.headerStyle) &&
                    ($.headerStyle = F.headerStyle),
                  ($.style = {
                    ...($.style || {}),
                    textAlign: "auto" === ae ? "right" : ae,
                    padding:
                      "auto" === ae && se
                        ? lodash.exports.set(le, [1], TREND_CELL_PADDING)
                        : le,
                    borderLineWidth: (e) => {
                      var T;
                      return se
                        ? [0, 0, 1, 0]
                        : generateBorderLineByValue(
                            oe,
                            null == (T = e.cellHeaderPaths.colHeaderPaths)
                              ? void 0
                              : T[0].value
                          );
                    },
                  });
              }
              return $;
            })),
      (ee.defaultHeaderColWidth = null != re ? re : "auto"),
      ee
    );
  },
  generatePeriodConditionColor = (e, T) => {
    const C = getConditionIndexByValue(T);
    return e.colors[C];
  },
  generatePeriodConditionIcon = (e, T) => {
    const C = getConditionIndexByValue(T),
      $ = e.members[C],
      F = generatePeriodConditionColor(e, T);
    return {
      type: "svg",
      name: `${$}${F}`,
      interactive: !1,
      svg: getIconSvg($, {
        width: "12px",
        height: "12px",
        color: F,
      }),
      marginRight: 2,
      positionType: "inlineFront",
      width: 12,
      height: 12,
    };
  },
  initTrendTree = (e, { vizData: T }) => {
    const { columnTree: C, rowTree: $ } = genTrendTree(T);
    return {
      ...e,
      columnTree: C,
      rowTree: $,
      hideIndicatorName: !0,
    };
  },
  CONST_HEADER = {
    dimensionKey: 0,
    value: "",
  },
  genTrendTree = (e) => {
    var T;
    const { colPivotTree: C, rowPivotTree: $, datasets: F } = e,
      { column: V = [], row: Y = [] } = e.cells[0],
      K = getHeadNode(C, e, null != V ? V : []),
      J = getHeadNode($, e, null != Y ? Y : [], 0);
    return (
      0 === K.length
        ? K.push({
            dimensionKey: " ",
            value: "",
          })
        : 0 === J.length &&
          J.push({
            dimensionKey: " ",
            value: "",
          }),
      {
        columnTree:
          (null == F ? void 0 : F.length) &&
          !(null == (T = null == C ? void 0 : C.values) ? void 0 : T.length)
            ? []
            : K,
        rowTree: J.length > 0 ? J : [CONST_HEADER],
      }
    );
  },
  getHeadNode = (e, T, C, $ = 0) => {
    var F;
    if (lodash.exports.isNil(e) || lodash.exports.isEmpty(e)) return [];
    const { cells: V } = T,
      { foldInfo: Y } = V[0],
      K = null == Y ? void 0 : Y.foldMap;
    return null !=
      (F =
        null == e
          ? void 0
          : e.values.map(({ value: F, child: V }) => {
              var J, ee;
              const te = getHeadNode(V, T, C, $ + 1);
              if (
                (null == e ? void 0 : e.field.toString()) ===
                (null == Y ? void 0 : Y.keyMulti)
              ) {
                return {
                  indicatorKey: null != (J = findKey(K, F)) ? J : "",
                  value: F,
                  children:
                    te.length > 0 ? lodash.exports.cloneDeep(te) : void 0,
                };
              }
              return {
                dimensionKey:
                  null == (ee = null == e ? void 0 : e.field)
                    ? void 0
                    : ee.toString(),
                value: F,
                children: te.length > 0 ? lodash.exports.cloneDeep(te) : void 0,
              };
            }))
      ? F
      : [];
  },
  findKey = (e, T, C = (e, T) => e === T) =>
    Object.keys(e).find(($) => C(e[$], T)),
  okrTable = {
    initial: {},
    pipes: [
      initPivotOption,
      initPivotLayout,
      initOKRTree,
      initOKRColumns,
      initOKRRows,
      initOKRIndicators,
      initDimensionStyle,
      theme,
      conditionalFormat$1,
      miniChart,
      stratify,
      disablePivotDataConfig,
    ],
  },
  pivotTable = {
    initial: {},
    pipes: [
      initPivotOption,
      initPivotCombined,
      initPivotLayout,
      initPivotTree,
      initIndicators,
      initDimensions,
      initIndicatorStyle,
      initDimensionStyle,
      pivotDrillMenu,
      pivotPopupMenu,
      theme,
      textContent,
      conditionalFormat$1,
      highlight,
      cornerMark,
      stratify,
      compact,
      disablePivotDataConfig,
    ],
  },
  table = {
    initial: {
      columns: [],
      records: [],
    },
    pipes: [
      initColumns,
      initBasicInfo,
      popupMenu,
      formatter$1,
      theme,
      textContent,
      conditionalFormat$1,
      miniChart,
      highlight,
      cornerMark,
      stratify,
      measureFirst,
      lineNumber,
      columnOrder,
      compact,
    ],
  },
  trendTable = {
    initial: {},
    pipes: [
      initPivotOption,
      initPivotLayout,
      initTrendTree,
      initTrendDimensions,
      initTrendDimensionStyle,
      pivotDrillMenu,
      theme,
      miniChart,
      conditionalFormat$1,
      stratify,
      disablePivotDataConfig,
    ],
  },
  extend = {
    initial: {
      type: "extend",
    },
    pipes: [],
  },
  pipelineMap = {
    [ChartType.TABLE]: table,
    [ChartType.RAW_TABLE]: table,
    [ChartType.PIVOT_TABLE]: pivotTable,
    [ChartType.TREND_TABLE]: trendTable,
    [ChartType.OKR_TABLE]: okrTable,
    [ChartType.COLUMN]: column,
    [ChartType.COLUMN_PERCENT]: column,
    [ChartType.COLUMN_PARALLEL]: column,
    [ChartType.BAR]: bar$1,
    [ChartType.BAR_PERCENT]: bar$1,
    [ChartType.BAR_PARALLEL]: bar$1,
    [ChartType.LINE]: line,
    [ChartType.AREA]: area,
    [ChartType.AREA_PERCENT]: area,
    [ChartType.PIE]: pie,
    [ChartType.ANNULAR]: pie,
    [ChartType.ROSE]: rose,
    [ChartType.RADAR]: radar,
    [ChartType.SCATTER]: scatter,
    [ChartType.CIRCLE_VIEWS]: circleViews,
    [ChartType.DUAL_AXIS]: dualAxis,
    [ChartType.BILATERAL]: bilateral,
    [ChartType.COMBINATION]: combination,
    [ChartType.MAP]: map,
    [ChartType.SCATTER_MAP]: scatterMap,
    [ChartType.WORD_CLOUD]: wordCloud,
    [ChartType.HISTOGRAM]: histogram,
    [ChartType.FUNNEL]: funnel,
    [ChartType.SANKEY]: sankey,
    [ChartType.GAUGE]: gauge,
    [ChartType.PROGRESS]: progress,
    [ChartType.LIQUID]: liquid,
    [ChartType.WATERFALL]: waterfall,
    [ChartType.WATERFALL_CHANGE]: waterfall,
    [ChartType.GIS_MAP]: gis,
    [ChartType.GIS_MARK_MAP]: gis,
    [ChartType.GIS_BAR_MAP]: gis,
    [ChartType.GIS_TRACE_MAP]: gis,
    [ChartType.GIS_HEAT_MAP]: gis,
    [ChartType.GIS_PULSE_MAP]: gis,
    [ChartType.EXTEND]: extend,
  },
  beforePipe = (e, T) => {
    var C, $;
    return {
      ...e,
      theme: {
        ...(null != (C = T.theme) ? C : {}),
        ...(null != ($ = e.theme) ? $ : {}),
      },
    };
  },
  afterPipe = (e, T) => {
    const { vizData: C } = T,
      {
        displayConf: $,
        fieldMap: F,
        chartType: V,
        sort: Y,
        referenceLine: K,
        other: J,
      } = C;
    return (
      [
        ChartType.TABLE,
        ChartType.PIVOT_TABLE,
        ChartType.RAW_TABLE,
        ChartType.TREND_TABLE,
        ChartType.OKR_TABLE,
      ].includes(V)
        ? (e.hash = generateHash({
            displayConf: $,
            fieldMap: Object.keys(F).map((e) => {
              const {
                contentFormat: T,
                format: C,
                description: $,
                headerStyle: V,
                customMenu: Y,
                alias: K,
              } = F[e];
              return {
                id: e,
                contentFormat: T,
                format: C,
                description: $,
                headerStyle: V,
                customMenu: Y,
                alias: K,
              };
            }),
            sort: Y,
            context: T.context,
            other: J,
            hash: C.hash,
          }))
        : (e.hash = generateHash({
            displayConf: $,
            referenceLine: K,
            pivotTree: {
              rowPivotTree: C.rowPivotTree,
              colPivotTree: C.colPivotTree,
            },
            fieldMap: Object.keys(F).map((e) => ({
              id: e,
              format: F[e].format,
              description: F[e].description,
              alias: F[e].alias,
            })),
            hash: C.hash,
          })),
      e
    );
  },
  getPipeline = (e) => {
    const { initial: T, pipes: C } = pipelineMap[e];
    return {
      initial: {
        ...T,
      },
      pipes: [...C],
    };
  },
  pipeline = (e, T = [], C) => {
    const { chartType: $ } = e,
      { initial: F, pipes: V } = null != C ? C : getPipeline($);
    return (C) =>
      execPipeline(F, [beforePipe, ...V, ...T, afterPipe], {
        vizData: e,
        ...C,
      });
  },
  execPipeline = (e, T, C) => T.reduce((e, T) => T(e, C), e),
  execPipelineAsync = async (e, T, C) => {
    let $ = e;
    for (const F of T) {
      let e = F($, C);
      e instanceof Promise && (e = await e), ($ = e);
    }
    return $;
  },
  pipelineAsync = (e, T = [], C) => {
    const { chartType: $ } = e,
      { initial: F, pipes: V } = null != C ? C : getPipeline($);
    return async (C, $) =>
      await execPipelineAsync(F, [beforePipe, ...V, ...T, afterPipe], {
        vizData: e,
        chartInstance: C,
        context: $,
      });
  },
  getColumnMinMax = ({
    field: e,
    records: T,
    valueType: C,
    excludeTotal: $,
    statistic: F = {},
  }) => {
    if ("number" === C && T.length > 0) {
      const { min: C, max: V } = F;
      if (!lodash.exports.isNil(C) && !lodash.exports.isNil(V)) return [C, V];
      let Y = null != V ? V : Number.MIN_SAFE_INTEGER,
        K = null != C ? C : Number.MAX_SAFE_INTEGER;
      for (let F = 0; F < T.length; F++)
        ($ && isCombined(T[F])) ||
          (isNum(T[F][e]) &&
            (lodash.exports.isNil(C) && (K = Math.min(parseFloat(T[F][e]), K)),
            lodash.exports.isNil(V) && (Y = Math.max(parseFloat(T[F][e]), Y))));
      return [K, Y];
    }
    return [void 0, void 0];
  },
  isExcludeTotalAndProcessingTotal = (e, T) => {
    const { excludeTotal: C } = e,
      { col: $, row: F, grid: V } = T,
      Y = V.getCellOriginRecord($, F);
    return !(!C || !isCombined(Y));
  },
  calcRuleValue = (e, T, C) => {
    var $;
    return "computed" === e.operandType && e.computedValue
      ? null != ($ = null == C ? void 0 : C[e.computedValue])
        ? $
        : e.value
      : "cmpField" === e.operandType && e.cmpFieldId && T
      ? T[e.cmpFieldId]
      : e.operandType && "fixed" !== e.operandType
      ? void 0
      : e.value;
  };
function isNum(e) {
  return "NaN" !== parseFloat(e).toString();
}
function toNum(e) {
  return parseFloat(e);
}
function RuleMatch(e, T, C) {
  switch (e) {
    case "all":
      return !0;
    case "none":
      return !1;
    case "empty":
      return !isNum(T);
    case "notEmpty":
      return isNum(T);
    case "<":
      return isNum(T) && toNum(T) < toNum(C);
    case "<=":
      return isNum(T) && toNum(T) <= toNum(C);
    case "!=":
      return isNum(T) && toNum(T) !== toNum(C);
    case "=":
      return isNum(T) && toNum(T) === toNum(C);
    case ">":
      return isNum(T) && toNum(T) > toNum(C);
    case ">=":
      return isNum(T) && toNum(T) >= toNum(C);
    case "%":
      return isNum(T) && toNum(T) % toNum(C) == 0;
    case "include":
      return null == T
        ? void 0
        : T.toString().includes(null == C ? void 0 : C.toString());
    case "exclude":
      return !(null == T
        ? void 0
        : T.toString().includes(null == C ? void 0 : C.toString()));
    case "startsWith":
      return null == T
        ? void 0
        : T.toString().startsWith(null == C ? void 0 : C.toString());
    case "endsWith":
      return null == T
        ? void 0
        : T.toString().endsWith(null == C ? void 0 : C.toString());
    case "strEqual":
      return (
        (null == T ? void 0 : T.toString()) ===
        (null == C ? void 0 : C.toString())
      );
    case "strNotEqual":
      return (
        (null == T ? void 0 : T.toString()) !==
        (null == C ? void 0 : C.toString())
      );
  }
  return !1;
}
function isMatchRule(e, T, C, $) {
  for (const F of e) {
    const e = calcRuleValue(F, C, $);
    if (!RuleMatch(F.ruleType, T, e)) return !1;
  }
  return !0;
}
function isMatchRuleGroup(e, T, C, $) {
  var F, V;
  if (!e.rules.length && !e.groups.length) return !0;
  const Y = "and" === e.operator;
  let K = Y;
  for (const J of e.rules) {
    const e = null != (F = J.pillId) ? F : $,
      ee = e ? C[e] : {},
      te = isMatchRule(
        [J],
        null != (V = T[`${e}`]) ? V : J.defaultPillValue,
        T,
        ee
      );
    if (Y) {
      if (((K = K && te), !K)) return K;
    } else if (((K = K || te), K)) return K;
  }
  for (const J of e.groups) {
    const e = isMatchRuleGroup(J, T, C, $);
    if (Y) {
      if (((K = K && e), !K)) return K;
    } else if (((K = K || e), K)) return K;
  }
  return K;
}
function instanceOfTableVisualBarData(e) {
  return (
    e && "positiveColor" in e && "negativeColor" in e && "barAxisColor" in e
  );
}
function instanceOfTableVisualColorLevelsData(e) {
  return (
    e &&
    "colors" in e &&
    "levels" in e &&
    Array.isArray(e.colors) &&
    Array.isArray(e.levels) &&
    e.colors.length === e.levels.length + 2
  );
}
function instanceOfTableVisualRule(e) {
  return (
    e &&
    "ruleType" in e &&
    ("value" in e || "computedValue" in e || "cmpFieldId" in e)
  );
}
function instanceOfTableVisualRules(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualRule(e))
  );
}
function instanceOfTableVisualTagData(e) {
  return (
    !!e &&
    "rules" in e &&
    "color" in e &&
    "tagIcon" in e &&
    "tagIconPosition" in e &&
    instanceOfTableVisualRules(e.rules)
  );
}
function instanceOfTableVisualTagDataArray(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualTagData(e))
  );
}
function instanceOfTableVisualSingleColorData(e) {
  var T, C;
  return (
    !!e &&
    "ruleGroup" in e &&
    "color" in e &&
    "bgColor" in e &&
    instanceOfTableVisualRules(
      null == (C = null == (T = e.ruleGroup.groups) ? void 0 : T[0])
        ? void 0
        : C.rules
    )
  );
}
function instanceOfTableVisualSingleColorDataArray(e) {
  return (
    Array.isArray(e) &&
    e.length > 0 &&
    e.every((e) => instanceOfTableVisualSingleColorData(e))
  );
}
function valuePercent(e, T, C) {
  return T === e ? (C >= T ? 1 : 0) : (C - e) / (T - e);
}
function linearInterpolations(e, T, C) {
  const $ = [];
  for (let F = 0; F < e.length; F++) $[F] = linearInterpolation(e[F], T[F], C);
  return $;
}
function linearInterpolation(e, T, C) {
  return e + (T - e) * C;
}
function getPropertyDefine(e) {
  return "function" == typeof e ? e : () => e;
}
function updatePropertyDefine(e, T) {
  return T && "function" == typeof e
    ? (C) => {
        const $ = e(C);
        return void 0 !== $ ? $ : getPropertyDefine(T)(C);
      }
    : getPropertyDefine(void 0 === e ? T : e);
}
const LABEL_COLOR_WHITE = "#ffffff",
  LABEL_COLOR_BLACK = "#141414",
  LABEL_L_THRESHOLD = 0.75,
  getDataValue = (e, T) => {
    var C;
    const { dataValue: $, col: F, row: V, grid: Y } = e;
    return T ? (null == (C = Y.getCellOriginRecord(F, V)) ? void 0 : C[T]) : $;
  };
var colorLevel = (e, T, C, $, F, V) => {
  var Y, K, J, ee, te;
  const { data: ie, excludeTotal: ne } = T,
    re =
      null != (K = null != (Y = ie.pillId) ? Y : e.indicatorKey) ? K : e.field,
    { fieldMap: ae } = V,
    oe = isNumberType(ae[re].type) ? "number" : "string",
    [se, le] = getColumnMinMax({
      field: re,
      records: $,
      valueType: oe,
      excludeTotal: ne,
      statistic:
        null == (J = null == V ? void 0 : V.statistics) ? void 0 : J[re],
    }),
    de = isNum(ie.min) ? ie.min : se,
    ce = isNum(ie.max) ? ie.max : le,
    ue = ce >= de ? ce : de,
    he = de < ce ? de : ce,
    pe = [he, ...ie.levels, ue],
    ge = (he + ue) / 2,
    fe = pe[pe.length - 1],
    me = pe[0],
    ye = (e) => {
      if (isExcludeTotalAndProcessingTotal(T, e)) return;
      const C = getDataValue(e, ie.pillId);
      return colorLevelFunc(ie, C, ge, me, fe, pe);
    };
  e.style = {
    ...e.style,
    bgColor: updatePropertyDefine(
      ye,
      null == (ee = e.style) ? void 0 : ee.bgColor
    ),
    color: updatePropertyDefine(
      ie.autoLabelColor
        ? (e) => {
            const T = ye(e);
            if (T) return getAutoLabelColor(T);
          }
        : (e) => {
            if (!isExcludeTotalAndProcessingTotal(T, e)) return ie.labelColor;
          },
      null == (te = e.style) ? void 0 : te.color
    ),
  };
};
const colorLevelFunc = (e, T, C, $, F, V) => {
    let Y = $,
      K = F;
    const J = Number(T);
    if (lodash.exports.isEmpty(T) || !isNum(J)) {
      if ("color" === e.emptyType) return e.emptyColor;
      if ("hidden" === e.emptyType) return;
    }
    if (J < Y) return e.colors[0];
    if (J > K) return e.colors[e.colors.length - 1];
    for (let ee = 1; ee < V.length; ee++) {
      const T = V[ee];
      if (((K = "median" === T ? C : T), J <= K)) {
        const T = valuePercent(Y, K, J);
        return `rgba(${linearInterpolations(
          chroma(e.colors[ee - 1]).rgba(),
          chroma(e.colors[ee]).rgba(),
          T
        )
          .map(Math.floor)
          .join(",")})`;
      }
      Y = K;
    }
  },
  getAutoLabelColor = (e) => {
    const [, , T] = chroma(e).hsl();
    return T >= LABEL_L_THRESHOLD ? LABEL_COLOR_BLACK : LABEL_COLOR_WHITE;
  };
var TableVisualType = ((e) => (
    (e.TAG = "tag"),
    (e.COLOR_LEVELS = "colorLevels"),
    (e.BAR = "bar"),
    (e.SINGLE_COLOR = "singleColor"),
    e
  ))(TableVisualType || {}),
  border = (e, { vizData: T }) => {
    const C = {},
      $ = T.displayConf,
      { border: F } = $;
    return (
      "display" === F &&
        ((C.gridLine = {
          visible: !0,
          color: "#D1D5DA",
          width: 1,
        }),
        (C.innerPadding = {
          ...e.innerPadding,
        })),
      {
        ...e,
        ...C,
      }
    );
  };
const MEASURE_CARD_NUMBER_LIMIT = 100,
  TagIconMap = {
    empty: "M Z",
    "icon-arrow-up":
      "M -0.2131 0.3515 C -0.2409 0.3813 -0.2876 0.383 -0.3174 0.3552 C -0.3472 0.3275 -0.3489 0.2808 -0.3212 0.251 L 0.1278 -0.2316 H -0.1576 C -0.1915 -0.2316 -0.2191 -0.2591 -0.2191 -0.293 V -0.3135 C -0.2191 -0.3475 -0.1915 -0.375 -0.1576 -0.375 H 0.3291 C 0.363 -0.375 0.3905 -0.3475 0.3905 -0.3135 L 0.3905 0.1731 C 0.3905 0.2071 0.363 0.2346 0.329 0.2346 H 0.3086 C 0.2746 0.2346 0.2471 0.2071 0.2471 0.1731 V -0.1432 L -0.2131 0.3515 Z",
    "icon-arrow-down":
      "M -0.205 -0.3495 C -0.2284 -0.3788 -0.2712 -0.3836 -0.3006 -0.3601 C -0.3299 -0.3366 -0.3347 -0.2938 -0.3112 -0.2645 L 0.0945 0.2427 H -0.1571 C -0.1884 0.2427 -0.2138 0.2681 -0.2138 0.2994 V 0.3183 C -0.2138 0.3496 -0.1884 0.375 -0.1571 0.375 H 0.2917 C 0.323 0.375 0.3484 0.3496 0.3484 0.3183 L 0.3484 -0.1305 C 0.3484 -0.1618 0.323 -0.1872 0.2917 -0.1872 H 0.2728 C 0.2415 -0.1872 0.2161 -0.1618 0.2161 -0.1305 V 0.1769 L -0.205 -0.3495 Z",
    "icon-right-strong":
      "M 0.095 0.2646 C 0.0728 0.2868 0.0728 0.3228 0.095 0.345 L 0.1084 0.3583 C 0.1306 0.3806 0.1666 0.3806 0.1888 0.3583 L 0.507 0.0402 C 0.5292 0.018 0.5292 -0.018 0.507 -0.0402 L 0.1888 -0.3584 C 0.1666 -0.3805 0.1306 -0.3805 0.1084 -0.3584 L 0.095 -0.345 C 0.0728 -0.3228 0.0728 -0.2868 0.095 -0.2646 L 0.2907 -0.0689 H -0.4091 C -0.4467 -0.0689 -0.4773 -0.0384 -0.4773 -0.0007 C -0.4773 0.037 -0.4467 0.0675 -0.4091 0.0675 H 0.2921 L 0.095 0.2646 Z",
    "icon-exclamation":
      "M -0.0341 -0.3125 a 0.0625 0.0625 90 0 1 0.0625 -0.0625 h 0 a 0.0625 0.0625 90 0 1 0.0625 0.0625 v 0.4375 a 0.0625 0.0625 90 0 1 -0.0625 0.0625 h 0 a 0.0625 0.0625 90 0 1 -0.0625 -0.0625 z M -0.0341 0.3125 a 0.0625 0.0625 90 1 0 0.125 0 a 0.0625 0.0625 90 1 0 -0.125 0 z",
    "icon-up-strong":
      "M 0.412 0.1499 C 0.424 0.1621 0.424 0.1817 0.412 0.1938 L 0.3788 0.2275 C 0.3665 0.2399 0.3466 0.2399 0.3343 0.2275 L 0.0393 -0.0712 C 0.027 -0.0836 0.007 -0.0836 -0.0052 -0.0712 L -0.3002 0.2275 C -0.3125 0.2399 -0.3325 0.2399 -0.3447 0.2275 L -0.3779 0.1938 C -0.39 0.1817 -0.39 0.1621 -0.3779 0.1499 L -0.0052 -0.2275 C 0.007 -0.2399 0.027 -0.2399 0.0393 -0.2275 L 0.412 0.1499 Z",
    "icon-down-strong":
      "M -0.3399 -0.1312 C -0.3505 -0.1418 -0.3505 -0.159 -0.3399 -0.1696 L -0.3109 -0.1991 C -0.3001 -0.2099 -0.2826 -0.2099 -0.2719 -0.1991 L -0.0138 0.0623 C -0.0031 0.0732 0.0144 0.0732 0.0251 0.0623 L 0.2833 -0.1991 C 0.294 -0.2099 0.3115 -0.2099 0.3222 -0.1991 L 0.3513 -0.1696 C 0.3618 -0.159 0.3618 -0.1418 0.3513 -0.1312 L 0.0251 0.1991 C 0.0144 0.2099 -0.0031 0.2099 -0.0138 0.1991 L -0.3399 -0.1312 Z",
    "icon-bar":
      "M -0.2989 -0.075 a 0.0125 0.0125 90 0 1 0.0125 -0.0125 h 0.675 a 0.0125 0.0125 90 0 1 0.0125 0.0125 v 0.1062 a 0.0125 0.0125 90 0 1 -0.0125 0.0125 h -0.675 a 0.0125 0.0125 90 0 1 -0.0125 -0.0125 z",
    "icon-circle":
      "M 0 0.3125 C 0.1726 0.3125 0.3125 0.1726 0.3125 0 C 0.3125 -0.1726 0.1726 -0.3125 0 -0.3125 C -0.1726 -0.3125 -0.3125 -0.1726 -0.3125 0 C -0.3125 0.1726 -0.1726 0.3125 0 0.3125 Z",
    "icon-triangle":
      "M -0.0487 -0.2568 L -0.3589 0.0867 C -0.3955 0.1272 -0.3657 0.1906 -0.3102 0.1906 H 0.3103 C 0.3227 0.1906 0.3349 0.1872 0.3453 0.1807 C 0.3558 0.1741 0.3641 0.1648 0.3692 0.1539 C 0.3744 0.1429 0.3761 0.1307 0.3743 0.1188 C 0.3725 0.1069 0.3672 0.0957 0.359 0.0867 L 0.0488 -0.2567 C 0.0427 -0.2634 0.0352 -0.2688 0.0268 -0.2725 C 0.0184 -0.2762 0.0093 -0.2781 0 -0.2781 C -0.0092 -0.2781 -0.0183 -0.2762 -0.0267 -0.2725 C -0.0351 -0.2688 -0.0426 -0.2634 -0.0487 -0.2567 V -0.2568 Z",
    "icon-sanjiao":
      "M 0.0884 0.2286 L 0.3986 -0.1148 C 0.4353 -0.1553 0.4055 -0.2188 0.3499 -0.2188 L -0.2705 -0.2188 C -0.2829 -0.2188 -0.2951 -0.2153 -0.3055 -0.2088 C -0.316 -0.2023 -0.3243 -0.193 -0.3294 -0.182 C -0.3346 -0.171 -0.3363 -0.1588 -0.3345 -0.1469 C -0.3327 -0.135 -0.3274 -0.1239 -0.3192 -0.1148 L -0.009 0.2286 C -0.0029 0.2353 0.0046 0.2407 0.013 0.2444 C 0.0214 0.2481 0.0305 0.25 0.0397 0.25 C 0.049 0.25 0.0581 0.2481 0.0665 0.2444 C 0.0749 0.2407 0.0824 0.2353 0.0884 0.2286 V 0.2286 Z",
    "icon-tailedarrow-up":
      "M 0.0408 -0.3918 C 0.0484 -0.3997 0.0611 -0.3997 0.0687 -0.3918 L 0.3583 -0.0908 C 0.3701 -0.0785 0.3614 -0.058 0.3443 -0.058 H -0.2349 C -0.2519 -0.058 -0.2606 -0.0785 -0.2488 -0.0908 L 0.0408 -0.3918 Z M -0.0613 -0.0967 a 0.0387 0.0387 90 0 1 0.0387 -0.0387 h 0.1548 a 0.0382 0.0382 90 0 1 0.0382 0.0382 v 0.4643 a 0.0382 0.0382 90 0 1 -0.0382 0.0382 h -0.1548 a 0.0382 0.0382 90 0 1 -0.0382 -0.0382 z",
    "icon-tailedarrow-down":
      "M 0.0588 0.3918 C 0.0512 0.3997 0.0385 0.3997 0.0309 0.3918 L -0.2587 0.0908 C -0.2705 0.0785 -0.2618 0.058 -0.2447 0.058 H 0.3345 C 0.3515 0.058 0.3602 0.0785 0.3484 0.0908 L 0.0588 0.3918 Z M -0.0716 -0.3658 a 0.0387 0.0387 90 0 1 0.0387 -0.0387 h 0.1548 a 0.0387 0.0387 90 0 1 0.0387 0.0387 v 0.4643 a 0.0387 0.0387 90 0 1 -0.0387 0.0387 h -0.1548 a 0.0387 0.0387 90 0 1 -0.0387 -0.0387 z",
  },
  TRANSPARENT_COLOR = "rgba(255,255,255,0)",
  getTagData = (e, T, C) => {
    const $ = C[e];
    return T.find((e) => isMatchRule(e.rules, $, C));
  },
  tagColorFunc = (e, T, C) => ($) => {
    var F;
    const V = getTagData(e, T, $);
    return null != (F = null == V ? void 0 : V.color) ? F : C;
  },
  tagShapeFunc = (e, T, C) => ($) => {
    var F;
    const V = getTagData(e, T, $);
    return V && null != (F = TagIconMap[V.tagIcon]) ? F : TagIconMap[C];
  },
  tagTextColorFunc = (e, T, C) => ($) => {
    var F;
    const V = getTagData(e, T, $);
    return null != (F = null == V ? void 0 : V.textColor) ? F : C;
  },
  onlyTagTextColorFunc = (e, T, C) => ($) =>
    getTagData(e, T, $) ? TRANSPARENT_COLOR : C,
  getSingleColorData = (e, T, C) =>
    e.find((e) => isMatchRuleGroup(e.ruleGroup, T, {}, C)),
  singleTextColorFunc = (e, T, C) => ($) => {
    var F;
    const V = getSingleColorData(e, $, T);
    return null != (F = null == V ? void 0 : V.color) ? F : C;
  },
  colorLevelBgColorFunc = (e, T, C, $) => {
    const F = T.map((T) => Number(T[e])).filter((e) => !isNaN(e)),
      V = "auto" === C.min || void 0 === C.min ? Math.min(...F) : Number(C.min),
      Y = "auto" === C.max || void 0 === C.max ? Math.max(...F) : Number(C.max),
      K = (V + Y) / 2,
      J = [V, ...C.levels, Y],
      ee = $[e];
    return colorLevelFunc(C, ee, K, V, Y, J);
  },
  getColorLevelAutoColor = (e, T, C, $) => {
    const F = Object.keys(e),
      V = C.value
        .filter((e) => F.includes(e))
        .map((T) => getOriginalMeasures(T, e, C)),
      Y = $.filter((e) => e.config.type === TableVisualType.COLOR_LEVELS);
    for (const { fields: K, config: J } of Y) {
      const $ = K.filter((e) => V.includes(e));
      if (0 === $.length) continue;
      const F = J.data,
        Y = getOriginalMeasures($[0], e, C),
        ee = colorLevelBgColorFunc(Y, T, F, e);
      return getAutoLabelColor(ee);
    }
  },
  getBackgroundColorFunc = (e, T, C) =>
    (null == C ? void 0 : C.length) > 0 &&
    (($) => {
      const F = e.cells[0],
        V = Object.keys($),
        Y = e.cells[0].value
          .filter((e) => V.includes(e))
          .map((e) => getOriginalMeasures(e, $, F));
      for (const { fields: K, config: J } of C) {
        const C = K.filter((e) => Y.includes(e));
        if (0 !== C.length)
          if (J.type === TableVisualType.SINGLE_COLOR) {
            const e = J.data.find((e) =>
              isMatchRuleGroup(e.ruleGroup, $, {}, C[0])
            );
            if (e) return e.bgColor;
          } else if (J.type === TableVisualType.COLOR_LEVELS) {
            const F = J.data,
              V = getOriginalMeasures(C[0], $, e.cells[0]);
            return colorLevelBgColorFunc(V, T, F, $);
          }
      }
    }),
  getMeasureCardSpacings = (e, T, C, $ = "loose", F) =>
    "tight" === $
      ? {
          titleSpacing: e.fontSize / 8 + T.nameSize / 8,
          indicatorKey: T.nameSize / 8 + T.valueSize / 8,
          indicatorValue: T.valueSize / 8 + C.nameSize / 8,
          secondarySpacing: C.nameSize / 4,
          indicatorTagSpacing: T.valueSize / 4,
          secondaryKeySpacing: C.valueSize,
          secondaryTagSpacing: C.valueSize / 2,
          paddingHorizontal: F > 1 ? 10 : 0,
          paddingVertical: F > 1 ? 10 : 0,
        }
      : "loose" === $
      ? {
          titleSpacing: e.fontSize / 4 + T.nameSize / 4,
          indicatorKey: T.nameSize / 4 + T.valueSize / 4,
          indicatorValue: T.valueSize / 4 + C.nameSize / 4,
          secondarySpacing: C.nameSize,
          indicatorTagSpacing: T.valueSize / 4,
          secondaryKeySpacing: C.valueSize,
          secondaryTagSpacing: C.valueSize / 2,
          paddingVertical: T.nameSize / 4 + T.valueSize / 4,
          paddingHorizontal: F > 1 ? 10 : 0,
        }
      : "wide" === $
      ? {
          titleSpacing: e.fontSize / 2 + T.nameSize / 2,
          indicatorKey: T.nameSize / 4 + T.valueSize / 4,
          indicatorValue: T.valueSize / 2 + C.nameSize / 2,
          secondarySpacing: C.nameSize,
          indicatorTagSpacing: T.valueSize / 4,
          secondaryKeySpacing: C.valueSize,
          secondaryTagSpacing: C.valueSize / 2,
          paddingVertical: T.nameSize / 4 + T.valueSize / 4,
          paddingHorizontal: F > 1 ? 10 : 0,
        }
      : void 0;
var conditionalFormat = (e, { vizData: T }) => {
    var C;
    const $ = T.displayConf,
      F = T.datasets.flat(3),
      V = T.cells[0],
      { conditionalFormat: Y } = $,
      K = lodash.exports.uniq(
        F.map((e) => getOriginalMeasures(V.value[0], e, V))
      ),
      J = [...(null != (C = e.secondaryIndicators) ? C : [])].filter(
        (e) => void 0 !== e
      ),
      ee = J.map((e) => e.field),
      te = e.indicatorField,
      ie = {},
      ne = {},
      re = {};
    K.forEach((e) => {
      const C = null == Y ? void 0 : Y.find(({ fields: T }) => T.includes(e));
      if (C) {
        const { config: $ } = C;
        if ($.type === TableVisualType.SINGLE_COLOR) {
          const T = $.data;
          ie[e] = singleTextColorFunc(T, e, te.valueStyle.color);
        } else if ($.type === TableVisualType.COLOR_LEVELS) {
          const C = $.data;
          ie[e] = (e) => {
            var $;
            const K = getOriginalMeasures(V.value[0], e, V),
              J = (null != ($ = e[V.group[0]]) ? $ : "") + K;
            if (C.autoLabelColor) {
              if (re[J]) return re[J];
              {
                const C = getColorLevelAutoColor(e, F, T.cells[0], Y);
                return C && (re[J] = C), C;
              }
            }
            return C.labelColor;
          };
        } else if ($.type === TableVisualType.TAG) {
          te.hasTag = !0;
          const T = {},
            C = $.data,
            F = null == C ? void 0 : C[0],
            V =
              !!(null == F ? void 0 : F.tagIconPosition) &&
              "none" !== F.tagIconPosition;
          T.hasTag = V;
          const Y =
            "right" === (null == F ? void 0 : F.tagIconPosition)
              ? "right"
              : "left";
          (T.tagPosition = Y),
            V &&
              ((T.fill = tagColorFunc(e, C, TRANSPARENT_COLOR)),
              (T.shape = tagShapeFunc(e, C, "empty"))),
            (ne[e] = T),
            "onlyTag" === (null == F ? void 0 : F.tagIconPosition)
              ? (ie[e] = onlyTagTextColorFunc(e, C, te.valueStyle.color))
              : (ie[e] = tagTextColorFunc(e, C, te.valueStyle.color));
        }
      }
    }),
      (te.valueStyle.normal = {
        fill: (e) => {
          const T = getOriginalMeasures(V.value[0], e, V),
            C = ie[T];
          return C ? C(e) : te.valueStyle.color;
        },
      }),
      (te.tagVisibleMethod = (e, T, C) => {
        const $ = getOriginalMeasures(V.value[0], C, V),
          F = ne[$];
        if (F) {
          const { hasTag: e } = F;
          return e;
        }
        return !1;
      }),
      (te.tagPositionMethod = (e, T, C) => {
        const $ = getOriginalMeasures(V.value[0], C, V),
          F = ne[$];
        if (F) {
          const { tagPosition: e } = F;
          return e;
        }
        return "left";
      });
    const { fontSize: ae } = te.valueStyle;
    (te.tagSpec = {
      normal: {
        size: ae,
        fill: (e) => {
          const T = getOriginalMeasures(V.value[0], e, V),
            C = ne[T];
          if (C && C.hasTag) {
            const { fill: T } = C;
            return T(e);
          }
          return TRANSPARENT_COLOR;
        },
        shape: (e) => {
          const T = getOriginalMeasures(V.value[0], e, V),
            C = ne[T];
          if (C && C.hasTag) {
            const { shape: T } = C;
            return T(e);
          }
          return "empty";
        },
      },
    }),
      J.forEach((e) => {
        const C =
          null == Y ? void 0 : Y.find(({ fields: T }) => T.includes(e.field));
        if (C) {
          const { config: $ } = C;
          if ($.type === TableVisualType.SINGLE_COLOR) {
            const T = $.data;
            e.valueStyle.normal = {
              fill: singleTextColorFunc(T, e.field, e.valueStyle.color),
            };
          } else if ($.type === TableVisualType.COLOR_LEVELS) {
            const C = $.data;
            e.valueStyle.normal = {
              fill: (e) => {
                var $;
                const K = getOriginalMeasures(V.value[0], e, V),
                  J = (null != ($ = e[V.group[0]]) ? $ : "") + K;
                if (C.autoLabelColor) {
                  if (re[J]) return re[J];
                  {
                    const C = getColorLevelAutoColor(e, F, T.cells[0], Y);
                    return C && (re[J] = C), C;
                  }
                }
                return C.labelColor;
              },
            };
          } else if ($.type === TableVisualType.TAG) {
            const T = $.data,
              C = null == T ? void 0 : T[0];
            if (
              ((e.hasTag =
                !!(null == C ? void 0 : C.tagIconPosition) &&
                "none" !== C.tagIconPosition),
              (e.tagPosition =
                "right" === (null == C ? void 0 : C.tagIconPosition)
                  ? "right"
                  : "left"),
              e.hasTag)
            ) {
              const { fontSize: C } = e.valueStyle;
              e.tagSpec = {
                normal: {
                  size: C,
                  fill: tagColorFunc(e.field, T, TRANSPARENT_COLOR),
                  shape: tagShapeFunc(e.field, T, "empty"),
                },
              };
            }
            "onlyTag" === (null == C ? void 0 : C.tagIconPosition)
              ? (e.valueStyle.normal = {
                  fill: onlyTagTextColorFunc(e.field, T, e.valueStyle.color),
                })
              : (e.valueStyle.normal = {
                  fill: tagTextColorFunc(e.field, T, e.valueStyle.color),
                });
          }
        }
      });
    return (
      [e.indicatorField, ...J]
        .filter((e) => void 0 === e.hasTag)
        .forEach((e) => {
          e.hasTag = !1;
        }),
      e.secondaryIndicators
        .filter((e) => e.hasTag && "left" === e.tagPosition)
        .forEach((T) => {
          const { field: C } = T;
          F.every((T) => {
            const $ = Object.keys(T);
            if ($.includes(C)) {
              const T = $.filter((e) => e !== C && ee.includes(e));
              if (T.length > 0)
                return (
                  T.forEach((T) => {
                    const C = e.secondaryIndicators.find((e) => e.field === T);
                    !1 === C.hasTag &&
                      ((C.hasTag = !0),
                      (C.tagPosition = "left"),
                      (C.tagSpec = {
                        normal: {
                          fill: TRANSPARENT_COLOR,
                        },
                      }));
                  }),
                  !1
                );
            }
            return !0;
          });
        }),
      (e.cardBackgroundColor = getBackgroundColorFunc(T, F, Y)),
      e
    );
  },
  dataset = (e, { vizData: T }) => ({
    ...e,
    data: [
      {
        name: "indicator",
        values: T.datasets[0][0][0].slice(0, MEASURE_CARD_NUMBER_LIMIT),
      },
    ],
  }),
  dimension = (e, { vizData: T }) => {
    var C, $;
    const F = {},
      V = T.displayConf,
      { dimension: Y = vizSchema.dimension, minorMeasure: K } = V,
      J = null != (C = T.cells[0].group) ? C : [];
    if (J.length > 0) {
      const e = J.flat()[0];
      F.title = {
        visible: Y.display,
        field: e,
        labelStyle: {
          fontSize: Y.fontSize,
          color: Y.fontColor,
        },
      };
    }
    const ee = T.datasets[0][0][0];
    if (ee.length > 1) {
      let T = Math.min(Y.columns, ee.length);
      K.ids && (T = Y.columns),
        (F.groupLayout = {
          ...e.groupLayout,
          column: T,
        });
    }
    return (
      (F.align = null != ($ = V.align) ? $ : "left"),
      {
        ...e,
        ...F,
      }
    );
  };
const INVALID_VALUE_MAP = {
  [SpecialValueType$1.BRACKET_TXT]: " ",
  [SpecialValueType$1.NULL]: "NULL",
  [SpecialValueType$1.ZERO]: "0",
  [SpecialValueType$1.DASH]: "--",
};
var formatter = (spec, { vizData: vizData, chartInstance: chartInstance }) => {
    var _a, _b;
    const displayConf = vizData.displayConf,
      invalidValue =
        null !=
        (_b = null == (_a = displayConf.specialValue) ? void 0 : _a.measures)
          ? _b
          : SpecialValueType$1.BRACKET_TXT,
      formatMethod = (key, value, mark) => {
        let _getOriginalMeasures, _getFieldFormat, _createFormatter;
        try {
          _getOriginalMeasures = getOriginalMeasures;
        } catch {
          _getOriginalMeasures = eval("getOriginalFields");
        }
        try {
          _getFieldFormat = getFieldFormat;
        } catch {
          _getFieldFormat = eval("getFieldFormat");
        }
        try {
          _createFormatter = createFormatter;
        } catch {
          _createFormatter = eval("createFormatter");
        }
        const cell = vizData.cells[0],
          field = _getOriginalMeasures(key, mark, cell),
          format = _getFieldFormat(field, vizData, "field"),
          curFormatter = _createFormatter(
            format,
            INVALID_VALUE_MAP[invalidValue]
          );
        return curFormatter(value);
      },
      MEASURE_VALUE_FORMATTER = "__AEOLUS_measure_value_formatter__";
    return (
      null == chartInstance ||
        chartInstance.registerFunction(MEASURE_VALUE_FORMATTER, formatMethod, {
          vizData: vizData,
          INVALID_VALUE_MAP: INVALID_VALUE_MAP,
          invalidValue: invalidValue,
        }),
      spec.indicatorField &&
        (spec.indicatorField.valueStyle.formatMethod = MEASURE_VALUE_FORMATTER),
      spec.indicatorFields &&
        spec.indicatorFields.forEach((e) => {
          e.valueStyle.formatMethod = MEASURE_VALUE_FORMATTER;
        }),
      spec.secondaryIndicators &&
        spec.secondaryIndicators.forEach((e) => {
          e.valueStyle.formatMethod = MEASURE_VALUE_FORMATTER;
        }),
      spec.title &&
        (spec.title.labelStyle.formatMethod = MEASURE_VALUE_FORMATTER),
      spec
    );
  },
  measure = (e, { vizData: T }) => {
    const C = {},
      $ = T.displayConf,
      {
        majorMeasure: F,
        minorMeasure: V,
        dimension: Y = measureCardDefaultConfig.dimension,
        gapMode: K,
      } = $,
      J = T.cells[0],
      ee = (null == e ? void 0 : e.type) || "indicator";
    let te = null,
      ie = null;
    "comparativeIndicator" === ee
      ? ((te = J.value.slice(0, 2)), (ie = J.value.slice(2)))
      : ((te = J.value.slice(0, 1)), (ie = J.value.slice(1)));
    const ne = (e) => T.fieldMap[e].alias,
      re = te.map((e, T) => ({
        field: e,
        keyVisible: F.showName,
        keyStyle: {
          fontSize: F.nameSize,
          fontWeight: 400,
          color: F.nameColor,
          formatMethod: (e, C, $) => {
            const F = getOriginalMeasures(J.value[T], $, J);
            return ne(F);
          },
        },
        valueStyle: {
          fontFamily: `Byte Number,${FONT_FAMILY}`,
          fontWeight: 400,
          fontSize: F.valueSize,
          color: F.valueColor,
        },
      }));
    if (
      ("comparativeIndicator" === ee
        ? (C.indicatorFields = re)
        : (C.indicatorField = re[0]),
      (C.secondaryIndicators = ie.map((e) => {
        const { nameSize: T, nameColor: C, valueSize: $, valueColor: F } = V;
        return {
          field: e,
          filterNull: !0,
          customName: ne(e),
          keyStyle: {
            fontSize: T,
            fontWeight: "normal",
            color: C,
          },
          valueStyle: {
            fontFamily: `Byte Number,${FONT_FAMILY}`,
            fontSize: $,
            fontWeight: "normal",
            color: F,
          },
        };
      })),
      "comparativeIndicator" === ee)
    )
      C.innerPadding = {
        titleSpacing: Y.fontSize / 8 + F.nameSize / 8,
        indicatorKey: F.nameSize / 8 + F.valueSize / 8,
        indicatorValue: F.valueSize / 8 + V.nameSize / 8,
        secondarySpacing: V.nameSize / 4,
        indicatorTagSpacing: F.valueSize / 4,
        secondaryKeySpacing: V.valueSize,
        secondaryTagSpacing: V.valueSize / 2,
      };
    else {
      const $ = T.datasets[0][0][0].length;
      (C.groupLayout = {
        ...e.groupLayout,
        horizontal: {
          padding: 0,
          spacing: 0,
        },
        vertical: {
          padding: 0,
          spacing: 0,
        },
      }),
        (C.innerPadding = getMeasureCardSpacings(Y, F, V, K, $));
    }
    return {
      ...e,
      ...C,
    };
  },
  mouseEvent = (e) => {
    const T = {
      scrollbar: [
        {
          orient: "right",
          consumeEvent: !1,
        },
        {
          orient: "indicator",
          consumeEvent: !1,
        },
      ],
    };
    return {
      ...e,
      ...T,
    };
  };
const measureCardPipes = {
  initial: {
    type: "indicator",
  },
  pipes: [
    measure,
    dataset,
    dimension,
    formatter,
    conditionalFormat,
    border,
    mouseEvent,
  ],
};
export {
  isPolarChart as $,
  isFunnelChart as A,
  isGauge as B,
  isLine as C,
  isOKRTable as D,
  isPivotTable as E,
  FONT_FAMILY as F,
  isRadarChart as G,
  isRawTable as H,
  isSankey as I,
  isScatter as J,
  isTable as K,
  LINE_NUMBER_COL_NAME as L,
  MAIN_SERIES_ID as M,
  isTrendTable as N,
  isAreaLikeChart as O,
  isBarLikeChart as P,
  isCartesianChart as Q,
  isHorizontalBar as R,
  SUB_SERIES_ID as S,
  TableVisualType as T,
  isLineLikeChart as U,
  isMapChart as V,
  isNonPivotTable as W,
  XYChartTypes as X,
  isPivot as Y,
  isPivotLikeTable as Z,
  isPivotableTotalChart as _,
  MAIN_REGION_ID as a,
  sankeyInteractive as a$,
  isSingleDimensionChart as a0,
  isSymbolLikeChart as a1,
  isTableChart as a2,
  isXYChart as a3,
  isPivotCombined as a4,
  getTotalPercentFormatter as a5,
  getTotalValueFormatter as a6,
  animation as a7,
  axisDimension as a8,
  axisMeasure as a9,
  crosshair as aA,
  datasets as aB,
  displayMode as aC,
  tableChartDisplayMode as aD,
  forecast as aE,
  isForecastPredRange as aF,
  gaugeData as aG,
  gaugeReverse as aH,
  gaugeExtensionMark as aI,
  gaugeIndicator as aJ,
  gaugeSection as aK,
  gaugeStyle as aL,
  initGauge as aM,
  buildSectionGoal as aN,
  buildSectionTick as aO,
  buildSectionTickLabel as aP,
  getSimpleTick as aQ,
  getSimpleTickEnd as aR,
  INVALID_VALUE_MAP$3 as aS,
  getFormatMethod as aT,
  getFormatMethodWithValue$1 as aU,
  barInteractive as aV,
  brush as aW,
  columnInteractive as aX,
  histogramInteractive as aY,
  mapInteractive as aZ,
  polarInteractive as a_,
  xyAxes$1 as aa,
  xyyAxes as ab,
  yxAxes as ac,
  yxxAxes as ad,
  yyAxes as ae,
  xAxes as af,
  yAxes as ag,
  gaugeAxis as ah,
  progressAxis as ai,
  radarAxis as aj,
  roseAxis as ak,
  barStyle as al,
  color as am,
  combinationIndicators as an,
  combinationRecords as ao,
  cartesian as ap,
  initCombination as aq,
  initFunnel as ar,
  initHistogram as as,
  initMap as at,
  initScatterMap as au,
  initMultiSeriesChart as av,
  polar as aw,
  initRadar as ax,
  initScatter as ay,
  initWordCloud as az,
  SUB_REGION_ID as b,
  trendStyle as b$,
  scatterInteractive as b0,
  multipleInteractive as b1,
  invalidType as b2,
  dataFilterCustomer$2 as b3,
  formatterCustomer$5 as b4,
  label as b5,
  labelCustomer$1 as b6,
  polarLabel as b7,
  radarLabel as b8,
  circleViewsLabel as b9,
  polarRadius as bA,
  initProgress as bB,
  progressData as bC,
  progressGoal as bD,
  progressIndicator as bE,
  progressSection as bF,
  progressStyle as bG,
  progressText as bH,
  initLiquid as bI,
  liquidData as bJ,
  liquidReverse as bK,
  liquidGoal as bL,
  liquidIndicator as bM,
  liquidStyle as bN,
  combinationReferenceLine as bO,
  referenceLine as bP,
  hierarchySankey as bQ,
  initSankey as bR,
  sankeyColor as bS,
  sankeyDimensionLabel as bT,
  combinationStack as bU,
  enableMeasureParallelList as bV,
  multiSeriesStack as bW,
  stack as bX,
  tableChartTheme as bY,
  theme$1 as bZ,
  tooltip as b_,
  scatterLabel as ba,
  sankeyLabel as bb,
  multiSeriesLabel as bc,
  combinationLabel as bd,
  funnelLabel as be,
  mapLabel as bf,
  scatterMapLabel as bg,
  bilateralLayout as bh,
  commonLayout as bi,
  legend as bj,
  mapLegend as bk,
  sankeyLegend as bl,
  scatterLegend as bm,
  scatterMapLegend as bn,
  tableChartLegend as bo,
  buildLegend as bp,
  partialSplit as bq,
  lineStyle as br,
  multipleLineStyle as bs,
  location as bt,
  scatterMapColor as bu,
  scatterMapSize as bv,
  percent as bw,
  pivot as bx,
  centerValue as by,
  polarMerge as bz,
  isMatchRuleGroup as c,
  Text$2 as c$,
  chartSpaceSizeToVChartSize as c0,
  getScatterSizeRange as c1,
  colorLevelFunc as c2,
  getAutoLabelColor as c3,
  RuleMatch as c4,
  instanceOfTableVisualBarData as c5,
  instanceOfTableVisualColorLevelsData as c6,
  instanceOfTableVisualRule as c7,
  instanceOfTableVisualRules as c8,
  instanceOfTableVisualSingleColorData as c9,
  BaseRenderContributionTime$1 as cA,
  parsePadding$1 as cB,
  getAttributeFromDefaultAttrList$1 as cC,
  ARC_NUMBER_TYPE$1 as cD,
  parseStroke$1 as cE,
  CIRCLE_NUMBER_TYPE$1 as cF,
  divideCubic$1 as cG,
  Direction$1 as cH,
  LINE_NUMBER_TYPE$1 as cI,
  calcLineCache$2 as cJ,
  divideLinear$1 as cK,
  AREA_NUMBER_TYPE$1 as cL,
  PATH_NUMBER_TYPE$1 as cM,
  RECT_NUMBER_TYPE$1 as cN,
  SYMBOL_NUMBER_TYPE$1 as cO,
  TEXT_NUMBER_TYPE$1 as cP,
  calculateLineHeight$1 as cQ,
  POLYGON_NUMBER_TYPE$1 as cR,
  GROUP_NUMBER_TYPE$1 as cS,
  IMAGE_NUMBER_TYPE$1 as cT,
  ResourceLoader$1 as cU,
  ARC3D_NUMBER_TYPE$1 as cV,
  GRAPHIC_UPDATE_TAG_KEY$1 as cW,
  Graphic$1 as cX,
  circleBounds$1 as cY,
  CustomPath2D$1 as cZ,
  NOWORK_ANIMATE_ATTR$1 as c_,
  instanceOfTableVisualSingleColorDataArray as ca,
  instanceOfTableVisualTagData as cb,
  instanceOfTableVisualTagDataArray as cc,
  isNum as cd,
  linearInterpolation as ce,
  linearInterpolations as cf,
  toNum as cg,
  valuePercent as ch,
  measureCardPipes as ci,
  TagIconMap as cj,
  Generator$1 as ck,
  application$1 as cl,
  DefaultTextAttribute$1 as cm,
  DefaultTextStyle$1 as cn,
  MeasureModeEnum as co,
  FederatedEvent$1 as cp,
  Group$2 as cq,
  Theme$1 as cr,
  getTheme$1 as cs,
  renderCommandList$1 as ct,
  interpolateColor$1 as cu,
  BoundsContext$1 as cv,
  boundStroke$1 as cw,
  GraphicCreator$2 as cx,
  textLayoutOffsetY$1 as cy,
  textDrawOffsetX$1 as cz,
  isCombined as d,
  CanvasTextLayout$1 as d0,
  SVG_PARSE_ATTRIBUTE_MAP_KEYS$1 as d1,
  SVG_PARSE_ATTRIBUTE_MAP$1 as d2,
  pointsInterpolation$1 as d3,
  DefaultImageAttribute$1 as d4,
  RICHTEXT_NUMBER_TYPE$1 as d5,
  DefaultRichTextAttribute$1 as d6,
  GraphicService$1 as d7,
  DefaultAttribute$1 as d8,
  defaultTimeline$1 as d9,
  TextMeasure as dA,
  genNumberType$1 as dB,
  IContainPointMode$1 as dC,
  ACustomAnimate$1 as dD,
  Animate$1 as dE,
  AABBBounds as dF,
  Logger as dG,
  degreeToRadian as dH,
  clamp$1 as dI,
  minInArray as dJ,
  maxInArray as dK,
  last as dL,
  Text$1 as dM,
  Group$1 as dN,
  DefaultTimeline$1 as da,
  createGroup$1 as db,
  createText$1 as dc,
  CustomEvent$1 as dd,
  DefaultFillStyle$1 as de,
  DefaultStrokeStyle$1 as df,
  rafBasedSto$1 as dg,
  isType$1 as dh,
  isNil$1 as di,
  isArrayLike$1 as dj,
  isString$1 as dk,
  isValid$1 as dl,
  isArray$1 as dm,
  isBoolean$1 as dn,
  isNumber$1 as dp,
  isFunction$1 as dq,
  RGB as dr,
  Color as ds,
  DEFAULT_COLORS as dt,
  hslToRgb as du,
  rgbToHsl as dv,
  Bounds as dw,
  arrayEqual as dx,
  isObject$1 as dy,
  isValidNumber$1 as dz,
  isMatchRule as e,
  colorLevel as f,
  getColumnMinMax as g,
  execPipeline as h,
  isExcludeTotalAndProcessingTotal as i,
  execPipelineAsync as j,
  getPipeline as k,
  pipelineAsync as l,
  isVChartInstance as m,
  isVTableChartInstance as n,
  isVTableInstance as o,
  pipeline as p,
  isVisActorInstance as q,
  LABEL_TYPES_FILTER_MAP as r,
  isMobile as s,
  isArea as t,
  updatePropertyDefine as u,
  isAreaPercent as v,
  isBilateral as w,
  isCircleViews as x,
  isCombination as y,
  isDualAxis as z,
};
