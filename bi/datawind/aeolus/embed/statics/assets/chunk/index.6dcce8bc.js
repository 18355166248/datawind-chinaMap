import { r as t, N as e } from "./index.es.020ae3ec.js";
import { p as i } from "./index.0e4302ed.js";
import {
  a as n,
  A as r,
  E as o,
  N as a,
  e as s,
} from "./emitEvent.61fdb922.js";
import {
  bh as l,
  ct as u,
  b1 as c,
  e6 as h,
  cV as p,
  eF as d,
  cx as f,
  i9 as g,
  ib as m,
  i2 as y,
  i8 as v,
  io as b,
  ij as x,
  cs as _,
  i as S,
  cw as M,
  ia as C,
  is as w,
  it as A,
  iy as E,
  iq as D,
  e7 as T,
  ic as P,
  cB as L,
  dq as I,
  hN as N,
} from "../entry/index.7886b0f6.js";
import { i as R } from "./invert.8c0ac90e.js";
import { G as O, a as F } from "./GhostElement.0a01c8ce.js";
import { E as z } from "./EntityHostElement.e9904ea6.js";
import "./typo.146e79ca.js";
import "./destroy.6bac23ca.js";
import "./removeTips.d0c4745f.js";
const { typo: k } = i,
  B = [
    "0,1",
    "-1,1",
    "0,10",
    "-10,10",
    "0,24",
    "1,60",
    "0,80",
    "0,100",
    "20,100",
    "-100,100",
    "0,300",
    "0,360",
    "-180,180",
    "-90,90",
  ],
  G = {};
function U(t) {
  if (!B.includes(t))
    throw new Error(
      `[vscreen-3d-charts] genStandardInputNumberConfig 传入 range ${t} 非法`
    );
  const e = G[t];
  if (e) return e;
  {
    const [e, i] = t.split(","),
      n = Number(e),
      r = Number(i),
      o = {
        min: n,
        max: r,
        step: j(n, r),
      };
    return (G[t] = o), o;
  }
}
function j(t, e) {
  return Math.abs(e - t) <= 20 ? 0.1 : 1;
}
function H(t) {
  const e = {
    key: "common",
    title_cn: "通用配置",
    title_en: "Common Config",
    type: n.Panel,
    layout: "top",
    properties: [
      {
        type: n.Number,
        title_cn: "最小可见区间",
        title_en: "zoomMin",
        layout_size: r.Medium,
        prefix: "text",
        icon_type: "axisDomainMin",
        key: "common.zoomMin",
        path: "common.zoomMin",
        ...U("0,24"),
      },
      {
        type: n.Number,
        title_cn: "最大可见区间",
        title_en: "zoomMax",
        layout_size: r.Medium,
        prefix: "text",
        icon_type: "axisDomainMax",
        key: "common.zoomMax",
        path: "common.zoomMax",
        ...U("0,24"),
      },
    ],
  };
  return (
    (null == t ? void 0 : t.showAllLevelData) &&
      e.properties.push({
        type: n.Boolean,
        title_cn: "展示全部层级数据",
        title_en: "show all level data",
        layout_size: r.Large,
        prefix: "text",
        key: "common.showAllLevelData",
        path: "common.showAllLevelData",
      }),
    e
  );
}
function V(t) {
  const e = {
    key: "poi",
    type: n.Panel,
    alias: o.CollapsePanel,
    properties: [
      {
        prefix: "text",
        layout_size: r.Large,
        title_cn: "标注",
        title_en: "poi",
        type: n.Boolean,
        key: "poi.enable",
        path: "poi.enable",
      },
      {
        type: n.Enum,
        title_cn: "显示方式",
        title_en: "Label Trigger",
        layout_size: r.Large,
        prefix: "text",
        alias: o.TitleSplitHalf,
        key: "poi.trigger",
        path: "poi.trigger",
        items: [
          {
            title_cn: "全显",
            title_en: "show",
            value: "show",
          },
          {
            title_cn: "单击",
            title_en: "click",
            value: "click",
          },
          {
            title_cn: "悬浮",
            title_en: "hover",
            value: "hover",
          },
        ],
      },
      {
        type: n.Enum,
        title_cn: "排列方式",
        title_en: "Label Orient",
        layout_size: r.Large,
        prefix: "text",
        alias: o.TitleSplitHalf,
        key: "poi.orient",
        path: "poi.orient",
        items: [
          {
            title_cn: "上下",
            title_en: "vertical",
            value: "vertical",
          },
          {
            title_cn: "左右",
            title_en: "horizontal",
            value: "horizontal",
          },
        ],
      },
      {
        type: n.Enum,
        title_cn: "对齐方式",
        title_en: "Label Alignment",
        layout_size: r.Large,
        prefix: "text",
        alias: o.TitleSplitHalf,
        key: "poi.alignment",
        path: "poi.alignment",
        items: [
          {
            title_cn: "顶部",
            title_en: "top",
            value: "top",
          },
          {
            title_cn: "居中",
            title_en: "middle",
            value: "middle",
          },
          {
            title_cn: "底部",
            title_en: "bottom",
            value: "bottom",
          },
        ],
      },
      {
        prefix: "text",
        type: n.Number,
        title_cn: "横向偏移",
        title_en: "offset x",
        layout_size: r.Medium,
        key: "poi.offsetX",
        path: "poi.offsetX",
        unit: "px",
      },
      {
        prefix: "text",
        type: n.Number,
        title_cn: "纵向偏移",
        title_en: "offset y",
        layout_size: r.Medium,
        key: "poi.offsetY",
        path: "poi.offsetY",
        unit: "px",
      },
      {
        prefix: "text",
        layout_size: r.Large,
        title_cn: "遮挡隐藏",
        title_en: "Text Cover Enable",
        type: n.Boolean,
        key: "poi.coverEnable",
        path: "poi.coverEnable",
      },
      {
        key: "poi.labelFontStyle",
        type: n.Panel,
        alias: o.CollapsePanel,
        properties: [
          {
            prefix: "text",
            layout_size: r.Large,
            title_cn: "主要标注",
            title_en: "major poi",
            type: n.Boolean,
            key: "poi.labelFontStyle.enable",
            path: "poi.labelFontStyle.enable",
          },
          {
            prefix: "icon",
            icon_type: "fontFamily",
            layout_size: r.Medium,
            ...k.fontFamily,
            key: "poi.labelFontStyle.fontFamily",
            path: "poi.labelFontStyle.fontFamily",
          },
          {
            prefix: "icon",
            icon_type: "fontWeight",
            layout_size: r.Medium,
            ...k.fontWeight,
            key: "poi.labelFontStyle.fontWeight",
            path: "poi.labelFontStyle.fontWeight",
          },
          {
            title_cn: "文字颜色",
            title_en: "Text Color",
            layout_size: "medium",
            type: n.Color,
            key: "poi.labelFontStyle.color",
            path: "poi.labelFontStyle.color",
          },
          {
            prefix: "icon",
            icon_type: "fontSize",
            layout_size: r.Medium,
            ...k.fontSize,
            key: "poi.labelFontStyle.fontSize",
            path: "poi.labelFontStyle.fontSize",
          },
          {
            type: n.String,
            title_cn: "前缀",
            title_en: "zoomMin",
            layout_size: r.Medium,
            prefix: "text",
            icon_type: "axisDomainMin",
            key: "poi.labelFontStyle.prefix",
            path: "poi.labelFontStyle.prefix",
          },
          {
            type: n.String,
            title_cn: "后缀",
            title_en: "zoomMax",
            layout_size: r.Medium,
            prefix: "text",
            icon_type: "axisDomainMax",
            key: "poi.labelFontStyle.suffix",
            path: "poi.labelFontStyle.suffix",
          },
          {
            type: n.Number,
            title_cn: "横向边距",
            title_en: "padding x",
            prefix: "text",
            layout_size: r.Medium,
            key: "poi.labelFontStyle.offsetX",
            path: "poi.labelFontStyle.offsetX",
            unit: "px",
            min: 0,
          },
          {
            type: n.Number,
            title_cn: "纵向边距",
            title_en: "padding y",
            prefix: "text",
            layout_size: r.Medium,
            key: "poi.labelFontStyle.offsetY",
            path: "poi.labelFontStyle.offsetY",
            unit: "px",
            min: 0,
          },
        ],
      },
      {
        key: "poi.valueFontStyle",
        type: n.Panel,
        alias: o.CollapsePanel,
        properties: [
          {
            prefix: "text",
            layout_size: r.Large,
            title_cn: "次要标注",
            title_en: "minor poi",
            type: n.Boolean,
            key: "poi.valueFontStyle.enable",
            path: "poi.valueFontStyle.enable",
          },
          {
            prefix: "icon",
            icon_type: "fontFamily",
            layout_size: r.Medium,
            ...k.fontFamily,
            key: "poi.valueFontStyle.fontFamily",
            path: "poi.valueFontStyle.fontFamily",
          },
          {
            prefix: "icon",
            icon_type: "fontWeight",
            layout_size: r.Medium,
            ...k.fontWeight,
            key: "poi.valueFontStyle.fontWeight",
            path: "poi.valueFontStyle.fontWeight",
          },
          {
            title_cn: "文字颜色",
            title_en: "Text Color",
            layout_size: r.Medium,
            type: n.Color,
            key: "poi.valueFontStyle.color",
            path: "poi.valueFontStyle.color",
          },
          {
            prefix: "icon",
            icon_type: "fontSize",
            layout_size: r.Medium,
            ...k.fontSize,
            key: "poi.valueFontStyle.fontSize",
            path: "poi.valueFontStyle.fontSize",
          },
          {
            type: n.String,
            title_cn: "前缀",
            title_en: "zoomMin",
            layout_size: r.Medium,
            prefix: "text",
            icon_type: "axisDomainMin",
            key: "poi.valueFontStyle.prefix",
            path: "poi.valueFontStyle.prefix",
          },
          {
            type: n.String,
            title_cn: "后缀",
            title_en: "zoomMax",
            layout_size: r.Medium,
            prefix: "text",
            icon_type: "axisDomainMax",
            key: "poi.valueFontStyle.suffix",
            path: "poi.valueFontStyle.suffix",
          },
          {
            type: n.Number,
            title_cn: "横向边距",
            title_en: "padding x",
            prefix: "text",
            layout_size: r.Medium,
            key: "poi.valueFontStyle.offsetX",
            path: "poi.valueFontStyle.offsetX",
            unit: "px",
            min: 0,
          },
          {
            type: n.Number,
            title_cn: "纵向边距",
            title_en: "padding y",
            prefix: "text",
            layout_size: r.Medium,
            key: "poi.valueFontStyle.offsetY",
            path: "poi.valueFontStyle.offsetY",
            unit: "px",
            min: 0,
          },
        ],
      },
      {
        key: "poi.background",
        type: n.Panel,
        title_cn: "标注背景",
        title_en: "poi background",
        properties: [
          {
            prefix: "text",
            layout_size: r.Large,
            title_cn: "背景色",
            title_en: "Background color",
            type: n.Color,
            key: "poi.background.color",
            path: "poi.background.color",
            alias: o.TitleSplitHalf,
          },
          {
            layout_size: r.Large,
            title_cn: "自定义上传贴图",
            title_en: "Image",
            type: n.Image,
            key: "poi.background.image",
            path: "poi.background.image",
          },
          {
            title_cn: "贴图不透明度",
            title_en: "Background Opacity",
            layout_size: r.Large,
            prefix: "text",
            type: n.Number,
            alias: o.TitleSplitHalf,
            key: "poi.background.opacity",
            path: "poi.background.opacity",
            ...U("0,1"),
          },
        ],
      },
      {
        key: "poi.background.shadow",
        type: n.Panel,
        title_cn: "内容阴影",
        title_en: "poi background shadow ",
        properties: [
          {
            prefix: "text",
            layout_size: r.Large,
            title_cn: "颜色",
            title_en: "Background color",
            type: n.Color,
            key: "poi.background.shadow.color",
            path: "poi.background.shadow.color",
            alias: o.TitleSplitHalf,
          },
          {
            title_cn: "模糊系数",
            title_en: "Shadow Blur",
            layout_size: r.Large,
            prefix: "text",
            type: n.Number,
            alias: o.TitleSplitHalf,
            key: "poi.background.shadow.blur",
            path: "poi.background.shadow.blur",
            min: 0,
            unit: "px",
          },
          {
            alias: "inputGroupWithTitle",
            title_cn: "阴影偏移",
            title_en: "Offset",
            layout_size: r.Large,
            key: "poi.background.shadow.offset",
            properties: [
              {
                type: n.Number,
                title_cn: "横向偏移",
                title_en: "offset x",
                layout_size: r.Small,
                key: "poi.background.shadow.offsetX",
                path: "poi.background.shadow.offsetX",
                unit: "px",
              },
              {
                type: n.Number,
                title_cn: "纵向偏移",
                title_en: "offset y",
                layout_size: r.Small,
                key: "poi.background.shadow.offsetY",
                path: "poi.background.shadow.offsetY",
                unit: "px",
              },
            ],
          },
        ],
      },
      {
        key: "poi.background.padding",
        type: n.Panel,
        title_cn: "内容边距",
        title_en: "poi background padding",
        properties: [
          {
            key: "poi.background.padding.top",
            path: "poi.background.padding.top",
            type: n.Number,
            title_cn: "上",
            title_en: "padding top",
            layout_size: r.Medium,
            min: 0,
            prefix: "text",
            unit: "px",
          },
          {
            key: "poi.background.padding.right",
            path: "poi.background.padding.right",
            type: n.Number,
            title_cn: "右",
            title_en: "padding right",
            layout_size: r.Medium,
            min: 0,
            prefix: "text",
            unit: "px",
          },
          {
            key: "poi.background.padding.bottom",
            path: "poi.background.padding.bottom",
            type: n.Number,
            title_cn: "下",
            title_en: "padding bottom",
            layout_size: r.Medium,
            min: 0,
            prefix: "text",
            unit: "px",
          },
          {
            key: "poi.background.padding.left",
            path: "poi.background.padding.left",
            type: n.Number,
            title_cn: "左",
            title_en: "padding left",
            layout_size: r.Medium,
            min: 0,
            prefix: "text",
            unit: "px",
          },
        ],
      },
      {
        key: "poi.background.borderRadius",
        type: n.Panel,
        title_cn: "边框圆角",
        title_en: "poi background borderRadius ",
        properties: [
          {
            key: "poi.background.borderRadius.topLeft",
            path: "poi.background.borderRadius.topLeft",
            type: n.Number,
            title_cn: "左上",
            title_en: "border top left radius",
            layout_size: r.Medium,
            prefix: "text",
            min: 0,
            unit: "px",
          },
          {
            key: "poi.background.borderRadius.topRight",
            path: "poi.background.borderRadius.topRight",
            type: n.Number,
            title_cn: "右上",
            title_en: "border top right radius",
            layout_size: r.Medium,
            prefix: "text",
            min: 0,
            unit: "px",
          },
          {
            key: "poi.background.borderRadius.bottomRight",
            path: "poi.background.borderRadius.bottomRight",
            type: n.Number,
            title_cn: "右下",
            title_en: "border bottom right radius",
            layout_size: r.Medium,
            prefix: "text",
            min: 0,
            unit: "px",
          },
          {
            key: "poi.background.borderRadius.bottomLeft",
            path: "poi.background.borderRadius.bottomLeft",
            type: n.Number,
            title_cn: "左下",
            title_en: "border bottom left radius",
            layout_size: r.Medium,
            prefix: "text",
            min: 0,
            unit: "px",
          },
        ],
      },
    ],
  };
  return (
    (null == t ? void 0 : t.hasAnchor) &&
      e.properties.splice(2, 0, {
        type: n.Enum,
        title_cn: "相对位置",
        title_en: "Label Anchor",
        layout_size: r.Large,
        prefix: "text",
        alias: o.TitleSplitHalf,
        key: "poi.anchor",
        path: "poi.anchor",
        items: [
          {
            title_cn: "顶部",
            title_en: "top",
            value: "top",
          },
          {
            title_cn: "居中",
            title_en: "middle",
            value: "middle",
          },
          {
            title_cn: "底部",
            title_en: "bottom",
            value: "bottom",
          },
        ],
      }),
    e
  );
}
const W = [
    H(),
    {
      key: "surface",
      type: n.Panel,
      properties: [
        {
          key: "surface.image",
          layout_size: r.Large,
          title_cn: "贴图",
          title_en: "Image",
          type: n.Image,
          path: "surface.image",
        },
        {
          type: n.Number,
          title_cn: "宽度",
          title_en: "Width",
          layout_size: r.Medium,
          prefix: "icon",
          icon_type: "columnWidth",
          key: "surface.width",
          path: "surface.width",
          ...U("0,300"),
        },
        {
          type: n.Number,
          title_cn: "高度",
          title_en: "Height",
          layout_size: r.Medium,
          prefix: "icon",
          icon_type: "height",
          key: "surface.height",
          path: "surface.height",
          ...U("0,300"),
        },
        {
          key: "surface.opacity",
          title_cn: "不透明度",
          title_en: "Opacity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.RangeInput,
          path: "surface.opacity",
          ...U("0,100"),
        },
        {
          key: "surface.offsetX",
          type: n.Number,
          title_cn: "横向偏移",
          title_en: "Offset X",
          layout_size: r.Medium,
          prefix: "text",
          path: "surface.offsetX",
          ...U("-100,100"),
        },
        {
          key: "surface.offsetY",
          type: n.Number,
          title_cn: "纵向偏移",
          title_en: "Offset Y",
          layout_size: r.Medium,
          prefix: "text",
          path: "surface.offsetY",
          ...U("-100,100"),
        },
        {
          key: "surface.offsetZ",
          type: n.Number,
          title_cn: "垂直偏移",
          title_en: "Offset Z",
          layout_size: r.Medium,
          prefix: "text",
          path: "surface.offsetZ",
          ...U("-100,100"),
        },
      ],
    },
    {
      key: "rotate",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "rotate.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "旋转动画",
          title_en: "Rotate",
          type: n.Boolean,
          path: "rotate.enable",
        },
        {
          key: "rotate.speed",
          title_cn: "旋转速度",
          title_en: "Speed",
          layout_size: r.Large,
          prefix: "text",
          alias: o.RangeInput,
          path: "rotate.speed",
          ...U("-100,100"),
        },
      ],
    },
  ],
  q = [
    H(),
    {
      key: "display",
      type: n.Panel,
      properties: [
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "display.image",
          path: "display.image",
        },
        {
          key: "display.size",
          type: n.Number,
          title_cn: "粒子尺寸",
          title_en: "Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "display.size",
          ...U("0,100"),
        },
        {
          key: "display.count",
          type: n.Number,
          title_cn: "粒子数量",
          title_en: "Count",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "display.count",
          ...U("0,100"),
        },
        {
          key: "scope",
          title_cn: "粒子范围",
          title_en: "Scope",
          type: n.Panel,
          properties: [
            {
              type: n.Number,
              title_cn: "区域长度",
              title_en: "Length",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.length",
              path: "scope.length",
              ...U("0,300"),
            },
            {
              type: n.Number,
              title_cn: "区域宽度",
              title_en: "Width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.width",
              path: "scope.width",
              ...U("0,300"),
            },
            {
              type: n.Number,
              title_cn: "区域高度",
              title_en: "Height",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.height",
              path: "scope.height",
              ...U("0,300"),
            },
          ],
        },
        {
          key: "animation",
          title_cn: "动画配置",
          title_en: "Animation",
          type: n.Panel,
          properties: [
            {
              type: n.Number,
              title_cn: "最小垂直运动速度",
              title_en: "Min Speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "animation.speedMin",
              path: "animation.speedMin",
              ...U("-100,100"),
            },
            {
              type: n.Number,
              title_cn: "最大垂直运动速度",
              title_en: "Max Speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "animation.speedMax",
              path: "animation.speedMax",
              ...U("-100,100"),
            },
          ],
        },
      ],
    },
  ],
  Y = [
    H(),
    {
      key: "display",
      type: n.Panel,
      properties: [
        {
          key: "display.width",
          type: n.Number,
          title_cn: "字符宽度",
          title_en: "Width",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "display.width",
          ...U("0,100"),
        },
        {
          key: "display.height",
          type: n.Number,
          title_cn: "字符高度",
          title_en: "Height",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "display.height",
          ...U("0,100"),
        },
        {
          key: "display.count",
          type: n.Number,
          title_cn: "字符数量",
          title_en: "Count",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "display.count",
          ...U("0,100"),
        },
        {
          key: "scope",
          title_cn: "字符范围",
          title_en: "Scope",
          type: n.Panel,
          properties: [
            {
              type: n.Number,
              title_cn: "区域长度",
              title_en: "Length",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.length",
              path: "scope.length",
              ...U("0,300"),
            },
            {
              type: n.Number,
              title_cn: "区域宽度",
              title_en: "Width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.width",
              path: "scope.width",
              ...U("0,300"),
            },
            {
              type: n.Number,
              title_cn: "区域高度",
              title_en: "Height",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "scope.height",
              path: "scope.height",
              ...U("0,300"),
            },
          ],
        },
        {
          key: "animation",
          title_cn: "动画配置",
          title_en: "Animation",
          type: n.Panel,
          properties: [
            {
              key: "animation.flashSpeed",
              type: n.Number,
              title_cn: "刷新速度",
              title_en: "Flash Speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              path: "animation.flashSpeed",
              ...U("0,100"),
            },
            {
              type: n.Number,
              title_cn: "最小垂直运动速度",
              title_en: "Min Speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "animation.speedMin",
              path: "animation.speedMin",
              ...U("0,100"),
            },
            {
              type: n.Number,
              title_cn: "最大垂直运动速度",
              title_en: "Max Speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "animation.speedMax",
              path: "animation.speedMax",
              ...U("0,100"),
            },
          ],
        },
      ],
    },
  ],
  { typo: X } = i,
  Q = {
    key: "tips",
    title_cn: "图表异常信息提示",
    title_en: "Tips",
    type: n.Panel,
    properties: [
      {
        key: "tips.backgroundColor",
        prefix: "text",
        layout_size: r.Large,
        title_cn: "背景颜色",
        title_en: "Background Color",
        type: n.Color,
        alias: o.TitleSplitHalf,
        path: "tips.backgroundColor",
      },
      {
        key: "tips.fontFamily",
        prefix: "icon",
        icon_type: "fontFamily",
        layout_size: r.Medium,
        title_cn: "字体",
        title_en: "Font Family",
        path: "tips.fontFamily",
        items: [],
        alias: o.FontFamily,
      },
      {
        key: "tips.fontWeight",
        prefix: "icon",
        icon_type: "fontWeight",
        layout_size: r.Medium,
        title_cn: "字重",
        title_en: "Font Weight",
        type: n.Enum,
        items: [
          "100",
          "200",
          "300",
          "400",
          "500",
          "600",
          "bold",
          "bolder",
          "normal",
        ].map((t) => ({
          value: t,
          title_en: t,
          title_cn: t,
        })),
        path: "tips.fontWeight",
      },
      {
        key: "tips.fontSize",
        prefix: "icon",
        icon_type: "fontSize",
        layout_size: r.Medium,
        title_cn: "字号",
        title_en: "Font Size",
        type: n.Number,
        min: 1,
        max: 1e3,
        mode: a.INTEGER,
        unit: "px",
        alias: o.FontSize,
        path: "tips.fontSize",
      },
      {
        key: "tips.color",
        layout_size: r.Medium,
        title_cn: "文字颜色",
        title_en: "Text Color",
        type: n.Color,
        path: "tips.color",
      },
    ],
  },
  Z = [
    {
      key: "viewport",
      title_cn: "视图配置",
      title_en: "Viewport",
      type: n.Panel,
      properties: [
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "经度",
          title_en: "center lng",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLng",
          path: "viewport.centerLng",
          ...U("-180,180"),
        },
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "纬度",
          title_en: "center lat",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLat",
          path: "viewport.centerLat",
          ...U("-90,90"),
        },
        {
          title_cn: "旋转角度",
          title_en: "rotation",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minRotation",
          maxPath: "viewport.maxRotation",
          key: "viewport.rotation",
          path: "viewport.rotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最小旋转角度",
          title_en: "min rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minRotation",
          path: "viewport.minRotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最大旋转角度",
          title_en: "max rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxRotation",
          path: "viewport.maxRotation",
          ...U("-90,90"),
        },
        {
          key: "viewport.pitch",
          title_cn: "倾斜角度",
          title_en: "pitch",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minPitch",
          maxPath: "viewport.maxPitch",
          path: "viewport.pitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最小倾斜角度",
          title_en: "min pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minPitch",
          path: "viewport.minPitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最大倾斜角度",
          title_en: "max pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxPitch",
          path: "viewport.maxPitch",
          ...U("0,80"),
        },
        {
          key: "viewport.zoom",
          title_cn: "缩放层级",
          title_en: "zoom",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minZoom",
          maxPath: "viewport.maxZoom",
          path: "viewport.zoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最小缩放层级",
          title_en: "min zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minZoom",
          path: "viewport.minZoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最大缩放层级",
          title_en: "max zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxZoom",
          path: "viewport.maxZoom",
          ...U("0,24"),
        },
      ],
    },
    {
      key: "gesture",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "手势交互",
          title_en: "Gesture Enable",
          type: n.Boolean,
          key: "interaction.sceneChangeEnable",
          path: "interaction.sceneChangeEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可缩放",
          title_en: "Zoom Enable",
          type: n.Boolean,
          key: "interaction.zoomEnable",
          path: "interaction.zoomEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可平移",
          title_en: "Translation Enable",
          type: n.Boolean,
          key: "interaction.translationEnable",
          path: "interaction.translationEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可倾斜",
          title_en: "Pitch Enable",
          type: n.Boolean,
          key: "interaction.pitchEnable",
          path: "interaction.pitchEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可旋转",
          title_en: "Rotation Enable",
          type: n.Boolean,
          key: "interaction.rotationEnable",
          path: "interaction.rotationEnable",
        },
      ],
    },
    {
      type: n.Panel,
      key: "data-region",
      properties: [
        {
          key: "data.custom.data",
          layout_size: r.Large,
          alias: o.TitleSplitHalf,
          title_cn: "地图数据",
          title_en: "Map Data",
          tag: "panel",
          type: "mapFile",
          path: "data.custom.data",
        },
        {
          key: "data.region",
          path: "data.region",
          alias: o.TitleSplitHalf,
          layout_size: r.Large,
          title_cn: "大区配置",
          title_en: "Initial Type",
          type: "mapRegionModal",
          tag: "panel",
        },
      ],
    },
    {
      key: "baseMapLayer",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "行政地图",
          title_en: "baseMapLayer show",
          type: n.Boolean,
          key: "baseMapLayer.show",
          path: "baseMapLayer.show",
        },
        {
          key: "districtOutline",
          title_cn: "外描边",
          title_en: "District Outline",
          type: n.Panel,
          properties: [
            {
              key: "districtOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "districtOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "districtOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "districtOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "districtOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "mapStyle.borderColor",
            },
          ],
        },
        {
          key: "provinceOutline",
          title_cn: "内描边",
          title_en: "Province Outline",
          type: n.Panel,
          properties: [
            {
              key: "provinceOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "provinceOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "provinceOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "provinceOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "provinceOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "provinceOutline.borderColor",
            },
          ],
        },
        {
          key: "innerShadow",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边发光",
              title_en: "innerShadow",
              type: n.Boolean,
              key: "innerShadow.enable",
              path: "innerShadow.enable",
            },
            {
              key: "innerShadow.width",
              path: "innerShadow.width",
              type: n.Number,
              title_cn: "发散范围",
              title_en: "innerShadow width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,1"),
            },
            {
              key: "innerShadow.color",
              path: "innerShadow.color",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "发光颜色",
              title_en: "innerShadow color",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "boundaryStreamer",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边流光",
              title_en: "boundaryStreamer",
              type: n.Boolean,
              key: "boundaryStreamer.enable",
              path: "boundaryStreamer.enable",
            },
            {
              key: "boundaryStreamer.length",
              path: "boundaryStreamer.length",
              type: n.Number,
              title_cn: "流光长度",
              title_en: "boundaryStreamer length",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.width",
              path: "boundaryStreamer.width",
              type: n.Number,
              title_cn: "流光宽度",
              title_en: "boundaryStreamer width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.speed",
              path: "boundaryStreamer.speed",
              type: n.Number,
              title_cn: "流光速度",
              title_en: "boundaryStreamer speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("-100,100"),
            },
            {
              key: "boundaryStreamer.headColor",
              path: "boundaryStreamer.headColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "头部颜色",
              title_en: "boundaryStreamer headColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
            {
              key: "boundaryStreamer.endColor",
              path: "boundaryStreamer.endColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "尾部颜色",
              title_en: "boundaryStreamer endColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "extrude",
          type: n.Panel,
          title_cn: "地图厚度",
          title_en: "Extrude",
          properties: [
            {
              key: "extrude.topColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "顶部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.topColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.bottomColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "底部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.bottomColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.height",
              path: "extrude.height",
              title_cn: "厚度",
              title_en: "Height",
              layout_size: r.Large,
              prefix: "text",
              type: n.Number,
              alias: o.TitleSplitHalf,
              ...U("0,10"),
            },
            {
              key: "mapStyle",
              title_cn: "填充样式",
              title_en: "Map display",
              type: n.Panel,
              properties: [
                {
                  key: "mapStyle.backgroundColor",
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "填充色",
                  title_en: "Background color",
                  type: n.Color,
                  path: "mapStyle.backgroundColor",
                  alias: o.TitleSplitHalf,
                },
                {
                  key: "mapStyle.metalness",
                  path: "mapStyle.metalness",
                  title_cn: "金属质感",
                  title_en: "metalness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  key: "mapStyle.roughness",
                  path: "mapStyle.roughness",
                  title_cn: "粗糙程度",
                  title_en: "roughness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  type: n.Panel,
                  key: "mapStyle-image",
                  properties: [
                    {
                      key: "mapStyle-image-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-image-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.backgroundType",
                          path: "mapStyle.backgroundType",
                        },
                        {
                          key: "mapStyle-image-tab-1",
                          type: n.Panel,
                          title_cn: "填充贴图",
                          title_en: "Background image",
                          properties: [
                            {
                              key: "mapStyle.backgroundImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "Background image",
                              type: "image",
                              path: "mapStyle.backgroundImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-image-tab-2",
                          type: n.Panel,
                          title_cn: "填充瓦片服务",
                          title_en: "Background tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.backgroundTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "Background tile",
                              path: "mapStyle.backgroundTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle-tile-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-tile-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.normalType",
                          path: "mapStyle.normalType",
                        },
                        {
                          key: "mapStyle-tile-tab-1",
                          type: n.Panel,
                          title_cn: "法线贴图",
                          title_en: "Normal image",
                          properties: [
                            {
                              key: "mapStyle.normalImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "normal image",
                              type: "image",
                              path: "mapStyle.normalImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-tile-tab-2",
                          type: n.Panel,
                          title_cn: "法线瓦片服务",
                          title_en: "Normal Tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.normalTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "normal tile",
                              path: "mapStyle.normalTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle.normalScale",
                      path: "mapStyle.normalScale",
                      title_cn: "法线强度",
                      title_en: "normalScale",
                      layout_size: r.Large,
                      prefix: "text",
                      type: n.Number,
                      alias: o.TitleSplitHalf,
                      ...U("0,100"),
                    },
                  ],
                },
                {
                  key: "mapStyle.fontStyle",
                  title_cn: "标注文本",
                  title_en: "Font style",
                  type: n.Panel,
                  alias: o.Typography,
                  properties: [
                    {
                      key: "mapStyle.fontStyle.fontFamily",
                      prefix: "icon",
                      icon_type: "fontFamily",
                      layout_size: r.Medium,
                      ...X.fontFamily,
                      path: "mapStyle.fontStyle.fontFamily",
                    },
                    {
                      key: "mapStyle.fontStyle.fontWeight",
                      prefix: "icon",
                      icon_type: "fontWeight",
                      layout_size: r.Medium,
                      ...X.fontWeight,
                      path: "mapStyle.fontStyle.fontWeight",
                    },
                    {
                      key: "mapStyle.fontStyle.color",
                      layout_size: r.Medium,
                      ...X.textColor,
                      path: "mapStyle.fontStyle.color",
                    },
                    {
                      key: "mapStyle.fontStyle.fontSize",
                      prefix: "icon",
                      icon_type: "fontSize",
                      layout_size: r.Medium,
                      ...X.fontSize,
                      path: "mapStyle.fontStyle.fontSize",
                    },
                  ],
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "展示标注文本",
                  title_en: "Label Enable",
                  type: n.Boolean,
                  key: "mapStyle.labelEnable",
                  path: "mapStyle.labelEnable",
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "文字遮挡隐藏",
                  title_en: "Text Cover Enable",
                  type: n.Boolean,
                  key: "mapStyle.coverEnable",
                  path: "mapStyle.coverEnable",
                },
              ],
            },
          ],
        },
      ],
    },
    {
      key: "componentBackground",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "componentBackground.hasColor",
          path: "componentBackground.hasColor",
          prefix: "text",
          title_cn: "背景填充",
          title_en: "componentBackground hasColor",
          type: n.Boolean,
        },
        {
          key: "componentBackground.backgroundColor",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "背景颜色",
          title_en: "Background color",
          path: "componentBackground.backgroundColor",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    {
      key: "light",
      title_cn: "光照阴影",
      title_en: "Light & Shadow",
      type: n.Panel,
      properties: [
        {
          key: "light.ambient.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "环境光颜色",
          title_en: "Ambient color",
          path: "light.ambient.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.ambient.intensity",
          type: n.Number,
          title_cn: "环境光强度",
          title_en: "Ambient Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.ambient.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "平行光颜色",
          title_en: "Directional color",
          path: "light.directional.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.directional.intensity",
          type: n.Number,
          title_cn: "平行光强度",
          title_en: "Directional Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.x",
          type: n.Number,
          title_cn: "平行光源位置X",
          title_en: "Directional X",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.x",
          ...U("-1,1"),
        },
        {
          key: "light.directional.y",
          type: n.Number,
          title_cn: "平行光源位置Y",
          title_en: "Directional Y",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.y",
          ...U("-1,1"),
        },
        {
          key: "light.directional.z",
          type: n.Number,
          title_cn: "平行光源位置Z",
          title_en: "Directional Z",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.z",
          ...U("0,1"),
        },
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "开启阴影",
          title_en: "Shadow Enable",
          type: n.Boolean,
          key: "light.shadow.enabled",
          path: "light.shadow.enabled",
        },
        {
          key: "light.shadow.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "阴影颜色",
          title_en: "Shadow color",
          path: "light.shadow.color",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    {
      key: "amap",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "高德底图",
          title_en: "AMap",
          type: n.Boolean,
          key: "amap.enable",
          path: "amap.enable",
        },
        {
          type: n.Panel,
          key: "amap-config",
          properties: [
            {
              key: "amap-style",
              tag: "panel",
              alias: "mapDataTab",
              path: "amap-style",
              layout_size: r.Large,
              properties: [
                {
                  key: "amap.type",
                  path: "amap.type",
                },
                {
                  key: "amap.default",
                  type: n.Panel,
                  title_cn: "标准模版",
                  properties: [
                    {
                      key: "amap.style",
                      path: "amap.style",
                      title_cn: "样式主题",
                      title_en: "AMap style",
                      type: n.Enum,
                      prefix: "text",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      items: [
                        {
                          title_cn: "幻影黑",
                          title_en: "AMap style dark",
                          value: "dark",
                        },
                        {
                          title_cn: "极夜蓝",
                          title_en: "AMap style darkblue",
                          value: "darkblue",
                        },
                        {
                          title_cn: "雅士灰",
                          title_en: "AMap style grey",
                          value: "grey",
                        },
                        {
                          title_cn: "草色青",
                          title_en: "AMap style fresh",
                          value: "fresh",
                        },
                        {
                          title_cn: "月光银",
                          title_en: "AMap style light",
                          value: "light",
                        },
                      ],
                    },
                  ],
                },
                {
                  key: "amap.custom",
                  type: n.Panel,
                  title_cn: "自定义",
                  properties: [
                    {
                      type: n.String,
                      key: "amap.custom.key",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "高德Key",
                      title_en: "AMap Key",
                      path: "amap.custom.key",
                    },
                    {
                      type: n.String,
                      key: "amap.custom.securityJsCode",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "高德安全密钥",
                      title_en: "AMap SecurityJsCode",
                      path: "amap.custom.securityJsCode",
                    },
                    {
                      type: n.String,
                      key: "amap.custom.id",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "样式ID",
                      title_en: "Style ID",
                      path: "amap.custom.id",
                    },
                  ],
                },
              ],
            },
            {
              key: "amap.content",
              title_cn: "内容控制",
              title_en: "AMap content",
              type: n.Panel,
              alias: o.Typography,
              properties: [
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "文字标注",
                  title_en: "AMap label",
                  type: n.Boolean,
                  key: "amap.content.label",
                  path: "amap.content.label",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "基础地图",
                  title_en: "AMap nebula",
                  type: n.Boolean,
                  key: "amap.content.nebula",
                  path: "amap.content.nebula",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "道路网络",
                  title_en: "AMap roadnet",
                  type: n.Boolean,
                  key: "amap.content.roadnet",
                  path: "amap.content.roadnet",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "实时交通",
                  title_en: "AMap roadnet",
                  type: n.Boolean,
                  key: "amap.content.traffic",
                  path: "amap.content.traffic",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "3D建筑",
                  title_en: "AMap buildings",
                  type: n.Boolean,
                  key: "amap.content.buildings",
                  path: "amap.content.buildings",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "3D地形",
                  title_en: "AMap terrain",
                  type: n.Boolean,
                  key: "amap.content.terrain",
                  path: "amap.content.terrain",
                },
              ],
            },
          ],
        },
        {
          key: "amap.filter",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Medium,
              title_cn: "风格滤镜",
              title_en: "Filter",
              type: n.Boolean,
              key: "amap.filter.enable",
              path: "amap.filter.enable",
            },
            {
              key: "amap.filter.brightness",
              path: "amap.filter.brightness",
              type: n.Number,
              title_cn: "亮度",
              title_en: "brightness",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.contrast",
              path: "amap.filter.contrast",
              type: n.Number,
              title_cn: "对比度",
              title_en: "contrast",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.grayscale",
              path: "amap.filter.grayscale",
              type: n.Number,
              title_cn: "灰度",
              title_en: "grayscale",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
            {
              key: "amap.filter.hueRotate",
              path: "amap.filter.hueRotate",
              type: n.Number,
              title_cn: "色相",
              title_en: "hueRotate",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,360"),
            },
            {
              key: "amap.filter.invert",
              path: "amap.filter.invert",
              type: n.Number,
              title_cn: "反转",
              title_en: "invert",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
            {
              key: "amap.filter.saturate",
              path: "amap.filter.saturate",
              type: n.Number,
              title_cn: "饱和度",
              title_en: "saturate",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.sepia",
              path: "amap.filter.sepia",
              type: n.Number,
              title_cn: "墨度",
              title_en: "sepia",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
          ],
        },
      ],
    },
    Q,
  ];
var J = Object.defineProperty,
  K = Object.defineProperties,
  $ = Object.getOwnPropertyDescriptors,
  tt = Object.getOwnPropertySymbols,
  et = Object.prototype.hasOwnProperty,
  it = Object.prototype.propertyIsEnumerable,
  nt = (t, e, i) =>
    e in t
      ? J(t, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: i,
        })
      : (t[e] = i),
  rt = (t, e) => {
    for (var i in e || (e = {})) et.call(e, i) && nt(t, i, e[i]);
    if (tt) for (var i of tt(e)) it.call(e, i) && nt(t, i, e[i]);
    return t;
  },
  ot = (t, e) => K(t, $(e)),
  at = (t, e) => {
    var i = {};
    for (var n in t) et.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
    if (null != t && tt)
      for (var n of tt(t)) e.indexOf(n) < 0 && it.call(t, n) && (i[n] = t[n]);
    return i;
  };
var st,
  lt,
  ut = "0.10.50",
  ct =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {};
function ht(t) {
  if (t.__esModule) return t;
  var e = Object.defineProperty({}, "__esModule", {
    value: !0,
  });
  return (
    Object.keys(t).forEach(function (i) {
      var n = Object.getOwnPropertyDescriptor(t, i);
      Object.defineProperty(
        e,
        i,
        n.get
          ? n
          : {
              enumerable: !0,
              get: function () {
                return t[i];
              },
            }
      );
    }),
    e
  );
}
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
(lt = st || (st = {})),
  (function (t) {
    var e =
        "object" == typeof ct
          ? ct
          : "object" == typeof self
          ? self
          : "object" == typeof this
          ? this
          : Function("return this;")(),
      i = n(lt);
    function n(t, e) {
      return function (i, n) {
        "function" != typeof t[i] &&
          Object.defineProperty(t, i, {
            configurable: !0,
            writable: !0,
            value: n,
          }),
          e && e(i, n);
      };
    }
    void 0 === e.Reflect ? (e.Reflect = lt) : (i = n(e.Reflect, i)),
      (function (t) {
        var e = Object.prototype.hasOwnProperty,
          i = "function" == typeof Symbol,
          n =
            i && void 0 !== Symbol.toPrimitive
              ? Symbol.toPrimitive
              : "@@toPrimitive",
          r = i && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator",
          o = "function" == typeof Object.create,
          a =
            {
              __proto__: [],
            } instanceof Array,
          s = !o && !a,
          l = {
            create: o
              ? function () {
                  return nt(Object.create(null));
                }
              : a
              ? function () {
                  return nt({
                    __proto__: null,
                  });
                }
              : function () {
                  return nt({});
                },
            has: s
              ? function (t, i) {
                  return e.call(t, i);
                }
              : function (t, e) {
                  return e in t;
                },
            get: s
              ? function (t, i) {
                  return e.call(t, i) ? t[i] : void 0;
                }
              : function (t, e) {
                  return t[e];
                },
          },
          u = Object.getPrototypeOf(Function),
          c =
            "object" == typeof process &&
            process.env &&
            "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL,
          h =
            c ||
            "function" != typeof Map ||
            "function" != typeof Map.prototype.entries
              ? tt()
              : Map,
          p =
            c ||
            "function" != typeof Set ||
            "function" != typeof Set.prototype.entries
              ? et()
              : Set,
          d = new (c || "function" != typeof WeakMap ? it() : WeakMap)();
        function f(t, e, i, n) {
          if (O(i)) {
            if (!V(t)) throw new TypeError();
            if (!q(e)) throw new TypeError();
            return C(t, e);
          }
          if (!V(t)) throw new TypeError();
          if (!k(e)) throw new TypeError();
          if (!k(n) && !O(n) && !F(n)) throw new TypeError();
          return F(n) && (n = void 0), w(t, e, (i = H(i)), n);
        }
        function g(t, e) {
          function i(i, n) {
            if (!k(i)) throw new TypeError();
            if (!O(n) && !Y(n)) throw new TypeError();
            L(t, e, i, n);
          }
          return i;
        }
        function m(t, e, i, n) {
          if (!k(i)) throw new TypeError();
          return O(n) || (n = H(n)), L(t, e, i, n);
        }
        function y(t, e, i) {
          if (!k(e)) throw new TypeError();
          return O(i) || (i = H(i)), E(t, e, i);
        }
        function v(t, e, i) {
          if (!k(e)) throw new TypeError();
          return O(i) || (i = H(i)), D(t, e, i);
        }
        function b(t, e, i) {
          if (!k(e)) throw new TypeError();
          return O(i) || (i = H(i)), T(t, e, i);
        }
        function x(t, e, i) {
          if (!k(e)) throw new TypeError();
          return O(i) || (i = H(i)), P(t, e, i);
        }
        function _(t, e) {
          if (!k(t)) throw new TypeError();
          return O(e) || (e = H(e)), I(t, e);
        }
        function S(t, e) {
          if (!k(t)) throw new TypeError();
          return O(e) || (e = H(e)), N(t, e);
        }
        function M(t, e, i) {
          if (!k(e)) throw new TypeError();
          O(i) || (i = H(i));
          var n = A(e, i, !1);
          if (O(n)) return !1;
          if (!n.delete(t)) return !1;
          if (n.size > 0) return !0;
          var r = d.get(e);
          return r.delete(i), r.size > 0 || d.delete(e), !0;
        }
        function C(t, e) {
          for (var i = t.length - 1; i >= 0; --i) {
            var n = (0, t[i])(e);
            if (!O(n) && !F(n)) {
              if (!q(n)) throw new TypeError();
              e = n;
            }
          }
          return e;
        }
        function w(t, e, i, n) {
          for (var r = t.length - 1; r >= 0; --r) {
            var o = (0, t[r])(e, i, n);
            if (!O(o) && !F(o)) {
              if (!k(o)) throw new TypeError();
              n = o;
            }
          }
          return n;
        }
        function A(t, e, i) {
          var n = d.get(t);
          if (O(n)) {
            if (!i) return;
            (n = new h()), d.set(t, n);
          }
          var r = n.get(e);
          if (O(r)) {
            if (!i) return;
            (r = new h()), n.set(e, r);
          }
          return r;
        }
        function E(t, e, i) {
          if (D(t, e, i)) return !0;
          var n = $(e);
          return !F(n) && E(t, n, i);
        }
        function D(t, e, i) {
          var n = A(e, i, !1);
          return !O(n) && U(n.has(t));
        }
        function T(t, e, i) {
          if (D(t, e, i)) return P(t, e, i);
          var n = $(e);
          return F(n) ? void 0 : T(t, n, i);
        }
        function P(t, e, i) {
          var n = A(e, i, !1);
          if (!O(n)) return n.get(t);
        }
        function L(t, e, i, n) {
          A(i, n, !0).set(t, e);
        }
        function I(t, e) {
          var i = N(t, e),
            n = $(t);
          if (null === n) return i;
          var r = I(n, e);
          if (r.length <= 0) return i;
          if (i.length <= 0) return r;
          for (var o = new p(), a = [], s = 0, l = i; s < l.length; s++) {
            var u = l[s];
            o.has(u) || (o.add(u), a.push(u));
          }
          for (var c = 0, h = r; c < h.length; c++)
            (u = h[c]), o.has(u) || (o.add(u), a.push(u));
          return a;
        }
        function N(t, e) {
          var i = [],
            n = A(t, e, !1);
          if (O(n)) return i;
          for (var r = Q(n.keys()), o = 0; ; ) {
            var a = J(r);
            if (!a) return (i.length = o), i;
            var s = Z(a);
            try {
              i[o] = s;
            } catch (l) {
              try {
                K(r);
              } finally {
                throw l;
              }
            }
            o++;
          }
        }
        function R(t) {
          if (null === t) return 1;
          switch (typeof t) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return null === t ? 1 : 6;
            default:
              return 6;
          }
        }
        function O(t) {
          return void 0 === t;
        }
        function F(t) {
          return null === t;
        }
        function z(t) {
          return "symbol" == typeof t;
        }
        function k(t) {
          return "object" == typeof t ? null !== t : "function" == typeof t;
        }
        function B(t, e) {
          switch (R(t)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              return t;
          }
          var i = 3 === e ? "string" : 5 === e ? "number" : "default",
            r = X(t, n);
          if (void 0 !== r) {
            var o = r.call(t, i);
            if (k(o)) throw new TypeError();
            return o;
          }
          return G(t, "default" === i ? "number" : i);
        }
        function G(t, e) {
          if ("string" === e) {
            var i = t.toString;
            if (W(i) && !k((r = i.call(t)))) return r;
            if (W((n = t.valueOf)) && !k((r = n.call(t)))) return r;
          } else {
            var n;
            if (W((n = t.valueOf)) && !k((r = n.call(t)))) return r;
            var r,
              o = t.toString;
            if (W(o) && !k((r = o.call(t)))) return r;
          }
          throw new TypeError();
        }
        function U(t) {
          return !!t;
        }
        function j(t) {
          return "" + t;
        }
        function H(t) {
          var e = B(t, 3);
          return z(e) ? e : j(e);
        }
        function V(t) {
          return Array.isArray
            ? Array.isArray(t)
            : t instanceof Object
            ? t instanceof Array
            : "[object Array]" === Object.prototype.toString.call(t);
        }
        function W(t) {
          return "function" == typeof t;
        }
        function q(t) {
          return "function" == typeof t;
        }
        function Y(t) {
          switch (R(t)) {
            case 3:
            case 4:
              return !0;
            default:
              return !1;
          }
        }
        function X(t, e) {
          var i = t[e];
          if (null != i) {
            if (!W(i)) throw new TypeError();
            return i;
          }
        }
        function Q(t) {
          var e = X(t, r);
          if (!W(e)) throw new TypeError();
          var i = e.call(t);
          if (!k(i)) throw new TypeError();
          return i;
        }
        function Z(t) {
          return t.value;
        }
        function J(t) {
          var e = t.next();
          return !e.done && e;
        }
        function K(t) {
          var e = t.return;
          e && e.call(t);
        }
        function $(t) {
          var e = Object.getPrototypeOf(t);
          if ("function" != typeof t || t === u) return e;
          if (e !== u) return e;
          var i = t.prototype,
            n = i && Object.getPrototypeOf(i);
          if (null == n || n === Object.prototype) return e;
          var r = n.constructor;
          return "function" != typeof r || r === t ? e : r;
        }
        function tt() {
          var t = {},
            e = [],
            i = (function () {
              function t(t, e, i) {
                (this._index = 0),
                  (this._keys = t),
                  (this._values = e),
                  (this._selector = i);
              }
              return (
                (t.prototype["@@iterator"] = function () {
                  return this;
                }),
                (t.prototype[r] = function () {
                  return this;
                }),
                (t.prototype.next = function () {
                  var t = this._index;
                  if (t >= 0 && t < this._keys.length) {
                    var i = this._selector(this._keys[t], this._values[t]);
                    return (
                      t + 1 >= this._keys.length
                        ? ((this._index = -1),
                          (this._keys = e),
                          (this._values = e))
                        : this._index++,
                      {
                        value: i,
                        done: !1,
                      }
                    );
                  }
                  return {
                    value: void 0,
                    done: !0,
                  };
                }),
                (t.prototype.throw = function (t) {
                  throw (
                    (this._index >= 0 &&
                      ((this._index = -1),
                      (this._keys = e),
                      (this._values = e)),
                    t)
                  );
                }),
                (t.prototype.return = function (t) {
                  return (
                    this._index >= 0 &&
                      ((this._index = -1),
                      (this._keys = e),
                      (this._values = e)),
                    {
                      value: t,
                      done: !0,
                    }
                  );
                }),
                t
              );
            })();
          return (function () {
            function e() {
              (this._keys = []),
                (this._values = []),
                (this._cacheKey = t),
                (this._cacheIndex = -2);
            }
            return (
              Object.defineProperty(e.prototype, "size", {
                get: function () {
                  return this._keys.length;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (e.prototype.has = function (t) {
                return this._find(t, !1) >= 0;
              }),
              (e.prototype.get = function (t) {
                var e = this._find(t, !1);
                return e >= 0 ? this._values[e] : void 0;
              }),
              (e.prototype.set = function (t, e) {
                var i = this._find(t, !0);
                return (this._values[i] = e), this;
              }),
              (e.prototype.delete = function (e) {
                var i = this._find(e, !1);
                if (i >= 0) {
                  for (var n = this._keys.length, r = i + 1; r < n; r++)
                    (this._keys[r - 1] = this._keys[r]),
                      (this._values[r - 1] = this._values[r]);
                  return (
                    this._keys.length--,
                    this._values.length--,
                    e === this._cacheKey &&
                      ((this._cacheKey = t), (this._cacheIndex = -2)),
                    !0
                  );
                }
                return !1;
              }),
              (e.prototype.clear = function () {
                (this._keys.length = 0),
                  (this._values.length = 0),
                  (this._cacheKey = t),
                  (this._cacheIndex = -2);
              }),
              (e.prototype.keys = function () {
                return new i(this._keys, this._values, n);
              }),
              (e.prototype.values = function () {
                return new i(this._keys, this._values, o);
              }),
              (e.prototype.entries = function () {
                return new i(this._keys, this._values, a);
              }),
              (e.prototype["@@iterator"] = function () {
                return this.entries();
              }),
              (e.prototype[r] = function () {
                return this.entries();
              }),
              (e.prototype._find = function (t, e) {
                return (
                  this._cacheKey !== t &&
                    (this._cacheIndex = this._keys.indexOf(
                      (this._cacheKey = t)
                    )),
                  this._cacheIndex < 0 &&
                    e &&
                    ((this._cacheIndex = this._keys.length),
                    this._keys.push(t),
                    this._values.push(void 0)),
                  this._cacheIndex
                );
              }),
              e
            );
          })();
          function n(t, e) {
            return t;
          }
          function o(t, e) {
            return e;
          }
          function a(t, e) {
            return [t, e];
          }
        }
        function et() {
          return (function () {
            function t() {
              this._map = new h();
            }
            return (
              Object.defineProperty(t.prototype, "size", {
                get: function () {
                  return this._map.size;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (t.prototype.has = function (t) {
                return this._map.has(t);
              }),
              (t.prototype.add = function (t) {
                return this._map.set(t, t), this;
              }),
              (t.prototype.delete = function (t) {
                return this._map.delete(t);
              }),
              (t.prototype.clear = function () {
                this._map.clear();
              }),
              (t.prototype.keys = function () {
                return this._map.keys();
              }),
              (t.prototype.values = function () {
                return this._map.values();
              }),
              (t.prototype.entries = function () {
                return this._map.entries();
              }),
              (t.prototype["@@iterator"] = function () {
                return this.keys();
              }),
              (t.prototype[r] = function () {
                return this.keys();
              }),
              t
            );
          })();
        }
        function it() {
          var t = 16,
            i = l.create(),
            n = r();
          return (function () {
            function t() {
              this._key = r();
            }
            return (
              (t.prototype.has = function (t) {
                var e = o(t, !1);
                return void 0 !== e && l.has(e, this._key);
              }),
              (t.prototype.get = function (t) {
                var e = o(t, !1);
                return void 0 !== e ? l.get(e, this._key) : void 0;
              }),
              (t.prototype.set = function (t, e) {
                return (o(t, !0)[this._key] = e), this;
              }),
              (t.prototype.delete = function (t) {
                var e = o(t, !1);
                return void 0 !== e && delete e[this._key];
              }),
              (t.prototype.clear = function () {
                this._key = r();
              }),
              t
            );
          })();
          function r() {
            var t;
            do {
              t = "@@WeakMap@@" + u();
            } while (l.has(i, t));
            return (i[t] = !0), t;
          }
          function o(t, i) {
            if (!e.call(t, n)) {
              if (!i) return;
              Object.defineProperty(t, n, {
                value: l.create(),
              });
            }
            return t[n];
          }
          function a(t, e) {
            for (var i = 0; i < e; ++i) t[i] = (255 * Math.random()) | 0;
            return t;
          }
          function s(t) {
            return "function" == typeof Uint8Array
              ? "undefined" != typeof crypto
                ? crypto.getRandomValues(new Uint8Array(t))
                : "undefined" != typeof msCrypto
                ? msCrypto.getRandomValues(new Uint8Array(t))
                : a(new Uint8Array(t), t)
              : a(new Array(t), t);
          }
          function u() {
            var e = s(t);
            (e[6] = (79 & e[6]) | 64), (e[8] = (191 & e[8]) | 128);
            for (var i = "", n = 0; n < t; ++n) {
              var r = e[n];
              (4 !== n && 6 !== n && 8 !== n) || (i += "-"),
                r < 16 && (i += "0"),
                (i += r.toString(16).toLowerCase());
            }
            return i;
          }
        }
        function nt(t) {
          return (t.__ = void 0), delete t.__, t;
        }
        t("decorate", f),
          t("metadata", g),
          t("defineMetadata", m),
          t("hasMetadata", y),
          t("hasOwnMetadata", v),
          t("getMetadata", b),
          t("getOwnMetadata", x),
          t("getMetadataKeys", _),
          t("getOwnMetadataKeys", S),
          t("deleteMetadata", M);
      })(i);
  })();
var pt = {
  exports: {},
};
!(function (t) {
  var e = Object.prototype.hasOwnProperty,
    i = "~";
  function n() {}
  function r(t, e, i) {
    (this.fn = t), (this.context = e), (this.once = i || !1);
  }
  function o(t, e, n, o, a) {
    if ("function" != typeof n)
      throw new TypeError("The listener must be a function");
    var s = new r(n, o || t, a),
      l = i ? i + e : e;
    return (
      t._events[l]
        ? t._events[l].fn
          ? (t._events[l] = [t._events[l], s])
          : t._events[l].push(s)
        : ((t._events[l] = s), t._eventsCount++),
      t
    );
  }
  function a(t, e) {
    0 == --t._eventsCount ? (t._events = new n()) : delete t._events[e];
  }
  function s() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (i = !1)),
    (s.prototype.eventNames = function () {
      var t,
        n,
        r = [];
      if (0 === this._eventsCount) return r;
      for (n in (t = this._events)) e.call(t, n) && r.push(i ? n.slice(1) : n);
      return Object.getOwnPropertySymbols
        ? r.concat(Object.getOwnPropertySymbols(t))
        : r;
    }),
    (s.prototype.listeners = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      if (!n) return [];
      if (n.fn) return [n.fn];
      for (var r = 0, o = n.length, a = new Array(o); r < o; r++)
        a[r] = n[r].fn;
      return a;
    }),
    (s.prototype.listenerCount = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      return n ? (n.fn ? 1 : n.length) : 0;
    }),
    (s.prototype.emit = function (t, e, n, r, o, a) {
      var s = i ? i + t : t;
      if (!this._events[s]) return !1;
      var l,
        u,
        c = this._events[s],
        h = arguments.length;
      if (c.fn) {
        switch ((c.once && this.removeListener(t, c.fn, void 0, !0), h)) {
          case 1:
            return c.fn.call(c.context), !0;
          case 2:
            return c.fn.call(c.context, e), !0;
          case 3:
            return c.fn.call(c.context, e, n), !0;
          case 4:
            return c.fn.call(c.context, e, n, r), !0;
          case 5:
            return c.fn.call(c.context, e, n, r, o), !0;
          case 6:
            return c.fn.call(c.context, e, n, r, o, a), !0;
        }
        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
        c.fn.apply(c.context, l);
      } else {
        var p,
          d = c.length;
        for (u = 0; u < d; u++)
          switch (
            (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), h)
          ) {
            case 1:
              c[u].fn.call(c[u].context);
              break;
            case 2:
              c[u].fn.call(c[u].context, e);
              break;
            case 3:
              c[u].fn.call(c[u].context, e, n);
              break;
            case 4:
              c[u].fn.call(c[u].context, e, n, r);
              break;
            default:
              if (!l)
                for (p = 1, l = new Array(h - 1); p < h; p++)
                  l[p - 1] = arguments[p];
              c[u].fn.apply(c[u].context, l);
          }
      }
      return !0;
    }),
    (s.prototype.on = function (t, e, i) {
      return o(this, t, e, i, !1);
    }),
    (s.prototype.once = function (t, e, i) {
      return o(this, t, e, i, !0);
    }),
    (s.prototype.removeListener = function (t, e, n, r) {
      var o = i ? i + t : t;
      if (!this._events[o]) return this;
      if (!e) return a(this, o), this;
      var s = this._events[o];
      if (s.fn)
        s.fn !== e || (r && !s.once) || (n && s.context !== n) || a(this, o);
      else {
        for (var l = 0, u = [], c = s.length; l < c; l++)
          (s[l].fn !== e || (r && !s[l].once) || (n && s[l].context !== n)) &&
            u.push(s[l]);
        u.length ? (this._events[o] = 1 === u.length ? u[0] : u) : a(this, o);
      }
      return this;
    }),
    (s.prototype.removeAllListeners = function (t) {
      var e;
      return (
        t
          ? ((e = i ? i + t : t), this._events[e] && a(this, e))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prefixed = i),
    (s.EventEmitter = s),
    (t.exports = s);
})(pt);
var dt = pt.exports;
var ft, gt, mt, yt;
class vt {
  addEventListener(t, e) {
    void 0 === this._listeners && (this._listeners = {});
    const i = this._listeners;
    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
  }
  hasEventListener(t, e) {
    if (void 0 === this._listeners) return !1;
    const i = this._listeners;
    return void 0 !== i[t] && -1 !== i[t].indexOf(e);
  }
  removeEventListener(t, e) {
    if (void 0 === this._listeners) return;
    const i = this._listeners[t];
    if (void 0 !== i) {
      const t = i.indexOf(e);
      -1 !== t && i.splice(t, 1);
    }
  }
  dispatchEvent(t) {
    if (void 0 === this._listeners) return;
    const e = this._listeners[t.type];
    if (void 0 !== e) {
      t.target = this;
      const i = e.slice(0);
      for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
      t.target = null;
    }
  }
}
((gt = ft || (ft = {}))[(gt.LEFT = 0)] = "LEFT"),
  (gt[(gt.MIDDLE = 1)] = "MIDDLE"),
  (gt[(gt.RIGHT = 2)] = "RIGHT"),
  (gt[(gt.ROTATE = 0)] = "ROTATE"),
  (gt[(gt.DOLLY = 1)] = "DOLLY"),
  (gt[(gt.PAN = 2)] = "PAN"),
  ((yt = mt || (mt = {}))[(yt.ROTATE = 0)] = "ROTATE"),
  (yt[(yt.PAN = 1)] = "PAN"),
  (yt[(yt.DOLLY_PAN = 2)] = "DOLLY_PAN"),
  (yt[(yt.DOLLY_ROTATE = 3)] = "DOLLY_ROTATE");
const bt = 1,
  xt = 2,
  _t = 100,
  St = 101,
  Mt = 102,
  Ct = 200,
  wt = 201,
  At = 202,
  Et = 203,
  Dt = 204,
  Tt = 205,
  Pt = 206,
  Lt = 207,
  It = 208,
  Nt = 209,
  Rt = 210,
  Ot = 301,
  Ft = 302,
  zt = 306,
  kt = 1e3,
  Bt = 1001,
  Gt = 1002,
  Ut = 1003,
  jt = 1004,
  Ht = 1005,
  Vt = 1006,
  Wt = 1007,
  qt = 1008,
  Yt = 1009,
  Xt = 1012,
  Qt = 1014,
  Zt = 1015,
  Jt = 1016,
  Kt = 1020,
  $t = 1022,
  te = 1023,
  ee = 1026,
  ie = 1027,
  ne = 2300,
  re = 2301,
  oe = 2302,
  ae = 2400,
  se = 2401,
  le = 2402,
  ue = 2500,
  ce = 3e3,
  he = 3001,
  pe = 3007,
  de = 3002,
  fe = 3003,
  ge = 3004,
  me = 3005,
  ye = 3006,
  ve = 7680,
  be = 35044,
  xe = 35048,
  _e = "300 es",
  Se = [];
for (let p7 = 0; p7 < 256; p7++)
  Se[p7] = (p7 < 16 ? "0" : "") + p7.toString(16);
const Me = Math.PI / 180,
  Ce = 180 / Math.PI;
function we() {
  const t = (4294967295 * Math.random()) | 0,
    e = (4294967295 * Math.random()) | 0,
    i = (4294967295 * Math.random()) | 0,
    n = (4294967295 * Math.random()) | 0;
  return (
    Se[255 & t] +
    Se[(t >> 8) & 255] +
    Se[(t >> 16) & 255] +
    Se[(t >> 24) & 255] +
    "-" +
    Se[255 & e] +
    Se[(e >> 8) & 255] +
    "-" +
    Se[((e >> 16) & 15) | 64] +
    Se[(e >> 24) & 255] +
    "-" +
    Se[(63 & i) | 128] +
    Se[(i >> 8) & 255] +
    "-" +
    Se[(i >> 16) & 255] +
    Se[(i >> 24) & 255] +
    Se[255 & n] +
    Se[(n >> 8) & 255] +
    Se[(n >> 16) & 255] +
    Se[(n >> 24) & 255]
  ).toUpperCase();
}
function Ae(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
function Ee(t, e, i) {
  return (1 - i) * t + i * e;
}
function De(t) {
  return t * Me;
}
function Te(t) {
  return !(t & (t - 1)) && 0 !== t;
}
function Pe(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
class Le {
  constructor(t = 0, e = 0) {
    (this.isVector2 = !0), (this.x = t), (this.y = e);
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new Le(this.x, this.y);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x,
      i = this.y,
      n = t.elements;
    return (
      (this.x = n[0] * e + n[3] * i + n[6]),
      (this.y = n[1] * e + n[4] * i + n[7]),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    );
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(t, Math.min(e, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      i = this.y - t.y;
    return e * e + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  }
  lerpVectors(t, e, i) {
    return (
      (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t;
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
  }
  rotateAround(t, e) {
    const i = Math.cos(e),
      n = Math.sin(e),
      r = this.x - t.x,
      o = this.y - t.y;
    return (this.x = r * i - o * n + t.x), (this.y = r * n + o * i + t.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ie {
  constructor() {
    (this.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "@dp/gis-engine: Matrix3: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, i, n, r, o, a, s, l) {
    const u = this.elements;
    return (
      (u[0] = t),
      (u[1] = n),
      (u[2] = a),
      (u[3] = e),
      (u[4] = r),
      (u[5] = s),
      (u[6] = i),
      (u[7] = o),
      (u[8] = l),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements,
      i = t.elements;
    return (
      (e[0] = i[0]),
      (e[1] = i[1]),
      (e[2] = i[2]),
      (e[3] = i[3]),
      (e[4] = i[4]),
      (e[5] = i[5]),
      (e[6] = i[6]),
      (e[7] = i[7]),
      (e[8] = i[8]),
      this
    );
  }
  extractBasis(t, e, i) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return (
      this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements,
      n = e.elements,
      r = this.elements,
      o = i[0],
      a = i[3],
      s = i[6],
      l = i[1],
      u = i[4],
      c = i[7],
      h = i[2],
      p = i[5],
      d = i[8],
      f = n[0],
      g = n[3],
      m = n[6],
      y = n[1],
      v = n[4],
      b = n[7],
      x = n[2],
      _ = n[5],
      S = n[8];
    return (
      (r[0] = o * f + a * y + s * x),
      (r[3] = o * g + a * v + s * _),
      (r[6] = o * m + a * b + s * S),
      (r[1] = l * f + u * y + c * x),
      (r[4] = l * g + u * v + c * _),
      (r[7] = l * m + u * b + c * S),
      (r[2] = h * f + p * y + d * x),
      (r[5] = h * g + p * v + d * _),
      (r[8] = h * m + p * b + d * S),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      i = t[1],
      n = t[2],
      r = t[3],
      o = t[4],
      a = t[5],
      s = t[6],
      l = t[7],
      u = t[8];
    return (
      e * o * u - e * a * l - i * r * u + i * a * s + n * r * l - n * o * s
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      i = t[1],
      n = t[2],
      r = t[3],
      o = t[4],
      a = t[5],
      s = t[6],
      l = t[7],
      u = t[8],
      c = u * o - a * l,
      h = a * s - u * r,
      p = l * r - o * s,
      d = e * c + i * h + n * p;
    if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const f = 1 / d;
    return (
      (t[0] = c * f),
      (t[1] = (n * l - u * i) * f),
      (t[2] = (a * i - n * o) * f),
      (t[3] = h * f),
      (t[4] = (u * e - n * s) * f),
      (t[5] = (n * r - a * e) * f),
      (t[6] = p * f),
      (t[7] = (i * s - l * e) * f),
      (t[8] = (o * e - i * r) * f),
      this
    );
  }
  transpose() {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  }
  setUvTransform(t, e, i, n, r, o, a) {
    const s = Math.cos(r),
      l = Math.sin(r);
    return (
      this.set(
        i * s,
        i * l,
        -i * (s * o + l * a) + o + t,
        -n * l,
        n * s,
        -n * (-l * o + s * a) + a + e,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(t, e) {
    const i = this.elements;
    return (
      (i[0] *= t),
      (i[3] *= t),
      (i[6] *= t),
      (i[1] *= e),
      (i[4] *= e),
      (i[7] *= e),
      this
    );
  }
  rotate(t) {
    const e = Math.cos(t),
      i = Math.sin(t),
      n = this.elements,
      r = n[0],
      o = n[3],
      a = n[6],
      s = n[1],
      l = n[4],
      u = n[7];
    return (
      (n[0] = e * r + i * s),
      (n[3] = e * o + i * l),
      (n[6] = e * a + i * u),
      (n[1] = -i * r + e * s),
      (n[4] = -i * o + e * l),
      (n[7] = -i * a + e * u),
      this
    );
  }
  translate(t, e) {
    const i = this.elements;
    return (
      (i[0] += t * i[2]),
      (i[3] += t * i[5]),
      (i[6] += t * i[8]),
      (i[1] += e * i[2]),
      (i[4] += e * i[5]),
      (i[7] += e * i[8]),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      i = t.elements;
    for (let n = 0; n < 9; n++) if (e[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return (
      (t[e] = i[0]),
      (t[e + 1] = i[1]),
      (t[e + 2] = i[2]),
      (t[e + 3] = i[3]),
      (t[e + 4] = i[4]),
      (t[e + 5] = i[5]),
      (t[e + 6] = i[6]),
      (t[e + 7] = i[7]),
      (t[e + 8] = i[8]),
      t
    );
  }
  clone() {
    return new Ie().fromArray(this.elements);
  }
}
function Ne(t) {
  if (0 === t.length) return -1 / 0;
  let e = t[0];
  for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
  return e;
}
function Re(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function Oe(t, e = 0) {
  let i = 3735928559 ^ e,
    n = 1103547991 ^ e;
  for (let r, o = 0; o < t.length; o++)
    (r = t.charCodeAt(o)),
      (i = Math.imul(i ^ r, 2654435761)),
      (n = Math.imul(n ^ r, 1597334677));
  return (
    (i =
      Math.imul(i ^ (i >>> 16), 2246822507) ^
      Math.imul(n ^ (n >>> 13), 3266489909)),
    (n =
      Math.imul(n ^ (n >>> 16), 2246822507) ^
      Math.imul(i ^ (i >>> 13), 3266489909)),
    4294967296 * (2097151 & n) + (i >>> 0)
  );
}
let Fe;
class ze {
  static getDataURL(t) {
    if (/^data:/i.test(t.src)) return t.src;
    if ("undefined" == typeof HTMLCanvasElement) return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;
    else {
      void 0 === Fe && (Fe = Re("canvas")),
        (Fe.width = t.width),
        (Fe.height = t.height);
      const i = Fe.getContext("2d");
      t instanceof ImageData
        ? i.putImageData(t, 0, 0)
        : i.drawImage(t, 0, 0, t.width, t.height),
        (e = Fe);
    }
    return e.width > 2048 || e.height > 2048
      ? e.toDataURL("image/jpeg", 0.6)
      : e.toDataURL("image/png");
  }
}
let ke = 0;
const Be = class extends vt {
  constructor(
    t = Be.DEFAULT_IMAGE,
    e = Be.DEFAULT_MAPPING,
    i = 1001,
    n = 1001,
    r = 1006,
    o = 1008,
    a = 1023,
    s = 1009,
    l = 1,
    u = ce
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", {
        value: ke++,
      }),
      (this.uuid = we()),
      (this.name = ""),
      (this.image = t),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.wrapS = i),
      (this.wrapT = n),
      (this.magFilter = r),
      (this.minFilter = o),
      (this.anisotropy = l),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = s),
      (this.offset = new Le(0, 0)),
      (this.repeat = new Le(1, 1)),
      (this.center = new Le(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Ie()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1);
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.image = t.image),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.encoding = t.encoding),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  toJSON(t) {
    const e = void 0 === t || "string" == typeof t;
    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON",
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (void 0 !== this.image) {
      const n = this.image;
      if (
        (void 0 === n.uuid && (n.uuid = we()),
        !e && void 0 === t.images[n.uuid])
      ) {
        let e;
        if (Array.isArray(n)) {
          e = [];
          for (let t = 0, i = n.length; t < i; t++)
            n[t].isDataTexture ? e.push(Ue(n[t].image)) : e.push(Ue(n[t]));
        } else e = Ue(n);
        t.images[n.uuid] = {
          uuid: n.uuid,
          url: e,
        };
      }
      i.image = n.uuid;
    }
    return (
      "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
      e || (t.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  transformUv(t) {
    if (300 !== this.mapping) return t;
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case kt:
          t.x = t.x - Math.floor(t.x);
          break;
        case Bt:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case Gt:
          1 === Math.abs(Math.floor(t.x) % 2)
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x));
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case kt:
          t.y = t.y - Math.floor(t.y);
          break;
        case Bt:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case Gt:
          1 === Math.abs(Math.floor(t.y) % 2)
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y));
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    !0 === t && this.version++;
  }
};
let Ge = Be;
function Ue(t) {
  return ("undefined" != typeof HTMLImageElement &&
    t instanceof HTMLImageElement) ||
    ("undefined" != typeof HTMLCanvasElement &&
      t instanceof HTMLCanvasElement) ||
    ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
    ? ze.getDataURL(t)
    : t.data
    ? {
        data: Array.prototype.slice.call(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : {};
}
Ge.DEFAULT_MAPPING = 300;
class je {
  constructor(t = 0, e = 0, i = 0, n = 1) {
    (this.isVector4 = !0),
      (this.x = t),
      (this.y = e),
      (this.z = i),
      (this.w = n);
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, i, n) {
    return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setW(t) {
    return (this.w = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new je(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    var e;
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = null != (e = t.w) ? e : 1),
      this
    );
  }
  add(t) {
    return (
      (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
    );
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    );
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    );
  }
  sub(t) {
    return (
      (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
    );
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    );
  }
  multiply(t) {
    return (
      (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
    );
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  }
  applyMatrix4(t) {
    const e = this.x,
      i = this.y,
      n = this.z,
      r = this.w,
      o = t.elements;
    return (
      (this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r),
      (this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r),
      (this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r),
      (this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r),
      this
    );
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, i, n, r;
    const o = 0.01,
      a = 0.1,
      s = t.elements,
      l = s[0],
      u = s[4],
      c = s[8],
      h = s[1],
      p = s[5],
      d = s[9],
      f = s[2],
      g = s[6],
      m = s[10];
    if (Math.abs(u - h) < o && Math.abs(c - f) < o && Math.abs(d - g) < o) {
      if (
        Math.abs(u + h) < a &&
        Math.abs(c + f) < a &&
        Math.abs(d + g) < a &&
        Math.abs(l + p + m - 3) < a
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const t = (l + 1) / 2,
        s = (p + 1) / 2,
        y = (m + 1) / 2,
        v = (u + h) / 4,
        b = (c + f) / 4,
        x = (d + g) / 4;
      return (
        t > s && t > y
          ? t < o
            ? ((i = 0), (n = 0.707106781), (r = 0.707106781))
            : ((i = Math.sqrt(t)), (n = v / i), (r = b / i))
          : s > y
          ? s < o
            ? ((i = 0.707106781), (n = 0), (r = 0.707106781))
            : ((n = Math.sqrt(s)), (i = v / n), (r = x / n))
          : y < o
          ? ((i = 0.707106781), (n = 0.707106781), (r = 0))
          : ((r = Math.sqrt(y)), (i = b / r), (n = x / r)),
        this.set(i, n, r, e),
        this
      );
    }
    let y = Math.sqrt(
      (g - d) * (g - d) + (c - f) * (c - f) + (h - u) * (h - u)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (g - d) / y),
      (this.y = (c - f) / y),
      (this.z = (h - u) / y),
      (this.w = Math.acos((l + p + m - 1) / 2)),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    );
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(t, Math.min(e, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  }
  lerpVectors(t, e, i) {
    return (
      (this.x = t.x + (e.x - t.x) * i),
      (this.y = t.y + (e.y - t.y) * i),
      (this.z = t.z + (e.z - t.z) * i),
      (this.w = t.w + (e.w - t.w) * i),
      this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return (
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class He extends vt {
  constructor(t, e, i = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = t),
      (this.height = e),
      (this.depth = 1),
      (this.scissor = new je(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new je(0, 0, t, e)),
      (this.texture = new Ge(
        void 0,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.image = {
        width: t,
        height: e,
        depth: 1,
      }),
      (this.texture.generateMipmaps =
        void 0 !== i.generateMipmaps && i.generateMipmaps),
      (this.texture.internalFormat =
        void 0 !== i.internalFormat ? i.internalFormat : null),
      (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Vt),
      (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
      (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
      (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null);
  }
  setTexture(t) {
    (t.image = {
      width: this.width,
      height: this.height,
      depth: this.depth,
    }),
      (this.texture = t);
  }
  setSize(t, e, i = 1) {
    (this.width === t && this.height === e && this.depth === i) ||
      ((this.width = t),
      (this.height = e),
      (this.depth = i),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, t, e),
      this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.viewport.copy(t.viewport),
      (this.texture = t.texture.clone()),
      (this.texture.image = rt({}, this.texture.image)),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
class Ve extends He {
  constructor(t, e, i) {
    super(t, e, i),
      (this.isWebGLMultisampleRenderTarget = !0),
      (this.samples = 4);
  }
  copy(t) {
    return super.copy.call(this, t), (this.samples = t.samples), this;
  }
}
class We {
  constructor(t = 0, e = 0, i = 0, n = 1) {
    (this.isQuaternion = !0),
      (this._x = t),
      (this._y = e),
      (this._z = i),
      (this._w = n);
  }
  static slerp(t, e, i, n) {
    return i.slerpQuaternions(t, e, n);
  }
  static slerpFlat(t, e, i, n, r, o, a) {
    let s = i[n + 0],
      l = i[n + 1],
      u = i[n + 2],
      c = i[n + 3];
    const h = r[o + 0],
      p = r[o + 1],
      d = r[o + 2],
      f = r[o + 3];
    if (0 === a)
      return (
        (t[e + 0] = s), (t[e + 1] = l), (t[e + 2] = u), void (t[e + 3] = c)
      );
    if (1 === a)
      return (
        (t[e + 0] = h), (t[e + 1] = p), (t[e + 2] = d), void (t[e + 3] = f)
      );
    if (c !== f || s !== h || l !== p || u !== d) {
      let t = 1 - a;
      const e = s * h + l * p + u * d + c * f,
        i = e >= 0 ? 1 : -1,
        n = 1 - e * e;
      if (n > Number.EPSILON) {
        const r = Math.sqrt(n),
          o = Math.atan2(r, e * i);
        (t = Math.sin(t * o) / r), (a = Math.sin(a * o) / r);
      }
      const r = a * i;
      if (
        ((s = s * t + h * r),
        (l = l * t + p * r),
        (u = u * t + d * r),
        (c = c * t + f * r),
        t === 1 - a)
      ) {
        const t = 1 / Math.sqrt(s * s + l * l + u * u + c * c);
        (s *= t), (l *= t), (u *= t), (c *= t);
      }
    }
    (t[e] = s), (t[e + 1] = l), (t[e + 2] = u), (t[e + 3] = c);
  }
  static multiplyQuaternionsFlat(t, e, i, n, r, o) {
    const a = i[n],
      s = i[n + 1],
      l = i[n + 2],
      u = i[n + 3],
      c = r[o],
      h = r[o + 1],
      p = r[o + 2],
      d = r[o + 3];
    return (
      (t[e] = a * d + u * c + s * p - l * h),
      (t[e + 1] = s * d + u * h + l * c - a * p),
      (t[e + 2] = l * d + u * p + a * h - s * c),
      (t[e + 3] = u * d - a * c - s * h - l * p),
      t
    );
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    (this._w = t), this._onChangeCallback();
  }
  set(t, e, i, n) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = i),
      (this._w = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new We(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(t, e) {
    if (!t || !t.isEuler)
      throw new Error(
        "@dp/gis-engine: Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const i = t._x,
      n = t._y,
      r = t._z,
      o = t._order,
      a = Math.cos,
      s = Math.sin,
      l = a(i / 2),
      u = a(n / 2),
      c = a(r / 2),
      h = s(i / 2),
      p = s(n / 2),
      d = s(r / 2);
    switch (o) {
      case "XYZ":
        (this._x = h * u * c + l * p * d),
          (this._y = l * p * c - h * u * d),
          (this._z = l * u * d + h * p * c),
          (this._w = l * u * c - h * p * d);
        break;
      case "YXZ":
        (this._x = h * u * c + l * p * d),
          (this._y = l * p * c - h * u * d),
          (this._z = l * u * d - h * p * c),
          (this._w = l * u * c + h * p * d);
        break;
      case "ZXY":
        (this._x = h * u * c - l * p * d),
          (this._y = l * p * c + h * u * d),
          (this._z = l * u * d + h * p * c),
          (this._w = l * u * c - h * p * d);
        break;
      case "ZYX":
        (this._x = h * u * c - l * p * d),
          (this._y = l * p * c + h * u * d),
          (this._z = l * u * d - h * p * c),
          (this._w = l * u * c + h * p * d);
        break;
      case "YZX":
        (this._x = h * u * c + l * p * d),
          (this._y = l * p * c + h * u * d),
          (this._z = l * u * d - h * p * c),
          (this._w = l * u * c - h * p * d);
        break;
      case "XZY":
        (this._x = h * u * c - l * p * d),
          (this._y = l * p * c - h * u * d),
          (this._z = l * u * d + h * p * c),
          (this._w = l * u * c + h * p * d);
    }
    return !1 !== e && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const i = e / 2,
      n = Math.sin(i);
    return (
      (this._x = t.x * n),
      (this._y = t.y * n),
      (this._z = t.z * n),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      i = e[0],
      n = e[4],
      r = e[8],
      o = e[1],
      a = e[5],
      s = e[9],
      l = e[2],
      u = e[6],
      c = e[10],
      h = i + a + c;
    if (h > 0) {
      const t = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / t),
        (this._x = (u - s) * t),
        (this._y = (r - l) * t),
        (this._z = (o - n) * t);
    } else if (i > a && i > c) {
      const t = 2 * Math.sqrt(1 + i - a - c);
      (this._w = (u - s) / t),
        (this._x = 0.25 * t),
        (this._y = (n + o) / t),
        (this._z = (r + l) / t);
    } else if (a > c) {
      const t = 2 * Math.sqrt(1 + a - i - c);
      (this._w = (r - l) / t),
        (this._x = (n + o) / t),
        (this._y = 0.25 * t),
        (this._z = (s + u) / t);
    } else {
      const t = 2 * Math.sqrt(1 + c - i - a);
      (this._w = (o - n) / t),
        (this._x = (r + l) / t),
        (this._y = (s + u) / t),
        (this._z = 0.25 * t);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let i = t.dot(e) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = i)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Ae(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const i = this.angleTo(t);
    if (0 === i) return this;
    const n = Math.min(1, e / i);
    return this.slerp(t, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let t = this.length();
    return (
      0 === t
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const i = t._x,
      n = t._y,
      r = t._z,
      o = t._w,
      a = e._x,
      s = e._y,
      l = e._z,
      u = e._w;
    return (
      (this._x = i * u + o * a + n * l - r * s),
      (this._y = n * u + o * s + r * a - i * l),
      (this._z = r * u + o * l + i * s - n * a),
      (this._w = o * u - i * a - n * s - r * l),
      this._onChangeCallback(),
      this
    );
  }
  slerp(t, e) {
    if (0 === e) return this;
    if (1 === e) return this.copy(t);
    const i = this._x,
      n = this._y,
      r = this._z,
      o = this._w;
    let a = o * t._w + i * t._x + n * t._y + r * t._z;
    if (
      (a < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (a = -a))
        : this.copy(t),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = n), (this._z = r), this;
    const s = 1 - a * a;
    if (s <= Number.EPSILON) {
      const t = 1 - e;
      return (
        (this._w = t * o + e * this._w),
        (this._x = t * i + e * this._x),
        (this._y = t * n + e * this._y),
        (this._z = t * r + e * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const l = Math.sqrt(s),
      u = Math.atan2(l, a),
      c = Math.sin((1 - e) * u) / l,
      h = Math.sin(e * u) / l;
    return (
      (this._w = o * c + this._w * h),
      (this._x = i * c + this._x * h),
      (this._y = n * c + this._y * h),
      (this._z = r * c + this._z * h),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(t, e, i) {
    this.copy(t).slerp(e, i);
  }
  random() {
    const t = Math.random(),
      e = Math.sqrt(1 - t),
      i = Math.sqrt(t),
      n = 2 * Math.PI * Math.random(),
      r = 2 * Math.PI * Math.random();
    return this.set(
      e * Math.cos(n),
      i * Math.sin(r),
      i * Math.cos(r),
      e * Math.sin(n)
    );
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    );
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this
    );
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
const qe = new We();
class Ye {
  constructor(t = 0, e = 0, i = 0) {
    (this.isVector3 = !0), (this.x = t), (this.y = e), (this.z = i);
  }
  set(t, e, i) {
    return (
      void 0 === i && (i = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = i),
      this
    );
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  addX(t) {
    return (this.x += t), this;
  }
  addY(t) {
    return (this.y += t), this;
  }
  addZ(t) {
    return (this.z += t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new Ye(this.x, this.y, this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    );
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    );
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    );
  }
  applyEuler(t) {
    return (
      (t && t.isEuler) ||
        console.error(
          "@dp/gis-engine: Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(qe.setFromEuler(t))
    );
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(qe.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x,
      i = this.y,
      n = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[3] * i + r[6] * n),
      (this.y = r[1] * e + r[4] * i + r[7] * n),
      (this.z = r[2] * e + r[5] * i + r[8] * n),
      this
    );
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x,
      i = this.y,
      n = this.z,
      r = t.elements,
      o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
    return (
      (this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o),
      (this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o),
      (this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o),
      this
    );
  }
  applyQuaternion(t) {
    const e = this.x,
      i = this.y,
      n = this.z,
      r = t.x,
      o = t.y,
      a = t.z,
      s = t.w,
      l = s * e + o * n - a * i,
      u = s * i + a * e - r * n,
      c = s * n + r * i - o * e,
      h = -r * e - o * i - a * n;
    return (
      (this.x = l * s + h * -r + u * -a - c * -o),
      (this.y = u * s + h * -o + c * -r - l * -a),
      (this.z = c * s + h * -a + l * -o - u * -r),
      this
    );
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    );
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    );
  }
  transformDirection(t) {
    const e = this.x,
      i = this.y,
      n = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[4] * i + r[8] * n),
      (this.y = r[1] * e + r[5] * i + r[9] * n),
      (this.z = r[2] * e + r[6] * i + r[10] * n),
      this.normalize()
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    );
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(t, Math.min(e, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  }
  lerpVectors(t, e, i) {
    return (
      (this.x = t.x + (e.x - t.x) * i),
      (this.y = t.y + (e.y - t.y) * i),
      (this.z = t.z + (e.z - t.z) * i),
      this
    );
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const i = t.x,
      n = t.y,
      r = t.z,
      o = e.x,
      a = e.y,
      s = e.z;
    return (
      (this.x = n * s - r * a),
      (this.y = r * o - i * s),
      (this.z = i * a - n * o),
      this
    );
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (0 === e) return this.set(0, 0, 0);
    const i = t.dot(this) / e;
    return this.copy(t).multiplyScalar(i);
  }
  projectOnPlane(t) {
    return Xe.copy(this).projectOnVector(t), this.sub(Xe);
  }
  reflect(t) {
    return this.sub(Xe.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (0 === e) return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(Ae(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      i = this.y - t.y,
      n = this.z - t.z;
    return e * e + i * i + n * n;
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    );
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, i) {
    const n = Math.sin(e) * t;
    return (
      (this.x = n * Math.sin(i)),
      (this.y = Math.cos(e) * t),
      (this.z = n * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, i) {
    return (
      (this.x = t * Math.sin(e)), (this.y = i), (this.z = t * Math.cos(e)), this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      i = this.setFromMatrixColumn(t, 1).length(),
      n = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = i), (this.z = n), this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, 4 * e);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, 3 * e);
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const t = 2 * (Math.random() - 0.5),
      e = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - t ** 2);
    return (
      (this.x = i * Math.cos(e)), (this.y = i * Math.sin(e)), (this.z = t), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Xe = new Ye(),
  Qe = [
    new Ye(),
    new Ye(),
    new Ye(),
    new Ye(),
    new Ye(),
    new Ye(),
    new Ye(),
    new Ye(),
  ],
  Ze = new Ye(),
  Je = new Ye(),
  Ke = new Ye(),
  $e = new Ye(),
  ti = new Ye(),
  ei = new Ye(),
  ii = new Ye(),
  ni = new Ye(),
  ri = new Ye(),
  oi = new Ye(),
  ai = new Ye();
function si(t, e, i, n, r) {
  for (let o = 0, a = t.length - 3; o <= a; o += 3) {
    ai.fromArray(t, o);
    const a =
        r.x * Math.abs(ai.x) + r.y * Math.abs(ai.y) + r.z * Math.abs(ai.z),
      s = e.dot(ai),
      l = i.dot(ai),
      u = n.dot(ai);
    if (Math.max(-Math.max(s, l, u), Math.min(s, l, u)) > a) return !1;
  }
  return !0;
}
class li {
  constructor(
    t = new Ye(1 / 0, 1 / 0, 1 / 0),
    e = new Ye(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = t), (this.max = e);
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    let e = 1 / 0,
      i = 1 / 0,
      n = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      a = -1 / 0;
    for (let s = 0, l = t.length; s < l; s += 3) {
      const l = t[s],
        u = t[s + 1],
        c = t[s + 2];
      l < e && (e = l),
        u < i && (i = u),
        c < n && (n = c),
        l > r && (r = l),
        u > o && (o = u),
        c > a && (a = c);
    }
    return this.min.set(e, i, n), this.max.set(r, o, a), this;
  }
  setFromBufferAttribute(t) {
    let e = 1 / 0,
      i = 1 / 0,
      n = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      a = -1 / 0;
    for (let s = 0, l = t.count; s < l; s++) {
      const l = t.getX(s),
        u = t.getY(s),
        c = t.getZ(s);
      l < e && (e = l),
        u < i && (i = u),
        c < n && (n = c),
        l > r && (r = l),
        u > o && (o = u),
        c > a && (a = c);
    }
    return this.min.set(e, i, n), this.max.set(r, o, a), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const i = Ze.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
  }
  setFromObject(t) {
    return this.makeEmpty(), this.expandByObject(t);
  }
  clone() {
    return new li().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    void 0 !== e &&
      (null === e.boundingBox && e.computeBoundingBox(),
      ui.copy(e.boundingBox),
      ui.applyMatrix4(t.matrixWorld),
      this.union(ui));
    const i = t.children;
    for (let n = 0, r = i.length; n < r; n++) this.expandByObject(i[n]);
    return this;
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    );
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, Ze),
      Ze.distanceToSquared(t.center) <= t.radius * t.radius
    );
  }
  intersectsPlane(t) {
    let e, i;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
      e <= -t.constant && i >= -t.constant
    );
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1;
    this.getCenter(ni),
      ri.subVectors(this.max, ni),
      Je.subVectors(t.a, ni),
      Ke.subVectors(t.b, ni),
      $e.subVectors(t.c, ni),
      ti.subVectors(Ke, Je),
      ei.subVectors($e, Ke),
      ii.subVectors(Je, $e);
    let e = [
      0,
      -ti.z,
      ti.y,
      0,
      -ei.z,
      ei.y,
      0,
      -ii.z,
      ii.y,
      ti.z,
      0,
      -ti.x,
      ei.z,
      0,
      -ei.x,
      ii.z,
      0,
      -ii.x,
      -ti.y,
      ti.x,
      0,
      -ei.y,
      ei.x,
      0,
      -ii.y,
      ii.x,
      0,
    ];
    return (
      !!si(e, Je, Ke, $e, ri) &&
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!si(e, Je, Ke, $e, ri) &&
        (oi.crossVectors(ti, ei),
        (e = [oi.x, oi.y, oi.z]),
        si(e, Je, Ke, $e, ri)))
    );
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return Ze.copy(t).clamp(this.min, this.max).sub(t).length();
  }
  getBoundingSphere(t) {
    return (
      this.getCenter(t.center), (t.radius = 0.5 * this.getSize(Ze).length()), t
    );
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return (
      this.isEmpty() ||
        (Qe[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        Qe[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        Qe[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        Qe[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        Qe[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        Qe[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        Qe[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        Qe[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(Qe)),
      this
    );
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const ui = new li(),
  ci = new li(),
  hi = new Ye(),
  pi = new Ye(),
  di = new Ye();
class fi {
  constructor(t = new Ye(), e = -1) {
    (this.center = t), (this.radius = e);
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this;
  }
  setFromPoints(t, e) {
    const i = this.center;
    void 0 !== e ? i.copy(e) : ci.setFromPoints(t).getCenter(i);
    let n = 0;
    for (let r = 0, o = t.length; r < o; r++)
      n = Math.max(n, i.distanceToSquared(t[r]));
    return (this.radius = Math.sqrt(n)), this;
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const i = this.center.distanceToSquared(t);
    return (
      e.copy(t),
      i > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    );
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    di.subVectors(t, this.center);
    const e = di.lengthSq();
    if (e > this.radius * this.radius) {
      const t = Math.sqrt(e),
        i = 0.5 * (t - this.radius);
      this.center.add(di.multiplyScalar(i / t)), (this.radius += i);
    }
    return this;
  }
  union(t) {
    return (
      pi.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
      this.expandByPoint(hi.copy(t.center).add(pi)),
      this.expandByPoint(hi.copy(t.center).sub(pi)),
      this
    );
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new fi().copy(this);
  }
}
const gi = new Ye(),
  mi = new Ye(),
  yi = new Ye(),
  vi = new Ye(),
  bi = new Ye(),
  xi = new Ye(),
  _i = new Ye();
class Si {
  constructor(t = new Ye(), e = new Ye(0, 0, -1)) {
    (this.origin = t), (this.direction = e);
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, gi)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const i = e.dot(this.direction);
    return i < 0
      ? e.copy(this.origin)
      : e.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = gi.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (gi.copy(this.direction).multiplyScalar(e).add(this.origin),
        gi.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, i, n) {
    mi.copy(t).add(e).multiplyScalar(0.5),
      yi.copy(e).sub(t).normalize(),
      vi.copy(this.origin).sub(mi);
    const r = 0.5 * t.distanceTo(e),
      o = -this.direction.dot(yi),
      a = vi.dot(this.direction),
      s = -vi.dot(yi),
      l = vi.lengthSq(),
      u = Math.abs(1 - o * o);
    let c, h, p, d;
    if (u > 0)
      if (((c = o * s - a), (h = o * a - s), (d = r * u), c >= 0))
        if (h >= -d)
          if (h <= d) {
            const t = 1 / u;
            (c *= t),
              (h *= t),
              (p = c * (c + o * h + 2 * a) + h * (o * c + h + 2 * s) + l);
          } else
            (h = r),
              (c = Math.max(0, -(o * h + a))),
              (p = -c * c + h * (h + 2 * s) + l);
        else
          (h = -r),
            (c = Math.max(0, -(o * h + a))),
            (p = -c * c + h * (h + 2 * s) + l);
      else
        h <= -d
          ? ((c = Math.max(0, -(-o * r + a))),
            (h = c > 0 ? -r : Math.min(Math.max(-r, -s), r)),
            (p = -c * c + h * (h + 2 * s) + l))
          : h <= d
          ? ((c = 0),
            (h = Math.min(Math.max(-r, -s), r)),
            (p = h * (h + 2 * s) + l))
          : ((c = Math.max(0, -(o * r + a))),
            (h = c > 0 ? r : Math.min(Math.max(-r, -s), r)),
            (p = -c * c + h * (h + 2 * s) + l));
    else
      (h = o > 0 ? -r : r),
        (c = Math.max(0, -(o * h + a))),
        (p = -c * c + h * (h + 2 * s) + l);
    return (
      i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
      n && n.copy(yi).multiplyScalar(h).add(mi),
      p
    );
  }
  intersectSphere(t, e) {
    gi.subVectors(t.center, this.origin);
    const i = gi.dot(this.direction),
      n = gi.dot(gi) - i * i,
      r = t.radius * t.radius;
    if (n > r) return null;
    const o = Math.sqrt(r - n),
      a = i - o,
      s = i + o;
    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
    const i = -(this.origin.dot(t.normal) + t.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(t, e) {
    const i = this.distanceToPlane(t);
    return null === i ? null : this.at(i, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    if (0 === e) return !0;
    return t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let i, n, r, o, a, s;
    const l = 1 / this.direction.x,
      u = 1 / this.direction.y,
      c = 1 / this.direction.z,
      h = this.origin;
    return (
      l >= 0
        ? ((i = (t.min.x - h.x) * l), (n = (t.max.x - h.x) * l))
        : ((i = (t.max.x - h.x) * l), (n = (t.min.x - h.x) * l)),
      u >= 0
        ? ((r = (t.min.y - h.y) * u), (o = (t.max.y - h.y) * u))
        : ((r = (t.max.y - h.y) * u), (o = (t.min.y - h.y) * u)),
      i > o || r > n
        ? null
        : ((r > i || i != i) && (i = r),
          (o < n || n != n) && (n = o),
          c >= 0
            ? ((a = (t.min.z - h.z) * c), (s = (t.max.z - h.z) * c))
            : ((a = (t.max.z - h.z) * c), (s = (t.min.z - h.z) * c)),
          i > s || a > n
            ? null
            : ((a > i || i != i) && (i = a),
              (s < n || n != n) && (n = s),
              n < 0 ? null : this.at(i >= 0 ? i : n, e)))
    );
  }
  intersectsBox(t) {
    return null !== this.intersectBox(t, gi);
  }
  intersectTriangle(t, e, i, n, r) {
    bi.subVectors(e, t), xi.subVectors(i, t), _i.crossVectors(bi, xi);
    let o,
      a = this.direction.dot(_i);
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else {
      if (!(a < 0)) return null;
      (o = -1), (a = -a);
    }
    vi.subVectors(this.origin, t);
    const s = o * this.direction.dot(xi.crossVectors(vi, xi));
    if (s < 0) return null;
    const l = o * this.direction.dot(bi.cross(vi));
    if (l < 0) return null;
    if (s + l > a) return null;
    const u = -o * vi.dot(_i);
    return u < 0 ? null : this.at(u / a, r);
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    );
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new Si().copy(this);
  }
}
class Mi {
  constructor() {
    (this.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      (this._v1 = new Ye()),
      (this._zero = new Ye(0, 0, 0)),
      (this._one = new Ye(1, 1, 1)),
      (this._x = new Ye()),
      (this._y = new Ye()),
      (this._z = new Ye()),
      arguments.length > 0 &&
        console.error(
          "@dp/gis-engine: Matrix4: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, i, n, r, o, a, s, l, u, c, h, p, d, f, g) {
    const m = this.elements;
    return (
      (m[0] = t),
      (m[4] = e),
      (m[8] = i),
      (m[12] = n),
      (m[1] = r),
      (m[5] = o),
      (m[9] = a),
      (m[13] = s),
      (m[2] = l),
      (m[6] = u),
      (m[10] = c),
      (m[14] = h),
      (m[3] = p),
      (m[7] = d),
      (m[11] = f),
      (m[15] = g),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Mi().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      i = t.elements;
    return (
      (e[0] = i[0]),
      (e[1] = i[1]),
      (e[2] = i[2]),
      (e[3] = i[3]),
      (e[4] = i[4]),
      (e[5] = i[5]),
      (e[6] = i[6]),
      (e[7] = i[7]),
      (e[8] = i[8]),
      (e[9] = i[9]),
      (e[10] = i[10]),
      (e[11] = i[11]),
      (e[12] = i[12]),
      (e[13] = i[13]),
      (e[14] = i[14]),
      (e[15] = i[15]),
      this
    );
  }
  copyPosition(t) {
    const e = this.elements,
      i = t.elements;
    return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return (
      this.set(
        e[0],
        e[3],
        e[6],
        0,
        e[1],
        e[4],
        e[7],
        0,
        e[2],
        e[5],
        e[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(t, e, i) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(t, e, i) {
    return (
      this.set(
        t.x,
        e.x,
        i.x,
        0,
        t.y,
        e.y,
        i.y,
        0,
        t.z,
        e.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(t) {
    const e = this.elements,
      i = t.elements,
      n = 1 / this._v1.setFromMatrixColumn(t, 0).length(),
      r = 1 / this._v1.setFromMatrixColumn(t, 1).length(),
      o = 1 / this._v1.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = i[0] * n),
      (e[1] = i[1] * n),
      (e[2] = i[2] * n),
      (e[3] = 0),
      (e[4] = i[4] * r),
      (e[5] = i[5] * r),
      (e[6] = i[6] * r),
      (e[7] = 0),
      (e[8] = i[8] * o),
      (e[9] = i[9] * o),
      (e[10] = i[10] * o),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromEuler(t) {
    (t && t.isEuler) ||
      console.error(
        "@dp/gis-engine: Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
    const e = this.elements,
      i = t.x,
      n = t.y,
      r = t.z,
      o = Math.cos(i),
      a = Math.sin(i),
      s = Math.cos(n),
      l = Math.sin(n),
      u = Math.cos(r),
      c = Math.sin(r);
    if ("XYZ" === t.order) {
      const t = o * u,
        i = o * c,
        n = a * u,
        r = a * c;
      (e[0] = s * u),
        (e[4] = -s * c),
        (e[8] = l),
        (e[1] = i + n * l),
        (e[5] = t - r * l),
        (e[9] = -a * s),
        (e[2] = r - t * l),
        (e[6] = n + i * l),
        (e[10] = o * s);
    } else if ("YXZ" === t.order) {
      const t = s * u,
        i = s * c,
        n = l * u,
        r = l * c;
      (e[0] = t + r * a),
        (e[4] = n * a - i),
        (e[8] = o * l),
        (e[1] = o * c),
        (e[5] = o * u),
        (e[9] = -a),
        (e[2] = i * a - n),
        (e[6] = r + t * a),
        (e[10] = o * s);
    } else if ("ZXY" === t.order) {
      const t = s * u,
        i = s * c,
        n = l * u,
        r = l * c;
      (e[0] = t - r * a),
        (e[4] = -o * c),
        (e[8] = n + i * a),
        (e[1] = i + n * a),
        (e[5] = o * u),
        (e[9] = r - t * a),
        (e[2] = -o * l),
        (e[6] = a),
        (e[10] = o * s);
    } else if ("ZYX" === t.order) {
      const t = o * u,
        i = o * c,
        n = a * u,
        r = a * c;
      (e[0] = s * u),
        (e[4] = n * l - i),
        (e[8] = t * l + r),
        (e[1] = s * c),
        (e[5] = r * l + t),
        (e[9] = i * l - n),
        (e[2] = -l),
        (e[6] = a * s),
        (e[10] = o * s);
    } else if ("YZX" === t.order) {
      const t = o * s,
        i = o * l,
        n = a * s,
        r = a * l;
      (e[0] = s * u),
        (e[4] = r - t * c),
        (e[8] = n * c + i),
        (e[1] = c),
        (e[5] = o * u),
        (e[9] = -a * u),
        (e[2] = -l * u),
        (e[6] = i * c + n),
        (e[10] = t - r * c);
    } else if ("XZY" === t.order) {
      const t = o * s,
        i = o * l,
        n = a * s,
        r = a * l;
      (e[0] = s * u),
        (e[4] = -c),
        (e[8] = l * u),
        (e[1] = t * c + r),
        (e[5] = o * u),
        (e[9] = i * c - n),
        (e[2] = n * c - i),
        (e[6] = a * u),
        (e[10] = r * c + t);
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(t) {
    return this.compose(this._zero, t, this._one);
  }
  lookAt(t, e, i) {
    const n = this.elements;
    return (
      this._z.subVectors(t, e),
      0 === this._z.lengthSq() && (this._z.z = 1),
      this._z.normalize(),
      this._x.crossVectors(i, this._z),
      0 === this._x.lengthSq() &&
        (1 === Math.abs(i.z) ? (this._z.x += 1e-4) : (this._z.z += 1e-4),
        this._z.normalize(),
        this._x.crossVectors(i, this._z)),
      this._x.normalize(),
      this._y.crossVectors(this._z, this._x),
      (n[0] = this._x.x),
      (n[4] = this._y.x),
      (n[8] = this._z.x),
      (n[1] = this._x.y),
      (n[5] = this._y.y),
      (n[9] = this._z.y),
      (n[2] = this._x.z),
      (n[6] = this._y.z),
      (n[10] = this._z.z),
      this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements,
      n = e.elements,
      r = this.elements,
      o = i[0],
      a = i[4],
      s = i[8],
      l = i[12],
      u = i[1],
      c = i[5],
      h = i[9],
      p = i[13],
      d = i[2],
      f = i[6],
      g = i[10],
      m = i[14],
      y = i[3],
      v = i[7],
      b = i[11],
      x = i[15],
      _ = n[0],
      S = n[4],
      M = n[8],
      C = n[12],
      w = n[1],
      A = n[5],
      E = n[9],
      D = n[13],
      T = n[2],
      P = n[6],
      L = n[10],
      I = n[14],
      N = n[3],
      R = n[7],
      O = n[11],
      F = n[15];
    return (
      (r[0] = o * _ + a * w + s * T + l * N),
      (r[4] = o * S + a * A + s * P + l * R),
      (r[8] = o * M + a * E + s * L + l * O),
      (r[12] = o * C + a * D + s * I + l * F),
      (r[1] = u * _ + c * w + h * T + p * N),
      (r[5] = u * S + c * A + h * P + p * R),
      (r[9] = u * M + c * E + h * L + p * O),
      (r[13] = u * C + c * D + h * I + p * F),
      (r[2] = d * _ + f * w + g * T + m * N),
      (r[6] = d * S + f * A + g * P + m * R),
      (r[10] = d * M + f * E + g * L + m * O),
      (r[14] = d * C + f * D + g * I + m * F),
      (r[3] = y * _ + v * w + b * T + x * N),
      (r[7] = y * S + v * A + b * P + x * R),
      (r[11] = y * M + v * E + b * L + x * O),
      (r[15] = y * C + v * D + b * I + x * F),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      i = t[4],
      n = t[8],
      r = t[12],
      o = t[1],
      a = t[5],
      s = t[9],
      l = t[13],
      u = t[2],
      c = t[6],
      h = t[10],
      p = t[14];
    return (
      t[3] *
        (+r * s * c -
          n * l * c -
          r * a * h +
          i * l * h +
          n * a * p -
          i * s * p) +
      t[7] *
        (+e * s * p -
          e * l * h +
          r * o * h -
          n * o * p +
          n * l * u -
          r * s * u) +
      t[11] *
        (+e * l * c -
          e * a * p -
          r * o * c +
          i * o * p +
          r * a * u -
          i * l * u) +
      t[15] *
        (-n * a * u - e * s * c + e * a * h + n * o * c - i * o * h + i * s * u)
    );
  }
  transpose() {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(t, e, i) {
    const n = this.elements;
    return (
      t instanceof Ye
        ? ((n[12] = t.x), (n[13] = t.y), (n[14] = t.z))
        : ((n[12] = t), (n[13] = e), (n[14] = i)),
      this
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      i = t[1],
      n = t[2],
      r = t[3],
      o = t[4],
      a = t[5],
      s = t[6],
      l = t[7],
      u = t[8],
      c = t[9],
      h = t[10],
      p = t[11],
      d = t[12],
      f = t[13],
      g = t[14],
      m = t[15],
      y = c * g * l - f * h * l + f * s * p - a * g * p - c * s * m + a * h * m,
      v = d * h * l - u * g * l - d * s * p + o * g * p + u * s * m - o * h * m,
      b = u * f * l - d * c * l + d * a * p - o * f * p - u * a * m + o * c * m,
      x = d * c * s - u * f * s - d * a * h + o * f * h + u * a * g - o * c * g,
      _ = e * y + i * v + n * b + r * x;
    if (0 === _)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / _;
    return (
      (t[0] = y * S),
      (t[1] =
        (f * h * r -
          c * g * r -
          f * n * p +
          i * g * p +
          c * n * m -
          i * h * m) *
        S),
      (t[2] =
        (a * g * r -
          f * s * r +
          f * n * l -
          i * g * l -
          a * n * m +
          i * s * m) *
        S),
      (t[3] =
        (c * s * r -
          a * h * r -
          c * n * l +
          i * h * l +
          a * n * p -
          i * s * p) *
        S),
      (t[4] = v * S),
      (t[5] =
        (u * g * r -
          d * h * r +
          d * n * p -
          e * g * p -
          u * n * m +
          e * h * m) *
        S),
      (t[6] =
        (d * s * r -
          o * g * r -
          d * n * l +
          e * g * l +
          o * n * m -
          e * s * m) *
        S),
      (t[7] =
        (o * h * r -
          u * s * r +
          u * n * l -
          e * h * l -
          o * n * p +
          e * s * p) *
        S),
      (t[8] = b * S),
      (t[9] =
        (d * c * r -
          u * f * r -
          d * i * p +
          e * f * p +
          u * i * m -
          e * c * m) *
        S),
      (t[10] =
        (o * f * r -
          d * a * r +
          d * i * l -
          e * f * l -
          o * i * m +
          e * a * m) *
        S),
      (t[11] =
        (u * a * r -
          o * c * r -
          u * i * l +
          e * c * l +
          o * i * p -
          e * a * p) *
        S),
      (t[12] = x * S),
      (t[13] =
        (u * f * n -
          d * c * n +
          d * i * h -
          e * f * h -
          u * i * g +
          e * c * g) *
        S),
      (t[14] =
        (d * a * n -
          o * f * n -
          d * i * s +
          e * f * s +
          o * i * g -
          e * a * g) *
        S),
      (t[15] =
        (o * c * n -
          u * a * n +
          u * i * s -
          e * c * s -
          o * i * h +
          e * a * h) *
        S),
      this
    );
  }
  scale(t) {
    const e = this.elements,
      i = t.x,
      n = t.y,
      r = t.z;
    return (
      (e[0] *= i),
      (e[4] *= n),
      (e[8] *= r),
      (e[1] *= i),
      (e[5] *= n),
      (e[9] *= r),
      (e[2] *= i),
      (e[6] *= n),
      (e[10] *= r),
      (e[3] *= i),
      (e[7] *= n),
      (e[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, i, n));
  }
  makeTranslation(t, e, i) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      i = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      i = Math.sin(t);
    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      i = Math.sin(t);
    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const i = Math.cos(e),
      n = Math.sin(e),
      r = 1 - i,
      o = t.x,
      a = t.y,
      s = t.z,
      l = r * o,
      u = r * a;
    return (
      this.set(
        l * o + i,
        l * a - n * s,
        l * s + n * a,
        0,
        l * a + n * s,
        u * a + i,
        u * s - n * o,
        0,
        l * s - n * a,
        u * s + n * o,
        r * s * s + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(t, e, i) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, i, n, r, o) {
    return this.set(1, i, r, 0, t, 1, o, 0, e, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, i) {
    const n = this.elements,
      r = e._x,
      o = e._y,
      a = e._z,
      s = e._w,
      l = r + r,
      u = o + o,
      c = a + a,
      h = r * l,
      p = r * u,
      d = r * c,
      f = o * u,
      g = o * c,
      m = a * c,
      y = s * l,
      v = s * u,
      b = s * c,
      x = i.x,
      _ = i.y,
      S = i.z;
    return (
      (n[0] = (1 - (f + m)) * x),
      (n[1] = (p + b) * x),
      (n[2] = (d - v) * x),
      (n[3] = 0),
      (n[4] = (p - b) * _),
      (n[5] = (1 - (h + m)) * _),
      (n[6] = (g + y) * _),
      (n[7] = 0),
      (n[8] = (d + v) * S),
      (n[9] = (g - y) * S),
      (n[10] = (1 - (h + f)) * S),
      (n[11] = 0),
      (n[12] = t.x),
      (n[13] = t.y),
      (n[14] = t.z),
      (n[15] = 1),
      this
    );
  }
  decompose(t, e, i) {
    const n = this.elements;
    let r = this._v1.set(n[0], n[1], n[2]).length();
    const o = this._v1.set(n[4], n[5], n[6]).length(),
      a = this._v1.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (r = -r),
      (t.x = n[12]),
      (t.y = n[13]),
      (t.z = n[14]),
      Ci.copy(this);
    const s = 1 / r,
      l = 1 / o,
      u = 1 / a;
    return (
      (Ci.elements[0] *= s),
      (Ci.elements[1] *= s),
      (Ci.elements[2] *= s),
      (Ci.elements[4] *= l),
      (Ci.elements[5] *= l),
      (Ci.elements[6] *= l),
      (Ci.elements[8] *= u),
      (Ci.elements[9] *= u),
      (Ci.elements[10] *= u),
      e.setFromRotationMatrix(Ci),
      (i.x = r),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(t, e, i, n, r, o) {
    const a = this.elements,
      s = (2 * r) / (e - t),
      l = (2 * r) / (i - n),
      u = (e + t) / (e - t),
      c = (i + n) / (i - n),
      h = -(o + r) / (o - r),
      p = (-2 * o * r) / (o - r);
    return (
      (a[0] = s),
      (a[4] = 0),
      (a[8] = u),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = l),
      (a[9] = c),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = h),
      (a[14] = p),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(t, e, i, n, r, o) {
    const a = this.elements,
      s = 1 / (e - t),
      l = 1 / (i - n),
      u = 1 / (o - r),
      c = (e + t) * s,
      h = (i + n) * l,
      p = (o + r) * u;
    return (
      (a[0] = 2 * s),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -c),
      (a[1] = 0),
      (a[5] = 2 * l),
      (a[9] = 0),
      (a[13] = -h),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * u),
      (a[14] = -p),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      i = t.elements;
    for (let n = 0; n < 16; n++) if (e[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(t = [], e = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return (
      (t[e] = i[0]),
      (t[e + 1] = i[1]),
      (t[e + 2] = i[2]),
      (t[e + 3] = i[3]),
      (t[e + 4] = i[4]),
      (t[e + 5] = i[5]),
      (t[e + 6] = i[6]),
      (t[e + 7] = i[7]),
      (t[e + 8] = i[8]),
      (t[e + 9] = i[9]),
      (t[e + 10] = i[10]),
      (t[e + 11] = i[11]),
      (t[e + 12] = i[12]),
      (t[e + 13] = i[13]),
      (t[e + 14] = i[14]),
      (t[e + 15] = i[15]),
      t
    );
  }
}
const Ci = new Mi(),
  wi = new Mi(),
  Ai = new We();
class Ei {
  constructor(t = 0, e = 0, i = 0, n = "XYZ") {
    (this.isEuler = !0),
      (this.DefaultOrder = "XYZ"),
      (this.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
      (this._x = t),
      (this._y = e),
      (this._z = i),
      (this._order = n);
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    (this._order = t), this._onChangeCallback();
  }
  set(t, e, i, n = this._order) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = i),
      (this._order = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new Ei(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t, e = this._order, i = !0) {
    const n = t.elements,
      r = n[0],
      o = n[4],
      a = n[8],
      s = n[1],
      l = n[5],
      u = n[9],
      c = n[2],
      h = n[6],
      p = n[10];
    switch (e) {
      case "XYZ":
        (this._y = Math.asin(Ae(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-o, r)))
            : ((this._x = Math.atan2(h, l)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Ae(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(s, l)))
            : ((this._y = Math.atan2(-c, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Ae(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-c, p)), (this._z = Math.atan2(-o, l)))
            : ((this._y = 0), (this._z = Math.atan2(s, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Ae(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(h, p)), (this._z = Math.atan2(s, r)))
            : ((this._x = 0), (this._z = Math.atan2(-o, l)));
        break;
      case "YZX":
        (this._z = Math.asin(Ae(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(-u, l)), (this._y = Math.atan2(-c, r)))
            : ((this._x = 0), (this._y = Math.atan2(a, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-Ae(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, r)))
            : ((this._x = Math.atan2(-u, p)), (this._y = 0));
    }
    return (this._order = e), !0 === i && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, i) {
    return (
      wi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(wi, e, i)
    );
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return Ai.setFromEuler(this), this.setFromQuaternion(Ai, t);
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    );
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      void 0 !== t[3] && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    );
  }
  toVector3(t) {
    return t
      ? t.set(this._x, this._y, this._z)
      : new Ye(this._x, this._y, this._z);
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
class Di {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = 1 << t;
  }
  enable(t) {
    this.mask |= 1 << t;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t;
  }
  disable(t) {
    this.mask &= ~(1 << t);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return !!(this.mask & t.mask);
  }
  isEnabled(t) {
    return !!(this.mask & (1 << t));
  }
}
let Ti = 0;
const Pi = new Ye(),
  Li = new We(),
  Ii = new Mi(),
  Ni = new Ye(),
  Ri = new Ye(),
  Oi = new Ye(),
  Fi = new We(),
  zi = new Ye(1, 0, 0),
  ki = new Ye(0, 1, 0),
  Bi = new Ye(0, 0, 1),
  Gi = {
    type: "added",
  },
  Ui = {
    type: "removed",
  },
  ji = class extends vt {
    constructor() {
      super(),
        (this.isObject3D = !0),
        (this.id = Ti++),
        (this.uuid = we()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.ext = {}),
        (this.up = ji.DefaultUp.clone());
      const t = new Ye(),
        e = new Ei(),
        i = new We(),
        n = new Ye(1, 1, 1);
      e._onChange(function () {
        i.setFromEuler(e, !1);
      }),
        i._onChange(function () {
          e.setFromQuaternion(i, void 0, !1);
        }),
        (this.position = t),
        (this.rotation = e),
        (this.quaternion = i),
        (this.scale = n),
        (this.modelViewMatrix = new Mi()),
        (this.normalMatrix = new Ie()),
        (this.matrix = new Mi()),
        (this.matrixWorld = new Mi()),
        (this.matrixAutoUpdate = ji.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new Di()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeRender(t, e, i, n, r, o) {}
    onAfterRender(t, e, i, n, r, o) {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    copyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.copy(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRenderIndex(t) {
      (this.renderOrder = t),
        Array.isArray(this.material)
          ? this.material.forEach((e) => e.setPolygonOffset(t))
          : this.material.setPolygonOffset(t);
    }
    setOpacity(t) {
      if (
        (this.children.forEach((e) => {
          e.setOpacity(t);
        }),
        Array.isArray(this.material))
      )
        for (let e = 0, i = this.material.length; e < i; e++)
          (this.material[e].transparent = !0), (this.material[e].opacity = t);
      else (this.material.transparent = !0), (this.material.opacity = t);
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return Li.setFromAxisAngle(t, e), this.quaternion.multiply(Li), this;
    }
    rotateOnWorldAxis(t, e) {
      return Li.setFromAxisAngle(t, e), this.quaternion.premultiply(Li), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(zi, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(ki, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(Bi, t);
    }
    translateOnAxis(t, e) {
      return (
        Pi.copy(t).applyQuaternion(this.quaternion),
        this.position.add(Pi.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(zi, t);
    }
    translateY(t) {
      return this.translateOnAxis(ki, t);
    }
    translateZ(t) {
      return this.translateOnAxis(Bi, t);
    }
    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return t.applyMatrix4(Ii.copy(this.matrixWorld).invert());
    }
    lookAt(t, e, i) {
      t instanceof Ye ? Ni.copy(t) : Ni.set(t, e, i);
      const n = this.parent;
      this.updateWorldMatrix(!0, !1),
        Ri.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? Ii.lookAt(Ri, Ni, this.up)
          : Ii.lookAt(Ni, Ri, this.up),
        this.quaternion.setFromRotationMatrix(Ii),
        n &&
          (Ii.extractRotation(n.matrixWorld),
          Li.setFromRotationMatrix(Ii),
          this.quaternion.premultiply(Li.invert()));
    }
    add(...t) {
      if (t.length >= 1) {
        for (let e = 0; e < t.length; e++) this._add(t[e]);
        return this;
      }
    }
    _add(t) {
      return t === this
        ? (console.error(
            "Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(Gi))
            : console.error(
                "@dp/gis-engine: Object3D.add: object not an instance of Object3D.",
                t
              ),
          this);
    }
    remove(...t) {
      if (t.length >= 1) {
        for (let e = 0; e < t.length; e++) this._remove(t[e]);
        return this;
      }
    }
    _remove(t) {
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Ui)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        (e.parent = null), e.dispatchEvent(Ui);
      }
      return (this.children.length = 0), this;
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        Ii.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          Ii.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(Ii),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let i = 0, n = this.children.length; i < n; i++) {
        const n = this.children[i].getObjectByProperty(t, e);
        if (void 0 !== n) return n;
      }
    }
    getObjectByFn(t) {
      if (t(this)) return this;
      for (let e = 0, i = this.children.length; e < i; e++) {
        const i = this.children[e].getObjectByFn(t);
        if (void 0 !== i) return i;
      }
    }
    getObjectsByFn(t) {
      const e = [];
      t(this) && e.push(this);
      for (let i = 0, n = this.children.length; i < n; i++) {
        const n = this.children[i].getObjectByFn(t);
        void 0 !== n && e.push(n);
      }
      return e;
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ri, t, Oi), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ri, Fi, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast(t, e) {}
    countChildren() {
      let t = 0;
      return (
        this.traverse((e) => {
          e.isGroup || t++;
        }),
        t
      );
    }
    traverse(t) {
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
    }
    updateWorldMatrix(t, e) {
      const i = this.parent;
      if (
        (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        i = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
        }),
        (i.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const n = {};
      function r(e, i) {
        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        !0 === this.castShadow && (n.castShadow = !0),
        !0 === this.receiveShadow && (n.receiveShadow = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.frustumCulled && (n.frustumCulled = !1),
        0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        (n.layers = this.layers.mask),
        (n.matrix = this.matrix.toArray()),
        !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((n.type = "InstancedMesh"),
          (n.count = this.count),
          (n.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (n.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (n.background = this.background.toJSON())
            : this.background.isTexture &&
              (n.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            (n.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const i = e.shapes;
          if (Array.isArray(i))
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              r(t.shapes, n);
            }
          else r(t.shapes, i);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((n.bindMode = this.bindMode),
          (n.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let i = 0, n = this.material.length; i < n; i++)
            e.push(r(t.materials, this.material[i]));
          n.material = e;
        } else n.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        n.children = [];
        for (let e = 0; e < this.children.length; e++)
          n.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        n.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const i = this.animations[e];
          n.animations.push(r(t.animations, i));
        }
      }
      if (e) {
        const e = o(t.geometries),
          n = o(t.materials),
          r = o(t.textures),
          a = o(t.images),
          s = o(t.shapes),
          l = o(t.skeletons),
          u = o(t.animations);
        e.length > 0 && (i.geometries = e),
          n.length > 0 && (i.materials = n),
          r.length > 0 && (i.textures = r),
          a.length > 0 && (i.images = a),
          s.length > 0 && (i.shapes = s),
          l.length > 0 && (i.skeletons = l),
          u.length > 0 && (i.animations = u);
      }
      return (i.object = n), i;
      function o(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          delete n.metadata, e.push(n);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        (this.ext = t.ext),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let i = 0; i < t.children.length; i++) {
          const e = t.children[i];
          this.add(e.clone());
        }
      return this;
    }
    deepClone(t = !0) {
      return new this.constructor().deepCopy(this, t);
    }
    deepCopy(t, e = !0) {
      if (
        ((this.name = t.name),
        (this.ext = JSON.parse(JSON.stringify(t.ext))),
        this.up.copy(t.up),
        this.position.copy(t.position),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        t.material && (this.material = t.material.clone()),
        t.geometry && (this.geometry = t.geometry.clone()),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let i = 0; i < t.children.length; i++) {
          const e = t.children[i];
          this.add(e.deepClone());
        }
      return this;
    }
    dispose() {
      this.geometry && this.geometry.dispose(),
        this.material &&
          (Array.isArray(this.material)
            ? this.material.forEach((t) => {
                t.disposeAll();
              })
            : this.material.disposeAll()),
        this.dispatchEvent(Ui);
    }
    destroy(t = !0) {
      this.traverse((t) => {
        t.dispose();
      }),
        (this.children = []),
        this.parent && t && (this.parent.remove(this), (this.parent = null));
    }
  };
let Hi = ji;
(Hi.DefaultUp = new Ye(0, 1, 0)), (Hi.DefaultMatrixAutoUpdate = !0);
const Vi = new Ye(),
  Wi = new Ye(),
  qi = new Ye(),
  Yi = new Ye(),
  Xi = new Ye(),
  Qi = new Ye(),
  Zi = new Ye(),
  Ji = new Ye(),
  Ki = new Ye(),
  $i = new Ye();
class tn {
  constructor(t = new Ye(), e = new Ye(), i = new Ye()) {
    (this.a = t), (this.b = e), (this.c = i);
  }
  static getNormal(t, e, i, n) {
    n.subVectors(i, e), Vi.subVectors(t, e), n.cross(Vi);
    const r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  static getBarycoord(t, e, i, n, r) {
    Vi.subVectors(n, e), Wi.subVectors(i, e), qi.subVectors(t, e);
    const o = Vi.dot(Vi),
      a = Vi.dot(Wi),
      s = Vi.dot(qi),
      l = Wi.dot(Wi),
      u = Wi.dot(qi),
      c = o * l - a * a;
    if (0 === c) return r.set(-2, -1, -1);
    const h = 1 / c,
      p = (l * s - a * u) * h,
      d = (o * u - a * s) * h;
    return r.set(1 - p - d, d, p);
  }
  static containsPoint(t, e, i, n) {
    return (
      this.getBarycoord(t, e, i, n, Yi),
      Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1
    );
  }
  static getUV(t, e, i, n, r, o, a, s) {
    return (
      this.getBarycoord(t, e, i, n, Yi),
      s.set(0, 0),
      s.addScaledVector(r, Yi.x),
      s.addScaledVector(o, Yi.y),
      s.addScaledVector(a, Yi.z),
      s
    );
  }
  static isFrontFacing(t, e, i, n) {
    return Vi.subVectors(i, e), Wi.subVectors(t, e), Vi.cross(Wi).dot(n) < 0;
  }
  set(t, e, i) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
  }
  setFromPointsAndIndices(t, e, i, n) {
    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
  }
  setFromAttributeAndIndices(t, e, i, n) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, i),
      this.c.fromBufferAttribute(t, n),
      this
    );
  }
  clone() {
    return new tn().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return (
      Vi.subVectors(this.c, this.b),
      Wi.subVectors(this.a, this.b),
      0.5 * Vi.cross(Wi).length()
    );
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return tn.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return tn.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getUV(t, e, i, n, r) {
    return tn.getUV(t, this.a, this.b, this.c, e, i, n, r);
  }
  containsPoint(t) {
    return tn.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return tn.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const i = this.a,
      n = this.b,
      r = this.c;
    let o, a;
    Xi.subVectors(n, i), Qi.subVectors(r, i), Ji.subVectors(t, i);
    const s = Xi.dot(Ji),
      l = Qi.dot(Ji);
    if (s <= 0 && l <= 0) return e.copy(i);
    Ki.subVectors(t, n);
    const u = Xi.dot(Ki),
      c = Qi.dot(Ki);
    if (u >= 0 && c <= u) return e.copy(n);
    const h = s * c - u * l;
    if (h <= 0 && s >= 0 && u <= 0)
      return (o = s / (s - u)), e.copy(i).addScaledVector(Xi, o);
    $i.subVectors(t, r);
    const p = Xi.dot($i),
      d = Qi.dot($i);
    if (d >= 0 && p <= d) return e.copy(r);
    const f = p * l - s * d;
    if (f <= 0 && l >= 0 && d <= 0)
      return (a = l / (l - d)), e.copy(i).addScaledVector(Qi, a);
    const g = u * d - p * c;
    if (g <= 0 && c - u >= 0 && p - d >= 0)
      return (
        Zi.subVectors(r, n),
        (a = (c - u) / (c - u + (p - d))),
        e.copy(n).addScaledVector(Zi, a)
      );
    const m = 1 / (g + f + h);
    return (
      (o = f * m),
      (a = h * m),
      e.copy(i).addScaledVector(Xi, o).addScaledVector(Qi, a)
    );
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const en = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  nn = {
    h: 0,
    s: 0,
    l: 0,
  },
  rn = {
    h: 0,
    s: 0,
    l: 0,
  };
function on(t, e, i) {
  return (
    i < 0 && (i += 1),
    i > 1 && (i -= 1),
    i < 1 / 6
      ? t + 6 * (e - t) * i
      : i < 0.5
      ? e
      : i < 2 / 3
      ? t + 6 * (e - t) * (2 / 3 - i)
      : t
  );
}
function an(t) {
  return t < 0.04045
    ? 0.0773993808 * t
    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
}
function sn(t) {
  return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
class ln {
  constructor(t, e, i) {
    return (
      (this.NAMES = en),
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    );
  }
  set(t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : "number" == typeof t
        ? this.setHex(t)
        : "string" == typeof t && this.setStyle(t),
      this
    );
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (255 & t) / 255),
      this
    );
  }
  setRGB(t, e, i) {
    return (this.r = t), (this.g = e), (this.b = i), this;
  }
  setHSL(t, e, i) {
    var n;
    if (
      ((t = ((t % (n = 1)) + n) % n),
      (e = Ae(e, 0, 1)),
      (i = Ae(i, 0, 1)),
      0 === e)
    )
      this.r = this.g = this.b = i;
    else {
      const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
        r = 2 * i - n;
      (this.r = on(r, n, t + 1 / 3)),
        (this.g = on(r, n, t)),
        (this.b = on(r, n, t - 1 / 3));
    }
    return this;
  }
  setStyle(t) {
    let e;
    if ((e = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
      let t;
      const i = e[1],
        n = e[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (
            (t =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
              t[4],
              this
            );
          if (
            (t =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
              t[4],
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (t =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          ) {
            const e = parseFloat(t[1]) / 360,
              i = parseInt(t[2], 10) / 100,
              n = parseInt(t[3], 10) / 100;
            return t[4], this.setHSL(e, i, n);
          }
      }
    } else if ((e = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const t = e[1],
        i = t.length;
      if (3 === i)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
          (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
          (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
          this
        );
      if (6 === i)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
          (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
          (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
          this
        );
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  }
  setColorName(t) {
    const e = en[t.toLowerCase()];
    return void 0 !== e && this.setHex(e), this;
  }
  clone() {
    return new ln(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copyGammaToLinear(t, e = 2) {
    return (
      (this.r = Math.pow(t.r, e)),
      (this.g = Math.pow(t.g, e)),
      (this.b = Math.pow(t.b, e)),
      this
    );
  }
  copyLinearToGamma(t, e = 2) {
    const i = e > 0 ? 1 / e : 1;
    return (
      (this.r = Math.pow(t.r, i)),
      (this.g = Math.pow(t.g, i)),
      (this.b = Math.pow(t.b, i)),
      this
    );
  }
  convertGammaToLinear(t) {
    return this.copyGammaToLinear(this, t), this;
  }
  convertLinearToGamma(t) {
    return this.copyLinearToGamma(this, t), this;
  }
  copySRGBToLinear(t) {
    return (this.r = an(t.r)), (this.g = an(t.g)), (this.b = an(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = sn(t.r)), (this.g = sn(t.g)), (this.b = sn(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ (255 * this.b);
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(t) {
    const e = this.r,
      i = this.g,
      n = this.b,
      r = Math.max(e, i, n),
      o = Math.min(e, i, n);
    let a, s;
    const l = (o + r) / 2;
    if (o === r) (a = 0), (s = 0);
    else {
      const t = r - o;
      switch (((s = l <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
        case e:
          a = (i - n) / t + (i < n ? 6 : 0);
          break;
        case i:
          a = (n - e) / t + 2;
          break;
        case n:
          a = (e - i) / t + 4;
      }
      a /= 6;
    }
    return (t.h = a), (t.s = s), (t.l = l), t;
  }
  getStyle() {
    return (
      "rgb(" +
      ((255 * this.r) | 0) +
      "," +
      ((255 * this.g) | 0) +
      "," +
      ((255 * this.b) | 0) +
      ")"
    );
  }
  offsetHSL(t, e, i) {
    return (
      this.getHSL(nn),
      (nn.h += t),
      (nn.s += e),
      (nn.l += i),
      this.setHSL(nn.h, nn.s, nn.l),
      this
    );
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpColors(t, e, i) {
    return (
      (this.r = t.r + (e.r - t.r) * i),
      (this.g = t.g + (e.g - t.g) * i),
      (this.b = t.b + (e.b - t.b) * i),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL(nn), t.getHSL(rn);
    const i = Ee(nn.h, rn.h, e),
      n = Ee(nn.s, rn.s, e),
      r = Ee(nn.l, rn.l, e);
    return this.setHSL(i, n, r), this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      !0 === t.normalized &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
let un = 0;
const cn = new Map();
class hn extends vt {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", {
        value: un++,
      }),
      (this.uuid = we()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = 1),
      (this.side = 0),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.format = te),
      (this.transparent = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = _t),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ve),
      (this.stencilZFail = ve),
      (this.stencilZPass = ve),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  get sheen() {
    return this._sheen;
  }
  get transmission() {
    return this._transmission;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile(t, e) {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (void 0 !== t)
      for (const e in t) {
        const i = t[e];
        if (void 0 === i) continue;
        if ("shading" === e) {
          this.type, (this.flatShading = 1 === i);
          continue;
        }
        const n = this[e];
        void 0 !== n
          ? n && n.isColor
            ? n.set(i)
            : n && n.isVector3 && i && i.isVector3
            ? n.copy(i)
            : (this[e] = i)
          : this.type;
      }
  }
  toJSON(t) {
    const e = void 0 === t || "string" == typeof t;
    e &&
      (t = {
        textures: {},
        images: {},
      });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    function n(t) {
      const e = [];
      for (const i in t) {
        const n = t[i];
        delete n.metadata, e.push(n);
      }
      return e;
    }
    if (
      ((i.uuid = this.uuid),
      (i.type = this.type),
      "" !== this.name && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      void 0 !== this.roughness && (i.roughness = this.roughness),
      void 0 !== this.metalness && (i.metalness = this.metalness),
      void 0 !== this.sheen && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      void 0 !== this.sheenRoughness &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular,
      this.specular.isColor && (i.specular = this.specular.getHex()),
      void 0 !== this.specularIntensity &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      void 0 !== this.shininess && (i.shininess = this.shininess),
      void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(t).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(t).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(t).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(t).uuid),
        void 0 !== this.combine && (i.combine = this.combine)),
      void 0 !== this.envMapIntensity &&
        (i.envMapIntensity = this.envMapIntensity),
      void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
      void 0 !== this.refractionRatio &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(t).uuid),
      void 0 !== this.transmission && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      void 0 !== this.thickness && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      void 0 !== this.attenuationDistance &&
        (i.attenuationDistance = this.attenuationDistance),
      void 0 !== this.attenuationColor &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      void 0 !== this.size && (i.size = this.size),
      null !== this.shadowSide && (i.shadowSide = this.shadowSide),
      void 0 !== this.sizeAttenuation &&
        (i.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (i.blending = this.blending),
      0 !== this.side && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.format !== te && (i.format = this.format),
      !0 === this.transparent && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
      !0 === this.polygonOffset && (i.polygonOffset = !0),
      0 !== this.polygonOffsetFactor &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
      void 0 !== this.dashSize && (i.dashSize = this.dashSize),
      void 0 !== this.gapSize && (i.gapSize = this.gapSize),
      void 0 !== this.scale && (i.scale = this.scale),
      !0 === this.dithering && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
      !0 === this.premultipliedAlpha &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      !0 === this.wireframe && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      "round" !== this.wireframeLinecap &&
        (i.wireframeLinecap = this.wireframeLinecap),
      "round" !== this.wireframeLinejoin &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.flatShading && (i.flatShading = this.flatShading),
      !1 === this.visible && (i.visible = !1),
      !1 === this.toneMapped && (i.toneMapped = !1),
      "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
      e)
    ) {
      const e = n(t.textures),
        r = n(t.images);
      e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
    }
    return i;
  }
  setPolygonOffset(t) {
    (this.level = t),
      (this.polygonOffset = !0),
      (this.polygonOffsetFactor = 0),
      this.reducePolygonOffsetUnits();
  }
  reducePolygonOffsetUnits() {
    let t = cn.get(this.level);
    t ? ((t += 10), cn.set(this.level, t)) : cn.set(this.level, 1),
      (this.polygonOffsetUnits = 1e5 * -this.level - cn.get(this.level));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.name = t.name),
      (this.fog = t.fog),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.format = t.format),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let i = null;
    if (null !== e) {
      const t = e.length;
      i = new Array(t);
      for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.level = t.level),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      this.level
        ? this.reducePolygonOffsetUnits()
        : (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  disposeAll() {
    this.dispatchEvent({
      type: "dispose",
    });
    for (const t of Object.keys(this)) {
      const e = this[t];
      e && "object" == typeof e && "minFilter" in e && e.dispose();
    }
  }
  set needsUpdate(t) {
    !0 === t && this.version++;
  }
}
class pn extends hn {
  constructor(t) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new ln(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    );
  }
}
const dn = new Ye(),
  fn = new Le();
class gn {
  constructor(t, e, i) {
    if (((this.isBufferAttribute = !0), Array.isArray(t)))
      throw new TypeError(
        "@dp/gis-engine: BufferAttribute: array should be a Typed Array."
      );
    (this.name = ""),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = !0 === i),
      (this.usage = be),
      (this.updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      this
    );
  }
  copyAt(t, e, i) {
    (t *= this.itemSize), (i *= e.itemSize);
    for (let n = 0, r = this.itemSize; n < r; n++)
      this.array[t + n] = e.array[i + n];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  copyColorsArray(t) {
    const e = this.array;
    let i = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const r = t[n];
      (e[i++] = r.r), (e[i++] = r.g), (e[i++] = r.b);
    }
    return this;
  }
  copyVector2sArray(t) {
    const e = this.array;
    let i = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      let r = t[n];
      void 0 === r && (r = new Le()), (e[i++] = r.x), (e[i++] = r.y);
    }
    return this;
  }
  copyVector3sArray(t) {
    const e = this.array;
    let i = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      let r = t[n];
      void 0 === r && (r = new Ye()),
        (e[i++] = r.x),
        (e[i++] = r.y),
        (e[i++] = r.z);
    }
    return this;
  }
  copyVector4sArray(t) {
    const e = this.array;
    let i = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      let r = t[n];
      void 0 === r && (r = new je()),
        (e[i++] = r.x),
        (e[i++] = r.y),
        (e[i++] = r.z),
        (e[i++] = r.w);
    }
    return this;
  }
  applyMatrix3(t) {
    if (2 === this.itemSize)
      for (let e = 0, i = this.count; e < i; e++)
        fn.fromBufferAttribute(this, e),
          fn.applyMatrix3(t),
          this.setXY(e, fn.x, fn.y);
    else if (3 === this.itemSize)
      for (let e = 0, i = this.count; e < i; e++)
        dn.fromBufferAttribute(this, e),
          dn.applyMatrix3(t),
          this.setXYZ(e, dn.x, dn.y, dn.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, i = this.count; e < i; e++)
      (dn.x = this.getX(e)),
        (dn.y = this.getY(e)),
        (dn.z = this.getZ(e)),
        dn.applyMatrix4(t),
        this.setXYZ(e, dn.x, dn.y, dn.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, i = this.count; e < i; e++)
      (dn.x = this.getX(e)),
        (dn.y = this.getY(e)),
        (dn.z = this.getZ(e)),
        dn.applyNormalMatrix(t),
        this.setXYZ(e, dn.x, dn.y, dn.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, i = this.count; e < i; e++)
      (dn.x = this.getX(e)),
        (dn.y = this.getY(e)),
        (dn.z = this.getZ(e)),
        dn.transformDirection(t),
        this.setXYZ(e, dn.x, dn.y, dn.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getX(t) {
    return this.array[t * this.itemSize];
  }
  setX(t, e) {
    return (this.array[t * this.itemSize] = e), this;
  }
  getY(t) {
    return this.array[t * this.itemSize + 1];
  }
  setY(t, e) {
    return (this.array[t * this.itemSize + 1] = e), this;
  }
  getZ(t) {
    return this.array[t * this.itemSize + 2];
  }
  setZ(t, e) {
    return (this.array[t * this.itemSize + 2] = e), this;
  }
  getW(t) {
    return this.array[t * this.itemSize + 3];
  }
  setW(t, e) {
    return (this.array[t * this.itemSize + 3] = e), this;
  }
  setXY(t, e, i) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = i),
      this
    );
  }
  setXYZ(t, e, i, n) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = i),
      (this.array[t + 2] = n),
      this
    );
  }
  setXYZW(t, e, i, n, r) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = i),
      (this.array[t + 2] = n),
      (this.array[t + 3] = r),
      this
    );
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  clone() {
    return new gn(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    };
    return (
      "" !== this.name && (t.name = this.name),
      this.usage !== be && (t.usage = this.usage),
      (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
        (t.updateRange = this.updateRange),
      t
    );
  }
}
class mn extends gn {
  constructor(t, e, i) {
    super(new Uint8ClampedArray(t), e, i);
  }
}
class yn extends gn {
  constructor(t, e, i) {
    super(new Uint16Array(t), e, i);
  }
}
class vn extends gn {
  constructor(t, e, i) {
    super(new Uint32Array(t), e, i);
  }
}
class bn extends gn {
  constructor(t, e, i) {
    super(new Float32Array(t), e, i);
  }
}
let xn = 0;
const _n = new Mi(),
  Sn = new Hi(),
  Mn = new Ye(),
  Cn = new li(),
  wn = new li(),
  An = new Ye();
class En extends vt {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", {
        value: xn++,
      }),
      (this.uuid = we()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = {
        start: 0,
        count: 1 / 0,
      }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return (
      Array.isArray(t)
        ? (this.index = new (Ne(t) > 65535 ? vn : yn)(t, 1))
        : (this.index = t),
      this
    );
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return void 0 !== this.attributes[t];
  }
  addGroup(t, e, i = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: i,
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const i = this.attributes.normal;
    if (void 0 !== i) {
      const e = new Ie().getNormalMatrix(t);
      i.applyNormalMatrix(e), (i.needsUpdate = !0);
    }
    const n = this.attributes.tangent;
    return (
      void 0 !== n && (n.transformDirection(t), (n.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(t) {
    return _n.makeRotationFromQuaternion(t), this.applyMatrix4(_n), this;
  }
  rotateX(t) {
    return _n.makeRotationX(t), this.applyMatrix4(_n), this;
  }
  rotateY(t) {
    return _n.makeRotationY(t), this.applyMatrix4(_n), this;
  }
  rotateZ(t) {
    return _n.makeRotationZ(t), this.applyMatrix4(_n), this;
  }
  translate(t, e, i) {
    return _n.makeTranslation(t, e, i), this.applyMatrix4(_n), this;
  }
  scale(t, e, i) {
    return _n.makeScale(t, e, i), this.applyMatrix4(_n), this;
  }
  lookAt(t) {
    return Sn.lookAt(t), Sn.updateMatrix(), this.applyMatrix4(Sn.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Mn).negate(),
      this.translate(Mn.x, Mn.y, Mn.z),
      this
    );
  }
  setFromPoints(t) {
    const e = [];
    for (let i = 0, n = t.length; i < n; i++) {
      const n = t[i];
      e.push(n.x, n.y, n.z || 0);
    }
    return this.setAttribute("position", new bn(e, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new li());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          '@dp/gis-engine: BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingBox.set(
          new Ye(-1 / 0, -1 / 0, -1 / 0),
          new Ye(1 / 0, 1 / 0, 1 / 0)
        )
      );
    if (void 0 !== t) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let i = 0, n = e.length; i < n; i++) {
          const t = e[i];
          Cn.setFromBufferAttribute(t),
            this.morphTargetsRelative
              ? (An.addVectors(this.boundingBox.min, Cn.min),
                this.boundingBox.expandByPoint(An),
                An.addVectors(this.boundingBox.max, Cn.max),
                this.boundingBox.expandByPoint(An))
              : (this.boundingBox.expandByPoint(Cn.min),
                this.boundingBox.expandByPoint(Cn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        '@dp/gis-engine: BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new fi());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          '@dp/gis-engine: BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingSphere.set(new Ye(), 1 / 0)
      );
    if (t) {
      const i = this.boundingSphere.center;
      if ((Cn.setFromBufferAttribute(t), e))
        for (let t = 0, r = e.length; t < r; t++) {
          const i = e[t];
          wn.setFromBufferAttribute(i),
            this.morphTargetsRelative
              ? (An.addVectors(Cn.min, wn.min),
                Cn.expandByPoint(An),
                An.addVectors(Cn.max, wn.max),
                Cn.expandByPoint(An))
              : (Cn.expandByPoint(wn.min), Cn.expandByPoint(wn.max));
        }
      Cn.getCenter(i);
      let n = 0;
      for (let e = 0, r = t.count; e < r; e++)
        An.fromBufferAttribute(t, e),
          (n = Math.max(n, i.distanceToSquared(An)));
      if (e)
        for (let r = 0, o = e.length; r < o; r++) {
          const o = e[r],
            a = this.morphTargetsRelative;
          for (let e = 0, r = o.count; e < r; e++)
            An.fromBufferAttribute(o, e),
              a && (Mn.fromBufferAttribute(t, e), An.add(Mn)),
              (n = Math.max(n, i.distanceToSquared(An)));
        }
      (this.boundingSphere.radius = Math.sqrt(n)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            '@dp/gis-engine: BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes;
    if (
      null === t ||
      void 0 === e.position ||
      void 0 === e.normal ||
      void 0 === e.uv
    )
      return void console.error(
        "@dp/gis-engine: BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
    const i = t.array,
      n = e.position.array,
      r = e.normal.array,
      o = e.uv.array,
      a = n.length / 3;
    void 0 === e.tangent &&
      this.setAttribute("tangent", new gn(new Float32Array(4 * a), 4));
    const s = e.tangent.array,
      l = [],
      u = [];
    for (let w = 0; w < a; w++) (l[w] = new Ye()), (u[w] = new Ye());
    const c = new Ye(),
      h = new Ye(),
      p = new Ye(),
      d = new Le(),
      f = new Le(),
      g = new Le(),
      m = new Ye(),
      y = new Ye();
    function v(t, e, i) {
      c.fromArray(n, 3 * t),
        h.fromArray(n, 3 * e),
        p.fromArray(n, 3 * i),
        d.fromArray(o, 2 * t),
        f.fromArray(o, 2 * e),
        g.fromArray(o, 2 * i),
        h.sub(c),
        p.sub(c),
        f.sub(d),
        g.sub(d);
      const r = 1 / (f.x * g.y - g.x * f.y);
      isFinite(r) &&
        (m
          .copy(h)
          .multiplyScalar(g.y)
          .addScaledVector(p, -f.y)
          .multiplyScalar(r),
        y
          .copy(p)
          .multiplyScalar(f.x)
          .addScaledVector(h, -g.x)
          .multiplyScalar(r),
        l[t].add(m),
        l[e].add(m),
        l[i].add(m),
        u[t].add(y),
        u[e].add(y),
        u[i].add(y));
    }
    let b = this.groups;
    0 === b.length &&
      (b = [
        {
          start: 0,
          count: i.length,
        },
      ]);
    for (let w = 0, A = b.length; w < A; ++w) {
      const t = b[w],
        e = t.start;
      for (let n = e, r = e + t.count; n < r; n += 3)
        v(i[n + 0], i[n + 1], i[n + 2]);
    }
    const x = new Ye(),
      _ = new Ye(),
      S = new Ye(),
      M = new Ye();
    function C(t) {
      S.fromArray(r, 3 * t), M.copy(S);
      const e = l[t];
      x.copy(e),
        x.sub(S.multiplyScalar(S.dot(e))).normalize(),
        _.crossVectors(M, e);
      const i = _.dot(u[t]) < 0 ? -1 : 1;
      (s[4 * t] = x.x),
        (s[4 * t + 1] = x.y),
        (s[4 * t + 2] = x.z),
        (s[4 * t + 3] = i);
    }
    for (let w = 0, A = b.length; w < A; ++w) {
      const t = b[w],
        e = t.start;
      for (let n = e, r = e + t.count; n < r; n += 3)
        C(i[n + 0]), C(i[n + 1]), C(i[n + 2]);
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute("position");
    if (void 0 !== e) {
      let i = this.getAttribute("normal");
      if (void 0 === i)
        (i = new gn(new Float32Array(3 * e.count), 3)),
          this.setAttribute("normal", i);
      else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
      const n = new Ye(),
        r = new Ye(),
        o = new Ye(),
        a = new Ye(),
        s = new Ye(),
        l = new Ye(),
        u = new Ye(),
        c = new Ye();
      if (t)
        for (let h = 0, p = t.count; h < p; h += 3) {
          const p = t.getX(h + 0),
            d = t.getX(h + 1),
            f = t.getX(h + 2);
          n.fromBufferAttribute(e, p),
            r.fromBufferAttribute(e, d),
            o.fromBufferAttribute(e, f),
            u.subVectors(o, r),
            c.subVectors(n, r),
            u.cross(c),
            a.fromBufferAttribute(i, p),
            s.fromBufferAttribute(i, d),
            l.fromBufferAttribute(i, f),
            a.add(u),
            s.add(u),
            l.add(u),
            i.setXYZ(p, a.x, a.y, a.z),
            i.setXYZ(d, s.x, s.y, s.z),
            i.setXYZ(f, l.x, l.y, l.z);
        }
      else
        for (let t = 0, h = e.count; t < h; t += 3)
          n.fromBufferAttribute(e, t + 0),
            r.fromBufferAttribute(e, t + 1),
            o.fromBufferAttribute(e, t + 2),
            u.subVectors(o, r),
            c.subVectors(n, r),
            u.cross(c),
            i.setXYZ(t + 0, u.x, u.y, u.z),
            i.setXYZ(t + 1, u.x, u.y, u.z),
            i.setXYZ(t + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  merge(t, e) {
    if (!t || !t.isBufferGeometry)
      return void console.error(
        "@dp/gis-engine: BufferGeometry.merge(): geometry not an instance of BufferGeometry.",
        t
      );
    void 0 === e && (e = 0);
    const i = this.attributes;
    for (const n in i) {
      if (void 0 === t.attributes[n]) continue;
      const r = i[n].array,
        o = t.attributes[n],
        a = o.array,
        s = o.itemSize * e,
        l = Math.min(a.length, r.length - s);
      for (let t = 0, e = s; t < l; t++, e++) r[e] = a[t];
    }
    return this;
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, i = t.count; e < i; e++)
      An.fromBufferAttribute(t, e),
        An.normalize(),
        t.setXYZ(e, An.x, An.y, An.z);
  }
  toNonIndexed() {
    function t(t, e) {
      const i = t.array,
        n = t.itemSize,
        r = t.normalized,
        o = new i.constructor(e.length * n);
      let a = 0,
        s = 0;
      for (let l = 0, u = e.length; l < u; l++) {
        a = t.isInterleavedBufferAttribute
          ? e[l] * t.data.stride + t.offset
          : e[l] * n;
        for (let t = 0; t < n; t++) o[s++] = i[a++];
      }
      return new gn(o, n, r);
    }
    if (null === this.index) return this;
    const e = new En(),
      i = this.index.array,
      n = this.attributes;
    for (const a in n) {
      const r = t(n[a], i);
      e.setAttribute(a, r);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const n = [],
        o = r[a];
      for (let e = 0, r = o.length; e < r; e++) {
        const r = t(o[e], i);
        n.push(r);
      }
      e.morphAttributes[a] = n;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, s = o.length; a < s; a++) {
      const t = o[a];
      e.addGroup(t.start, t.count, t.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      "" !== this.name && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const e = this.parameters;
      for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
      return t;
    }
    t.data = {
      attributes: {},
    };
    const e = this.index;
    null !== e &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const i = this.attributes;
    for (const s in i) {
      const e = i[s];
      t.data.attributes[s] = e.toJSON(t.data);
    }
    const n = {};
    let r = !1;
    for (const s in this.morphAttributes) {
      const e = this.morphAttributes[s],
        i = [];
      for (let n = 0, r = e.length; n < r; n++) {
        const r = e[n];
        i.push(r.toJSON(t.data));
      }
      i.length > 0 && ((n[s] = i), (r = !0));
    }
    r &&
      ((t.data.morphAttributes = n),
      (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      null !== a &&
        (t.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      t
    );
  }
  clone() {
    return new En().copy(this);
  }
  copy(t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const i = t.index;
    null !== i && this.setIndex(i.clone(e));
    const n = t.attributes;
    for (const l in n) {
      const t = n[l];
      this.setAttribute(l, t.clone(e));
    }
    const r = t.morphAttributes;
    for (const l in r) {
      const t = [],
        i = r[l];
      for (let n = 0, r = i.length; n < r; n++) t.push(i[n].clone(e));
      this.morphAttributes[l] = t;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const t = o[l];
      this.addGroup(t.start, t.count, t.materialIndex);
    }
    const a = t.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    const s = t.boundingSphere;
    return (
      null !== s && (this.boundingSphere = s.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      void 0 !== t.parameters &&
        (this.parameters = Object.assign({}, t.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
const Dn = new Mi(),
  Tn = new Si(),
  Pn = new fi(),
  Ln = new Ye(),
  In = new Ye(),
  Nn = new Ye(),
  Rn = new Ye(),
  On = new Ye(),
  Fn = new Ye(),
  zn = new Ye(),
  kn = new Ye(),
  Bn = new Ye(),
  Gn = new Le(),
  Un = new Le(),
  jn = new Le(),
  Hn = new Ye(),
  Vn = new Ye();
class Wn extends Hi {
  constructor(t = new En(), e = new pn()) {
    super(),
      (this.geometry = t),
      (this.material = e),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      void 0 !== t.morphTargetInfluences &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      void 0 !== t.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        i = Object.keys(e);
      if (i.length > 0) {
        const t = e[i[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[i] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "@dp/gis-engine: Mesh.updateMorphTargets() no longer supports Geometry. Use BufferGeometry instead."
        );
    }
  }
  raycast(t, e) {
    const i = this.geometry,
      n = this.material,
      r = this.matrixWorld;
    if (void 0 === n) return;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      Pn.copy(i.boundingSphere),
      Pn.applyMatrix4(r),
      !1 === t.ray.intersectsSphere(Pn))
    )
      return;
    if (
      (Dn.copy(r).invert(),
      Tn.copy(t.ray).applyMatrix4(Dn),
      null !== i.boundingBox && !1 === Tn.intersectsBox(i.boundingBox))
    )
      return;
    let o;
    if (i.isBufferGeometry) {
      const r = i.index,
        a = i.attributes.position,
        s = i.morphAttributes.position,
        l = i.morphTargetsRelative,
        u = i.attributes.uv,
        c = i.attributes.uv2,
        h = i.groups,
        p = i.drawRange;
      if (null !== r)
        if (Array.isArray(n))
          for (let i = 0, d = h.length; i < d; i++) {
            const d = h[i],
              f = n[d.materialIndex];
            if (void 0 === f) continue;
            for (
              let i = Math.max(d.start, p.start),
                n = Math.min(
                  r.count,
                  Math.min(d.start + d.count, p.start + p.count)
                );
              i < n;
              i += 3
            ) {
              const n = r.getX(i),
                h = r.getX(i + 1),
                p = r.getX(i + 2);
              (o = qn(this, f, t, Tn, a, s, l, u, c, n, h, p)),
                o &&
                  ((o.faceIndex = Math.floor(i / 3)),
                  (o.face.materialIndex = d.materialIndex),
                  e.push(o));
            }
          }
        else {
          for (
            let i = Math.max(0, p.start),
              h = Math.min(r.count, p.start + p.count);
            i < h;
            i += 3
          ) {
            const h = r.getX(i),
              p = r.getX(i + 1),
              d = r.getX(i + 2);
            (o = qn(this, n, t, Tn, a, s, l, u, c, h, p, d)),
              o && ((o.faceIndex = Math.floor(i / 3)), e.push(o));
          }
        }
      else if (void 0 !== a)
        if (Array.isArray(n))
          for (let i = 0, d = h.length; i < d; i++) {
            const r = h[i],
              d = n[r.materialIndex];
            for (
              let i = Math.max(r.start, p.start),
                n = Math.min(
                  a.count,
                  Math.min(r.start + r.count, p.start + p.count)
                );
              i < n;
              i += 3
            ) {
              (o = qn(this, d, t, Tn, a, s, l, u, c, i, i + 1, i + 2)),
                o &&
                  ((o.faceIndex = Math.floor(i / 3)),
                  (o.face.materialIndex = r.materialIndex),
                  e.push(o));
            }
          }
        else {
          for (
            let i = Math.max(0, p.start),
              r = Math.min(a.count, p.start + p.count);
            i < r;
            i += 3
          ) {
            (o = qn(this, n, t, Tn, a, s, l, u, c, i, i + 1, i + 2)),
              o && ((o.faceIndex = Math.floor(i / 3)), e.push(o));
          }
        }
    } else
      i.isGeometry &&
        console.error(
          "@dp/gis-engine: Mesh.raycast() no longer supports Geometry. Use BufferGeometry instead."
        );
  }
}
function qn(t, e, i, n, r, o, a, s, l, u, c, h) {
  Ln.fromBufferAttribute(r, u),
    In.fromBufferAttribute(r, c),
    Nn.fromBufferAttribute(r, h);
  const p = t.morphTargetInfluences;
  if (o && p) {
    zn.set(0, 0, 0), kn.set(0, 0, 0), Bn.set(0, 0, 0);
    for (let t = 0, e = o.length; t < e; t++) {
      const e = p[t],
        i = o[t];
      0 !== e &&
        (Rn.fromBufferAttribute(i, u),
        On.fromBufferAttribute(i, c),
        Fn.fromBufferAttribute(i, h),
        a
          ? (zn.addScaledVector(Rn, e),
            kn.addScaledVector(On, e),
            Bn.addScaledVector(Fn, e))
          : (zn.addScaledVector(Rn.sub(Ln), e),
            kn.addScaledVector(On.sub(In), e),
            Bn.addScaledVector(Fn.sub(Nn), e)));
    }
    Ln.add(zn), In.add(kn), Nn.add(Bn);
  }
  t.isSkinnedMesh &&
    (t.boneTransform(u, Ln), t.boneTransform(c, In), t.boneTransform(h, Nn));
  const d = (function (t, e, i, n, r, o, a, s) {
    let l;
    if (
      ((l =
        e.side === bt
          ? n.intersectTriangle(a, o, r, !0, s)
          : n.intersectTriangle(r, o, a, e.side !== xt, s)),
      null === l)
    )
      return null;
    Vn.copy(s), Vn.applyMatrix4(t.matrixWorld);
    const u = i.ray.origin.distanceTo(Vn);
    return u < i.near || u > i.far
      ? null
      : {
          distance: u,
          point: Vn.clone(),
          object: t,
        };
  })(t, e, i, n, Ln, In, Nn, Hn);
  if (d) {
    s &&
      (Gn.fromBufferAttribute(s, u),
      Un.fromBufferAttribute(s, c),
      jn.fromBufferAttribute(s, h),
      (d.uv = tn.getUV(Hn, Ln, In, Nn, Gn, Un, jn, new Le()))),
      l &&
        (Gn.fromBufferAttribute(l, u),
        Un.fromBufferAttribute(l, c),
        jn.fromBufferAttribute(l, h),
        (d.uv2 = tn.getUV(Hn, Ln, In, Nn, Gn, Un, jn, new Le())));
    const t = {
      a: u,
      b: c,
      c: h,
      normal: new Ye(),
      materialIndex: 0,
    };
    tn.getNormal(Ln, In, Nn, t.normal), (d.face = t);
  }
  return d;
}
class Yn extends En {
  constructor(t = 1, e = 1, i = 1, n = 1, r = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: o,
      });
    const a = this;
    (n = Math.floor(n)), (r = Math.floor(r)), (o = Math.floor(o));
    const s = [],
      l = [],
      u = [],
      c = [];
    let h = 0,
      p = 0;
    function d(t, e, i, n, r, o, d, f, g, m, y) {
      const v = o / g,
        b = d / m,
        x = o / 2,
        _ = d / 2,
        S = f / 2,
        M = g + 1,
        C = m + 1;
      let w = 0,
        A = 0;
      const E = new Ye();
      for (let a = 0; a < C; a++) {
        const o = a * b - _;
        for (let s = 0; s < M; s++) {
          const h = s * v - x;
          (E[t] = h * n),
            (E[e] = o * r),
            (E[i] = S),
            l.push(E.x, E.y, E.z),
            (E[t] = 0),
            (E[e] = 0),
            (E[i] = f > 0 ? 1 : -1),
            u.push(E.x, E.y, E.z),
            c.push(s / g),
            c.push(1 - a / m),
            (w += 1);
        }
      }
      for (let a = 0; a < m; a++)
        for (let t = 0; t < g; t++) {
          const e = h + t + M * a,
            i = h + t + M * (a + 1),
            n = h + (t + 1) + M * (a + 1),
            r = h + (t + 1) + M * a;
          s.push(e, i, r), s.push(i, n, r), (A += 6);
        }
      a.addGroup(p, A, y), (p += A), (h += w);
    }
    d("z", "y", "x", -1, -1, i, e, t, o, r, 0),
      d("z", "y", "x", 1, -1, i, e, -t, o, r, 1),
      d("x", "z", "y", 1, 1, t, i, e, n, o, 2),
      d("x", "z", "y", 1, -1, t, i, -e, n, o, 3),
      d("x", "y", "z", 1, -1, t, e, i, n, r, 4),
      d("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
      this.setIndex(s),
      this.setAttribute("position", new bn(l, 3)),
      this.setAttribute("normal", new bn(u, 3)),
      this.setAttribute("uv", new bn(c, 2));
  }
  static fromJSON(t) {
    return new Yn(
      t.width,
      t.height,
      t.depth,
      t.widthSegments,
      t.heightSegments,
      t.depthSegments
    );
  }
}
function Xn(t) {
  const e = {};
  for (const i in t) {
    e[i] = {};
    for (const n in t[i]) {
      const r = t[i][n];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? (e[i][n] = r.clone())
        : Array.isArray(r)
        ? (e[i][n] = r.slice())
        : (e[i][n] = r);
    }
  }
  return e;
}
function Qn(t) {
  const e = {};
  for (let i = 0; i < t.length; i++) {
    const n = Xn(t[i]);
    for (const t in n) e[t] = n[t];
  }
  return e;
}
const Zn = {
  clone: Xn,
  merge: Qn,
};
class Jn extends hn {
  constructor(t) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"),
      (this.fragmentShader =
        "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n"),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== t && this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = Xn(t.uniforms)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    (e.glslVersion = this.glslVersion), (e.uniforms = {});
    for (const n in this.uniforms) {
      const i = this.uniforms[n].value;
      i && i.isTexture
        ? (e.uniforms[n] = {
            type: "t",
            value: i.toJSON(t).uuid,
          })
        : i && i.isColor
        ? (e.uniforms[n] = {
            type: "c",
            value: i.getHex(),
          })
        : i && i.isVector2
        ? (e.uniforms[n] = {
            type: "v2",
            value: i.toArray(),
          })
        : i && i.isVector3
        ? (e.uniforms[n] = {
            type: "v3",
            value: i.toArray(),
          })
        : i && i.isVector4
        ? (e.uniforms[n] = {
            type: "v4",
            value: i.toArray(),
          })
        : i && i.isMatrix3
        ? (e.uniforms[n] = {
            type: "m3",
            value: i.toArray(),
          })
        : i && i.isMatrix4
        ? (e.uniforms[n] = {
            type: "m4",
            value: i.toArray(),
          })
        : (e.uniforms[n] = {
            value: i,
          });
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader);
    const i = {};
    for (const n in this.extensions) !0 === this.extensions[n] && (i[n] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}
class Kn extends Hi {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Mi()),
      (this.projectionMatrix = new Mi()),
      (this.projectionMatrixInverse = new Mi());
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateProjectionMatrix() {}
  clone() {
    return new this.constructor().copy(this);
  }
}
class $n extends Kn {
  constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = i),
      (this.far = n),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    );
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t;
    (this.fov = 2 * Ce * Math.atan(e)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(0.5 * Me * this.fov);
    return (0.5 * this.getFilmHeight()) / t;
  }
  getEffectiveFOV() {
    return 2 * Ce * Math.atan(Math.tan(0.5 * Me * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(t, e, i, n, r, o) {
    (this.aspect = t / e),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  update(t, e) {
    const i = t / e;
    (this.aspect = i), this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = (t * Math.tan(0.5 * Me * this.fov)) / this.zoom,
      i = 2 * e,
      n = this.aspect * i,
      r = -0.5 * n;
    const o = this.view;
    if (null !== this.view && this.view.enabled) {
      const t = o.fullWidth,
        a = o.fullHeight;
      (r += (o.offsetX * n) / t),
        (e -= (o.offsetY * i) / a),
        (n *= o.width / t),
        (i *= o.height / a);
    }
    const a = this.filmOffset;
    0 !== a && (r += (t * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    );
  }
}
const tr = 90;
class er extends Hi {
  constructor(t, e, i) {
    if ((super(), (this.type = "CubeCamera"), !0 !== i.isWebGLCubeRenderTarget))
      return void console.error(
        "@dp/gis-engine: CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
      );
    this.renderTarget = i;
    const n = new $n(tr, 1, t, e);
    (n.layers = this.layers),
      n.up.set(0, -1, 0),
      n.lookAt(new Ye(1, 0, 0)),
      this.add(n);
    const r = new $n(tr, 1, t, e);
    (r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new Ye(-1, 0, 0)),
      this.add(r);
    const o = new $n(tr, 1, t, e);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(new Ye(0, 1, 0)),
      this.add(o);
    const a = new $n(tr, 1, t, e);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(new Ye(0, -1, 0)),
      this.add(a);
    const s = new $n(tr, 1, t, e);
    (s.layers = this.layers),
      s.up.set(0, -1, 0),
      s.lookAt(new Ye(0, 0, 1)),
      this.add(s);
    const l = new $n(tr, 1, t, e);
    (l.layers = this.layers),
      l.up.set(0, -1, 0),
      l.lookAt(new Ye(0, 0, -1)),
      this.add(l);
  }
  update(t, e) {
    null === this.parent && this.updateMatrixWorld();
    const i = this.renderTarget,
      [n, r, o, a, s, l] = this.children,
      u = t.getRenderTarget(),
      c = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      t.setRenderTarget(i, 0),
      t.render(e, n),
      t.setRenderTarget(i, 1),
      t.render(e, r),
      t.setRenderTarget(i, 2),
      t.render(e, o),
      t.setRenderTarget(i, 3),
      t.render(e, a),
      t.setRenderTarget(i, 4),
      t.render(e, s),
      (i.texture.generateMipmaps = c),
      t.setRenderTarget(i, 5),
      t.render(e, l),
      t.setRenderTarget(u);
  }
}
class ir extends Ge {
  constructor(t, e, i, n, r, o, a, s, l, u) {
    super(
      (t = void 0 !== t ? t : []),
      (e = void 0 !== e ? e : Ot),
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u
    ),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class nr extends He {
  constructor(t, e, i) {
    Number.isInteger(e) && (e = i),
      super(t, t, e),
      (this.isWebGLCubeRenderTarget = !0),
      (e = e || {}),
      (this.texture = new ir(
        void 0,
        e.mapping,
        e.wrapS,
        e.wrapT,
        e.magFilter,
        e.minFilter,
        e.format,
        e.type,
        e.anisotropy,
        e.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        void 0 !== e.generateMipmaps && e.generateMipmaps),
      (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Vt),
      (this.texture._needsFlipEnvMap = !1);
  }
  fromEquirectangularTexture(t, e) {
    (this.texture.type = e.type),
      (this.texture.format = te),
      (this.texture.encoding = e.encoding),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter);
    const i = {
        uniforms: {
          tEquirect: {
            value: null,
          },
        },
        vertexShader:
          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader:
          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
      },
      n = new Yn(5, 5, 5),
      r = new Jn({
        name: "CubemapFromEquirect",
        uniforms: Xn(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: bt,
        blending: 0,
      });
    r.uniforms.tEquirect.value = e;
    const o = new Wn(n, r),
      a = e.minFilter;
    e.minFilter === qt && (e.minFilter = Vt);
    return (
      new er(1, 10, this).update(t, o),
      (e.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(t, e, i, n) {
    const r = t.getRenderTarget();
    for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, i, n);
    t.setRenderTarget(r);
  }
}
class rr {
  constructor() {
    this.__target = [];
  }
  get(t, e) {
    const i = new He(t || 1, e || 1);
    return this.__target.push(i), i;
  }
  remove(t) {
    t.dispose(), this.__target.splice(this.__target.indexOf(t), 1);
  }
  updateSize(t, e) {
    this.__target.forEach((i) => {
      i.setSize(t, e);
    });
  }
  destroy() {
    this.__target.forEach((t) => t.dispose()), (this.__target = []);
  }
}
const or = new Ye(),
  ar = new Ye(),
  sr = new Ie();
class lr {
  constructor(t = new Ye(1, 0, 0), e = 0) {
    (this.isPlane = !0), (this.normal = t), (this.constant = e);
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  }
  setComponents(t, e, i, n) {
    return this.normal.set(t, e, i), (this.constant = n), this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  }
  setFromCoplanarPoints(t, e, i) {
    const n = or.subVectors(i, e).cross(ar.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
  }
  intersectLine(t, e) {
    const i = t.delta(or),
      n = this.normal.dot(i);
    if (0 === n)
      return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
    const r = -(t.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      i = this.distanceToPoint(t.end);
    return (e < 0 && i > 0) || (i < 0 && e > 0);
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const i = e || sr.getNormalMatrix(t),
      n = this.coplanarPoint(or).applyMatrix4(t),
      r = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -n.dot(r)), this;
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new lr().copy(this);
  }
}
const ur = new fi(),
  cr = new Ye();
class hr {
  constructor(
    t = new lr(),
    e = new lr(),
    i = new lr(),
    n = new lr(),
    r = new lr(),
    o = new lr()
  ) {
    this.planes = [t, e, i, n, r, o];
  }
  set(t, e, i, n, r, o) {
    const a = this.planes;
    return (
      a[0].copy(t),
      a[1].copy(e),
      a[2].copy(i),
      a[3].copy(n),
      a[4].copy(r),
      a[5].copy(o),
      this
    );
  }
  copy(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
    return this;
  }
  setFromProjectionMatrix(t) {
    const e = this.planes,
      i = t.elements,
      n = i[0],
      r = i[1],
      o = i[2],
      a = i[3],
      s = i[4],
      l = i[5],
      u = i[6],
      c = i[7],
      h = i[8],
      p = i[9],
      d = i[10],
      f = i[11],
      g = i[12],
      m = i[13],
      y = i[14],
      v = i[15];
    return (
      e[0].setComponents(a - n, c - s, f - h, v - g).normalize(),
      e[1].setComponents(a + n, c + s, f + h, v + g).normalize(),
      e[2].setComponents(a + r, c + l, f + p, v + m).normalize(),
      e[3].setComponents(a - r, c - l, f - p, v - m).normalize(),
      e[4].setComponents(a - o, c - u, f - d, v - y).normalize(),
      e[5].setComponents(a + o, c + u, f + d, v + y).normalize(),
      this
    );
  }
  intersectsObject(t) {
    const e = t.geometry;
    return (
      null === e.boundingSphere && e.computeBoundingSphere(),
      ur.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ur)
    );
  }
  intersectsSprite(t) {
    return (
      ur.center.set(0, 0, 0),
      (ur.radius = 0.7071067811865476),
      ur.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ur)
    );
  }
  intersectsSphere(t) {
    const e = this.planes,
      i = t.center,
      n = -t.radius;
    for (let r = 0; r < 6; r++) {
      if (e[r].distanceToPoint(i) < n) return !1;
    }
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = e[i];
      if (
        ((cr.x = n.normal.x > 0 ? t.max.x : t.min.x),
        (cr.y = n.normal.y > 0 ? t.max.y : t.min.y),
        (cr.z = n.normal.z > 0 ? t.max.z : t.min.z),
        n.distanceToPoint(cr) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
    return !0;
  }
  clone() {
    return new hr().copy(this);
  }
}
class pr {
  constructor(t, e) {
    (this.gl = t),
      (this.capabilities = e),
      (this.isWebGL2 = e.isWebGL2),
      (this.buffers = new WeakMap());
  }
  createBuffer(t, e) {
    const i = t.array,
      n = t.usage,
      r = this.gl.createBuffer();
    this.gl.bindBuffer(e, r), this.gl.bufferData(e, i, n), t.onUploadCallback();
    let o = this.gl.FLOAT;
    return (
      i instanceof Float32Array
        ? (o = this.gl.FLOAT)
        : i instanceof Float64Array ||
          (i instanceof Uint16Array
            ? t.isFloat16BufferAttribute
              ? this.isWebGL2 && (o = this.gl.HALF_FLOAT)
              : (o = this.gl.UNSIGNED_SHORT)
            : i instanceof Int16Array
            ? (o = this.gl.SHORT)
            : i instanceof Uint32Array
            ? (o = this.gl.UNSIGNED_INT)
            : i instanceof Int32Array
            ? (o = this.gl.INT)
            : i instanceof Int8Array
            ? (o = this.gl.BYTE)
            : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) &&
              (o = this.gl.UNSIGNED_BYTE)),
      {
        buffer: r,
        type: o,
        bytesPerElement: i.BYTES_PER_ELEMENT,
        version: t.version,
      }
    );
  }
  updateBuffer(t, e, i) {
    const n = e.array,
      r = e.updateRange;
    this.gl.bindBuffer(i, t),
      -1 === r.count
        ? this.gl.bufferSubData(i, 0, n)
        : (this.isWebGL2
            ? this.gl.bufferSubData(
                i,
                r.offset * n.BYTES_PER_ELEMENT,
                n,
                r.offset,
                r.count
              )
            : this.gl.bufferSubData(
                i,
                r.offset * n.BYTES_PER_ELEMENT,
                n.subarray(r.offset, r.offset + r.count)
              ),
          (r.count = -1));
  }
  get(t) {
    return t.isInterleavedBufferAttribute && (t = t.data), this.buffers.get(t);
  }
  remove(t) {
    t.isInterleavedBufferAttribute && (t = t.data);
    const e = this.buffers.get(t);
    e && (this.gl.deleteBuffer(e.buffer), this.buffers.delete(t));
  }
  update(t, e) {
    if (t.isGLBufferAttribute) {
      const e = this.buffers.get(t);
      return void (
        (!e || e.version < t.version) &&
        this.buffers.set(t, {
          buffer: t.buffer,
          type: t.type,
          bytesPerElement: t.elementSize,
          version: t.version,
        })
      );
    }
    t.isInterleavedBufferAttribute && (t = t.data);
    const i = this.buffers.get(t);
    void 0 === i
      ? this.buffers.set(t, this.createBuffer(t, e))
      : i.version < t.version &&
        (this.updateBuffer(i.buffer, t, e), (i.version = t.version));
  }
}
class dr extends En {
  constructor(t = 1, e = 1, i = 1, n = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: i,
        heightSegments: n,
      });
    const r = t / 2,
      o = e / 2,
      a = Math.floor(i),
      s = Math.floor(n),
      l = a + 1,
      u = s + 1,
      c = t / a,
      h = e / s,
      p = [],
      d = [],
      f = [],
      g = [];
    for (let m = 0; m < u; m++) {
      const t = m * h - o;
      for (let e = 0; e < l; e++) {
        const i = e * c - r;
        d.push(i, -t, 0), f.push(0, 0, 1), g.push(e / a), g.push(1 - m / s);
      }
    }
    for (let m = 0; m < s; m++)
      for (let t = 0; t < a; t++) {
        const e = t + l * m,
          i = t + l * (m + 1),
          n = t + 1 + l * (m + 1),
          r = t + 1 + l * m;
        p.push(e, i, r), p.push(i, n, r);
      }
    this.setIndex(p),
      this.setAttribute("position", new bn(d, 3)),
      this.setAttribute("normal", new bn(f, 3)),
      this.setAttribute("uv", new bn(g, 2));
  }
  static fromJSON(t) {
    return new dr(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
const fr = {
    common: {
      diffuse: {
        value: new ln(16777215),
      },
      opacity: {
        value: 1,
      },
      map: {
        value: null,
      },
      uvTransform: {
        value: new Ie(),
      },
      uv2Transform: {
        value: new Ie(),
      },
      alphaMap: {
        value: null,
      },
      alphaTest: {
        value: 0,
      },
    },
    specularmap: {
      specularMap: {
        value: null,
      },
    },
    envmap: {
      envMap: {
        value: null,
      },
      flipEnvMap: {
        value: -1,
      },
      reflectivity: {
        value: 1,
      },
      ior: {
        value: 1.5,
      },
      refractionRatio: {
        value: 0.98,
      },
    },
    aomap: {
      aoMap: {
        value: null,
      },
      aoMapIntensity: {
        value: 1,
      },
    },
    lightmap: {
      lightMap: {
        value: null,
      },
      lightMapIntensity: {
        value: 1,
      },
    },
    emissivemap: {
      emissiveMap: {
        value: null,
      },
    },
    bumpmap: {
      bumpMap: {
        value: null,
      },
      bumpScale: {
        value: 1,
      },
    },
    normalmap: {
      normalMap: {
        value: null,
      },
      normalScale: {
        value: new Le(1, 1),
      },
    },
    displacementmap: {
      displacementMap: {
        value: null,
      },
      displacementScale: {
        value: 1,
      },
      displacementBias: {
        value: 0,
      },
    },
    roughnessmap: {
      roughnessMap: {
        value: null,
      },
    },
    metalnessmap: {
      metalnessMap: {
        value: null,
      },
    },
    gradientmap: {
      gradientMap: {
        value: null,
      },
    },
    fog: {
      fogDensity: {
        value: 25e-5,
      },
      fogNear: {
        value: 1,
      },
      fogFar: {
        value: 2e3,
      },
      fogColor: {
        value: new ln(16777215),
      },
    },
    lights: {
      ambientLightColor: {
        value: [],
      },
      lightProbe: {
        value: [],
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
        },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: {
        value: [],
      },
      directionalShadowMatrix: {
        value: [],
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: {
        value: [],
      },
      spotShadowMatrix: {
        value: [],
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
        },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: {
        value: [],
      },
      pointShadowMatrix: {
        value: [],
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {},
        },
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {},
        },
      },
      ltc_1: {
        value: null,
      },
      ltc_2: {
        value: null,
      },
    },
    points: {
      diffuse: {
        value: new ln(16777215),
      },
      opacity: {
        value: 1,
      },
      size: {
        value: 1,
      },
      scale: {
        value: 1,
      },
      map: {
        value: null,
      },
      alphaMap: {
        value: null,
      },
      alphaTest: {
        value: 0,
      },
      uvTransform: {
        value: new Ie(),
      },
    },
    sprite: {
      diffuse: {
        value: new ln(16777215),
      },
      opacity: {
        value: 1,
      },
      center: {
        value: new Le(0.5, 0.5),
      },
      rotation: {
        value: 0,
      },
      map: {
        value: null,
      },
      alphaMap: {
        value: null,
      },
      alphaTest: {
        value: 0,
      },
      uvTransform: {
        value: new Ie(),
      },
    },
  },
  gr = {
    alphamap_fragment:
      "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n",
    alphamap_pars_fragment:
      "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
    alphatest_fragment:
      "\n#ifdef USE_ALPHATEST\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n#endif\n",
    alphatest_pars_fragment:
      "\n#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif\n",
    aomap_fragment:
      "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n\n#endif\n",
    aomap_pars_fragment:
      "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n",
    begin_vertex: "\nvec3 transformed = vec3( position );\n",
    beginnormal_vertex:
      "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz ); // 将顶点输入的法线临时存储一个变量\n\n#endif\n",
    bsdfs:
      '\n\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( V * D );\n\n}\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat D_Charlie( float roughness, float dotNH ) {\n\n\tfloat alpha = pow2( roughness );\n\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n\n}\n\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\n\treturn sheenColor * ( D * V );\n\n}\n\n#endif\n',
    bumpmap_pars_fragment:
      "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n",
    clipping_planes_fragment:
      "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n",
    clipping_planes_pars_fragment:
      "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n",
    clipping_planes_pars_vertex:
      "\n// 如果裁剪平面数量大于0\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n",
    clipping_planes_vertex:
      "\n// 如果裁剪平面数量大于0\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz; // 摄像机空间的位置\n\n#endif\n",
    color_fragment:
      "\n#if defined( USE_COLOR_ALPHA )\n\n\tdiffuseColor *= vColor;\n\n#elif defined( USE_COLOR )\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n",
    color_pars_fragment:
      "\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n",
    color_pars_vertex:
      "\n// 如果定义了USE_COLOR宏才加入下面代码\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor; // 定义将颜色输出到fragmentshader的变量\n\n#endif\n",
    color_vertex:
      "\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n// 如果定义了使用颜色变量才加入这些代码\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;  // 将输入的顶点颜色不经过任何处理直接输出到fragmentshader\n\n#endif\n",
    common:
      "\n#define PI 3.141592653589793  //π(180)\n#define PI2 6.283185307179586 //2π(360)\n#define PI_HALF 1.5707963267948966 //0.5π(90度)\n#define RECIPROCAL_PI 0.3183098861837907 // 1/π\n#define RECIPROCAL_PI2 0.15915494309189535  // 1/2π\n#define EPSILON 1e-6   // 1x10的-6次方 相当于接近0的小数\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )   // 收拢到0~1.0之间\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )  // 收拢后再用1.0减\n\nfloat pow2( const in float x ) { return x*x; }   // 平方\nfloat pow3( const in float x ) { return x*x*x; }  // 三次方\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; } // 四次方\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }  // 三向量x,y,z三个数平均数\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {    // 随机数\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\n// 入射光\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\n// 反射光\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\n// 几何体信息\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\n// 变换方向\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// 逆向变换方向(一般知道worldmatrix 和 local下的normal求worldnormal可以用次方法)\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\n// 矩阵求转置\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// 线性rgb颜色值求相对亮度\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n",
    cube_uv_reflection_fragment:
      "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\n\t\tvec2 f = fract( uv );\n\n\t\tuv += 0.5 - f;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\n\t\t}\n\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n\t\tuv *= texelSize;\n\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.x += texelSize;\n\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.y += texelSize;\n\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tuv.x -= texelSize;\n\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n\t\tvec3 tm = mix( tl, tr, f.x );\n\n\t\tvec3 bm = mix( bl, br, f.x );\n\n\t\treturn mix( tm, bm, f.y );\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= r1 ) {\n\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n\t\t} else if ( roughness >= r4 ) {\n\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n\t\t} else if ( roughness >= r5 ) {\n\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n\t\t} else if ( roughness >= r6 ) {\n\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n",
    defaultnormal_vertex:
      "\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n// 将local坐标下的法线转换到摄像机坐标系下\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED // 如果定义了FLIP_SIDED 翻转法线\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n",
    displacementmap_pars_vertex:
      "\n#ifdef USE_DISPLACEMENTMAP\n\n  uniform sampler2D displacementMap; // 置换贴图采样器\n  uniform float displacementScale; // 缩放参数\n  uniform float displacementBias; // bias因子\n\n#endif\n",
    displacementmap_vertex:
      "\n// 如果定义了USE_DISPLACEMENTMAP加入下面代码\n#ifdef USE_DISPLACEMENTMAP\n// 下面的算法主要目的是将顶点按照法线方向偏移一定距离，这个距离的控制通过采样置换贴图的值(dx),distance = dx*dscale+dbias;\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n",
    emissivemap_fragment:
      "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n",
    emissivemap_pars_fragment:
      "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n",
    encodings_fragment:
      "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n",
    encodings_pars_fragment:
      "\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n\t// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests\n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255.0, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
    envmap_fragment:
      "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n",
    envmap_common_pars_fragment:
      "\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\n#endif\n",
    envmap_pars_fragment:
      "\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n",
    envmap_pars_vertex:
      "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n",
    envmap_physical_pars_fragment:
      "\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 reflectVec;\n\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t\t#else\n\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\n\t\t\t#endif\n\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t\t#else\n\n\t\t\treturn vec3( 0.0 );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
    envmap_vertex:
      "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
    fog_vertex:
      "\n// 如果定义的USE_FOG加入代码\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z; // 将摄像机空间的顶点z坐标赋值给fogDepth\n\n#endif\n",
    fog_pars_vertex:
      "\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n",
    fog_fragment:
      "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n",
    fog_pars_fragment:
      "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n",
    gradientmap_pars_fragment:
      "\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n",
    lightmap_fragment:
      "\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tlightMapIrradiance *= PI;\n\n\t#endif\n\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n#endif\n",
    lightmap_pars_fragment:
      "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n",
    lights_lambert_vertex:
      "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n",
    lights_pars_begin:
      "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n  // 点光源信息\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\n\t\tlight.direction = normalize( lVector );\n\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation > 0.0 ) {\n\n\t\t\tfloat lightDistance = length( lVector );\n\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
    lights_toon_fragment:
      "\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\n",
    lights_toon_pars_fragment:
      "\nvarying vec3 vViewPosition;\n\nstruct ToonMaterial {\n\n\tvec3 diffuseColor;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n",
    lights_phong_fragment:
      "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
    lights_phong_pars_fragment:
      "\nvarying vec3 vViewPosition;\n\nstruct BlinnPhongMaterial {\n\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n",
    lights_physical_fragment:
      "\n// 存放物理材质信息\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor ); // 金属性越强漫反射颜色越小\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n\n#ifdef IOR\n\n\t#ifdef SPECULAR\n\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\n\t\t#endif\n\n\t\t#ifdef USE_SPECULARCOLORMAP\n\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\n\t\t#endif\n\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\n\t#else\n\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\n\t#endif\n\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheenColor;\n\n\t#ifdef USE_SHEENCOLORMAP\n\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\n\t#endif\n\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\n\t#endif\n\n#endif\n",
    lights_physical_pars_fragment:
      '\n// 物理材质信息\nstruct PhysicalMaterial {\n\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\n};\n\n// temporary\nvec3 clearcoatSpecular = vec3( 0.0 );\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\n\treturn fab;\n\n}\n\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\treturn specularColor * fab.x + specularF90 * fab.y;\n\n}\n\n// Fdez-Agüera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\n\t#endif\n\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\n\t#endif\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n',
    lights_fragment_begin:
      "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\n// 存放几何数据\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
    lights_fragment_maps:
      "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI;\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\n\t#endif\n\n#endif\n",
    lights_fragment_end:
      "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n",
    logdepthbuf_fragment:
      "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n",
    logdepthbuf_pars_fragment:
      "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n",
    logdepthbuf_pars_vertex:
      "\n// 如果定义了USE_LOGDEPTHBUF加入下面代码\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT // 如果定义了USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth; // 输出到fragmentshader的深度\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n",
    logdepthbuf_vertex:
      "\n// 如果定义了USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT // 如果定义了USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
    map_fragment:
      "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n",
    map_pars_fragment:
      "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n",
    map_particle_fragment:
      "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n",
    map_particle_pars_fragment:
      "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
    metalnessmap_fragment:
      "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n",
    metalnessmap_pars_fragment:
      "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n",
    morphnormal_vertex:
      "\n// 如果定义了USE_MORPHNORMALS加入代码\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n    // 下面线性插值将法线进行调节 c = (b - a) * scale +a;\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n\t#endif\n\n#endif\n",
    morphtarget_pars_vertex:
      "\n// 如果定义了USE_MORPHTARGETS加入下面代码\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\n\t\t}\n\n\t#else\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\tuniform float morphTargetInfluences[ 8 ]; // 变形动画调节因子\n\n\t\t#else\n\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
    morphtarget_vertex:
      "\n// 如果定义了USE_MORPHTARGETS\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\n\t\t\t#endif\n\n\t\t}\n\n\t#else\n\n    // 对位置进行线性插值后加权 c = (b - a)*scale+a;\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t\t#ifndef USE_MORPHNORMALS // 如果没有定义USE_MORPHNORMALS才执行如下操作\n\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
    normal_fragment_begin:
      "\nfloat faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n",
    normal_fragment_maps:
      "\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n\n#endif\n",
    normal_pars_fragment:
      "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
    normal_pars_vertex:
      "\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n",
    normal_vertex:
      "\n#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n",
    normalmap_pars_fragment:
      "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Normal Mapping Without Precomputed Tangents\n\t// http://www.thetenthplanet.de/archives/1180\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 N = surf_norm; // normalized\n\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n\t}\n\n#endif\n",
    clearcoat_normal_fragment_begin:
      "\n#ifdef USE_CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n",
    clearcoat_normal_fragment_maps:
      "\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\n\t#endif\n\n#endif\n",
    clearcoat_pars_fragment:
      "\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n",
    output_fragment:
      "\n#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n\n// https://github.com/mrdoob/three.js/pull/22425\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\n\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",
    packing:
      "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\n\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
    premultiplied_alpha_fragment:
      "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n",
    project_vertex:
      "\nvec4 mvPosition = vec4( transformed, 1.0 ); // 将local坐标转换到摄像机空间\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition; // 再将摄像机空间坐标乘以投影矩阵做投影变换转到裁剪空间\n",
    dithering_fragment:
      "\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n",
    dithering_pars_fragment:
      "\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n",
    roughnessmap_fragment:
      "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n",
    roughnessmap_pars_fragment:
      "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n",
    shadowmap_pars_fragment:
      "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
    shadowmap_pars_vertex:
      "\n// 如果定义了USE_SHADOWMAP加入下面代码\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ]; // 方向光的投影矩阵\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ]; // 输出到fragmentshader的坐标\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];// 聚光灯的阴影矩阵\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];// 输出到fragmentshader的坐标\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];// 点光源的阴影矩阵\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ]; // 点光源的阴影坐标\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n",
    shadowmap_vertex:
      "\n// 如果定义了USE_SHADOWMAP加入代码 通过个光源的阴影投影矩阵对顶点坐标进行投影\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\t// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\n\t#endif\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n",
    shadowmask_pars_fragment:
      "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n",
    skinbase_vertex:
      "\n// 如果定义了USE_SKINNING 获取四个骨骼矩阵\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n",
    skinning_pars_vertex:
      "\n// 如果定义了USE_SKINNING加入代码\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix; // 绑定矩阵\n\tuniform mat4 bindMatrixInverse; // 绑定矩阵逆矩阵\n\n\t#ifdef BONE_TEXTURE // 如果使用了骨骼纹理(定义了BONE_TEXTURE)\n\n\t\tuniform highp sampler2D boneTexture; // 骨骼纹理 这里使用的float纹理\n\t\tuniform int boneTextureSize; // 骨骼纹理大小\n\n\t\tmat4 getBoneMatrix( const in float i ) { // 获取骨骼纹理\n\n\t\t\tfloat j = i * 4.0; // 每个像素是xyzw一个向量 四个就能组合一个像素,这里i表示骨骼id(0~xxx)\n\t\t\tfloat x = mod( j, float( boneTextureSize ) ); // 计算骨骼数据所在的x坐标\n\t\t\tfloat y = floor( j / float( boneTextureSize ) ); // 计算骨骼数据所在的y坐标\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize ); // 每个像素占宽度所在的百分比\n\t\t\tfloat dy = 1.0 / float( boneTextureSize ); // 每个像素占宽度所在的百分比\n\n\t\t\ty = dy * ( y + 0.5 );\n\n      // 采样骨骼矩阵\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n    // 直接通过统一变量存储骨骼矩阵获取数据，这种方式可能受限uniform存储的容量限制导致支持骨骼数量不会太多\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
    skinning_vertex:
      "\n// 如果定义USE_SKINNING加入代码\n#ifdef USE_SKINNING\n\n  // 使用四个骨骼矩阵对顶点坐标进行加权\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n",
    skinnormal_vertex:
      "\n// 如果定义了USE_SKINNING使用下面代码计算骨骼对法线的影响\n#ifdef USE_SKINNING\n\n  // 对四个骨骼矩阵进行加权\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n  // 应用法线和蒙皮矩阵\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n",
    specularmap_fragment:
      "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n",
    specularmap_pars_fragment:
      "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n",
    tonemapping_fragment:
      "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n",
    tonemapping_pars_fragment:
      "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n\n}\n\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\n\tcolor *= toneMappingExposure / 0.6;\n\n\tcolor = ACESInputMat * color;\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat * color;\n\n\t// Clamp to [0, 1]\n\treturn saturate( color );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return color; }\n",
    transmission_fragment:
      "\n#ifdef USE_TRANSMISSION\n\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif\n",
    transmission_pars_fragment:
      "\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\n\t\tif ( attenuationDistance == 0.0 ) {\n\n\t\t\t// Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n",
    uv_pars_fragment:
      "\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n",
    uv_pars_vertex:
      "\n#ifdef USE_UV // 判断是否使用 uv\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv; // 输出到fragmentshader变量定义\n\n\t#endif\n\n\tuniform mat3 uvTransform;   // uv变换矩阵3x3\n\n#endif\n",
    uv_vertex:
      "\n#ifdef USE_UV // 判断是否使用 uv\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;  // uv运用变换矩阵后输出到fragmentshader\n\n#endif\n",
    uv2_pars_fragment:
      "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n",
    uv2_pars_vertex:
      "\n// 如果定义了USE_LIGHTMAP和USE_AOMAP才加入下面代码,也就是光照贴图和AO贴图都需要用到第二套uv\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n",
    uv2_vertex:
      "\n// 如果定义USE_LIGHTMAP或者USE_AOMAP加入下面代码\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n",
    worldpos_vertex:
      "\n// 如果定义USE_ENVMAP DISTANCE USE_SHADOWMAP USE_TRANSMISSION 就需要计算顶点相对世界坐标系下的位置\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n",
    background_vert:
      "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n",
    background_frag:
      "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
    cube_vert:
      "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n",
    cube_frag:
      "\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
    depth_vert:
      "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
    depth_frag:
      "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
    distanceRGBA_vert:
      "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
    distanceRGBA_frag:
      "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
    equirect_vert:
      "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n",
    equirect_frag:
      "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV = equirectUv( direction );\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
    linedashed_vert:
      "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
    linedashed_frag:
      "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
    meshbasic_vert:
      "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
    meshbasic_frag:
      "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
    meshlambert_vert:
      "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
    meshlambert_frag:
      "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
    meshmatcap_vert:
      "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n",
    meshmatcap_frag:
      "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
    meshnormal_vert:
      "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n",
    meshnormal_frag:
      "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n",
    meshphong_vert:
      "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
    meshphong_frag:
      "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
    meshphysical_vert:
      "\n#define STANDARD  // 定义物理材质的宏\n\nvarying vec3 vViewPosition; // 相机空间每个顶点的位置\n\n#ifdef USE_TRANSMISSION // 是否使用透射\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#include <common> // 包含着色器公共模块(包含常用的数学工具函数以及一些常量定义什么的)\n#include <uv_pars_vertex> // 包含处理uv所需要的一些定义\n#include <uv2_pars_vertex> // 包含处理uv2所需要的一些定义\n#include <displacementmap_pars_vertex> // 包含置换贴图displacementmap所需要的定义\n#include <color_pars_vertex> // 包含顶点颜色所需要的定义\n#include <fog_pars_vertex> // 包含雾化效果所需要的定义\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex> // 包含变形动画所需要的定义\n#include <skinning_pars_vertex> // 包含蒙皮动画所需要的定义\n#include <shadowmap_pars_vertex> // 包含阴影计算所需要的定义\n#include <logdepthbuf_pars_vertex> // 包含深度处理的一些定义\n#include <clipping_planes_pars_vertex> // 包含裁剪平面所需要的一些定义\n\nvoid main() {\n\n\t#include <uv_vertex> //  uv 数据处理\n\t#include <uv2_vertex> // uv2 数据处理\n\t#include <color_vertex> // 颜色 数据处理\n\n\t#include <beginnormal_vertex> // 开始法线处理\n\t#include <morphnormal_vertex> // 变形动画法线处理\n\t#include <skinbase_vertex> // 骨骼蒙皮基本运算\n\t#include <skinnormal_vertex> // 骨骼蒙皮法线运算\n\t#include <defaultnormal_vertex> // 默认法线处理\n\t#include <normal_vertex>\n\n\t#include <begin_vertex> // 开始顶点位置处理\n\t#include <morphtarget_vertex>  // 变形动画位置处理\n\t#include <skinning_vertex>  // 蒙皮顶点处理\n\t#include <displacementmap_vertex> // 置换贴图运用顶点处理\n\t#include <project_vertex>   // 投影顶点运算\n\t#include <logdepthbuf_vertex>  // logDepth深度运算\n\t#include <clipping_planes_vertex>  // 裁剪平面运算\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n}\n",
    meshphysical_frag:
      "\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\nuniform vec3 diffuse; // 漫反射颜色\nuniform vec3 emissive; // 自发光颜色\nuniform float roughness; // 粗糙度\nuniform float metalness; // 金属性\nuniform float opacity; // 透明度\n\n#ifdef IOR\n\tuniform float ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n\nvarying vec3 vViewPosition;  // 摄像机空间的坐标\n\n#include <common> //  包含着色器公共模块(包含常用的数学工具函数以及一些常量定义什么的)\n#include <packing>  // 数据编码解码功能函数\n#include <dithering_pars_fragment> // 抖动处理的定义\n#include <color_pars_fragment> // 颜色处理的定义\n#include <uv_pars_fragment> // uv相关处理的定义\n#include <uv2_pars_fragment>  // uv2相关处理的定义\n#include <map_pars_fragment>  // map贴图相关处理的定义\n#include <alphamap_pars_fragment>  // alphamap贴图的处理定义\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment> // aomap贴图的处理定义\n#include <lightmap_pars_fragment> // lighmap贴图处理定义\n#include <emissivemap_pars_fragment> // emissivemap贴图处理的定义\n#include <bsdfs>   // brdf相关的功能函数\n#include <cube_uv_reflection_fragment>  // cubemap反射相关\n#include <envmap_common_pars_fragment>  // envmap贴图处理的定义\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>  // 雾化需要的定义\n#include <lights_pars_begin> // 灯光相关定义\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>  // 灯光相关物理运算\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment> // roughnessmap相关运算的定义\n#include <metalnessmap_pars_fragment> // metalnessmap相关运算的定义\n#include <logdepthbuf_pars_fragment> // logdepth相关运算的定义\n#include <clipping_planes_pars_fragment> // clipplane裁剪平面相关的定义\n\nvoid main() {\n\n\t#include <clipping_planes_fragment> // 裁剪平面裁剪\n\n\tvec4 diffuseColor = vec4( diffuse, opacity ); // 合成rgba四通道漫反射颜色\n  // 初始化光照反射\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment> // logdepth运算\n\t#include <map_fragment> // map通道颜色采样\n\t#include <color_fragment> // color参与计算\n\t#include <alphamap_fragment> // alphamap通道颜色采样\n\t#include <alphatest_fragment> // alpha测试\n\t#include <roughnessmap_fragment> // 粗糙贴图采样\n\t#include <metalnessmap_fragment> // 金属性贴图采样\n\t#include <normal_fragment_begin> // 法线贴图基本运算\n\t#include <normal_fragment_maps>  // 法线通过法线贴图运算\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n  #include <lights_physical_fragment> // 物理光照基础运算\n  #include <lights_fragment_begin> // 计算各种灯光入射光和反射光信息\n  #include <lights_fragment_maps> // 从环境光和光照贴图获取辐射\n  #include <lights_fragment_end>  // 根据辐射光取得反射信息\n\n\n\t// modulation\n\t#include <aomap_fragment> // 根据AO贴图调整反射光照强度\n\n  // 反射光直接漫反射+间接漫反射+直接高光+间接高光+自发光 = 输出光照颜色\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t#include <transmission_fragment>\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n\t#endif\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>// tonemap进行曝光\n  #include <encodings_fragment> // 颜色编码\n  #include <fog_fragment>             // 雾化颜色运算\n  #include <premultiplied_alpha_fragment> // 颜色预乘alpha\n  #include <dithering_fragment>   // 颜色随机抖动\n\n}\n",
    meshtoon_vert:
      "\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
    meshtoon_frag:
      "\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
    points_vert:
      "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n",
    points_frag:
      "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
    shadow_vert:
      "\n#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
    shadow_frag:
      "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
    sprite_vert:
      "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
    sprite_frag:
      "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
  },
  mr = {
    basic: {
      uniforms: Qn([
        fr.common,
        fr.specularmap,
        fr.envmap,
        fr.aomap,
        fr.lightmap,
        fr.fog,
      ]),
      vertexShader: gr.meshbasic_vert,
      fragmentShader: gr.meshbasic_frag,
    },
    lambert: {
      uniforms: Qn([
        fr.common,
        fr.specularmap,
        fr.envmap,
        fr.aomap,
        fr.lightmap,
        fr.emissivemap,
        fr.fog,
        fr.lights,
        {
          emissive: {
            value: new ln(0),
          },
        },
      ]),
      vertexShader: gr.meshlambert_vert,
      fragmentShader: gr.meshlambert_frag,
    },
    phong: {
      uniforms: Qn([
        fr.common,
        fr.specularmap,
        fr.envmap,
        fr.aomap,
        fr.lightmap,
        fr.emissivemap,
        fr.bumpmap,
        fr.normalmap,
        fr.displacementmap,
        fr.fog,
        fr.lights,
        {
          emissive: {
            value: new ln(0),
          },
          specular: {
            value: new ln(1118481),
          },
          shininess: {
            value: 30,
          },
        },
      ]),
      vertexShader: gr.meshphong_vert,
      fragmentShader: gr.meshphong_frag,
    },
    standard: {
      uniforms: Qn([
        fr.common,
        fr.envmap,
        fr.aomap,
        fr.lightmap,
        fr.emissivemap,
        fr.bumpmap,
        fr.normalmap,
        fr.displacementmap,
        fr.roughnessmap,
        fr.metalnessmap,
        fr.fog,
        fr.lights,
        {
          emissive: {
            value: new ln(0),
          },
          roughness: {
            value: 1,
          },
          metalness: {
            value: 0,
          },
          envMapIntensity: {
            value: 1,
          },
        },
      ]),
      vertexShader: gr.meshphysical_vert,
      fragmentShader: gr.meshphysical_frag,
    },
    toon: {
      uniforms: Qn([
        fr.common,
        fr.aomap,
        fr.lightmap,
        fr.emissivemap,
        fr.bumpmap,
        fr.normalmap,
        fr.displacementmap,
        fr.gradientmap,
        fr.fog,
        fr.lights,
        {
          emissive: {
            value: new ln(0),
          },
        },
      ]),
      vertexShader: gr.meshtoon_vert,
      fragmentShader: gr.meshtoon_frag,
    },
    matcap: {
      uniforms: Qn([
        fr.common,
        fr.bumpmap,
        fr.normalmap,
        fr.displacementmap,
        fr.fog,
        {
          matcap: {
            value: null,
          },
        },
      ]),
      vertexShader: gr.meshmatcap_vert,
      fragmentShader: gr.meshmatcap_frag,
    },
    points: {
      uniforms: Qn([fr.points, fr.fog]),
      vertexShader: gr.points_vert,
      fragmentShader: gr.points_frag,
    },
    dashed: {
      uniforms: Qn([
        fr.common,
        fr.fog,
        {
          scale: {
            value: 1,
          },
          dashSize: {
            value: 1,
          },
          totalSize: {
            value: 2,
          },
        },
      ]),
      vertexShader: gr.linedashed_vert,
      fragmentShader: gr.linedashed_frag,
    },
    depth: {
      uniforms: Qn([fr.common, fr.displacementmap]),
      vertexShader: gr.depth_vert,
      fragmentShader: gr.depth_frag,
    },
    normal: {
      uniforms: Qn([
        fr.common,
        fr.bumpmap,
        fr.normalmap,
        fr.displacementmap,
        {
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: gr.meshnormal_vert,
      fragmentShader: gr.meshnormal_frag,
    },
    sprite: {
      uniforms: Qn([fr.sprite, fr.fog]),
      vertexShader: gr.sprite_vert,
      fragmentShader: gr.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new Ie(),
        },
        t2D: {
          value: null,
        },
      },
      vertexShader: gr.background_vert,
      fragmentShader: gr.background_frag,
    },
    cube: {
      uniforms: Qn([
        fr.envmap,
        {
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: gr.cube_vert,
      fragmentShader: gr.cube_frag,
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null,
        },
      },
      vertexShader: gr.equirect_vert,
      fragmentShader: gr.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Qn([
        fr.common,
        fr.displacementmap,
        {
          referencePosition: {
            value: new Ye(),
          },
          nearDistance: {
            value: 1,
          },
          farDistance: {
            value: 1e3,
          },
        },
      ]),
      vertexShader: gr.distanceRGBA_vert,
      fragmentShader: gr.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Qn([
        fr.lights,
        fr.fog,
        {
          color: {
            value: new ln(0),
          },
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: gr.shadow_vert,
      fragmentShader: gr.shadow_frag,
    },
  };
mr.physical = {
  uniforms: Qn([
    mr.standard.uniforms,
    {
      clearcoat: {
        value: 0,
      },
      clearcoatMap: {
        value: null,
      },
      clearcoatRoughness: {
        value: 0,
      },
      clearcoatRoughnessMap: {
        value: null,
      },
      clearcoatNormalScale: {
        value: new Le(1, 1),
      },
      clearcoatNormalMap: {
        value: null,
      },
      sheen: {
        value: 0,
      },
      sheenColor: {
        value: new ln(0),
      },
      sheenColorMap: {
        value: null,
      },
      sheenRoughness: {
        value: 0,
      },
      sheenRoughnessMap: {
        value: null,
      },
      transmission: {
        value: 0,
      },
      transmissionMap: {
        value: null,
      },
      transmissionSamplerSize: {
        value: new Le(),
      },
      transmissionSamplerMap: {
        value: null,
      },
      thickness: {
        value: 0,
      },
      thicknessMap: {
        value: null,
      },
      attenuationDistance: {
        value: 0,
      },
      attenuationColor: {
        value: new ln(0),
      },
      specularIntensity: {
        value: 0,
      },
      specularIntensityMap: {
        value: null,
      },
      specularColor: {
        value: new ln(1, 1, 1),
      },
      specularColorMap: {
        value: null,
      },
    },
  ]),
  vertexShader: gr.meshphysical_vert,
  fragmentShader: gr.meshphysical_frag,
};
class yr {
  constructor(t, e, i, n, r) {
    (this.renderer = t),
      (this.cubemaps = e),
      (this.state = i),
      (this.objects = n),
      (this.premultipliedAlpha = r),
      (this.clearColor = new ln(0)),
      (this.clearAlpha = 0),
      this.planeMesh,
      this.boxMesh,
      (this.currentBackground = null),
      (this.currentBackgroundVersion = 0),
      (this.currentTonemapping = null);
  }
  render(t, e) {
    let i = !1,
      n = !0 === e.isScene ? e.background : null;
    n && n.isTexture && (n = this.cubemaps.get(n)),
      null === n
        ? this.setClear(this.clearColor, this.clearAlpha)
        : n && n.isColor && (this.setClear(n, 1), (i = !0)),
      (this.renderer.autoClear || i) &&
        this.renderer.clear(
          this.renderer.autoClearColor,
          this.renderer.autoClearDepth,
          this.renderer.autoClearStencil
        ),
      n && (n.isCubeTexture || n.mapping === zt)
        ? (void 0 === this.boxMesh &&
            ((this.boxMesh = new Wn(
              new Yn(1, 1, 1),
              new Jn({
                name: "BackgroundCubeMaterial",
                uniforms: Xn(mr.cube.uniforms),
                vertexShader: mr.cube.vertexShader,
                fragmentShader: mr.cube.fragmentShader,
                side: bt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            this.boxMesh.geometry.deleteAttribute("normal"),
            this.boxMesh.geometry.deleteAttribute("uv"),
            (this.boxMesh.onBeforeRender = (t, e, i) => {
              this.matrixWorld.copyPosition(i.matrixWorld);
            }),
            Object.defineProperty(this.boxMesh.material, "envMap", {
              get() {
                return this.uniforms.envMap.value;
              },
            }),
            this.objects.update(this.boxMesh)),
          (this.boxMesh.material.uniforms.envMap.value = n),
          (this.boxMesh.material.uniforms.flipEnvMap.value =
            n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1),
          (this.currentBackground === n &&
            this.currentBackgroundVersion === n.version &&
            this.currentTonemapping === this.renderer.toneMapping) ||
            ((this.boxMesh.material.needsUpdate = !0),
            (this.currentBackground = n),
            (this.currentBackgroundVersion = n.version),
            (this.currentTonemapping = this.renderer.toneMapping)),
          t.unshift(
            this.boxMesh,
            this.boxMesh.geometry,
            this.boxMesh.material,
            0,
            0,
            null
          ))
        : n &&
          n.isTexture &&
          (void 0 === this.planeMesh &&
            ((this.planeMesh = new Wn(
              new dr(2, 2),
              new Jn({
                name: "BackgroundMaterial",
                uniforms: Xn(mr.background.uniforms),
                vertexShader: mr.background.vertexShader,
                fragmentShader: mr.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            this.planeMesh.geometry.deleteAttribute("normal"),
            Object.defineProperty(this.planeMesh.material, "map", {
              get() {
                return this.uniforms.t2D.value;
              },
            }),
            this.objects.update(this.planeMesh)),
          (this.planeMesh.material.uniforms.t2D.value = n),
          !0 === n.matrixAutoUpdate && n.updateMatrix(),
          this.planeMesh.material.uniforms.uvTransform.value.copy(n.matrix),
          (this.currentBackground === n &&
            this.currentBackgroundVersion === n.version &&
            this.currentTonemapping === this.renderer.toneMapping) ||
            ((this.planeMesh.material.needsUpdate = !0),
            (this.currentBackground = n),
            (this.currentBackgroundVersion = n.version),
            (this.currentTonemapping = this.renderer.toneMapping)),
          t.unshift(
            this.planeMesh,
            this.planeMesh.geometry,
            this.planeMesh.material,
            0,
            0,
            null
          ));
  }
  setClear(t, e) {
    this.state.buffers.color.setClear(
      t.r,
      t.g,
      t.b,
      e,
      this.premultipliedAlpha
    );
  }
  getClearColor() {
    return this.clearColor;
  }
  setClearColor(t, e = 1) {
    this.clearColor.set(t),
      (this.clearAlpha = e),
      this.setClear(this.clearColor, this.clearAlpha);
  }
  getClearAlpha() {
    return this.clearAlpha;
  }
  setClearAlpha(t) {
    (this.clearAlpha = t), this.setClear(this.clearColor, this.clearAlpha);
  }
}
class vr {
  constructor(t, e, i, n) {
    (this.gl = t),
      (this.extensions = e),
      (this.attributes = i),
      (this.capabilities = n),
      (this.maxVertexAttributes = t.getParameter(t.MAX_VERTEX_ATTRIBS)),
      (this.extension = n.isWebGL2 ? null : e.get("OES_vertex_array_object")),
      (this.vaoAvailable = n.isWebGL2 || null !== this.extension),
      (this.bindingStates = {}),
      (this.defaultState = this.createBindingState(null)),
      (this.currentState = this.defaultState);
  }
  setup(t, e, i, n, r) {
    let o = !1;
    if (this.vaoAvailable) {
      const t = this.getBindingState(n, i, e);
      this.currentState !== t &&
        ((this.currentState = t),
        this.bindVertexArrayObject(this.currentState.object)),
        (o = this.needsUpdate(n, r)),
        o && this.saveCache(n, r);
    } else {
      const t = !0 === e.wireframe;
      (this.currentState.geometry === n.id &&
        this.currentState.program === i.id &&
        this.currentState.wireframe === t) ||
        ((this.currentState.geometry = n.id),
        (this.currentState.program = i.id),
        (this.currentState.wireframe = t),
        (o = !0));
    }
    !0 === t.isInstancedMesh && (o = !0),
      null !== r && this.attributes.update(r, this.gl.ELEMENT_ARRAY_BUFFER),
      o &&
        (this.setupVertexAttributes(t, e, i, n),
        null !== r &&
          this.gl.bindBuffer(
            this.gl.ELEMENT_ARRAY_BUFFER,
            this.attributes.get(r).buffer
          ));
  }
  createVertexArrayObject() {
    return this.capabilities.isWebGL2
      ? this.gl.createVertexArray()
      : this.extension.createVertexArrayOES();
  }
  bindVertexArrayObject(t) {
    return this.capabilities.isWebGL2
      ? this.gl.bindVertexArray(t)
      : this.extension.bindVertexArrayOES(t);
  }
  deleteVertexArrayObject(t) {
    return this.capabilities.isWebGL2
      ? this.gl.deleteVertexArray(t)
      : this.extension.deleteVertexArrayOES(t);
  }
  getBindingState(t, e, i) {
    const n = !0 === i.wireframe;
    let r = this.bindingStates[t.id];
    void 0 === r && ((r = {}), (this.bindingStates[t.id] = r));
    let o = r[e.id];
    void 0 === o && ((o = {}), (r[e.id] = o));
    let a = o[n];
    return (
      void 0 === a &&
        ((a = this.createBindingState(this.createVertexArrayObject())),
        (o[n] = a)),
      a
    );
  }
  createBindingState(t) {
    const e = [],
      i = [],
      n = [];
    for (let r = 0; r < this.maxVertexAttributes; r++)
      (e[r] = 0), (i[r] = 0), (n[r] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: i,
      attributeDivisors: n,
      object: t,
      attributes: {},
      index: null,
    };
  }
  needsUpdate(t, e) {
    const i = this.currentState.attributes,
      n = t.attributes;
    let r = 0;
    for (const o in n) {
      const t = i[o],
        e = n[o];
      if (void 0 === t) return !0;
      if (t.attribute !== e) return !0;
      if (t.data !== e.data) return !0;
      r++;
    }
    return (
      this.currentState.attributesNum !== r || this.currentState.index !== e
    );
  }
  saveCache(t, e) {
    const i = {},
      n = t.attributes;
    let r = 0;
    for (const o in n) {
      const t = n[o],
        e = {};
      (e.attribute = t), t.data && (e.data = t.data), (i[o] = e), r++;
    }
    (this.currentState.attributes = i),
      (this.currentState.attributesNum = r),
      (this.currentState.index = e);
  }
  initAttributes() {
    const t = this.currentState.newAttributes;
    for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
  }
  enableAttribute(t) {
    this.enableAttributeAndDivisor(t, 0);
  }
  enableAttributeAndDivisor(t, e) {
    const i = this.currentState.newAttributes,
      n = this.currentState.enabledAttributes,
      r = this.currentState.attributeDivisors;
    if (
      ((i[t] = 1),
      0 === n[t] && (this.gl.enableVertexAttribArray(t), (n[t] = 1)),
      r[t] !== e)
    ) {
      (this.capabilities.isWebGL2
        ? this.gl
        : this.extensions.get("ANGLE_instanced_arrays"))[
        this.capabilities.isWebGL2
          ? "vertexAttribDivisor"
          : "vertexAttribDivisorANGLE"
      ](t, e),
        (r[t] = e);
    }
  }
  disableUnusedAttributes() {
    const t = this.currentState.newAttributes,
      e = this.currentState.enabledAttributes;
    for (let i = 0, n = e.length; i < n; i++)
      e[i] !== t[i] && (this.gl.disableVertexAttribArray(i), (e[i] = 0));
  }
  vertexAttribPointer(t, e, i, n, r, o) {
    !0 !== this.capabilities.isWebGL2 ||
    (i !== this.gl.INT && i !== this.gl.UNSIGNED_INT)
      ? this.gl.vertexAttribPointer(t, e, i, n, r, o)
      : this.gl.vertexAttribIPointer(t, e, i, r, o);
  }
  setupVertexAttributes(t, e, i, n) {
    if (
      !1 === this.capabilities.isWebGL2 &&
      (t.isInstancedMesh || n.isInstancedBufferGeometry) &&
      null === this.extensions.get("ANGLE_instanced_arrays")
    )
      return;
    this.initAttributes();
    const r = n.attributes,
      o = i.getAttributes(),
      a = e.defaultAttributeValues;
    for (const s in o) {
      const e = o[s];
      if (e.location >= 0) {
        let i = r[s];
        if (
          (void 0 === i &&
            ("instanceMatrix" === s &&
              t.instanceMatrix &&
              (i = t.instanceMatrix),
            "instanceColor" === s && t.instanceColor && (i = t.instanceColor)),
          void 0 !== i)
        ) {
          const r = i.normalized,
            o = i.itemSize,
            a = this.attributes.get(i);
          if (void 0 === a) continue;
          const s = a.buffer,
            l = a.type,
            u = a.bytesPerElement;
          if (i.isInterleavedBufferAttribute) {
            const a = i.data,
              c = a.stride,
              h = i.offset;
            if (a && a.isInstancedInterleavedBuffer) {
              for (let t = 0; t < e.locationSize; t++)
                this.enableAttributeAndDivisor(
                  e.location + t,
                  a.meshPerAttribute
                );
              !0 !== t.isInstancedMesh &&
                void 0 === n._maxInstanceCount &&
                (n._maxInstanceCount = a.meshPerAttribute * a.count);
            } else
              for (let t = 0; t < e.locationSize; t++)
                this.enableAttribute(e.location + t);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s);
            for (let t = 0; t < e.locationSize; t++)
              this.vertexAttribPointer(
                e.location + t,
                o / e.locationSize,
                l,
                r,
                c * u,
                (h + (o / e.locationSize) * t) * u
              );
          } else {
            if (i.isInstancedBufferAttribute) {
              for (let t = 0; t < e.locationSize; t++)
                this.enableAttributeAndDivisor(
                  e.location + t,
                  i.meshPerAttribute
                );
              !0 !== t.isInstancedMesh &&
                void 0 === n._maxInstanceCount &&
                (n._maxInstanceCount = i.meshPerAttribute * i.count);
            } else
              for (let t = 0; t < e.locationSize; t++)
                this.enableAttribute(e.location + t);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s);
            for (let t = 0; t < e.locationSize; t++)
              this.vertexAttribPointer(
                e.location + t,
                o / e.locationSize,
                l,
                r,
                o * u,
                (o / e.locationSize) * t * u
              );
          }
        } else if (void 0 !== a) {
          const t = a[s];
          if (void 0 !== t)
            switch (t.length) {
              case 2:
                this.gl.vertexAttrib2fv(e.location, t);
                break;
              case 3:
                this.gl.vertexAttrib3fv(e.location, t);
                break;
              case 4:
                this.gl.vertexAttrib4fv(e.location, t);
                break;
              default:
                this.gl.vertexAttrib1fv(e.location, t);
            }
        }
      }
    }
    this.disableUnusedAttributes();
  }
  dispose() {
    this.reset();
    for (const t in this.bindingStates) {
      const e = this.bindingStates[t];
      for (const t in e) {
        const i = e[t];
        for (const t in i)
          this.deleteVertexArrayObject(i[t].object), delete i[t];
        delete e[t];
      }
      delete this.bindingStates[t];
    }
  }
  releaseStatesOfGeometry(t) {
    if (void 0 === this.bindingStates[t.id]) return;
    const e = this.bindingStates[t.id];
    for (const i in e) {
      const t = e[i];
      for (const e in t) this.deleteVertexArrayObject(t[e].object), delete t[e];
      delete e[i];
    }
    delete this.bindingStates[t.id];
  }
  releaseStatesOfProgram(t) {
    for (const e in this.bindingStates) {
      const i = this.bindingStates[e];
      if (void 0 === i[t.id]) continue;
      const n = i[t.id];
      for (const t in n) this.deleteVertexArrayObject(n[t].object), delete n[t];
      delete i[t.id];
    }
  }
  reset() {
    this.resetDefaultState(),
      this.currentState !== this.defaultState &&
        ((this.currentState = this.defaultState),
        this.bindVertexArrayObject(this.currentState.object));
  }
  resetDefaultState() {
    (this.defaultState.geometry = null),
      (this.defaultState.program = null),
      (this.defaultState.wireframe = !1);
  }
}
function br(t, e, i, n) {
  const r = n.isWebGL2;
  let o;
  (this.setMode = function (t) {
    o = t;
  }),
    (this.render = function (e, n) {
      t.drawArrays(o, e, n), i.update(n, o, 1);
    }),
    (this.renderInstances = function (n, a, s) {
      if (0 === s) return;
      let l, u;
      if (r) (l = t), (u = "drawArraysInstanced");
      else if (
        ((l = e.get("ANGLE_instanced_arrays")),
        (u = "drawArraysInstancedANGLE"),
        null === l)
      )
        return void console.error(
          "@dp/gis-engine: WebGLBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      l[u](o, n, a, s), i.update(a, o, s);
    });
}
class xr {
  constructor(t, e, i) {
    (this.gl = t),
      (this.extensions = e),
      (this.parameters = i),
      (this.isWebGL2 =
        ("undefined" != typeof WebGL2RenderingContext &&
          this.gl instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          t instanceof WebGL2ComputeRenderingContext)),
      (this.precision = void 0 !== i.precision ? i.precision : "highp");
    const n = this.getMaxPrecision(this.precision);
    n !== this.precision && (this.precision, (this.precision = n)),
      (this.drawBuffers = this.isWebGL2 || e.has("WEBGL_draw_buffers")),
      (this.logarithmicDepthBuffer = !0 === i.logarithmicDepthBuffer),
      (this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)),
      (this.maxVertexTextures = t.getParameter(
        t.MAX_VERTEX_TEXTURE_IMAGE_UNITS
      )),
      (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)),
      (this.maxCubemapSize = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)),
      (this.maxAttributes = t.getParameter(t.MAX_VERTEX_ATTRIBS)),
      (this.maxVertexUniforms = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)),
      (this.maxVaryings = t.getParameter(t.MAX_VARYING_VECTORS)),
      (this.maxFragmentUniforms = t.getParameter(
        t.MAX_FRAGMENT_UNIFORM_VECTORS
      )),
      (this.vertexTextures = this.maxVertexTextures > 0),
      (this.floatFragmentTextures =
        this.isWebGL2 || e.has("OES_texture_float")),
      (this.floatVertexTextures =
        this.vertexTextures && this.floatFragmentTextures),
      (this.maxSamples = this.isWebGL2 ? t.getParameter(t.MAX_SAMPLES) : 0);
  }
  getMaxAnisotropy() {
    if (void 0 !== this.maxAnisotropy) return this.maxAnisotropy;
    if (!0 === this.extensions.has("EXT_texture_filter_anisotropic")) {
      const t = this.extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = this.gl.getParameter(
        t.MAX_TEXTURE_MAX_ANISOTROPY_EXT
      );
    } else this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
  getMaxPrecision(t) {
    if ("highp" === t) {
      if (
        this.gl.getShaderPrecisionFormat(
          this.gl.VERTEX_SHADER,
          this.gl.HIGH_FLOAT
        ).precision > 0 &&
        this.gl.getShaderPrecisionFormat(
          this.gl.FRAGMENT_SHADER,
          this.gl.HIGH_FLOAT
        ).precision > 0
      )
        return "highp";
      t = "mediump";
    }
    return "mediump" === t &&
      this.gl.getShaderPrecisionFormat(
        this.gl.VERTEX_SHADER,
        this.gl.MEDIUM_FLOAT
      ).precision > 0 &&
      this.gl.getShaderPrecisionFormat(
        this.gl.FRAGMENT_SHADER,
        this.gl.MEDIUM_FLOAT
      ).precision > 0
      ? "mediump"
      : "lowp";
  }
}
class _r {
  constructor(t) {
    (this.properties = t),
      (this.globalState = null),
      (this.numGlobalPlanes = 0),
      (this.localClippingEnabled = !1),
      (this.renderingShadows = !1),
      (this.plane = new lr()),
      (this.viewNormalMatrix = new Ie()),
      (this.uniform = {
        value: null,
        needsUpdate: !1,
      }),
      (this.numPlanes = 0),
      (this.numIntersection = 0);
  }
  init(t, e, i) {
    const n =
      0 !== t.length ||
      e ||
      0 !== this.numGlobalPlanes ||
      this.localClippingEnabled;
    return (
      (this.localClippingEnabled = e),
      (this.globalState = this.projectPlanes(t, i, 0)),
      (this.numGlobalPlanes = t.length),
      n
    );
  }
  beginShadows() {
    (this.renderingShadows = !0), this.projectPlanes(null);
  }
  endShadows() {
    (this.renderingShadows = !1), this.resetGlobalState();
  }
  setState(t, e, i) {
    const n = t.clippingPlanes,
      r = t.clipIntersection,
      o = t.clipShadows,
      a = this.properties.get(t);
    if (
      !this.localClippingEnabled ||
      null === n ||
      0 === n.length ||
      (this.renderingShadows && !o)
    )
      this.renderingShadows
        ? this.projectPlanes(null)
        : this.resetGlobalState();
    else {
      const t = this.renderingShadows ? 0 : this.numGlobalPlanes,
        o = 4 * t;
      let s = a.clippingState || null;
      (this.uniform.value = s), (s = this.projectPlanes(n, e, o, i));
      for (let e = 0; e !== o; ++e) s[e] = this.globalState[e];
      (a.clippingState = s),
        (this.numIntersection = r ? this.numPlanes : 0),
        (this.numPlanes += t);
    }
  }
  resetGlobalState() {
    this.uniform.value !== this.globalState &&
      ((this.uniform.value = this.globalState),
      (this.uniform.needsUpdate = this.numGlobalPlanes > 0)),
      (this.numPlanes = this.numGlobalPlanes),
      (this.numIntersection = 0);
  }
  projectPlanes(t, e, i, n) {
    const r = null !== t ? t.length : 0;
    let o = null;
    if (0 !== r) {
      if (((o = this.uniform.value), !0 !== n || null === o)) {
        const n = i + 4 * r,
          a = e.matrixWorldInverse;
        this.viewNormalMatrix.getNormalMatrix(a),
          (null === o || o.length < n) && (o = new Float32Array(n));
        for (let e = 0, s = i; e !== r; ++e, s += 4)
          this.plane.copy(t[e]).applyMatrix4(a, this.viewNormalMatrix),
            this.plane.normal.toArray(o, s),
            (o[s + 3] = this.plane.constant);
      }
      (this.uniform.value = o), (this.uniform.needsUpdate = !0);
    }
    (this.numPlanes = r), (this.numIntersection = 0);
  }
}
class Sr {
  constructor(t) {
    (this.renderer = t),
      (this.onTextureDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onTextureDispose);
        const i = this.cubemaps.get(e);
        void 0 !== i && (this.cubemaps.delete(e), i.dispose());
      }),
      (this.cubemaps = new WeakMap());
  }
  mapTextureMapping(t, e) {
    return 303 === e ? (t.mapping = Ot) : 304 === e && (t.mapping = Ft), t;
  }
  get(t) {
    if (t && t.isTexture && !1 === t.isRenderTargetTexture) {
      const e = t.mapping;
      if (303 === e || 304 === e) {
        if (this.cubemaps.has(t)) {
          const e = this.cubemaps.get(t).texture;
          return this.mapTextureMapping(e, t.mapping);
        }
        {
          const e = t.image;
          if (e && e.height > 0) {
            const i = this.renderer.getRenderTarget(),
              n = new nr(e.height / 2);
            return (
              n.fromEquirectangularTexture(this.renderer, t),
              this.cubemaps.set(t, n),
              this.renderer.setRenderTarget(i),
              t.addEventListener("dispose", this.onTextureDispose),
              this.mapTextureMapping(n.texture, t.mapping)
            );
          }
          return null;
        }
      }
    }
    return t;
  }
  dispose() {
    this.cubemaps = new WeakMap();
  }
}
class Mr extends Kn {
  constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = i),
      (this.bottom = n),
      (this.near = r),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  update(t, e) {
    (this.left = -t / 2),
      (this.right = t / 2),
      (this.top = e / 2),
      (this.bottom = -e / 2),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      this
    );
  }
  setViewOffset(t, e, i, n, r, o) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      n = (this.top + this.bottom) / 2;
    let r = i - t,
      o = i + t,
      a = n + e,
      s = n - e;
    if (null !== this.view && this.view.enabled) {
      const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += t * this.view.offsetX),
        (o = r + t * this.view.width),
        (a -= e * this.view.offsetY),
        (s = a - e * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      e
    );
  }
}
class Cr extends Jn {
  constructor(t) {
    super(t),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
const wr = Math.pow(2, 8),
  Ar = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Er = 5 + Ar.length,
  Dr = 20,
  Tr = {
    [ce]: 0,
    [he]: 1,
    [de]: 2,
    [ge]: 3,
    [me]: 4,
    [ye]: 5,
    [pe]: 6,
  },
  Pr = new Mr(),
  { _lodPlanes: Lr, _sizeLods: Ir, _sigmas: Nr } = Ur(),
  Rr = new ln();
let Or = null;
const Fr = (1 + Math.sqrt(5)) / 2,
  zr = 1 / Fr,
  kr = [
    new Ye(1, 1, 1),
    new Ye(-1, 1, 1),
    new Ye(1, 1, -1),
    new Ye(-1, 1, -1),
    new Ye(0, Fr, zr),
    new Ye(0, Fr, -zr),
    new Ye(zr, 0, Fr),
    new Ye(-zr, 0, Fr),
    new Ye(Fr, zr, 0),
    new Ye(-Fr, zr, 0),
  ];
class Br {
  constructor(t) {
    (this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._blurMaterial = (function (t) {
        const e = new Float32Array(t),
          i = new Ye(0, 1, 0);
        return new Cr({
          name: "SphericalGaussianBlur",
          defines: {
            n: t,
          },
          uniforms: {
            envMap: {
              value: null,
            },
            samples: {
              value: 1,
            },
            weights: {
              value: e,
            },
            latitudinal: {
              value: !1,
            },
            dTheta: {
              value: 0,
            },
            mipInt: {
              value: 0,
            },
            poleAxis: {
              value: i,
            },
            inputEncoding: {
              value: Tr[ce],
            },
            outputEncoding: {
              value: Tr[ce],
            },
          },
          vertexShader: qr(),
          fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Yr()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      })(Dr)),
      (this._equirectShader = null),
      (this._cubemapShader = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, i = 0.1, n = 100) {
    Or = this._renderer.getRenderTarget();
    const r = this._allocateTargets();
    return (
      this._sceneToCubeUV(t, i, n, r),
      e > 0 && this._blur(r, 0, 0, e),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(t) {
    return this._fromTexture(t);
  }
  fromCubemap(t) {
    return this._fromTexture(t);
  }
  compileCubemapShader() {
    null === this._cubemapShader &&
      ((this._cubemapShader = Wr()),
      this._compileMaterial(this._cubemapShader));
  }
  compileEquirectangularShader() {
    null === this._equirectShader &&
      ((this._equirectShader = Vr()),
      this._compileMaterial(this._equirectShader));
  }
  dispose() {
    this._blurMaterial.dispose(),
      null !== this._cubemapShader && this._cubemapShader.dispose(),
      null !== this._equirectShader && this._equirectShader.dispose();
    for (let t = 0; t < Lr.length; t++) Lr[t].dispose();
  }
  _cleanup(t) {
    this._pingPongRenderTarget.dispose(),
      this._renderer.setRenderTarget(Or),
      (t.scissorTest = !1),
      Hr(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t) {
    Or = this._renderer.getRenderTarget();
    const e = this._allocateTargets(t);
    return (
      this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
    );
  }
  _allocateTargets(t) {
    const e = {
        magFilter: Ut,
        minFilter: Ut,
        generateMipmaps: !1,
        type: Yt,
        format: 1023,
        encoding: Gr(t) ? t.encoding : de,
        depthBuffer: !1,
      },
      i = jr(e);
    return (i.depthBuffer = !t), (this._pingPongRenderTarget = jr(e)), i;
  }
  _compileMaterial(t) {
    const e = new Wn(Lr[0], t);
    this._renderer.compile(e, Pr);
  }
  _sceneToCubeUV(t, e, i, n) {
    const r = new $n(90, 1, e, i),
      o = [1, -1, 1, 1, 1, 1],
      a = [1, 1, 1, -1, -1, -1],
      s = this._renderer,
      l = s.autoClear,
      u = s.outputEncoding,
      c = s.toneMapping;
    s.getClearColor(Rr),
      (s.toneMapping = 0),
      (s.outputEncoding = ce),
      (s.autoClear = !1);
    const h = new pn({
        name: "PMREM.Background",
        side: bt,
        depthWrite: !1,
        depthTest: !1,
      }),
      p = new Wn(new Yn(), h);
    let d = !1;
    const f = t.background;
    f
      ? f.isColor && (h.color.copy(f), (t.background = null), (d = !0))
      : (h.color.copy(Rr), (d = !0));
    for (let g = 0; g < 6; g++) {
      const e = g % 3;
      0 == e
        ? (r.up.set(0, o[g], 0), r.lookAt(a[g], 0, 0))
        : 1 == e
        ? (r.up.set(0, 0, o[g]), r.lookAt(0, a[g], 0))
        : (r.up.set(0, o[g], 0), r.lookAt(0, 0, a[g])),
        Hr(n, e * wr, g > 2 ? wr : 0, wr, wr),
        s.setRenderTarget(n),
        d && s.render(p, r),
        s.render(t, r);
    }
    p.geometry.dispose(),
      p.material.dispose(),
      (s.toneMapping = c),
      (s.outputEncoding = u),
      (s.autoClear = l),
      (t.background = f);
  }
  _setEncoding(t, e) {
    t.value = Tr[e.encoding];
  }
  _textureToCubeUV(t, e) {
    const i = this._renderer,
      n = t.mapping === Ot || t.mapping === Ft;
    n
      ? null == this._cubemapShader && (this._cubemapShader = Wr())
      : null == this._equirectShader && (this._equirectShader = Vr());
    const r = n ? this._cubemapShader : this._equirectShader,
      o = new Wn(Lr[0], r),
      a = r.uniforms;
    (a.envMap.value = t),
      n || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
      this._setEncoding(a.inputEncoding, t),
      this._setEncoding(a.outputEncoding, e.texture),
      Hr(e, 0, 0, 3 * wr, 2 * wr),
      i.setRenderTarget(e),
      i.render(o, Pr);
  }
  _applyPMREM(t) {
    const e = this._renderer,
      i = e.autoClear;
    e.autoClear = !1;
    for (let n = 1; n < Er; n++) {
      const e = Math.sqrt(Nr[n] * Nr[n] - Nr[n - 1] * Nr[n - 1]),
        i = kr[(n - 1) % kr.length];
      this._blur(t, n - 1, n, e, i);
    }
    e.autoClear = i;
  }
  _blur(t, e, i, n, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(t, o, e, i, n, "latitudinal", r),
      this._halfBlur(o, t, i, i, n, "longitudinal", r);
  }
  _halfBlur(t, e, i, n, r, o, a) {
    const s = this._renderer,
      l = this._blurMaterial;
    "latitudinal" !== o &&
      "longitudinal" !== o &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = new Wn(Lr[n], l),
      c = l.uniforms,
      h = Ir[i] - 1,
      p = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
      d = r / p,
      f = isFinite(r) ? 1 + Math.floor(3 * d) : Dr,
      g = [];
    let m = 0;
    for (let v = 0; v < Dr; ++v) {
      const t = v / d,
        e = Math.exp((-t * t) / 2);
      g.push(e), 0 == v ? (m += e) : v < f && (m += 2 * e);
    }
    for (let v = 0; v < g.length; v++) g[v] = g[v] / m;
    (c.envMap.value = t.texture),
      (c.samples.value = f),
      (c.weights.value = g),
      (c.latitudinal.value = "latitudinal" === o),
      a && (c.poleAxis.value = a),
      (c.dTheta.value = p),
      (c.mipInt.value = 8 - i),
      this._setEncoding(c.inputEncoding, t.texture),
      this._setEncoding(c.outputEncoding, t.texture);
    const y = Ir[n];
    Hr(
      e,
      3 * Math.max(0, wr - 2 * y),
      (0 === n ? 0 : 2 * wr) + 2 * y * (n > 4 ? n - 8 + 4 : 0),
      3 * y,
      2 * y
    ),
      s.setRenderTarget(e),
      s.render(u, Pr);
  }
}
function Gr(t) {
  return (
    void 0 !== t &&
    t.type === Yt &&
    (t.encoding === ce || t.encoding === he || t.encoding === pe)
  );
}
function Ur() {
  const t = [],
    e = [],
    i = [];
  let n = 8;
  for (let r = 0; r < Er; r++) {
    const o = Math.pow(2, n);
    e.push(o);
    let a = 1 / o;
    r > 4 ? (a = Ar[r - 8 + 4 - 1]) : 0 == r && (a = 0), i.push(a);
    const s = 1 / (o - 1),
      l = -s / 2,
      u = 1 + s / 2,
      c = [l, l, u, l, u, u, l, l, u, u, l, u],
      h = 6,
      p = 6,
      d = 3,
      f = 2,
      g = 1,
      m = new Float32Array(d * p * h),
      y = new Float32Array(f * p * h),
      v = new Float32Array(g * p * h);
    for (let t = 0; t < h; t++) {
      const e = ((t % 3) * 2) / 3 - 1,
        i = t > 2 ? 0 : -1,
        n = [
          e,
          i,
          0,
          e + 2 / 3,
          i,
          0,
          e + 2 / 3,
          i + 1,
          0,
          e,
          i,
          0,
          e + 2 / 3,
          i + 1,
          0,
          e,
          i + 1,
          0,
        ];
      m.set(n, d * p * t), y.set(c, f * p * t);
      const r = [t, t, t, t, t, t];
      v.set(r, g * p * t);
    }
    const b = new En();
    b.setAttribute("position", new gn(m, d)),
      b.setAttribute("uv", new gn(y, f)),
      b.setAttribute("faceIndex", new gn(v, g)),
      t.push(b),
      n > 4 && n--;
  }
  return {
    _lodPlanes: t,
    _sizeLods: e,
    _sigmas: i,
  };
}
function jr(t) {
  const e = new He(3 * wr, 3 * wr, t);
  return (
    (e.texture.mapping = zt),
    (e.texture.name = "PMREM.cubeUv"),
    (e.scissorTest = !0),
    e
  );
}
function Hr(t, e, i, n, r) {
  t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r);
}
function Vr() {
  const t = new Le(1, 1);
  return new Cr({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
      texelSize: {
        value: t,
      },
      inputEncoding: {
        value: Tr[ce],
      },
      outputEncoding: {
        value: Tr[ce],
      },
    },
    vertexShader: qr(),
    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Yr()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Wr() {
  return new Cr({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
      inputEncoding: {
        value: Tr[ce],
      },
      outputEncoding: {
        value: Tr[ce],
      },
    },
    vertexShader: qr(),
    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Yr()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function qr() {
  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}
function Yr() {
  return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
}
class Xr {
  constructor(t) {
    (this.renderer = t),
      (this.onTextureDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onTextureDispose);
        const i = this.cubeUVmaps.get(e);
        void 0 !== i && (this.cubeUVmaps.delete(e), i.dispose());
      }),
      (this.cubeUVmaps = new WeakMap()),
      (this.pmremGenerator = null);
  }
  get(t) {
    if (t && t.isTexture && !1 === t.isRenderTargetTexture) {
      const e = t.mapping,
        i = 303 === e || 304 === e,
        n = e === Ot || e === Ft;
      if (i || n) {
        if (this.cubeUVmaps.has(t)) return this.cubeUVmaps.get(t).texture;
        {
          const e = t.image;
          if (
            (i && e && e.height > 0) ||
            (n && e && this.isCubeTextureComplete(e))
          ) {
            const e = this.renderer.getRenderTarget();
            null === this.pmremGenerator &&
              (this.pmremGenerator = new Br(this.renderer));
            const n = i
              ? this.pmremGenerator.fromEquirectangular(t)
              : this.pmremGenerator.fromCubemap(t);
            return (
              this.cubeUVmaps.set(t, n),
              this.renderer.setRenderTarget(e),
              t.addEventListener("dispose", this.onTextureDispose),
              n.texture
            );
          }
          return null;
        }
      }
    }
    return t;
  }
  isCubeTextureComplete(t) {
    let e = 0;
    for (let i = 0; i < 6; i++) void 0 !== t[i] && e++;
    return 6 === e;
  }
  dispose() {
    (this.cubeUVmaps = new WeakMap()),
      null !== this.pmremGenerator &&
        (this.pmremGenerator.dispose(), (this.pmremGenerator = null));
  }
}
class Qr {
  constructor(t) {
    (this.gl = t), (this.extensions = {});
  }
  getExtension(t) {
    if (void 0 !== this.extensions[t]) return this.extensions[t];
    let e;
    switch (t) {
      case "WEBGL_depth_texture":
        e =
          this.gl.getExtension("WEBGL_depth_texture") ||
          this.gl.getExtension("MOZ_WEBGL_depth_texture") ||
          this.gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        e =
          this.gl.getExtension("EXT_texture_filter_anisotropic") ||
          this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        e =
          this.gl.getExtension("WEBGL_compressed_texture_s3tc") ||
          this.gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          this.gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        e =
          this.gl.getExtension("WEBGL_compressed_texture_pvrtc") ||
          this.gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        e = this.gl.getExtension(t);
    }
    return (this.extensions[t] = e), e;
  }
  has(t) {
    return null !== this.getExtension(t);
  }
  init(t) {
    t.isWebGL2
      ? this.getExtension("EXT_color_buffer_float")
      : (this.getExtension("WEBGL_depth_texture"),
        this.getExtension("OES_texture_float"),
        this.getExtension("OES_texture_half_float"),
        this.getExtension("OES_texture_half_float_linear"),
        this.getExtension("OES_standard_derivatives"),
        this.getExtension("OES_element_index_uint"),
        this.getExtension("OES_vertex_array_object"),
        this.getExtension("ANGLE_instanced_arrays")),
      this.getExtension("OES_texture_float_linear"),
      this.getExtension("EXT_color_buffer_half_float");
  }
  get(t) {
    const e = this.getExtension(t);
    return e;
  }
}
class Zr {
  constructor(t, e, i, n) {
    (this.gl = t),
      (this.attributes = e),
      (this.info = i),
      (this.bindingStates = n),
      (this.onGeometryDispose = (t) => {
        const e = t.target;
        null !== e.index && this.attributes.remove(e.index);
        for (const n in e.attributes) this.attributes.remove(e.attributes[n]);
        e.removeEventListener("dispose", this.onGeometryDispose),
          delete this.geometries[e.id];
        const i = this.wireframeAttributes.get(e);
        i && (this.attributes.remove(i), this.wireframeAttributes.delete(e)),
          this.bindingStates.releaseStatesOfGeometry(e),
          !0 === e.isInstancedBufferGeometry && delete e._maxInstanceCount,
          this.info.memory.geometries--;
      }),
      (this.geometries = {}),
      (this.wireframeAttributes = new WeakMap());
  }
  get(t, e) {
    return (
      !0 === this.geometries[e.id] ||
        (e.addEventListener("dispose", this.onGeometryDispose),
        (this.geometries[e.id] = !0),
        this.info.memory.geometries++),
      e
    );
  }
  update(t) {
    const e = t.attributes;
    for (const n in e) this.attributes.update(e[n], this.gl.ARRAY_BUFFER);
    const i = t.morphAttributes;
    for (const n in i) {
      const t = i[n];
      for (let e = 0, i = t.length; e < i; e++)
        this.attributes.update(t[e], this.gl.ARRAY_BUFFER);
    }
  }
  updateWireframeAttribute(t) {
    const e = [],
      i = t.index,
      n = t.attributes.position;
    let r = 0;
    if (null !== i) {
      const t = i.array;
      r = i.version;
      for (let i = 0, n = t.length; i < n; i += 3) {
        const n = t[i + 0],
          r = t[i + 1],
          o = t[i + 2];
        e.push(n, r, r, o, o, n);
      }
    } else {
      const t = n.array;
      r = n.version;
      for (let i = 0, n = t.length / 3 - 1; i < n; i += 3) {
        const t = i + 0,
          n = i + 1,
          r = i + 2;
        e.push(t, n, n, r, r, t);
      }
    }
    const o = new (Ne(e) > 65535 ? vn : yn)(e, 1);
    o.version = r;
    const a = this.wireframeAttributes.get(t);
    a && this.attributes.remove(a), this.wireframeAttributes.set(t, o);
  }
  getWireframeAttribute(t) {
    const e = this.wireframeAttributes.get(t);
    if (e) {
      const i = t.index;
      null !== i && e.version < i.version && this.updateWireframeAttribute(t);
    } else this.updateWireframeAttribute(t);
    return this.wireframeAttributes.get(t);
  }
}
function Jr(t, e, i, n) {
  const r = n.isWebGL2;
  let o, a, s;
  (this.setMode = function (t) {
    o = t;
  }),
    (this.setIndex = function (t) {
      (a = t.type), (s = t.bytesPerElement);
    }),
    (this.render = function (e, n) {
      t.drawElements(o, n, a, e * s), i.update(n, o, 1);
    }),
    (this.renderInstances = function (n, l, u) {
      if (0 === u) return;
      let c, h;
      if (r) (c = t), (h = "drawElementsInstanced");
      else if (
        ((c = e.get("ANGLE_instanced_arrays")),
        (h = "drawElementsInstancedANGLE"),
        null === c)
      )
        return void console.error(
          "@dp/gis-engine: WebGLIndexedBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      c[h](o, l, a, n * s, u), i.update(l, o, u);
    });
}
class Kr {
  constructor(t) {
    (this.gl = t),
      (this.autoReset = !0),
      (this.programs = null),
      (this.memory = {
        geometries: 0,
        textures: 0,
      }),
      (this.render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
      });
  }
  update(t, e, i) {
    switch ((this.render.calls++, e)) {
      case this.gl.TRIANGLES:
        this.render.triangles += i * (t / 3);
        break;
      case this.gl.LINES:
        this.render.lines += i * (t / 2);
        break;
      case this.gl.LINE_STRIP:
        this.render.lines += i * (t - 1);
        break;
      case this.gl.LINE_LOOP:
        this.render.lines += i * t;
        break;
      case this.gl.POINTS:
        this.render.points += i * t;
        break;
      default:
        console.error("@dp/gis-engine: WebGLInfo: Unknown draw mode:", e);
    }
  }
  reset() {
    this.render.frame++,
      (this.render.calls = 0),
      (this.render.triangles = 0),
      (this.render.points = 0),
      (this.render.lines = 0);
  }
}
class $r {
  constructor(t) {
    this.properties = t;
  }
  refreshFogUniforms(t, e) {
    t.fogColor.value.copy(e.color),
      e.isFog
        ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
        : e.isFogExp2 && (t.fogDensity.value = e.density);
  }
  refreshMaterialUniforms(t, e, i, n, r) {
    e.isMeshBasicMaterial
      ? this.refreshUniformsCommon(t, e)
      : e.isMeshLambertMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsLambert(t, e))
      : e.isMeshToonMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsToon(t, e))
      : e.isMeshPhongMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsPhong(t, e))
      : e.isMeshStandardMaterial
      ? (this.refreshUniformsCommon(t, e),
        e.isMeshPhysicalMaterial
          ? this.refreshUniformsPhysical(t, e, r)
          : this.refreshUniformsStandard(t, e))
      : e.isMeshMatcapMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsMatcap(t, e))
      : e.isMeshDepthMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsDepth(t, e))
      : e.isMeshDistanceMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsDistance(t, e))
      : e.isMeshNormalMaterial
      ? (this.refreshUniformsCommon(t, e), this.refreshUniformsNormal(t, e))
      : e.isLineBasicMaterial
      ? (this.refreshUniformsLine(t, e),
        e.isLineDashedMaterial && this.refreshUniformsDash(t, e))
      : e.isPointsMaterial
      ? this.refreshUniformsPoints(t, e, i, n)
      : e.isSpriteMaterial
      ? this.refreshUniformsSprites(t, e)
      : e.isShadowMaterial
      ? (t.color.value.copy(e.color), (t.opacity.value = e.opacity))
      : e.isShaderMaterial && (e.uniformsNeedUpdate = !1);
  }
  refreshUniformsCommon(t, e) {
    (t.opacity.value = e.opacity),
      e.color && t.diffuse.value.copy(e.color),
      e.emissive &&
        t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
      e.map && (t.map.value = e.map),
      e.alphaMap && (t.alphaMap.value = e.alphaMap),
      e.specularMap && (t.specularMap.value = e.specularMap),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
    const i = this.properties.get(e).envMap;
    let n, r;
    i &&
      ((t.envMap.value = i),
      (t.flipEnvMap.value =
        i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
      (t.reflectivity.value = e.reflectivity),
      (t.ior.value = e.ior),
      (t.refractionRatio.value = e.refractionRatio)),
      e.lightMap &&
        ((t.lightMap.value = e.lightMap),
        (t.lightMapIntensity.value = e.lightMapIntensity)),
      e.aoMap &&
        ((t.aoMap.value = e.aoMap),
        (t.aoMapIntensity.value = e.aoMapIntensity)),
      e.map
        ? (n = e.map)
        : e.specularMap
        ? (n = e.specularMap)
        : e.displacementMap
        ? (n = e.displacementMap)
        : e.normalMap
        ? (n = e.normalMap)
        : e.bumpMap
        ? (n = e.bumpMap)
        : e.roughnessMap
        ? (n = e.roughnessMap)
        : e.metalnessMap
        ? (n = e.metalnessMap)
        : e.alphaMap
        ? (n = e.alphaMap)
        : e.emissiveMap
        ? (n = e.emissiveMap)
        : e.clearcoatMap
        ? (n = e.clearcoatMap)
        : e.clearcoatNormalMap
        ? (n = e.clearcoatNormalMap)
        : e.clearcoatRoughnessMap
        ? (n = e.clearcoatRoughnessMap)
        : e.specularIntensityMap
        ? (n = e.specularIntensityMap)
        : e.specularColorMap
        ? (n = e.specularColorMap)
        : e.transmissionMap
        ? (n = e.transmissionMap)
        : e.thicknessMap
        ? (n = e.thicknessMap)
        : e.sheenColorMap
        ? (n = e.sheenColorMap)
        : e.sheenRoughnessMap && (n = e.sheenRoughnessMap),
      void 0 !== n &&
        (n.isWebGLRenderTarget && (n = n.texture),
        !0 === n.matrixAutoUpdate && n.updateMatrix(),
        t.uvTransform.value.copy(n.matrix)),
      e.aoMap ? (r = e.aoMap) : e.lightMap && (r = e.lightMap),
      void 0 !== r &&
        (r.isWebGLRenderTarget && (r = r.texture),
        !0 === r.matrixAutoUpdate && r.updateMatrix(),
        t.uv2Transform.value.copy(r.matrix));
  }
  refreshUniformsLine(t, e) {
    t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
  }
  refreshUniformsDash(t, e) {
    (t.dashSize.value = e.dashSize),
      (t.totalSize.value = e.dashSize + e.gapSize),
      (t.scale.value = e.scale);
  }
  refreshUniformsPoints(t, e, i, n) {
    let r;
    t.diffuse.value.copy(e.color),
      (t.opacity.value = e.opacity),
      (t.size.value = e.size * i),
      (t.scale.value = 0.5 * n),
      e.map && (t.map.value = e.map),
      e.alphaMap && (t.alphaMap.value = e.alphaMap),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
      e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
      void 0 !== r &&
        (!0 === r.matrixAutoUpdate && r.updateMatrix(),
        t.uvTransform.value.copy(r.matrix));
  }
  refreshUniformsSprites(t, e) {
    let i;
    t.diffuse.value.copy(e.color),
      (t.opacity.value = e.opacity),
      (t.rotation.value = e.rotation),
      e.map && (t.map.value = e.map),
      e.alphaMap && (t.alphaMap.value = e.alphaMap),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
      e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
      void 0 !== i &&
        (!0 === i.matrixAutoUpdate && i.updateMatrix(),
        t.uvTransform.value.copy(i.matrix));
  }
  refreshUniformsLambert(t, e) {
    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
  }
  refreshUniformsPhong(t, e) {
    t.specular.value.copy(e.specular),
      (t.shininess.value = Math.max(e.shininess, 1e-4)),
      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
      e.bumpMap &&
        ((t.bumpMap.value = e.bumpMap),
        (t.bumpScale.value = e.bumpScale),
        e.side === bt && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        t.normalScale.value.copy(e.normalScale),
        e.side === bt && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias));
  }
  refreshUniformsToon(t, e) {
    e.gradientMap && (t.gradientMap.value = e.gradientMap),
      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
      e.bumpMap &&
        ((t.bumpMap.value = e.bumpMap),
        (t.bumpScale.value = e.bumpScale),
        e.side === bt && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        t.normalScale.value.copy(e.normalScale),
        e.side === bt && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias));
  }
  refreshUniformsStandard(t, e) {
    (t.roughness.value = e.roughness),
      (t.metalness.value = e.metalness),
      e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
      e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
      e.bumpMap &&
        ((t.bumpMap.value = e.bumpMap),
        (t.bumpScale.value = e.bumpScale),
        e.side === bt && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        t.normalScale.value.copy(e.normalScale),
        e.side === bt && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias));
    this.properties.get(e).envMap &&
      (t.envMapIntensity.value = e.envMapIntensity);
  }
  refreshUniformsPhysical(t, e, i) {
    this.refreshUniformsStandard(t, e),
      (t.ior.value = e.ior),
      e.sheen > 0 &&
        (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
        (t.sheenRoughness.value = e.sheenRoughness),
        e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
        e.sheenRoughnessMap &&
          (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
      e.clearcoat > 0 &&
        ((t.clearcoat.value = e.clearcoat),
        (t.clearcoatRoughness.value = e.clearcoatRoughness),
        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
        e.clearcoatRoughnessMap &&
          (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
        e.clearcoatNormalMap &&
          (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
          e.side === bt && t.clearcoatNormalScale.value.negate())),
      e.transmission > 0 &&
        ((t.transmission.value = e.transmission),
        (t.transmissionSamplerMap.value = i.texture),
        t.transmissionSamplerSize.value.set(i.width, i.height),
        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
        (t.thickness.value = e.thickness),
        e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
        (t.attenuationDistance.value = e.attenuationDistance),
        t.attenuationColor.value.copy(e.attenuationColor)),
      (t.specularIntensity.value = e.specularIntensity),
      t.specularColor.value.copy(e.specularColor),
      e.specularIntensityMap &&
        (t.specularIntensityMap.value = e.specularIntensityMap),
      e.specularColorMap && (t.specularColorMap.value = e.specularColorMap);
  }
  refreshUniformsMatcap(t, e) {
    e.matcap && (t.matcap.value = e.matcap),
      e.bumpMap &&
        ((t.bumpMap.value = e.bumpMap),
        (t.bumpScale.value = e.bumpScale),
        e.side === bt && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        t.normalScale.value.copy(e.normalScale),
        e.side === bt && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias));
  }
  refreshUniformsDepth(t, e) {
    e.displacementMap &&
      ((t.displacementMap.value = e.displacementMap),
      (t.displacementScale.value = e.displacementScale),
      (t.displacementBias.value = e.displacementBias));
  }
  refreshUniformsDistance(t, e) {
    e.displacementMap &&
      ((t.displacementMap.value = e.displacementMap),
      (t.displacementScale.value = e.displacementScale),
      (t.displacementBias.value = e.displacementBias)),
      t.referencePosition.value.copy(e.referencePosition),
      (t.nearDistance.value = e.nearDistance),
      (t.farDistance.value = e.farDistance);
  }
  refreshUniformsNormal(t, e) {
    e.bumpMap &&
      ((t.bumpMap.value = e.bumpMap),
      (t.bumpScale.value = e.bumpScale),
      e.side === bt && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        t.normalScale.value.copy(e.normalScale),
        e.side === bt && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias));
  }
}
class to extends Ge {
  constructor(t = null, e = 1, i = 1, n = 1) {
    super(null),
      (this.isDataTexture2DArray = !0),
      (this.image = {
        data: t,
        width: e,
        height: i,
        depth: n,
      }),
      (this.magFilter = Ut),
      (this.minFilter = Ut),
      (this.wrapR = Bt),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
function eo(t, e) {
  return t[0] - e[0];
}
function io(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function no(t, e) {
  let i = 1;
  const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  n instanceof Int8Array
    ? (i = 127)
    : n instanceof Int16Array
    ? (i = 32767)
    : n instanceof Int32Array
    ? (i = 2147483647)
    : console.error(
        "@dp/gis-engine: WebGLMorphtargets: Unsupported morph attribute data type: ",
        n
      ),
    t.divideScalar(i);
}
class ro {
  constructor(t, e, i) {
    (this.gl = t),
      (this.capabilities = e),
      (this.textures = i),
      (this.influencesList = {}),
      (this.morphInfluences = new Float32Array(8)),
      (this.morphTextures = new WeakMap()),
      (this.morph = new Ye()),
      (this.workInfluences = []);
    for (let n = 0; n < 8; n++) this.workInfluences[n] = [n, 0];
  }
  update(t, e, i, n) {
    const r = t.morphTargetInfluences;
    if (!0 === this.capabilities.isWebGL2) {
      const t = e.morphAttributes.position.length;
      let i = this.morphTextures.get(e);
      if (void 0 === i || i.count !== t) {
        void 0 !== i && i.texture.dispose();
        const n = void 0 !== e.morphAttributes.normal,
          r = e.morphAttributes.position,
          o = e.morphAttributes.normal || [],
          a = !0 === n ? 2 : 1;
        let s = e.attributes.position.count * a,
          l = 1;
        s > this.capabilities.maxTextureSize &&
          ((l = Math.ceil(s / this.capabilities.maxTextureSize)),
          (s = this.capabilities.maxTextureSize));
        const u = new Float32Array(s * l * 4 * t),
          c = new to(u, s, l, t);
        (c.format = te), (c.type = Zt);
        const h = 4 * a;
        for (let e = 0; e < t; e++) {
          const t = r[e],
            i = o[e],
            a = s * l * 4 * e;
          for (let e = 0; e < t.count; e++) {
            this.morph.fromBufferAttribute(t, e),
              !0 === t.normalized && no(this.morph, t);
            const r = e * h;
            (u[a + r + 0] = this.morph.x),
              (u[a + r + 1] = this.morph.y),
              (u[a + r + 2] = this.morph.z),
              (u[a + r + 3] = 0),
              !0 === n &&
                (this.morph.fromBufferAttribute(i, e),
                !0 === i.normalized && no(this.morph, i),
                (u[a + r + 4] = this.morph.x),
                (u[a + r + 5] = this.morph.y),
                (u[a + r + 6] = this.morph.z),
                (u[a + r + 7] = 0));
          }
        }
        (i = {
          count: t,
          texture: c,
          size: new Le(s, l),
        }),
          this.morphTextures.set(e, i);
      }
      let o = 0;
      for (let e = 0; e < r.length; e++) o += r[e];
      const a = e.morphTargetsRelative ? 1 : 1 - o;
      n.getUniforms().setValue(this.gl, "morphTargetBaseInfluence", a),
        n.getUniforms().setValue(this.gl, "morphTargetInfluences", r),
        n
          .getUniforms()
          .setValue(this.gl, "morphTargetsTexture", i.texture, this.textures),
        n.getUniforms().setValue(this.gl, "morphTargetsTextureSize", i.size);
    } else {
      const t = void 0 === r ? 0 : r.length;
      let i = this.influencesList[e.id];
      if (void 0 === i || i.length !== t) {
        i = [];
        for (let e = 0; e < t; e++) i[e] = [e, 0];
        this.influencesList[e.id] = i;
      }
      for (let e = 0; e < t; e++) {
        const t = i[e];
        (t[0] = e), (t[1] = r[e]);
      }
      i.sort(io);
      for (let e = 0; e < 8; e++)
        e < t && i[e][1]
          ? ((this.workInfluences[e][0] = i[e][0]),
            (this.workInfluences[e][1] = i[e][1]))
          : ((this.workInfluences[e][0] = Number.MAX_SAFE_INTEGER),
            (this.workInfluences[e][1] = 0));
      this.workInfluences.sort(eo);
      const o = e.morphAttributes.position,
        a = e.morphAttributes.normal;
      let s = 0;
      for (let n = 0; n < 8; n++) {
        const t = this.workInfluences[n],
          i = t[0],
          r = t[1];
        i !== Number.MAX_SAFE_INTEGER && r
          ? (o &&
              e.getAttribute("morphTarget" + n) !== o[i] &&
              e.setAttribute("morphTarget" + n, o[i]),
            a &&
              e.getAttribute("morphNormal" + n) !== a[i] &&
              e.setAttribute("morphNormal" + n, a[i]),
            (this.morphInfluences[n] = r),
            (s += r))
          : (o &&
              !0 === e.hasAttribute("morphTarget" + n) &&
              e.deleteAttribute("morphTarget" + n),
            a &&
              !0 === e.hasAttribute("morphNormal" + n) &&
              e.deleteAttribute("morphNormal" + n),
            (this.morphInfluences[n] = 0));
      }
      const l = e.morphTargetsRelative ? 1 : 1 - s;
      n.getUniforms().setValue(this.gl, "morphTargetBaseInfluence", l),
        n
          .getUniforms()
          .setValue(this.gl, "morphTargetInfluences", this.morphInfluences);
    }
  }
}
class oo {
  constructor(t, e, i, n) {
    (this.gl = t),
      (this.geometries = e),
      (this.attributes = i),
      (this.info = n),
      (this.updateMap = new WeakMap()),
      (this.onInstancedMeshDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onInstancedMeshDispose),
          this.attributes.remove(e.instanceMatrix),
          null !== e.instanceColor && this.attributes.remove(e.instanceColor);
      });
  }
  update(t) {
    const e = this.info.render.frame,
      i = t.geometry,
      n = this.geometries.get(t, i);
    return (
      this.updateMap.get(n) !== e &&
        (this.geometries.update(n), this.updateMap.set(n, e)),
      t.isInstancedMesh &&
        (!1 === t.hasEventListener("dispose", this.onInstancedMeshDispose) &&
          t.addEventListener("dispose", this.onInstancedMeshDispose),
        this.attributes.update(t.instanceMatrix, this.gl.ARRAY_BUFFER),
        null !== t.instanceColor &&
          this.attributes.update(t.instanceColor, this.gl.ARRAY_BUFFER)),
      n
    );
  }
  dispose() {
    this.updateMap = new WeakMap();
  }
}
const ao = new Ge(),
  so = new to(),
  lo = new (class extends Ge {
    constructor(t = null, e = 1, i = 1, n = 1) {
      super(null),
        (this.isDataTexture3D = !0),
        (this.image = {
          data: t,
          width: e,
          height: i,
          depth: n,
        }),
        (this.magFilter = Ut),
        (this.minFilter = Ut),
        (this.wrapR = Bt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1),
        (this.needsUpdate = !0);
    }
  })(),
  uo = new ir(),
  co = [],
  ho = [],
  po = new Float32Array(16),
  fo = new Float32Array(9),
  go = new Float32Array(4);
function mo(t, e, i) {
  const n = t[0];
  if (n <= 0 || n > 0) return t;
  const r = e * i;
  let o = co[r];
  if ((void 0 === o && ((o = new Float32Array(r)), (co[r] = o)), 0 !== e)) {
    n.toArray(o, 0);
    for (let n = 1, r = 0; n !== e; ++n) (r += i), t[n].toArray(o, r);
  }
  return o;
}
function yo(t, e) {
  if (t.length !== e.length) return !1;
  for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
  return !0;
}
function vo(t, e) {
  for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
}
function bo(t, e) {
  let i = ho[e];
  void 0 === i && ((i = new Int32Array(e)), (ho[e] = i));
  for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
  return i;
}
function xo(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
}
function _o(t, e) {
  const i = this.cache;
  if (void 0 !== e.x)
    (i[0] === e.x && i[1] === e.y) ||
      (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
  else {
    if (yo(i, e)) return;
    t.uniform2fv(this.addr, e), vo(i, e);
  }
}
function So(t, e) {
  const i = this.cache;
  if (void 0 !== e.x)
    (i[0] === e.x && i[1] === e.y && i[2] === e.z) ||
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z));
  else if (void 0 !== e.r)
    (i[0] === e.r && i[1] === e.g && i[2] === e.b) ||
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (i[0] = e.r),
      (i[1] = e.g),
      (i[2] = e.b));
  else {
    if (yo(i, e)) return;
    t.uniform3fv(this.addr, e), vo(i, e);
  }
}
function Mo(t, e) {
  const i = this.cache;
  if (void 0 !== e.x)
    (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) ||
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z),
      (i[3] = e.w));
  else {
    if (yo(i, e)) return;
    t.uniform4fv(this.addr, e), vo(i, e);
  }
}
function Co(t, e) {
  const i = this.cache,
    n = e.elements;
  if (void 0 === n) {
    if (yo(i, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), vo(i, e);
  } else {
    if (yo(i, n)) return;
    go.set(n), t.uniformMatrix2fv(this.addr, !1, go), vo(i, n);
  }
}
function wo(t, e) {
  const i = this.cache,
    n = e.elements;
  if (void 0 === n) {
    if (yo(i, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), vo(i, e);
  } else {
    if (yo(i, n)) return;
    fo.set(n), t.uniformMatrix3fv(this.addr, !1, fo), vo(i, n);
  }
}
function Ao(t, e) {
  const i = this.cache,
    n = e.elements;
  if (void 0 === n) {
    if (yo(i, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), vo(i, e);
  } else {
    if (yo(i, n)) return;
    po.set(n), t.uniformMatrix4fv(this.addr, !1, po), vo(i, n);
  }
}
function Eo(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
}
function Do(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform2iv(this.addr, e), vo(i, e));
}
function To(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform3iv(this.addr, e), vo(i, e));
}
function Po(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform4iv(this.addr, e), vo(i, e));
}
function Lo(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e));
}
function Io(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform2uiv(this.addr, e), vo(i, e));
}
function No(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform3uiv(this.addr, e), vo(i, e));
}
function Ro(t, e) {
  const i = this.cache;
  yo(i, e) || (t.uniform4uiv(this.addr, e), vo(i, e));
}
function Oo(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.safeSetTexture2D(e || ao, r);
}
function Fo(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture3D(e || lo, r);
}
function zo(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.safeSetTextureCube(e || uo, r);
}
function ko(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture2DArray(e || so, r);
}
function Bo(t, e) {
  t.uniform1fv(this.addr, e);
}
function Go(t, e) {
  const i = mo(e, this.size, 2);
  t.uniform2fv(this.addr, i);
}
function Uo(t, e) {
  const i = mo(e, this.size, 3);
  t.uniform3fv(this.addr, i);
}
function jo(t, e) {
  const i = mo(e, this.size, 4);
  t.uniform4fv(this.addr, i);
}
function Ho(t, e) {
  const i = mo(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, i);
}
function Vo(t, e) {
  const i = mo(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, i);
}
function Wo(t, e) {
  const i = mo(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, i);
}
function qo(t, e) {
  t.uniform1iv(this.addr, e);
}
function Yo(t, e) {
  t.uniform2iv(this.addr, e);
}
function Xo(t, e) {
  t.uniform3iv(this.addr, e);
}
function Qo(t, e) {
  t.uniform4iv(this.addr, e);
}
function Zo(t, e) {
  t.uniform1uiv(this.addr, e);
}
function Jo(t, e) {
  t.uniform2uiv(this.addr, e);
}
function Ko(t, e) {
  t.uniform3uiv(this.addr, e);
}
function $o(t, e) {
  t.uniform4uiv(this.addr, e);
}
function ta(t, e, i) {
  const n = e.length,
    r = bo(i, n);
  t.uniform1iv(this.addr, r);
  for (let o = 0; o !== n; ++o) i.safeSetTexture2D(e[o] || ao, r[o]);
}
function ea(t, e, i) {
  const n = e.length,
    r = bo(i, n);
  t.uniform1iv(this.addr, r);
  for (let o = 0; o !== n; ++o) i.setTexture3D(e[o] || lo, r[o]);
}
function ia(t, e, i) {
  const n = e.length,
    r = bo(i, n);
  t.uniform1iv(this.addr, r);
  for (let o = 0; o !== n; ++o) i.safeSetTextureCube(e[o] || uo, r[o]);
}
function na(t, e, i) {
  const n = e.length,
    r = bo(i, n);
  t.uniform1iv(this.addr, r);
  for (let o = 0; o !== n; ++o) i.setTexture2DArray(e[o] || so, r[o]);
}
class ra {
  constructor(t, e, i) {
    (this.id = t),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return xo;
          case 35664:
            return _o;
          case 35665:
            return So;
          case 35666:
            return Mo;
          case 35674:
            return Co;
          case 35675:
            return wo;
          case 35676:
            return Ao;
          case 5124:
          case 35670:
            return Eo;
          case 35667:
          case 35671:
            return Do;
          case 35668:
          case 35672:
            return To;
          case 35669:
          case 35673:
            return Po;
          case 5125:
            return Lo;
          case 36294:
            return Io;
          case 36295:
            return No;
          case 36296:
            return Ro;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Oo;
          case 35679:
          case 36299:
          case 36307:
            return Fo;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return zo;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return ko;
        }
      })(e.type));
  }
}
class oa {
  constructor(t, e, i) {
    (this.id = t),
      (this.addr = i),
      (this.cache = []),
      (this.size = e.size),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return Bo;
          case 35664:
            return Go;
          case 35665:
            return Uo;
          case 35666:
            return jo;
          case 35674:
            return Ho;
          case 35675:
            return Vo;
          case 35676:
            return Wo;
          case 5124:
          case 35670:
            return qo;
          case 35667:
          case 35671:
            return Yo;
          case 35668:
          case 35672:
            return Xo;
          case 35669:
          case 35673:
            return Qo;
          case 5125:
            return Zo;
          case 36294:
            return Jo;
          case 36295:
            return Ko;
          case 36296:
            return $o;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return ta;
          case 35679:
          case 36299:
          case 36307:
            return ea;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return ia;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return na;
        }
      })(e.type));
  }
  updateCache(t) {
    const e = this.cache;
    t instanceof Float32Array &&
      e.length !== t.length &&
      (this.cache = new Float32Array(t.length)),
      vo(e, t);
  }
}
class aa {
  constructor(t) {
    (this.id = t), (this.seq = []), (this.map = {});
  }
  setValue(t, e, i) {
    const n = this.seq;
    for (let r = 0, o = n.length; r !== o; ++r) {
      const o = n[r];
      o.setValue(t, e[o.id], i);
    }
  }
}
const sa = /(\w+)(\])?(\[|\.)?/g;
function la(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function ua(t, e, i) {
  const n = t.name,
    r = n.length;
  for (sa.lastIndex = 0; ; ) {
    const o = sa.exec(n),
      a = sa.lastIndex;
    let s = o[1];
    const l = "]" === o[2],
      u = o[3];
    if ((l && (s |= 0), void 0 === u || ("[" === u && a + 2 === r))) {
      la(i, void 0 === u ? new ra(s, t, e) : new oa(s, t, e));
      break;
    }
    {
      let t = i.map[s];
      void 0 === t && ((t = new aa(s)), la(i, t)), (i = t);
    }
  }
}
class ca {
  constructor(t, e) {
    (this.seq = []), (this.map = {});
    const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      const i = t.getActiveUniform(e, n);
      ua(i, t.getUniformLocation(e, i.name), this);
    }
  }
}
function ha(t, e, i) {
  const n = t.createShader(e);
  if (
    (t.shaderSource(n, i),
    t.compileShader(n),
    !t.getShaderParameter(n, t.COMPILE_STATUS))
  )
    throw t.getShaderInfoLog(n);
  return n;
}
(ca.prototype.setValue = function (t, e, i, n) {
  const r = this.map[e];
  void 0 !== r && r.setValue(t, i, n);
}),
  (ca.prototype.setOptional = function (t, e, i) {
    const n = e[i];
    void 0 !== n && this.setValue(t, i, n);
  }),
  (ca.upload = function (t, e, i, n) {
    for (let r = 0, o = e.length; r !== o; ++r) {
      const o = e[r],
        a = i[o.id];
      !1 !== a.needsUpdate && o.setValue(t, a.value, n);
    }
  }),
  (ca.seqWithValue = function (t, e) {
    const i = [];
    for (let n = 0, r = t.length; n !== r; ++n) {
      const r = t[n];
      r.id in e && i.push(r);
    }
    return i;
  });
let pa = 0;
function da(t) {
  switch (t) {
    case ce:
      return ["Linear", "( value )"];
    case he:
      return ["sRGB", "( value )"];
    case de:
      return ["RGBE", "( value )"];
    case ge:
      return ["RGBM", "( value, 7.0 )"];
    case me:
      return ["RGBM", "( value, 16.0 )"];
    case ye:
      return ["RGBD", "( value, 256.0 )"];
    case pe:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case fe:
      return ["LogLuv", "( value )"];
    default:
      return ["Linear", "( value )"];
  }
}
function fa(t, e, i) {
  const n = t.getShaderParameter(e, t.COMPILE_STATUS),
    r = t.getShaderInfoLog(e).trim();
  return n && "" === r
    ? ""
    : i.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (t) {
          const e = t.split("\n");
          for (let i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
          return e.join("\n");
        })(t.getShaderSource(e));
}
function ga(t, e) {
  const i = da(e);
  return (
    "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
  );
}
function ma(t, e) {
  const i = da(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
}
function ya(t, e) {
  let i;
  switch (e) {
    case 1:
    default:
      i = "Linear";
      break;
    case 2:
      i = "Reinhard";
      break;
    case 3:
      i = "OptimizedCineon";
      break;
    case 4:
      i = "ACESFilmic";
      break;
    case 5:
      i = "Custom";
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  );
}
function va(t) {
  return "" !== t;
}
function ba(t, e) {
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function xa(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const _a = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Sa(t) {
  return t.replace(_a, Ma);
}
function Ma(t, e) {
  const i = gr[e];
  if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
  return Sa(i);
}
const Ca =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  wa =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Aa(t) {
  return t.replace(wa, Da).replace(Ca, Ea);
}
function Ea(t, e, i, n) {
  return Da(t, e, i, n);
}
function Da(t, e, i, n) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(i); o++)
    r += n
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function Ta(t) {
  let e =
    "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
  return (
    "highp" === t.precision
      ? (e += "\n#define HIGH_PRECISION")
      : "mediump" === t.precision
      ? (e += "\n#define MEDIUM_PRECISION")
      : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
    e
  );
}
class Pa {
  constructor(t, e, i, n) {
    (this.renderer = t),
      (this.cacheKey = e),
      (this.parameters = i),
      (this.bindingStates = n),
      (this.gl = t.getContext());
    const r = i.defines;
    let o = i.vertexShader,
      a = i.fragmentShader;
    const s = (function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          1 === t.shadowMapType
            ? (e = "SHADOWMAP_TYPE_PCF")
            : 2 === t.shadowMapType
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      })(i),
      l = (function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case Ot:
            case Ft:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case zt:
            case 307:
              e = "ENVMAP_TYPE_CUBE_UV";
          }
        return e;
      })(i),
      u = (function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (t.envMap)
          switch (t.envMapMode) {
            case Ft:
            case 307:
              e = "ENVMAP_MODE_REFRACTION";
          }
        return e;
      })(i),
      c = (function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case 0:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case 1:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case 2:
              e = "ENVMAP_BLENDING_ADD";
          }
        return e;
      })(i),
      h = t.gammaFactor > 0 ? t.gammaFactor : 1,
      p = i.isWebGL2
        ? ""
        : (function (t) {
            return [
              t.extensionDerivatives ||
              t.envMapCubeUV ||
              t.bumpMap ||
              t.tangentSpaceNormalMap ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              "physical" === t.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
              t.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter(va)
              .join("\n");
          })(i),
      d = (function (t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          !1 !== n && e.push("#define " + i + " " + n);
        }
        return e.join("\n");
      })(r),
      f = this.gl.createProgram();
    let g,
      m,
      y = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
    i.isRawShaderMaterial
      ? ((g = [d].filter(va).join("\n")),
        g.length > 0 && (g += "\n"),
        (m = [p, d].filter(va).join("\n")),
        m.length > 0 && (m += "\n"))
      : ((g = [
          Ta(i),
          "#define SHADER_NAME " + i.shaderName,
          d,
          i.instancing ? "#define USE_INSTANCING" : "",
          i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          "#define GAMMA_FACTOR " + h,
          "#define MAX_BONES " + i.maxBones,
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
          i.map ? "#define USE_MAP" : "",
          i.envMap ? "#define USE_ENVMAP" : "",
          i.envMap ? "#define " + u : "",
          i.lightMap ? "#define USE_LIGHTMAP" : "",
          i.aoMap ? "#define USE_AOMAP" : "",
          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          i.bumpMap ? "#define USE_BUMPMAP" : "",
          i.normalMap ? "#define USE_NORMALMAP" : "",
          i.normalMap && i.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          i.normalMap && i.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          i.displacementMap && i.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          i.specularMap ? "#define USE_SPECULARMAP" : "",
          i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
          i.alphaMap ? "#define USE_ALPHAMAP" : "",
          i.transmission ? "#define USE_TRANSMISSION" : "",
          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          i.vertexTangents ? "#define USE_TANGENT" : "",
          i.vertexColors ? "#define USE_COLOR" : "",
          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          i.vertexUvs ? "#define USE_UV" : "",
          i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          i.flatShading ? "#define FLAT_SHADED" : "",
          i.skinning ? "#define USE_SKINNING" : "",
          i.useVertexTexture ? "#define BONE_TEXTURE" : "",
          i.morphTargets ? "#define USE_MORPHTARGETS" : "",
          i.morphNormals && !1 === i.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          i.morphTargets && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
          i.morphTargets && i.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
            : "",
          i.doubleSided ? "#define DOUBLE_SIDED" : "",
          i.flipSided ? "#define FLIP_SIDED" : "",
          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          i.shadowMapEnabled ? "#define " + s : "",
          i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(va)
          .join("\n")),
        (m = [
          p,
          Ta(i),
          "#define SHADER_NAME " + i.shaderName,
          d,
          "#define GAMMA_FACTOR " + h,
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
          i.map ? "#define USE_MAP" : "",
          i.matcap ? "#define USE_MATCAP" : "",
          i.envMap ? "#define USE_ENVMAP" : "",
          i.envMap ? "#define " + l : "",
          i.envMap ? "#define " + u : "",
          i.envMap ? "#define " + c : "",
          i.lightMap ? "#define USE_LIGHTMAP" : "",
          i.aoMap ? "#define USE_AOMAP" : "",
          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          i.bumpMap ? "#define USE_BUMPMAP" : "",
          i.normalMap ? "#define USE_NORMALMAP" : "",
          i.normalMap && i.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          i.normalMap && i.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          i.clearcoat ? "#define USE_CLEARCOAT" : "",
          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          i.specularMap ? "#define USE_SPECULARMAP" : "",
          i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
          i.alphaMap ? "#define USE_ALPHAMAP" : "",
          i.alphaTest ? "#define USE_ALPHATEST" : "",
          i.sheen ? "#define USE_SHEEN" : "",
          i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          i.transmission ? "#define USE_TRANSMISSION" : "",
          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          i.vertexTangents ? "#define USE_TANGENT" : "",
          i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          i.vertexUvs ? "#define USE_UV" : "",
          i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          i.gradientMap ? "#define USE_GRADIENTMAP" : "",
          i.flatShading ? "#define FLAT_SHADED" : "",
          i.doubleSided ? "#define DOUBLE_SIDED" : "",
          i.flipSided ? "#define FLIP_SIDED" : "",
          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          i.shadowMapEnabled ? "#define " + s : "",
          i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          (i.extensionShaderTextureLOD || i.envMap) &&
          i.rendererExtensionShaderTextureLod
            ? "#define TEXTURE_LOD_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          0 !== i.toneMapping ? "#define TONE_MAPPING" : "",
          0 !== i.toneMapping ? gr.tonemapping_pars_fragment : "",
          0 !== i.toneMapping ? ya("toneMapping", i.toneMapping) : "",
          i.dithering ? "#define DITHERING" : "",
          i.format === $t ? "#define OPAQUE" : "",
          gr.encodings_pars_fragment,
          i.map ? ga("mapTexelToLinear", i.mapEncoding) : "",
          i.matcap ? ga("matcapTexelToLinear", i.matcapEncoding) : "",
          i.envMap ? ga("envMapTexelToLinear", i.envMapEncoding) : "",
          i.emissiveMap
            ? ga("emissiveMapTexelToLinear", i.emissiveMapEncoding)
            : "",
          i.specularColorMap
            ? ga("specularColorMapTexelToLinear", i.specularColorMapEncoding)
            : "",
          i.sheenColorMap
            ? ga("sheenColorMapTexelToLinear", i.sheenColorMapEncoding)
            : "",
          i.lightMap ? ga("lightMapTexelToLinear", i.lightMapEncoding) : "",
          ma("linearToOutputTexel", i.outputEncoding),
          i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
          "\n",
        ]
          .filter(va)
          .join("\n"))),
      (o = Sa(o)),
      (o = ba(o, i)),
      (o = xa(o, i)),
      (a = Sa(a)),
      (a = ba(a, i)),
      (a = xa(a, i)),
      (o = Aa(o)),
      (a = Aa(a)),
      i.isWebGL2 &&
        !0 !== i.isRawShaderMaterial &&
        ((y = "#version 300 es\n"),
        (g =
          [
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          g),
        (m =
          [
            "#define varying in",
            i.glslVersion === _e ? "" : "out highp vec4 pc_fragColor;",
            i.glslVersion === _e ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          m));
    const v = y + g + o,
      b = y + m + a,
      x = ha(this.gl, this.gl.VERTEX_SHADER, v),
      _ = ha(this.gl, this.gl.FRAGMENT_SHADER, b);
    if (
      (this.gl.attachShader(f, x),
      this.gl.attachShader(f, _),
      void 0 !== i.index0AttributeName
        ? this.gl.bindAttribLocation(f, 0, i.index0AttributeName)
        : !0 === i.morphTargets && this.gl.bindAttribLocation(f, 0, "position"),
      this.gl.linkProgram(f),
      t.debug.checkShaderErrors)
    ) {
      const t = this.gl.getProgramInfoLog(f).trim(),
        e = this.gl.getShaderInfoLog(x).trim(),
        i = this.gl.getShaderInfoLog(_).trim();
      let n = !0,
        r = !0;
      if (!1 === this.gl.getProgramParameter(f, this.gl.LINK_STATUS)) {
        n = !1;
        const e = fa(this.gl, x, "vertex"),
          i = fa(this.gl, _, "fragment");
        console.error(
          "@dp/gis-engine: WebGLProgram: Shader Error " +
            this.gl.getError() +
            " - VALIDATE_STATUS " +
            this.gl.getProgramParameter(f, this.gl.VALIDATE_STATUS) +
            "\n\nProgram Info Log: " +
            t +
            "\n" +
            e +
            "\n" +
            i
        );
      } else "" !== t || ("" !== e && "" !== i) || (r = !1);
      r &&
        (this.diagnostics = {
          runnable: n,
          programLog: t,
          vertexShader: {
            log: e,
            prefix: g,
          },
          fragmentShader: {
            log: i,
            prefix: m,
          },
        });
    }
    this.gl.deleteShader(x),
      this.gl.deleteShader(_),
      (this.name = i.shaderName),
      (this.id = pa++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = f),
      (this.vertexShader = x),
      (this.fragmentShader = _),
      this.cachedUniforms,
      this.cachedAttributes;
  }
  getUniforms() {
    return (
      void 0 === this.cachedUniforms &&
        (this.cachedUniforms = new ca(this.gl, this.program)),
      this.cachedUniforms
    );
  }
  getAttributes() {
    return (
      void 0 === this.cachedAttributes &&
        (this.cachedAttributes = (function (t, e) {
          const i = {},
            n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
          for (let r = 0; r < n; r++) {
            const n = t.getActiveAttrib(e, r),
              o = n.name;
            let a = 1;
            n.type === t.FLOAT_MAT2 && (a = 2),
              n.type === t.FLOAT_MAT3 && (a = 3),
              n.type === t.FLOAT_MAT4 && (a = 4),
              (i[o] = {
                type: n.type,
                location: t.getAttribLocation(e, o),
                locationSize: a,
              });
          }
          return i;
        })(this.gl, this.program)),
      this.cachedAttributes
    );
  }
  destroy() {
    this.bindingStates.releaseStatesOfProgram(this),
      this.gl.deleteProgram(this.program),
      (this.program = void 0);
  }
}
class La {
  constructor(t, e, i, n, r, o, a) {
    (this.renderer = t),
      (this.cubeuvmaps = e),
      (this.cubemaps = i),
      (this.extensions = n),
      (this.capabilities = r),
      (this.bindingStates = o),
      (this.clipping = a),
      (this.programs = []),
      (this.isWebGL2 = r.isWebGL2),
      (this.logarithmicDepthBuffer = r.logarithmicDepthBuffer),
      (this.floatVertexTextures = r.floatVertexTextures),
      (this.maxVertexUniforms = r.maxVertexUniforms),
      (this.vertexTextures = r.vertexTextures),
      (this.precision = r.precision),
      (this.shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite",
      }),
      (this.parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoat",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "alphaTest",
        "combine",
        "vertexColors",
        "vertexAlphas",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "morphTargetsCount",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        "physicallyCorrectLights",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "format",
        "specularIntensityMap",
        "specularColorMap",
        "specularColorMapEncoding",
        "transmission",
        "transmissionMap",
        "thicknessMap",
        "sheen",
        "sheenColorMap",
        "sheenColorMapEncoding",
        "sheenRoughnessMap",
      ]);
  }
  getMaxBones(t) {
    const e = t.skeleton.bones;
    if (this.floatVertexTextures) return 1024;
    {
      const t = this.maxVertexUniforms,
        i = Math.floor((t - 20) / 4),
        n = Math.min(i, e.length);
      return n < e.length ? (e.length, 0) : n;
    }
  }
  getTextureEncodingFromMap(t) {
    let e;
    return (
      (e =
        t && t.isTexture
          ? t.encoding
          : t && t.isWebGLRenderTarget
          ? t.texture.encoding
          : ce),
      e
    );
  }
  getParameters(t, e, i, n, r) {
    const o = n.fog,
      a = t.isMeshStandardMaterial ? n.environment : null,
      s = (t.isMeshStandardMaterial ? this.cubeuvmaps : this.cubemaps).get(
        t.envMap || a
      ),
      l = this.shaderIDs[t.type],
      u = r.isSkinnedMesh ? this.getMaxBones(r) : 0;
    let c, h;
    if (
      (null !== t.precision &&
        ((this.precision = this.capabilities.getMaxPrecision(t.precision)),
        this.precision !== t.precision && (t.precision, this.precision)),
      l)
    ) {
      const t = mr[l];
      (c = t.vertexShader), (h = t.fragmentShader);
    } else (c = t.vertexShader), (h = t.fragmentShader);
    const p = this.renderer.getRenderTarget(),
      d = t.alphaTest > 0,
      f = t.clearcoat > 0;
    return {
      isWebGL2: this.isWebGL2,
      shaderID: l,
      shaderName: t.type,
      vertexShader: c,
      fragmentShader: h,
      defines: t.defines,
      isRawShaderMaterial: !0 === t.isRawShaderMaterial,
      glslVersion: t.glslVersion,
      precision: this.precision,
      instancing: !0 === r.isInstancedMesh,
      instancingColor: !0 === r.isInstancedMesh && null !== r.instanceColor,
      supportsVertexTextures: this.vertexTextures,
      outputEncoding:
        null !== p
          ? this.getTextureEncodingFromMap(p.texture)
          : this.renderer.outputEncoding,
      map: !!t.map,
      mapEncoding: this.getTextureEncodingFromMap(t.map),
      matcap: !!t.matcap,
      matcapEncoding: this.getTextureEncodingFromMap(t.matcap),
      envMap: !!s,
      envMapMode: s && s.mapping,
      envMapEncoding: this.getTextureEncodingFromMap(s),
      envMapCubeUV: !!s && (s.mapping === zt || 307 === s.mapping),
      lightMap: !!t.lightMap,
      lightMapEncoding: this.getTextureEncodingFromMap(t.lightMap),
      aoMap: !!t.aoMap,
      emissiveMap: !!t.emissiveMap,
      emissiveMapEncoding: this.getTextureEncodingFromMap(t.emissiveMap),
      bumpMap: !!t.bumpMap,
      normalMap: !!t.normalMap,
      objectSpaceNormalMap: 1 === t.normalMapType,
      tangentSpaceNormalMap: 0 === t.normalMapType,
      clearcoat: f,
      clearcoatMap: f && !!t.clearcoatMap,
      clearcoatRoughnessMap: f && !!t.clearcoatRoughnessMap,
      clearcoatNormalMap: f && !!t.clearcoatNormalMap,
      displacementMap: !!t.displacementMap,
      roughnessMap: !!t.roughnessMap,
      metalnessMap: !!t.metalnessMap,
      specularMap: !!t.specularMap,
      specularIntensityMap: !!t.specularIntensityMap,
      specularColorMap: !!t.specularColorMap,
      specularColorMapEncoding: this.getTextureEncodingFromMap(
        t.specularColorMap
      ),
      alphaMap: !!t.alphaMap,
      alphaTest: d,
      gradientMap: !!t.gradientMap,
      sheen: t.sheen > 0,
      sheenColorMap: !!t.sheenColorMap,
      sheenColorMapEncoding: this.getTextureEncodingFromMap(t.sheenColorMap),
      sheenRoughnessMap: !!t.sheenRoughnessMap,
      transmission: t.transmission > 0,
      transmissionMap: !!t.transmissionMap,
      thicknessMap: !!t.thicknessMap,
      combine: t.combine,
      vertexTangents:
        !!t.normalMap && !!r.geometry && !!r.geometry.attributes.tangent,
      vertexColors: t.vertexColors,
      vertexAlphas:
        !0 === t.vertexColors &&
        !!r.geometry &&
        !!r.geometry.attributes.color &&
        4 === r.geometry.attributes.color.itemSize,
      vertexUvs:
        !!t.map ||
        !!t.bumpMap ||
        !!t.normalMap ||
        !!t.specularMap ||
        !!t.alphaMap ||
        !!t.emissiveMap ||
        !!t.roughnessMap ||
        !!t.metalnessMap ||
        !!t.clearcoatMap ||
        !!t.clearcoatRoughnessMap ||
        !!t.clearcoatNormalMap ||
        !!t.displacementMap ||
        !!t.transmissionMap ||
        !!t.thicknessMap ||
        !!t.specularIntensityMap ||
        !!t.specularColorMap ||
        !!t.sheenColorMap ||
        t.sheenRoughnessMap,
      uvsVertexOnly: !(
        t.map ||
        t.bumpMap ||
        t.normalMap ||
        t.specularMap ||
        t.alphaMap ||
        t.emissiveMap ||
        t.roughnessMap ||
        t.metalnessMap ||
        t.clearcoatNormalMap ||
        t.transmission > 0 ||
        t.transmissionMap ||
        t.thicknessMap ||
        t.specularIntensityMap ||
        t.specularColorMap ||
        t.sheen > 0 ||
        t.sheenColorMap ||
        t.sheenRoughnessMap ||
        !t.displacementMap
      ),
      fog: !!o,
      useFog: t.fog,
      fogExp2: o && o.isFogExp2,
      flatShading: !!t.flatShading,
      sizeAttenuation: t.sizeAttenuation,
      logarithmicDepthBuffer: this.logarithmicDepthBuffer,
      skinning: !0 === r.isSkinnedMesh && u > 0,
      maxBones: u,
      useVertexTexture: this.floatVertexTextures,
      morphTargets: !!r.geometry && !!r.geometry.morphAttributes.position,
      morphNormals: !!r.geometry && !!r.geometry.morphAttributes.normal,
      morphTargetsCount:
        r.geometry && r.geometry.morphAttributes.position
          ? r.geometry.morphAttributes.position.length
          : 0,
      numDirLights: e.directional.length,
      numPointLights: e.point.length,
      numSpotLights: e.spot.length,
      numRectAreaLights: e.rectArea.length,
      numHemiLights: e.hemi.length,
      numDirLightShadows: e.directionalShadowMap.length,
      numPointLightShadows: e.pointShadowMap.length,
      numSpotLightShadows: e.spotShadowMap.length,
      numClippingPlanes: this.clipping.numPlanes,
      numClipIntersection: this.clipping.numIntersection,
      format: t.format,
      dithering: t.dithering,
      shadowMapEnabled: this.renderer.shadowMap.enabled && i.length > 0,
      shadowMapType: this.renderer.shadowMap.type,
      toneMapping: t.toneMapped ? this.renderer.toneMapping : 0,
      physicallyCorrectLights: this.renderer.physicallyCorrectLights,
      premultipliedAlpha: t.premultipliedAlpha,
      doubleSided: t.side === xt,
      flipSided: t.side === bt,
      depthPacking: void 0 !== t.depthPacking && t.depthPacking,
      index0AttributeName: t.index0AttributeName,
      extensionDerivatives: t.extensions && t.extensions.derivatives,
      extensionFragDepth: t.extensions && t.extensions.fragDepth,
      extensionDrawBuffers: t.extensions && t.extensions.drawBuffers,
      extensionShaderTextureLOD: t.extensions && t.extensions.shaderTextureLOD,
      rendererExtensionFragDepth:
        this.isWebGL2 || this.extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers:
        this.isWebGL2 || this.extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod:
        this.isWebGL2 || this.extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: t.customProgramCacheKey(),
    };
  }
  getProgramCacheKey(t) {
    const e = [];
    if (
      (t.shaderID
        ? e.push(t.shaderID)
        : (e.push(Oe(t.fragmentShader)), e.push(Oe(t.vertexShader))),
      void 0 !== t.defines)
    )
      for (const i in t.defines) e.push(i), e.push(t.defines[i]);
    if (!1 === t.isRawShaderMaterial) {
      for (let i = 0; i < this.parameterNames.length; i++)
        e.push(t[this.parameterNames[i]]);
      e.push(this.renderer.outputEncoding), e.push(this.renderer.gammaFactor);
    }
    return e.push(t.customProgramCacheKey), e.join();
  }
  getUniforms(t) {
    const e = this.shaderIDs[t.type];
    let i;
    if (e) {
      const t = mr[e];
      i = Zn.clone(t.uniforms);
    } else i = t.uniforms;
    return i;
  }
  acquireProgram(t, e) {
    let i;
    for (let n = 0, r = this.programs.length; n < r; n++) {
      const t = this.programs[n];
      if (t.cacheKey === e) {
        (i = t), ++i.usedTimes;
        break;
      }
    }
    return (
      void 0 === i &&
        ((i = new Pa(this.renderer, e, t, this.bindingStates)),
        this.programs.push(i)),
      i
    );
  }
  releaseProgram(t) {
    if (0 == --t.usedTimes) {
      const e = this.programs.indexOf(t);
      (this.programs[e] = this.programs[this.programs.length - 1]),
        this.programs.pop(),
        t.destroy();
    }
  }
}
class Ia {
  constructor() {
    this.properties = new WeakMap();
  }
  get(t) {
    let e = this.properties.get(t);
    return void 0 === e && ((e = {}), this.properties.set(t, e)), e;
  }
  remove(t) {
    this.properties.delete(t);
  }
  update(t, e, i) {
    this.properties.get(t)[e] = i;
  }
  dispose() {
    this.properties = new WeakMap();
  }
}
function Na(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.program !== e.program
    ? t.program.id - e.program.id
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function Ra(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
class Oa {
  constructor(t) {
    (this.properties = t),
      (this.renderItems = []),
      (this.renderItemsIndex = 0),
      (this.opaque = []),
      (this.transmissive = []),
      (this.transparent = []),
      (this.defaultProgram = {
        id: -1,
      });
  }
  init() {
    (this.renderItemsIndex = 0),
      (this.opaque.length = 0),
      (this.transmissive.length = 0),
      (this.transparent.length = 0);
  }
  getNextRenderItem(t, e, i, n, r, o) {
    let a = this.renderItems[this.renderItemsIndex];
    const s = this.properties.get(i);
    return (
      void 0 === a
        ? ((a = {
            id: t.id,
            object: t,
            geometry: e,
            material: i,
            program: s.program || this.defaultProgram,
            groupOrder: n,
            renderOrder: t.renderOrder,
            z: r,
            group: o,
          }),
          (this.renderItems[this.renderItemsIndex] = a))
        : ((a.id = t.id),
          (a.object = t),
          (a.geometry = e),
          (a.material = i),
          (a.program = s.program || this.defaultProgram),
          (a.groupOrder = n),
          (a.renderOrder = t.renderOrder),
          (a.z = r),
          (a.group = o)),
      this.renderItemsIndex++,
      a
    );
  }
  push(t, e, i, n, r, o) {
    const a = this.getNextRenderItem(t, e, i, n, r, o);
    i.transmission > 0
      ? this.transmissive.push(a)
      : !0 === i.transparent
      ? this.transparent.push(a)
      : this.opaque.push(a);
  }
  unshift(t, e, i, n, r, o) {
    const a = this.getNextRenderItem(t, e, i, n, r, o);
    i.transmission > 0
      ? this.transmissive.unshift(a)
      : !0 === i.transparent
      ? this.transparent.unshift(a)
      : this.opaque.unshift(a);
  }
  sort(t, e) {
    this.opaque.length > 1 && this.opaque.sort(t || Na),
      this.transmissive.length > 1 && this.transmissive.sort(e || Ra),
      this.transparent.length > 1 && this.transparent.sort(e || Ra);
  }
  finish() {
    for (
      let t = this.renderItemsIndex, e = this.renderItems.length;
      t < e;
      t++
    ) {
      const e = this.renderItems[t];
      if (null === e.id) break;
      (e.id = null),
        (e.object = null),
        (e.geometry = null),
        (e.material = null),
        (e.program = null),
        (e.group = null);
    }
  }
}
class Fa {
  constructor(t) {
    (this.properties = t), (this.lists = new WeakMap());
  }
  get(t, e) {
    let i;
    return (
      !1 === this.lists.has(t)
        ? ((i = new Oa(this.properties)), this.lists.set(t, [i]))
        : e >= this.lists.get(t).length
        ? ((i = new Oa(this.properties)), this.lists.get(t).push(i))
        : (i = this.lists.get(t)[e]),
      i
    );
  }
  dispose() {
    this.lists = new WeakMap();
  }
}
class za {
  constructor() {
    this.lights = {};
  }
  get(t) {
    if (void 0 !== this.lights[t.id]) return this.lights[t.id];
    let e;
    switch (t.type) {
      case "DirectionalLight":
        e = {
          direction: new Ye(),
          color: new ln(),
        };
        break;
      case "SpotLight":
        e = {
          position: new Ye(),
          direction: new Ye(),
          color: new ln(),
          distance: 0,
          coneCos: 0,
          penumbraCos: 0,
          decay: 0,
        };
        break;
      case "PointLight":
        e = {
          position: new Ye(),
          color: new ln(),
          distance: 0,
          decay: 0,
        };
        break;
      case "HemisphereLight":
        e = {
          direction: new Ye(),
          skyColor: new ln(),
          groundColor: new ln(),
        };
        break;
      case "RectAreaLight":
        e = {
          color: new ln(),
          position: new Ye(),
          halfWidth: new Ye(),
          halfHeight: new Ye(),
        };
    }
    return (this.lights[t.id] = e), e;
  }
}
let ka = 0;
function Ba(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
class Ga {
  constructor(t, e) {
    (this.extensions = t),
      (this.capabilities = e),
      (this.cache = new za()),
      (this.shadowCache = (function () {
        const t = {};
        return {
          get(e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let i;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                i = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Le(),
                };
                break;
              case "PointLight":
                i = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Le(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (t[e.id] = i), i;
          },
        };
      })()),
      (this.state = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
      });
    for (let i = 0; i < 9; i++) this.state.probe.push(new Ye());
    (this.vector3 = new Ye()),
      (this.matrix4 = new Mi()),
      (this.matrix42 = new Mi());
  }
  setup(t, e) {
    let i = 0,
      n = 0,
      r = 0;
    for (let g = 0; g < 9; g++) this.state.probe[g].set(0, 0, 0);
    let o = 0,
      a = 0,
      s = 0,
      l = 0,
      u = 0,
      c = 0,
      h = 0,
      p = 0;
    t.sort(Ba);
    const d = !0 !== e ? Math.PI : 1;
    for (let g = 0, m = t.length; g < m; g++) {
      const e = t[g],
        f = e.color,
        m = e.intensity,
        y = e.distance,
        v = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
      if (e.isAmbientLight)
        (i += f.r * m * d), (n += f.g * m * d), (r += f.b * m * d);
      else if (e.isLightProbe)
        for (let t = 0; t < 9; t++)
          this.state.probe[t].addScaledVector(e.sh.coefficients[t], m);
      else if (e.isDirectionalLight) {
        const t = this.cache.get(e);
        if (
          (t.color.copy(e.color).multiplyScalar(e.intensity * d), e.castShadow)
        ) {
          const t = e.shadow,
            i = this.shadowCache.get(e);
          (i.shadowBias = t.bias),
            (i.shadowNormalBias = t.normalBias),
            (i.shadowRadius = t.radius),
            (i.shadowMapSize = t.mapSize),
            (this.state.directionalShadow[o] = i),
            (this.state.directionalShadowMap[o] = v),
            (this.state.directionalShadowMatrix[o] = e.shadow.matrix),
            c++;
        }
        (this.state.directional[o] = t), o++;
      } else if (e.isSpotLight) {
        const t = this.cache.get(e);
        if (
          (t.position.setFromMatrixPosition(e.matrixWorld),
          t.color.copy(f).multiplyScalar(m * d),
          (t.distance = y),
          (t.coneCos = Math.cos(e.angle)),
          (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
          (t.decay = e.decay),
          e.castShadow)
        ) {
          const t = e.shadow,
            i = this.shadowCache.get(e);
          (i.shadowBias = t.bias),
            (i.shadowNormalBias = t.normalBias),
            (i.shadowRadius = t.radius),
            (i.shadowMapSize = t.mapSize),
            (this.state.spotShadow[s] = i),
            (this.state.spotShadowMap[s] = v),
            (this.state.spotShadowMatrix[s] = e.shadow.matrix),
            p++;
        }
        (this.state.spot[s] = t), s++;
      } else if (e.isRectAreaLight) {
        const t = this.cache.get(e);
        t.color.copy(f).multiplyScalar(m),
          t.halfWidth.set(0.5 * e.width, 0, 0),
          t.halfHeight.set(0, 0.5 * e.height, 0),
          (this.state.rectArea[l] = t),
          l++;
      } else if (e.isPointLight) {
        const t = this.cache.get(e);
        if (
          (t.color.copy(e.color).multiplyScalar(e.intensity * d),
          (t.distance = e.distance),
          (t.decay = e.decay),
          e.castShadow)
        ) {
          const t = e.shadow,
            i = this.shadowCache.get(e);
          (i.shadowBias = t.bias),
            (i.shadowNormalBias = t.normalBias),
            (i.shadowRadius = t.radius),
            (i.shadowMapSize = t.mapSize),
            (i.shadowCameraNear = t.camera.near),
            (i.shadowCameraFar = t.camera.far),
            (this.state.pointShadow[a] = i),
            (this.state.pointShadowMap[a] = v),
            (this.state.pointShadowMatrix[a] = e.shadow.matrix),
            h++;
        }
        (this.state.point[a] = t), a++;
      } else if (e.isHemisphereLight) {
        const t = this.cache.get(e);
        t.skyColor.copy(e.color).multiplyScalar(m * d),
          t.groundColor.copy(e.groundColor).multiplyScalar(m * d),
          (this.state.hemi[u] = t),
          u++;
      }
    }
    l > 0 &&
      (this.capabilities.isWebGL2 ||
      !0 === this.extensions.has("OES_texture_float_linear")
        ? ((this.state.rectAreaLTC1 = fr.LTC_FLOAT_1),
          (this.state.rectAreaLTC2 = fr.LTC_FLOAT_2))
        : !0 === this.extensions.has("OES_texture_half_float_linear")
        ? ((this.state.rectAreaLTC1 = fr.LTC_HALF_1),
          (this.state.rectAreaLTC2 = fr.LTC_HALF_2))
        : console.error(
            "@dp/gis-engine: WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (this.state.ambient[0] = i),
      (this.state.ambient[1] = n),
      (this.state.ambient[2] = r);
    const f = this.state.hash;
    (f.directionalLength === o &&
      f.pointLength === a &&
      f.spotLength === s &&
      f.rectAreaLength === l &&
      f.hemiLength === u &&
      f.numDirectionalShadows === c &&
      f.numPointShadows === h &&
      f.numSpotShadows === p) ||
      ((this.state.directional.length = o),
      (this.state.spot.length = s),
      (this.state.rectArea.length = l),
      (this.state.point.length = a),
      (this.state.hemi.length = u),
      (this.state.directionalShadow.length = c),
      (this.state.directionalShadowMap.length = c),
      (this.state.pointShadow.length = h),
      (this.state.pointShadowMap.length = h),
      (this.state.spotShadow.length = p),
      (this.state.spotShadowMap.length = p),
      (this.state.directionalShadowMatrix.length = c),
      (this.state.pointShadowMatrix.length = h),
      (this.state.spotShadowMatrix.length = p),
      (f.directionalLength = o),
      (f.pointLength = a),
      (f.spotLength = s),
      (f.rectAreaLength = l),
      (f.hemiLength = u),
      (f.numDirectionalShadows = c),
      (f.numPointShadows = h),
      (f.numSpotShadows = p),
      (this.state.version = ka++));
  }
  setupView(t, e) {
    let i = 0,
      n = 0,
      r = 0,
      o = 0,
      a = 0;
    const s = e.matrixWorldInverse;
    for (let l = 0, u = t.length; l < u; l++) {
      const e = t[l];
      if (e.isDirectionalLight) {
        const t = this.state.directional[i];
        t.direction.setFromMatrixPosition(e.matrixWorld),
          this.vector3.setFromMatrixPosition(e.target.matrixWorld),
          t.direction.sub(this.vector3),
          t.direction.transformDirection(s),
          i++;
      } else if (e.isSpotLight) {
        const t = this.state.spot[r];
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(s),
          t.direction.setFromMatrixPosition(e.matrixWorld),
          this.vector3.setFromMatrixPosition(e.target.matrixWorld),
          t.direction.sub(this.vector3),
          t.direction.transformDirection(s),
          r++;
      } else if (e.isRectAreaLight) {
        const t = this.state.rectArea[o];
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(s),
          this.matrix42.identity(),
          this.matrix4.copy(e.matrixWorld),
          this.matrix4.premultiply(s),
          this.matrix42.extractRotation(this.matrix4),
          t.halfWidth.set(0.5 * e.width, 0, 0),
          t.halfHeight.set(0, 0.5 * e.height, 0),
          t.halfWidth.applyMatrix4(this.matrix42),
          t.halfHeight.applyMatrix4(this.matrix42),
          o++;
      } else if (e.isPointLight) {
        const t = this.state.point[n];
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(s),
          n++;
      } else if (e.isHemisphereLight) {
        const t = this.state.hemi[a];
        t.direction.setFromMatrixPosition(e.matrixWorld),
          t.direction.transformDirection(s),
          t.direction.normalize(),
          a++;
      }
    }
  }
}
class Ua {
  constructor(t, e) {
    (this.extensions = t),
      (this.capabilities = e),
      (this.lights = new Ga(t, e)),
      (this.lightsArray = []),
      (this.shadowsArray = []),
      (this.state = {
        lightsArray: this.lightsArray,
        shadowsArray: this.shadowsArray,
        lights: this.lights,
      });
  }
  init() {
    (this.lightsArray.length = 0), (this.shadowsArray.length = 0);
  }
  pushLight(t) {
    this.lightsArray.push(t);
  }
  pushShadow(t) {
    this.shadowsArray.push(t);
  }
  setupLights(t) {
    this.lights.setup(this.lightsArray, t);
  }
  setupLightsView(t) {
    this.lights.setupView(this.lightsArray, t);
  }
}
class ja {
  constructor(t, e) {
    (this.extensions = t),
      (this.capabilities = e),
      (this.renderStates = new WeakMap());
  }
  get(t, e = 0) {
    let i;
    return (
      !1 === this.renderStates.has(t)
        ? ((i = new Ua(this.extensions, this.capabilities)),
          this.renderStates.set(t, [i]))
        : e >= this.renderStates.get(t).length
        ? ((i = new Ua(this.extensions, this.capabilities)),
          this.renderStates.get(t).push(i))
        : (i = this.renderStates.get(t)[e]),
      i
    );
  }
  dispose() {
    this.renderStates = new WeakMap();
  }
}
class Ha extends hn {
  constructor(t) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = 3200),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    );
  }
}
class Va extends hn {
  constructor(t) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new Ye()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.referencePosition.copy(t.referencePosition),
      (this.nearDistance = t.nearDistance),
      (this.farDistance = t.farDistance),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    );
  }
}
class Wa {
  constructor(t, e, i) {
    (this._renderer = t),
      (this._objects = e),
      (this._capabilities = i),
      (this._frustum = new hr()),
      (this._shadowMapSize = new Le()),
      (this._viewportSize = new Le()),
      (this._viewport = new je()),
      (this._depthMaterial = new Ha({
        depthPacking: 3201,
      })),
      (this._distanceMaterial = new Va()),
      (this._materialCache = {}),
      (this._maxTextureSize = i.maxTextureSize),
      (this.shadowSide = {
        0: bt,
        1: 0,
        2: xt,
      }),
      (this.shadowMaterialVertical = new Jn({
        defines: {
          VSM_SAMPLES: 8,
        },
        uniforms: {
          shadow_pass: {
            value: null,
          },
          resolution: {
            value: new Le(),
          },
          radius: {
            value: 4,
          },
        },
        vertexShader:
          "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",
        fragmentShader:
          "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n\tconst float samples = float( VSM_SAMPLES );\n\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\t// float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\n\t\t#ifdef HORIZONTAL_PASS\n\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n\t\t#else\n\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\n\t\t#endif\n\n\t}\n\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n",
      })),
      (this.shadowMaterialHorizontal = this.shadowMaterialVertical.clone()),
      (this.shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1);
    const n = new En();
    n.setAttribute(
      "position",
      new gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    ),
      (this.fullScreenMesh = new Wn(n, this.shadowMaterialVertical)),
      (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = 1);
  }
  render(t, e, i) {
    if (!1 === this.enabled) return;
    if (!1 === this.autoUpdate && !1 === this.needsUpdate) return;
    if (0 === t.length) return;
    const n = this._renderer.getRenderTarget(),
      r = this._renderer.getActiveCubeFace(),
      o = this._renderer.getActiveMipmapLevel(),
      a = this._renderer.state;
    a.setBlending(0),
      a.buffers.color.setClear(1, 1, 1, 1),
      a.buffers.depth.setTest(!0),
      a.setScissorTest(!1);
    for (let s = 0, l = t.length; s < l; s++) {
      const n = t[s],
        r = n.shadow;
      if (void 0 === r) continue;
      if (!1 === r.autoUpdate && !1 === r.needsUpdate) continue;
      this._shadowMapSize.copy(r.mapSize);
      const o = r.getFrameExtents();
      if (
        (this._shadowMapSize.multiply(o),
        this._viewportSize.copy(r.mapSize),
        (this._shadowMapSize.x > this._maxTextureSize ||
          this._shadowMapSize.y > this._maxTextureSize) &&
          (this._shadowMapSize.x > this._maxTextureSize &&
            ((this._viewportSize.x = Math.floor(this._maxTextureSize / o.x)),
            (this._shadowMapSize.x = this._viewportSize.x * o.x),
            (r.mapSize.x = this._viewportSize.x)),
          this._shadowMapSize.y > this._maxTextureSize &&
            ((this._viewportSize.y = Math.floor(this._maxTextureSize / o.y)),
            (this._shadowMapSize.y = this._viewportSize.y * o.y),
            (r.mapSize.y = this._viewportSize.y))),
        null === r.map && !r.isPointLightShadow && 3 === this.type)
      ) {
        const t = {
          minFilter: Vt,
          magFilter: Vt,
          format: te,
        };
        (r.map = new He(this._shadowMapSize.x, this._shadowMapSize.y, t)),
          (r.map.texture.name = n.name + ".shadowMap"),
          (r.mapPass = new He(this._shadowMapSize.x, this._shadowMapSize.y, t)),
          r.camera.updateProjectionMatrix();
      }
      if (null === r.map) {
        const t = {
          minFilter: Ut,
          magFilter: Ut,
          format: te,
        };
        (r.map = new He(this._shadowMapSize.x, this._shadowMapSize.y, t)),
          (r.map.texture.name = n.name + ".shadowMap"),
          r.camera.updateProjectionMatrix();
      }
      this._renderer.setRenderTarget(r.map), this._renderer.clear();
      const l = r.getViewportCount();
      for (let t = 0; t < l; t++) {
        const o = r.getViewport(t);
        this._viewport.set(
          this._viewportSize.x * o.x,
          this._viewportSize.y * o.y,
          this._viewportSize.x * o.z,
          this._viewportSize.y * o.w
        ),
          a.viewport(this._viewport),
          r.updateMatrices(n, t),
          (this._frustum = r.getFrustum()),
          this.renderObject(e, i, r.camera, n, this.type);
      }
      r.isPointLightShadow || 3 !== this.type || this.VSMPass(r, i),
        (r.needsUpdate = !1);
    }
    (this.needsUpdate = !1), this._renderer.setRenderTarget(n, r, o);
  }
  VSMPass(t, e) {
    const i = this._objects.update(this.fullScreenMesh);
    this.shadowMaterialVertical.defines.VSM_SAMPLES !== t.blurSamples &&
      ((this.shadowMaterialVertical.defines.VSM_SAMPLES = t.blurSamples),
      (this.shadowMaterialHorizontal.defines.VSM_SAMPLES = t.blurSamples),
      (this.shadowMaterialVertical.needsUpdate = !0),
      (this.shadowMaterialHorizontal.needsUpdate = !0)),
      (this.shadowMaterialVertical.uniforms.shadow_pass.value = t.map.texture),
      (this.shadowMaterialVertical.uniforms.resolution.value = t.mapSize),
      (this.shadowMaterialVertical.uniforms.radius.value = t.radius),
      this._renderer.setRenderTarget(t.mapPass),
      this._renderer.clear(),
      this._renderer.renderBufferDirect(
        e,
        null,
        i,
        this.shadowMaterialVertical,
        this.fullScreenMesh,
        null
      ),
      (this.shadowMaterialHorizontal.uniforms.shadow_pass.value =
        t.mapPass.texture),
      (this.shadowMaterialHorizontal.uniforms.resolution.value = t.mapSize),
      (this.shadowMaterialHorizontal.uniforms.radius.value = t.radius),
      this._renderer.setRenderTarget(t.map),
      this._renderer.clear(),
      this._renderer.renderBufferDirect(
        e,
        null,
        i,
        this.shadowMaterialHorizontal,
        this.fullScreenMesh,
        null
      );
  }
  getDepthMaterial(t, e, i, n, r, o, a) {
    let s = null;
    const l =
      !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
    if (
      ((s =
        void 0 !== l
          ? l
          : !0 === n.isPointLight
          ? this._distanceMaterial
          : this._depthMaterial),
      (this._renderer.localClippingEnabled &&
        !0 === i.clipShadows &&
        0 !== i.clippingPlanes.length) ||
        (i.displacementMap && 0 !== i.displacementScale) ||
        (i.alphaMap && i.alphaTest > 0))
    ) {
      const t = s.uuid,
        e = i.uuid;
      let n = this._materialCache[t];
      void 0 === n && ((n = {}), (this._materialCache[t] = n));
      let r = n[e];
      void 0 === r && ((r = s.clone()), (n[e] = r)), (s = r);
    }
    return (
      (s.visible = i.visible),
      (s.wireframe = i.wireframe),
      (s.side =
        3 === a
          ? null !== i.shadowSide
            ? i.shadowSide
            : i.side
          : null !== i.shadowSide
          ? i.shadowSide
          : this.shadowSide[i.side]),
      (s.alphaMap = i.alphaMap),
      (s.alphaTest = i.alphaTest),
      (s.clipShadows = i.clipShadows),
      (s.clippingPlanes = i.clippingPlanes),
      (s.clipIntersection = i.clipIntersection),
      (s.displacementMap = i.displacementMap),
      (s.displacementScale = i.displacementScale),
      (s.displacementBias = i.displacementBias),
      (s.wireframeLinewidth = i.wireframeLinewidth),
      (s.linewidth = i.linewidth),
      !0 === n.isPointLight &&
        !0 === s.isMeshDistanceMaterial &&
        (s.referencePosition.setFromMatrixPosition(n.matrixWorld),
        (s.nearDistance = r),
        (s.farDistance = o)),
      s
    );
  }
  renderObject(t, e, i, n, r) {
    if (!1 === t.visible) return;
    if (
      t.layers.test(e.layers) &&
      (t.isMesh || t.isLine || t.isPoints) &&
      (t.castShadow || (t.receiveShadow && 3 === r)) &&
      (!t.frustumCulled || this._frustum.intersectsObject(t))
    ) {
      t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
      const e = this._objects.update(t),
        o = t.material;
      if (Array.isArray(o)) {
        const a = e.groups;
        for (let s = 0, l = a.length; s < l; s++) {
          const l = a[s],
            u = o[l.materialIndex];
          if (u && u.visible) {
            const o = this.getDepthMaterial(t, e, u, n, i.near, i.far, r);
            this._renderer.renderBufferDirect(i, null, e, o, t, l);
          }
        }
      } else if (o.visible) {
        const a = this.getDepthMaterial(t, e, o, n, i.near, i.far, r);
        this._renderer.renderBufferDirect(i, null, e, a, t, null);
      }
    }
    const o = t.children;
    for (let a = 0, s = o.length; a < s; a++)
      this.renderObject(o[a], e, i, n, r);
  }
}
class qa {
  constructor(t) {
    (this.gl = t),
      (this.locked = !1),
      (this.color = new je()),
      (this.currentColorMask = null),
      (this.currentColorClear = new je(0, 0, 0, 0));
  }
  setMask(t) {
    this.currentColorMask === t ||
      this.locked ||
      (this.gl.colorMask(t, t, t, t), (this.currentColorMask = t));
  }
  setLocked(t) {
    this.locked = t;
  }
  setClear(t, e, i, n, r) {
    !0 === r && ((t *= n), (e *= n), (i *= n)),
      this.color.set(t, e, i, n),
      !1 === this.currentColorClear.equals(this.color) &&
        (this.gl.clearColor(t, e, i, n),
        this.currentColorClear.copy(this.color));
  }
  reset() {
    (this.locked = !1),
      (this.currentColorMask = null),
      this.currentColorClear.set(-1, 0, 0, 0);
  }
}
class Ya {
  constructor(t, e, i) {
    (this.gl = t),
      (this.enable = e),
      (this.disable = i),
      (this.locked = !1),
      (this.currentDepthMask = null),
      (this.currentDepthFunc = null),
      (this.currentDepthClear = null);
  }
  setTest(t) {
    t ? this.enable(this.gl.DEPTH_TEST) : this.disable(this.gl.DEPTH_TEST);
  }
  setMask(t) {
    this.currentDepthMask === t ||
      this.locked ||
      (this.gl.depthMask(t), (this.currentDepthMask = t));
  }
  setFunc(t) {
    if (this.currentDepthFunc !== t) {
      if (t)
        switch (t) {
          case 0:
            this.gl.depthFunc(this.gl.NEVER);
            break;
          case 1:
            this.gl.depthFunc(this.gl.ALWAYS);
            break;
          case 2:
            this.gl.depthFunc(this.gl.LESS);
            break;
          case 3:
          default:
            this.gl.depthFunc(this.gl.LEQUAL);
            break;
          case 4:
            this.gl.depthFunc(this.gl.EQUAL);
            break;
          case 5:
            this.gl.depthFunc(this.gl.GEQUAL);
            break;
          case 6:
            this.gl.depthFunc(this.gl.GREATER);
            break;
          case 7:
            this.gl.depthFunc(this.gl.NOTEQUAL);
        }
      else this.gl.depthFunc(this.gl.LEQUAL);
      this.currentDepthFunc = t;
    }
  }
  setLocked(t) {
    this.locked = t;
  }
  setClear(t) {
    this.currentDepthClear !== t &&
      (this.gl.clearDepth(t), (this.currentDepthClear = t));
  }
  reset() {
    (this.locked = !1),
      (this.currentDepthMask = null),
      (this.currentDepthFunc = null),
      (this.currentDepthClear = null);
  }
}
class Xa {
  constructor(t, e, i) {
    (this.gl = t),
      (this.enable = e),
      (this.disable = i),
      (this.locked = !1),
      (this.currentStencilMask = null),
      (this.currentStencilFunc = null),
      (this.currentStencilRef = null),
      (this.currentStencilFuncMask = null),
      (this.currentStencilFail = null),
      (this.currentStencilZFail = null),
      (this.currentStencilZPass = null),
      (this.currentStencilClear = null);
  }
  setTest(t) {
    this.locked ||
      (t
        ? this.enable(this.gl.STENCIL_TEST)
        : this.disable(this.gl.STENCIL_TEST));
  }
  setMask(t) {
    this.currentStencilMask === t ||
      this.locked ||
      (this.gl.stencilMask(t), (this.currentStencilMask = t));
  }
  setFunc(t, e, i) {
    (this.currentStencilFunc === t &&
      this.currentStencilRef === e &&
      this.currentStencilFuncMask === i) ||
      (this.gl.stencilFunc(t, e, i),
      (this.currentStencilFunc = t),
      (this.currentStencilRef = e),
      (this.currentStencilFuncMask = i));
  }
  setOp(t, e, i) {
    (this.currentStencilFail === t &&
      this.currentStencilZFail === e &&
      this.currentStencilZPass === i) ||
      (this.gl.stencilOp(t, e, i),
      (this.currentStencilFail = t),
      (this.currentStencilZFail = e),
      (this.currentStencilZPass = i));
  }
  setLocked(t) {
    this.locked = t;
  }
  setClear(t) {
    this.currentStencilClear !== t &&
      (this.gl.clearStencil(t), (this.currentStencilClear = t));
  }
  reset() {
    (this.locked = !1),
      (this.currentStencilMask = null),
      (this.currentStencilFunc = null),
      (this.currentStencilRef = null),
      (this.currentStencilFuncMask = null),
      (this.currentStencilFail = null),
      (this.currentStencilZFail = null),
      (this.currentStencilZPass = null),
      (this.currentStencilClear = null);
  }
}
class Qa {
  constructor(t, e, i) {
    (this.gl = t),
      (this.extensions = e),
      (this.capabilities = i),
      (this.isWebGL2 = i.isWebGL2),
      (this.colorBuffer = new qa(t)),
      (this.depthBuffer = new Ya(
        t,
        this.enable.bind(this),
        this.disable.bind(this)
      )),
      (this.stencilBuffer = new Xa(
        t,
        this.enable.bind(this),
        this.disable.bind(this)
      )),
      (this.buffers = {
        color: this.colorBuffer,
        depth: this.depthBuffer,
        stencil: this.stencilBuffer,
      }),
      (this.enabledCapabilities = {}),
      (this.xrFramebuffer = null),
      (this.currentBoundFramebuffers = {}),
      (this.currentProgram = null),
      (this.currentBlendingEnabled = !1),
      (this.currentBlending = null),
      (this.currentBlendEquation = null),
      (this.currentBlendSrc = null),
      (this.currentBlendDst = null),
      (this.currentBlendEquationAlpha = null),
      (this.currentBlendSrcAlpha = null),
      (this.currentBlendDstAlpha = null),
      (this.currentPremultipledAlpha = !1),
      (this.currentFlipSided = null),
      (this.currentCullFace = null),
      (this.currentLineWidth = null),
      (this.currentPolygonOffsetFactor = null),
      (this.currentPolygonOffsetUnits = null),
      (this.maxTextures = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),
      (this.lineWidthAvailable = !1);
    let n = 0;
    if (
      ((this.glVersion = t.getParameter(t.VERSION)),
      -1 !== this.glVersion.indexOf("WebGL")
        ? ((n = parseFloat(/^WebGL (\d)/.exec(this.glVersion)[1])),
          (this.lineWidthAvailable = n >= 1))
        : -1 !== this.glVersion.indexOf("OpenGL ES") &&
          ((n = parseFloat(/^OpenGL ES (\d)/.exec(this.glVersion)[1])),
          (this.lineWidthAvailable = n >= 2)),
      (this.currentTextureSlot = null),
      (this.currentBoundTextures = {}),
      (this.scissorParam = t.getParameter(t.SCISSOR_BOX)),
      (this.viewportParam = t.getParameter(t.VIEWPORT)),
      (this.currentScissor = new je().fromArray(this.scissorParam)),
      (this.currentViewport = new je().fromArray(this.viewportParam)),
      (this.emptyTextures = {}),
      (this.emptyTextures[t.TEXTURE_2D] = this.createTexture(
        t.TEXTURE_2D,
        t.TEXTURE_2D,
        1
      )),
      (this.emptyTextures[t.TEXTURE_CUBE_MAP] = this.createTexture(
        t.TEXTURE_CUBE_MAP,
        t.TEXTURE_CUBE_MAP_POSITIVE_X,
        6
      )),
      this.colorBuffer.setClear(0, 0, 0, 1),
      this.depthBuffer.setClear(1),
      this.stencilBuffer.setClear(0),
      this.enable(t.DEPTH_TEST),
      this.depthBuffer.setFunc(3),
      this.setFlipSided(!1),
      this.setCullFace(1),
      this.enable(t.CULL_FACE),
      this.setBlending(0),
      (this.equationToGL = {
        [_t]: t.FUNC_ADD,
        [St]: t.FUNC_SUBTRACT,
        [Mt]: t.FUNC_REVERSE_SUBTRACT,
      }),
      this.isWebGL2)
    )
      (this.equationToGL[103] = t.MIN), (this.equationToGL[104] = t.MAX);
    else {
      const t = e.get("EXT_blend_minmax");
      null !== t &&
        ((this.equationToGL[103] = t.MIN_EXT),
        (this.equationToGL[104] = t.MAX_EXT));
    }
    this.factorToGL = {
      [Ct]: t.ZERO,
      [wt]: t.ONE,
      [At]: t.SRC_COLOR,
      [Dt]: t.SRC_ALPHA,
      [Rt]: t.SRC_ALPHA_SATURATE,
      [It]: t.DST_COLOR,
      [Pt]: t.DST_ALPHA,
      [Et]: t.ONE_MINUS_SRC_COLOR,
      [Tt]: t.ONE_MINUS_SRC_ALPHA,
      [Nt]: t.ONE_MINUS_DST_COLOR,
      [Lt]: t.ONE_MINUS_DST_ALPHA,
    };
  }
  createTexture(t, e, i) {
    const n = new Uint8Array(4),
      r = this.gl.createTexture();
    this.gl.bindTexture(t, r),
      this.gl.texParameteri(t, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST),
      this.gl.texParameteri(t, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    for (let o = 0; o < i; o++)
      this.gl.texImage2D(
        e + o,
        0,
        this.gl.RGBA,
        1,
        1,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        n
      );
    return r;
  }
  enable(t) {
    !0 !== this.enabledCapabilities[t] &&
      (this.gl.enable(t), (this.enabledCapabilities[t] = !0));
  }
  disable(t) {
    !1 !== this.enabledCapabilities[t] &&
      (this.gl.disable(t), (this.enabledCapabilities[t] = !1));
  }
  bindFramebuffer(t, e) {
    return (
      this.currentBoundFramebuffers[t] !== e &&
      (this.gl.bindFramebuffer(t, e),
      (this.currentBoundFramebuffers[t] = e),
      this.isWebGL2 &&
        (t === this.gl.DRAW_FRAMEBUFFER &&
          (this.currentBoundFramebuffers[this.gl.FRAMEBUFFER] = e),
        t === this.gl.FRAMEBUFFER &&
          (this.currentBoundFramebuffers[this.gl.DRAW_FRAMEBUFFER] = e)),
      !0)
    );
  }
  useProgram(t) {
    return (
      this.currentProgram !== t &&
      (this.gl.useProgram(t), (this.currentProgram = t), !0)
    );
  }
  setBlending(t, e, i, n, r, o, a, s) {
    if (0 !== t) {
      if (
        (!1 === this.currentBlendingEnabled &&
          (this.enable(this.gl.BLEND), (this.currentBlendingEnabled = !0)),
        5 === t)
      )
        (r = r || e),
          (o = o || i),
          (a = a || n),
          (e === this.currentBlendEquation &&
            r === this.currentBlendEquationAlpha) ||
            (this.gl.blendEquationSeparate(
              this.equationToGL[e],
              this.equationToGL[r]
            ),
            (this.currentBlendEquation = e),
            (this.currentBlendEquationAlpha = r)),
          (i === this.currentBlendSrc &&
            n === this.currentBlendDst &&
            o === this.currentBlendSrcAlpha &&
            a === this.currentBlendDstAlpha) ||
            (this.gl.blendFuncSeparate(
              this.factorToGL[i],
              this.factorToGL[n],
              this.factorToGL[o],
              this.factorToGL[a]
            ),
            (this.currentBlendSrc = i),
            (this.currentBlendDst = n),
            (this.currentBlendSrcAlpha = o),
            (this.currentBlendDstAlpha = a)),
          (this.currentBlending = t),
          (this.currentPremultipledAlpha = null);
      else if (
        t !== this.currentBlending ||
        s !== this.currentPremultipledAlpha
      ) {
        if (
          ((this.currentBlendEquation === _t &&
            this.currentBlendEquationAlpha === _t) ||
            (this.gl.blendEquation(this.gl.FUNC_ADD),
            (this.currentBlendEquation = _t),
            (this.currentBlendEquationAlpha = _t)),
          s)
        )
          switch (t) {
            case 1:
              this.gl.blendFuncSeparate(
                this.gl.ONE,
                this.gl.ONE_MINUS_SRC_ALPHA,
                this.gl.ONE,
                this.gl.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
              break;
            case 3:
              this.gl.blendFuncSeparate(
                this.gl.ZERO,
                this.gl.ZERO,
                this.gl.ONE_MINUS_SRC_COLOR,
                this.gl.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 4:
              this.gl.blendFuncSeparate(
                this.gl.ZERO,
                this.gl.SRC_COLOR,
                this.gl.ZERO,
                this.gl.SRC_ALPHA
              );
              break;
            default:
              console.error(
                "@dp/gis-engine: WebGLState: Invalid blending: ",
                t
              );
          }
        else
          switch (t) {
            case 1:
              this.gl.blendFuncSeparate(
                this.gl.SRC_ALPHA,
                this.gl.ONE_MINUS_SRC_ALPHA,
                this.gl.ONE,
                this.gl.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
              break;
            case 3:
              this.gl.blendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_COLOR);
              break;
            case 4:
              this.gl.blendFunc(this.gl.ZERO, this.gl.SRC_COLOR);
              break;
            default:
              console.error(
                "@dp/gis-engine: WebGLState: Invalid blending: ",
                t
              );
          }
        (this.currentBlendSrc = null),
          (this.currentBlendDst = null),
          (this.currentBlendSrcAlpha = null),
          (this.currentBlendDstAlpha = null),
          (this.currentBlending = t),
          (this.currentPremultipledAlpha = s);
      }
    } else
      !0 === this.currentBlendingEnabled &&
        (this.disable(this.gl.BLEND), (this.currentBlendingEnabled = !1));
  }
  setMaterial(t, e) {
    t.side === xt
      ? this.disable(this.gl.CULL_FACE)
      : this.enable(this.gl.CULL_FACE);
    let i = t.side === bt;
    e && (i = !i),
      this.setFlipSided(i),
      1 === t.blending && !1 === t.transparent
        ? this.setBlending(0)
        : this.setBlending(
            t.blending,
            t.blendEquation,
            t.blendSrc,
            t.blendDst,
            t.blendEquationAlpha,
            t.blendSrcAlpha,
            t.blendDstAlpha,
            t.premultipliedAlpha
          ),
      this.depthBuffer.setFunc(t.depthFunc),
      this.depthBuffer.setTest(t.depthTest),
      this.depthBuffer.setMask(t.depthWrite),
      this.colorBuffer.setMask(t.colorWrite);
    const n = t.stencilWrite;
    this.stencilBuffer.setTest(n),
      n &&
        (this.stencilBuffer.setMask(t.stencilWriteMask),
        this.stencilBuffer.setFunc(
          t.stencilFunc,
          t.stencilRef,
          t.stencilFuncMask
        ),
        this.stencilBuffer.setOp(
          t.stencilFail,
          t.stencilZFail,
          t.stencilZPass
        )),
      this.setPolygonOffset(
        t.polygonOffset,
        t.polygonOffsetFactor,
        t.polygonOffsetUnits
      ),
      !0 === t.alphaToCoverage
        ? this.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE)
        : this.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setFlipSided(t) {
    this.currentFlipSided !== t &&
      (t ? this.gl.frontFace(this.gl.CW) : this.gl.frontFace(this.gl.CCW),
      (this.currentFlipSided = t));
  }
  setCullFace(t) {
    0 !== t
      ? (this.enable(this.gl.CULL_FACE),
        t !== this.currentCullFace &&
          (1 === t
            ? this.gl.cullFace(this.gl.BACK)
            : 2 === t
            ? this.gl.cullFace(this.gl.FRONT)
            : this.gl.cullFace(this.gl.FRONT_AND_BACK)))
      : this.disable(this.gl.CULL_FACE),
      (this.currentCullFace = t);
  }
  setLineWidth(t) {
    t !== this.currentLineWidth &&
      (this.lineWidthAvailable && this.gl.lineWidth(t),
      (this.currentLineWidth = t));
  }
  setPolygonOffset(t, e, i) {
    t
      ? (this.enable(this.gl.POLYGON_OFFSET_FILL),
        (this.currentPolygonOffsetFactor === e &&
          this.currentPolygonOffsetUnits === i) ||
          (this.gl.polygonOffset(e, i),
          (this.currentPolygonOffsetFactor = e),
          (this.currentPolygonOffsetUnits = i)))
      : this.disable(this.gl.POLYGON_OFFSET_FILL);
  }
  setScissorTest(t) {
    t ? this.enable(this.gl.SCISSOR_TEST) : this.disable(this.gl.SCISSOR_TEST);
  }
  activeTexture(t) {
    void 0 === t && (t = this.gl.TEXTURE0 + this.maxTextures - 1),
      this.currentTextureSlot !== t &&
        (this.gl.activeTexture(t), (this.currentTextureSlot = t));
  }
  bindTexture(t, e) {
    null === this.currentTextureSlot && this.activeTexture();
    let i = this.currentBoundTextures[this.currentTextureSlot];
    void 0 === i &&
      ((i = {
        type: void 0,
        texture: void 0,
      }),
      (this.currentBoundTextures[this.currentTextureSlot] = i)),
      (i.type === t && i.texture === e) ||
        (this.gl.bindTexture(t, e || this.emptyTextures[t]),
        (i.type = t),
        (i.texture = e));
  }
  unbindTexture() {
    const t = this.currentBoundTextures[this.currentTextureSlot];
    void 0 !== t &&
      void 0 !== t.type &&
      (this.gl.bindTexture(t.type, null),
      (t.type = void 0),
      (t.texture = void 0));
  }
  compressedTexImage2D(...t) {
    try {
      this.gl.compressedTexImage2D.apply(this.gl, t);
    } catch (e) {
      console.error("@dp/gis-engine: WebGLState:", e);
    }
  }
  texSubImage2D(...t) {
    try {
      this.gl.texSubImage2D.apply(this.gl, t);
    } catch (e) {
      console.error("@dp/gis-engine: WebGLState:", e);
    }
  }
  texStorage2D(...t) {
    try {
      this.gl.texStorage2D.apply(this.gl, t);
    } catch (e) {
      console.error("@dp/gis-engine: WebGLState:", e);
    }
  }
  texImage2D(...t) {
    try {
      this.gl.texImage2D.apply(this.gl, t);
    } catch (e) {
      console.error("@dp/gis-engine: WebGLState:", e);
    }
  }
  texImage3D(...t) {
    try {
      this.gl.texImage3D.apply(this.gl, t);
    } catch (e) {
      console.error("@dp/gis-engine: WebGLState:", e);
    }
  }
  scissor(t) {
    !1 === this.currentScissor.equals(t) &&
      (this.gl.scissor(t.x, t.y, t.z, t.w), this.currentScissor.copy(t));
  }
  viewport(t) {
    !1 === this.currentViewport.equals(t) &&
      (this.gl.viewport(t.x, t.y, t.z, t.w), this.currentViewport.copy(t));
  }
  reset() {
    this.gl.disable(this.gl.BLEND),
      this.gl.disable(this.gl.CULL_FACE),
      this.gl.disable(this.gl.DEPTH_TEST),
      this.gl.disable(this.gl.POLYGON_OFFSET_FILL),
      this.gl.disable(this.gl.SCISSOR_TEST),
      this.gl.disable(this.gl.STENCIL_TEST),
      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE),
      this.gl.blendEquation(this.gl.FUNC_ADD),
      this.gl.blendFunc(this.gl.ONE, this.gl.ZERO),
      this.gl.blendFuncSeparate(
        this.gl.ONE,
        this.gl.ZERO,
        this.gl.ONE,
        this.gl.ZERO
      ),
      this.gl.colorMask(!0, !0, !0, !0),
      this.gl.clearColor(0, 0, 0, 0),
      this.gl.depthMask(!0),
      this.gl.depthFunc(this.gl.LESS),
      this.gl.clearDepth(1),
      this.gl.stencilMask(4294967295),
      this.gl.stencilFunc(this.gl.ALWAYS, 0, 4294967295),
      this.gl.stencilOp(this.gl.KEEP, this.gl.KEEP, this.gl.KEEP),
      this.gl.clearStencil(0),
      this.gl.cullFace(this.gl.BACK),
      this.gl.frontFace(this.gl.CCW),
      this.gl.polygonOffset(0, 0),
      this.gl.activeTexture(this.gl.TEXTURE0),
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null),
      !0 === this.isWebGL2 &&
        (this.gl.bindFramebuffer(this.gl.DRAW_FRAMEBUFFER, null),
        this.gl.bindFramebuffer(this.gl.READ_FRAMEBUFFER, null)),
      this.gl.useProgram(null),
      this.gl.lineWidth(1),
      this.gl.scissor(0, 0, this.gl.canvas.width, this.gl.canvas.height),
      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height),
      (this.enabledCapabilities = {}),
      (this.currentTextureSlot = null),
      (this.currentBoundTextures = {}),
      (this.xrFramebuffer = null),
      (this.currentBoundFramebuffers = {}),
      (this.currentProgram = null),
      (this.currentBlendingEnabled = !1),
      (this.currentBlending = null),
      (this.currentBlendEquation = null),
      (this.currentBlendSrc = null),
      (this.currentBlendDst = null),
      (this.currentBlendEquationAlpha = null),
      (this.currentBlendSrcAlpha = null),
      (this.currentBlendDstAlpha = null),
      (this.currentPremultipledAlpha = !1),
      (this.currentFlipSided = null),
      (this.currentCullFace = null),
      (this.currentLineWidth = null),
      (this.currentPolygonOffsetFactor = null),
      (this.currentPolygonOffsetUnits = null),
      this.currentScissor.set(
        0,
        0,
        this.gl.canvas.width,
        this.gl.canvas.height
      ),
      this.currentViewport.set(
        0,
        0,
        this.gl.canvas.width,
        this.gl.canvas.height
      ),
      this.colorBuffer.reset(),
      this.depthBuffer.reset(),
      this.stencilBuffer.reset();
  }
}
class Za {
  constructor(t, e, i, n, r, o, a) {
    (this._gl = t),
      (this.extensions = e),
      (this.state = i),
      (this.properties = n),
      (this.capabilities = r),
      (this.utils = o),
      (this.info = a),
      (this.onTextureDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onTextureDispose),
          this.deallocateTexture(e),
          e.isVideoTexture && this._videoTextures.delete(e),
          this.info.memory.textures--;
      }),
      (this.onRenderTargetDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onRenderTargetDispose),
          this.deallocateRenderTarget(e);
      }),
      (this.isWebGL2 = r.isWebGL2),
      (this.maxTextures = r.maxTextures),
      (this.maxCubemapSize = r.maxCubemapSize),
      (this.maxTextureSize = r.maxTextureSize),
      (this.maxSamples = r.maxSamples),
      (this._videoTextures = new WeakMap()),
      this._canvas,
      (this.useOffscreenCanvas = !1);
    try {
      this.useOffscreenCanvas =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (s) {}
    (this.textureUnits = 0),
      (this.warnedTexture2D = !1),
      (this.warnedTextureCube = !1),
      (this.wrappingToGL = {
        [kt]: this._gl.REPEAT,
        [Bt]: this._gl.CLAMP_TO_EDGE,
        [Gt]: this._gl.MIRRORED_REPEAT,
      }),
      (this.filterToGL = {
        [Ut]: this._gl.NEAREST,
        [jt]: this._gl.NEAREST_MIPMAP_NEAREST,
        [Ht]: this._gl.NEAREST_MIPMAP_LINEAR,
        [Vt]: this._gl.LINEAR,
        [Wt]: this._gl.LINEAR_MIPMAP_NEAREST,
        [qt]: this._gl.LINEAR_MIPMAP_LINEAR,
      });
  }
  createCanvas(t, e) {
    return this.useOffscreenCanvas ? new OffscreenCanvas(t, e) : Re("canvas");
  }
  resizeImage(t, e, i, n) {
    let r = 1;
    if (
      ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)),
      r < 1 || !0 === e)
    ) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const n = e ? Pe : Math.floor,
          o = n(r * t.width),
          a = n(r * t.height);
        void 0 === this._canvas && (this._canvas = this.createCanvas(o, a));
        const s = i ? this.createCanvas(o, a) : this._canvas;
        (s.width = o), (s.height = a);
        return (
          s.getContext("2d").drawImage(t, 0, 0, o, a), t.width, t.height, s
        );
      }
      return "data" in t && (t.width, t.height), t;
    }
    return t;
  }
  isPowerOfTwo(t) {
    return Te(t.width) && Te(t.height);
  }
  textureNeedsPowerOfTwo(t) {
    return (
      !this.isWebGL2 &&
      (t.wrapS !== Bt ||
        t.wrapT !== Bt ||
        (t.minFilter !== Ut && t.minFilter !== Vt))
    );
  }
  textureNeedsGenerateMipmaps(t, e) {
    return t.generateMipmaps && e && t.minFilter !== Ut && t.minFilter !== Vt;
  }
  generateMipmap(t) {
    this._gl.generateMipmap(t);
  }
  getInternalFormat(t, e, i, n) {
    if (!1 === this.isWebGL2) return e;
    if (null !== t && void 0 !== this._gl[t]) return this._gl[t];
    let r = e;
    return (
      e === this._gl.RED &&
        (i === this._gl.FLOAT && (r = this._gl.R32F),
        i === this._gl.HALF_FLOAT && (r = this._gl.R16F),
        i === this._gl.UNSIGNED_BYTE && (r = this._gl.R8)),
      e === this._gl.RGB &&
        (i === this._gl.FLOAT && (r = this._gl.RGB32F),
        i === this._gl.HALF_FLOAT && (r = this._gl.RGB16F),
        i === this._gl.UNSIGNED_BYTE && (r = this._gl.RGB8)),
      e === this._gl.RGBA &&
        (i === this._gl.FLOAT && (r = this._gl.RGBA32F),
        i === this._gl.HALF_FLOAT && (r = this._gl.RGBA16F),
        i === this._gl.UNSIGNED_BYTE && (r = this._gl.RGBA8)),
      (r !== this._gl.R16F &&
        r !== this._gl.R32F &&
        r !== this._gl.RGBA16F &&
        r !== this._gl.RGBA32F) ||
        this.extensions.get("EXT_color_buffer_float"),
      r
    );
  }
  getMipLevels(t, e, i) {
    return !0 === this.textureNeedsGenerateMipmaps(t, i)
      ? Math.log2(Math.max(e.width, e.height)) + 1
      : t.mipmaps.length > 0
      ? t.mipmaps.length
      : 1;
  }
  filterFallback(t) {
    return t === Ut || 1004 === t || 1005 === t
      ? this._gl.NEAREST
      : this._gl.LINEAR;
  }
  deallocateTexture(t) {
    const e = this.properties.get(t);
    void 0 !== e.__webglInit &&
      (this._gl.deleteTexture(e.__webglTexture), this.properties.remove(t));
  }
  deallocateRenderTarget(t) {
    const e = t.texture,
      i = this.properties.get(t),
      n = this.properties.get(e);
    if (t) {
      if (
        (void 0 !== n.__webglTexture &&
          (this._gl.deleteTexture(n.__webglTexture),
          this.info.memory.textures--),
        t.depthTexture && t.depthTexture.dispose(),
        t.isWebGLCubeRenderTarget)
      )
        for (let t = 0; t < 6; t++)
          this._gl.deleteFramebuffer(i.__webglFramebuffer[t]),
            i.__webglDepthbuffer &&
              this._gl.deleteRenderbuffer(i.__webglDepthbuffer[t]);
      else
        this._gl.deleteFramebuffer(i.__webglFramebuffer),
          i.__webglDepthbuffer &&
            this._gl.deleteRenderbuffer(i.__webglDepthbuffer),
          i.__webglMultisampledFramebuffer &&
            this._gl.deleteFramebuffer(i.__webglMultisampledFramebuffer),
          i.__webglColorRenderbuffer &&
            this._gl.deleteRenderbuffer(i.__webglColorRenderbuffer),
          i.__webglDepthRenderbuffer &&
            this._gl.deleteRenderbuffer(i.__webglDepthRenderbuffer);
      if (t.isWebGLMultipleRenderTargets)
        for (let t = 0, i = e.length; t < i; t++) {
          const i = this.properties.get(e[t]);
          i.__webglTexture &&
            (this._gl.deleteTexture(i.__webglTexture),
            this.info.memory.textures--),
            this.properties.remove(e[t]);
        }
      this.properties.remove(e), this.properties.remove(t);
    }
  }
  resetTextureUnits() {
    this.textureUnits = 0;
  }
  allocateTextureUnit() {
    const t = this.textureUnits;
    return (
      t >= this.maxTextures && this.maxTextures, (this.textureUnits += 1), t
    );
  }
  setTexture2D(t, e) {
    const i = this.properties.get(t);
    if (
      (t.isVideoTexture && this.updateVideoTexture(t),
      t.version > 0 && i.__version !== t.version)
    ) {
      const n = t.image;
      if (void 0 === n);
      else if (!1 !== n.complete) return void this.uploadTexture(i, t, e);
    }
    this.state.activeTexture(this._gl.TEXTURE0 + e),
      this.state.bindTexture(this._gl.TEXTURE_2D, i.__webglTexture);
  }
  setTexture2DArray(t, e) {
    const i = this.properties.get(t);
    t.version > 0 && i.__version !== t.version
      ? this.uploadTexture(i, t, e)
      : (this.state.activeTexture(this._gl.TEXTURE0 + e),
        this.state.bindTexture(this._gl.TEXTURE_2D_ARRAY, i.__webglTexture));
  }
  setTexture3D(t, e) {
    const i = this.properties.get(t);
    t.version > 0 && i.__version !== t.version
      ? this.uploadTexture(i, t, e)
      : (this.state.activeTexture(this._gl.TEXTURE0 + e),
        this.state.bindTexture(this._gl.TEXTURE_3D, i.__webglTexture));
  }
  setTextureCube(t, e) {
    const i = this.properties.get(t);
    t.version > 0 && i.__version !== t.version
      ? this.uploadCubeTexture(i, t, e)
      : (this.state.activeTexture(this._gl.TEXTURE0 + e),
        this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, i.__webglTexture));
  }
  setTextureParameters(t, e, i) {
    if (
      (i
        ? (this._gl.texParameteri(
            t,
            this._gl.TEXTURE_WRAP_S,
            this.wrappingToGL[e.wrapS]
          ),
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_WRAP_T,
            this.wrappingToGL[e.wrapT]
          ),
          (t !== this._gl.TEXTURE_3D && t !== this._gl.TEXTURE_2D_ARRAY) ||
            this._gl.texParameteri(
              t,
              this._gl.TEXTURE_WRAP_R,
              this.wrappingToGL[e.wrapR]
            ),
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_MAG_FILTER,
            this.filterToGL[e.magFilter]
          ),
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_MIN_FILTER,
            this.filterToGL[e.minFilter]
          ))
        : (this._gl.texParameteri(
            t,
            this._gl.TEXTURE_WRAP_S,
            this._gl.CLAMP_TO_EDGE
          ),
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_WRAP_T,
            this._gl.CLAMP_TO_EDGE
          ),
          (t !== this._gl.TEXTURE_3D && t !== this._gl.TEXTURE_2D_ARRAY) ||
            this._gl.texParameteri(
              t,
              this._gl.TEXTURE_WRAP_R,
              this._gl.CLAMP_TO_EDGE
            ),
          e.wrapS !== Bt || e.wrapT,
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_MAG_FILTER,
            this.filterFallback(e.magFilter)
          ),
          this._gl.texParameteri(
            t,
            this._gl.TEXTURE_MIN_FILTER,
            this.filterFallback(e.minFilter)
          ),
          e.minFilter !== Ut && e.minFilter),
      !0 === this.extensions.has("EXT_texture_filter_anisotropic"))
    ) {
      const i = this.extensions.get("EXT_texture_filter_anisotropic");
      if (
        e.type === Zt &&
        !1 === this.extensions.has("OES_texture_float_linear")
      )
        return;
      if (
        !1 === this.isWebGL2 &&
        e.type === Jt &&
        !1 === this.extensions.has("OES_texture_half_float_linear")
      )
        return;
      (e.anisotropy > 1 || this.properties.get(e).__currentAnisotropy) &&
        (this._gl.texParameterf(
          t,
          i.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(e.anisotropy, this.capabilities.getMaxAnisotropy())
        ),
        (this.properties.get(e).__currentAnisotropy = e.anisotropy));
    }
  }
  initTexture(t, e) {
    void 0 === t.__webglInit &&
      ((t.__webglInit = !0),
      e.addEventListener("dispose", this.onTextureDispose),
      (t.__webglTexture = this._gl.createTexture()),
      this.info.memory.textures++);
  }
  uploadTexture(t, e, i) {
    let n = this._gl.TEXTURE_2D;
    e.isDataTexture2DArray && (n = this._gl.TEXTURE_2D_ARRAY),
      e.isDataTexture3D && (n = this._gl.TEXTURE_3D),
      this.initTexture(t, e),
      this.state.activeTexture(this._gl.TEXTURE0 + i),
      this.state.bindTexture(n, t.__webglTexture),
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e.flipY),
      this._gl.pixelStorei(
        this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        e.premultiplyAlpha
      ),
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, e.unpackAlignment),
      this._gl.pixelStorei(
        this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
        this._gl.NONE
      );
    const r =
        this.textureNeedsPowerOfTwo(e) && !1 === this.isPowerOfTwo(e.image),
      o = this.resizeImage(e.image, r, !1, this.maxTextureSize),
      a = this.isPowerOfTwo(o) || this.isWebGL2,
      s = this.utils.convert(e.format);
    let l,
      u = this.utils.convert(e.type),
      c = this.getInternalFormat(e.internalFormat, s, u, e.encoding);
    this.setTextureParameters(n, e, a);
    const h = e.mipmaps;
    if (e.isDepthTexture)
      (c = this._gl.DEPTH_COMPONENT),
        this.isWebGL2
          ? (c =
              e.type === Zt
                ? this._gl.DEPTH_COMPONENT32F
                : e.type === Qt
                ? this._gl.DEPTH_COMPONENT24
                : e.type === Kt
                ? this._gl.DEPTH24_STENCIL8
                : this._gl.DEPTH_COMPONENT16)
          : e.type === Zt &&
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2."
            ),
        e.format === ee &&
          c === this._gl.DEPTH_COMPONENT &&
          e.type !== Xt &&
          e.type !== Qt &&
          ((e.type = Xt), (u = this.utils.convert(e.type))),
        e.format === ie &&
          c === this._gl.DEPTH_COMPONENT &&
          ((c = this._gl.DEPTH_STENCIL),
          e.type !== Kt && ((e.type = Kt), (u = this.utils.convert(e.type)))),
        this.state.texImage2D(
          this._gl.TEXTURE_2D,
          0,
          c,
          o.width,
          o.height,
          0,
          s,
          u,
          null
        );
    else if (e.isDataTexture)
      if (h.length > 0 && a) {
        for (let t = 0, e = h.length; t < e; t++)
          (l = h[t]),
            this.state.texImage2D(
              this._gl.TEXTURE_2D,
              t,
              c,
              l.width,
              l.height,
              0,
              s,
              u,
              l.data
            );
        e.generateMipmaps = !1;
      } else
        this.state.texImage2D(
          this._gl.TEXTURE_2D,
          0,
          c,
          o.width,
          o.height,
          0,
          s,
          u,
          o.data
        );
    else if (e.isCompressedTexture)
      for (let p = 0, d = h.length; p < d; p++)
        (l = h[p]),
          e.format !== te && e.format !== $t
            ? null !== s &&
              this.state.compressedTexImage2D(
                this._gl.TEXTURE_2D,
                p,
                c,
                l.width,
                l.height,
                0,
                l.data
              )
            : this.state.texImage2D(
                this._gl.TEXTURE_2D,
                p,
                c,
                l.width,
                l.height,
                0,
                s,
                u,
                l.data
              );
    else if (e.isDataTexture2DArray)
      this.state.texImage3D(
        this._gl.TEXTURE_2D_ARRAY,
        0,
        c,
        o.width,
        o.height,
        o.depth,
        0,
        s,
        u,
        o.data
      );
    else if (e.isDataTexture3D)
      this.state.texImage3D(
        this._gl.TEXTURE_3D,
        0,
        c,
        o.width,
        o.height,
        o.depth,
        0,
        s,
        u,
        o.data
      );
    else {
      const i = this.getMipLevels(e, o, a),
        n = this.isWebGL2 && !0 !== e.isVideoTexture,
        r = void 0 === t.__version;
      if (h.length > 0 && a) {
        n &&
          r &&
          this.state.texStorage2D(
            this._gl.TEXTURE_2D,
            i,
            c,
            h[0].width,
            h[0].height
          );
        for (let t = 0, e = h.length; t < e; t++)
          (l = h[t]),
            n
              ? this.state.texSubImage2D(this._gl.TEXTURE_2D, t, 0, 0, s, u, l)
              : this.state.texImage2D(this._gl.TEXTURE_2D, t, c, s, u, l);
        e.generateMipmaps = !1;
      } else
        n
          ? (r &&
              this.state.texStorage2D(
                this._gl.TEXTURE_2D,
                i,
                c,
                o.width,
                o.height
              ),
            this.state.texSubImage2D(this._gl.TEXTURE_2D, 0, 0, 0, s, u, o))
          : this.state.texImage2D(this._gl.TEXTURE_2D, 0, c, s, u, o);
    }
    this.textureNeedsGenerateMipmaps(e, a) && this.generateMipmap(n),
      (t.__version = e.version),
      e.onUpdate && e.onUpdate(e);
  }
  uploadCubeTexture(t, e, i) {
    if (6 !== e.image.length) return;
    this.initTexture(t, e),
      this.state.activeTexture(this._gl.TEXTURE0 + i),
      this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, t.__webglTexture),
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e.flipY),
      this._gl.pixelStorei(
        this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        e.premultiplyAlpha
      ),
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, e.unpackAlignment),
      this._gl.pixelStorei(
        this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,
        this._gl.NONE
      );
    const n = e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
      r = e.image[0] && e.image[0].isDataTexture,
      o = [];
    for (let p = 0; p < 6; p++)
      o[p] =
        n || r
          ? r
            ? e.image[p].image
            : e.image[p]
          : this.resizeImage(e.image[p], !1, !0, this.maxCubemapSize);
    const a = o[0],
      s = this.isPowerOfTwo(a) || this.isWebGL2,
      l = this.utils.convert(e.format),
      u = this.utils.convert(e.type),
      c = this.getInternalFormat(e.internalFormat, l, u, e.encoding);
    let h;
    if ((this.setTextureParameters(this._gl.TEXTURE_CUBE_MAP, e, s), n))
      for (let p = 0; p < 6; p++) {
        h = o[p].mipmaps;
        for (let t = 0; t < h.length; t++) {
          const i = h[t];
          e.format !== te && e.format !== $t
            ? null !== l &&
              this.state.compressedTexImage2D(
                this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + p,
                t,
                c,
                i.width,
                i.height,
                0,
                i.data
              )
            : this.state.texImage2D(
                this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + p,
                t,
                c,
                i.width,
                i.height,
                0,
                l,
                u,
                i.data
              );
        }
      }
    else {
      h = e.mipmaps;
      for (let t = 0; t < 6; t++)
        if (r) {
          this.state.texImage2D(
            this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + t,
            0,
            c,
            o[t].width,
            o[t].height,
            0,
            l,
            u,
            o[t].data
          );
          for (let e = 0; e < h.length; e++) {
            const i = h[e].image[t].image;
            this.state.texImage2D(
              this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + t,
              e + 1,
              c,
              i.width,
              i.height,
              0,
              l,
              u,
              i.data
            );
          }
        } else {
          this.state.texImage2D(
            this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + t,
            0,
            c,
            l,
            u,
            o[t]
          );
          for (let e = 0; e < h.length; e++) {
            const i = h[e];
            this.state.texImage2D(
              this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + t,
              e + 1,
              c,
              l,
              u,
              i.image[t]
            );
          }
        }
    }
    this.textureNeedsGenerateMipmaps(e, s) &&
      this.generateMipmap(this._gl.TEXTURE_CUBE_MAP),
      (t.__version = e.version),
      e.onUpdate && e.onUpdate(e);
  }
  setupFrameBufferTexture(t, e, i, n, r) {
    const o = this.utils.convert(i.format),
      a = this.utils.convert(i.type),
      s = this.getInternalFormat(i.internalFormat, o, a, i.encoding);
    r === this._gl.TEXTURE_3D || r === this._gl.TEXTURE_2D_ARRAY
      ? this.state.texImage3D(
          r,
          0,
          s,
          e.width,
          e.height,
          e.depth,
          0,
          o,
          a,
          null
        )
      : this.state.texImage2D(r, 0, s, e.width, e.height, 0, o, a, null),
      this.state.bindFramebuffer(this._gl.FRAMEBUFFER, t),
      this._gl.framebufferTexture2D(
        this._gl.FRAMEBUFFER,
        n,
        r,
        this.properties.get(i).__webglTexture,
        0
      ),
      this.state.bindFramebuffer(this._gl.FRAMEBUFFER, null);
  }
  setupRenderBufferStorage(t, e, i) {
    if (
      (this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, t),
      e.depthBuffer && !e.stencilBuffer)
    ) {
      let n = this._gl.DEPTH_COMPONENT16;
      if (i) {
        const t = e.depthTexture;
        t &&
          t.isDepthTexture &&
          (t.type === Zt
            ? (n = this._gl.DEPTH_COMPONENT32F)
            : t.type === Qt && (n = this._gl.DEPTH_COMPONENT24));
        const i = this.getRenderTargetSamples(e);
        this._gl.renderbufferStorageMultisample(
          this._gl.RENDERBUFFER,
          i,
          n,
          e.width,
          e.height
        );
      } else
        this._gl.renderbufferStorage(
          this._gl.RENDERBUFFER,
          n,
          e.width,
          e.height
        );
      this._gl.framebufferRenderbuffer(
        this._gl.FRAMEBUFFER,
        this._gl.DEPTH_ATTACHMENT,
        this._gl.RENDERBUFFER,
        t
      );
    } else if (e.depthBuffer && e.stencilBuffer) {
      if (i) {
        const t = this.getRenderTargetSamples(e);
        this._gl.renderbufferStorageMultisample(
          this._gl.RENDERBUFFER,
          t,
          this._gl.DEPTH24_STENCIL8,
          e.width,
          e.height
        );
      } else
        this._gl.renderbufferStorage(
          this._gl.RENDERBUFFER,
          this._gl.DEPTH_STENCIL,
          e.width,
          e.height
        );
      this._gl.framebufferRenderbuffer(
        this._gl.FRAMEBUFFER,
        this._gl.DEPTH_STENCIL_ATTACHMENT,
        this._gl.RENDERBUFFER,
        t
      );
    } else {
      const t =
          !0 === e.isWebGLMultipleRenderTargets ? e.texture[0] : e.texture,
        n = this.utils.convert(t.format),
        r = this.utils.convert(t.type),
        o = this.getInternalFormat(t.internalFormat, n, r, t.encoding);
      if (i) {
        const t = this.getRenderTargetSamples(e);
        this._gl.renderbufferStorageMultisample(
          this._gl.RENDERBUFFER,
          t,
          o,
          e.width,
          e.height
        );
      } else
        this._gl.renderbufferStorage(
          this._gl.RENDERBUFFER,
          o,
          e.width,
          e.height
        );
    }
    this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
  }
  setupDepthTexture(t, e) {
    if (e && e.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (this.state.bindFramebuffer(this._gl.FRAMEBUFFER, t),
      !e.depthTexture || !e.depthTexture.isDepthTexture)
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of DepthTexture"
      );
    (this.properties.get(e.depthTexture).__webglTexture &&
      e.depthTexture.image.width === e.width &&
      e.depthTexture.image.height === e.height) ||
      ((e.depthTexture.image.width = e.width),
      (e.depthTexture.image.height = e.height),
      (e.depthTexture.needsUpdate = !0)),
      this.setTexture2D(e.depthTexture, 0);
    const i = this.properties.get(e.depthTexture).__webglTexture;
    if (e.depthTexture.format === ee)
      this._gl.framebufferTexture2D(
        this._gl.FRAMEBUFFER,
        this._gl.DEPTH_ATTACHMENT,
        this._gl.TEXTURE_2D,
        i,
        0
      );
    else {
      if (e.depthTexture.format !== ie)
        throw new Error("Unknown depthTexture format");
      this._gl.framebufferTexture2D(
        this._gl.FRAMEBUFFER,
        this._gl.DEPTH_STENCIL_ATTACHMENT,
        this._gl.TEXTURE_2D,
        i,
        0
      );
    }
  }
  setupDepthRenderbuffer(t) {
    const e = this.properties.get(t),
      i = !0 === t.isWebGLCubeRenderTarget;
    if (t.depthTexture) {
      if (i)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      this.setupDepthTexture(e.__webglFramebuffer, t);
    } else if (i) {
      e.__webglDepthbuffer = [];
      for (let i = 0; i < 6; i++)
        this.state.bindFramebuffer(
          this._gl.FRAMEBUFFER,
          e.__webglFramebuffer[i]
        ),
          (e.__webglDepthbuffer[i] = this._gl.createRenderbuffer()),
          this.setupRenderBufferStorage(e.__webglDepthbuffer[i], t, !1);
    } else
      this.state.bindFramebuffer(this._gl.FRAMEBUFFER, e.__webglFramebuffer),
        (e.__webglDepthbuffer = this._gl.createRenderbuffer()),
        this.setupRenderBufferStorage(e.__webglDepthbuffer, t, !1);
    this.state.bindFramebuffer(this._gl.FRAMEBUFFER, null);
  }
  setupRenderTarget(t) {
    const e = t.texture,
      i = this.properties.get(t),
      n = this.properties.get(e);
    t.addEventListener("dispose", this.onRenderTargetDispose),
      !0 !== t.isWebGLMultipleRenderTargets &&
        ((n.__webglTexture = this._gl.createTexture()),
        (n.__version = e.version),
        this.info.memory.textures++);
    const r = !0 === t.isWebGLCubeRenderTarget,
      o = !0 === t.isWebGLMultipleRenderTargets,
      a = !0 === t.isWebGLMultisampleRenderTarget,
      s = e.isDataTexture3D || e.isDataTexture2DArray,
      l = this.isPowerOfTwo(t) || this.isWebGL2;
    if (
      (!this.isWebGL2 ||
        e.format !== $t ||
        (e.type !== Zt && e.type !== Jt) ||
        (e.format = te),
      r)
    ) {
      i.__webglFramebuffer = [];
      for (let t = 0; t < 6; t++)
        i.__webglFramebuffer[t] = this._gl.createFramebuffer();
    } else if (((i.__webglFramebuffer = this._gl.createFramebuffer()), o)) {
      if (this.capabilities.drawBuffers) {
        const e = t.texture;
        for (let t = 0, i = e.length; t < i; t++) {
          const i = this.properties.get(e[t]);
          void 0 === i.__webglTexture &&
            ((i.__webglTexture = this._gl.createTexture()),
            this.info.memory.textures++);
        }
      }
    } else if (a && this.isWebGL2) {
      (i.__webglMultisampledFramebuffer = this._gl.createFramebuffer()),
        (i.__webglColorRenderbuffer = this._gl.createRenderbuffer()),
        this._gl.bindRenderbuffer(
          this._gl.RENDERBUFFER,
          i.__webglColorRenderbuffer
        );
      const n = this.utils.convert(e.format),
        r = this.utils.convert(e.type),
        o = this.getInternalFormat(e.internalFormat, n, r, e.encoding),
        a = this.getRenderTargetSamples(t);
      this._gl.renderbufferStorageMultisample(
        this._gl.RENDERBUFFER,
        a,
        o,
        t.width,
        t.height
      ),
        this.state.bindFramebuffer(
          this._gl.FRAMEBUFFER,
          i.__webglMultisampledFramebuffer
        ),
        this._gl.framebufferRenderbuffer(
          this._gl.FRAMEBUFFER,
          this._gl.COLOR_ATTACHMENT0,
          this._gl.RENDERBUFFER,
          i.__webglColorRenderbuffer
        ),
        this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null),
        t.depthBuffer &&
          ((i.__webglDepthRenderbuffer = this._gl.createRenderbuffer()),
          this.setupRenderBufferStorage(i.__webglDepthRenderbuffer, t, !0)),
        this.state.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    }
    if (r) {
      this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, n.__webglTexture),
        this.setTextureParameters(this._gl.TEXTURE_CUBE_MAP, e, l);
      for (let n = 0; n < 6; n++)
        this.setupFrameBufferTexture(
          i.__webglFramebuffer[n],
          t,
          e,
          this._gl.COLOR_ATTACHMENT0,
          this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + n
        );
      this.textureNeedsGenerateMipmaps(e, l) &&
        this.generateMipmap(this._gl.TEXTURE_CUBE_MAP),
        this.state.unbindTexture();
    } else if (o) {
      const e = t.texture;
      for (let n = 0, r = e.length; n < r; n++) {
        const r = e[n],
          o = this.properties.get(r);
        this.state.bindTexture(this._gl.TEXTURE_2D, o.__webglTexture),
          this.setTextureParameters(this._gl.TEXTURE_2D, r, l),
          this.setupFrameBufferTexture(
            i.__webglFramebuffer,
            t,
            r,
            this._gl.COLOR_ATTACHMENT0 + n,
            this._gl.TEXTURE_2D
          ),
          this.textureNeedsGenerateMipmaps(r, l) &&
            this.generateMipmap(this._gl.TEXTURE_2D);
      }
      this.state.unbindTexture();
    } else {
      let r = this._gl.TEXTURE_2D;
      if (s && this.isWebGL2) {
        r = e.isDataTexture3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
      }
      this.state.bindTexture(r, n.__webglTexture),
        this.setTextureParameters(r, e, l),
        this.setupFrameBufferTexture(
          i.__webglFramebuffer,
          t,
          e,
          this._gl.COLOR_ATTACHMENT0,
          r
        ),
        this.textureNeedsGenerateMipmaps(e, l) && this.generateMipmap(r),
        this.state.unbindTexture();
    }
    t.depthBuffer && this.setupDepthRenderbuffer(t);
  }
  updateRenderTargetMipmap(t) {
    const e = this.isPowerOfTwo(t) || this.isWebGL2,
      i = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
    for (let n = 0, r = i.length; n < r; n++) {
      const r = i[n];
      if (this.textureNeedsGenerateMipmaps(r, e)) {
        const e = t.isWebGLCubeRenderTarget
            ? this._gl.TEXTURE_CUBE_MAP
            : this._gl.TEXTURE_2D,
          i = this.properties.get(r).__webglTexture;
        this.state.bindTexture(e, i),
          this.generateMipmap(e),
          this.state.unbindTexture();
      }
    }
  }
  updateMultisampleRenderTarget(t) {
    if (t.isWebGLMultisampleRenderTarget && this.isWebGL2) {
      const e = t.width,
        i = t.height;
      let n = this._gl.COLOR_BUFFER_BIT;
      t.depthBuffer && (n |= this._gl.DEPTH_BUFFER_BIT),
        t.stencilBuffer && (n |= this._gl.STENCIL_BUFFER_BIT);
      const r = this.properties.get(t);
      this.state.bindFramebuffer(
        this._gl.READ_FRAMEBUFFER,
        r.__webglMultisampledFramebuffer
      ),
        this.state.bindFramebuffer(
          this._gl.DRAW_FRAMEBUFFER,
          r.__webglFramebuffer
        ),
        this._gl.blitFramebuffer(0, 0, e, i, 0, 0, e, i, n, this._gl.NEAREST),
        this.state.bindFramebuffer(this._gl.READ_FRAMEBUFFER, null),
        this.state.bindFramebuffer(
          this._gl.DRAW_FRAMEBUFFER,
          r.__webglMultisampledFramebuffer
        );
    }
  }
  getRenderTargetSamples(t) {
    return this.isWebGL2 && t.isWebGLMultisampleRenderTarget
      ? Math.min(this.maxSamples, t.samples)
      : 0;
  }
  updateVideoTexture(t) {
    const e = this.info.render.frame;
    this._videoTextures.get(t) !== e &&
      (this._videoTextures.set(t, e), t.update());
  }
  safeSetTexture2D(t, e) {
    t &&
      t.isWebGLRenderTarget &&
      (!1 === this.warnedTexture2D && (this.warnedTexture2D = !0),
      (t = t.texture)),
      this.setTexture2D(t, e);
  }
  safeSetTextureCube(t, e) {
    t &&
      t.isWebGLCubeRenderTarget &&
      (!1 === this.warnedTextureCube && (this.warnedTextureCube = !0),
      (t = t.texture)),
      this.setTextureCube(t, e);
  }
}
class Ja {
  constructor(t) {
    (this.parameters = t),
      (this.onContextLost = (t) => {
        t.preventDefault(),
          console.error("@dp/gis-engine: WebGLRenderer: Context Lost."),
          (this._isContextLost = !0);
      }),
      (this.onContextRestore = () => {
        console.error("@dp/gis-engine: WebGLRenderer: Context Restored."),
          (this._isContextLost = !1);
        const t = this.info.autoReset,
          e = this.shadowMap.enabled,
          i = this.shadowMap.autoUpdate,
          n = this.shadowMap.needsUpdate,
          r = this.shadowMap.type;
        this.initGLContext(),
          (this.info.autoReset = t),
          (this.shadowMap.enabled = e),
          (this.shadowMap.autoUpdate = i),
          (this.shadowMap.needsUpdate = n),
          (this.shadowMap.type = r);
      }),
      (this.onMaterialDispose = (t) => {
        const e = t.target;
        e.removeEventListener("dispose", this.onMaterialDispose),
          this.deallocateMaterial(e);
      }),
      (this._canvas =
        void 0 !== t.canvas
          ? t.canvas
          : (function () {
              const t = Re("canvas");
              return (t.style.display = "block"), t;
            })()),
      (this._context = void 0 !== t.context ? t.context : null),
      (this._alpha = void 0 !== t.alpha && t.alpha),
      (this._depth = void 0 === t.depth || t.depth),
      (this._stencil = void 0 === t.stencil || t.stencil),
      (this._antialias = void 0 !== t.antialias && t.antialias),
      (this._premultipliedAlpha =
        void 0 === t.premultipliedAlpha || t.premultipliedAlpha),
      (this._preserveDrawingBuffer =
        void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer),
      (this._powerPreference =
        void 0 !== t.powerPreference ? t.powerPreference : "default"),
      (this._failIfMajorPerformanceCaveat =
        void 0 !== t.failIfMajorPerformanceCaveat &&
        t.failIfMajorPerformanceCaveat),
      (this.currentRenderList = null),
      (this.currentRenderState = null),
      (this.renderListStack = []),
      (this.renderStateStack = []),
      (this.domElement = this._canvas),
      (this.debug = {
        checkShaderErrors: !0,
      }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.gammaFactor = 2),
      (this.outputEncoding = ce),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = 0),
      (this.toneMappingExposure = 1),
      (this._isContextLost = !1),
      (this._currentActiveCubeFace = 0),
      (this._currentActiveMipmapLevel = 0),
      (this._currentRenderTarget = null),
      (this._currentMaterialId = -1),
      (this._currentCamera = null),
      (this._currentViewport = new je()),
      (this._currentScissor = new je()),
      (this._currentScissorTest = null),
      (this._width = this._canvas.width),
      (this._height = this._canvas.height),
      (this._pixelRatio = 1),
      (this._opaqueSort = null),
      (this._transparentSort = null),
      (this._viewport = new je(0, 0, this._width, this._height)),
      (this._scissor = new je(0, 0, this._width, this._height)),
      (this._scissorTest = !1),
      (this._currentDrawBuffers = []),
      (this._frustum = new hr()),
      (this._clippingEnabled = !1),
      (this._localClippingEnabled = !1),
      (this._transmissionRenderTarget = null),
      (this._projScreenMatrix = new Mi()),
      (this._vector3 = new Ye()),
      (this._emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      }),
      (this._gl = this._context);
    const e = (t, e) => {
      for (let i = 0; i < t.length; i++) {
        const n = t[i],
          r = this._canvas.getContext(n, e);
        if (null !== r) return r;
      }
      return null;
    };
    try {
      const t = {
        alpha: this._alpha,
        depth: this._depth,
        stencil: this._stencil,
        antialias: this._antialias,
        premultipliedAlpha: this._premultipliedAlpha,
        preserveDrawingBuffer: this._preserveDrawingBuffer,
        powerPreference: this._powerPreference,
        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
      };
      if (
        (this._canvas.addEventListener(
          "webglcontextlost",
          this.onContextLost,
          !1
        ),
        this._canvas.addEventListener(
          "webglcontextrestored",
          this.onContextRestore,
          !1
        ),
        null === this._gl)
      ) {
        const i = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (!0 === this.isWebGL1Renderer && i.shift(),
          (this._gl = e(i, t)),
          null === this._gl)
        )
          throw e(i)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      void 0 === this._gl.getShaderPrecisionFormat &&
        (this._gl.getShaderPrecisionFormat = function () {
          return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1,
          };
        });
    } catch (i) {
      throw (console.error("@dp/gis-engine: WebGLRenderer: " + i.message), i);
    }
    this.initGLContext();
  }
  getTargetPixelRatio() {
    return null === this._currentRenderTarget ? this._pixelRatio : 1;
  }
  initGLContext() {
    (this.extensions = new Qr(this._gl)),
      (this.capabilities = new xr(this._gl, this.extensions, this.parameters)),
      this.extensions.init(this.capabilities),
      (this.utils = new tD(this._gl, this.extensions, this.capabilities)),
      (this.state = new Qa(this._gl, this.extensions, this.capabilities)),
      (this._currentDrawBuffers[0] = this._gl.BACK),
      (this.info = new Kr(this._gl)),
      (this.properties = new Ia()),
      (this.textures = new Za(
        this._gl,
        this.extensions,
        this.state,
        this.properties,
        this.capabilities,
        this.utils,
        this.info
      )),
      (this.cubemaps = new Sr(this)),
      (this.cubeuvmaps = new Xr(this)),
      (this.attributes = new pr(this._gl, this.capabilities)),
      (this.bindingStates = new vr(
        this._gl,
        this.extensions,
        this.attributes,
        this.capabilities
      )),
      (this.geometries = new Zr(
        this._gl,
        this.attributes,
        this.info,
        this.bindingStates
      )),
      (this.objects = new oo(
        this._gl,
        this.geometries,
        this.attributes,
        this.info
      )),
      (this.morphtargets = new ro(this._gl, this.capabilities, this.textures)),
      (this.clipping = new _r(this.properties)),
      (this.programCache = new La(
        this,
        this.cubemaps,
        this.cubeuvmaps,
        this.extensions,
        this.capabilities,
        this.bindingStates,
        this.clipping
      )),
      (this.materials = new $r(this.properties)),
      (this.renderLists = new Fa(this.properties)),
      (this.renderStates = new ja(this.extensions, this.capabilities)),
      (this.background = new yr(
        this,
        this.cubemaps,
        this.state,
        this.objects,
        this._premultipliedAlpha
      )),
      (this.shadowMap = new Wa(this, this.objects, this.capabilities)),
      (this.bufferRenderer = new br(
        this._gl,
        this.extensions,
        this.info,
        this.capabilities
      )),
      (this.indexedBufferRenderer = new Jr(
        this._gl,
        this.extensions,
        this.info,
        this.capabilities
      )),
      (this.info.programs = this.programCache.programs);
  }
  getContext() {
    return this._gl;
  }
  getContextAttributes() {
    return this._gl.getContextAttributes();
  }
  forceContextLoss() {
    const t = this.extensions.get("WEBGL_lose_context");
    t && t.loseContext();
  }
  forceContextRestore() {
    const t = this.extensions.get("WEBGL_lose_context");
    t && t.restoreContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  setPixelRatio(t) {
    void 0 !== t &&
      ((this._pixelRatio = t), this.setSize(this._width, this._height, !1));
  }
  getSize(t) {
    return t.set(this._width, this._height);
  }
  setSize(t, e, i) {
    (this._width = t),
      (this._height = e),
      (this._canvas.width = Math.floor(t * this._pixelRatio)),
      (this._canvas.height = Math.floor(e * this._pixelRatio)),
      !1 !== i &&
        ((this._canvas.style.width = t + "px"),
        (this._canvas.style.height = e + "px")),
      this.setViewport(0, 0, t, e);
  }
  getDrawingBufferSize(t) {
    return t
      .set(this._width * this._pixelRatio, this._height * this._pixelRatio)
      .floor();
  }
  setDrawingBufferSize(t, e, i) {
    (this._width = t),
      (this._height = e),
      (this._pixelRatio = i),
      (this._canvas.width = Math.floor(t * i)),
      (this._canvas.height = Math.floor(e * i)),
      this.setViewport(0, 0, t, e);
  }
  getCurrentViewport(t) {
    return t.copy(this._currentViewport);
  }
  getViewport(t) {
    return t.copy(this._viewport);
  }
  setViewport(t, e, i, n) {
    t.isVector4
      ? this._viewport.set(t.x, t.y, t.z, t.w)
      : this._viewport.set(t, e, i, n),
      this.state.viewport(
        this._currentViewport
          .copy(this._viewport)
          .multiplyScalar(this._pixelRatio)
          .floor()
      );
  }
  getScissor(t) {
    return t.copy(this._scissor);
  }
  setScissor(t, e, i, n) {
    t.isVector4
      ? this._scissor.set(t.x, t.y, t.z, t.w)
      : this._scissor.set(t, e, i, n),
      this.state.scissor(
        this._currentScissor
          .copy(this._scissor)
          .multiplyScalar(this._pixelRatio)
          .floor()
      );
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(t) {
    this.state.setScissorTest((this._scissorTest = t));
  }
  setOpaqueSort(t) {
    this._opaqueSort = t;
  }
  setTransparentSort(t) {
    this._transparentSort = t;
  }
  getClearColor(t) {
    return t.copy(this.background.getClearColor());
  }
  setClearColor() {
    this.background.setClearColor.apply(this.background, arguments);
  }
  getClearAlpha() {
    return this.background.getClearAlpha();
  }
  setClearAlpha() {
    this.background.setClearAlpha.apply(this.background, arguments);
  }
  clear(t, e, i) {
    let n = 0;
    (void 0 === t || t) && (n |= this._gl.COLOR_BUFFER_BIT),
      (void 0 === e || e) && (n |= this._gl.DEPTH_BUFFER_BIT),
      (void 0 === i || i) && (n |= this._gl.STENCIL_BUFFER_BIT),
      this._gl.clear(n);
  }
  clearColor() {
    this.clear(!0, !1, !1);
  }
  clearDepth() {
    this.clear(!1, !0, !1);
  }
  clearStencil() {
    this.clear(!1, !1, !0);
  }
  dispose() {
    this._canvas.removeEventListener(
      "webglcontextlost",
      this.onContextLost,
      !1
    ),
      this._canvas.removeEventListener(
        "webglcontextrestored",
        this.onContextRestore,
        !1
      ),
      this.renderLists.dispose(),
      this.renderStates.dispose(),
      this.properties.dispose(),
      this.cubemaps.dispose(),
      this.cubeuvmaps.dispose(),
      this.objects.dispose(),
      this.bindingStates.dispose(),
      this._transmissionRenderTarget &&
        (this._transmissionRenderTarget.dispose(),
        (this._transmissionRenderTarget = null));
  }
  deallocateMaterial(t) {
    this.releaseMaterialProgramReferences(t), this.properties.remove(t);
  }
  releaseMaterialProgramReferences(t) {
    const e = this.properties.get(t).programs;
    void 0 !== e &&
      e.forEach((t) => {
        this.programCache.releaseProgram(t);
      });
  }
  renderBufferDirect(t, e, i, n, r, o) {
    null === e && (e = this._emptyScene);
    const a = r.isMesh && r.matrixWorld.determinant() < 0,
      s = this.setProgram(t, e, i, n, r);
    this.state.setMaterial(n, a);
    let l = i.index;
    const u = i.attributes.position;
    if (null === l) {
      if (void 0 === u || 0 === u.count) return;
    } else if (0 === l.count) return;
    let c,
      h = 1;
    !0 === n.wireframe &&
      ((l = this.geometries.getWireframeAttribute(i)), (h = 2)),
      this.bindingStates.setup(r, n, s, i, l);
    let p = this.bufferRenderer;
    null !== l &&
      ((c = this.attributes.get(l)),
      (p = this.indexedBufferRenderer),
      p.setIndex(c));
    const d = null !== l ? l.count : u.count,
      f = i.drawRange.start * h,
      g = i.drawRange.count * h,
      m = null !== o ? o.start * h : 0,
      y = null !== o ? o.count * h : 1 / 0,
      v = Math.max(f, m),
      b = Math.min(d, f + g, m + y) - 1,
      x = Math.max(0, b - v + 1);
    if (0 !== x) {
      if (r.isMesh)
        !0 === n.wireframe
          ? (this.state.setLineWidth(
              n.wireframeLinewidth * this.getTargetPixelRatio()
            ),
            p.setMode(this._gl.LINES))
          : p.setMode(this._gl.TRIANGLES);
      else if (r.isLine) {
        let t = n.linewidth;
        void 0 === t && (t = 1),
          this.state.setLineWidth(t * this.getTargetPixelRatio()),
          r.isLineSegments
            ? p.setMode(this._gl.LINES)
            : r.isLineLoop
            ? p.setMode(this._gl.LINE_LOOP)
            : p.setMode(this._gl.LINE_STRIP);
      } else
        r.isPoints
          ? p.setMode(this._gl.POINTS)
          : r.isSprite && p.setMode(this._gl.TRIANGLES);
      if (r.isInstancedMesh) p.renderInstances(v, x, r.count);
      else if (i.isInstancedBufferGeometry) {
        const t = Math.min(i.instanceCount, i._maxInstanceCount);
        p.renderInstances(v, x, t);
      } else p.render(v, x);
    }
  }
  compile(t, e) {
    (this.currentRenderState = this.renderStates.get(t)),
      this.currentRenderState.init(),
      this.renderStateStack.push(this.currentRenderState),
      t.traverseVisible((t) => {
        t.isLight &&
          t.layers.test(e.layers) &&
          (this.currentRenderState.pushLight(t),
          t.castShadow && this.currentRenderState.pushShadow(t));
      }),
      this.currentRenderState.setupLights(this.physicallyCorrectLights),
      t.traverse((e) => {
        const i = e.material;
        if (i)
          if (Array.isArray(i))
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              this.getProgram(r, t, e);
            }
          else this.getProgram(i, t, e);
      }),
      this.renderStateStack.pop(),
      (this.currentRenderState = null);
  }
  render(t, e) {
    if (void 0 !== e && !0 !== e.isCamera)
      return void console.error(
        "@dp/gis-engine: WebGLRenderer.render: camera is not an instance of Camera."
      );
    if (!0 === this._isContextLost) return;
    !0 === t.autoUpdate && t.updateMatrixWorld(),
      null === e.parent && e.updateMatrixWorld(),
      !0 === t.isScene &&
        t.onBeforeRender(this, t, e, this._currentRenderTarget),
      (this.currentRenderState = this.renderStates.get(
        t,
        this.renderStateStack.length
      )),
      this.currentRenderState.init(),
      this.renderStateStack.push(this.currentRenderState),
      this._projScreenMatrix.multiplyMatrices(
        e.projectionMatrix,
        e.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(this._projScreenMatrix),
      (this._localClippingEnabled = this.localClippingEnabled),
      (this._clippingEnabled = this.clipping.init(
        this.clippingPlanes,
        this._localClippingEnabled,
        e
      )),
      (this.currentRenderList = this.renderLists.get(
        t,
        this.renderListStack.length
      )),
      this.currentRenderList.init(),
      this.renderListStack.push(this.currentRenderList),
      this.projectObject(t, e, 0, this.sortObjects, t.ext && t.ext.zoom),
      this.currentRenderList.finish(),
      !0 === this.sortObjects &&
        this.currentRenderList.sort(this._opaqueSort, this._transparentSort),
      !0 === this._clippingEnabled && this.clipping.beginShadows();
    const i = this.currentRenderState.state.shadowsArray;
    if (
      (this.shadowMap.render(i, t, e),
      !0 === this._clippingEnabled && this.clipping.endShadows(),
      !0 === this.info.autoReset && this.info.reset(),
      this.background.render(this.currentRenderList, t),
      this.currentRenderState.setupLights(this.physicallyCorrectLights),
      e.isArrayCamera)
    ) {
      const i = e.cameras;
      for (let e = 0, n = i.length; e < n; e++) {
        const n = i[e];
        this.renderScene(this.currentRenderList, t, n, n.viewport);
      }
    } else this.renderScene(this.currentRenderList, t, e);
    null !== this._currentRenderTarget &&
      (this.textures.updateMultisampleRenderTarget(this._currentRenderTarget),
      this.textures.updateRenderTargetMipmap(this._currentRenderTarget)),
      !0 === t.isScene && t.onAfterRender(this, t, e),
      this.state.buffers.depth.setTest(!0),
      this.state.buffers.depth.setMask(!0),
      this.state.buffers.color.setMask(!0),
      this.state.setPolygonOffset(!1),
      this.bindingStates.resetDefaultState(),
      (this._currentMaterialId = -1),
      (this._currentCamera = null),
      this.renderStateStack.pop(),
      this.renderStateStack.length > 0
        ? (this.currentRenderState =
            this.renderStateStack[this.renderStateStack.length - 1])
        : (this.currentRenderState = null),
      this.renderListStack.pop(),
      this.renderListStack.length > 0
        ? (this.currentRenderList =
            this.renderListStack[this.renderListStack.length - 1])
        : (this.currentRenderList = null);
  }
  projectObject(t, e, i, n, r = -1) {
    if (!1 === t.visible) return;
    if (t.layers.test(e.layers))
      if (t.isGroup) i = t.renderOrder;
      else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
      else if (t.isLight)
        this.currentRenderState.pushLight(t),
          t.castShadow && this.currentRenderState.pushShadow(t);
      else if (t.isSprite) {
        if (!t.frustumCulled || this._frustum.intersectsSprite(t)) {
          n &&
            this._vector3
              .setFromMatrixPosition(t.matrixWorld)
              .applyMatrix4(this._projScreenMatrix);
          const e = this.objects.update(t),
            r = t.material;
          r.visible &&
            this.currentRenderList.push(t, e, r, i, this._vector3.z, null);
        }
      } else if (
        (t.isMesh || t.isLine || t.isPoints) &&
        (t.isSkinnedMesh &&
          t.skeleton.frame !== this.info.render.frame &&
          (t.skeleton.update(), (t.skeleton.frame = this.info.render.frame)),
        !t.frustumCulled || this._frustum.intersectsObject(t))
      ) {
        n &&
          this._vector3
            .setFromMatrixPosition(t.matrixWorld)
            .applyMatrix4(this._projScreenMatrix);
        const e = this.objects.update(t),
          r = t.material;
        if (Array.isArray(r)) {
          const n = e.groups;
          for (let o = 0, a = n.length; o < a; o++) {
            const a = n[o],
              s = r[a.materialIndex];
            s &&
              s.visible &&
              this.currentRenderList.push(t, e, s, i, this._vector3.z, a);
          }
        } else
          r.visible &&
            this.currentRenderList.push(t, e, r, i, this._vector3.z, null);
      }
    const o = t.children;
    for (let a = 0, s = o.length; a < s; a++) {
      const s = o[a];
      if (s.ext && s.ext.zoomRange) {
        if (r < s.ext.zoomRange[0] || r >= s.ext.zoomRange[1]) continue;
        this.projectObject(s, e, i, n, t.ext && t.ext.zoom);
      } else this.projectObject(s, e, i, n, t.ext && t.ext.zoom);
    }
  }
  renderScene(t, e, i, n) {
    const r = t.opaque,
      o = t.transmissive,
      a = t.transparent;
    this.currentRenderState.setupLightsView(i),
      o.length > 0 && this.renderTransmissionPass(r, e, i),
      n && this.state.viewport(this._currentViewport.copy(n)),
      r.length > 0 && this.renderObjects(r, e, i),
      o.length > 0 && this.renderObjects(o, e, i),
      a.length > 0 && this.renderObjects(a, e, i);
  }
  renderTransmissionPass(t, e, i) {
    if (null === this._transmissionRenderTarget) {
      const t =
        !0 === this._antialias && !0 === this.capabilities.isWebGL2 ? Ve : He;
      this._transmissionRenderTarget = new t(1024, 1024, {
        generateMipmaps: !0,
        type: null !== this.utils.convert(Jt) ? Jt : Yt,
        minFilter: qt,
        magFilter: Ut,
        wrapS: Bt,
        wrapT: Bt,
      });
    }
    const n = this.getRenderTarget();
    this.setRenderTarget(this._transmissionRenderTarget), this.clear();
    const r = this.toneMapping;
    (this.toneMapping = 0),
      this.renderObjects(t, e, i),
      (this.toneMapping = r),
      this.textures.updateMultisampleRenderTarget(
        this._transmissionRenderTarget
      ),
      this.textures.updateRenderTargetMipmap(this._transmissionRenderTarget),
      this.setRenderTarget(n);
  }
  renderObjects(t, e, i) {
    const n = !0 === e.isScene ? e.overrideMaterial : null;
    for (let r = 0, o = t.length; r < o; r++) {
      const o = t[r],
        a = o.object,
        s = o.geometry,
        l = null === n ? o.material : n,
        u = o.group;
      a.layers.test(i.layers) && this.renderObject(a, e, i, s, l, u);
    }
  }
  renderObject(t, e, i, n, r, o) {
    t.onBeforeRender(this, e, i, n, r, o),
      t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
      t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
      r.onBeforeRender(this, e, i, n, t, o),
      !0 === r.transparent && r.side === xt
        ? ((r.side = bt),
          (r.needsUpdate = !0),
          this.renderBufferDirect(i, e, n, r, t, o),
          (r.side = 0),
          (r.needsUpdate = !0),
          this.renderBufferDirect(i, e, n, r, t, o),
          (r.side = xt))
        : this.renderBufferDirect(i, e, n, r, t, o),
      t.onAfterRender(this, e, i, n, r, o);
  }
  getProgram(t, e, i) {
    !0 !== e.isScene && (e = this._emptyScene);
    const n = this.properties.get(t),
      r = this.currentRenderState.state.lights,
      o = this.currentRenderState.state.shadowsArray,
      a = r.state.version,
      s = this.programCache.getParameters(t, r.state, o, e, i),
      l = this.programCache.getProgramCacheKey(s);
    let u = n.programs;
    (n.environment = t.isMeshStandardMaterial ? e.environment : null),
      (n.fog = e.fog),
      (n.envMap = (
        t.isMeshStandardMaterial ? this.cubeuvmaps : this.cubemaps
      ).get(t.envMap || n.environment)),
      void 0 === u &&
        (t.addEventListener("dispose", this.onMaterialDispose),
        (u = new Map()),
        (n.programs = u));
    let c = u.get(l);
    if (void 0 !== c) {
      if (n.currentProgram === c && n.lightsStateVersion === a)
        return this.updateCommonMaterialProperties(t, s), c;
    } else
      (s.uniforms = this.programCache.getUniforms(t)),
        t.onBuild(i, s, this),
        t.onBeforeCompile(s, this),
        (c = this.programCache.acquireProgram(s, l)),
        u.set(l, c),
        (n.uniforms = s.uniforms);
    const h = n.uniforms;
    ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
      (h.clippingPlanes = this.clipping.uniform),
      this.updateCommonMaterialProperties(t, s),
      (n.needsLights = this.materialNeedsLights(t)),
      (n.lightsStateVersion = a),
      n.needsLights &&
        ((h.ambientLightColor.value = r.state.ambient),
        (h.lightProbe.value = r.state.probe),
        (h.directionalLights.value = r.state.directional),
        (h.directionalLightShadows.value = r.state.directionalShadow),
        (h.spotLights.value = r.state.spot),
        (h.spotLightShadows.value = r.state.spotShadow),
        (h.rectAreaLights.value = r.state.rectArea),
        (h.ltc_1.value = r.state.rectAreaLTC1),
        (h.ltc_2.value = r.state.rectAreaLTC2),
        (h.pointLights.value = r.state.point),
        (h.pointLightShadows.value = r.state.pointShadow),
        (h.hemisphereLights.value = r.state.hemi),
        (h.directionalShadowMap.value = r.state.directionalShadowMap),
        (h.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
        (h.spotShadowMap.value = r.state.spotShadowMap),
        (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
        (h.pointShadowMap.value = r.state.pointShadowMap),
        (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
    const p = c.getUniforms(),
      d = ca.seqWithValue(p.seq, h);
    return (n.currentProgram = c), (n.uniformsList = d), c;
  }
  updateCommonMaterialProperties(t, e) {
    const i = this.properties.get(t);
    (i.outputEncoding = e.outputEncoding),
      (i.instancing = e.instancing),
      (i.skinning = e.skinning),
      (i.morphTargets = e.morphTargets),
      (i.morphNormals = e.morphNormals),
      (i.morphTargetsCount = e.morphTargetsCount),
      (i.numClippingPlanes = e.numClippingPlanes),
      (i.numIntersection = e.numClipIntersection),
      (i.vertexAlphas = e.vertexAlphas),
      (i.vertexTangents = e.vertexTangents);
  }
  setProgram(t, e, i, n, r) {
    !0 !== e.isScene && (e = this._emptyScene),
      this.textures.resetTextureUnits();
    const o = e.fog,
      a = n.isMeshStandardMaterial ? e.environment : null,
      s =
        null === this._currentRenderTarget
          ? this.outputEncoding
          : this._currentRenderTarget.texture.encoding,
      l = (n.isMeshStandardMaterial ? this.cubeuvmaps : this.cubemaps).get(
        n.envMap || a
      ),
      u =
        !0 === n.vertexColors &&
        !!i.attributes.color &&
        4 === i.attributes.color.itemSize,
      c = !!n.normalMap && !!i.attributes.tangent,
      h = !!i.morphAttributes.position,
      p = !!i.morphAttributes.normal,
      d = i.morphAttributes.position ? i.morphAttributes.position.length : 0,
      f = this.properties.get(n),
      g = this.currentRenderState.state.lights;
    if (
      !0 === this._clippingEnabled &&
      (!0 === this._localClippingEnabled || t !== this._currentCamera)
    ) {
      const e = t === this._currentCamera && n.id === this._currentMaterialId;
      this.clipping.setState(n, t, e);
    }
    let m = !1;
    n.version === f.__version
      ? (f.needsLights && f.lightsStateVersion !== g.state.version) ||
        f.outputEncoding !== s ||
        (r.isInstancedMesh && !1 === f.instancing)
        ? (m = !0)
        : r.isInstancedMesh || !0 !== f.instancing
        ? r.isSkinnedMesh && !1 === f.skinning
          ? (m = !0)
          : r.isSkinnedMesh || !0 !== f.skinning
          ? f.envMap !== l || (n.fog && f.fog !== o)
            ? (m = !0)
            : void 0 === f.numClippingPlanes ||
              (f.numClippingPlanes === this.clipping.numPlanes &&
                f.numIntersection === this.clipping.numIntersection)
            ? (f.vertexAlphas !== u ||
                f.vertexTangents !== c ||
                f.morphTargets !== h ||
                f.morphNormals !== p ||
                (!0 === this.capabilities.isWebGL2 &&
                  f.morphTargetsCount !== d)) &&
              (m = !0)
            : (m = !0)
          : (m = !0)
        : (m = !0)
      : ((m = !0), (f.__version = n.version));
    let y = f.currentProgram;
    !0 === m && (y = this.getProgram(n, e, r));
    let v = !1,
      b = !1,
      x = !1;
    const _ = y.getUniforms(),
      S = f.uniforms;
    if (
      (this.state.useProgram(y.program) && ((v = !0), (b = !0), (x = !0)),
      n.id !== this._currentMaterialId &&
        ((this._currentMaterialId = n.id), (b = !0)),
      v || this._currentCamera !== t)
    ) {
      if (
        (_.setValue(this._gl, "projectionMatrix", t.projectionMatrix),
        this.capabilities.logarithmicDepthBuffer &&
          _.setValue(
            this._gl,
            "logDepthBufFC",
            2 / (Math.log(t.far + 1) / Math.LN2)
          ),
        this._currentCamera !== t &&
          ((this._currentCamera = t), (b = !0), (x = !0)),
        n.isShaderMaterial ||
          n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshStandardMaterial ||
          n.envMap)
      ) {
        const e = _.map.cameraPosition;
        void 0 !== e &&
          e.setValue(
            this._gl,
            this._vector3.setFromMatrixPosition(t.matrixWorld)
          );
      }
      (n.isMeshPhongMaterial ||
        n.isMeshToonMaterial ||
        n.isMeshLambertMaterial ||
        n.isMeshBasicMaterial ||
        n.isMeshStandardMaterial ||
        n.isShaderMaterial) &&
        _.setValue(this._gl, "isOrthographic", !0 === t.isOrthographicCamera),
        (n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshLambertMaterial ||
          n.isMeshBasicMaterial ||
          n.isMeshStandardMaterial ||
          n.isShaderMaterial ||
          n.isShadowMaterial ||
          r.isSkinnedMesh) &&
          _.setValue(this._gl, "viewMatrix", t.matrixWorldInverse);
    }
    if (r.isSkinnedMesh) {
      _.setOptional(this._gl, r, "bindMatrix"),
        _.setOptional(this._gl, r, "bindMatrixInverse");
      const t = r.skeleton;
      t &&
        (this.capabilities.floatVertexTextures
          ? (null === t.boneTexture && t.computeBoneTexture(),
            _.setValue(this._gl, "boneTexture", t.boneTexture, this.textures),
            _.setValue(this._gl, "boneTextureSize", t.boneTextureSize))
          : _.setOptional(this._gl, t, "boneMatrices"));
    }
    return (
      !i ||
        (void 0 === i.morphAttributes.position &&
          void 0 === i.morphAttributes.normal) ||
        this.morphtargets.update(r, i, n, y),
      (b || f.receiveShadow !== r.receiveShadow) &&
        ((f.receiveShadow = r.receiveShadow),
        _.setValue(this._gl, "receiveShadow", r.receiveShadow)),
      b &&
        (_.setValue(this._gl, "toneMappingExposure", this.toneMappingExposure),
        f.needsLights && this.markUniformsLightsNeedsUpdate(S, x),
        o && n.fog && this.materials.refreshFogUniforms(S, o),
        this.materials.refreshMaterialUniforms(
          S,
          n,
          this._pixelRatio,
          this._height,
          this._transmissionRenderTarget
        ),
        ca.upload(this._gl, f.uniformsList, S, this.textures)),
      n.isShaderMaterial &&
        !0 === n.uniformsNeedUpdate &&
        (ca.upload(this._gl, f.uniformsList, S, this.textures),
        (n.uniformsNeedUpdate = !1)),
      n.isSpriteMaterial && _.setValue(this._gl, "center", r.center),
      _.setValue(this._gl, "modelViewMatrix", r.modelViewMatrix),
      _.setValue(this._gl, "normalMatrix", r.normalMatrix),
      _.setValue(this._gl, "modelMatrix", r.matrixWorld),
      y
    );
  }
  markUniformsLightsNeedsUpdate(t, e) {
    (t.ambientLightColor.needsUpdate = e),
      (t.lightProbe.needsUpdate = e),
      (t.directionalLights.needsUpdate = e),
      (t.directionalLightShadows.needsUpdate = e),
      (t.pointLights.needsUpdate = e),
      (t.pointLightShadows.needsUpdate = e),
      (t.spotLights.needsUpdate = e),
      (t.spotLightShadows.needsUpdate = e),
      (t.rectAreaLights.needsUpdate = e),
      (t.hemisphereLights.needsUpdate = e);
  }
  materialNeedsLights(t) {
    return (
      t.isMeshLambertMaterial ||
      t.isMeshToonMaterial ||
      t.isMeshPhongMaterial ||
      t.isMeshStandardMaterial ||
      t.isShadowMaterial ||
      (t.isShaderMaterial && !0 === t.lights)
    );
  }
  getActiveCubeFace() {
    return this._currentActiveCubeFace;
  }
  getActiveMipmapLevel() {
    return this._currentActiveMipmapLevel;
  }
  getRenderTarget() {
    return this._currentRenderTarget;
  }
  setRenderTarget(t, e = 0, i = 0) {
    (this._currentRenderTarget = t),
      (this._currentActiveCubeFace = e),
      (this._currentActiveMipmapLevel = i),
      t &&
        void 0 === this.properties.get(t).__webglFramebuffer &&
        this.textures.setupRenderTarget(t);
    let n = null,
      r = !1,
      o = !1;
    if (t) {
      const i = t.texture;
      (i.isDataTexture3D || i.isDataTexture2DArray) && (o = !0);
      const a = this.properties.get(t).__webglFramebuffer;
      t.isWebGLCubeRenderTarget
        ? ((n = a[e]), (r = !0))
        : (n = t.isWebGLMultisampleRenderTarget
            ? this.properties.get(t).__webglMultisampledFramebuffer
            : a),
        this._currentViewport.copy(t.viewport),
        this._currentScissor.copy(t.scissor),
        (this._currentScissorTest = t.scissorTest);
    } else
      this._currentViewport
        .copy(this._viewport)
        .multiplyScalar(this._pixelRatio)
        .floor(),
        this._currentScissor
          .copy(this._scissor)
          .multiplyScalar(this._pixelRatio)
          .floor(),
        (this._currentScissorTest = this._scissorTest);
    if (
      this.state.bindFramebuffer(this._gl.FRAMEBUFFER, n) &&
      this.capabilities.drawBuffers
    ) {
      let e = !1;
      if (t)
        if (t.isWebGLMultipleRenderTargets) {
          const i = t.texture;
          if (
            this._currentDrawBuffers.length !== i.length ||
            this._currentDrawBuffers[0] !== this._gl.COLOR_ATTACHMENT0
          ) {
            for (let t = 0, e = i.length; t < e; t++)
              this._currentDrawBuffers[t] = this._gl.COLOR_ATTACHMENT0 + t;
            (this._currentDrawBuffers.length = i.length), (e = !0);
          }
        } else
          (1 === this._currentDrawBuffers.length &&
            this._currentDrawBuffers[0] === this._gl.COLOR_ATTACHMENT0) ||
            ((this._currentDrawBuffers[0] = this._gl.COLOR_ATTACHMENT0),
            (this._currentDrawBuffers.length = 1),
            (e = !0));
      else
        (1 === this._currentDrawBuffers.length &&
          this._currentDrawBuffers[0] === this._gl.BACK) ||
          ((this._currentDrawBuffers[0] = this._gl.BACK),
          (this._currentDrawBuffers.length = 1),
          (e = !0));
      e &&
        (this.capabilities.isWebGL2
          ? this._gl.drawBuffers(this._currentDrawBuffers)
          : this.extensions
              .get("WEBGL_draw_buffers")
              .drawBuffersWEBGL(this._currentDrawBuffers));
    }
    if (
      (this.state.viewport(this._currentViewport),
      this.state.scissor(this._currentScissor),
      this.state.setScissorTest(this._currentScissorTest),
      r)
    ) {
      const n = this.properties.get(t.texture);
      this._gl.framebufferTexture2D(
        this._gl.FRAMEBUFFER,
        this._gl.COLOR_ATTACHMENT0,
        this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + e,
        n.__webglTexture,
        i
      );
    } else if (o) {
      const n = this.properties.get(t.texture),
        r = e || 0;
      this._gl.framebufferTextureLayer(
        this._gl.FRAMEBUFFER,
        this._gl.COLOR_ATTACHMENT0,
        n.__webglTexture,
        i || 0,
        r
      );
    }
    this._currentMaterialId = -1;
  }
  readRenderTargetPixels(t, e, i, n, r, o, a) {
    if (!t || !t.isWebGLRenderTarget)
      return void console.error(
        "@dp/gis-engine: WebGLRenderer.readRenderTargetPixels: renderTarget is not WebGLRenderTarget."
      );
    let s = this.properties.get(t).__webglFramebuffer;
    if ((t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s)) {
      this.state.bindFramebuffer(this._gl.FRAMEBUFFER, s);
      try {
        const a = t.texture,
          s = a.format,
          l = a.type;
        if (
          s !== te &&
          this.utils.convert(s) !==
            this._gl.getParameter(this._gl.IMPLEMENTATION_COLOR_READ_FORMAT)
        )
          return void console.error(
            "@dp/gis-engine: WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
          );
        const u =
          l === Jt &&
          (this.extensions.has("EXT_color_buffer_half_float") ||
            (this.capabilities.isWebGL2 &&
              this.extensions.has("EXT_color_buffer_float")));
        if (
          !(
            l === Yt ||
            this.utils.convert(l) ===
              this._gl.getParameter(this._gl.IMPLEMENTATION_COLOR_READ_TYPE) ||
            (l === Zt &&
              (this.capabilities.isWebGL2 ||
                this.extensions.has("OES_texture_float") ||
                this.extensions.has("WEBGL_color_buffer_float"))) ||
            u
          )
        )
          return void console.error(
            "@dp/gis-engine: WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
          );
        this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER) ===
        this._gl.FRAMEBUFFER_COMPLETE
          ? e >= 0 &&
            e <= t.width - n &&
            i >= 0 &&
            i <= t.height - r &&
            this._gl.readPixels(
              e,
              i,
              n,
              r,
              this.utils.convert(s),
              this.utils.convert(l),
              o
            )
          : console.error(
              "@dp/gis-engine: WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
            );
      } finally {
        const t =
          null !== this._currentRenderTarget
            ? this.properties.get(this._currentRenderTarget).__webglFramebuffer
            : null;
        this.state.bindFramebuffer(this._gl.FRAMEBUFFER, t);
      }
    }
  }
  copyFramebufferToTexture(t, e, i = 0) {
    const n = Math.pow(2, -i),
      r = Math.floor(e.image.width * n),
      o = Math.floor(e.image.height * n);
    let a = this.utils.convert(e.format);
    this.capabilities.isWebGL2 &&
      (a === this._gl.RGB && (a = this._gl.RGB8),
      a === this._gl.RGBA && (a = this._gl.RGBA8)),
      this.textures.setTexture2D(e, 0),
      this._gl.copyTexImage2D(this._gl.TEXTURE_2D, i, a, t.x, t.y, r, o, 0),
      this.state.unbindTexture();
  }
  copyTextureToTexture(t, e, i, n = 0) {
    const r = e.image.width,
      o = e.image.height,
      a = this.utils.convert(i.format),
      s = this.utils.convert(i.type);
    this.textures.setTexture2D(i, 0),
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, i.flipY),
      this._gl.pixelStorei(
        this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        i.premultiplyAlpha
      ),
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, i.unpackAlignment),
      e.isDataTexture
        ? this._gl.texSubImage2D(
            this._gl.TEXTURE_2D,
            n,
            t.x,
            t.y,
            r,
            o,
            a,
            s,
            e.image.data
          )
        : e.isCompressedTexture
        ? this._gl.compressedTexSubImage2D(
            this._gl.TEXTURE_2D,
            n,
            t.x,
            t.y,
            e.mipmaps[0].width,
            e.mipmaps[0].height,
            a,
            e.mipmaps[0].data
          )
        : this._gl.texSubImage2D(
            this._gl.TEXTURE_2D,
            n,
            t.x,
            t.y,
            a,
            s,
            e.image
          ),
      0 === n &&
        i.generateMipmaps &&
        this._gl.generateMipmap(this._gl.TEXTURE_2D),
      this.state.unbindTexture();
  }
  copyTextureToTexture3D(t, e, i, n, r = 0) {
    if (this.isWebGL1Renderer) return;
    const o = t.max.x - t.min.x + 1,
      a = t.max.y - t.min.y + 1,
      s = t.max.z - t.min.z + 1,
      l = this.utils.convert(n.format),
      u = this.utils.convert(n.type);
    let c;
    if (n.isDataTexture3D)
      this.textures.setTexture3D(n, 0), (c = this._gl.TEXTURE_3D);
    else {
      if (!n.isDataTexture2DArray) return;
      this.textures.setTexture2DArray(n, 0), (c = this._gl.TEXTURE_2D_ARRAY);
    }
    this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, n.flipY),
      this._gl.pixelStorei(
        this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        n.premultiplyAlpha
      ),
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, n.unpackAlignment);
    const h = this._gl.getParameter(this._gl.UNPACK_ROW_LENGTH),
      p = this._gl.getParameter(this._gl.UNPACK_IMAGE_HEIGHT),
      d = this._gl.getParameter(this._gl.UNPACK_SKIP_PIXELS),
      f = this._gl.getParameter(this._gl.UNPACK_SKIP_ROWS),
      g = this._gl.getParameter(this._gl.UNPACK_SKIP_IMAGES),
      m = i.isCompressedTexture ? i.mipmaps[0] : i.image;
    this._gl.pixelStorei(this._gl.UNPACK_ROW_LENGTH, m.width),
      this._gl.pixelStorei(this._gl.UNPACK_IMAGE_HEIGHT, m.height),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_PIXELS, t.min.x),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_ROWS, t.min.y),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_IMAGES, t.min.z),
      i.isDataTexture || i.isDataTexture3D
        ? this._gl.texSubImage3D(c, r, e.x, e.y, e.z, o, a, s, l, u, m.data)
        : i.isCompressedTexture
        ? this._gl.compressedTexSubImage3D(
            c,
            r,
            e.x,
            e.y,
            e.z,
            o,
            a,
            s,
            l,
            m.data
          )
        : this._gl.texSubImage3D(c, r, e.x, e.y, e.z, o, a, s, l, u, m),
      this._gl.pixelStorei(this._gl.UNPACK_ROW_LENGTH, h),
      this._gl.pixelStorei(this._gl.UNPACK_IMAGE_HEIGHT, p),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_PIXELS, d),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_ROWS, f),
      this._gl.pixelStorei(this._gl.UNPACK_SKIP_IMAGES, g),
      0 === r && n.generateMipmaps && this._gl.generateMipmap(c),
      this.state.unbindTexture();
  }
  initTexture(t) {
    this.textures.setTexture2D(t, 0), this.state.unbindTexture();
  }
  resetState() {
    (this._currentActiveCubeFace = 0),
      (this._currentActiveMipmapLevel = 0),
      (this._currentRenderTarget = null),
      this.state.reset(),
      this.bindingStates.reset();
  }
}
class Ka extends Hi {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0);
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      null !== t.background && (this.background = t.background.clone()),
      null !== t.environment && (this.environment = t.environment.clone()),
      null !== t.fog && (this.fog = t.fog.clone()),
      null !== t.overrideMaterial &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.autoUpdate = t.autoUpdate),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
  }
}
class $a {
  constructor(t, e) {
    (this.isInterleavedBuffer = !0),
      (this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.usage = be),
      (this.updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.version = 0),
      (this.uuid = we());
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    );
  }
  copyAt(t, e, i) {
    (t *= this.stride), (i *= e.stride);
    for (let n = 0, r = this.stride; n < r; n++)
      this.array[t + n] = e.array[i + n];
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  clone(t) {
    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = we()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(e, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  toJSON(t) {
    return (
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = we()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const ts = new Ye();
class es {
  constructor(t, e, i, n = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = i),
      (this.normalized = !0 === n);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t;
  }
  applyMatrix4(t) {
    for (let e = 0, i = this.data.count; e < i; e++)
      (ts.x = this.getX(e)),
        (ts.y = this.getY(e)),
        (ts.z = this.getZ(e)),
        ts.applyMatrix4(t),
        this.setXYZ(e, ts.x, ts.y, ts.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, i = this.count; e < i; e++)
      (ts.x = this.getX(e)),
        (ts.y = this.getY(e)),
        (ts.z = this.getZ(e)),
        ts.applyNormalMatrix(t),
        this.setXYZ(e, ts.x, ts.y, ts.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, i = this.count; e < i; e++)
      (ts.x = this.getX(e)),
        (ts.y = this.getY(e)),
        (ts.z = this.getZ(e)),
        ts.transformDirection(t),
        this.setXYZ(e, ts.x, ts.y, ts.z);
    return this;
  }
  setX(t, e) {
    return (this.data.array[t * this.data.stride + this.offset] = e), this;
  }
  setY(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
  }
  setZ(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
  }
  setW(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
  }
  getX(t) {
    return this.data.array[t * this.data.stride + this.offset];
  }
  getY(t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  }
  getZ(t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  }
  getW(t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  }
  setXY(t, e, i) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = i),
      this
    );
  }
  setXYZ(t, e, i, n) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = i),
      (this.data.array[t + 2] = n),
      this
    );
  }
  setXYZW(t, e, i, n, r) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = i),
      (this.data.array[t + 2] = n),
      (this.data.array[t + 3] = r),
      this
    );
  }
  clone(t) {
    if (void 0 === t) {
      const t = [];
      for (let e = 0; e < this.count; e++) {
        const i = e * this.data.stride + this.offset;
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
      }
      return new gn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
      new es(
        t.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized
      )
    );
  }
  toJSON(t) {
    if (void 0 === t) {
      const t = [];
      for (let e = 0; e < this.count; e++) {
        const i = e * this.data.stride + this.offset;
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      }
    );
  }
}
class is extends Ge {
  constructor(t = null, e = 1, i = 1, n, r, o, a, s, l = 1003, u = 1003, c, h) {
    super(null, o, a, s, l, u, n, r, c, h),
      (this.isDataTexture = !0),
      (this.image = {
        data: t,
        width: e,
        height: i,
        colorSpace: "srgb",
      }),
      (this.magFilter = l),
      (this.minFilter = u),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
class ns extends gn {
  constructor(t, e, i, n = 1) {
    "number" == typeof i &&
      ((n = i),
      (i = !1),
      console.error(
        "@dp/gis-engine: InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      )),
      super(t, e, i),
      (this.meshPerAttribute = n),
      (this.isInstancedBufferAttribute = !0);
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    );
  }
}
const rs = new Mi(),
  os = new Mi(),
  as = [],
  ss = new Wn();
class ls extends Wn {
  constructor(t, e, i) {
    super(t, e),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new ns(new Float32Array(16 * i), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.frustumCulled = !1),
      (this.instanceUserData = []);
  }
  copy(t) {
    return (
      super.copy(t),
      this.instanceMatrix.copy(t.instanceMatrix),
      null !== t.instanceColor &&
        (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      this
    );
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, 3 * t);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t);
  }
  getUserDataAt(t) {
    return this.userData[t];
  }
  raycast(t, e) {
    const i = this.matrixWorld,
      n = this.count;
    if (
      ((ss.geometry = this.geometry),
      (ss.material = this.material),
      void 0 !== ss.material)
    )
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, rs),
          os.multiplyMatrices(i, rs),
          (ss.matrixWorld = os),
          ss.raycast(t, as);
        for (let t = 0, i = as.length; t < i; t++) {
          const i = as[t];
          (i.instanceId = r), (i.object = this), e.push(i);
        }
        as.length = 0;
      }
  }
  setColorAt(t, e) {
    null === this.instanceColor &&
      (this.instanceColor = new ns(
        new Float32Array(3 * this.instanceMatrix.count),
        3
      )),
      e.toArray(this.instanceColor.array, 3 * t);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t);
  }
  setUserDataAt(t, e) {
    this.userData[t] = e;
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
class us extends hn {
  constructor(t) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new ln(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      this
    );
  }
}
const cs = new Ye(),
  hs = new Ye(),
  ps = new Mi(),
  ds = new Si(),
  fs = new fi();
class gs extends Hi {
  constructor(t = new En(), e = new us()) {
    super(),
      (this.geometry = t),
      (this.material = e),
      (this.isLine = !0),
      (this.type = "Line"),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      if (null === t.index) {
        const e = t.attributes.position,
          i = [0];
        for (let t = 1, n = e.count; t < n; t++)
          cs.fromBufferAttribute(e, t - 1),
            hs.fromBufferAttribute(e, t),
            (i[t] = i[t - 1]),
            (i[t] += cs.distanceTo(hs));
        t.setAttribute("lineDistance", new bn(i, 1));
      }
    } else
      t.isGeometry &&
        console.error(
          "@dp/gis-engine: Line.computeLineDistances() no longer supports Geometry. Use BufferGeometry instead."
        );
    return this;
  }
  raycast(t, e) {
    const i = this.geometry,
      n = this.matrixWorld,
      r = t.params.Line.threshold,
      o = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      fs.copy(i.boundingSphere),
      fs.applyMatrix4(n),
      (fs.radius += r),
      !1 === t.ray.intersectsSphere(fs))
    )
      return;
    ps.copy(n).invert(), ds.copy(t.ray).applyMatrix4(ps);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = a * a,
      l = new Ye(),
      u = new Ye(),
      c = new Ye(),
      h = new Ye(),
      p = this.isLineSegments ? 2 : 1;
    if (i.isBufferGeometry) {
      const n = i.index,
        r = i.attributes.position;
      if (null !== n) {
        for (
          let i = Math.max(0, o.start),
            a = Math.min(n.count, o.start + o.count) - 1;
          i < a;
          i += p
        ) {
          const o = n.getX(i),
            a = n.getX(i + 1);
          l.fromBufferAttribute(r, o), u.fromBufferAttribute(r, a);
          if (ds.distanceSqToSegment(l, u, h, c) > s) continue;
          h.applyMatrix4(this.matrixWorld);
          const p = t.ray.origin.distanceTo(h);
          p < t.near ||
            p > t.far ||
            e.push({
              distance: p,
              point: c.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        for (
          let i = Math.max(0, o.start),
            n = Math.min(r.count, o.start + o.count) - 1;
          i < n;
          i += p
        ) {
          l.fromBufferAttribute(r, i), u.fromBufferAttribute(r, i + 1);
          if (ds.distanceSqToSegment(l, u, h, c) > s) continue;
          h.applyMatrix4(this.matrixWorld);
          const n = t.ray.origin.distanceTo(h);
          n < t.near ||
            n > t.far ||
            e.push({
              distance: n,
              point: c.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    } else
      i.isGeometry &&
        console.error(
          "@dp/gis-engine: Line.raycast() no longer supports Geometry. Use BufferGeometry instead."
        );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        i = Object.keys(e);
      if (i.length > 0) {
        const t = e[i[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[i] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "@dp/gis-engine: Line.updateMorphTargets() does not support Geometry. Use BufferGeometry instead."
        );
    }
  }
}
const ms = new Ye(),
  ys = new Ye();
class vs extends gs {
  constructor(t, e) {
    super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      if (null === t.index) {
        const e = t.attributes.position,
          i = [];
        for (let t = 0, n = e.count; t < n; t += 2)
          ms.fromBufferAttribute(e, t),
            ys.fromBufferAttribute(e, t + 1),
            (i[t] = 0 === t ? 0 : i[t - 1]),
            (i[t + 1] = i[t] + ms.distanceTo(ys));
        t.setAttribute("lineDistance", new bn(i, 1));
      }
    } else
      t.isGeometry &&
        console.error(
          "@dp/gis-engine: LineSegments.computeLineDistances() no longer supports Geometry. Use BufferGeometry instead."
        );
    return this;
  }
}
class bs extends hn {
  constructor(t) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new ln(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    );
  }
}
const xs = new Mi(),
  _s = new Si(),
  Ss = new fi(),
  Ms = new Ye();
class Cs extends Hi {
  constructor(t = new En(), e = new bs()) {
    super(),
      (this.geometry = t),
      (this.material = e),
      (this.isPoints = !0),
      (this.type = "Points"),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  raycast(t, e) {
    const i = this.geometry,
      n = this.matrixWorld,
      r = t.params.Points.threshold,
      o = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      Ss.copy(i.boundingSphere),
      Ss.applyMatrix4(n),
      (Ss.radius += r),
      !1 === t.ray.intersectsSphere(Ss))
    )
      return;
    xs.copy(n).invert(), _s.copy(t.ray).applyMatrix4(xs);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = a * a;
    if (i.isBufferGeometry) {
      const r = i.index,
        a = i.attributes.position;
      if (null !== r) {
        for (
          let i = Math.max(0, o.start),
            l = Math.min(r.count, o.start + o.count);
          i < l;
          i++
        ) {
          const o = r.getX(i);
          Ms.fromBufferAttribute(a, o), ws(Ms, o, s, n, t, e, this);
        }
      } else {
        for (
          let i = Math.max(0, o.start),
            r = Math.min(a.count, o.start + o.count);
          i < r;
          i++
        )
          Ms.fromBufferAttribute(a, i), ws(Ms, i, s, n, t, e, this);
      }
    } else
      console.error(
        "@dp/gis-engine: Points.raycast() no longer supports Geometry. Use BufferGeometry instead."
      );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        i = Object.keys(e);
      if (i.length > 0) {
        const t = e[i[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[i] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "@dp/gis-engine: Points.updateMorphTargets() does not support Geometry. Use BufferGeometry instead."
        );
    }
  }
}
function ws(t, e, i, n, r, o, a) {
  const s = _s.distanceSqToPoint(t);
  if (s < i) {
    const i = new Ye();
    _s.closestPointToPoint(t, i), i.applyMatrix4(n);
    const l = r.ray.origin.distanceTo(i);
    if (l < r.near || l > r.far) return;
    o.push({
      distance: l,
      distanceToRay: Math.sqrt(s),
      point: i,
      index: e,
      face: null,
      object: a,
    });
  }
}
class As extends Hi {
  constructor() {
    super(), (this.isGroup = !0);
  }
}
class Es extends Ge {
  constructor(t, e, i, n, r, o, a, s, l) {
    super(t, e, i, n, r, o, a, s, l),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
new Ye(), new Ye(), new Ye(), new tn();
class Ds {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint(t, e) {
    return null;
  }
  getPointAt(t, e) {
    const i = this.getUtoTmapping(t);
    return this.getPoint(i, e);
  }
  getPoints(t = 5) {
    const e = [];
    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    const e = [];
    for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
    return e;
  }
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === t + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let i,
      n = this.getPoint(0),
      r = 0;
    e.push(0);
    for (let o = 1; o <= t; o++)
      (i = this.getPoint(o / t)), (r += i.distanceTo(n)), e.push(r), (n = i);
    return (this.cacheArcLengths = e), e;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(t, e) {
    const i = this.getLengths();
    let n = 0;
    const r = i.length;
    let o;
    o = e || t * i[r - 1];
    let a,
      s = 0,
      l = r - 1;
    for (; s <= l; )
      if (((n = Math.floor(s + (l - s) / 2)), (a = i[n] - o), a < 0)) s = n + 1;
      else {
        if (!(a > 0)) {
          l = n;
          break;
        }
        l = n - 1;
      }
    if (((n = l), i[n] === o)) return n / (r - 1);
    const u = i[n];
    return (n + (o - u) / (i[n + 1] - u)) / (r - 1);
  }
  getTangent(t, e) {
    const i = 1e-4;
    let n = t - i,
      r = t + i;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const o = this.getPoint(n),
      a = this.getPoint(r),
      s = e || (o.isVector2 ? new Le() : new Ye());
    return s.copy(a).sub(o).normalize(), s;
  }
  getTangentAt(t, e) {
    const i = this.getUtoTmapping(t);
    return this.getTangent(i, e);
  }
  computeFrenetFrames(t, e) {
    const i = new Ye(),
      n = [],
      r = [],
      o = [],
      a = new Ye(),
      s = new Mi();
    for (let p = 0; p <= t; p++) {
      const e = p / t;
      n[p] = this.getTangentAt(e, new Ye());
    }
    (r[0] = new Ye()), (o[0] = new Ye());
    let l = Number.MAX_VALUE;
    const u = Math.abs(n[0].x),
      c = Math.abs(n[0].y),
      h = Math.abs(n[0].z);
    u <= l && ((l = u), i.set(1, 0, 0)),
      c <= l && ((l = c), i.set(0, 1, 0)),
      h <= l && i.set(0, 0, 1),
      a.crossVectors(n[0], i).normalize(),
      r[0].crossVectors(n[0], a),
      o[0].crossVectors(n[0], r[0]);
    for (let p = 1; p <= t; p++) {
      if (
        ((r[p] = r[p - 1].clone()),
        (o[p] = o[p - 1].clone()),
        a.crossVectors(n[p - 1], n[p]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const t = Math.acos(Ae(n[p - 1].dot(n[p]), -1, 1));
        r[p].applyMatrix4(s.makeRotationAxis(a, t));
      }
      o[p].crossVectors(n[p], r[p]);
    }
    if (!0 === e) {
      let e = Math.acos(Ae(r[0].dot(r[t]), -1, 1));
      (e /= t), n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
      for (let i = 1; i <= t; i++)
        r[i].applyMatrix4(s.makeRotationAxis(n[i], e * i)),
          o[i].crossVectors(n[i], r[i]);
    }
    return {
      tangents: n,
      normals: r,
      binormals: o,
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON",
      },
    };
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    );
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
}
class Ts extends Ds {
  constructor(
    t = 0,
    e = 0,
    i = 1,
    n = 1,
    r = 0,
    o = 2 * Math.PI,
    a = !1,
    s = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = i),
      (this.yRadius = n),
      (this.aStartAngle = r),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = s);
  }
  getPoint(t, e) {
    const i = e || new Le(),
      n = 2 * Math.PI;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += n;
    for (; r > n; ) r -= n;
    r < Number.EPSILON && (r = o ? 0 : n),
      !0 !== this.aClockwise || o || (r === n ? (r = -n) : (r -= n));
    const a = this.aStartAngle + t * r;
    let s = this.aX + this.xRadius * Math.cos(a),
      l = this.aY + this.yRadius * Math.sin(a);
    if (0 !== this.aRotation) {
      const t = Math.cos(this.aRotation),
        e = Math.sin(this.aRotation),
        i = s - this.aX,
        n = l - this.aY;
      (s = i * t - n * e + this.aX), (l = i * e + n * t + this.aY);
    }
    return i.set(s, l);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
}
class Ps {
  constructor() {
    (this.c0 = 0), (this.c1 = 0), (this.c2 = 0), (this.c3 = 0);
  }
  init(t, e, i, n) {
    (this.c0 = t),
      (this.c1 = i),
      (this.c2 = -3 * t + 3 * e - 2 * i - n),
      (this.c3 = 2 * t - 2 * e + i + n);
  }
  initCatmullRom(t, e, i, n, r) {
    this.init(e, i, r * (i - t), r * (n - e));
  }
  initNonuniformCatmullRom(t, e, i, n, r, o, a) {
    let s = (e - t) / r - (i - t) / (r + o) + (i - e) / o,
      l = (i - e) / o - (n - e) / (o + a) + (n - i) / a;
    (s *= o), (l *= o), this.init(e, i, s, l);
  }
  calc(t) {
    const e = t * t,
      i = e * t;
    return this.c0 + this.c1 * t + this.c2 * e + this.c3 * i;
  }
}
const Ls = new Ye(),
  Is = new Ps(),
  Ns = new Ps(),
  Rs = new Ps();
function Os(t, e, i, n, r) {
  const o = 0.5 * (n - e),
    a = 0.5 * (r - i),
    s = t * t;
  return (
    (2 * i - 2 * n + o + a) * (t * s) +
    (-3 * i + 3 * n - 2 * o - a) * s +
    o * t +
    i
  );
}
function Fs(t, e, i, n) {
  return (
    (function (t, e) {
      const i = 1 - t;
      return i * i * e;
    })(t, e) +
    (function (t, e) {
      return 2 * (1 - t) * t * e;
    })(t, i) +
    (function (t, e) {
      return t * t * e;
    })(t, n)
  );
}
function zs(t, e, i, n, r) {
  return (
    (function (t, e) {
      const i = 1 - t;
      return i * i * i * e;
    })(t, e) +
    (function (t, e) {
      const i = 1 - t;
      return 3 * i * i * t * e;
    })(t, i) +
    (function (t, e) {
      return 3 * (1 - t) * t * t * e;
    })(t, n) +
    (function (t, e) {
      return t * t * t * e;
    })(t, r)
  );
}
class ks extends Ds {
  constructor(t = new Le(), e = new Le(), i = new Le(), n = new Le()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = i),
      (this.v3 = n);
  }
  getPoint(t, e = new Le()) {
    const i = e,
      n = this.v0,
      r = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(zs(t, n.x, r.x, o.x, a.x), zs(t, n.y, r.y, o.y, a.y)), i;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class Bs extends Ds {
  constructor(t = new Ye(), e = new Ye(), i = new Ye(), n = new Ye()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = i),
      (this.v3 = n);
  }
  getPoint(t, e = new Ye()) {
    const i = e,
      n = this.v0,
      r = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        zs(t, n.x, r.x, o.x, a.x),
        zs(t, n.y, r.y, o.y, a.y),
        zs(t, n.z, r.z, o.z, a.z)
      ),
      i
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class Gs extends Ds {
  constructor(t = new Le(), e = new Le()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = t),
      (this.v2 = e);
  }
  getPoint(t, e = new Le()) {
    const i = e;
    return (
      1 === t
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)),
      i
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e) {
    const i = e || new Le();
    return i.copy(this.v2).sub(this.v1).normalize(), i;
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    );
  }
}
class Us extends Ds {
  constructor(t = new Le(), e = new Le(), i = new Le()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = i);
  }
  getPoint(t, e = new Le()) {
    const i = e,
      n = this.v0,
      r = this.v1,
      o = this.v2;
    return i.set(Fs(t, n.x, r.x, o.x), Fs(t, n.y, r.y, o.y)), i;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
class js extends Ds {
  constructor(t = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = t);
  }
  getPoint(t, e = new Le()) {
    const i = e,
      n = this.points,
      r = (n.length - 1) * t,
      o = Math.floor(r),
      a = r - o,
      s = n[0 === o ? o : o - 1],
      l = n[o],
      u = n[o > n.length - 2 ? n.length - 1 : o + 1],
      c = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return i.set(Os(a, s.x, l.x, u.x, c.x), Os(a, s.y, l.y, u.y, c.y)), i;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, i = t.points.length; e < i; e++) {
      const i = t.points[e];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, i = this.points.length; e < i; e++) {
      const i = this.points[e];
      t.points.push(i.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, i = t.points.length; e < i; e++) {
      const i = t.points[e];
      this.points.push(new Le().fromArray(i));
    }
    return this;
  }
}
var Hs = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ArcCurve: class extends Ts {
        constructor(t, e, i, n, r, o) {
          super(t, e, i, i, n, r, o),
            (this.isArcCurve = !0),
            (this.type = "ArcCurve");
        }
      },
      CatmullRomCurve3: class extends Ds {
        constructor(t = [], e = !1, i = "centripetal", n = 0.5) {
          super(),
            (this.isCatmullRomCurve3 = !0),
            (this.type = "CatmullRomCurve3"),
            (this.points = t),
            (this.closed = e),
            (this.curveType = i),
            (this.tension = n);
        }
        getPoint(t, e = new Ye()) {
          const i = e,
            n = this.points,
            r = n.length,
            o = (r - (this.closed ? 0 : 1)) * t;
          let a,
            s,
            l = Math.floor(o),
            u = o - l;
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
            : 0 === u && l === r - 1 && ((l = r - 2), (u = 1)),
            this.closed || l > 0
              ? (a = n[(l - 1) % r])
              : (Ls.subVectors(n[0], n[1]).add(n[0]), (a = Ls));
          const c = n[l % r],
            h = n[(l + 1) % r];
          if (
            (this.closed || l + 2 < r
              ? (s = n[(l + 2) % r])
              : (Ls.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), (s = Ls)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            const t = "chordal" === this.curveType ? 0.5 : 0.25;
            let e = Math.pow(a.distanceToSquared(c), t),
              i = Math.pow(c.distanceToSquared(h), t),
              n = Math.pow(h.distanceToSquared(s), t);
            i < 1e-4 && (i = 1),
              e < 1e-4 && (e = i),
              n < 1e-4 && (n = i),
              Is.initNonuniformCatmullRom(a.x, c.x, h.x, s.x, e, i, n),
              Ns.initNonuniformCatmullRom(a.y, c.y, h.y, s.y, e, i, n),
              Rs.initNonuniformCatmullRom(a.z, c.z, h.z, s.z, e, i, n);
          } else
            "catmullrom" === this.curveType &&
              (Is.initCatmullRom(a.x, c.x, h.x, s.x, this.tension),
              Ns.initCatmullRom(a.y, c.y, h.y, s.y, this.tension),
              Rs.initCatmullRom(a.z, c.z, h.z, s.z, this.tension));
          return i.set(Is.calc(u), Ns.calc(u), Rs.calc(u)), i;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(i.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e];
            t.points.push(i.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(new Ye().fromArray(i));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
      },
      CubicBezierCurve: ks,
      CubicBezierCurve3: Bs,
      EllipseCurve: Ts,
      LineCurve: Gs,
      LineCurve3: class extends Ds {
        constructor(t = new Ye(), e = new Ye()) {
          super(),
            (this.isLineCurve3 = !0),
            (this.type = "LineCurve3"),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new Ye()) {
          const i = e;
          return (
            1 === t
              ? i.copy(this.v2)
              : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(t).add(this.v1)),
            i
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      },
      QuadraticBezierCurve: Us,
      QuadraticBezierCurve3: class extends Ds {
        constructor(t = new Ye(), e = new Ye(), i = new Ye()) {
          super(),
            (this.isQuadraticBezierCurve3 = !0),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i);
        }
        getPoint(t, e = new Ye()) {
          const i = e,
            n = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            i.set(
              Fs(t, n.x, r.x, o.x),
              Fs(t, n.y, r.y, o.y),
              Fs(t, n.z, r.z, o.z)
            ),
            i
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      },
      SplineCurve: js,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
class Vs extends Ds {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Gs(e, t));
  }
  getPoint(t, e) {
    const i = t * this.getLength(),
      n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= i) {
        const t = n[r] - i,
          o = this.curves[r],
          a = o.getLength(),
          s = 0 === a ? 0 : 1 - t / a;
        return o.getPointAt(s, e);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      (e += this.curves[i].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let i;
    for (let n = 0, r = this.curves; n < r.length; n++) {
      const o = r[n],
        a =
          o && o.isEllipseCurve
            ? 2 * t
            : o && (o.isLineCurve || o.isLineCurve3)
            ? 1
            : o && o.isSplineCurve
            ? t * o.points.length
            : t,
        s = o.getPoints(a);
      for (let t = 0; t < s.length; t++) {
        const n = s[t];
        (i && i.equals(n)) || (e.push(n), (i = n));
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    );
  }
  copy(t) {
    super.copy(t), (this.curves = []);
    for (let e = 0, i = t.curves.length; e < i; e++) {
      const i = t.curves[e];
      this.curves.push(i.clone());
    }
    return (this.autoClose = t.autoClose), this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, i = this.curves.length; e < i; e++) {
      const i = this.curves[e];
      t.curves.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
    for (let e = 0, i = t.curves.length; e < i; e++) {
      const i = t.curves[e];
      this.curves.push(new Hs[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Ws extends Vs {
  constructor(t) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Le()),
      t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const i = new Gs(this.currentPoint.clone(), new Le(t, e));
    return this.curves.push(i), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, i, n) {
    const r = new Us(this.currentPoint.clone(), new Le(t, e), new Le(i, n));
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(t, e, i, n, r, o) {
    const a = new ks(
      this.currentPoint.clone(),
      new Le(t, e),
      new Le(i, n),
      new Le(r, o)
    );
    return this.curves.push(a), this.currentPoint.set(r, o), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      i = new js(e);
    return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, i, n, r, o = !1) {
    const a = this.currentPoint.x,
      s = this.currentPoint.y;
    return this.absarc(t + a, e + s, i, n, r, o), this;
  }
  absarc(t, e, i, n, r, o = !1) {
    return this.absellipse(t, e, i, i, n, r, o), this;
  }
  ellipse(t, e, i, n, r, o, a = !1, s = 0) {
    const l = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absellipse(t + l, e + u, i, n, r, o, a, s), this;
  }
  absellipse(t, e, i, n, r, o, a = !1, s = 0) {
    const l = new Ts(t, e, i, n, r, o, a, s);
    if (this.curves.length > 0) {
      const t = l.getPoint(0);
      t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.currentPoint = this.currentPoint.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class qs extends Ws {
  constructor(t) {
    super(t), (this.uuid = we()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(t) {
    const e = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      e[i] = this.holes[i].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t),
    };
  }
  copy(t) {
    super.copy(t), (this.holes = []);
    for (let e = 0, i = t.holes.length; e < i; e++) {
      const i = t.holes[e];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.uuid = this.uuid), (t.holes = []);
    for (let e = 0, i = this.holes.length; e < i; e++) {
      const i = this.holes[e];
      t.holes.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
    for (let e = 0, i = t.holes.length; e < i; e++) {
      const i = t.holes[e];
      this.holes.push(new Ws().fromJSON(i));
    }
    return this;
  }
}
function Ys(t, e) {
  return (function (t, e) {
    const i = t.toString(),
      n = i.lastIndexOf(".");
    return parseFloat(i.substring(0, e + n + 1));
  })(Math.random() * (e - t) + t, 2);
}
var Xs = {
  exports: {},
};
function Qs(t, e, i) {
  i = i || 2;
  var n,
    r,
    o,
    a,
    s,
    l,
    u,
    c = e && e.length,
    h = c ? e[0] * i : t.length,
    p = Zs(t, 0, h, i, !0),
    d = [];
  if (!p || p.next === p.prev) return d;
  if (
    (c &&
      (p = (function (t, e, i, n) {
        var r,
          o,
          a,
          s = [];
        for (r = 0, o = e.length; r < o; r++)
          (a = Zs(t, e[r] * n, r < o - 1 ? e[r + 1] * n : t.length, n, !1)) ===
            a.next && (a.steiner = !0),
            s.push(sl(a));
        for (s.sort(nl), r = 0; r < s.length; r++)
          i = Js((i = rl(s[r], i)), i.next);
        return i;
      })(t, e, p, i)),
    t.length > 80 * i)
  ) {
    (n = o = t[0]), (r = a = t[1]);
    for (var f = i; f < h; f += i)
      (s = t[f]) < n && (n = s),
        (l = t[f + 1]) < r && (r = l),
        s > o && (o = s),
        l > a && (a = l);
    u = 0 !== (u = Math.max(o - n, a - r)) ? 1 / u : 0;
  }
  return Ks(p, d, i, n, r, u), d;
}
function Zs(t, e, i, n, r) {
  var o, a;
  if (r === xl(t, e, i, n) > 0)
    for (o = e; o < i; o += n) a = yl(o, t[o], t[o + 1], a);
  else for (o = i - n; o >= e; o -= n) a = yl(o, t[o], t[o + 1], a);
  return a && hl(a, a.next) && (vl(a), (a = a.next)), a;
}
function Js(t, e) {
  if (!t) return t;
  e || (e = t);
  var i,
    n = t;
  do {
    if (
      ((i = !1), n.steiner || (!hl(n, n.next) && 0 !== cl(n.prev, n, n.next)))
    )
      n = n.next;
    else {
      if ((vl(n), (n = e = n.prev) === n.next)) break;
      i = !0;
    }
  } while (i || n !== e);
  return e;
}
function Ks(t, e, i, n, r, o, a) {
  if (t) {
    !a &&
      o &&
      (function (t, e, i, n) {
        var r = t;
        do {
          null === r.z && (r.z = al(r.x, r.y, e, i, n)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== t);
        (r.prevZ.nextZ = null),
          (r.prevZ = null),
          (function (t) {
            var e,
              i,
              n,
              r,
              o,
              a,
              s,
              l,
              u = 1;
            do {
              for (i = t, t = null, o = null, a = 0; i; ) {
                for (
                  a++, n = i, s = 0, e = 0;
                  e < u && (s++, (n = n.nextZ));
                  e++
                );
                for (l = u; s > 0 || (l > 0 && n); )
                  0 !== s && (0 === l || !n || i.z <= n.z)
                    ? ((r = i), (i = i.nextZ), s--)
                    : ((r = n), (n = n.nextZ), l--),
                    o ? (o.nextZ = r) : (t = r),
                    (r.prevZ = o),
                    (o = r);
                i = n;
              }
              (o.nextZ = null), (u *= 2);
            } while (a > 1);
          })(r);
      })(t, n, r, o);
    for (var s, l, u = t; t.prev !== t.next; )
      if (((s = t.prev), (l = t.next), o ? tl(t, n, r, o) : $s(t)))
        e.push(s.i / i),
          e.push(t.i / i),
          e.push(l.i / i),
          vl(t),
          (t = l.next),
          (u = l.next);
      else if ((t = l) === u) {
        a
          ? 1 === a
            ? Ks((t = el(Js(t), e, i)), e, i, n, r, o, 2)
            : 2 === a && il(t, e, i, n, r, o)
          : Ks(Js(t), e, i, n, r, o, 1);
        break;
      }
  }
}
function $s(t) {
  var e = t.prev,
    i = t,
    n = t.next;
  if (cl(e, i, n) >= 0) return !1;
  for (var r = t.next.next; r !== t.prev; ) {
    if (
      ll(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
      cl(r.prev, r, r.next) >= 0
    )
      return !1;
    r = r.next;
  }
  return !0;
}
function tl(t, e, i, n) {
  var r = t.prev,
    o = t,
    a = t.next;
  if (cl(r, o, a) >= 0) return !1;
  for (
    var s = r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
      l = r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
      u = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
      c = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
      h = al(s, l, e, i, n),
      p = al(u, c, e, i, n),
      d = t.prevZ,
      f = t.nextZ;
    d && d.z >= h && f && f.z <= p;

  ) {
    if (
      d !== t.prev &&
      d !== t.next &&
      ll(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
      cl(d.prev, d, d.next) >= 0
    )
      return !1;
    if (
      ((d = d.prevZ),
      f !== t.prev &&
        f !== t.next &&
        ll(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
        cl(f.prev, f, f.next) >= 0)
    )
      return !1;
    f = f.nextZ;
  }
  for (; d && d.z >= h; ) {
    if (
      d !== t.prev &&
      d !== t.next &&
      ll(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
      cl(d.prev, d, d.next) >= 0
    )
      return !1;
    d = d.prevZ;
  }
  for (; f && f.z <= p; ) {
    if (
      f !== t.prev &&
      f !== t.next &&
      ll(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
      cl(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.nextZ;
  }
  return !0;
}
function el(t, e, i) {
  var n = t;
  do {
    var r = n.prev,
      o = n.next.next;
    !hl(r, o) &&
      pl(r, n, n.next, o) &&
      gl(r, o) &&
      gl(o, r) &&
      (e.push(r.i / i),
      e.push(n.i / i),
      e.push(o.i / i),
      vl(n),
      vl(n.next),
      (n = t = o)),
      (n = n.next);
  } while (n !== t);
  return Js(n);
}
function il(t, e, i, n, r, o) {
  var a = t;
  do {
    for (var s = a.next.next; s !== a.prev; ) {
      if (a.i !== s.i && ul(a, s)) {
        var l = ml(a, s);
        return (
          (a = Js(a, a.next)),
          (l = Js(l, l.next)),
          Ks(a, e, i, n, r, o),
          void Ks(l, e, i, n, r, o)
        );
      }
      s = s.next;
    }
    a = a.next;
  } while (a !== t);
}
function nl(t, e) {
  return t.x - e.x;
}
function rl(t, e) {
  var i = (function (t, e) {
    var i,
      n = e,
      r = t.x,
      o = t.y,
      a = -1 / 0;
    do {
      if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
        var s = n.x + ((o - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
        if (s <= r && s > a) {
          if (((a = s), s === r)) {
            if (o === n.y) return n;
            if (o === n.next.y) return n.next;
          }
          i = n.x < n.next.x ? n : n.next;
        }
      }
      n = n.next;
    } while (n !== e);
    if (!i) return null;
    if (r === a) return i;
    var l,
      u = i,
      c = i.x,
      h = i.y,
      p = 1 / 0;
    n = i;
    do {
      r >= n.x &&
        n.x >= c &&
        r !== n.x &&
        ll(o < h ? r : a, o, c, h, o < h ? a : r, o, n.x, n.y) &&
        ((l = Math.abs(o - n.y) / (r - n.x)),
        gl(n, t) &&
          (l < p || (l === p && (n.x > i.x || (n.x === i.x && ol(i, n))))) &&
          ((i = n), (p = l))),
        (n = n.next);
    } while (n !== u);
    return i;
  })(t, e);
  if (!i) return e;
  var n = ml(i, t),
    r = Js(i, i.next);
  return Js(n, n.next), e === i ? r : e;
}
function ol(t, e) {
  return cl(t.prev, t, e.prev) < 0 && cl(e.next, t, t.next) < 0;
}
function al(t, e, i, n, r) {
  return (
    (t =
      1431655765 &
      ((t =
        858993459 &
        ((t =
          252645135 &
          ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
            (t << 4))) |
          (t << 2))) |
        (t << 1))) |
    ((e =
      1431655765 &
      ((e =
        858993459 &
        ((e =
          252645135 &
          ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
            (e << 4))) |
          (e << 2))) |
        (e << 1))) <<
      1)
  );
}
function sl(t) {
  var e = t,
    i = t;
  do {
    (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
  } while (e !== t);
  return i;
}
function ll(t, e, i, n, r, o, a, s) {
  return (
    (r - a) * (e - s) - (t - a) * (o - s) >= 0 &&
    (t - a) * (n - s) - (i - a) * (e - s) >= 0 &&
    (i - a) * (o - s) - (r - a) * (n - s) >= 0
  );
}
function ul(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !(function (t, e) {
      var i = t;
      do {
        if (
          i.i !== t.i &&
          i.next.i !== t.i &&
          i.i !== e.i &&
          i.next.i !== e.i &&
          pl(i, i.next, t, e)
        )
          return !0;
        i = i.next;
      } while (i !== t);
      return !1;
    })(t, e) &&
    ((gl(t, e) &&
      gl(e, t) &&
      (function (t, e) {
        var i = t,
          n = !1,
          r = (t.x + e.x) / 2,
          o = (t.y + e.y) / 2;
        do {
          i.y > o != i.next.y > o &&
            i.next.y !== i.y &&
            r < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
            (n = !n),
            (i = i.next);
        } while (i !== t);
        return n;
      })(t, e) &&
      (cl(t.prev, t, e.prev) || cl(t, e.prev, e))) ||
      (hl(t, e) && cl(t.prev, t, t.next) > 0 && cl(e.prev, e, e.next) > 0))
  );
}
function cl(t, e, i) {
  return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
}
function hl(t, e) {
  return t.x === e.x && t.y === e.y;
}
function pl(t, e, i, n) {
  var r = fl(cl(t, e, i)),
    o = fl(cl(t, e, n)),
    a = fl(cl(i, n, t)),
    s = fl(cl(i, n, e));
  return (
    (r !== o && a !== s) ||
    !(0 !== r || !dl(t, i, e)) ||
    !(0 !== o || !dl(t, n, e)) ||
    !(0 !== a || !dl(i, t, n)) ||
    !(0 !== s || !dl(i, e, n))
  );
}
function dl(t, e, i) {
  return (
    e.x <= Math.max(t.x, i.x) &&
    e.x >= Math.min(t.x, i.x) &&
    e.y <= Math.max(t.y, i.y) &&
    e.y >= Math.min(t.y, i.y)
  );
}
function fl(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function gl(t, e) {
  return cl(t.prev, t, t.next) < 0
    ? cl(t, e, t.next) >= 0 && cl(t, t.prev, e) >= 0
    : cl(t, e, t.prev) < 0 || cl(t, t.next, e) < 0;
}
function ml(t, e) {
  var i = new bl(t.i, t.x, t.y),
    n = new bl(e.i, e.x, e.y),
    r = t.next,
    o = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (i.next = r),
    (r.prev = i),
    (n.next = i),
    (i.prev = n),
    (o.next = n),
    (n.prev = o),
    n
  );
}
function yl(t, e, i, n) {
  var r = new bl(t, e, i);
  return (
    n
      ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function vl(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function bl(t, e, i) {
  (this.i = t),
    (this.x = e),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function xl(t, e, i, n) {
  for (var r = 0, o = e, a = i - n; o < i; o += n)
    (r += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
  return r;
}
(Xs.exports = Qs),
  (Xs.exports.default = Qs),
  (Qs.deviation = function (t, e, i, n) {
    var r = e && e.length,
      o = r ? e[0] * i : t.length,
      a = Math.abs(xl(t, 0, o, i));
    if (r)
      for (var s = 0, l = e.length; s < l; s++) {
        var u = e[s] * i,
          c = s < l - 1 ? e[s + 1] * i : t.length;
        a -= Math.abs(xl(t, u, c, i));
      }
    var h = 0;
    for (s = 0; s < n.length; s += 3) {
      var p = n[s] * i,
        d = n[s + 1] * i,
        f = n[s + 2] * i;
      h += Math.abs(
        (t[p] - t[f]) * (t[d + 1] - t[p + 1]) -
          (t[p] - t[d]) * (t[f + 1] - t[p + 1])
      );
    }
    return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a);
  }),
  (Qs.flatten = function (t) {
    for (
      var e = t[0][0].length,
        i = {
          vertices: [],
          holes: [],
          dimensions: e,
        },
        n = 0,
        r = 0;
      r < t.length;
      r++
    ) {
      for (var o = 0; o < t[r].length; o++)
        for (var a = 0; a < e; a++) i.vertices.push(t[r][o][a]);
      r > 0 && ((n += t[r - 1].length), i.holes.push(n));
    }
    return i;
  });
var _l = Xs.exports,
  Sl =
    "object" == typeof global && global && global.Object === Object && global,
  Ml = "object" == typeof self && self && self.Object === Object && self,
  Cl = Sl || Ml || Function("return this")(),
  wl = Cl.Symbol,
  Al = Object.prototype,
  El = Al.hasOwnProperty,
  Dl = Al.toString,
  Tl = wl ? wl.toStringTag : void 0;
var Pl = Object.prototype.toString;
var Ll = "[object Null]",
  Il = "[object Undefined]",
  Nl = wl ? wl.toStringTag : void 0;
function Rl(t) {
  return null == t
    ? void 0 === t
      ? Il
      : Ll
    : Nl && Nl in Object(t)
    ? (function (t) {
        var e = El.call(t, Tl),
          i = t[Tl];
        try {
          t[Tl] = void 0;
          var n = !0;
        } catch (o) {}
        var r = Dl.call(t);
        return n && (e ? (t[Tl] = i) : delete t[Tl]), r;
      })(t)
    : (function (t) {
        return Pl.call(t);
      })(t);
}
function Ol(t) {
  return null != t && "object" == typeof t;
}
var Fl = "[object Symbol]";
function zl(t) {
  return "symbol" == typeof t || (Ol(t) && Rl(t) == Fl);
}
var kl = Array.isArray,
  Bl = /\s/;
var Gl = /^\s+/;
function Ul(t) {
  return t
    ? t
        .slice(
          0,
          (function (t) {
            for (var e = t.length; e-- && Bl.test(t.charAt(e)); );
            return e;
          })(t) + 1
        )
        .replace(Gl, "")
    : t;
}
function jl(t) {
  var e = typeof t;
  return null != t && ("object" == e || "function" == e);
}
var Hl = NaN,
  Vl = /^[-+]0x[0-9a-f]+$/i,
  Wl = /^0b[01]+$/i,
  ql = /^0o[0-7]+$/i,
  Yl = parseInt;
var Xl = 1 / 0,
  Ql = 17976931348623157e292;
function Zl(t) {
  return t
    ? (t = (function (t) {
        if ("number" == typeof t) return t;
        if (zl(t)) return Hl;
        if (jl(t)) {
          var e = "function" == typeof t.valueOf ? t.valueOf() : t;
          t = jl(e) ? e + "" : e;
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = Ul(t);
        var i = Wl.test(t);
        return i || ql.test(t)
          ? Yl(t.slice(2), i ? 2 : 8)
          : Vl.test(t)
          ? Hl
          : +t;
      })(t)) === Xl || t === -Xl
      ? (t < 0 ? -1 : 1) * Ql
      : t == t
      ? t
      : 0
    : 0 === t
    ? t
    : 0;
}
function Jl(t) {
  var e = Zl(t),
    i = e % 1;
  return e == e ? (i ? e - i : e) : 0;
}
function Kl(t) {
  return t;
}
var $l = "[object AsyncFunction]",
  tu = "[object Function]",
  eu = "[object GeneratorFunction]",
  iu = "[object Proxy]";
function nu(t) {
  if (!jl(t)) return !1;
  var e = Rl(t);
  return e == tu || e == eu || e == $l || e == iu;
}
var ru,
  ou = Cl["__core-js_shared__"],
  au = (ru = /[^.]+$/.exec((ou && ou.keys && ou.keys.IE_PROTO) || ""))
    ? "Symbol(src)_1." + ru
    : "";
var su = Function.prototype.toString;
function lu(t) {
  if (null != t) {
    try {
      return su.call(t);
    } catch (e) {}
    try {
      return t + "";
    } catch (e) {}
  }
  return "";
}
var uu = /^\[object .+?Constructor\]$/,
  cu = Function.prototype,
  hu = Object.prototype,
  pu = cu.toString,
  du = hu.hasOwnProperty,
  fu = RegExp(
    "^" +
      pu
        .call(du)
        .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function gu(t) {
  return !(!jl(t) || ((e = t), au && au in e)) && (nu(t) ? fu : uu).test(lu(t));
  var e;
}
function mu(t, e) {
  var i = (function (t, e) {
    return null == t ? void 0 : t[e];
  })(t, e);
  return gu(i) ? i : void 0;
}
var yu = mu(Cl, "WeakMap"),
  vu = yu && new yu(),
  bu = vu
    ? function (t, e) {
        return vu.set(t, e), t;
      }
    : Kl,
  xu = bu,
  _u = Object.create,
  Su = (function () {
    function t() {}
    return function (e) {
      if (!jl(e)) return {};
      if (_u) return _u(e);
      t.prototype = e;
      var i = new t();
      return (t.prototype = void 0), i;
    };
  })(),
  Mu = Su;
function Cu(t) {
  return function () {
    var e = arguments;
    switch (e.length) {
      case 0:
        return new t();
      case 1:
        return new t(e[0]);
      case 2:
        return new t(e[0], e[1]);
      case 3:
        return new t(e[0], e[1], e[2]);
      case 4:
        return new t(e[0], e[1], e[2], e[3]);
      case 5:
        return new t(e[0], e[1], e[2], e[3], e[4]);
      case 6:
        return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
      case 7:
        return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6]);
    }
    var i = Mu(t.prototype),
      n = t.apply(i, e);
    return jl(n) ? n : i;
  };
}
var wu = 1;
function Au(t, e, i) {
  switch (i.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, i[0]);
    case 2:
      return t.call(e, i[0], i[1]);
    case 3:
      return t.call(e, i[0], i[1], i[2]);
  }
  return t.apply(e, i);
}
var Eu = Math.max;
function Du(t, e, i, n) {
  for (
    var r = -1,
      o = t.length,
      a = i.length,
      s = -1,
      l = e.length,
      u = Eu(o - a, 0),
      c = Array(l + u),
      h = !n;
    ++s < l;

  )
    c[s] = e[s];
  for (; ++r < a; ) (h || r < o) && (c[i[r]] = t[r]);
  for (; u--; ) c[s++] = t[r++];
  return c;
}
var Tu = Math.max;
function Pu(t, e, i, n) {
  for (
    var r = -1,
      o = t.length,
      a = -1,
      s = i.length,
      l = -1,
      u = e.length,
      c = Tu(o - s, 0),
      h = Array(c + u),
      p = !n;
    ++r < c;

  )
    h[r] = t[r];
  for (var d = r; ++l < u; ) h[d + l] = e[l];
  for (; ++a < s; ) (p || r < o) && (h[d + i[a]] = t[r++]);
  return h;
}
function Lu() {}
var Iu = 4294967295;
function Nu(t) {
  (this.__wrapped__ = t),
    (this.__actions__ = []),
    (this.__dir__ = 1),
    (this.__filtered__ = !1),
    (this.__iteratees__ = []),
    (this.__takeCount__ = Iu),
    (this.__views__ = []);
}
(Nu.prototype = Mu(Lu.prototype)), (Nu.prototype.constructor = Nu);
var Ru = vu
    ? function (t) {
        return vu.get(t);
      }
    : function () {},
  Ou = Ru,
  Fu = {},
  zu = Object.prototype.hasOwnProperty;
function ku(t, e) {
  (this.__wrapped__ = t),
    (this.__actions__ = []),
    (this.__chain__ = !!e),
    (this.__index__ = 0),
    (this.__values__ = void 0);
}
function Bu(t, e) {
  var i = -1,
    n = t.length;
  for (e || (e = Array(n)); ++i < n; ) e[i] = t[i];
  return e;
}
(ku.prototype = Mu(Lu.prototype)), (ku.prototype.constructor = ku);
var Gu = Object.prototype.hasOwnProperty;
function Uu(t) {
  if (Ol(t) && !kl(t) && !(t instanceof Nu)) {
    if (t instanceof ku) return t;
    if (Gu.call(t, "__wrapped__"))
      return (function (t) {
        if (t instanceof Nu) return t.clone();
        var e = new ku(t.__wrapped__, t.__chain__);
        return (
          (e.__actions__ = Bu(t.__actions__)),
          (e.__index__ = t.__index__),
          (e.__values__ = t.__values__),
          e
        );
      })(t);
  }
  return new ku(t);
}
function ju(t) {
  var e = (function (t) {
      for (
        var e = t.name + "", i = Fu[e], n = zu.call(Fu, e) ? i.length : 0;
        n--;

      ) {
        var r = i[n],
          o = r.func;
        if (null == o || o == t) return r.name;
      }
      return e;
    })(t),
    i = Uu[e];
  if ("function" != typeof i || !(e in Nu.prototype)) return !1;
  if (t === i) return !0;
  var n = Ou(i);
  return !!n && t === n[0];
}
(Uu.prototype = Lu.prototype), (Uu.prototype.constructor = Uu);
var Hu = Date.now;
function Vu(t) {
  var e = 0,
    i = 0;
  return function () {
    var n = Hu(),
      r = 16 - (n - i);
    if (((i = n), r > 0)) {
      if (++e >= 800) return arguments[0];
    } else e = 0;
    return t.apply(void 0, arguments);
  };
}
var Wu = Vu(xu),
  qu = /\{\n\/\* \[wrapped with (.+)\] \*/,
  Yu = /,? & /;
var Xu = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
var Qu = (function () {
    try {
      var t = mu(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch (e) {}
  })(),
  Zu = Qu,
  Ju = Zu
    ? function (t, e) {
        return Zu(t, "toString", {
          configurable: !0,
          enumerable: !1,
          value:
            ((i = e),
            function () {
              return i;
            }),
          writable: !0,
        });
        var i;
      }
    : Kl,
  Ku = Vu(Ju);
function $u(t, e) {
  for (
    var i = -1, n = null == t ? 0 : t.length;
    ++i < n && !1 !== e(t[i], i, t);

  );
  return t;
}
function tc(t) {
  return t != t;
}
function ec(t, e) {
  return (
    !!(null == t ? 0 : t.length) &&
    (function (t, e, i) {
      return e == e
        ? (function (t, e, i) {
            for (var n = i - 1, r = t.length; ++n < r; )
              if (t[n] === e) return n;
            return -1;
          })(t, e, i)
        : (function (t, e, i, n) {
            for (var r = t.length, o = i + (n ? 1 : -1); n ? o-- : ++o < r; )
              if (e(t[o], o, t)) return o;
            return -1;
          })(t, tc, i);
    })(t, e, 0) > -1
  );
}
var ic = [
  ["ary", 128],
  ["bind", 1],
  ["bindKey", 2],
  ["curry", 8],
  ["curryRight", 16],
  ["flip", 512],
  ["partial", 32],
  ["partialRight", 64],
  ["rearg", 256],
];
function nc(t, e, i) {
  var n = e + "";
  return Ku(
    t,
    (function (t, e) {
      var i = e.length;
      if (!i) return t;
      var n = i - 1;
      return (
        (e[n] = (i > 1 ? "& " : "") + e[n]),
        (e = e.join(i > 2 ? ", " : " ")),
        t.replace(Xu, "{\n/* [wrapped with " + e + "] */\n")
      );
    })(
      n,
      (function (t, e) {
        return (
          $u(ic, function (i) {
            var n = "_." + i[0];
            e & i[1] && !ec(t, n) && t.push(n);
          }),
          t.sort()
        );
      })(
        (function (t) {
          var e = t.match(qu);
          return e ? e[1].split(Yu) : [];
        })(n),
        i
      )
    )
  );
}
var rc = 1,
  oc = 2,
  ac = 4,
  sc = 8,
  lc = 32,
  uc = 64;
function cc(t, e, i, n, r, o, a, s, l, u) {
  var c = e & sc;
  (e |= c ? lc : uc), (e &= ~(c ? uc : lc)) & ac || (e &= ~(rc | oc));
  var h = [
      t,
      e,
      r,
      c ? o : void 0,
      c ? a : void 0,
      c ? void 0 : o,
      c ? void 0 : a,
      s,
      l,
      u,
    ],
    p = i.apply(void 0, h);
  return ju(t) && Wu(p, h), (p.placeholder = n), nc(p, t, e);
}
function hc(t) {
  return t.placeholder;
}
var pc = 9007199254740991,
  dc = /^(?:0|[1-9]\d*)$/;
function fc(t, e) {
  var i = typeof t;
  return (
    !!(e = null == e ? pc : e) &&
    ("number" == i || ("symbol" != i && dc.test(t))) &&
    t > -1 &&
    t % 1 == 0 &&
    t < e
  );
}
var gc = Math.min;
var mc = "__lodash_placeholder__";
function yc(t, e) {
  for (var i = -1, n = t.length, r = 0, o = []; ++i < n; ) {
    var a = t[i];
    (a !== e && a !== mc) || ((t[i] = mc), (o[r++] = i));
  }
  return o;
}
var vc = 1,
  bc = 2,
  xc = 8,
  _c = 16,
  Sc = 128,
  Mc = 512;
function Cc(t, e, i, n, r, o, a, s, l, u) {
  var c = e & Sc,
    h = e & vc,
    p = e & bc,
    d = e & (xc | _c),
    f = e & Mc,
    g = p ? void 0 : Cu(t);
  return function m() {
    for (var y = arguments.length, v = Array(y), b = y; b--; )
      v[b] = arguments[b];
    if (d)
      var x = hc(m),
        _ = (function (t, e) {
          for (var i = t.length, n = 0; i--; ) t[i] === e && ++n;
          return n;
        })(v, x);
    if (
      (n && (v = Du(v, n, r, d)),
      o && (v = Pu(v, o, a, d)),
      (y -= _),
      d && y < u)
    ) {
      var S = yc(v, x);
      return cc(t, e, Cc, m.placeholder, i, v, S, s, l, u - y);
    }
    var M = h ? i : this,
      C = p ? M[t] : t;
    return (
      (y = v.length),
      s
        ? (v = (function (t, e) {
            for (var i = t.length, n = gc(e.length, i), r = Bu(t); n--; ) {
              var o = e[n];
              t[n] = fc(o, i) ? r[o] : void 0;
            }
            return t;
          })(v, s))
        : f && y > 1 && v.reverse(),
      c && l < y && (v.length = l),
      this && this !== Cl && this instanceof m && (C = g || Cu(C)),
      C.apply(M, v)
    );
  };
}
var wc = 1;
var Ac = "__lodash_placeholder__",
  Ec = 1,
  Dc = 2,
  Tc = 4,
  Pc = 8,
  Lc = 128,
  Ic = 256,
  Nc = Math.min;
var Rc = "Expected a function",
  Oc = 1,
  Fc = 2,
  zc = 8,
  kc = 16,
  Bc = 32,
  Gc = 64,
  Uc = Math.max;
function jc(t, e, i, n, r, o, a, s) {
  var l = e & Fc;
  if (!l && "function" != typeof t) throw new TypeError(Rc);
  var u = n ? n.length : 0;
  if (
    (u || ((e &= ~(Bc | Gc)), (n = r = void 0)),
    (a = void 0 === a ? a : Uc(Jl(a), 0)),
    (s = void 0 === s ? s : Jl(s)),
    (u -= r ? r.length : 0),
    e & Gc)
  ) {
    var c = n,
      h = r;
    n = r = void 0;
  }
  var p = l ? void 0 : Ou(t),
    d = [t, e, i, n, r, c, h, o, a, s];
  if (
    (p &&
      (function (t, e) {
        var i = t[1],
          n = e[1],
          r = i | n,
          o = r < (Ec | Dc | Lc),
          a =
            (n == Lc && i == Pc) ||
            (n == Lc && i == Ic && t[7].length <= e[8]) ||
            (n == (Lc | Ic) && e[7].length <= e[8] && i == Pc);
        if (!o && !a) return t;
        n & Ec && ((t[2] = e[2]), (r |= i & Ec ? 0 : Tc));
        var s = e[3];
        if (s) {
          var l = t[3];
          (t[3] = l ? Du(l, s, e[4]) : s), (t[4] = l ? yc(t[3], Ac) : e[4]);
        }
        (s = e[5]) &&
          ((l = t[5]),
          (t[5] = l ? Pu(l, s, e[6]) : s),
          (t[6] = l ? yc(t[5], Ac) : e[6])),
          (s = e[7]) && (t[7] = s),
          n & Lc && (t[8] = null == t[8] ? e[8] : Nc(t[8], e[8])),
          null == t[9] && (t[9] = e[9]),
          (t[0] = e[0]),
          (t[1] = r);
      })(d, p),
    (t = d[0]),
    (e = d[1]),
    (i = d[2]),
    (n = d[3]),
    (r = d[4]),
    !(s = d[9] = void 0 === d[9] ? (l ? 0 : t.length) : Uc(d[9] - u, 0)) &&
      e & (zc | kc) &&
      (e &= ~(zc | kc)),
    e && e != Oc)
  )
    f =
      e == zc || e == kc
        ? (function (t, e, i) {
            var n = Cu(t);
            return function r() {
              for (
                var o = arguments.length, a = Array(o), s = o, l = hc(r);
                s--;

              )
                a[s] = arguments[s];
              var u = o < 3 && a[0] !== l && a[o - 1] !== l ? [] : yc(a, l);
              return (o -= u.length) < i
                ? cc(
                    t,
                    e,
                    Cc,
                    r.placeholder,
                    void 0,
                    a,
                    u,
                    void 0,
                    void 0,
                    i - o
                  )
                : Au(this && this !== Cl && this instanceof r ? n : t, this, a);
            };
          })(t, e, s)
        : (e != Bc && e != (Oc | Bc)) || r.length
        ? Cc.apply(void 0, d)
        : (function (t, e, i, n) {
            var r = e & wc,
              o = Cu(t);
            return function e() {
              for (
                var a = -1,
                  s = arguments.length,
                  l = -1,
                  u = n.length,
                  c = Array(u + s),
                  h = this && this !== Cl && this instanceof e ? o : t;
                ++l < u;

              )
                c[l] = n[l];
              for (; s--; ) c[l++] = arguments[++a];
              return Au(h, r ? i : this, c);
            };
          })(t, e, i, n);
  else
    var f = (function (t, e, i) {
      var n = e & wu,
        r = Cu(t);
      return function e() {
        return (this && this !== Cl && this instanceof e ? r : t).apply(
          n ? i : this,
          arguments
        );
      };
    })(t, e, i);
  return nc((p ? xu : Wu)(f, d), t, e);
}
function Hc(t, e, i) {
  "__proto__" == e && Zu
    ? Zu(t, e, {
        configurable: !0,
        enumerable: !0,
        value: i,
        writable: !0,
      })
    : (t[e] = i);
}
function Vc(t, e) {
  return t === e || (t != t && e != e);
}
var Wc = Object.prototype.hasOwnProperty;
function qc(t, e, i) {
  var n = t[e];
  (Wc.call(t, e) && Vc(n, i) && (void 0 !== i || e in t)) || Hc(t, e, i);
}
function Yc(t, e, i, n) {
  var r = !i;
  i || (i = {});
  for (var o = -1, a = e.length; ++o < a; ) {
    var s = e[o],
      l = n ? n(i[s], t[s], s, i, t) : void 0;
    void 0 === l && (l = t[s]), r ? Hc(i, s, l) : qc(i, s, l);
  }
  return i;
}
var Xc = Math.max;
function Qc(t, e) {
  return Ku(
    (function (t, e, i) {
      return (
        (e = Xc(void 0 === e ? t.length - 1 : e, 0)),
        function () {
          for (
            var n = arguments, r = -1, o = Xc(n.length - e, 0), a = Array(o);
            ++r < o;

          )
            a[r] = n[e + r];
          r = -1;
          for (var s = Array(e + 1); ++r < e; ) s[r] = n[r];
          return (s[e] = i(a)), Au(t, this, s);
        }
      );
    })(t, e, Kl),
    t + ""
  );
}
var Zc = 9007199254740991;
function Jc(t) {
  return "number" == typeof t && t > -1 && t % 1 == 0 && t <= Zc;
}
function Kc(t) {
  return null != t && Jc(t.length) && !nu(t);
}
function $c(t) {
  return Qc(function (e, i) {
    var n = -1,
      r = i.length,
      o = r > 1 ? i[r - 1] : void 0,
      a = r > 2 ? i[2] : void 0;
    for (
      o = t.length > 3 && "function" == typeof o ? (r--, o) : void 0,
        a &&
          (function (t, e, i) {
            if (!jl(i)) return !1;
            var n = typeof e;
            return (
              !!("number" == n
                ? Kc(i) && fc(e, i.length)
                : "string" == n && (e in i)) && Vc(i[e], t)
            );
          })(i[0], i[1], a) &&
          ((o = r < 3 ? void 0 : o), (r = 1)),
        e = Object(e);
      ++n < r;

    ) {
      var s = i[n];
      s && t(e, s, n, o);
    }
    return e;
  });
}
var th = Object.prototype;
function eh(t) {
  var e = t && t.constructor;
  return t === (("function" == typeof e && e.prototype) || th);
}
function ih(t) {
  return Ol(t) && "[object Arguments]" == Rl(t);
}
var nh = Object.prototype,
  rh = nh.hasOwnProperty,
  oh = nh.propertyIsEnumerable,
  ah = ih(
    (function () {
      return arguments;
    })()
  )
    ? ih
    : function (t) {
        return Ol(t) && rh.call(t, "callee") && !oh.call(t, "callee");
      };
var sh = "object" == typeof exports && exports && !exports.nodeType && exports,
  lh = sh && "object" == typeof module && module && !module.nodeType && module,
  uh = lh && lh.exports === sh ? Cl.Buffer : void 0,
  ch =
    (uh ? uh.isBuffer : void 0) ||
    function () {
      return !1;
    },
  hh = {};
function ph(t) {
  return function (e) {
    return t(e);
  };
}
(hh["[object Float32Array]"] =
  hh["[object Float64Array]"] =
  hh["[object Int8Array]"] =
  hh["[object Int16Array]"] =
  hh["[object Int32Array]"] =
  hh["[object Uint8Array]"] =
  hh["[object Uint8ClampedArray]"] =
  hh["[object Uint16Array]"] =
  hh["[object Uint32Array]"] =
    !0),
  (hh["[object Arguments]"] =
    hh["[object Array]"] =
    hh["[object ArrayBuffer]"] =
    hh["[object Boolean]"] =
    hh["[object DataView]"] =
    hh["[object Date]"] =
    hh["[object Error]"] =
    hh["[object Function]"] =
    hh["[object Map]"] =
    hh["[object Number]"] =
    hh["[object Object]"] =
    hh["[object RegExp]"] =
    hh["[object Set]"] =
    hh["[object String]"] =
    hh["[object WeakMap]"] =
      !1);
var dh = "object" == typeof exports && exports && !exports.nodeType && exports,
  fh = dh && "object" == typeof module && module && !module.nodeType && module,
  gh = fh && fh.exports === dh && Sl.process,
  mh = (function () {
    try {
      var t = fh && fh.require && fh.require("util").types;
      return t || (gh && gh.binding && gh.binding("util"));
    } catch (e) {}
  })(),
  yh = mh && mh.isTypedArray,
  vh = yh
    ? ph(yh)
    : function (t) {
        return Ol(t) && Jc(t.length) && !!hh[Rl(t)];
      },
  bh = Object.prototype.hasOwnProperty;
function xh(t, e) {
  var i = kl(t),
    n = !i && ah(t),
    r = !i && !n && ch(t),
    o = !i && !n && !r && vh(t),
    a = i || n || r || o,
    s = a
      ? (function (t, e) {
          for (var i = -1, n = Array(t); ++i < t; ) n[i] = e(i);
          return n;
        })(t.length, String)
      : [],
    l = s.length;
  for (var u in t)
    (!e && !bh.call(t, u)) ||
      (a &&
        ("length" == u ||
          (r && ("offset" == u || "parent" == u)) ||
          (o && ("buffer" == u || "byteLength" == u || "byteOffset" == u)) ||
          fc(u, l))) ||
      s.push(u);
  return s;
}
function _h(t, e) {
  return function (i) {
    return t(e(i));
  };
}
var Sh = _h(Object.keys, Object),
  Mh = Object.prototype.hasOwnProperty;
function Ch(t) {
  return Kc(t)
    ? xh(t)
    : (function (t) {
        if (!eh(t)) return Sh(t);
        var e = [];
        for (var i in Object(t))
          Mh.call(t, i) && "constructor" != i && e.push(i);
        return e;
      })(t);
}
var wh = Object.prototype.hasOwnProperty;
function Ah(t) {
  if (!jl(t))
    return (function (t) {
      var e = [];
      if (null != t) for (var i in Object(t)) e.push(i);
      return e;
    })(t);
  var e = eh(t),
    i = [];
  for (var n in t) ("constructor" != n || (!e && wh.call(t, n))) && i.push(n);
  return i;
}
function Eh(t) {
  return Kc(t) ? xh(t, !0) : Ah(t);
}
var Dh = mu(Object, "create");
var Th = Object.prototype.hasOwnProperty;
var Ph = Object.prototype.hasOwnProperty;
function Lh(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
function Ih(t, e) {
  for (var i = t.length; i--; ) if (Vc(t[i][0], e)) return i;
  return -1;
}
(Lh.prototype.clear = function () {
  (this.__data__ = Dh ? Dh(null) : {}), (this.size = 0);
}),
  (Lh.prototype.delete = function (t) {
    var e = this.has(t) && delete this.__data__[t];
    return (this.size -= e ? 1 : 0), e;
  }),
  (Lh.prototype.get = function (t) {
    var e = this.__data__;
    if (Dh) {
      var i = e[t];
      return "__lodash_hash_undefined__" === i ? void 0 : i;
    }
    return Th.call(e, t) ? e[t] : void 0;
  }),
  (Lh.prototype.has = function (t) {
    var e = this.__data__;
    return Dh ? void 0 !== e[t] : Ph.call(e, t);
  }),
  (Lh.prototype.set = function (t, e) {
    var i = this.__data__;
    return (
      (this.size += this.has(t) ? 0 : 1),
      (i[t] = Dh && void 0 === e ? "__lodash_hash_undefined__" : e),
      this
    );
  });
var Nh = Array.prototype.splice;
function Rh(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
(Rh.prototype.clear = function () {
  (this.__data__ = []), (this.size = 0);
}),
  (Rh.prototype.delete = function (t) {
    var e = this.__data__,
      i = Ih(e, t);
    return (
      !(i < 0) &&
      (i == e.length - 1 ? e.pop() : Nh.call(e, i, 1), --this.size, !0)
    );
  }),
  (Rh.prototype.get = function (t) {
    var e = this.__data__,
      i = Ih(e, t);
    return i < 0 ? void 0 : e[i][1];
  }),
  (Rh.prototype.has = function (t) {
    return Ih(this.__data__, t) > -1;
  }),
  (Rh.prototype.set = function (t, e) {
    var i = this.__data__,
      n = Ih(i, t);
    return n < 0 ? (++this.size, i.push([t, e])) : (i[n][1] = e), this;
  });
var Oh = mu(Cl, "Map");
function Fh(t, e) {
  var i,
    n,
    r = t.__data__;
  return (
    "string" == (n = typeof (i = e)) ||
    "number" == n ||
    "symbol" == n ||
    "boolean" == n
      ? "__proto__" !== i
      : null === i
  )
    ? r["string" == typeof e ? "string" : "hash"]
    : r.map;
}
function zh(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
function kh(t, e) {
  for (var i = -1, n = e.length, r = t.length; ++i < n; ) t[r + i] = e[i];
  return t;
}
(zh.prototype.clear = function () {
  (this.size = 0),
    (this.__data__ = {
      hash: new Lh(),
      map: new (Oh || Rh)(),
      string: new Lh(),
    });
}),
  (zh.prototype.delete = function (t) {
    var e = Fh(this, t).delete(t);
    return (this.size -= e ? 1 : 0), e;
  }),
  (zh.prototype.get = function (t) {
    return Fh(this, t).get(t);
  }),
  (zh.prototype.has = function (t) {
    return Fh(this, t).has(t);
  }),
  (zh.prototype.set = function (t, e) {
    var i = Fh(this, t),
      n = i.size;
    return i.set(t, e), (this.size += i.size == n ? 0 : 1), this;
  });
var Bh = _h(Object.getPrototypeOf, Object),
  Gh = "[object Object]",
  Uh = Function.prototype,
  jh = Object.prototype,
  Hh = Uh.toString,
  Vh = jh.hasOwnProperty,
  Wh = Hh.call(Object);
function qh(t) {
  var e = (this.__data__ = new Rh(t));
  this.size = e.size;
}
(qh.prototype.clear = function () {
  (this.__data__ = new Rh()), (this.size = 0);
}),
  (qh.prototype.delete = function (t) {
    var e = this.__data__,
      i = e.delete(t);
    return (this.size = e.size), i;
  }),
  (qh.prototype.get = function (t) {
    return this.__data__.get(t);
  }),
  (qh.prototype.has = function (t) {
    return this.__data__.has(t);
  }),
  (qh.prototype.set = function (t, e) {
    var i = this.__data__;
    if (i instanceof Rh) {
      var n = i.__data__;
      if (!Oh || n.length < 199)
        return n.push([t, e]), (this.size = ++i.size), this;
      i = this.__data__ = new zh(n);
    }
    return i.set(t, e), (this.size = i.size), this;
  });
var Yh = "object" == typeof exports && exports && !exports.nodeType && exports,
  Xh = Yh && "object" == typeof module && module && !module.nodeType && module,
  Qh = Xh && Xh.exports === Yh ? Cl.Buffer : void 0,
  Zh = Qh ? Qh.allocUnsafe : void 0;
function Jh(t, e) {
  if (e) return t.slice();
  var i = t.length,
    n = Zh ? Zh(i) : new t.constructor(i);
  return t.copy(n), n;
}
function Kh() {
  return [];
}
var $h = Object.prototype.propertyIsEnumerable,
  tp = Object.getOwnPropertySymbols,
  ep = tp
    ? function (t) {
        return null == t
          ? []
          : ((t = Object(t)),
            (function (t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length, r = 0, o = [];
                ++i < n;

              ) {
                var a = t[i];
                e(a, i, t) && (o[r++] = a);
              }
              return o;
            })(tp(t), function (e) {
              return $h.call(t, e);
            }));
      }
    : Kh,
  ip = ep;
var np = Object.getOwnPropertySymbols
    ? function (t) {
        for (var e = []; t; ) kh(e, ip(t)), (t = Bh(t));
        return e;
      }
    : Kh,
  rp = np;
function op(t, e, i) {
  var n = e(t);
  return kl(t) ? n : kh(n, i(t));
}
function ap(t) {
  return op(t, Ch, ip);
}
function sp(t) {
  return op(t, Eh, rp);
}
var lp = mu(Cl, "DataView"),
  up = mu(Cl, "Promise"),
  cp = mu(Cl, "Set"),
  hp = "[object Map]",
  pp = "[object Promise]",
  dp = "[object Set]",
  fp = "[object WeakMap]",
  gp = "[object DataView]",
  mp = lu(lp),
  yp = lu(Oh),
  vp = lu(up),
  bp = lu(cp),
  xp = lu(yu),
  _p = Rl;
((lp && _p(new lp(new ArrayBuffer(1))) != gp) ||
  (Oh && _p(new Oh()) != hp) ||
  (up && _p(up.resolve()) != pp) ||
  (cp && _p(new cp()) != dp) ||
  (yu && _p(new yu()) != fp)) &&
  (_p = function (t) {
    var e = Rl(t),
      i = "[object Object]" == e ? t.constructor : void 0,
      n = i ? lu(i) : "";
    if (n)
      switch (n) {
        case mp:
          return gp;
        case yp:
          return hp;
        case vp:
          return pp;
        case bp:
          return dp;
        case xp:
          return fp;
      }
    return e;
  });
var Sp = _p,
  Mp = Object.prototype.hasOwnProperty;
var Cp = Cl.Uint8Array;
function wp(t) {
  var e = new t.constructor(t.byteLength);
  return new Cp(e).set(new Cp(t)), e;
}
var Ap = /\w*$/;
var Ep = wl ? wl.prototype : void 0,
  Dp = Ep ? Ep.valueOf : void 0;
function Tp(t, e) {
  var i = e ? wp(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.length);
}
var Pp = "[object Boolean]",
  Lp = "[object Date]",
  Ip = "[object Map]",
  Np = "[object Number]",
  Rp = "[object RegExp]",
  Op = "[object Set]",
  Fp = "[object String]",
  zp = "[object Symbol]",
  kp = "[object ArrayBuffer]",
  Bp = "[object DataView]",
  Gp = "[object Float32Array]",
  Up = "[object Float64Array]",
  jp = "[object Int8Array]",
  Hp = "[object Int16Array]",
  Vp = "[object Int32Array]",
  Wp = "[object Uint8Array]",
  qp = "[object Uint8ClampedArray]",
  Yp = "[object Uint16Array]",
  Xp = "[object Uint32Array]";
function Qp(t, e, i) {
  var n,
    r,
    o,
    a = t.constructor;
  switch (e) {
    case kp:
      return wp(t);
    case Pp:
    case Lp:
      return new a(+t);
    case Bp:
      return (function (t, e) {
        var i = e ? wp(t.buffer) : t.buffer;
        return new t.constructor(i, t.byteOffset, t.byteLength);
      })(t, i);
    case Gp:
    case Up:
    case jp:
    case Hp:
    case Vp:
    case Wp:
    case qp:
    case Yp:
    case Xp:
      return Tp(t, i);
    case Ip:
      return new a();
    case Np:
    case Fp:
      return new a(t);
    case Rp:
      return (
        ((o = new (r = t).constructor(r.source, Ap.exec(r))).lastIndex =
          r.lastIndex),
        o
      );
    case Op:
      return new a();
    case zp:
      return (n = t), Dp ? Object(Dp.call(n)) : {};
  }
}
function Zp(t) {
  return "function" != typeof t.constructor || eh(t) ? {} : Mu(Bh(t));
}
var Jp = mh && mh.isMap,
  Kp = Jp
    ? ph(Jp)
    : function (t) {
        return Ol(t) && "[object Map]" == Sp(t);
      };
var $p = mh && mh.isSet,
  td = $p
    ? ph($p)
    : function (t) {
        return Ol(t) && "[object Set]" == Sp(t);
      },
  ed = 1,
  id = 2,
  nd = 4,
  rd = "[object Arguments]",
  od = "[object Function]",
  ad = "[object GeneratorFunction]",
  sd = "[object Object]",
  ld = {};
function ud(t, e, i, n, r, o) {
  var a,
    s = e & ed,
    l = e & id,
    u = e & nd;
  if ((i && (a = r ? i(t, n, r, o) : i(t)), void 0 !== a)) return a;
  if (!jl(t)) return t;
  var c = kl(t);
  if (c) {
    if (
      ((a = (function (t) {
        var e = t.length,
          i = new t.constructor(e);
        return (
          e &&
            "string" == typeof t[0] &&
            Mp.call(t, "index") &&
            ((i.index = t.index), (i.input = t.input)),
          i
        );
      })(t)),
      !s)
    )
      return Bu(t, a);
  } else {
    var h = Sp(t),
      p = h == od || h == ad;
    if (ch(t)) return Jh(t, s);
    if (h == sd || h == rd || (p && !r)) {
      if (((a = l || p ? {} : Zp(t)), !s))
        return l
          ? (function (t, e) {
              return Yc(t, rp(t), e);
            })(
              t,
              (function (t, e) {
                return t && Yc(e, Eh(e), t);
              })(a, t)
            )
          : (function (t, e) {
              return Yc(t, ip(t), e);
            })(
              t,
              (function (t, e) {
                return t && Yc(e, Ch(e), t);
              })(a, t)
            );
    } else {
      if (!ld[h]) return r ? t : {};
      a = Qp(t, h, s);
    }
  }
  o || (o = new qh());
  var d = o.get(t);
  if (d) return d;
  o.set(t, a),
    td(t)
      ? t.forEach(function (n) {
          a.add(ud(n, e, i, n, t, o));
        })
      : Kp(t) &&
        t.forEach(function (n, r) {
          a.set(r, ud(n, e, i, r, t, o));
        });
  var f = c ? void 0 : (u ? (l ? sp : ap) : l ? Eh : Ch)(t);
  return (
    $u(f || t, function (n, r) {
      f && (n = t[(r = n)]), qc(a, r, ud(n, e, i, r, t, o));
    }),
    a
  );
}
(ld[rd] =
  ld["[object Array]"] =
  ld["[object ArrayBuffer]"] =
  ld["[object DataView]"] =
  ld["[object Boolean]"] =
  ld["[object Date]"] =
  ld["[object Float32Array]"] =
  ld["[object Float64Array]"] =
  ld["[object Int8Array]"] =
  ld["[object Int16Array]"] =
  ld["[object Int32Array]"] =
  ld["[object Map]"] =
  ld["[object Number]"] =
  ld[sd] =
  ld["[object RegExp]"] =
  ld["[object Set]"] =
  ld["[object String]"] =
  ld["[object Symbol]"] =
  ld["[object Uint8Array]"] =
  ld["[object Uint8ClampedArray]"] =
  ld["[object Uint16Array]"] =
  ld["[object Uint32Array]"] =
    !0),
  (ld["[object Error]"] = ld[od] = ld["[object WeakMap]"] = !1);
var cd = 1,
  hd = 4;
function pd(t) {
  return ud(t, cd | hd);
}
function dd(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.__data__ = new zh(); ++e < i; ) this.add(t[e]);
}
function fd(t, e) {
  for (var i = -1, n = null == t ? 0 : t.length; ++i < n; )
    if (e(t[i], i, t)) return !0;
  return !1;
}
(dd.prototype.add = dd.prototype.push =
  function (t) {
    return this.__data__.set(t, "__lodash_hash_undefined__"), this;
  }),
  (dd.prototype.has = function (t) {
    return this.__data__.has(t);
  });
var gd = 1,
  md = 2;
function yd(t, e, i, n, r, o) {
  var a = i & gd,
    s = t.length,
    l = e.length;
  if (s != l && !(a && l > s)) return !1;
  var u = o.get(t),
    c = o.get(e);
  if (u && c) return u == e && c == t;
  var h = -1,
    p = !0,
    d = i & md ? new dd() : void 0;
  for (o.set(t, e), o.set(e, t); ++h < s; ) {
    var f = t[h],
      g = e[h];
    if (n) var m = a ? n(g, f, h, e, t, o) : n(f, g, h, t, e, o);
    if (void 0 !== m) {
      if (m) continue;
      p = !1;
      break;
    }
    if (d) {
      if (
        !fd(e, function (t, e) {
          if (((a = e), !d.has(a) && (f === t || r(f, t, i, n, o))))
            return d.push(e);
          var a;
        })
      ) {
        p = !1;
        break;
      }
    } else if (f !== g && !r(f, g, i, n, o)) {
      p = !1;
      break;
    }
  }
  return o.delete(t), o.delete(e), p;
}
function vd(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (t, n) {
      i[++e] = [n, t];
    }),
    i
  );
}
function bd(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (t) {
      i[++e] = t;
    }),
    i
  );
}
var xd = 1,
  _d = 2,
  Sd = "[object Boolean]",
  Md = "[object Date]",
  Cd = "[object Error]",
  wd = "[object Map]",
  Ad = "[object Number]",
  Ed = "[object RegExp]",
  Dd = "[object Set]",
  Td = "[object String]",
  Pd = "[object Symbol]",
  Ld = "[object ArrayBuffer]",
  Id = "[object DataView]",
  Nd = wl ? wl.prototype : void 0,
  Rd = Nd ? Nd.valueOf : void 0;
var Od = 1,
  Fd = Object.prototype.hasOwnProperty;
var zd = 1,
  kd = "[object Arguments]",
  Bd = "[object Array]",
  Gd = "[object Object]",
  Ud = Object.prototype.hasOwnProperty;
function jd(t, e, i, n, r, o) {
  var a = kl(t),
    s = kl(e),
    l = a ? Bd : Sp(t),
    u = s ? Bd : Sp(e),
    c = (l = l == kd ? Gd : l) == Gd,
    h = (u = u == kd ? Gd : u) == Gd,
    p = l == u;
  if (p && ch(t)) {
    if (!ch(e)) return !1;
    (a = !0), (c = !1);
  }
  if (p && !c)
    return (
      o || (o = new qh()),
      a || vh(t)
        ? yd(t, e, i, n, r, o)
        : (function (t, e, i, n, r, o, a) {
            switch (i) {
              case Id:
                if (
                  t.byteLength != e.byteLength ||
                  t.byteOffset != e.byteOffset
                )
                  return !1;
                (t = t.buffer), (e = e.buffer);
              case Ld:
                return !(
                  t.byteLength != e.byteLength || !o(new Cp(t), new Cp(e))
                );
              case Sd:
              case Md:
              case Ad:
                return Vc(+t, +e);
              case Cd:
                return t.name == e.name && t.message == e.message;
              case Ed:
              case Td:
                return t == e + "";
              case wd:
                var s = vd;
              case Dd:
                var l = n & xd;
                if ((s || (s = bd), t.size != e.size && !l)) return !1;
                var u = a.get(t);
                if (u) return u == e;
                (n |= _d), a.set(t, e);
                var c = yd(s(t), s(e), n, r, o, a);
                return a.delete(t), c;
              case Pd:
                if (Rd) return Rd.call(t) == Rd.call(e);
            }
            return !1;
          })(t, e, l, i, n, r, o)
    );
  if (!(i & zd)) {
    var d = c && Ud.call(t, "__wrapped__"),
      f = h && Ud.call(e, "__wrapped__");
    if (d || f) {
      var g = d ? t.value() : t,
        m = f ? e.value() : e;
      return o || (o = new qh()), r(g, m, i, n, o);
    }
  }
  return (
    !!p &&
    (o || (o = new qh()),
    (function (t, e, i, n, r, o) {
      var a = i & Od,
        s = ap(t),
        l = s.length;
      if (l != ap(e).length && !a) return !1;
      for (var u = l; u--; ) {
        var c = s[u];
        if (!(a ? c in e : Fd.call(e, c))) return !1;
      }
      var h = o.get(t),
        p = o.get(e);
      if (h && p) return h == e && p == t;
      var d = !0;
      o.set(t, e), o.set(e, t);
      for (var f = a; ++u < l; ) {
        var g = t[(c = s[u])],
          m = e[c];
        if (n) var y = a ? n(m, g, c, e, t, o) : n(g, m, c, t, e, o);
        if (!(void 0 === y ? g === m || r(g, m, i, n, o) : y)) {
          d = !1;
          break;
        }
        f || (f = "constructor" == c);
      }
      if (d && !f) {
        var v = t.constructor,
          b = e.constructor;
        v == b ||
          !("constructor" in t) ||
          !("constructor" in e) ||
          ("function" == typeof v &&
            v instanceof v &&
            "function" == typeof b &&
            b instanceof b) ||
          (d = !1);
      }
      return o.delete(t), o.delete(e), d;
    })(t, e, i, n, r, o))
  );
}
function Hd(t, e, i, n, r) {
  return (
    t === e ||
    (null == t || null == e || (!Ol(t) && !Ol(e))
      ? t != t && e != e
      : jd(t, e, i, n, Hd, r))
  );
}
var Vd,
  Wd = function (t, e, i) {
    for (var n = -1, r = Object(t), o = i(t), a = o.length; a--; ) {
      var s = o[Vd ? a : ++n];
      if (!1 === e(r[s], s, r)) break;
    }
    return t;
  },
  qd = Wd;
function Yd(t, e, i) {
  var n = jc(
    t,
    8,
    void 0,
    void 0,
    void 0,
    void 0,
    void 0,
    (e = i ? void 0 : e)
  );
  return (n.placeholder = Yd.placeholder), n;
}
function Xd(t, e, i) {
  ((void 0 !== i && !Vc(t[e], i)) || (void 0 === i && !(e in t))) &&
    Hc(t, e, i);
}
function Qd(t, e) {
  if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e)
    return t[e];
}
function Zd(t, e, i, n, r, o, a) {
  var s = Qd(t, i),
    l = Qd(e, i),
    u = a.get(l);
  if (u) Xd(t, i, u);
  else {
    var c,
      h = o ? o(s, l, i + "", t, e, a) : void 0,
      p = void 0 === h;
    if (p) {
      var d = kl(l),
        f = !d && ch(l),
        g = !d && !f && vh(l);
      (h = l),
        d || f || g
          ? kl(s)
            ? (h = s)
            : Ol((c = s)) && Kc(c)
            ? (h = Bu(s))
            : f
            ? ((p = !1), (h = Jh(l, !0)))
            : g
            ? ((p = !1), (h = Tp(l, !0)))
            : (h = [])
          : (function (t) {
              if (!Ol(t) || Rl(t) != Gh) return !1;
              var e = Bh(t);
              if (null === e) return !0;
              var i = Vh.call(e, "constructor") && e.constructor;
              return (
                "function" == typeof i && i instanceof i && Hh.call(i) == Wh
              );
            })(l) || ah(l)
          ? ((h = s),
            ah(s)
              ? (h = (function (t) {
                  return Yc(t, Eh(t));
                })(s))
              : (jl(s) && !nu(s)) || (h = Zp(l)))
          : (p = !1);
    }
    p && (a.set(l, h), r(h, l, n, o, a), a.delete(l)), Xd(t, i, h);
  }
}
function Jd(t, e, i, n, r) {
  t !== e &&
    qd(
      e,
      function (o, a) {
        if ((r || (r = new qh()), jl(o))) Zd(t, e, a, i, Jd, n, r);
        else {
          var s = n ? n(Qd(t, a), o, a + "", t, e, r) : void 0;
          void 0 === s && (s = o), Xd(t, a, s);
        }
      },
      Eh
    );
}
Yd.placeholder = {};
var Kd = $c(function (t, e, i, n) {
  Jd(t, e, i, n);
});
function $d(t, e) {
  return t > e;
}
function tf(t, e) {
  return Hd(t, e);
}
function ef(t) {
  return t && t.length
    ? (function (t, e, i) {
        for (var n = -1, r = t.length; ++n < r; ) {
          var o = t[n],
            a = e(o);
          if (null != a && (void 0 === s ? a == a && !zl(a) : i(a, s)))
            var s = a,
              l = o;
        }
        return l;
      })(t, Kl, $d)
    : void 0;
}
var nf = $c(function (t, e, i) {
  Jd(t, e, i);
});
const rf = (function () {
  try {
    return (
      0 ===
      document
        .createElement("canvas")
        .toDataURL("image/webp", 0.5)
        .indexOf("data:image/webp")
    );
  } catch (t) {
    return !1;
  }
})();
const of = pd,
  af = function (t, ...e) {
    return Kd(pd(t), ...e, (t, e) =>
      kl(e) ? e : void 0 === e ? null : void 0
    );
  };
function sf(t, e) {
  return t && t.hasOwnProperty(e);
}
function lf(t) {
  return uf(t) || "" === t;
}
function uf(t) {
  return null == t;
}
function cf(t) {
  return !uf(t);
}
function hf(t) {
  return uf(t) || 0 === t.length;
}
function pf(t) {
  const e = {};
  for (const i in t) {
    e[t[i]] = i;
  }
  return e;
}
function df(t) {
  return Math.fround(t);
}
function ff(t, e) {
  if ("images" === t)
    if (!rf) {
      const t = e.split(".");
      e = ["china", "bg", "noise", "cloud"].includes(t[0])
        ? e.replace(".webp", ".png")
        : e.replace(".webp", ".jpg");
    }
  return `https://lf3-dpfe.${atob("Ynl0ZXRvcy5jb20=")}/obj/gis/` + t + "/" + e;
}
function gf(t) {
  let e = !1;
  if (RegExp(/\.(jpg|jpeg|tiff|bmp)\b/).test(t.src)) return e;
  const i = document.createElement("canvas"),
    n = i.getContext("2d"),
    r = t.width,
    o = t.height;
  (i.width = r), (i.height = o), n.clearRect(0, 0, r, o), n.drawImage(t, 0, 0);
  const a = n.getImageData(0, 0, r, o).data;
  for (let s = 3; s < a.length; s += 4)
    if (255 != a[s]) {
      e = !0;
      break;
    }
  return e;
}
const mf =
  (...t) =>
  (e) =>
    t.reduce((t, e) => e(t), e);
const yf = {
    "top-left": "50%,50%",
    "top-right": "-50%,50%",
    "top-center": "0,50%",
    "bottom-left": "50%,-50%",
    "bottom-right": "-50%,-50%",
    "bottom-center": "0,-50%",
    "middle-left": "50%,0",
    "middle-right": "-50%,0",
    center: "0,0",
  },
  vf = class {
    static create(t, e, i) {
      const n = document.createElement(t);
      return (n.className = e || ""), i && i.appendChild(n), n;
    }
    static remove(t) {
      const e = t.parentNode;
      e && e.removeChild(t);
    }
    static addClass(t, e) {
      if (t.classList) {
        const i = xf(e).split(/\s+/);
        for (let e = 0, n = i.length; e < n; e++) t.classList.add(i[e]);
      } else if (!vf.hasClass(t, e)) {
        const i = vf.getClass(t);
        vf.setClass(t, (i ? i + " " : "") + e);
      }
    }
    static removeClass(t, e) {
      t.classList
        ? t.classList.remove(e)
        : vf.setClass(
            t,
            xf((" " + vf.getClass(t) + " ").replace(" " + e + " ", " "))
          );
    }
    static hasClass(t, e) {
      if (t.classList) return t.classList.contains(e);
      const i = vf.getClass(t);
      return i.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(i);
    }
    static setClass(t, e) {
      t instanceof HTMLElement ? (t.className = e) : (t.className.baseVal = e);
    }
    static getClass(t) {
      var e;
      return (
        t instanceof SVGElement && (t = t.correspondingElement),
        null != (e = t.className.baseVal) ? e : t.className
      );
    }
    static empty(t) {
      for (; t && t.firstChild; ) t.removeChild(t.firstChild);
    }
    static setTransform(t, e) {
      t.style[vf.transformProp] = e;
    }
    static testProp(t) {
      if (!vf.docStyle) return t[0];
      for (const e in t) if (t[e] && t[e] in vf.docStyle) return t[e];
      return t[0];
    }
    static createHTMLDomByStr(t) {
      const e = window.document.createDocumentFragment(),
        i = window.document.createElement("body");
      let n;
      for (i.innerHTML = t; (n = i.firstChild), n; ) e.appendChild(n);
      return e;
    }
    static setVisible(t, e) {
      t.style.visibility = e ? "visible" : "hidden";
    }
  };
let bf = vf;
function xf(t) {
  return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
}
(bf.transformProp = vf.testProp(["transform", "WebkitTransform"])),
  (bf.docStyle = window.document.documentElement.style);
const _f = (t, e, i) => {
    const { position: n, offset: r } = i;
    if ("marker" === t) {
      const t = document.createElement("div");
      t.style["pointer-events"] = "none";
      const i = document.createElement("div");
      return (
        (i.style["pointer-events"] = "none"),
        (i.style.transform = `translate(${yf[n]}) translate(${
          r[0]
        }px, ${-r[1]}px)`),
        t.appendChild(i),
        i.append(e),
        t
      );
    }
    return (
      (e.style.transform = `translate(${yf[n]}) translate(${
        r[0]
      }px, ${-r[1]}px)`),
      e
    );
  },
  Sf = (t) =>
    Array.from(t.children[0].children).find(
      (t) => "marker-container" === t.className
    );
function Mf(t, e, i, n, r, o, a) {
  a && (Cf(t, i, n, r, o, a), t.clip()), t.drawImage(e, i, n, r, o);
}
function Cf(t, e, i, n, r, o) {
  t.beginPath(),
    t.translate(e, i),
    t.arc(n - o[2], r - o[2], o[2], 0, Math.PI / 2),
    t.lineTo(o[2], r),
    t.arc(o[3], r - o[3], o[3], Math.PI / 2, Math.PI),
    t.lineTo(0, o[3]),
    t.arc(o[0], o[0], o[0], Math.PI, (3 * Math.PI) / 2),
    t.lineTo(n - o[0], 0),
    t.arc(n - o[1], o[1], o[1], (3 * Math.PI) / 2, 2 * Math.PI),
    t.lineTo(n, r - o[1]),
    t.closePath();
}
function wf(t, e) {
  return void 0 === e && (e = 15), +parseFloat(Number(t).toPrecision(e));
}
function Af(t) {
  var e = t.toString().split(/[eE]/),
    i = (e[0].split(".")[1] || "").length - +(e[1] || 0);
  return i > 0 ? i : 0;
}
function Ef(t) {
  if (-1 === t.toString().indexOf("e"))
    return Number(t.toString().replace(".", ""));
  var e = Af(t);
  return e > 0 ? wf(Number(t) * Math.pow(10, e)) : Number(t);
}
function Df(t) {
  Of && (t > Number.MAX_SAFE_INTEGER || Number.MIN_SAFE_INTEGER);
}
function Tf(t) {
  return function () {
    for (var e = [], i = 0; i < arguments.length; i++) e[i] = arguments[i];
    var n = e[0];
    return e.slice(1).reduce(function (e, i) {
      return t(e, i);
    }, n);
  };
}
var Pf = Tf(function (t, e) {
    var i = Ef(t),
      n = Ef(e),
      r = Af(t) + Af(e),
      o = i * n;
    return Df(o), o / Math.pow(10, r);
  }),
  Lf = Tf(function (t, e) {
    var i = Math.pow(10, Math.max(Af(t), Af(e)));
    return (Pf(t, i) + Pf(e, i)) / i;
  }),
  If = Tf(function (t, e) {
    var i = Ef(t),
      n = Ef(e);
    return Df(i), Df(n), Pf(i / n, wf(Math.pow(10, Af(e) - Af(t))));
  });
function Nf(t, e) {
  var i = Math.pow(10, e),
    n = If(Math.round(Math.abs(Pf(t, i))), i);
  return t < 0 && 0 !== n && (n = Pf(n, -1)), n;
}
var Rf,
  Of = !0;
function Ff(t, e) {
  if ("string" == typeof e) return t[e];
  {
    const i = e.length;
    let n,
      r,
      o = -1;
    for (; ++o < i && ((n = e[o]), Object.hasOwnProperty.call(t, n)); )
      r = t = t[n];
    return o === i ? r : void 0;
  }
}
void 0 === (Rf = !1) && (Rf = !0), (Of = Rf);
class zf {
  constructor(t) {
    (this.parent = t), (this.watchers = []);
  }
  addWatch(t) {
    t instanceof Array
      ? Array.prototype.push.apply(this.watchers, t)
      : this.watchers.push(t),
      this.watchers.sort((t, e) => (t.priority || 10) - (e.priority || 10));
  }
  compare(t, e) {
    if (e && t)
      for (let i = 0, n = this.watchers.length; i < n; i++) {
        const n = this.watchers[i],
          { rule: r, cb: o } = n;
        if (this.__calcRuleAndProps(r, e, t) && (o(e, t), n.serial)) break;
      }
  }
  defaultRule(t, e, i, n = !1) {
    return this.parent.defaultRule(t, e, i, n);
  }
  __calcRuleAndProps(t, e, i) {
    let n = !1;
    switch (t.type) {
      case "all":
        t.rules && (n = t.rules.every((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      case "some":
        t.rules && (n = t.rules.some((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      default: {
        const n =
          "custom" === t.type ? t.ruleFunc : this.parent.ruleFuncMap[t.type];
        return !!n && n(e, i, t.key);
      }
    }
    return n;
  }
}
const kf = new (class {
  constructor() {
    this.ruleFuncMap = {};
  }
  registerRule(t, e) {
    this.ruleFuncMap[t] = e;
  }
  createPropsWatch() {
    return new zf(this);
  }
  defaultRule(t, e, i, n = !1) {
    return {
      rule: {
        type: e,
        key: t,
      },
      cb: i,
      serial: n,
    };
  }
})();
kf.registerRule("has", (t, e, i) => cf(Ff(t, i))),
  kf.registerRule("diff", (t, e, i) => {
    const n = Ff(t, i),
      r = Ff(e, i);
    return cf(n) && n !== r;
  }),
  kf.registerRule("diffDeep", (t, e, i) => {
    const n = Ff(t, i),
      r = Ff(e, i);
    return (
      cf(n) && n !== r && (Array.isArray(n) ? !tf(n, r) : !tf(nf({}, r, n), r))
    );
  }),
  kf.registerRule("diffAnyone", (t, e, i) =>
    i.some((i) => {
      const n = Ff(t, i),
        r = Ff(e, i);
      return cf(n) && n !== r;
    })
  ),
  kf.registerRule("diffAnyoneDeep", (t, e, i) =>
    i.some((i) => {
      const n = Ff(t, i),
        r = Ff(e, i);
      return (
        cf(n) &&
        n !== r &&
        (Array.isArray(n) ? !tf(n, r) : !tf(nf({}, r, n), r))
      );
    })
  ),
  kf.registerRule("always", () => !0),
  kf.registerRule("hasAndClose", (t, e, i) => {
    const n = Ff(t, i);
    return cf(n) && !n;
  });
const Bf = 0.01,
  Gf = Math.PI / 180,
  Uf = 180 / Math.PI,
  jf = 63781.37,
  Hf = 1565.4303392804097,
  Vf = jf * Math.PI * 2,
  Wf = [];
for (let p7 = 0; p7 <= 31; p7++) {
  const t = Xf(p7, 1),
    e = [];
  for (let i = 0; i < 10; i++) e.push(Xf(p7 + 0.1 * i, 1));
  Wf.push({
    value: t,
    subValue: e,
  });
}
function qf(t, e) {
  0 === e && (e = 512);
  const i = (function (t) {
      if (t >= Wf[0].value)
        return {
          zoom: 0,
          distance: Wf[0].subValue[0],
        };
      let e = 0,
        i = 0,
        n = !1;
      for (; e < Wf.length - 1; e++) {
        if (Wf[e + 1].value <= t) {
          const r = Wf[e].subValue;
          for (i = 0; i < r.length; i++) {
            if (r[i] <= t) {
              n = !0;
              break;
            }
            if (i == r.length - 1) break;
          }
        }
        if (n || e == Wf.length - 1) break;
      }
      return {
        zoom: e + 0.1 * i,
        distance: Wf[e].subValue[i],
      };
    })(t / e).zoom,
    n = Kf(i),
    r = Math.tan((n * Gf) / 2),
    o = (e * Hf) / Math.pow(2, i) / 2 / r;
  return -1 * Math.log2(t / o) + i;
}
function Yf(t) {
  return Jf.getResolution(t);
}
function Xf(t, e) {
  0 === e && (e = 512);
  return (
    (e * (Hf / Math.pow(2, t))) /
    2 /
    Math.tan(((56 - Math.floor(10 * t) / 10) * Gf) / 2)
  );
}
function Qf(t) {
  const e = Jf;
  if (void 0 === t[2]) {
    return e.project(t[0], t[1]);
  }
  {
    const i = e.project(t[0], t[1]);
    return i.push(t[2]), i;
  }
}
function Zf(t) {
  const e = Jf;
  if (void 0 === t[2]) {
    return e.unproject(t[0], t[1]);
  }
  {
    const i = e.unproject(t[0], t[1]);
    return i.push(t[2]), i;
  }
}
class Jf {
  static project(t, e) {
    const i = 85.0511287798;
    return (
      (e = Math.max(Math.min(i, e), -i)),
      (t *= Gf),
      (e *= Gf),
      (e = Math.log(Math.tan(Math.PI / 4 + e / 2))),
      [t * jf, e * jf]
    );
  }
  static unproject(t, e) {
    return [
      (t / jf) * Uf,
      (2 * Math.atan(Math.exp(e / jf)) - Math.PI / 2) * Uf,
    ];
  }
  static getResolution(t) {
    return Hf / Math.pow(2, t);
  }
}
function Kf(t) {
  return 56 - t;
}
var $f = {},
  tg = {
    RADIUS: 6378137,
    FLATTENING: 1 / 298.257223563,
    POLAR_RADIUS: 6356752.3142,
  },
  eg = tg;
function ig(t) {
  var e = 0;
  if (t && t.length > 0) {
    e += Math.abs(ng(t[0]));
    for (var i = 1; i < t.length; i++) e -= Math.abs(ng(t[i]));
  }
  return e;
}
function ng(t) {
  var e,
    i,
    n,
    r,
    o,
    a,
    s = 0,
    l = t.length;
  if (l > 2) {
    for (a = 0; a < l; a++)
      a === l - 2
        ? ((n = l - 2), (r = l - 1), (o = 0))
        : a === l - 1
        ? ((n = l - 1), (r = 0), (o = 1))
        : ((n = a), (r = a + 1), (o = a + 2)),
        (e = t[n]),
        (i = t[r]),
        (s += (rg(t[o][0]) - rg(e[0])) * Math.sin(rg(i[1])));
    s = (s * eg.RADIUS * eg.RADIUS) / 2;
  }
  return s;
}
function rg(t) {
  return (t * Math.PI) / 180;
}
($f.geometry = function t(e) {
  var i,
    n = 0;
  switch (e.type) {
    case "Polygon":
      return ig(e.coordinates);
    case "MultiPolygon":
      for (i = 0; i < e.coordinates.length; i++) n += ig(e.coordinates[i]);
      return n;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
    case "GeometryCollection":
      for (i = 0; i < e.geometries.length; i++) n += t(e.geometries[i]);
      return n;
  }
}),
  ($f.ring = ng);
var og = $f,
  ag = function t(e, i) {
    switch ((e && e.type) || null) {
      case "FeatureCollection":
        return (e.features = e.features.map(sg(t, i))), e;
      case "Feature":
        return (e.geometry = t(e.geometry, i)), e;
      case "Polygon":
      case "MultiPolygon":
        return (function (t, e) {
          "Polygon" === t.type
            ? (t.coordinates = lg(t.coordinates, e))
            : "MultiPolygon" === t.type &&
              (t.coordinates = t.coordinates.map(sg(lg, e)));
          return t;
        })(e, i);
      default:
        return e;
    }
  };
function sg(t, e) {
  return function (i) {
    return t(i, e);
  };
}
function lg(t, e) {
  (e = !!e), (t[0] = ug(t[0], e));
  for (var i = 1; i < t.length; i++) t[i] = ug(t[i], !e);
  return t;
}
function ug(t, e) {
  return (function (t) {
    return og.ring(t) >= 0;
  })(t) === e
    ? t
    : t.reverse();
}
function cg(t) {
  var e;
  return (
    "Point" == t.type
      ? (e = [t.coordinates])
      : "LineString" == t.type || "MultiPoint" == t.type
      ? (e = t.coordinates)
      : "Polygon" == t.type || "MultiLineString" == t.type
      ? (e = t.coordinates.reduce(function (t, e) {
          return t.concat(e);
        }, []))
      : "MultiPolygon" == t.type
      ? (e = t.coordinates.reduce(function (t, e) {
          return t.concat(
            e.reduce(function (t, e) {
              return t.concat(e);
            }, [])
          );
        }, []))
      : "Feature" == t.type
      ? (e = cg(t.geometry))
      : "GeometryCollection" == t.type
      ? (e = t.geometries.reduce(function (t, e) {
          return t.concat(cg(e));
        }, []))
      : "FeatureCollection" == t.type &&
        (e = t.features.reduce(function (t, e) {
          return t.concat(cg(e));
        }, [])),
    e
  );
}
var hg = Object.prototype.hasOwnProperty;
function pg(t, e, i, n, r, o) {
  3 === arguments.length && ((n = o = Array), (r = null));
  for (
    var a = new n((t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))),
      s = new o(t),
      l = t - 1,
      u = 0;
    u < t;
    ++u
  )
    a[u] = r;
  return {
    set: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return (s[u] = o);
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    maybeSet: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    get: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) break;
        c = a[(u = (u + 1) & l)];
      }
      return o;
    },
    keys: function () {
      for (var t = [], e = 0, i = a.length; e < i; ++e) {
        var n = a[e];
        n != r && t.push(n);
      }
      return t;
    },
  };
}
function dg(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
var fg = new ArrayBuffer(16),
  gg = new Float64Array(fg),
  mg = new Uint32Array(fg);
function yg(t) {
  (gg[0] = t[0]), (gg[1] = t[1]);
  var e = mg[0] ^ mg[1];
  return 2147483647 & (e = (e << 5) ^ (e >> 7) ^ mg[2] ^ mg[3]);
}
function vg(t) {
  var e,
    i,
    n,
    r,
    o = t.coordinates,
    a = t.lines,
    s = t.rings,
    l = (function () {
      for (
        var t = pg(1.4 * o.length, _, S, Int32Array, -1, Int32Array),
          e = new Int32Array(o.length),
          i = 0,
          n = o.length;
        i < n;
        ++i
      )
        e[i] = t.maybeSet(i, i);
      return e;
    })(),
    u = new Int32Array(o.length),
    c = new Int32Array(o.length),
    h = new Int32Array(o.length),
    p = new Int8Array(o.length),
    d = 0;
  for (e = 0, i = o.length; e < i; ++e) u[e] = c[e] = h[e] = -1;
  for (e = 0, i = a.length; e < i; ++e) {
    var f = a[e],
      g = f[0],
      m = f[1];
    for (n = l[g], r = l[++g], ++d, p[n] = 1; ++g <= m; )
      x(e, n, (n = r), (r = l[g]));
    ++d, (p[r] = 1);
  }
  for (e = 0, i = o.length; e < i; ++e) u[e] = -1;
  for (e = 0, i = s.length; e < i; ++e) {
    var y = s[e],
      v = y[0] + 1,
      b = y[1];
    for (x(e, l[b - 1], (n = l[v - 1]), (r = l[v])); ++v <= b; )
      x(e, n, (n = r), (r = l[v]));
  }
  function x(t, e, i, n) {
    if (u[i] !== t) {
      u[i] = t;
      var r = c[i];
      if (r >= 0) {
        var o = h[i];
        (r === e && o === n) || (r === n && o === e) || (++d, (p[i] = 1));
      } else (c[i] = e), (h[i] = n);
    }
  }
  function _(t) {
    return yg(o[t]);
  }
  function S(t, e) {
    return dg(o[t], o[e]);
  }
  u = c = h = null;
  var M,
    C = (function (t, e, i, n, r) {
      3 === arguments.length && ((n = Array), (r = null));
      for (
        var o = new n(
            (t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))
          ),
          a = t - 1,
          s = 0;
        s < t;
        ++s
      )
        o[s] = r;
      return {
        add: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) throw new Error("full hashset");
            l = o[(s = (s + 1) & a)];
          }
          return (o[s] = n), !0;
        },
        has: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) break;
            l = o[(s = (s + 1) & a)];
          }
          return !1;
        },
        values: function () {
          for (var t = [], e = 0, i = o.length; e < i; ++e) {
            var n = o[e];
            n != r && t.push(n);
          }
          return t;
        },
      };
    })(1.4 * d, yg, dg);
  for (e = 0, i = o.length; e < i; ++e) p[(M = l[e])] && C.add(o[M]);
  return C;
}
function bg(t, e, i, n) {
  xg(t, e, i), xg(t, e, e + n), xg(t, e + n, i);
}
function xg(t, e, i) {
  for (var n, r = e + ((i-- - e) >> 1); e < r; ++e, --i)
    (n = t[e]), (t[e] = t[i]), (t[i] = n);
}
function _g(t) {
  var e,
    i,
    n = {};
  for (e in t)
    n[e] =
      null == (i = t[e])
        ? {
            type: null,
          }
        : ("FeatureCollection" === i.type
            ? Sg
            : "Feature" === i.type
            ? Mg
            : Cg)(i);
  return n;
}
function Sg(t) {
  var e = {
    type: "GeometryCollection",
    geometries: t.features.map(Mg),
  };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function Mg(t) {
  var e,
    i = Cg(t.geometry);
  for (e in (null != t.id && (i.id = t.id),
  null != t.bbox && (i.bbox = t.bbox),
  t.properties)) {
    i.properties = t.properties;
    break;
  }
  return i;
}
function Cg(t) {
  if (null == t)
    return {
      type: null,
    };
  var e =
    "GeometryCollection" === t.type
      ? {
          type: "GeometryCollection",
          geometries: t.geometries.map(Cg),
        }
      : "Point" === t.type || "MultiPoint" === t.type
      ? {
          type: t.type,
          coordinates: t.coordinates,
        }
      : {
          type: t.type,
          arcs: t.coordinates,
        };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function wg(t) {
  var e,
    i = t[0],
    n = t[1];
  return n < i && ((e = i), (i = n), (n = e)), i + 31 * n;
}
function Ag(t, e) {
  var i,
    n = t[0],
    r = t[1],
    o = e[0],
    a = e[1];
  return (
    r < n && ((i = n), (n = r), (r = i)),
    a < o && ((i = o), (o = a), (a = i)),
    n === o && r === a
  );
}
var Eg = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        topology: function (t, e) {
          var i = (function (t) {
              var e = 1 / 0,
                i = 1 / 0,
                n = -1 / 0,
                r = -1 / 0;
              function o(t) {
                null != t && hg.call(a, t.type) && a[t.type](t);
              }
              var a = {
                GeometryCollection: function (t) {
                  t.geometries.forEach(o);
                },
                Point: function (t) {
                  s(t.coordinates);
                },
                MultiPoint: function (t) {
                  t.coordinates.forEach(s);
                },
                LineString: function (t) {
                  l(t.arcs);
                },
                MultiLineString: function (t) {
                  t.arcs.forEach(l);
                },
                Polygon: function (t) {
                  t.arcs.forEach(l);
                },
                MultiPolygon: function (t) {
                  t.arcs.forEach(u);
                },
              };
              function s(t) {
                var o = t[0],
                  a = t[1];
                o < e && (e = o),
                  o > n && (n = o),
                  a < i && (i = a),
                  a > r && (r = a);
              }
              function l(t) {
                t.forEach(s);
              }
              function u(t) {
                t.forEach(l);
              }
              for (var c in t) o(t[c]);
              return n >= e && r >= i ? [e, i, n, r] : void 0;
            })((t = _g(t))),
            n =
              e > 0 &&
              i &&
              (function (t, e, i) {
                var n = e[0],
                  r = e[1],
                  o = e[2],
                  a = e[3],
                  s = o - n ? (i - 1) / (o - n) : 1,
                  l = a - r ? (i - 1) / (a - r) : 1;
                function u(t) {
                  return [
                    Math.round((t[0] - n) * s),
                    Math.round((t[1] - r) * l),
                  ];
                }
                function c(t, e) {
                  for (
                    var i,
                      o,
                      a,
                      u,
                      c,
                      h = -1,
                      p = 0,
                      d = t.length,
                      f = new Array(d);
                    ++h < d;

                  )
                    (i = t[h]),
                      (u = Math.round((i[0] - n) * s)),
                      (c = Math.round((i[1] - r) * l)),
                      (u === o && c === a) || (f[p++] = [(o = u), (a = c)]);
                  for (f.length = p; p < e; ) p = f.push([f[0][0], f[0][1]]);
                  return f;
                }
                function h(t) {
                  return c(t, 2);
                }
                function p(t) {
                  return c(t, 4);
                }
                function d(t) {
                  return t.map(p);
                }
                function f(t) {
                  null != t && hg.call(g, t.type) && g[t.type](t);
                }
                var g = {
                  GeometryCollection: function (t) {
                    t.geometries.forEach(f);
                  },
                  Point: function (t) {
                    t.coordinates = u(t.coordinates);
                  },
                  MultiPoint: function (t) {
                    t.coordinates = t.coordinates.map(u);
                  },
                  LineString: function (t) {
                    t.arcs = h(t.arcs);
                  },
                  MultiLineString: function (t) {
                    t.arcs = t.arcs.map(h);
                  },
                  Polygon: function (t) {
                    t.arcs = d(t.arcs);
                  },
                  MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(d);
                  },
                };
                for (var m in t) f(t[m]);
                return {
                  scale: [1 / s, 1 / l],
                  translate: [n, r],
                };
              })(t, i, e),
            r = (function (t) {
              var e,
                i,
                n,
                r,
                o = t.coordinates,
                a = t.lines,
                s = t.rings,
                l = a.length + s.length;
              for (
                delete t.lines, delete t.rings, n = 0, r = a.length;
                n < r;
                ++n
              )
                for (e = a[n]; (e = e.next); ) ++l;
              for (n = 0, r = s.length; n < r; ++n)
                for (i = s[n]; (i = i.next); ) ++l;
              var u = pg(2 * l * 1.4, yg, dg),
                c = (t.arcs = []);
              for (n = 0, r = a.length; n < r; ++n) {
                e = a[n];
                do {
                  h(e);
                } while ((e = e.next));
              }
              for (n = 0, r = s.length; n < r; ++n)
                if ((i = s[n]).next)
                  do {
                    h(i);
                  } while ((i = i.next));
                else p(i);
              function h(t) {
                var e, i, n, r, a, s, l, h;
                if ((n = u.get((e = o[t[0]]))))
                  for (l = 0, h = n.length; l < h; ++l)
                    if (d((r = n[l]), t))
                      return (t[0] = r[0]), void (t[1] = r[1]);
                if ((a = u.get((i = o[t[1]]))))
                  for (l = 0, h = a.length; l < h; ++l)
                    if (f((s = a[l]), t))
                      return (t[1] = s[0]), void (t[0] = s[1]);
                n ? n.push(t) : u.set(e, [t]),
                  a ? a.push(t) : u.set(i, [t]),
                  c.push(t);
              }
              function p(t) {
                var e, i, n, r, a;
                if ((i = u.get(o[t[0]])))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                if ((i = u.get((e = o[t[0] + y(t)]))))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                i ? i.push(t) : u.set(e, [t]), c.push(t);
              }
              function d(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1];
                if (i - r != n - e[1]) return !1;
                for (; i <= r; ++i, ++n) if (!dg(o[i], o[n])) return !1;
                return !0;
              }
              function f(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1];
                if (i - r != n - a) return !1;
                for (; i <= r; ++i, --a) if (!dg(o[i], o[a])) return !1;
                return !0;
              }
              function g(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1] - i;
                if (r !== e[1] - n) return !1;
                for (var a = y(t), s = y(e), l = 0; l < r; ++l)
                  if (!dg(o[i + ((l + a) % r)], o[n + ((l + s) % r)]))
                    return !1;
                return !0;
              }
              function m(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1],
                  s = r - i;
                if (s !== a - n) return !1;
                for (var l = y(t), u = s - y(e), c = 0; c < s; ++c)
                  if (!dg(o[i + ((c + l) % s)], o[a - ((c + u) % s)]))
                    return !1;
                return !0;
              }
              function y(t) {
                for (
                  var e = t[0], i = t[1], n = e, r = n, a = o[n];
                  ++n < i;

                ) {
                  var s = o[n];
                  (s[0] < a[0] || (s[0] === a[0] && s[1] < a[1])) &&
                    ((r = n), (a = s));
                }
                return r - e;
              }
              return t;
            })(
              (function (t) {
                var e,
                  i,
                  n,
                  r = vg(t),
                  o = t.coordinates,
                  a = t.lines,
                  s = t.rings;
                for (i = 0, n = a.length; i < n; ++i)
                  for (var l = a[i], u = l[0], c = l[1]; ++u < c; )
                    r.has(o[u]) &&
                      ((e = {
                        0: u,
                        1: l[1],
                      }),
                      (l[1] = u),
                      (l = l.next = e));
                for (i = 0, n = s.length; i < n; ++i)
                  for (
                    var h = s[i], p = h[0], d = p, f = h[1], g = r.has(o[p]);
                    ++d < f;

                  )
                    r.has(o[d]) &&
                      (g
                        ? ((e = {
                            0: d,
                            1: h[1],
                          }),
                          (h[1] = d),
                          (h = h.next = e))
                        : (bg(o, p, f, f - d),
                          (o[f] = o[p]),
                          (g = !0),
                          (d = p)));
                return t;
              })(
                (function (t) {
                  var e = -1,
                    i = [],
                    n = [],
                    r = [];
                  function o(t) {
                    t && hg.call(a, t.type) && a[t.type](t);
                  }
                  var a = {
                    GeometryCollection: function (t) {
                      t.geometries.forEach(o);
                    },
                    LineString: function (t) {
                      t.arcs = s(t.arcs);
                    },
                    MultiLineString: function (t) {
                      t.arcs = t.arcs.map(s);
                    },
                    Polygon: function (t) {
                      t.arcs = t.arcs.map(l);
                    },
                    MultiPolygon: function (t) {
                      t.arcs = t.arcs.map(u);
                    },
                  };
                  function s(t) {
                    for (var n = 0, o = t.length; n < o; ++n) r[++e] = t[n];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return i.push(a), a;
                  }
                  function l(t) {
                    for (var i = 0, o = t.length; i < o; ++i) r[++e] = t[i];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return n.push(a), a;
                  }
                  function u(t) {
                    return t.map(l);
                  }
                  for (var c in t) o(t[c]);
                  return {
                    type: "Topology",
                    coordinates: r,
                    lines: i,
                    rings: n,
                    objects: t,
                  };
                })(t)
              )
            ),
            o = r.coordinates,
            a = pg(1.4 * r.arcs.length, wg, Ag);
          function s(t) {
            t && hg.call(l, t.type) && l[t.type](t);
          }
          (t = r.objects),
            (r.bbox = i),
            (r.arcs = r.arcs.map(function (t, e) {
              return a.set(t, e), o.slice(t[0], t[1] + 1);
            })),
            delete r.coordinates,
            (o = null);
          var l = {
            GeometryCollection: function (t) {
              t.geometries.forEach(s);
            },
            LineString: function (t) {
              t.arcs = u(t.arcs);
            },
            MultiLineString: function (t) {
              t.arcs = t.arcs.map(u);
            },
            Polygon: function (t) {
              t.arcs = t.arcs.map(u);
            },
            MultiPolygon: function (t) {
              t.arcs = t.arcs.map(c);
            },
          };
          function u(t) {
            var e = [];
            do {
              var i = a.get(t);
              e.push(t[0] < t[1] ? i : ~i);
            } while ((t = t.next));
            return e;
          }
          function c(t) {
            return t.map(u);
          }
          for (var h in t) s(t[h]);
          return (
            n &&
              ((r.transform = n),
              (r.arcs = (function (t) {
                for (var e = -1, i = t.length; ++e < i; ) {
                  for (
                    var n,
                      r,
                      o = t[e],
                      a = 0,
                      s = 1,
                      l = o.length,
                      u = o[0],
                      c = u[0],
                      h = u[1];
                    ++a < l;

                  )
                    (n = (u = o[a])[0]),
                      (r = u[1]),
                      (n === c && r === h) ||
                        ((o[s++] = [n - c, r - h]), (c = n), (h = r));
                  1 === s && (o[s++] = [0, 0]), (o.length = s);
                }
                return t;
              })(r.arcs))),
            r
          );
        },
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Dg = ht(Eg);
function Tg(t) {
  return t;
}
function Pg(t) {
  if (null == t) return Tg;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u);
    for (c[0] = (e += t[0]) * n + o, c[1] = (i += t[1]) * r + a; l < u; )
      (c[l] = t[l]), ++l;
    return c;
  };
}
function Lg(t) {
  var e,
    i = Pg(t.transform),
    n = 1 / 0,
    r = n,
    o = -n,
    a = -n;
  function s(t) {
    (t = i(t))[0] < n && (n = t[0]),
      t[0] > o && (o = t[0]),
      t[1] < r && (r = t[1]),
      t[1] > a && (a = t[1]);
  }
  function l(t) {
    switch (t.type) {
      case "GeometryCollection":
        t.geometries.forEach(l);
        break;
      case "Point":
        s(t.coordinates);
        break;
      case "MultiPoint":
        t.coordinates.forEach(s);
    }
  }
  for (e in (t.arcs.forEach(function (t) {
    for (var e, s = -1, l = t.length; ++s < l; )
      (e = i(t[s], s))[0] < n && (n = e[0]),
        e[0] > o && (o = e[0]),
        e[1] < r && (r = e[1]),
        e[1] > a && (a = e[1]);
  }),
  t.objects))
    l(t.objects[e]);
  return [n, r, o, a];
}
function Ig(t, e) {
  var i = e.id,
    n = e.bbox,
    r = null == e.properties ? {} : e.properties,
    o = Ng(t, e);
  return null == i && null == n
    ? {
        type: "Feature",
        properties: r,
        geometry: o,
      }
    : null == n
    ? {
        type: "Feature",
        id: i,
        properties: r,
        geometry: o,
      }
    : {
        type: "Feature",
        id: i,
        bbox: n,
        properties: r,
        geometry: o,
      };
}
function Ng(t, e) {
  var i = Pg(t.transform),
    n = t.arcs;
  function r(t, e) {
    e.length && e.pop();
    for (var r = n[t < 0 ? ~t : t], o = 0, a = r.length; o < a; ++o)
      e.push(i(r[o], o));
    t < 0 &&
      (function (t, e) {
        for (var i, n = t.length, r = n - e; r < --n; )
          (i = t[r]), (t[r++] = t[n]), (t[n] = i);
      })(e, a);
  }
  function o(t) {
    return i(t);
  }
  function a(t) {
    for (var e = [], i = 0, n = t.length; i < n; ++i) r(t[i], e);
    return e.length < 2 && e.push(e[0]), e;
  }
  function s(t) {
    for (var e = a(t); e.length < 4; ) e.push(e[0]);
    return e;
  }
  function l(t) {
    return t.map(s);
  }
  return (function t(e) {
    var i,
      n = e.type;
    switch (n) {
      case "GeometryCollection":
        return {
          type: n,
          geometries: e.geometries.map(t),
        };
      case "Point":
        i = o(e.coordinates);
        break;
      case "MultiPoint":
        i = e.coordinates.map(o);
        break;
      case "LineString":
        i = a(e.arcs);
        break;
      case "MultiLineString":
        i = e.arcs.map(a);
        break;
      case "Polygon":
        i = l(e.arcs);
        break;
      case "MultiPolygon":
        i = e.arcs.map(l);
        break;
      default:
        return null;
    }
    return {
      type: n,
      coordinates: i,
    };
  })(e);
}
function Rg(t, e) {
  var i = {},
    n = {},
    r = {},
    o = [],
    a = -1;
  function s(t, e) {
    for (var n in t) {
      var r = t[n];
      delete e[r.start],
        delete r.start,
        delete r.end,
        r.forEach(function (t) {
          i[t < 0 ? ~t : t] = 1;
        }),
        o.push(r);
    }
  }
  return (
    e.forEach(function (i, n) {
      var r,
        o = t.arcs[i < 0 ? ~i : i];
      o.length < 3 &&
        !o[1][0] &&
        !o[1][1] &&
        ((r = e[++a]), (e[a] = i), (e[n] = r));
    }),
    e.forEach(function (e) {
      var i,
        o,
        a = (function (e) {
          var i,
            n = t.arcs[e < 0 ? ~e : e],
            r = n[0];
          t.transform
            ? ((i = [0, 0]),
              n.forEach(function (t) {
                (i[0] += t[0]), (i[1] += t[1]);
              }))
            : (i = n[n.length - 1]);
          return e < 0 ? [i, r] : [r, i];
        })(e),
        s = a[0],
        l = a[1];
      if ((i = r[s]))
        if ((delete r[i.end], i.push(e), (i.end = l), (o = n[l]))) {
          delete n[o.start];
          var u = o === i ? i : i.concat(o);
          n[(u.start = i.start)] = r[(u.end = o.end)] = u;
        } else n[i.start] = r[i.end] = i;
      else if ((i = n[l]))
        if ((delete n[i.start], i.unshift(e), (i.start = s), (o = r[s]))) {
          delete r[o.end];
          var c = o === i ? i : o.concat(i);
          n[(c.start = o.start)] = r[(c.end = i.end)] = c;
        } else n[i.start] = r[i.end] = i;
      else n[((i = [e]).start = s)] = r[(i.end = l)] = i;
    }),
    s(r, n),
    s(n, r),
    e.forEach(function (t) {
      i[t < 0 ? ~t : t] || o.push([t]);
    }),
    o
  );
}
function Og(t, e, i) {
  var n, r, o;
  if (arguments.length > 1)
    n = (function (t, e, i) {
      var n,
        r = [],
        o = [];
      function a(t) {
        var e = t < 0 ? ~t : t;
        (o[e] || (o[e] = [])).push({
          i: t,
          g: n,
        });
      }
      function s(t) {
        t.forEach(a);
      }
      function l(t) {
        t.forEach(s);
      }
      function u(t) {
        t.forEach(l);
      }
      function c(t) {
        switch (((n = t), t.type)) {
          case "GeometryCollection":
            t.geometries.forEach(c);
            break;
          case "LineString":
            s(t.arcs);
            break;
          case "MultiLineString":
          case "Polygon":
            l(t.arcs);
            break;
          case "MultiPolygon":
            u(t.arcs);
        }
      }
      return (
        c(e),
        o.forEach(
          null == i
            ? function (t) {
                r.push(t[0].i);
              }
            : function (t) {
                i(t[0].g, t[t.length - 1].g) && r.push(t[0].i);
              }
        ),
        r
      );
    })(0, e, i);
  else for (r = 0, n = new Array((o = t.arcs.length)); r < o; ++r) n[r] = r;
  return {
    type: "MultiLineString",
    arcs: Rg(t, n),
  };
}
function Fg(t, e) {
  var i = {},
    n = [],
    r = [];
  function o(t) {
    t.forEach(function (e) {
      e.forEach(function (e) {
        (i[(e = e < 0 ? ~e : e)] || (i[e] = [])).push(t);
      });
    }),
      n.push(t);
  }
  function a(e) {
    return (function (t) {
      for (var e, i = -1, n = t.length, r = t[n - 1], o = 0; ++i < n; )
        (e = r), (r = t[i]), (o += e[0] * r[1] - e[1] * r[0]);
      return Math.abs(o);
    })(
      Ng(t, {
        type: "Polygon",
        arcs: [e],
      }).coordinates[0]
    );
  }
  return (
    e.forEach(function t(e) {
      switch (e.type) {
        case "GeometryCollection":
          e.geometries.forEach(t);
          break;
        case "Polygon":
          o(e.arcs);
          break;
        case "MultiPolygon":
          e.arcs.forEach(o);
      }
    }),
    n.forEach(function (t) {
      if (!t._) {
        var e = [],
          n = [t];
        for (t._ = 1, r.push(e); (t = n.pop()); )
          e.push(t),
            t.forEach(function (t) {
              t.forEach(function (t) {
                i[t < 0 ? ~t : t].forEach(function (t) {
                  t._ || ((t._ = 1), n.push(t));
                });
              });
            });
      }
    }),
    n.forEach(function (t) {
      delete t._;
    }),
    {
      type: "MultiPolygon",
      arcs: r
        .map(function (e) {
          var n,
            r = [];
          if (
            (e.forEach(function (t) {
              t.forEach(function (t) {
                t.forEach(function (t) {
                  i[t < 0 ? ~t : t].length < 2 && r.push(t);
                });
              });
            }),
            (n = (r = Rg(t, r)).length) > 1)
          )
            for (var o, s, l = 1, u = a(r[0]); l < n; ++l)
              (o = a(r[l])) > u &&
                ((s = r[0]), (r[0] = r[l]), (r[l] = s), (u = o));
          return r;
        })
        .filter(function (t) {
          return t.length > 0;
        }),
    }
  );
}
function zg(t, e) {
  for (var i = 0, n = t.length; i < n; ) {
    var r = (i + n) >>> 1;
    t[r] < e ? (i = r + 1) : (n = r);
  }
  return i;
}
function kg(t) {
  if (null == t) return Tg;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u),
      h = Math.round((t[0] - o) / n),
      p = Math.round((t[1] - a) / r);
    for (c[0] = h - e, e = h, c[1] = p - i, i = p; l < u; ) (c[l] = t[l]), ++l;
    return c;
  };
}
var Bg = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bbox: Lg,
        feature: function (t, e) {
          return (
            "string" == typeof e && (e = t.objects[e]),
            "GeometryCollection" === e.type
              ? {
                  type: "FeatureCollection",
                  features: e.geometries.map(function (e) {
                    return Ig(t, e);
                  }),
                }
              : Ig(t, e)
          );
        },
        mesh: function (t) {
          return Ng(t, Og.apply(this, arguments));
        },
        meshArcs: Og,
        merge: function (t) {
          return Ng(t, Fg.apply(this, arguments));
        },
        mergeArcs: Fg,
        neighbors: function (t) {
          var e = {},
            i = t.map(function () {
              return [];
            });
          function n(t, i) {
            t.forEach(function (t) {
              t < 0 && (t = ~t);
              var n = e[t];
              n ? n.push(i) : (e[t] = [i]);
            });
          }
          function r(t, e) {
            t.forEach(function (t) {
              n(t, e);
            });
          }
          var o = {
            LineString: n,
            MultiLineString: r,
            Polygon: r,
            MultiPolygon: function (t, e) {
              t.forEach(function (t) {
                r(t, e);
              });
            },
          };
          for (var a in (t.forEach(function t(e, i) {
            "GeometryCollection" === e.type
              ? e.geometries.forEach(function (e) {
                  t(e, i);
                })
              : e.type in o && o[e.type](e.arcs, i);
          }),
          e))
            for (var s = e[a], l = s.length, u = 0; u < l; ++u)
              for (var c = u + 1; c < l; ++c) {
                var h,
                  p = s[u],
                  d = s[c];
                (h = i[p])[(a = zg(h, d))] !== d && h.splice(a, 0, d),
                  (h = i[d])[(a = zg(h, p))] !== p && h.splice(a, 0, p);
              }
          return i;
        },
        quantize: function (t, e) {
          if (t.transform) throw new Error("already quantized");
          if (e && e.scale) s = t.bbox;
          else {
            if (!((i = Math.floor(e)) >= 2)) throw new Error("n must be ≥2");
            var i,
              n = (s = t.bbox || Lg(t))[0],
              r = s[1],
              o = s[2],
              a = s[3];
            e = {
              scale: [
                o - n ? (o - n) / (i - 1) : 1,
                a - r ? (a - r) / (i - 1) : 1,
              ],
              translate: [n, r],
            };
          }
          var s,
            l,
            u = kg(e),
            c = t.objects,
            h = {};
          function p(t) {
            return u(t);
          }
          function d(t) {
            var e;
            switch (t.type) {
              case "GeometryCollection":
                e = {
                  type: "GeometryCollection",
                  geometries: t.geometries.map(d),
                };
                break;
              case "Point":
                e = {
                  type: "Point",
                  coordinates: p(t.coordinates),
                };
                break;
              case "MultiPoint":
                e = {
                  type: "MultiPoint",
                  coordinates: t.coordinates.map(p),
                };
                break;
              default:
                return t;
            }
            return (
              null != t.id && (e.id = t.id),
              null != t.bbox && (e.bbox = t.bbox),
              null != t.properties && (e.properties = t.properties),
              e
            );
          }
          for (l in c) h[l] = d(c[l]);
          return {
            type: "Topology",
            bbox: s,
            transform: e,
            objects: h,
            arcs: t.arcs.map(function (t) {
              var e,
                i = 0,
                n = 1,
                r = t.length,
                o = new Array(r);
              for (o[0] = u(t[0], 0); ++i < r; )
                ((e = u(t[i], i))[0] || e[1]) && (o[n++] = e);
              return 1 === n && (o[n++] = [0, 0]), (o.length = n), o;
            }),
          };
        },
        transform: Pg,
        untransform: kg,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Gg = ht(Bg),
  Ug = function (t) {
    var e = t.slice(),
      i = [];
    for (; e.length > 0; ) {
      var n = e.shift();
      (e = e.reduce(function (t, e) {
        var i = Hg(n, e);
        return i ? (n = i) : t.push(e), t;
      }, [])),
        i.push(n);
    }
    i =
      1 === i.length
        ? i[0]
        : {
            type: "MultiLineString",
            coordinates: i.map(function (t) {
              return t.coordinates;
            }),
          };
    return i;
  };
function jg(t) {
  return t[0].toString() + "," + t[1].toString();
}
function Hg(t, e) {
  var i,
    n = jg(t.coordinates[0]),
    r = jg(t.coordinates[t.coordinates.length - 1]),
    o = jg(e.coordinates[0]),
    a = jg(e.coordinates[e.coordinates.length - 1]);
  if (n === a) i = e.coordinates.concat(t.coordinates.slice(1));
  else if (o === r) i = t.coordinates.concat(e.coordinates.slice(1));
  else if (n === o) i = t.coordinates.slice(1).reverse().concat(e.coordinates);
  else {
    if (r !== a) return null;
    i = t.coordinates.concat(e.coordinates.reverse().slice(1));
  }
  return {
    type: "LineString",
    coordinates: i,
  };
}
var Vg = {};
function Wg(t, e, i) {
  var n,
    r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p,
    d = 0,
    f = 0,
    g = "FeatureCollection" === t.type,
    m = "Feature" === t.type,
    y = g ? t.features.length : 1;
  for (n = 0; n < y; n++)
    for (
      u = (p =
        "GeometryCollection" ===
        (h = g ? t.features[n].geometry : m ? t.geometry : t).type)
        ? h.geometries.length
        : 1,
        a = 0;
      a < u;
      a++
    )
      if (
        ((c = (l = p ? h.geometries[a] : h).coordinates),
        (d = !i || ("Polygon" !== l.type && "MultiPolygon" !== l.type) ? 0 : 1),
        "Point" === l.type)
      )
        e(c, f), f++;
      else if ("LineString" === l.type || "MultiPoint" === l.type)
        for (r = 0; r < c.length; r++) e(c[r], f), f++;
      else if ("Polygon" === l.type || "MultiLineString" === l.type)
        for (r = 0; r < c.length; r++)
          for (o = 0; o < c[r].length - d; o++) e(c[r][o], f), f++;
      else if ("MultiPolygon" === l.type)
        for (r = 0; r < c.length; r++)
          for (o = 0; o < c[r].length; o++)
            for (s = 0; s < c[r][o].length - d; s++) e(c[r][o][s], f), f++;
      else {
        if ("GeometryCollection" !== l.type)
          throw new Error("Unknown Geometry Type");
        for (r = 0; r < l.geometries.length; r++) Wg(l.geometries[r], e, i);
      }
}
function qg(t, e) {
  var i;
  switch (t.type) {
    case "FeatureCollection":
      for (i = 0; i < t.features.length; i++) e(t.features[i].properties, i);
      break;
    case "Feature":
      e(t.properties, 0);
  }
}
function Yg(t, e) {
  if ("Feature" === t.type) e(t, 0);
  else if ("FeatureCollection" === t.type)
    for (var i = 0; i < t.features.length; i++) e(t.features[i], i);
}
function Xg(t, e) {
  var i,
    n,
    r,
    o,
    a,
    s,
    l,
    u = 0,
    c = "FeatureCollection" === t.type,
    h = "Feature" === t.type,
    p = c ? t.features.length : 1;
  for (i = 0; i < p; i++)
    for (
      a = (l =
        "GeometryCollection" ===
        (s = c ? t.features[i].geometry : h ? t.geometry : t).type)
        ? s.geometries.length
        : 1,
        r = 0;
      r < a;
      r++
    )
      if (
        "Point" === (o = l ? s.geometries[r] : s).type ||
        "LineString" === o.type ||
        "MultiPoint" === o.type ||
        "Polygon" === o.type ||
        "MultiLineString" === o.type ||
        "MultiPolygon" === o.type
      )
        e(o, u), u++;
      else {
        if ("GeometryCollection" !== o.type)
          throw new Error("Unknown Geometry Type");
        for (n = 0; n < o.geometries.length; n++) e(o.geometries[n], u), u++;
      }
}
(Vg.coordEach = Wg),
  (Vg.coordReduce = function (t, e, i, n) {
    var r = i;
    return (
      Wg(
        t,
        function (t, n) {
          r = 0 === n && void 0 === i ? t : e(r, t, n);
        },
        n
      ),
      r
    );
  }),
  (Vg.propEach = qg),
  (Vg.propReduce = function (t, e, i) {
    var n = i;
    return (
      qg(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (Vg.featureEach = Yg),
  (Vg.featureReduce = function (t, e, i) {
    var n = i;
    return (
      Yg(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (Vg.coordAll = function (t) {
    var e = [];
    return (
      Wg(t, function (t) {
        e.push(t);
      }),
      e
    );
  }),
  (Vg.geomEach = Xg),
  (Vg.geomReduce = function (t, e, i) {
    var n = i;
    return (
      Xg(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  });
var Qg = Dg.topology,
  Zg = Gg.merge,
  Jg = Ug,
  Kg = Vg.geomEach,
  $g = function t(e) {
    switch ((e && e.type) || null) {
      case "FeatureCollection":
        return (
          (e.features = e.features.reduce(function (e, i) {
            return e.concat(t(i));
          }, [])),
          e
        );
      case "Feature":
        return e.geometry
          ? t(e.geometry).map(function (t) {
              var i = {
                type: "Feature",
                properties: JSON.parse(JSON.stringify(e.properties)),
                geometry: t,
              };
              return void 0 !== e.id && (i.id = e.id), i;
            })
          : e;
      case "MultiPoint":
        return e.coordinates.map(function (t) {
          return {
            type: "Point",
            coordinates: t,
          };
        });
      case "MultiPolygon":
        return e.coordinates.map(function (t) {
          return {
            type: "Polygon",
            coordinates: t,
          };
        });
      case "MultiLineString":
        return e.coordinates.map(function (t) {
          return {
            type: "LineString",
            coordinates: t,
          };
        });
      case "GeometryCollection":
        return e.geometries.map(t).reduce(function (t, e) {
          return t.concat(e);
        }, []);
      case "Point":
      case "Polygon":
      case "LineString":
        return [e];
    }
  },
  tm = function () {
    var t = ((i = arguments),
      i.length
        ? Array.isArray(i[0])
          ? i[0]
          : Array.prototype.slice.call(i)
        : []).reduce(function (t, e) {
        var i = $g(e);
        Array.isArray(i) || (i = [i]);
        for (var n = 0; n < i.length; n++)
          Kg(i[n], function (e) {
            t.push(e);
          });
        return t;
      }, []),
      e = (function (t) {
        for (var e = null, i = 0; i < t.length; i++)
          if (e) {
            if (e !== t[i].type) return null;
          } else e = t[i].type;
        return e;
      })(t);
    var i;
    if (!e) throw new Error("List does not contain only homoegenous GeoJSON");
    switch (e) {
      case "LineString":
        return Jg(t);
      case "Polygon":
        return (function (t) {
          var e = {
              geoms: {
                type: "GeometryCollection",
                geometries: JSON.parse(JSON.stringify(t)),
              },
            },
            i = Qg(e);
          return Zg(i, i.objects.geoms.geometries);
        })(t);
      default:
        return t;
    }
  };
var em = {
    exports: {},
  },
  im = function (t, e) {
    (this.p1 = t), (this.p2 = e);
  };
(im.prototype.rise = function () {
  return this.p2[1] - this.p1[1];
}),
  (im.prototype.run = function () {
    return this.p2[0] - this.p1[0];
  }),
  (im.prototype.slope = function () {
    return this.rise() / this.run();
  }),
  (im.prototype.yIntercept = function () {
    return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
  }),
  (im.prototype.isVertical = function () {
    return !isFinite(this.slope());
  }),
  (im.prototype.isHorizontal = function () {
    return this.p1[1] == this.p2[1];
  }),
  (im.prototype._perpendicularDistanceHorizontal = function (t) {
    return Math.abs(this.p1[1] - t[1]);
  }),
  (im.prototype._perpendicularDistanceVertical = function (t) {
    return Math.abs(this.p1[0] - t[0]);
  }),
  (im.prototype._perpendicularDistanceHasSlope = function (t) {
    var e = this.slope(),
      i = this.yIntercept();
    return Math.abs(e * t[0] - t[1] + i) / Math.sqrt(Math.pow(e, 2) + 1);
  }),
  (im.prototype.perpendicularDistance = function (t) {
    return this.isVertical()
      ? this._perpendicularDistanceVertical(t)
      : this.isHorizontal()
      ? this._perpendicularDistanceHorizontal(t)
      : this._perpendicularDistanceHasSlope(t);
  });
var nm = im,
  rm = function (t, e) {
    for (var i = 0, n = 0, r = 1; r <= t.length - 2; r++) {
      var o = new nm(t[0], t[t.length - 1]).perpendicularDistance(t[r]);
      o > i && ((n = r), (i = o));
    }
    if (i > e)
      var a = rm(t.slice(0, n), e),
        s = rm(t.slice(n, t.length), e),
        l = a.concat(s);
    else l = t.length > 1 ? [t[0], t[t.length - 1]] : [t[0]];
    return l;
  },
  om = rm;
!(function (t) {
  var e = om;
  function i(e, i) {
    var n = e.geometry,
      r = n.type;
    if ("LineString" === r)
      n.coordinates = t.exports.simplify(n.coordinates, i);
    else if ("Polygon" === r || "MultiLineString" === r)
      for (var o = 0; o < n.coordinates.length; o++)
        n.coordinates[o] = t.exports.simplify(n.coordinates[o], i);
    else if ("MultiPolygon" === r)
      for (var a = 0; a < n.coordinates.length; a++)
        for (var s = 0; s < n.coordinates[a].length; s++)
          n.coordinates[a][s] = t.exports.simplify(n.coordinates[a][s], i);
    return e;
  }
  (t.exports = function (t, e, n) {
    return (
      n || (t = JSON.parse(JSON.stringify(t))),
      t.features
        ? (function (t, e) {
            for (var n = 0; n < t.features.length; n++)
              t.features[n] = i(t.features[n], e);
            return t;
          })(t, e)
        : t.type && "Feature" === t.type
        ? i(t, e)
        : new Error("FeatureCollection or individual Feature required")
    );
  }),
    (t.exports.simplify = function (t, i) {
      return e(t, i);
    });
})(em);
const am = {
  rewind: ag,
  bbox: function (t) {
    var e, i;
    if (t.hasOwnProperty("type"))
      return (
        (e = cg(t)),
        (i = [
          Number.POSITIVE_INFINITY,
          Number.POSITIVE_INFINITY,
          Number.NEGATIVE_INFINITY,
          Number.NEGATIVE_INFINITY,
        ]),
        e.reduce(function (t, e) {
          return [
            Math.min(e[0], t[0]),
            Math.min(e[1], t[1]),
            Math.max(e[0], t[2]),
            Math.max(e[1], t[3]),
          ];
        }, i)
      );
  },
  flatten: function t(e) {
    switch ((e && e.type) || null) {
      case "FeatureCollection":
        return (
          (e.features = e.features.reduce(function (e, i) {
            return e.concat(t(i));
          }, [])),
          e
        );
      case "Feature":
        return e.geometry
          ? t(e.geometry).map(function (t) {
              var i = {
                type: "Feature",
                properties: JSON.parse(JSON.stringify(e.properties)),
                geometry: t,
              };
              return void 0 !== e.id && (i.id = e.id), i;
            })
          : [e];
      case "MultiPoint":
        return e.coordinates.map(function (t) {
          return {
            type: "Point",
            coordinates: t,
          };
        });
      case "MultiPolygon":
        return e.coordinates.map(function (t) {
          return {
            type: "Polygon",
            coordinates: t,
          };
        });
      case "MultiLineString":
        return e.coordinates.map(function (t) {
          return {
            type: "LineString",
            coordinates: t,
          };
        });
      case "GeometryCollection":
        return e.geometries.map(t).reduce(function (t, e) {
          return t.concat(e);
        }, []);
      case "Point":
      case "Polygon":
      case "LineString":
        return [e];
    }
  },
  dissolve: tm,
  simplify: em.exports,
};
function sm(t, e) {
  const i = (t) => {
      const i = e(t);
      (t[0] = +i[0].toFixed(6)), (t[1] = +i[1].toFixed(6));
    },
    n = JSON.parse(JSON.stringify(t));
  switch (n.type) {
    case "FeatureCollection":
      for (let t = 0; t < n.features.length; t++) lm(n.features[t].geometry, i);
      break;
    case "Feature":
      lm(n.geometry, i);
      break;
    case "GeometryCollection":
      for (let t = 0; t < n.geometries.length; t++) lm(n.geometries[t], i);
      break;
    default:
      lm(n, i);
  }
  return n;
}
function lm(t, e) {
  let i, n, r;
  const o = t.coordinates;
  switch (t.type) {
    case "Point":
      e(o);
      break;
    case "LineString":
    case "MultiPoint":
      for (i = 0; i < o.length; i++) e(o[i]);
      break;
    case "Polygon":
    case "MultiLineString":
      for (i = 0; i < o.length; i++)
        for (n = 0; n < o[i].length; n++) e(o[i][n]);
      break;
    case "MultiPolygon":
      for (i = 0; i < o.length; i++)
        for (n = 0; n < o[i].length; n++)
          for (r = 0; r < o[i][n].length; r++) e(o[i][n][r]);
  }
}
var um = 6371008.8,
  cm = {
    centimeters: 100 * um,
    centimetres: 100 * um,
    degrees: um / 111325,
    feet: 3.28084 * um,
    inches: 39.37 * um,
    kilometers: um / 1e3,
    kilometres: um / 1e3,
    meters: um,
    metres: um,
    miles: um / 1609.344,
    millimeters: 1e3 * um,
    millimetres: 1e3 * um,
    nauticalmiles: um / 1852,
    radians: 1,
    yards: 1.0936 * um,
  };
function hm(t, e, i) {
  void 0 === i && (i = {});
  var n = {
    type: "Feature",
  };
  return (
    (0 === i.id || i.id) && (n.id = i.id),
    i.bbox && (n.bbox = i.bbox),
    (n.properties = e || {}),
    (n.geometry = t),
    n
  );
}
function pm(t, e, i) {
  if ((void 0 === i && (i = {}), !t))
    throw new Error("coordinates is required");
  if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
  if (t.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Sm(t[0]) || !Sm(t[1]))
    throw new Error("coordinates must contain numbers");
  return hm(
    {
      type: "Point",
      coordinates: t,
    },
    e,
    i
  );
}
function dm(t, e, i) {
  void 0 === i && (i = {});
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    if (o.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    for (var a = 0; a < o[o.length - 1].length; a++)
      if (o[o.length - 1][a] !== o[0][a])
        throw new Error("First and last Position are not equivalent.");
  }
  return hm(
    {
      type: "Polygon",
      coordinates: t,
    },
    e,
    i
  );
}
function fm(t, e, i) {
  if ((void 0 === i && (i = {}), t.length < 2))
    throw new Error("coordinates must be an array of two or more positions");
  return hm(
    {
      type: "LineString",
      coordinates: t,
    },
    e,
    i
  );
}
function gm(t, e) {
  void 0 === e && (e = {});
  var i = {
    type: "FeatureCollection",
  };
  return (
    e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), (i.features = t), i
  );
}
function mm(t, e, i) {
  return (
    void 0 === i && (i = {}),
    hm(
      {
        type: "MultiLineString",
        coordinates: t,
      },
      e,
      i
    )
  );
}
function ym(t, e, i) {
  return (
    void 0 === i && (i = {}),
    hm(
      {
        type: "MultiPolygon",
        coordinates: t,
      },
      e,
      i
    )
  );
}
function vm(t, e) {
  void 0 === e && (e = "kilometers");
  var i = cm[e];
  if (!i) throw new Error(e + " units is invalid");
  return t * i;
}
function bm(t, e) {
  void 0 === e && (e = "kilometers");
  var i = cm[e];
  if (!i) throw new Error(e + " units is invalid");
  return t / i;
}
function xm(t) {
  return (180 * (t % (2 * Math.PI))) / Math.PI;
}
function _m(t) {
  return ((t % 360) * Math.PI) / 180;
}
function Sm(t) {
  return !isNaN(t) && null !== t && !Array.isArray(t);
}
function Mm(t, e, i) {
  if (null !== t)
    for (
      var n,
        r,
        o,
        a,
        s,
        l,
        u,
        c,
        h = 0,
        p = 0,
        d = t.type,
        f = "FeatureCollection" === d,
        g = "Feature" === d,
        m = f ? t.features.length : 1,
        y = 0;
      y < m;
      y++
    ) {
      s = (c =
        !!(u = f ? t.features[y].geometry : g ? t.geometry : t) &&
        "GeometryCollection" === u.type)
        ? u.geometries.length
        : 1;
      for (var v = 0; v < s; v++) {
        var b = 0,
          x = 0;
        if (null !== (a = c ? u.geometries[v] : u)) {
          l = a.coordinates;
          var _ = a.type;
          switch (
            ((h = !i || ("Polygon" !== _ && "MultiPolygon" !== _) ? 0 : 1), _)
          ) {
            case null:
              break;
            case "Point":
              if (!1 === e(l, p, y, b, x)) return !1;
              p++, b++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < l.length; n++) {
                if (!1 === e(l[n], p, y, b, x)) return !1;
                p++, "MultiPoint" === _ && b++;
              }
              "LineString" === _ && b++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < l.length; n++) {
                for (r = 0; r < l[n].length - h; r++) {
                  if (!1 === e(l[n][r], p, y, b, x)) return !1;
                  p++;
                }
                "MultiLineString" === _ && b++, "Polygon" === _ && x++;
              }
              "Polygon" === _ && b++;
              break;
            case "MultiPolygon":
              for (n = 0; n < l.length; n++) {
                for (x = 0, r = 0; r < l[n].length; r++) {
                  for (o = 0; o < l[n][r].length - h; o++) {
                    if (!1 === e(l[n][r][o], p, y, b, x)) return !1;
                    p++;
                  }
                  x++;
                }
                b++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < a.geometries.length; n++)
                if (!1 === Mm(a.geometries[n], e, i)) return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Cm(t, e) {
  if ("Feature" === t.type) e(t, 0);
  else if ("FeatureCollection" === t.type)
    for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);
}
function wm(t, e) {
  var i,
    n,
    r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p = 0,
    d = "FeatureCollection" === t.type,
    f = "Feature" === t.type,
    g = d ? t.features.length : 1;
  for (i = 0; i < g; i++) {
    for (
      s = d ? t.features[i].geometry : f ? t.geometry : t,
        u = d ? t.features[i].properties : f ? t.properties : {},
        c = d ? t.features[i].bbox : f ? t.bbox : void 0,
        h = d ? t.features[i].id : f ? t.id : void 0,
        a = (l = !!s && "GeometryCollection" === s.type)
          ? s.geometries.length
          : 1,
        r = 0;
      r < a;
      r++
    )
      if (null !== (o = l ? s.geometries[r] : s))
        switch (o.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            if (!1 === e(o, p, u, c, h)) return !1;
            break;
          case "GeometryCollection":
            for (n = 0; n < o.geometries.length; n++)
              if (!1 === e(o.geometries[n], p, u, c, h)) return !1;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      else if (!1 === e(null, p, u, c, h)) return !1;
    p++;
  }
}
function Am(t, e) {
  wm(t, function (t, i, n, r, o) {
    var a,
      s = null === t ? null : t.type;
    switch (s) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return (
          !1 !==
            e(
              hm(t, n, {
                bbox: r,
                id: o,
              }),
              i,
              0
            ) && void 0
        );
    }
    switch (s) {
      case "MultiPoint":
        a = "Point";
        break;
      case "MultiLineString":
        a = "LineString";
        break;
      case "MultiPolygon":
        a = "Polygon";
    }
    for (var l = 0; l < t.coordinates.length; l++) {
      var u = t.coordinates[l];
      if (
        !1 ===
        e(
          hm(
            {
              type: a,
              coordinates: u,
            },
            n
          ),
          i,
          l
        )
      )
        return !1;
    }
  });
}
function Em(t) {
  var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return (
    Mm(t, function (t) {
      e[0] > t[0] && (e[0] = t[0]),
        e[1] > t[1] && (e[1] = t[1]),
        e[2] < t[0] && (e[2] = t[0]),
        e[3] < t[1] && (e[3] = t[1]);
    }),
    e
  );
}
function Dm(t) {
  if (!t) throw new Error("coord is required");
  if (!Array.isArray(t)) {
    if (
      "Feature" === t.type &&
      null !== t.geometry &&
      "Point" === t.geometry.type
    )
      return t.geometry.coordinates;
    if ("Point" === t.type) return t.coordinates;
  }
  if (
    Array.isArray(t) &&
    t.length >= 2 &&
    !Array.isArray(t[0]) &&
    !Array.isArray(t[1])
  )
    return t;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Tm(t) {
  if (Array.isArray(t)) return t;
  if ("Feature" === t.type) {
    if (null !== t.geometry) return t.geometry.coordinates;
  } else if (t.coordinates) return t.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function Pm(t) {
  return "Feature" === t.type ? t.geometry : t;
}
function Lm(t, e) {
  return "FeatureCollection" === t.type
    ? "FeatureCollection"
    : "GeometryCollection" === t.type
    ? "GeometryCollection"
    : "Feature" === t.type && null !== t.geometry
    ? t.geometry.type
    : t.type;
}
function Im(t, e, i) {
  if ((void 0 === i && (i = {}), !t)) throw new Error("point is required");
  if (!e) throw new Error("polygon is required");
  var n = Dm(t),
    r = Pm(e),
    o = r.type,
    a = e.bbox,
    s = r.coordinates;
  if (
    a &&
    !1 ===
      (function (t, e) {
        return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
      })(n, a)
  )
    return !1;
  "Polygon" === o && (s = [s]);
  for (var l = !1, u = 0; u < s.length && !l; u++)
    if (Nm(n, s[u][0], i.ignoreBoundary)) {
      for (var c = !1, h = 1; h < s[u].length && !c; )
        Nm(n, s[u][h], !i.ignoreBoundary) && (c = !0), h++;
      c || (l = !0);
    }
  return l;
}
function Nm(t, e, i) {
  var n = !1;
  e[0][0] === e[e.length - 1][0] &&
    e[0][1] === e[e.length - 1][1] &&
    (e = e.slice(0, e.length - 1));
  for (var r = 0, o = e.length - 1; r < e.length; o = r++) {
    var a = e[r][0],
      s = e[r][1],
      l = e[o][0],
      u = e[o][1];
    if (
      t[1] * (a - l) + s * (l - t[0]) + u * (t[0] - a) == 0 &&
      (a - t[0]) * (l - t[0]) <= 0 &&
      (s - t[1]) * (u - t[1]) <= 0
    )
      return !i;
    s > t[1] != u > t[1] &&
      t[0] < ((l - a) * (t[1] - s)) / (u - s) + a &&
      (n = !n);
  }
  return n;
}
function Rm(t, e, i) {
  void 0 === i && (i = {});
  var n = Dm(t),
    r = Dm(e),
    o = _m(r[1] - n[1]),
    a = _m(r[0] - n[0]),
    s = _m(n[1]),
    l = _m(r[1]),
    u =
      Math.pow(Math.sin(o / 2), 2) +
      Math.pow(Math.sin(a / 2), 2) * Math.cos(s) * Math.cos(l);
  return vm(2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)), i.units);
}
function Om(t, e, i, n) {
  void 0 === n && (n = {});
  var r = Dm(t),
    o = _m(r[0]),
    a = _m(r[1]),
    s = _m(i),
    l = bm(e, n.units),
    u = Math.asin(
      Math.sin(a) * Math.cos(l) + Math.cos(a) * Math.sin(l) * Math.cos(s)
    );
  return pm(
    [
      xm(
        o +
          Math.atan2(
            Math.sin(s) * Math.sin(l) * Math.cos(a),
            Math.cos(l) - Math.sin(a) * Math.sin(u)
          )
      ),
      xm(u),
    ],
    n.properties
  );
}
function Fm(t, e, i) {
  if ((void 0 === i && (i = {}), !0 === i.final))
    return (function (t, e) {
      var i = Fm(e, t);
      return (i = (i + 180) % 360);
    })(t, e);
  var n = Dm(t),
    r = Dm(e),
    o = _m(n[0]),
    a = _m(r[0]),
    s = _m(n[1]),
    l = _m(r[1]),
    u = Math.sin(a - o) * Math.cos(l),
    c = Math.cos(s) * Math.sin(l) - Math.sin(s) * Math.cos(l) * Math.cos(a - o);
  return xm(Math.atan2(u, c));
}
function zm(t, e) {
  void 0 === e && (e = {});
  var i = Em(t);
  return pm([(i[0] + i[2]) / 2, (i[1] + i[3]) / 2], e.properties, e);
}
function km(t) {
  if (!t) throw new Error("geojson is required");
  var e = [];
  return (
    Am(t, function (t) {
      !(function (t, e) {
        var i = [],
          n = t.geometry;
        if (null !== n) {
          switch (n.type) {
            case "Polygon":
              i = Tm(n);
              break;
            case "LineString":
              i = [Tm(n)];
          }
          i.forEach(function (i) {
            var n = (function (t, e) {
              var i = [];
              return (
                t.reduce(function (t, n) {
                  var r,
                    o,
                    a,
                    s,
                    l,
                    u,
                    c = fm([t, n], e);
                  return (
                    (c.bbox =
                      ((o = n),
                      (a = (r = t)[0]),
                      (s = r[1]),
                      (l = o[0]),
                      (u = o[1]),
                      [
                        a < l ? a : l,
                        s < u ? s : u,
                        a > l ? a : l,
                        s > u ? s : u,
                      ])),
                    i.push(c),
                    n
                  );
                }),
                i
              );
            })(i, t.properties);
            n.forEach(function (t) {
              (t.id = e.length), e.push(t);
            });
          });
        }
      })(t, e);
    }),
    gm(e)
  );
}
Em.default = Em;
var Bm = {
  exports: {},
};
function Gm(t, e, i, n, r) {
  Um(t, e, i || 0, n || t.length - 1, r || Hm);
}
function Um(t, e, i, n, r) {
  for (; n > i; ) {
    if (n - i > 600) {
      var o = n - i + 1,
        a = e - i + 1,
        s = Math.log(o),
        l = 0.5 * Math.exp((2 * s) / 3),
        u = 0.5 * Math.sqrt((s * l * (o - l)) / o) * (a - o / 2 < 0 ? -1 : 1);
      Um(
        t,
        e,
        Math.max(i, Math.floor(e - (a * l) / o + u)),
        Math.min(n, Math.floor(e + ((o - a) * l) / o + u)),
        r
      );
    }
    var c = t[e],
      h = i,
      p = n;
    for (jm(t, i, e), r(t[n], c) > 0 && jm(t, i, n); h < p; ) {
      for (jm(t, h, p), h++, p--; r(t[h], c) < 0; ) h++;
      for (; r(t[p], c) > 0; ) p--;
    }
    0 === r(t[i], c) ? jm(t, i, p) : jm(t, ++p, n),
      p <= e && (i = p + 1),
      e <= p && (n = p - 1);
  }
}
function jm(t, e, i) {
  var n = t[e];
  (t[e] = t[i]), (t[i] = n);
}
function Hm(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Vm(t, e, i) {
  if (!i) return e.indexOf(t);
  for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n;
  return -1;
}
function Wm(t, e) {
  qm(t, 0, t.children.length, e, t);
}
function qm(t, e, i, n, r) {
  r || (r = ey(null)),
    (r.minX = 1 / 0),
    (r.minY = 1 / 0),
    (r.maxX = -1 / 0),
    (r.maxY = -1 / 0);
  for (let o = e; o < i; o++) {
    const e = t.children[o];
    Ym(r, t.leaf ? n(e) : e);
  }
  return r;
}
function Ym(t, e) {
  return (
    (t.minX = Math.min(t.minX, e.minX)),
    (t.minY = Math.min(t.minY, e.minY)),
    (t.maxX = Math.max(t.maxX, e.maxX)),
    (t.maxY = Math.max(t.maxY, e.maxY)),
    t
  );
}
function Xm(t, e) {
  return t.minX - e.minX;
}
function Qm(t, e) {
  return t.minY - e.minY;
}
function Zm(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function Jm(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function Km(t, e) {
  const i = Math.max(t.minX, e.minX),
    n = Math.max(t.minY, e.minY),
    r = Math.min(t.maxX, e.maxX),
    o = Math.min(t.maxY, e.maxY);
  return Math.max(0, r - i) * Math.max(0, o - n);
}
function $m(t, e) {
  return (
    t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
  );
}
function ty(t, e) {
  return (
    e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
  );
}
function ey(t) {
  return {
    children: t,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0,
  };
}
function iy(t, e, i, n, r) {
  const o = [e, i];
  for (; o.length; ) {
    if ((i = o.pop()) - (e = o.pop()) <= n) continue;
    const a = e + Math.ceil((i - e) / n / 2) * n;
    Gm(t, a, e, i, r), o.push(e, a, a, i);
  }
}
var ny = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: class {
          constructor(t = 9) {
            (this._maxEntries = Math.max(4, t)),
              (this._minEntries = Math.max(
                2,
                Math.ceil(0.4 * this._maxEntries)
              )),
              this.clear();
          }
          all() {
            return this._all(this.data, []);
          }
          search(t) {
            let e = this.data;
            const i = [];
            if (!ty(t, e)) return i;
            const n = this.toBBox,
              r = [];
            for (; e; ) {
              for (let o = 0; o < e.children.length; o++) {
                const a = e.children[o],
                  s = e.leaf ? n(a) : a;
                ty(t, s) &&
                  (e.leaf ? i.push(a) : $m(t, s) ? this._all(a, i) : r.push(a));
              }
              e = r.pop();
            }
            return i;
          }
          collides(t) {
            let e = this.data;
            if (!ty(t, e)) return !1;
            const i = [];
            for (; e; ) {
              for (let n = 0; n < e.children.length; n++) {
                const r = e.children[n],
                  o = e.leaf ? this.toBBox(r) : r;
                if (ty(t, o)) {
                  if (e.leaf || $m(t, o)) return !0;
                  i.push(r);
                }
              }
              e = i.pop();
            }
            return !1;
          }
          load(t) {
            if (!t || !t.length) return this;
            if (t.length < this._minEntries) {
              for (let e = 0; e < t.length; e++) this.insert(t[e]);
              return this;
            }
            let e = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length)
              if (this.data.height === e.height) this._splitRoot(this.data, e);
              else {
                if (this.data.height < e.height) {
                  const t = this.data;
                  (this.data = e), (e = t);
                }
                this._insert(e, this.data.height - e.height - 1, !0);
              }
            else this.data = e;
            return this;
          }
          insert(t) {
            return t && this._insert(t, this.data.height - 1), this;
          }
          clear() {
            return (this.data = ey([])), this;
          }
          remove(t, e) {
            if (!t) return this;
            let i = this.data;
            const n = this.toBBox(t),
              r = [],
              o = [];
            let a, s, l;
            for (; i || r.length; ) {
              if (
                (i ||
                  ((i = r.pop()),
                  (s = r[r.length - 1]),
                  (a = o.pop()),
                  (l = !0)),
                i.leaf)
              ) {
                const n = Vm(t, i.children, e);
                if (-1 !== n)
                  return (
                    i.children.splice(n, 1), r.push(i), this._condense(r), this
                  );
              }
              l || i.leaf || !$m(i, n)
                ? s
                  ? (a++, (i = s.children[a]), (l = !1))
                  : (i = null)
                : (r.push(i), o.push(a), (a = 0), (s = i), (i = i.children[0]));
            }
            return this;
          }
          toBBox(t) {
            return t;
          }
          compareMinX(t, e) {
            return t.minX - e.minX;
          }
          compareMinY(t, e) {
            return t.minY - e.minY;
          }
          toJSON() {
            return this.data;
          }
          fromJSON(t) {
            return (this.data = t), this;
          }
          _all(t, e) {
            const i = [];
            for (; t; )
              t.leaf ? e.push(...t.children) : i.push(...t.children),
                (t = i.pop());
            return e;
          }
          _build(t, e, i, n) {
            const r = i - e + 1;
            let o,
              a = this._maxEntries;
            if (r <= a)
              return (o = ey(t.slice(e, i + 1))), Wm(o, this.toBBox), o;
            n ||
              ((n = Math.ceil(Math.log(r) / Math.log(a))),
              (a = Math.ceil(r / Math.pow(a, n - 1)))),
              (o = ey([])),
              (o.leaf = !1),
              (o.height = n);
            const s = Math.ceil(r / a),
              l = s * Math.ceil(Math.sqrt(a));
            iy(t, e, i, l, this.compareMinX);
            for (let u = e; u <= i; u += l) {
              const e = Math.min(u + l - 1, i);
              iy(t, u, e, s, this.compareMinY);
              for (let i = u; i <= e; i += s) {
                const r = Math.min(i + s - 1, e);
                o.children.push(this._build(t, i, r, n - 1));
              }
            }
            return Wm(o, this.toBBox), o;
          }
          _chooseSubtree(t, e, i, n) {
            for (; n.push(e), !e.leaf && n.length - 1 !== i; ) {
              let i,
                n = 1 / 0,
                a = 1 / 0;
              for (let s = 0; s < e.children.length; s++) {
                const l = e.children[s],
                  u = Zm(l),
                  c =
                    ((r = t),
                    (o = l),
                    (Math.max(o.maxX, r.maxX) - Math.min(o.minX, r.minX)) *
                      (Math.max(o.maxY, r.maxY) - Math.min(o.minY, r.minY)) -
                      u);
                c < a
                  ? ((a = c), (n = u < n ? u : n), (i = l))
                  : c === a && u < n && ((n = u), (i = l));
              }
              e = i || e.children[0];
            }
            var r, o;
            return e;
          }
          _insert(t, e, i) {
            const n = i ? t : this.toBBox(t),
              r = [],
              o = this._chooseSubtree(n, this.data, e, r);
            for (
              o.children.push(t), Ym(o, n);
              e >= 0 && r[e].children.length > this._maxEntries;

            )
              this._split(r, e), e--;
            this._adjustParentBBoxes(n, r, e);
          }
          _split(t, e) {
            const i = t[e],
              n = i.children.length,
              r = this._minEntries;
            this._chooseSplitAxis(i, r, n);
            const o = this._chooseSplitIndex(i, r, n),
              a = ey(i.children.splice(o, i.children.length - o));
            (a.height = i.height),
              (a.leaf = i.leaf),
              Wm(i, this.toBBox),
              Wm(a, this.toBBox),
              e ? t[e - 1].children.push(a) : this._splitRoot(i, a);
          }
          _splitRoot(t, e) {
            (this.data = ey([t, e])),
              (this.data.height = t.height + 1),
              (this.data.leaf = !1),
              Wm(this.data, this.toBBox);
          }
          _chooseSplitIndex(t, e, i) {
            let n,
              r = 1 / 0,
              o = 1 / 0;
            for (let a = e; a <= i - e; a++) {
              const e = qm(t, 0, a, this.toBBox),
                s = qm(t, a, i, this.toBBox),
                l = Km(e, s),
                u = Zm(e) + Zm(s);
              l < r
                ? ((r = l), (n = a), (o = u < o ? u : o))
                : l === r && u < o && ((o = u), (n = a));
            }
            return n || i - e;
          }
          _chooseSplitAxis(t, e, i) {
            const n = t.leaf ? this.compareMinX : Xm,
              r = t.leaf ? this.compareMinY : Qm;
            this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) &&
              t.children.sort(n);
          }
          _allDistMargin(t, e, i, n) {
            t.children.sort(n);
            const r = this.toBBox,
              o = qm(t, 0, e, r),
              a = qm(t, i - e, i, r);
            let s = Jm(o) + Jm(a);
            for (let l = e; l < i - e; l++) {
              const e = t.children[l];
              Ym(o, t.leaf ? r(e) : e), (s += Jm(o));
            }
            for (let l = i - e - 1; l >= e; l--) {
              const e = t.children[l];
              Ym(a, t.leaf ? r(e) : e), (s += Jm(a));
            }
            return s;
          }
          _adjustParentBBoxes(t, e, i) {
            for (let n = i; n >= 0; n--) Ym(e[n], t);
          }
          _condense(t) {
            for (let e, i = t.length - 1; i >= 0; i--)
              0 === t[i].children.length
                ? i > 0
                  ? ((e = t[i - 1].children), e.splice(e.indexOf(t[i]), 1))
                  : this.clear()
                : Wm(t[i], this.toBBox);
          }
        },
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  ry = ht(ny),
  oy = {};
!(function (t) {
  function e(t, e, i) {
    void 0 === i && (i = {});
    var n = {
      type: "Feature",
    };
    return (
      (0 === i.id || i.id) && (n.id = i.id),
      i.bbox && (n.bbox = i.bbox),
      (n.properties = e || {}),
      (n.geometry = t),
      n
    );
  }
  function i(t, i, n) {
    if ((void 0 === n && (n = {}), !t))
      throw new Error("coordinates is required");
    if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
    if (t.length < 2)
      throw new Error("coordinates must be at least 2 numbers long");
    if (!p(t[0]) || !p(t[1]))
      throw new Error("coordinates must contain numbers");
    return e(
      {
        type: "Point",
        coordinates: t,
      },
      i,
      n
    );
  }
  function n(t, i, n) {
    void 0 === n && (n = {});
    for (var r = 0, o = t; r < o.length; r++) {
      var a = o[r];
      if (a.length < 4)
        throw new Error(
          "Each LinearRing of a Polygon must have 4 or more Positions."
        );
      for (var s = 0; s < a[a.length - 1].length; s++)
        if (a[a.length - 1][s] !== a[0][s])
          throw new Error("First and last Position are not equivalent.");
    }
    return e(
      {
        type: "Polygon",
        coordinates: t,
      },
      i,
      n
    );
  }
  function r(t, i, n) {
    if ((void 0 === n && (n = {}), t.length < 2))
      throw new Error("coordinates must be an array of two or more positions");
    return e(
      {
        type: "LineString",
        coordinates: t,
      },
      i,
      n
    );
  }
  function o(t, e) {
    void 0 === e && (e = {});
    var i = {
      type: "FeatureCollection",
    };
    return (
      e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), (i.features = t), i
    );
  }
  function a(t, i, n) {
    return (
      void 0 === n && (n = {}),
      e(
        {
          type: "MultiLineString",
          coordinates: t,
        },
        i,
        n
      )
    );
  }
  function s(t, i, n) {
    return (
      void 0 === n && (n = {}),
      e(
        {
          type: "MultiPoint",
          coordinates: t,
        },
        i,
        n
      )
    );
  }
  function l(t, i, n) {
    return (
      void 0 === n && (n = {}),
      e(
        {
          type: "MultiPolygon",
          coordinates: t,
        },
        i,
        n
      )
    );
  }
  function u(e, i) {
    void 0 === i && (i = "kilometers");
    var n = t.factors[i];
    if (!n) throw new Error(i + " units is invalid");
    return e * n;
  }
  function c(e, i) {
    void 0 === i && (i = "kilometers");
    var n = t.factors[i];
    if (!n) throw new Error(i + " units is invalid");
    return e / n;
  }
  function h(t) {
    return (180 * (t % (2 * Math.PI))) / Math.PI;
  }
  function p(t) {
    return !isNaN(t) && null !== t && !Array.isArray(t);
  }
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.earthRadius = 6371008.8),
    (t.factors = {
      centimeters: 100 * t.earthRadius,
      centimetres: 100 * t.earthRadius,
      degrees: t.earthRadius / 111325,
      feet: 3.28084 * t.earthRadius,
      inches: 39.37 * t.earthRadius,
      kilometers: t.earthRadius / 1e3,
      kilometres: t.earthRadius / 1e3,
      meters: t.earthRadius,
      metres: t.earthRadius,
      miles: t.earthRadius / 1609.344,
      millimeters: 1e3 * t.earthRadius,
      millimetres: 1e3 * t.earthRadius,
      nauticalmiles: t.earthRadius / 1852,
      radians: 1,
      yards: 1.0936 * t.earthRadius,
    }),
    (t.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 0.001,
      kilometres: 0.001,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / t.earthRadius,
      yards: 1.0936133,
    }),
    (t.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046,
    }),
    (t.feature = e),
    (t.geometry = function (t, e, o) {
      switch (t) {
        case "Point":
          return i(e).geometry;
        case "LineString":
          return r(e).geometry;
        case "Polygon":
          return n(e).geometry;
        case "MultiPoint":
          return s(e).geometry;
        case "MultiLineString":
          return a(e).geometry;
        case "MultiPolygon":
          return l(e).geometry;
        default:
          throw new Error(t + " is invalid");
      }
    }),
    (t.point = i),
    (t.points = function (t, e, n) {
      return (
        void 0 === n && (n = {}),
        o(
          t.map(function (t) {
            return i(t, e);
          }),
          n
        )
      );
    }),
    (t.polygon = n),
    (t.polygons = function (t, e, i) {
      return (
        void 0 === i && (i = {}),
        o(
          t.map(function (t) {
            return n(t, e);
          }),
          i
        )
      );
    }),
    (t.lineString = r),
    (t.lineStrings = function (t, e, i) {
      return (
        void 0 === i && (i = {}),
        o(
          t.map(function (t) {
            return r(t, e);
          }),
          i
        )
      );
    }),
    (t.featureCollection = o),
    (t.multiLineString = a),
    (t.multiPoint = s),
    (t.multiPolygon = l),
    (t.geometryCollection = function (t, i, n) {
      return (
        void 0 === n && (n = {}),
        e(
          {
            type: "GeometryCollection",
            geometries: t,
          },
          i,
          n
        )
      );
    }),
    (t.round = function (t, e) {
      if ((void 0 === e && (e = 0), e && !(e >= 0)))
        throw new Error("precision must be a positive number");
      var i = Math.pow(10, e || 0);
      return Math.round(t * i) / i;
    }),
    (t.radiansToLength = u),
    (t.lengthToRadians = c),
    (t.lengthToDegrees = function (t, e) {
      return h(c(t, e));
    }),
    (t.bearingToAzimuth = function (t) {
      var e = t % 360;
      return e < 0 && (e += 360), e;
    }),
    (t.radiansToDegrees = h),
    (t.degreesToRadians = function (t) {
      return ((t % 360) * Math.PI) / 180;
    }),
    (t.convertLength = function (t, e, i) {
      if (
        (void 0 === e && (e = "kilometers"),
        void 0 === i && (i = "kilometers"),
        !(t >= 0))
      )
        throw new Error("length must be a positive number");
      return u(c(t, e), i);
    }),
    (t.convertArea = function (e, i, n) {
      if (
        (void 0 === i && (i = "meters"),
        void 0 === n && (n = "kilometers"),
        !(e >= 0))
      )
        throw new Error("area must be a positive number");
      var r = t.areaFactors[i];
      if (!r) throw new Error("invalid original units");
      var o = t.areaFactors[n];
      if (!o) throw new Error("invalid final units");
      return (e / r) * o;
    }),
    (t.isNumber = p),
    (t.isObject = function (t) {
      return !!t && t.constructor === Object;
    }),
    (t.validateBBox = function (t) {
      if (!t) throw new Error("bbox is required");
      if (!Array.isArray(t)) throw new Error("bbox must be an Array");
      if (4 !== t.length && 6 !== t.length)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      t.forEach(function (t) {
        if (!p(t)) throw new Error("bbox must only contain numbers");
      });
    }),
    (t.validateId = function (t) {
      if (!t) throw new Error("id is required");
      if (-1 === ["string", "number"].indexOf(typeof t))
        throw new Error("id must be a number or a string");
    });
})(oy);
var ay = {};
Object.defineProperty(ay, "__esModule", {
  value: !0,
});
var sy = oy;
function ly(t, e, i) {
  if (null !== t)
    for (
      var n,
        r,
        o,
        a,
        s,
        l,
        u,
        c,
        h = 0,
        p = 0,
        d = t.type,
        f = "FeatureCollection" === d,
        g = "Feature" === d,
        m = f ? t.features.length : 1,
        y = 0;
      y < m;
      y++
    ) {
      s = (c =
        !!(u = f ? t.features[y].geometry : g ? t.geometry : t) &&
        "GeometryCollection" === u.type)
        ? u.geometries.length
        : 1;
      for (var v = 0; v < s; v++) {
        var b = 0,
          x = 0;
        if (null !== (a = c ? u.geometries[v] : u)) {
          l = a.coordinates;
          var _ = a.type;
          switch (
            ((h = !i || ("Polygon" !== _ && "MultiPolygon" !== _) ? 0 : 1), _)
          ) {
            case null:
              break;
            case "Point":
              if (!1 === e(l, p, y, b, x)) return !1;
              p++, b++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < l.length; n++) {
                if (!1 === e(l[n], p, y, b, x)) return !1;
                p++, "MultiPoint" === _ && b++;
              }
              "LineString" === _ && b++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < l.length; n++) {
                for (r = 0; r < l[n].length - h; r++) {
                  if (!1 === e(l[n][r], p, y, b, x)) return !1;
                  p++;
                }
                "MultiLineString" === _ && b++, "Polygon" === _ && x++;
              }
              "Polygon" === _ && b++;
              break;
            case "MultiPolygon":
              for (n = 0; n < l.length; n++) {
                for (x = 0, r = 0; r < l[n].length; r++) {
                  for (o = 0; o < l[n][r].length - h; o++) {
                    if (!1 === e(l[n][r][o], p, y, b, x)) return !1;
                    p++;
                  }
                  x++;
                }
                b++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < a.geometries.length; n++)
                if (!1 === ly(a.geometries[n], e, i)) return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function uy(t, e) {
  var i;
  switch (t.type) {
    case "FeatureCollection":
      for (
        i = 0;
        i < t.features.length && !1 !== e(t.features[i].properties, i);
        i++
      );
      break;
    case "Feature":
      e(t.properties, 0);
  }
}
function cy(t, e) {
  if ("Feature" === t.type) e(t, 0);
  else if ("FeatureCollection" === t.type)
    for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);
}
function hy(t, e) {
  var i,
    n,
    r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p = 0,
    d = "FeatureCollection" === t.type,
    f = "Feature" === t.type,
    g = d ? t.features.length : 1;
  for (i = 0; i < g; i++) {
    for (
      s = d ? t.features[i].geometry : f ? t.geometry : t,
        u = d ? t.features[i].properties : f ? t.properties : {},
        c = d ? t.features[i].bbox : f ? t.bbox : void 0,
        h = d ? t.features[i].id : f ? t.id : void 0,
        a = (l = !!s && "GeometryCollection" === s.type)
          ? s.geometries.length
          : 1,
        r = 0;
      r < a;
      r++
    )
      if (null !== (o = l ? s.geometries[r] : s))
        switch (o.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            if (!1 === e(o, p, u, c, h)) return !1;
            break;
          case "GeometryCollection":
            for (n = 0; n < o.geometries.length; n++)
              if (!1 === e(o.geometries[n], p, u, c, h)) return !1;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      else if (!1 === e(null, p, u, c, h)) return !1;
    p++;
  }
}
function py(t, e) {
  hy(t, function (t, i, n, r, o) {
    var a,
      s = null === t ? null : t.type;
    switch (s) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return (
          !1 !==
            e(
              sy.feature(t, n, {
                bbox: r,
                id: o,
              }),
              i,
              0
            ) && void 0
        );
    }
    switch (s) {
      case "MultiPoint":
        a = "Point";
        break;
      case "MultiLineString":
        a = "LineString";
        break;
      case "MultiPolygon":
        a = "Polygon";
    }
    for (var l = 0; l < t.coordinates.length; l++) {
      var u = {
        type: a,
        coordinates: t.coordinates[l],
      };
      if (!1 === e(sy.feature(u, n), i, l)) return !1;
    }
  });
}
function dy(t, e) {
  py(t, function (t, i, n) {
    var r = 0;
    if (t.geometry) {
      var o = t.geometry.type;
      if ("Point" !== o && "MultiPoint" !== o) {
        var a,
          s = 0,
          l = 0,
          u = 0;
        return (
          !1 !==
            ly(t, function (o, c, h, p, d) {
              if (void 0 === a || i > s || p > l || d > u)
                return (a = o), (s = i), (l = p), (u = d), void (r = 0);
              var f = sy.lineString([a, o], t.properties);
              if (!1 === e(f, i, n, d, r)) return !1;
              r++, (a = o);
            }) && void 0
        );
      }
    }
  });
}
function fy(t, e) {
  if (!t) throw new Error("geojson is required");
  py(t, function (t, i, n) {
    if (null !== t.geometry) {
      var r = t.geometry.type,
        o = t.geometry.coordinates;
      switch (r) {
        case "LineString":
          if (!1 === e(t, i, n, 0, 0)) return !1;
          break;
        case "Polygon":
          for (var a = 0; a < o.length; a++)
            if (!1 === e(sy.lineString(o[a], t.properties), i, n, a)) return !1;
      }
    }
  });
}
(ay.coordAll = function (t) {
  var e = [];
  return (
    ly(t, function (t) {
      e.push(t);
    }),
    e
  );
}),
  (ay.coordEach = ly),
  (ay.coordReduce = function (t, e, i, n) {
    var r = i;
    return (
      ly(
        t,
        function (t, n, o, a, s) {
          r = 0 === n && void 0 === i ? t : e(r, t, n, o, a, s);
        },
        n
      ),
      r
    );
  }),
  (ay.featureEach = cy),
  (ay.featureReduce = function (t, e, i) {
    var n = i;
    return (
      cy(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (ay.findPoint = function (t, e) {
    if (((e = e || {}), !sy.isObject(e))) throw new Error("options is invalid");
    var i,
      n = e.featureIndex || 0,
      r = e.multiFeatureIndex || 0,
      o = e.geometryIndex || 0,
      a = e.coordIndex || 0,
      s = e.properties;
    switch (t.type) {
      case "FeatureCollection":
        n < 0 && (n = t.features.length + n),
          (s = s || t.features[n].properties),
          (i = t.features[n].geometry);
        break;
      case "Feature":
        (s = s || t.properties), (i = t.geometry);
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        i = t;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (null === i) return null;
    var l = i.coordinates;
    switch (i.type) {
      case "Point":
        return sy.point(l, s, e);
      case "MultiPoint":
        return r < 0 && (r = l.length + r), sy.point(l[r], s, e);
      case "LineString":
        return a < 0 && (a = l.length + a), sy.point(l[a], s, e);
      case "Polygon":
        return (
          o < 0 && (o = l.length + o),
          a < 0 && (a = l[o].length + a),
          sy.point(l[o][a], s, e)
        );
      case "MultiLineString":
        return (
          r < 0 && (r = l.length + r),
          a < 0 && (a = l[r].length + a),
          sy.point(l[r][a], s, e)
        );
      case "MultiPolygon":
        return (
          r < 0 && (r = l.length + r),
          o < 0 && (o = l[r].length + o),
          a < 0 && (a = l[r][o].length - a),
          sy.point(l[r][o][a], s, e)
        );
    }
    throw new Error("geojson is invalid");
  }),
  (ay.findSegment = function (t, e) {
    if (((e = e || {}), !sy.isObject(e))) throw new Error("options is invalid");
    var i,
      n = e.featureIndex || 0,
      r = e.multiFeatureIndex || 0,
      o = e.geometryIndex || 0,
      a = e.segmentIndex || 0,
      s = e.properties;
    switch (t.type) {
      case "FeatureCollection":
        n < 0 && (n = t.features.length + n),
          (s = s || t.features[n].properties),
          (i = t.features[n].geometry);
        break;
      case "Feature":
        (s = s || t.properties), (i = t.geometry);
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        i = t;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (null === i) return null;
    var l = i.coordinates;
    switch (i.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return (
          a < 0 && (a = l.length + a - 1), sy.lineString([l[a], l[a + 1]], s, e)
        );
      case "Polygon":
        return (
          o < 0 && (o = l.length + o),
          a < 0 && (a = l[o].length + a - 1),
          sy.lineString([l[o][a], l[o][a + 1]], s, e)
        );
      case "MultiLineString":
        return (
          r < 0 && (r = l.length + r),
          a < 0 && (a = l[r].length + a - 1),
          sy.lineString([l[r][a], l[r][a + 1]], s, e)
        );
      case "MultiPolygon":
        return (
          r < 0 && (r = l.length + r),
          o < 0 && (o = l[r].length + o),
          a < 0 && (a = l[r][o].length - a - 1),
          sy.lineString([l[r][o][a], l[r][o][a + 1]], s, e)
        );
    }
    throw new Error("geojson is invalid");
  }),
  (ay.flattenEach = py),
  (ay.flattenReduce = function (t, e, i) {
    var n = i;
    return (
      py(t, function (t, r, o) {
        n = 0 === r && 0 === o && void 0 === i ? t : e(n, t, r, o);
      }),
      n
    );
  }),
  (ay.geomEach = hy),
  (ay.geomReduce = function (t, e, i) {
    var n = i;
    return (
      hy(t, function (t, r, o, a, s) {
        n = 0 === r && void 0 === i ? t : e(n, t, r, o, a, s);
      }),
      n
    );
  }),
  (ay.lineEach = fy),
  (ay.lineReduce = function (t, e, i) {
    var n = i;
    return (
      fy(t, function (t, r, o, a) {
        n = 0 === r && void 0 === i ? t : e(n, t, r, o, a);
      }),
      n
    );
  }),
  (ay.propEach = uy),
  (ay.propReduce = function (t, e, i) {
    var n = i;
    return (
      uy(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (ay.segmentEach = dy),
  (ay.segmentReduce = function (t, e, i) {
    var n = i,
      r = !1;
    return (
      dy(t, function (t, o, a, s, l) {
        (n = !1 === r && void 0 === i ? t : e(n, t, o, a, s, l)), (r = !0);
      }),
      n
    );
  });
var gy = {};
Object.defineProperty(gy, "__esModule", {
  value: !0,
});
var my = ay;
function yy(t) {
  var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return (
    my.coordEach(t, function (t) {
      e[0] > t[0] && (e[0] = t[0]),
        e[1] > t[1] && (e[1] = t[1]),
        e[2] < t[0] && (e[2] = t[0]),
        e[3] < t[1] && (e[3] = t[1]);
    }),
    e
  );
}
(yy.default = yy), (gy.default = yy);
var vy = ry,
  by = oy,
  xy = ay,
  _y = gy.default,
  Sy = xy.featureEach;
xy.coordEach;
var My = by.featureCollection;
function Cy(t) {
  var e = new vy(t);
  return (
    (e.insert = function (t) {
      if ("Feature" !== t.type) throw new Error("invalid feature");
      return (
        (t.bbox = t.bbox ? t.bbox : _y(t)), vy.prototype.insert.call(this, t)
      );
    }),
    (e.load = function (t) {
      var e = [];
      return (
        Array.isArray(t)
          ? t.forEach(function (t) {
              if ("Feature" !== t.type) throw new Error("invalid features");
              (t.bbox = t.bbox ? t.bbox : _y(t)), e.push(t);
            })
          : Sy(t, function (t) {
              if ("Feature" !== t.type) throw new Error("invalid features");
              (t.bbox = t.bbox ? t.bbox : _y(t)), e.push(t);
            }),
        vy.prototype.load.call(this, e)
      );
    }),
    (e.remove = function (t, e) {
      if ("Feature" !== t.type) throw new Error("invalid feature");
      return (
        (t.bbox = t.bbox ? t.bbox : _y(t)), vy.prototype.remove.call(this, t, e)
      );
    }),
    (e.clear = function () {
      return vy.prototype.clear.call(this);
    }),
    (e.search = function (t) {
      var e = vy.prototype.search.call(this, this.toBBox(t));
      return My(e);
    }),
    (e.collides = function (t) {
      return vy.prototype.collides.call(this, this.toBBox(t));
    }),
    (e.all = function () {
      var t = vy.prototype.all.call(this);
      return My(t);
    }),
    (e.toJSON = function () {
      return vy.prototype.toJSON.call(this);
    }),
    (e.fromJSON = function (t) {
      return vy.prototype.fromJSON.call(this, t);
    }),
    (e.toBBox = function (t) {
      var e;
      if (t.bbox) e = t.bbox;
      else if (Array.isArray(t) && 4 === t.length) e = t;
      else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]];
      else if ("Feature" === t.type) e = _y(t);
      else {
        if ("FeatureCollection" !== t.type) throw new Error("invalid geojson");
        e = _y(t);
      }
      return {
        minX: e[0],
        minY: e[1],
        maxX: e[2],
        maxY: e[3],
      };
    }),
    e
  );
}
(Bm.exports = Cy), (Bm.exports.default = Cy);
var wy = Bm.exports;
function Ay(t, e) {
  var i = {},
    n = [];
  if (
    ("LineString" === t.type && (t = hm(t)),
    "LineString" === e.type && (e = hm(e)),
    "Feature" === t.type &&
      "Feature" === e.type &&
      null !== t.geometry &&
      null !== e.geometry &&
      "LineString" === t.geometry.type &&
      "LineString" === e.geometry.type &&
      2 === t.geometry.coordinates.length &&
      2 === e.geometry.coordinates.length)
  ) {
    var r = Ey(t, e);
    return r && n.push(r), gm(n);
  }
  var o = wy();
  return (
    o.load(km(e)),
    Cm(km(t), function (t) {
      Cm(o.search(t), function (e) {
        var r = Ey(t, e);
        if (r) {
          var o = Tm(r).join(",");
          i[o] || ((i[o] = !0), n.push(r));
        }
      });
    }),
    gm(n)
  );
}
function Ey(t, e) {
  var i = Tm(t),
    n = Tm(e);
  if (2 !== i.length)
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (2 !== n.length)
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  var r = i[0][0],
    o = i[0][1],
    a = i[1][0],
    s = i[1][1],
    l = n[0][0],
    u = n[0][1],
    c = n[1][0],
    h = n[1][1],
    p = (h - u) * (a - r) - (c - l) * (s - o),
    d = (c - l) * (o - u) - (h - u) * (r - l),
    f = (a - r) * (o - u) - (s - o) * (r - l);
  if (0 === p) return null;
  var g = d / p,
    m = f / p;
  return g >= 0 && g <= 1 && m >= 0 && m <= 1
    ? pm([r + g * (a - r), o + g * (s - o)])
    : null;
}
function Dy(t, e, i) {
  void 0 === i && (i = {});
  for (var n = Dm(t), r = Tm(e), o = 0; o < r.length - 1; o++) {
    var a = !1;
    if (
      (i.ignoreEndVertices &&
        (0 === o && (a = "start"),
        o === r.length - 2 && (a = "end"),
        0 === o && o + 1 === r.length - 1 && (a = "both")),
      Ty(r[o], r[o + 1], n, a, void 0 === i.epsilon ? null : i.epsilon))
    )
      return !0;
  }
  return !1;
}
function Ty(t, e, i, n, r) {
  var o = i[0],
    a = i[1],
    s = t[0],
    l = t[1],
    u = e[0],
    c = e[1],
    h = u - s,
    p = c - l,
    d = (i[0] - s) * p - (i[1] - l) * h;
  if (null !== r) {
    if (Math.abs(d) > r) return !1;
  } else if (0 !== d) return !1;
  return n
    ? "start" === n
      ? Math.abs(h) >= Math.abs(p)
        ? h > 0
          ? s < o && o <= u
          : u <= o && o < s
        : p > 0
        ? l < a && a <= c
        : c <= a && a < l
      : "end" === n
      ? Math.abs(h) >= Math.abs(p)
        ? h > 0
          ? s <= o && o < u
          : u < o && o <= s
        : p > 0
        ? l <= a && a < c
        : c < a && a <= l
      : "both" === n &&
        (Math.abs(h) >= Math.abs(p)
          ? h > 0
            ? s < o && o < u
            : u < o && o < s
          : p > 0
          ? l < a && a < c
          : c < a && a < l)
    : Math.abs(h) >= Math.abs(p)
    ? h > 0
      ? s <= o && o <= u
      : u <= o && o <= s
    : p > 0
    ? l <= a && a <= c
    : c <= a && a <= l;
}
function Py(t, e) {
  var i = Pm(t),
    n = Pm(e),
    r = i.type,
    o = n.type;
  switch (r) {
    case "Point":
      switch (o) {
        case "MultiPoint":
          return (function (t, e) {
            var i,
              n = !1;
            for (i = 0; i < e.coordinates.length; i++)
              if (Iy(e.coordinates[i], t.coordinates)) {
                n = !0;
                break;
              }
            return n;
          })(i, n);
        case "LineString":
          return Dy(i, n, {
            ignoreEndVertices: !0,
          });
        case "Polygon":
        case "MultiPolygon":
          return Im(i, n, {
            ignoreBoundary: !0,
          });
        default:
          throw new Error("feature2 " + o + " geometry not supported");
      }
    case "MultiPoint":
      switch (o) {
        case "MultiPoint":
          return (function (t, e) {
            for (var i = 0; i < t.coordinates.length; i++) {
              for (var n = !1, r = 0; r < e.coordinates.length; r++)
                Iy(t.coordinates[i], e.coordinates[r]) && (n = !0);
              if (!n) return !1;
            }
            return !0;
          })(i, n);
        case "LineString":
          return (function (t, e) {
            for (var i = !1, n = 0; n < t.coordinates.length; n++) {
              if (!Dy(t.coordinates[n], e)) return !1;
              i ||
                (i = Dy(t.coordinates[n], e, {
                  ignoreEndVertices: !0,
                }));
            }
            return i;
          })(i, n);
        case "Polygon":
        case "MultiPolygon":
          return (function (t, e) {
            for (var i = !0, n = !1, r = 0; r < t.coordinates.length; r++) {
              if (!(n = Im(t.coordinates[1], e))) {
                i = !1;
                break;
              }
              n = Im(t.coordinates[1], e, {
                ignoreBoundary: !0,
              });
            }
            return i && n;
          })(i, n);
        default:
          throw new Error("feature2 " + o + " geometry not supported");
      }
    case "LineString":
      switch (o) {
        case "LineString":
          return (function (t, e) {
            for (var i = 0; i < t.coordinates.length; i++)
              if (!Dy(t.coordinates[i], e)) return !1;
            return !0;
          })(i, n);
        case "Polygon":
        case "MultiPolygon":
          return (function (t, e) {
            var i = Em(e),
              n = Em(t);
            if (!Ly(i, n)) return !1;
            for (var r = !1, o = 0; o < t.coordinates.length - 1; o++) {
              if (!Im(t.coordinates[o], e)) return !1;
              if (
                (r ||
                  (r = Im(t.coordinates[o], e, {
                    ignoreBoundary: !0,
                  })),
                !r)
              )
                r = Im(Ny(t.coordinates[o], t.coordinates[o + 1]), e, {
                  ignoreBoundary: !0,
                });
            }
            return r;
          })(i, n);
        default:
          throw new Error("feature2 " + o + " geometry not supported");
      }
    case "Polygon":
      switch (o) {
        case "Polygon":
        case "MultiPolygon":
          return (function (t, e) {
            var i = Em(t);
            if (!Ly(Em(e), i)) return !1;
            for (var n = 0; n < t.coordinates[0].length; n++)
              if (!Im(t.coordinates[0][n], e)) return !1;
            return !0;
          })(i, n);
        default:
          throw new Error("feature2 " + o + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + r + " geometry not supported");
  }
}
function Ly(t, e) {
  return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);
}
function Iy(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function Ny(t, e) {
  return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];
}
function Ry(t, e) {
  void 0 === e && (e = {});
  var i = e.precision,
    n = e.coordinates,
    r = e.mutate;
  if (
    ((i = null == i || isNaN(i) ? 6 : i),
    (n = null == n || isNaN(n) ? 3 : n),
    !t)
  )
    throw new Error("<geojson> is required");
  if ("number" != typeof i) throw new Error("<precision> must be a number");
  if ("number" != typeof n) throw new Error("<coordinates> must be a number");
  (!1 !== r && void 0 !== r) || (t = JSON.parse(JSON.stringify(t)));
  var o = Math.pow(10, i);
  return (
    Mm(t, function (t) {
      !(function (t, e, i) {
        t.length > i && t.splice(i, t.length);
        for (var n = 0; n < t.length; n++) t[n] = Math.round(t[n] * e) / e;
      })(t, o, n);
    }),
    t
  );
}
function Oy(t, e) {
  var i = [],
    n = wy();
  return (
    Am(e, function (e) {
      if (
        (i.forEach(function (t, e) {
          t.id = e;
        }),
        i.length)
      ) {
        var r = n.search(e);
        if (r.features.length) {
          var o = zy(e, r);
          (i = i.filter(function (t) {
            return t.id !== o.id;
          })),
            n.remove(o),
            Cm(Fy(o, e), function (t) {
              i.push(t), n.insert(t);
            });
        }
      } else
        (i = Fy(t, e).features).forEach(function (t) {
          t.bbox ||
            (t.bbox = (function (t) {
              var e = t[0],
                i = t[1],
                n = t[2],
                r = t[3];
              if (Rm(t.slice(0, 2), [n, i]) >= Rm(t.slice(0, 2), [e, r])) {
                var o = (i + r) / 2;
                return [e, o - (n - e) / 2, n, o + (n - e) / 2];
              }
              var a = (e + n) / 2;
              return [a - (r - i) / 2, i, a + (r - i) / 2, r];
            })(Em(t)));
        }),
          n.load(gm(i));
    }),
    gm(i)
  );
}
function Fy(t, e) {
  var i = [],
    n = Tm(t)[0],
    r = Tm(t)[t.geometry.coordinates.length - 1];
  if (ky(n, Dm(e)) || ky(r, Dm(e))) return gm([t]);
  var o = wy(),
    a = km(t);
  o.load(a);
  var s = o.search(e);
  if (!s.features.length) return gm([t]);
  var l = zy(e, s),
    u = (function (t, e, i) {
      var n = i;
      return (
        Cm(t, function (t, r) {
          n = 0 === r && void 0 === i ? t : e(n, t, r);
        }),
        n
      );
    })(
      a,
      function (t, n, r) {
        var o = Tm(n)[1],
          a = Dm(e);
        return r === l.id
          ? (t.push(a), i.push(fm(t)), ky(a, o) ? [a] : [a, o])
          : (t.push(o), t);
      },
      [n]
    );
  return u.length > 1 && i.push(fm(u)), gm(i);
}
function zy(t, e) {
  if (!e.features.length) throw new Error("lines must contain features");
  if (1 === e.features.length) return e.features[0];
  var i,
    n = 1 / 0;
  return (
    Cm(e, function (e) {
      var r = (function (t, e, i) {
          void 0 === i && (i = {});
          var n = pm([1 / 0, 1 / 0], {
              dist: 1 / 0,
            }),
            r = 0;
          return (
            Am(t, function (t) {
              for (var o = Tm(t), a = 0; a < o.length - 1; a++) {
                var s = pm(o[a]);
                s.properties.dist = Rm(e, s, i);
                var l = pm(o[a + 1]);
                l.properties.dist = Rm(e, l, i);
                var u = Rm(s, l, i),
                  c = Math.max(s.properties.dist, l.properties.dist),
                  h = Fm(s, l),
                  p = Om(e, c, h + 90, i),
                  d = Om(e, c, h - 90, i),
                  f = Ay(
                    fm([p.geometry.coordinates, d.geometry.coordinates]),
                    fm([s.geometry.coordinates, l.geometry.coordinates])
                  ),
                  g = null;
                f.features.length > 0 &&
                  (((g = f.features[0]).properties.dist = Rm(e, g, i)),
                  (g.properties.location = r + Rm(s, g, i))),
                  s.properties.dist < n.properties.dist &&
                    (((n = s).properties.index = a),
                    (n.properties.location = r)),
                  l.properties.dist < n.properties.dist &&
                    (((n = l).properties.index = a + 1),
                    (n.properties.location = r + u)),
                  g &&
                    g.properties.dist < n.properties.dist &&
                    ((n = g).properties.index = a),
                  (r += u);
              }
            }),
            n
          );
        })(e, t),
        o = r.properties.dist;
      o < n && ((i = e), (n = o));
    }),
    i
  );
}
function ky(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function By(t, e) {
  void 0 === e && (e = {});
  var i = Pm(t);
  switch (
    (e.properties || "Feature" !== t.type || (e.properties = t.properties),
    i.type)
  ) {
    case "Polygon":
      return (function (t, e) {
        void 0 === e && (e = {});
        var i = Pm(t),
          n = i.coordinates,
          r = e.properties
            ? e.properties
            : "Feature" === t.type
            ? t.properties
            : {};
        return Gy(n, r);
      })(i, e);
    case "MultiPolygon":
      return (function (t, e) {
        void 0 === e && (e = {});
        var i = Pm(t),
          n = i.coordinates,
          r = e.properties
            ? e.properties
            : "Feature" === t.type
            ? t.properties
            : {},
          o = [];
        return (
          n.forEach(function (t) {
            o.push(Gy(t, r));
          }),
          gm(o)
        );
      })(i, e);
    default:
      throw new Error("invalid poly");
  }
}
function Gy(t, e) {
  return t.length > 1 ? mm(t, e) : fm(t[0], e);
}
function Uy(t, e) {
  var i, n, r, o, a, s, l;
  for (n = 1; n <= 8; n *= 2) {
    for (
      i = [], o = !(Hy((r = t[t.length - 1]), e) & n), a = 0;
      a < t.length;
      a++
    )
      (l = !(Hy((s = t[a]), e) & n)) !== o && i.push(jy(r, s, n, e)),
        l && i.push(s),
        (r = s),
        (o = l);
    if (!(t = i).length) break;
  }
  return i;
}
function jy(t, e, i, n) {
  return 8 & i
    ? [t[0] + ((e[0] - t[0]) * (n[3] - t[1])) / (e[1] - t[1]), n[3]]
    : 4 & i
    ? [t[0] + ((e[0] - t[0]) * (n[1] - t[1])) / (e[1] - t[1]), n[1]]
    : 2 & i
    ? [n[2], t[1] + ((e[1] - t[1]) * (n[2] - t[0])) / (e[0] - t[0])]
    : 1 & i
    ? [n[0], t[1] + ((e[1] - t[1]) * (n[0] - t[0])) / (e[0] - t[0])]
    : null;
}
function Hy(t, e) {
  var i = 0;
  return (
    t[0] < e[0] ? (i |= 1) : t[0] > e[2] && (i |= 2),
    t[1] < e[1] ? (i |= 4) : t[1] > e[3] && (i |= 8),
    i
  );
}
function Vy(t, e) {
  for (var i = [], n = 0, r = t; n < r.length; n++) {
    var o = Uy(r[n], e);
    o.length > 0 &&
      ((o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1]) ||
        o.push(o[0]),
      o.length >= 4 && i.push(o));
  }
  return i;
}
function Wy(t, e) {
  var i = !0;
  return (
    Am(t, function (t) {
      Am(e, function (e) {
        if (!1 === i) return !1;
        i = (function (t, e) {
          switch (t.type) {
            case "Point":
              switch (e.type) {
                case "Point":
                  return (
                    (i = t.coordinates),
                    (n = e.coordinates),
                    !(i[0] === n[0] && i[1] === n[1])
                  );
                case "LineString":
                  return !qy(e, t);
                case "Polygon":
                  return !Im(t, e);
              }
              break;
            case "LineString":
              switch (e.type) {
                case "Point":
                  return !qy(t, e);
                case "LineString":
                  return !(function (t, e) {
                    if (Ay(t, e).features.length > 0) return !0;
                    return !1;
                  })(t, e);
                case "Polygon":
                  return !Yy(e, t);
              }
              break;
            case "Polygon":
              switch (e.type) {
                case "Point":
                  return !Im(e, t);
                case "LineString":
                  return !Yy(t, e);
                case "Polygon":
                  return !(function (t, e) {
                    for (var i = 0, n = t.coordinates[0]; i < n.length; i++) {
                      if (Im(n[i], e)) return !0;
                    }
                    for (var r = 0, o = e.coordinates[0]; r < o.length; r++) {
                      if (Im(o[r], t)) return !0;
                    }
                    var a = Ay(By(t), By(e));
                    if (a.features.length > 0) return !0;
                    return !1;
                  })(e, t);
              }
          }
          var i, n;
          /**
           * splaytree v3.1.1
           * Fast Splay tree for Node and browser
           *
           * @author Alexander Milevski <info@w8r.name>
           * @license MIT
           * @preserve
           */
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
          return !1;
        })(t.geometry, e.geometry);
      });
    }),
    i
  );
}
function qy(t, e) {
  for (var i = 0; i < t.coordinates.length - 1; i++)
    if (Xy(t.coordinates[i], t.coordinates[i + 1], e.coordinates)) return !0;
  return !1;
}
function Yy(t, e) {
  for (var i = 0, n = e.coordinates; i < n.length; i++) {
    if (Im(n[i], t)) return !0;
  }
  return Ay(e, By(t)).features.length > 0;
}
function Xy(t, e, i) {
  var n = i[0] - t[0],
    r = i[1] - t[1],
    o = e[0] - t[0],
    a = e[1] - t[1];
  return (
    0 == n * a - r * o &&
    (Math.abs(o) >= Math.abs(a)
      ? o > 0
        ? t[0] <= i[0] && i[0] <= e[0]
        : e[0] <= i[0] && i[0] <= t[0]
      : a > 0
      ? t[1] <= i[1] && i[1] <= e[1]
      : e[1] <= i[1] && i[1] <= t[1])
  );
}
function Qy(t, e) {
  var i,
    n,
    r,
    o,
    a = {
      label: 0,
      sent: function () {
        if (1 & r[0]) throw r[1];
        return r[1];
      },
      trys: [],
      ops: [],
    };
  return (
    (o = {
      next: s(0),
      throw: s(1),
      return: s(2),
    }),
    "function" == typeof Symbol &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function s(o) {
    return function (s) {
      return (function (o) {
        if (i) throw new TypeError("Generator is already executing.");
        for (; a; )
          try {
            if (
              ((i = 1),
              n &&
                (r =
                  2 & o[0]
                    ? n.return
                    : o[0]
                    ? n.throw || ((r = n.return) && r.call(n), 0)
                    : n.next) &&
                !(r = r.call(n, o[1])).done)
            )
              return r;
            switch (((n = 0), r && (o = [2 & o[0], r.value]), o[0])) {
              case 0:
              case 1:
                r = o;
                break;
              case 4:
                return (
                  a.label++,
                  {
                    value: o[1],
                    done: !1,
                  }
                );
              case 5:
                a.label++, (n = o[1]), (o = [0]);
                continue;
              case 7:
                (o = a.ops.pop()), a.trys.pop();
                continue;
              default:
                if (
                  !((r = a.trys),
                  (r = r.length > 0 && r[r.length - 1]) ||
                    (6 !== o[0] && 2 !== o[0]))
                ) {
                  a = 0;
                  continue;
                }
                if (3 === o[0] && (!r || (o[1] > r[0] && o[1] < r[3]))) {
                  a.label = o[1];
                  break;
                }
                if (6 === o[0] && a.label < r[1]) {
                  (a.label = r[1]), (r = o);
                  break;
                }
                if (r && a.label < r[2]) {
                  (a.label = r[2]), a.ops.push(o);
                  break;
                }
                r[2] && a.ops.pop(), a.trys.pop();
                continue;
            }
            o = e.call(t, a);
          } catch (s) {
            (o = [6, s]), (n = 0);
          } finally {
            i = r = 0;
          }
        if (5 & o[0]) throw o[1];
        return {
          value: o[0] ? o[1] : void 0,
          done: !0,
        };
      })([o, s]);
    };
  }
}
var Zy = function (t, e) {
  (this.next = null),
    (this.key = t),
    (this.data = e),
    (this.left = null),
    (this.right = null);
};
function Jy(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function Ky(t, e, i) {
  for (var n = new Zy(null, null), r = n, o = n; ; ) {
    var a = i(t, e.key);
    if (a < 0) {
      if (null === e.left) break;
      if (i(t, e.left.key) < 0) {
        var s = e.left;
        if (((e.left = s.right), (s.right = e), null === (e = s).left)) break;
      }
      (o.left = e), (o = e), (e = e.left);
    } else {
      if (!(a > 0)) break;
      if (null === e.right) break;
      if (i(t, e.right.key) > 0) {
        s = e.right;
        if (((e.right = s.left), (s.left = e), null === (e = s).right)) break;
      }
      (r.right = e), (r = e), (e = e.right);
    }
  }
  return (
    (r.right = e.left),
    (o.left = e.right),
    (e.left = n.right),
    (e.right = n.left),
    e
  );
}
function $y(t, e, i, n) {
  var r = new Zy(t, e);
  if (null === i) return (r.left = r.right = null), r;
  var o = n(t, (i = Ky(t, i, n)).key);
  return (
    o < 0
      ? ((r.left = i.left), (r.right = i), (i.left = null))
      : o >= 0 && ((r.right = i.right), (r.left = i), (i.right = null)),
    r
  );
}
function tv(t, e, i) {
  var n = null,
    r = null;
  if (e) {
    var o = i((e = Ky(t, e, i)).key, t);
    0 === o
      ? ((n = e.left), (r = e.right))
      : o < 0
      ? ((r = e.right), (e.right = null), (n = e))
      : ((n = e.left), (e.left = null), (r = e));
  }
  return {
    left: n,
    right: r,
  };
}
function ev(t, e, i, n, r) {
  if (t) {
    n(e + (i ? "└── " : "├── ") + r(t) + "\n");
    var o = e + (i ? "    " : "│   ");
    t.left && ev(t.left, o, !1, n, r), t.right && ev(t.right, o, !0, n, r);
  }
}
var iv = (function () {
  function t(t) {
    void 0 === t && (t = Jy),
      (this._root = null),
      (this._size = 0),
      (this._comparator = t);
  }
  return (
    (t.prototype.insert = function (t, e) {
      return (
        this._size++, (this._root = $y(t, e, this._root, this._comparator))
      );
    }),
    (t.prototype.add = function (t, e) {
      var i = new Zy(t, e);
      null === this._root &&
        ((i.left = i.right = null), this._size++, (this._root = i));
      var n = this._comparator,
        r = Ky(t, this._root, n),
        o = n(t, r.key);
      return (
        0 === o
          ? (this._root = r)
          : (o < 0
              ? ((i.left = r.left), (i.right = r), (r.left = null))
              : o > 0 && ((i.right = r.right), (i.left = r), (r.right = null)),
            this._size++,
            (this._root = i)),
        this._root
      );
    }),
    (t.prototype.remove = function (t) {
      this._root = this._remove(t, this._root, this._comparator);
    }),
    (t.prototype._remove = function (t, e, i) {
      var n;
      return null === e
        ? null
        : 0 === i(t, (e = Ky(t, e, i)).key)
        ? (null === e.left
            ? (n = e.right)
            : ((n = Ky(t, e.left, i)).right = e.right),
          this._size--,
          n)
        : e;
    }),
    (t.prototype.pop = function () {
      var t = this._root;
      if (t) {
        for (; t.left; ) t = t.left;
        return (
          (this._root = Ky(t.key, this._root, this._comparator)),
          (this._root = this._remove(t.key, this._root, this._comparator)),
          {
            key: t.key,
            data: t.data,
          }
        );
      }
      return null;
    }),
    (t.prototype.findStatic = function (t) {
      for (var e = this._root, i = this._comparator; e; ) {
        var n = i(t, e.key);
        if (0 === n) return e;
        e = n < 0 ? e.left : e.right;
      }
      return null;
    }),
    (t.prototype.find = function (t) {
      return this._root &&
        ((this._root = Ky(t, this._root, this._comparator)),
        0 !== this._comparator(t, this._root.key))
        ? null
        : this._root;
    }),
    (t.prototype.contains = function (t) {
      for (var e = this._root, i = this._comparator; e; ) {
        var n = i(t, e.key);
        if (0 === n) return !0;
        e = n < 0 ? e.left : e.right;
      }
      return !1;
    }),
    (t.prototype.forEach = function (t, e) {
      for (var i = this._root, n = [], r = !1; !r; )
        null !== i
          ? (n.push(i), (i = i.left))
          : 0 !== n.length
          ? ((i = n.pop()), t.call(e, i), (i = i.right))
          : (r = !0);
      return this;
    }),
    (t.prototype.range = function (t, e, i, n) {
      for (
        var r = [], o = this._comparator, a = this._root;
        0 !== r.length || a;

      )
        if (a) r.push(a), (a = a.left);
        else {
          if (o((a = r.pop()).key, e) > 0) break;
          if (o(a.key, t) >= 0 && i.call(n, a)) return this;
          a = a.right;
        }
      return this;
    }),
    (t.prototype.keys = function () {
      var t = [];
      return (
        this.forEach(function (e) {
          var i = e.key;
          return t.push(i);
        }),
        t
      );
    }),
    (t.prototype.values = function () {
      var t = [];
      return (
        this.forEach(function (e) {
          var i = e.data;
          return t.push(i);
        }),
        t
      );
    }),
    (t.prototype.min = function () {
      return this._root ? this.minNode(this._root).key : null;
    }),
    (t.prototype.max = function () {
      return this._root ? this.maxNode(this._root).key : null;
    }),
    (t.prototype.minNode = function (t) {
      if ((void 0 === t && (t = this._root), t)) for (; t.left; ) t = t.left;
      return t;
    }),
    (t.prototype.maxNode = function (t) {
      if ((void 0 === t && (t = this._root), t)) for (; t.right; ) t = t.right;
      return t;
    }),
    (t.prototype.at = function (t) {
      for (var e = this._root, i = !1, n = 0, r = []; !i; )
        if (e) r.push(e), (e = e.left);
        else if (r.length > 0) {
          if (((e = r.pop()), n === t)) return e;
          n++, (e = e.right);
        } else i = !0;
      return null;
    }),
    (t.prototype.next = function (t) {
      var e = this._root,
        i = null;
      if (t.right) {
        for (i = t.right; i.left; ) i = i.left;
        return i;
      }
      for (var n = this._comparator; e; ) {
        var r = n(t.key, e.key);
        if (0 === r) break;
        r < 0 ? ((i = e), (e = e.left)) : (e = e.right);
      }
      return i;
    }),
    (t.prototype.prev = function (t) {
      var e = this._root,
        i = null;
      if (null !== t.left) {
        for (i = t.left; i.right; ) i = i.right;
        return i;
      }
      for (var n = this._comparator; e; ) {
        var r = n(t.key, e.key);
        if (0 === r) break;
        r < 0 ? (e = e.left) : ((i = e), (e = e.right));
      }
      return i;
    }),
    (t.prototype.clear = function () {
      return (this._root = null), (this._size = 0), this;
    }),
    (t.prototype.toList = function () {
      return (function (t) {
        var e = t,
          i = [],
          n = !1,
          r = new Zy(null, null),
          o = r;
        for (; !n; )
          e
            ? (i.push(e), (e = e.left))
            : i.length > 0
            ? (e = (e = o = o.next = i.pop()).right)
            : (n = !0);
        return (o.next = null), r.next;
      })(this._root);
    }),
    (t.prototype.load = function (t, e, i) {
      void 0 === e && (e = []), void 0 === i && (i = !1);
      var n = t.length,
        r = this._comparator;
      if ((i && ov(t, e, 0, n - 1, r), null === this._root))
        (this._root = nv(t, e, 0, n)), (this._size = n);
      else {
        var o = (function (t, e, i) {
          var n = new Zy(null, null),
            r = n,
            o = t,
            a = e;
          for (; null !== o && null !== a; )
            i(o.key, a.key) < 0
              ? ((r.next = o), (o = o.next))
              : ((r.next = a), (a = a.next)),
              (r = r.next);
          null !== o ? (r.next = o) : null !== a && (r.next = a);
          return n.next;
        })(
          this.toList(),
          (function (t, e) {
            for (var i = new Zy(null, null), n = i, r = 0; r < t.length; r++)
              n = n.next = new Zy(t[r], e[r]);
            return (n.next = null), i.next;
          })(t, e),
          r
        );
        (n = this._size + n),
          (this._root = rv(
            {
              head: o,
            },
            0,
            n
          ));
      }
      return this;
    }),
    (t.prototype.isEmpty = function () {
      return null === this._root;
    }),
    Object.defineProperty(t.prototype, "size", {
      get: function () {
        return this._size;
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(t.prototype, "root", {
      get: function () {
        return this._root;
      },
      enumerable: !0,
      configurable: !0,
    }),
    (t.prototype.toString = function (t) {
      void 0 === t &&
        (t = function (t) {
          return String(t.key);
        });
      var e = [];
      return (
        ev(
          this._root,
          "",
          !0,
          function (t) {
            return e.push(t);
          },
          t
        ),
        e.join("")
      );
    }),
    (t.prototype.update = function (t, e, i) {
      var n = this._comparator,
        r = tv(t, this._root, n),
        o = r.left,
        a = r.right;
      n(t, e) < 0 ? (a = $y(e, i, a, n)) : (o = $y(e, i, o, n)),
        (this._root = (function (t, e, i) {
          return null === e
            ? t
            : (null === t || ((e = Ky(t.key, e, i)).left = t), e);
        })(o, a, n));
    }),
    (t.prototype.split = function (t) {
      return tv(t, this._root, this._comparator);
    }),
    (t.prototype[Symbol.iterator] = function () {
      var t;
      return Qy(this, function (e) {
        switch (e.label) {
          case 0:
            (t = this.minNode()), (e.label = 1);
          case 1:
            return t ? [4, t] : [3, 3];
          case 2:
            return e.sent(), (t = this.next(t)), [3, 1];
          case 3:
            return [2];
        }
      });
    }),
    t
  );
})();
function nv(t, e, i, n) {
  var r = n - i;
  if (r > 0) {
    var o = i + Math.floor(r / 2),
      a = t[o],
      s = e[o],
      l = new Zy(a, s);
    return (l.left = nv(t, e, i, o)), (l.right = nv(t, e, o + 1, n)), l;
  }
  return null;
}
function rv(t, e, i) {
  var n = i - e;
  if (n > 0) {
    var r = e + Math.floor(n / 2),
      o = rv(t, e, r),
      a = t.head;
    return (a.left = o), (t.head = t.head.next), (a.right = rv(t, r + 1, i)), a;
  }
  return null;
}
function ov(t, e, i, n, r) {
  if (!(i >= n)) {
    for (var o = t[(i + n) >> 1], a = i - 1, s = n + 1; ; ) {
      do {
        a++;
      } while (r(t[a], o) < 0);
      do {
        s--;
      } while (r(t[s], o) > 0);
      if (a >= s) break;
      var l = t[a];
      (t[a] = t[s]), (t[s] = l), (l = e[a]), (e[a] = e[s]), (e[s] = l);
    }
    ov(t, e, i, s, r), ov(t, e, s + 1, n, r);
  }
}
function av(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function sv(t, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      "value" in n && (n.writable = !0),
      Object.defineProperty(t, n.key, n);
  }
}
function lv(t, e, i) {
  return e && sv(t.prototype, e), i && sv(t, i), t;
}
var uv = function (t, e) {
    return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y;
  },
  cv = function (t, e) {
    if (
      e.ur.x < t.ll.x ||
      t.ur.x < e.ll.x ||
      e.ur.y < t.ll.y ||
      t.ur.y < e.ll.y
    )
      return null;
    var i = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,
      n = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;
    return {
      ll: {
        x: i,
        y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y,
      },
      ur: {
        x: n,
        y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y,
      },
    };
  },
  hv = Number.EPSILON;
void 0 === hv && (hv = Math.pow(2, -52));
var pv = hv * hv,
  dv = function (t, e) {
    if (-hv < t && t < hv && -hv < e && e < hv) return 0;
    var i = t - e;
    return i * i < pv * t * e ? 0 : t < e ? -1 : 1;
  },
  fv = (function () {
    function t() {
      av(this, t), this.reset();
    }
    return (
      lv(t, [
        {
          key: "reset",
          value: function () {
            (this.xRounder = new gv()), (this.yRounder = new gv());
          },
        },
        {
          key: "round",
          value: function (t, e) {
            return {
              x: this.xRounder.round(t),
              y: this.yRounder.round(e),
            };
          },
        },
      ]),
      t
    );
  })(),
  gv = (function () {
    function t() {
      av(this, t), (this.tree = new iv()), this.round(0);
    }
    return (
      lv(t, [
        {
          key: "round",
          value: function (t) {
            var e = this.tree.add(t),
              i = this.tree.prev(e);
            if (null !== i && 0 === dv(e.key, i.key))
              return this.tree.remove(t), i.key;
            var n = this.tree.next(e);
            return null !== n && 0 === dv(e.key, n.key)
              ? (this.tree.remove(t), n.key)
              : t;
          },
        },
      ]),
      t
    );
  })(),
  mv = new fv(),
  yv = function (t, e) {
    return t.x * e.y - t.y * e.x;
  },
  vv = function (t, e) {
    return t.x * e.x + t.y * e.y;
  },
  bv = function (t, e, i) {
    var n = {
        x: e.x - t.x,
        y: e.y - t.y,
      },
      r = {
        x: i.x - t.x,
        y: i.y - t.y,
      },
      o = yv(n, r);
    return dv(o, 0);
  },
  xv = function (t) {
    return Math.sqrt(vv(t, t));
  },
  _v = function (t, e, i) {
    var n = {
        x: e.x - t.x,
        y: e.y - t.y,
      },
      r = {
        x: i.x - t.x,
        y: i.y - t.y,
      };
    return vv(r, n) / xv(r) / xv(n);
  },
  Sv = function (t, e, i) {
    return 0 === e.y
      ? null
      : {
          x: t.x + (e.x / e.y) * (i - t.y),
          y: i,
        };
  },
  Mv = function (t, e, i) {
    return 0 === e.x
      ? null
      : {
          x: i,
          y: t.y + (e.y / e.x) * (i - t.x),
        };
  },
  Cv = (function () {
    function t(e, i) {
      av(this, t),
        void 0 === e.events ? (e.events = [this]) : e.events.push(this),
        (this.point = e),
        (this.isLeft = i);
    }
    return (
      lv(t, null, [
        {
          key: "compare",
          value: function (e, i) {
            var n = t.comparePoints(e.point, i.point);
            return 0 !== n
              ? n
              : (e.point !== i.point && e.link(i),
                e.isLeft !== i.isLeft
                  ? e.isLeft
                    ? 1
                    : -1
                  : Av.compare(e.segment, i.segment));
          },
        },
        {
          key: "comparePoints",
          value: function (t, e) {
            return t.x < e.x
              ? -1
              : t.x > e.x
              ? 1
              : t.y < e.y
              ? -1
              : t.y > e.y
              ? 1
              : 0;
          },
        },
      ]),
      lv(t, [
        {
          key: "link",
          value: function (t) {
            if (t.point === this.point)
              throw new Error("Tried to link already linked events");
            for (var e = t.point.events, i = 0, n = e.length; i < n; i++) {
              var r = e[i];
              this.point.events.push(r), (r.point = this.point);
            }
            this.checkForConsuming();
          },
        },
        {
          key: "checkForConsuming",
          value: function () {
            for (var t = this.point.events.length, e = 0; e < t; e++) {
              var i = this.point.events[e];
              if (void 0 === i.segment.consumedBy)
                for (var n = e + 1; n < t; n++) {
                  var r = this.point.events[n];
                  void 0 === r.consumedBy &&
                    i.otherSE.point.events === r.otherSE.point.events &&
                    i.segment.consume(r.segment);
                }
            }
          },
        },
        {
          key: "getAvailableLinkedEvents",
          value: function () {
            for (var t = [], e = 0, i = this.point.events.length; e < i; e++) {
              var n = this.point.events[e];
              n !== this &&
                !n.segment.ringOut &&
                n.segment.isInResult() &&
                t.push(n);
            }
            return t;
          },
        },
        {
          key: "getLeftmostComparator",
          value: function (t) {
            var e = this,
              i = new Map(),
              n = function (n) {
                var r,
                  o,
                  a,
                  s,
                  l,
                  u = n.otherSE;
                i.set(n, {
                  sine:
                    ((r = e.point),
                    (o = t.point),
                    (a = u.point),
                    (s = {
                      x: o.x - r.x,
                      y: o.y - r.y,
                    }),
                    (l = {
                      x: a.x - r.x,
                      y: a.y - r.y,
                    }),
                    yv(l, s) / xv(l) / xv(s)),
                  cosine: _v(e.point, t.point, u.point),
                });
              };
            return function (t, e) {
              i.has(t) || n(t), i.has(e) || n(e);
              var r = i.get(t),
                o = r.sine,
                a = r.cosine,
                s = i.get(e),
                l = s.sine,
                u = s.cosine;
              return o >= 0 && l >= 0
                ? a < u
                  ? 1
                  : a > u
                  ? -1
                  : 0
                : o < 0 && l < 0
                ? a < u
                  ? -1
                  : a > u
                  ? 1
                  : 0
                : l < o
                ? -1
                : l > o
                ? 1
                : 0;
            };
          },
        },
      ]),
      t
    );
  })(),
  wv = 0,
  Av = (function () {
    function t(e, i, n, r) {
      av(this, t),
        (this.id = ++wv),
        (this.leftSE = e),
        (e.segment = this),
        (e.otherSE = i),
        (this.rightSE = i),
        (i.segment = this),
        (i.otherSE = e),
        (this.rings = n),
        (this.windings = r);
    }
    return (
      lv(t, null, [
        {
          key: "compare",
          value: function (t, e) {
            var i = t.leftSE.point.x,
              n = e.leftSE.point.x,
              r = t.rightSE.point.x,
              o = e.rightSE.point.x;
            if (o < i) return 1;
            if (r < n) return -1;
            var a = t.leftSE.point.y,
              s = e.leftSE.point.y,
              l = t.rightSE.point.y,
              u = e.rightSE.point.y;
            if (i < n) {
              if (s < a && s < l) return 1;
              if (s > a && s > l) return -1;
              var c = t.comparePoint(e.leftSE.point);
              if (c < 0) return 1;
              if (c > 0) return -1;
              var h = e.comparePoint(t.rightSE.point);
              return 0 !== h ? h : -1;
            }
            if (i > n) {
              if (a < s && a < u) return -1;
              if (a > s && a > u) return 1;
              var p = e.comparePoint(t.leftSE.point);
              if (0 !== p) return p;
              var d = t.comparePoint(e.rightSE.point);
              return d < 0 ? 1 : d > 0 ? -1 : 1;
            }
            if (a < s) return -1;
            if (a > s) return 1;
            if (r < o) {
              var f = e.comparePoint(t.rightSE.point);
              if (0 !== f) return f;
            }
            if (r > o) {
              var g = t.comparePoint(e.rightSE.point);
              if (g < 0) return 1;
              if (g > 0) return -1;
            }
            if (r !== o) {
              var m = l - a,
                y = r - i,
                v = u - s,
                b = o - n;
              if (m > y && v < b) return 1;
              if (m < y && v > b) return -1;
            }
            return r > o
              ? 1
              : r < o || l < u
              ? -1
              : l > u
              ? 1
              : t.id < e.id
              ? -1
              : t.id > e.id
              ? 1
              : 0;
          },
        },
      ]),
      lv(
        t,
        [
          {
            key: "replaceRightSE",
            value: function (t) {
              (this.rightSE = t),
                (this.rightSE.segment = this),
                (this.rightSE.otherSE = this.leftSE),
                (this.leftSE.otherSE = this.rightSE);
            },
          },
          {
            key: "bbox",
            value: function () {
              var t = this.leftSE.point.y,
                e = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: t < e ? t : e,
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: t > e ? t : e,
                },
              };
            },
          },
          {
            key: "vector",
            value: function () {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y,
              };
            },
          },
          {
            key: "isAnEndpoint",
            value: function (t) {
              return (
                (t.x === this.leftSE.point.x && t.y === this.leftSE.point.y) ||
                (t.x === this.rightSE.point.x && t.y === this.rightSE.point.y)
              );
            },
          },
          {
            key: "comparePoint",
            value: function (t) {
              if (this.isAnEndpoint(t)) return 0;
              var e = this.leftSE.point,
                i = this.rightSE.point,
                n = this.vector();
              if (e.x === i.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
              var r = (t.y - e.y) / n.y,
                o = e.x + r * n.x;
              if (t.x === o) return 0;
              var a = (t.x - e.x) / n.x,
                s = e.y + a * n.y;
              return t.y === s ? 0 : t.y < s ? -1 : 1;
            },
          },
          {
            key: "getIntersection",
            value: function (t) {
              var e = this.bbox(),
                i = t.bbox(),
                n = cv(e, i);
              if (null === n) return null;
              var r = this.leftSE.point,
                o = this.rightSE.point,
                a = t.leftSE.point,
                s = t.rightSE.point,
                l = uv(e, a) && 0 === this.comparePoint(a),
                u = uv(i, r) && 0 === t.comparePoint(r),
                c = uv(e, s) && 0 === this.comparePoint(s),
                h = uv(i, o) && 0 === t.comparePoint(o);
              if (u && l) return h && !c ? o : !h && c ? s : null;
              if (u) return c && r.x === s.x && r.y === s.y ? null : r;
              if (l) return h && o.x === a.x && o.y === a.y ? null : a;
              if (h && c) return null;
              if (h) return o;
              if (c) return s;
              var p = (function (t, e, i, n) {
                if (0 === e.x) return Mv(i, n, t.x);
                if (0 === n.x) return Mv(t, e, i.x);
                if (0 === e.y) return Sv(i, n, t.y);
                if (0 === n.y) return Sv(t, e, i.y);
                var r = yv(e, n);
                if (0 == r) return null;
                var o = {
                    x: i.x - t.x,
                    y: i.y - t.y,
                  },
                  a = yv(o, e) / r,
                  s = yv(o, n) / r;
                return {
                  x: (t.x + s * e.x + (i.x + a * n.x)) / 2,
                  y: (t.y + s * e.y + (i.y + a * n.y)) / 2,
                };
              })(r, this.vector(), a, t.vector());
              return null === p ? null : uv(n, p) ? mv.round(p.x, p.y) : null;
            },
          },
          {
            key: "split",
            value: function (e) {
              var i = [],
                n = void 0 !== e.events,
                r = new Cv(e, !0),
                o = new Cv(e, !1),
                a = this.rightSE;
              this.replaceRightSE(o), i.push(o), i.push(r);
              var s = new t(r, a, this.rings.slice(), this.windings.slice());
              return (
                Cv.comparePoints(s.leftSE.point, s.rightSE.point) > 0 &&
                  s.swapEvents(),
                Cv.comparePoints(this.leftSE.point, this.rightSE.point) > 0 &&
                  this.swapEvents(),
                n && (r.checkForConsuming(), o.checkForConsuming()),
                i
              );
            },
          },
          {
            key: "swapEvents",
            value: function () {
              var t = this.rightSE;
              (this.rightSE = this.leftSE),
                (this.leftSE = t),
                (this.leftSE.isLeft = !0),
                (this.rightSE.isLeft = !1);
              for (var e = 0, i = this.windings.length; e < i; e++)
                this.windings[e] *= -1;
            },
          },
          {
            key: "consume",
            value: function (e) {
              for (var i = this, n = e; i.consumedBy; ) i = i.consumedBy;
              for (; n.consumedBy; ) n = n.consumedBy;
              var r = t.compare(i, n);
              if (0 !== r) {
                if (r > 0) {
                  var o = i;
                  (i = n), (n = o);
                }
                if (i.prev === n) {
                  var a = i;
                  (i = n), (n = a);
                }
                for (var s = 0, l = n.rings.length; s < l; s++) {
                  var u = n.rings[s],
                    c = n.windings[s],
                    h = i.rings.indexOf(u);
                  -1 === h
                    ? (i.rings.push(u), i.windings.push(c))
                    : (i.windings[h] += c);
                }
                (n.rings = null),
                  (n.windings = null),
                  (n.consumedBy = i),
                  (n.leftSE.consumedBy = i.leftSE),
                  (n.rightSE.consumedBy = i.rightSE);
              }
            },
          },
          {
            key: "prevInResult",
            value: function () {
              return (
                void 0 !== this._prevInResult ||
                  (this.prev
                    ? this.prev.isInResult()
                      ? (this._prevInResult = this.prev)
                      : (this._prevInResult = this.prev.prevInResult())
                    : (this._prevInResult = null)),
                this._prevInResult
              );
            },
          },
          {
            key: "beforeState",
            value: function () {
              if (void 0 !== this._beforeState) return this._beforeState;
              if (this.prev) {
                var t = this.prev.consumedBy || this.prev;
                this._beforeState = t.afterState();
              } else
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: [],
                };
              return this._beforeState;
            },
          },
          {
            key: "afterState",
            value: function () {
              if (void 0 !== this._afterState) return this._afterState;
              var t = this.beforeState();
              this._afterState = {
                rings: t.rings.slice(0),
                windings: t.windings.slice(0),
                multiPolys: [],
              };
              for (
                var e = this._afterState.rings,
                  i = this._afterState.windings,
                  n = this._afterState.multiPolys,
                  r = 0,
                  o = this.rings.length;
                r < o;
                r++
              ) {
                var a = this.rings[r],
                  s = this.windings[r],
                  l = e.indexOf(a);
                -1 === l ? (e.push(a), i.push(s)) : (i[l] += s);
              }
              for (var u = [], c = [], h = 0, p = e.length; h < p; h++)
                if (0 !== i[h]) {
                  var d = e[h],
                    f = d.poly;
                  if (-1 === c.indexOf(f))
                    if (d.isExterior) u.push(f);
                    else {
                      -1 === c.indexOf(f) && c.push(f);
                      var g = u.indexOf(d.poly);
                      -1 !== g && u.splice(g, 1);
                    }
                }
              for (var m = 0, y = u.length; m < y; m++) {
                var v = u[m].multiPoly;
                -1 === n.indexOf(v) && n.push(v);
              }
              return this._afterState;
            },
          },
          {
            key: "isInResult",
            value: function () {
              if (this.consumedBy) return !1;
              if (void 0 !== this._isInResult) return this._isInResult;
              var t = this.beforeState().multiPolys,
                e = this.afterState().multiPolys;
              switch (Fv.type) {
                case "union":
                  var i = 0 === t.length,
                    n = 0 === e.length;
                  this._isInResult = i !== n;
                  break;
                case "intersection":
                  var r, o;
                  t.length < e.length
                    ? ((r = t.length), (o = e.length))
                    : ((r = e.length), (o = t.length)),
                    (this._isInResult = o === Fv.numMultiPolys && r < o);
                  break;
                case "xor":
                  var a = Math.abs(t.length - e.length);
                  this._isInResult = a % 2 == 1;
                  break;
                case "difference":
                  var s = function (t) {
                    return 1 === t.length && t[0].isSubject;
                  };
                  this._isInResult = s(t) !== s(e);
                  break;
                default:
                  throw new Error(
                    "Unrecognized operation type found ".concat(Fv.type)
                  );
              }
              return this._isInResult;
            },
          },
        ],
        [
          {
            key: "fromRing",
            value: function (e, i, n) {
              var r,
                o,
                a,
                s = Cv.comparePoints(e, i);
              if (s < 0) (r = e), (o = i), (a = 1);
              else {
                if (!(s > 0))
                  throw new Error(
                    "Tried to create degenerate segment at ["
                      .concat(e.x, ", ")
                      .concat(e.y, "]")
                  );
                (r = i), (o = e), (a = -1);
              }
              return new t(new Cv(r, !0), new Cv(o, !1), [n], [a]);
            },
          },
        ]
      ),
      t
    );
  })(),
  Ev = (function () {
    function t(e, i, n) {
      if ((av(this, t), !Array.isArray(e) || 0 === e.length))
        throw new Error(
          "Input geometry is not a valid Polygon or MultiPolygon"
        );
      if (
        ((this.poly = i),
        (this.isExterior = n),
        (this.segments = []),
        "number" != typeof e[0][0] || "number" != typeof e[0][1])
      )
        throw new Error(
          "Input geometry is not a valid Polygon or MultiPolygon"
        );
      var r = mv.round(e[0][0], e[0][1]);
      this.bbox = {
        ll: {
          x: r.x,
          y: r.y,
        },
        ur: {
          x: r.x,
          y: r.y,
        },
      };
      for (var o = r, a = 1, s = e.length; a < s; a++) {
        if ("number" != typeof e[a][0] || "number" != typeof e[a][1])
          throw new Error(
            "Input geometry is not a valid Polygon or MultiPolygon"
          );
        var l = mv.round(e[a][0], e[a][1]);
        (l.x === o.x && l.y === o.y) ||
          (this.segments.push(Av.fromRing(o, l, this)),
          l.x < this.bbox.ll.x && (this.bbox.ll.x = l.x),
          l.y < this.bbox.ll.y && (this.bbox.ll.y = l.y),
          l.x > this.bbox.ur.x && (this.bbox.ur.x = l.x),
          l.y > this.bbox.ur.y && (this.bbox.ur.y = l.y),
          (o = l));
      }
      (r.x === o.x && r.y === o.y) ||
        this.segments.push(Av.fromRing(o, r, this));
    }
    return (
      lv(t, [
        {
          key: "getSweepEvents",
          value: function () {
            for (var t = [], e = 0, i = this.segments.length; e < i; e++) {
              var n = this.segments[e];
              t.push(n.leftSE), t.push(n.rightSE);
            }
            return t;
          },
        },
      ]),
      t
    );
  })(),
  Dv = (function () {
    function t(e, i) {
      if ((av(this, t), !Array.isArray(e)))
        throw new Error(
          "Input geometry is not a valid Polygon or MultiPolygon"
        );
      (this.exteriorRing = new Ev(e[0], this, !0)),
        (this.bbox = {
          ll: {
            x: this.exteriorRing.bbox.ll.x,
            y: this.exteriorRing.bbox.ll.y,
          },
          ur: {
            x: this.exteriorRing.bbox.ur.x,
            y: this.exteriorRing.bbox.ur.y,
          },
        }),
        (this.interiorRings = []);
      for (var n = 1, r = e.length; n < r; n++) {
        var o = new Ev(e[n], this, !1);
        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
          o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
          o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
          o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
          this.interiorRings.push(o);
      }
      this.multiPoly = i;
    }
    return (
      lv(t, [
        {
          key: "getSweepEvents",
          value: function () {
            for (
              var t = this.exteriorRing.getSweepEvents(),
                e = 0,
                i = this.interiorRings.length;
              e < i;
              e++
            )
              for (
                var n = this.interiorRings[e].getSweepEvents(),
                  r = 0,
                  o = n.length;
                r < o;
                r++
              )
                t.push(n[r]);
            return t;
          },
        },
      ]),
      t
    );
  })(),
  Tv = (function () {
    function t(e, i) {
      if ((av(this, t), !Array.isArray(e)))
        throw new Error(
          "Input geometry is not a valid Polygon or MultiPolygon"
        );
      try {
        "number" == typeof e[0][0][0] && (e = [e]);
      } catch (a) {}
      (this.polys = []),
        (this.bbox = {
          ll: {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY,
          },
          ur: {
            x: Number.NEGATIVE_INFINITY,
            y: Number.NEGATIVE_INFINITY,
          },
        });
      for (var n = 0, r = e.length; n < r; n++) {
        var o = new Dv(e[n], this);
        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
          o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
          o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
          o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
          this.polys.push(o);
      }
      this.isSubject = i;
    }
    return (
      lv(t, [
        {
          key: "getSweepEvents",
          value: function () {
            for (var t = [], e = 0, i = this.polys.length; e < i; e++)
              for (
                var n = this.polys[e].getSweepEvents(), r = 0, o = n.length;
                r < o;
                r++
              )
                t.push(n[r]);
            return t;
          },
        },
      ]),
      t
    );
  })(),
  Pv = (function () {
    function t(e) {
      av(this, t), (this.events = e);
      for (var i = 0, n = e.length; i < n; i++) e[i].segment.ringOut = this;
      this.poly = null;
    }
    return (
      lv(t, null, [
        {
          key: "factory",
          value: function (e) {
            for (var i = [], n = 0, r = e.length; n < r; n++) {
              var o = e[n];
              if (o.isInResult() && !o.ringOut) {
                for (
                  var a = null,
                    s = o.leftSE,
                    l = o.rightSE,
                    u = [s],
                    c = s.point,
                    h = [];
                  (a = s), (s = l), u.push(s), s.point !== c;

                )
                  for (;;) {
                    var p = s.getAvailableLinkedEvents();
                    if (0 === p.length) {
                      var d = u[0].point,
                        f = u[u.length - 1].point;
                      throw new Error(
                        "Unable to complete output ring starting at [".concat(
                          d.x,
                          ","
                        ) +
                          " ".concat(
                            d.y,
                            "]. Last matching segment found ends at"
                          ) +
                          " [".concat(f.x, ", ").concat(f.y, "].")
                      );
                    }
                    if (1 === p.length) {
                      l = p[0].otherSE;
                      break;
                    }
                    for (var g = null, m = 0, y = h.length; m < y; m++)
                      if (h[m].point === s.point) {
                        g = m;
                        break;
                      }
                    if (null === g) {
                      h.push({
                        index: u.length,
                        point: s.point,
                      });
                      var v = s.getLeftmostComparator(a);
                      l = p.sort(v)[0].otherSE;
                      break;
                    }
                    var b = h.splice(g)[0],
                      x = u.splice(b.index);
                    x.unshift(x[0].otherSE), i.push(new t(x.reverse()));
                  }
                i.push(new t(u));
              }
            }
            return i;
          },
        },
      ]),
      lv(t, [
        {
          key: "getGeom",
          value: function () {
            for (
              var t = this.events[0].point,
                e = [t],
                i = 1,
                n = this.events.length - 1;
              i < n;
              i++
            ) {
              var r = this.events[i].point,
                o = this.events[i + 1].point;
              0 !== bv(r, t, o) && (e.push(r), (t = r));
            }
            if (1 === e.length) return null;
            var a = e[0],
              s = e[1];
            0 === bv(a, t, s) && e.shift(), e.push(e[0]);
            for (
              var l = this.isExteriorRing() ? 1 : -1,
                u = this.isExteriorRing() ? 0 : e.length - 1,
                c = this.isExteriorRing() ? e.length : -1,
                h = [],
                p = u;
              p != c;
              p += l
            )
              h.push([e[p].x, e[p].y]);
            return h;
          },
        },
        {
          key: "isExteriorRing",
          value: function () {
            if (void 0 === this._isExteriorRing) {
              var t = this.enclosingRing();
              this._isExteriorRing = !t || !t.isExteriorRing();
            }
            return this._isExteriorRing;
          },
        },
        {
          key: "enclosingRing",
          value: function () {
            return (
              void 0 === this._enclosingRing &&
                (this._enclosingRing = this._calcEnclosingRing()),
              this._enclosingRing
            );
          },
        },
        {
          key: "_calcEnclosingRing",
          value: function () {
            for (
              var t = this.events[0], e = 1, i = this.events.length;
              e < i;
              e++
            ) {
              var n = this.events[e];
              Cv.compare(t, n) > 0 && (t = n);
            }
            for (
              var r = t.segment.prevInResult(), o = r ? r.prevInResult() : null;
              ;

            ) {
              if (!r) return null;
              if (!o) return r.ringOut;
              if (o.ringOut !== r.ringOut)
                return o.ringOut.enclosingRing() !== r.ringOut
                  ? r.ringOut
                  : r.ringOut.enclosingRing();
              (r = o.prevInResult()), (o = r ? r.prevInResult() : null);
            }
          },
        },
      ]),
      t
    );
  })(),
  Lv = (function () {
    function t(e) {
      av(this, t),
        (this.exteriorRing = e),
        (e.poly = this),
        (this.interiorRings = []);
    }
    return (
      lv(t, [
        {
          key: "addInterior",
          value: function (t) {
            this.interiorRings.push(t), (t.poly = this);
          },
        },
        {
          key: "getGeom",
          value: function () {
            var t = [this.exteriorRing.getGeom()];
            if (null === t[0]) return null;
            for (var e = 0, i = this.interiorRings.length; e < i; e++) {
              var n = this.interiorRings[e].getGeom();
              null !== n && t.push(n);
            }
            return t;
          },
        },
      ]),
      t
    );
  })(),
  Iv = (function () {
    function t(e) {
      av(this, t), (this.rings = e), (this.polys = this._composePolys(e));
    }
    return (
      lv(t, [
        {
          key: "getGeom",
          value: function () {
            for (var t = [], e = 0, i = this.polys.length; e < i; e++) {
              var n = this.polys[e].getGeom();
              null !== n && t.push(n);
            }
            return t;
          },
        },
        {
          key: "_composePolys",
          value: function (t) {
            for (var e = [], i = 0, n = t.length; i < n; i++) {
              var r = t[i];
              if (!r.poly)
                if (r.isExteriorRing()) e.push(new Lv(r));
                else {
                  var o = r.enclosingRing();
                  o.poly || e.push(new Lv(o)), o.poly.addInterior(r);
                }
            }
            return e;
          },
        },
      ]),
      t
    );
  })(),
  Nv = (function () {
    function t(e) {
      var i =
        arguments.length > 1 && void 0 !== arguments[1]
          ? arguments[1]
          : Av.compare;
      av(this, t),
        (this.queue = e),
        (this.tree = new iv(i)),
        (this.segments = []);
    }
    return (
      lv(t, [
        {
          key: "process",
          value: function (t) {
            var e = t.segment,
              i = [];
            if (t.consumedBy)
              return (
                t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), i
              );
            var n = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
            if (!n)
              throw new Error(
                "Unable to find segment #".concat(e.id, " ") +
                  "["
                    .concat(e.leftSE.point.x, ", ")
                    .concat(e.leftSE.point.y, "] -> ") +
                  "["
                    .concat(e.rightSE.point.x, ", ")
                    .concat(e.rightSE.point.y, "] ") +
                  "in SweepLine tree. Please submit a bug report."
              );
            for (var r = n, o = n, a = void 0, s = void 0; void 0 === a; )
              null === (r = this.tree.prev(r))
                ? (a = null)
                : void 0 === r.key.consumedBy && (a = r.key);
            for (; void 0 === s; )
              null === (o = this.tree.next(o))
                ? (s = null)
                : void 0 === o.key.consumedBy && (s = o.key);
            if (t.isLeft) {
              var l = null;
              if (a) {
                var u = a.getIntersection(e);
                if (
                  null !== u &&
                  (e.isAnEndpoint(u) || (l = u), !a.isAnEndpoint(u))
                )
                  for (
                    var c = this._splitSafely(a, u), h = 0, p = c.length;
                    h < p;
                    h++
                  )
                    i.push(c[h]);
              }
              var d = null;
              if (s) {
                var f = s.getIntersection(e);
                if (
                  null !== f &&
                  (e.isAnEndpoint(f) || (d = f), !s.isAnEndpoint(f))
                )
                  for (
                    var g = this._splitSafely(s, f), m = 0, y = g.length;
                    m < y;
                    m++
                  )
                    i.push(g[m]);
              }
              if (null !== l || null !== d) {
                var v = null;
                if (null === l) v = d;
                else if (null === d) v = l;
                else {
                  v = Cv.comparePoints(l, d) <= 0 ? l : d;
                }
                this.queue.remove(e.rightSE), i.push(e.rightSE);
                for (var b = e.split(v), x = 0, _ = b.length; x < _; x++)
                  i.push(b[x]);
              }
              i.length > 0
                ? (this.tree.remove(e), i.push(t))
                : (this.segments.push(e), (e.prev = a));
            } else {
              if (a && s) {
                var S = a.getIntersection(s);
                if (null !== S) {
                  if (!a.isAnEndpoint(S))
                    for (
                      var M = this._splitSafely(a, S), C = 0, w = M.length;
                      C < w;
                      C++
                    )
                      i.push(M[C]);
                  if (!s.isAnEndpoint(S))
                    for (
                      var A = this._splitSafely(s, S), E = 0, D = A.length;
                      E < D;
                      E++
                    )
                      i.push(A[E]);
                }
              }
              this.tree.remove(e);
            }
            return i;
          },
        },
        {
          key: "_splitSafely",
          value: function (t, e) {
            this.tree.remove(t);
            var i = t.rightSE;
            this.queue.remove(i);
            var n = t.split(e);
            return n.push(i), void 0 === t.consumedBy && this.tree.insert(t), n;
          },
        },
      ]),
      t
    );
  })(),
  Rv =
    ("undefined" != typeof process && {}.POLYGON_CLIPPING_MAX_QUEUE_SIZE) ||
    1e6,
  Ov =
    ("undefined" != typeof process &&
      {}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) ||
    1e6,
  Fv = new ((function () {
    function t() {
      av(this, t);
    }
    return (
      lv(t, [
        {
          key: "run",
          value: function (t, e, i) {
            (Fv.type = t), mv.reset();
            for (var n = [new Tv(e, !0)], r = 0, o = i.length; r < o; r++)
              n.push(new Tv(i[r], !1));
            if (((Fv.numMultiPolys = n.length), "difference" === Fv.type))
              for (var a = n[0], s = 1; s < n.length; )
                null !== cv(n[s].bbox, a.bbox) ? s++ : n.splice(s, 1);
            if ("intersection" === Fv.type)
              for (var l = 0, u = n.length; l < u; l++)
                for (var c = n[l], h = l + 1, p = n.length; h < p; h++)
                  if (null === cv(c.bbox, n[h].bbox)) return [];
            for (var d = new iv(Cv.compare), f = 0, g = n.length; f < g; f++)
              for (
                var m = n[f].getSweepEvents(), y = 0, v = m.length;
                y < v;
                y++
              )
                if ((d.insert(m[y]), d.size > Rv))
                  throw new Error(
                    "Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report."
                  );
            for (var b = new Nv(d), x = d.size, _ = d.pop(); _; ) {
              var S = _.key;
              if (d.size === x) {
                var M = S.segment;
                throw new Error(
                  "Unable to pop() ".concat(
                    S.isLeft ? "left" : "right",
                    " SweepEvent "
                  ) +
                    "["
                      .concat(S.point.x, ", ")
                      .concat(S.point.y, "] from segment #")
                      .concat(M.id, " ") +
                    "["
                      .concat(M.leftSE.point.x, ", ")
                      .concat(M.leftSE.point.y, "] -> ") +
                    "["
                      .concat(M.rightSE.point.x, ", ")
                      .concat(M.rightSE.point.y, "] from queue. ") +
                    "Please file a bug report."
                );
              }
              if (d.size > Rv)
                throw new Error(
                  "Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report."
                );
              if (b.segments.length > Ov)
                throw new Error(
                  "Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report."
                );
              for (var C = b.process(S), w = 0, A = C.length; w < A; w++) {
                var E = C[w];
                void 0 === E.consumedBy && d.insert(E);
              }
              (x = d.size), (_ = d.pop());
            }
            mv.reset();
            var D = Pv.factory(b.segments);
            return new Iv(D).getGeom();
          },
        },
      ]),
      t
    );
  })())(),
  zv = {
    union: function (t) {
      for (
        var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1;
        n < e;
        n++
      )
        i[n - 1] = arguments[n];
      return Fv.run("union", t, i);
    },
    intersection: function (t) {
      for (
        var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1;
        n < e;
        n++
      )
        i[n - 1] = arguments[n];
      return Fv.run("intersection", t, i);
    },
    xor: function (t) {
      for (
        var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1;
        n < e;
        n++
      )
        i[n - 1] = arguments[n];
      return Fv.run("xor", t, i);
    },
    difference: function (t) {
      for (
        var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1;
        n < e;
        n++
      )
        i[n - 1] = arguments[n];
      return Fv.run("difference", t, i);
    },
  };
"fill" in Array.prototype ||
  Object.defineProperty(Array.prototype, "fill", {
    configurable: !0,
    value: function (t) {
      if (null == this) throw new TypeError(this + " is not an object");
      var e = Object(this),
        i = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
        n = (1 in arguments && parseInt(Number(arguments[1]), 10)) || 0;
      n = n < 0 ? Math.max(i + n, 0) : Math.min(n, i);
      var r =
        2 in arguments && void 0 !== arguments[2]
          ? parseInt(Number(arguments[2]), 10) || 0
          : i;
      for (r = r < 0 ? Math.max(i + arguments[2], 0) : Math.min(r, i); n < r; )
        (e[n] = t), ++n;
      return e;
    },
    writable: !0,
  }),
  (Number.isFinite =
    Number.isFinite ||
    function (t) {
      return "number" == typeof t && isFinite(t);
    }),
  (Number.isInteger =
    Number.isInteger ||
    function (t) {
      return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
    }),
  (Number.parseFloat = Number.parseFloat || parseFloat),
  (Number.isNaN =
    Number.isNaN ||
    function (t) {
      return t != t;
    }),
  (Math.trunc =
    Math.trunc ||
    function (t) {
      return t < 0 ? Math.ceil(t) : Math.floor(t);
    });
var kv = function () {};
(kv.prototype.interfaces_ = function () {
  return [];
}),
  (kv.prototype.getClass = function () {
    return kv;
  }),
  (kv.prototype.equalsWithTolerance = function (t, e, i) {
    return Math.abs(t - e) <= i;
  });
var Bv = (function (t) {
    function e(e) {
      t.call(this, e),
        (this.name = "IllegalArgumentException"),
        (this.message = e),
        (this.stack = new t().stack);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      e
    );
  })(Error),
  Gv = function () {},
  Uv = {
    MAX_VALUE: {
      configurable: !0,
    },
  };
(Gv.isNaN = function (t) {
  return Number.isNaN(t);
}),
  (Gv.doubleToLongBits = function (t) {
    return t;
  }),
  (Gv.longBitsToDouble = function (t) {
    return t;
  }),
  (Gv.isInfinite = function (t) {
    return !Number.isFinite(t);
  }),
  (Uv.MAX_VALUE.get = function () {
    return Number.MAX_VALUE;
  }),
  Object.defineProperties(Gv, Uv);
var jv = function () {},
  Hv = function () {},
  Vv = function () {};
function Wv() {}
var qv = function t() {
    if (
      ((this.x = null),
      (this.y = null),
      (this.z = null),
      0 === arguments.length)
    )
      (this.x = 0), (this.y = 0), (this.z = t.NULL_ORDINATE);
    else if (1 === arguments.length) {
      var e = arguments[0];
      (this.x = e.x), (this.y = e.y), (this.z = e.z);
    } else
      2 === arguments.length
        ? ((this.x = arguments[0]),
          (this.y = arguments[1]),
          (this.z = t.NULL_ORDINATE))
        : 3 === arguments.length &&
          ((this.x = arguments[0]),
          (this.y = arguments[1]),
          (this.z = arguments[2]));
  },
  Yv = {
    DimensionalComparator: {
      configurable: !0,
    },
    serialVersionUID: {
      configurable: !0,
    },
    NULL_ORDINATE: {
      configurable: !0,
    },
    X: {
      configurable: !0,
    },
    Y: {
      configurable: !0,
    },
    Z: {
      configurable: !0,
    },
  };
(qv.prototype.setOrdinate = function (t, e) {
  switch (t) {
    case qv.X:
      this.x = e;
      break;
    case qv.Y:
      this.y = e;
      break;
    case qv.Z:
      this.z = e;
      break;
    default:
      throw new Bv("Invalid ordinate index: " + t);
  }
}),
  (qv.prototype.equals2D = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.x === t.x && this.y === t.y;
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      return (
        !!kv.equalsWithTolerance(this.x, e.x, i) &&
        !!kv.equalsWithTolerance(this.y, e.y, i)
      );
    }
  }),
  (qv.prototype.getOrdinate = function (t) {
    switch (t) {
      case qv.X:
        return this.x;
      case qv.Y:
        return this.y;
      case qv.Z:
        return this.z;
    }
    throw new Bv("Invalid ordinate index: " + t);
  }),
  (qv.prototype.equals3D = function (t) {
    return (
      this.x === t.x &&
      this.y === t.y &&
      (this.z === t.z || Gv.isNaN(this.z)) &&
      Gv.isNaN(t.z)
    );
  }),
  (qv.prototype.equals = function (t) {
    return t instanceof qv && this.equals2D(t);
  }),
  (qv.prototype.equalInZ = function (t, e) {
    return kv.equalsWithTolerance(this.z, t.z, e);
  }),
  (qv.prototype.compareTo = function (t) {
    var e = t;
    return this.x < e.x
      ? -1
      : this.x > e.x
      ? 1
      : this.y < e.y
      ? -1
      : this.y > e.y
      ? 1
      : 0;
  }),
  (qv.prototype.clone = function () {}),
  (qv.prototype.copy = function () {
    return new qv(this);
  }),
  (qv.prototype.toString = function () {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")";
  }),
  (qv.prototype.distance3D = function (t) {
    var e = this.x - t.x,
      i = this.y - t.y,
      n = this.z - t.z;
    return Math.sqrt(e * e + i * i + n * n);
  }),
  (qv.prototype.distance = function (t) {
    var e = this.x - t.x,
      i = this.y - t.y;
    return Math.sqrt(e * e + i * i);
  }),
  (qv.prototype.hashCode = function () {
    var t = 17;
    return (t = 37 * (t = 37 * t + qv.hashCode(this.x)) + qv.hashCode(this.y));
  }),
  (qv.prototype.setCoordinate = function (t) {
    (this.x = t.x), (this.y = t.y), (this.z = t.z);
  }),
  (qv.prototype.interfaces_ = function () {
    return [jv, Hv, Wv];
  }),
  (qv.prototype.getClass = function () {
    return qv;
  }),
  (qv.hashCode = function () {
    if (1 === arguments.length) {
      Gv.doubleToLongBits(arguments[0]);
      return Math.trunc(0);
    }
  }),
  (Yv.DimensionalComparator.get = function () {
    return Xv;
  }),
  (Yv.serialVersionUID.get = function () {
    return 0x5cbf2c235c7e5800;
  }),
  (Yv.NULL_ORDINATE.get = function () {
    return Gv.NaN;
  }),
  (Yv.X.get = function () {
    return 0;
  }),
  (Yv.Y.get = function () {
    return 1;
  }),
  (Yv.Z.get = function () {
    return 2;
  }),
  Object.defineProperties(qv, Yv);
var Xv = function (t) {
  if (((this._dimensionsToTest = 2), 0 === arguments.length));
  else if (1 === arguments.length) {
    var e = arguments[0];
    if (2 !== e && 3 !== e)
      throw new Bv("only 2 or 3 dimensions may be specified");
    this._dimensionsToTest = e;
  }
};
(Xv.prototype.compare = function (t, e) {
  var i = t,
    n = e,
    r = Xv.compare(i.x, n.x);
  if (0 !== r) return r;
  var o = Xv.compare(i.y, n.y);
  return 0 !== o ? o : this._dimensionsToTest <= 2 ? 0 : Xv.compare(i.z, n.z);
}),
  (Xv.prototype.interfaces_ = function () {
    return [Vv];
  }),
  (Xv.prototype.getClass = function () {
    return Xv;
  }),
  (Xv.compare = function (t, e) {
    return t < e
      ? -1
      : t > e
      ? 1
      : Gv.isNaN(t)
      ? Gv.isNaN(e)
        ? 0
        : -1
      : Gv.isNaN(e)
      ? 1
      : 0;
  });
var Qv = function () {};
(Qv.prototype.create = function () {}),
  (Qv.prototype.interfaces_ = function () {
    return [];
  }),
  (Qv.prototype.getClass = function () {
    return Qv;
  });
var Zv = function () {},
  Jv = {
    INTERIOR: {
      configurable: !0,
    },
    BOUNDARY: {
      configurable: !0,
    },
    EXTERIOR: {
      configurable: !0,
    },
    NONE: {
      configurable: !0,
    },
  };
(Zv.prototype.interfaces_ = function () {
  return [];
}),
  (Zv.prototype.getClass = function () {
    return Zv;
  }),
  (Zv.toLocationSymbol = function (t) {
    switch (t) {
      case Zv.EXTERIOR:
        return "e";
      case Zv.BOUNDARY:
        return "b";
      case Zv.INTERIOR:
        return "i";
      case Zv.NONE:
        return "-";
    }
    throw new Bv("Unknown location value: " + t);
  }),
  (Jv.INTERIOR.get = function () {
    return 0;
  }),
  (Jv.BOUNDARY.get = function () {
    return 1;
  }),
  (Jv.EXTERIOR.get = function () {
    return 2;
  }),
  (Jv.NONE.get = function () {
    return -1;
  }),
  Object.defineProperties(Zv, Jv);
var Kv = function (t, e) {
    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;
  },
  $v = function () {},
  tb = {
    LOG_10: {
      configurable: !0,
    },
  };
($v.prototype.interfaces_ = function () {
  return [];
}),
  ($v.prototype.getClass = function () {
    return $v;
  }),
  ($v.log10 = function (t) {
    var e = Math.log(t);
    return Gv.isInfinite(e) || Gv.isNaN(e) ? e : e / $v.LOG_10;
  }),
  ($v.min = function (t, e, i, n) {
    var r = t;
    return e < r && (r = e), i < r && (r = i), n < r && (r = n), r;
  }),
  ($v.clamp = function () {
    if (
      "number" == typeof arguments[2] &&
      "number" == typeof arguments[0] &&
      "number" == typeof arguments[1]
    ) {
      var t = arguments[0],
        e = arguments[1],
        i = arguments[2];
      return t < e ? e : t > i ? i : t;
    }
    if (
      Number.isInteger(arguments[2]) &&
      Number.isInteger(arguments[0]) &&
      Number.isInteger(arguments[1])
    ) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2];
      return n < r ? r : n > o ? o : n;
    }
  }),
  ($v.wrap = function (t, e) {
    return t < 0 ? e - (-t % e) : t % e;
  }),
  ($v.max = function () {
    if (3 === arguments.length) {
      var t = arguments[1],
        e = arguments[2],
        i = arguments[0];
      return t > i && (i = t), e > i && (i = e), i;
    }
    if (4 === arguments.length) {
      var n = arguments[1],
        r = arguments[2],
        o = arguments[3],
        a = arguments[0];
      return n > a && (a = n), r > a && (a = r), o > a && (a = o), a;
    }
  }),
  ($v.average = function (t, e) {
    return (t + e) / 2;
  }),
  (tb.LOG_10.get = function () {
    return Math.log(10);
  }),
  Object.defineProperties($v, tb);
var eb = function (t) {
  this.str = t;
};
(eb.prototype.append = function (t) {
  this.str += t;
}),
  (eb.prototype.setCharAt = function (t, e) {
    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
  }),
  (eb.prototype.toString = function (t) {
    return this.str;
  });
var ib = function (t) {
  this.value = t;
};
(ib.prototype.intValue = function () {
  return this.value;
}),
  (ib.prototype.compareTo = function (t) {
    return this.value < t ? -1 : this.value > t ? 1 : 0;
  }),
  (ib.isNaN = function (t) {
    return Number.isNaN(t);
  });
var nb = function () {};
(nb.isWhitespace = function (t) {
  return (t <= 32 && t >= 0) || 127 === t;
}),
  (nb.toUpperCase = function (t) {
    return t.toUpperCase();
  });
var rb = function t() {
    if (((this._hi = 0), (this._lo = 0), 0 === arguments.length)) this.init(0);
    else if (1 === arguments.length) {
      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        this.init(e);
      } else if (arguments[0] instanceof t) {
        var i = arguments[0];
        this.init(i);
      } else if ("string" == typeof arguments[0]) {
        t.call(this, t.parse(arguments[0]));
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
        r = arguments[1];
      this.init(n, r);
    }
  },
  ob = {
    PI: {
      configurable: !0,
    },
    TWO_PI: {
      configurable: !0,
    },
    PI_2: {
      configurable: !0,
    },
    E: {
      configurable: !0,
    },
    NaN: {
      configurable: !0,
    },
    EPS: {
      configurable: !0,
    },
    SPLIT: {
      configurable: !0,
    },
    MAX_PRINT_DIGITS: {
      configurable: !0,
    },
    TEN: {
      configurable: !0,
    },
    ONE: {
      configurable: !0,
    },
    SCI_NOT_EXPONENT_CHAR: {
      configurable: !0,
    },
    SCI_NOT_ZERO: {
      configurable: !0,
    },
  };
(rb.prototype.le = function (t) {
  return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo;
}),
  (rb.prototype.extractSignificantDigits = function (t, e) {
    var i = this.abs(),
      n = rb.magnitude(i._hi),
      r = rb.TEN.pow(n);
    (i = i.divide(r)).gt(rb.TEN)
      ? ((i = i.divide(rb.TEN)), (n += 1))
      : i.lt(rb.ONE) && ((i = i.multiply(rb.TEN)), (n -= 1));
    for (
      var o = n + 1, a = new eb(), s = rb.MAX_PRINT_DIGITS - 1, l = 0;
      l <= s;
      l++
    ) {
      t && l === o && a.append(".");
      var u = Math.trunc(i._hi);
      if (u < 0) break;
      var c = !1,
        h = 0;
      u > 9 ? ((c = !0), (h = "9")) : (h = "0" + u),
        a.append(h),
        (i = i.subtract(rb.valueOf(u)).multiply(rb.TEN)),
        c && i.selfAdd(rb.TEN);
      var p = !0,
        d = rb.magnitude(i._hi);
      if ((d < 0 && Math.abs(d) >= s - l && (p = !1), !p)) break;
    }
    return (e[0] = n), a.toString();
  }),
  (rb.prototype.sqr = function () {
    return this.multiply(this);
  }),
  (rb.prototype.doubleValue = function () {
    return this._hi + this._lo;
  }),
  (rb.prototype.subtract = function () {
    if (arguments[0] instanceof rb) {
      var t = arguments[0];
      return this.add(t.negate());
    }
    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.add(-e);
    }
  }),
  (rb.prototype.equals = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this._hi === t._hi && this._lo === t._lo;
    }
  }),
  (rb.prototype.isZero = function () {
    return 0 === this._hi && 0 === this._lo;
  }),
  (rb.prototype.selfSubtract = function () {
    if (arguments[0] instanceof rb) {
      var t = arguments[0];
      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);
    }
    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.isNaN() ? this : this.selfAdd(-e, 0);
    }
  }),
  (rb.prototype.getSpecialNumberString = function () {
    return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
  }),
  (rb.prototype.min = function (t) {
    return this.le(t) ? this : t;
  }),
  (rb.prototype.selfDivide = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof rb) {
        var t = arguments[0];
        return this.selfDivide(t._hi, t._lo);
      }
      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        return this.selfDivide(e, 0);
      }
    } else if (2 === arguments.length) {
      var i,
        n,
        r,
        o,
        a = arguments[0],
        s = arguments[1],
        l = null,
        u = null,
        c = null,
        h = null;
      return (
        (r = this._hi / a),
        (h =
          (l = (c = rb.SPLIT * r) - (l = c - r)) *
            (u = (h = rb.SPLIT * a) - (u = h - a)) -
          (o = r * a) +
          l * (n = a - u) +
          (i = r - l) * u +
          i * n),
        (h = r + (c = (this._hi - o - h + this._lo - r * s) / a)),
        (this._hi = h),
        (this._lo = r - h + c),
        this
      );
    }
  }),
  (rb.prototype.dump = function () {
    return "DD<" + this._hi + ", " + this._lo + ">";
  }),
  (rb.prototype.divide = function () {
    if (arguments[0] instanceof rb) {
      var t,
        e,
        i,
        n,
        r = arguments[0],
        o = null,
        a = null,
        s = null,
        l = null;
      return (
        (t = (i = this._hi / r._hi) - (o = (s = rb.SPLIT * i) - (o = s - i))),
        (l =
          o * (a = (l = rb.SPLIT * r._hi) - (a = l - r._hi)) -
          (n = i * r._hi) +
          o * (e = r._hi - a) +
          t * a +
          t * e),
        (s = (this._hi - n - l + this._lo - i * r._lo) / r._hi),
        new rb((l = i + s), i - l + s)
      );
    }
    if ("number" == typeof arguments[0]) {
      var u = arguments[0];
      return Gv.isNaN(u) ? rb.createNaN() : rb.copy(this).selfDivide(u, 0);
    }
  }),
  (rb.prototype.ge = function (t) {
    return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo;
  }),
  (rb.prototype.pow = function (t) {
    if (0 === t) return rb.valueOf(1);
    var e = new rb(this),
      i = rb.valueOf(1),
      n = Math.abs(t);
    if (n > 1)
      for (; n > 0; )
        n % 2 == 1 && i.selfMultiply(e), (n /= 2) > 0 && (e = e.sqr());
    else i = e;
    return t < 0 ? i.reciprocal() : i;
  }),
  (rb.prototype.ceil = function () {
    if (this.isNaN()) return rb.NaN;
    var t = Math.ceil(this._hi),
      e = 0;
    return t === this._hi && (e = Math.ceil(this._lo)), new rb(t, e);
  }),
  (rb.prototype.compareTo = function (t) {
    var e = t;
    return this._hi < e._hi
      ? -1
      : this._hi > e._hi
      ? 1
      : this._lo < e._lo
      ? -1
      : this._lo > e._lo
      ? 1
      : 0;
  }),
  (rb.prototype.rint = function () {
    return this.isNaN() ? this : this.add(0.5).floor();
  }),
  (rb.prototype.setValue = function () {
    if (arguments[0] instanceof rb) {
      var t = arguments[0];
      return this.init(t), this;
    }
    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return this.init(e), this;
    }
  }),
  (rb.prototype.max = function (t) {
    return this.ge(t) ? this : t;
  }),
  (rb.prototype.sqrt = function () {
    if (this.isZero()) return rb.valueOf(0);
    if (this.isNegative()) return rb.NaN;
    var t = 1 / Math.sqrt(this._hi),
      e = this._hi * t,
      i = rb.valueOf(e),
      n = this.subtract(i.sqr())._hi * (0.5 * t);
    return i.add(n);
  }),
  (rb.prototype.selfAdd = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof rb) {
        var t = arguments[0];
        return this.selfAdd(t._hi, t._lo);
      }
      if ("number" == typeof arguments[0]) {
        var e,
          i,
          n,
          r,
          o,
          a = arguments[0],
          s = null;
        return (
          (s = (n = this._hi + a) - (r = n - this._hi)),
          (i =
            (o = (s = a - r + (this._hi - s)) + this._lo) + (n - (e = n + o))),
          (this._hi = e + i),
          (this._lo = i + (e - this._hi)),
          this
        );
      }
    } else if (2 === arguments.length) {
      var l,
        u,
        c,
        h,
        p = arguments[0],
        d = arguments[1],
        f = null,
        g = null,
        m = null;
      (c = this._hi + p),
        (u = this._lo + d),
        (g = c - (m = c - this._hi)),
        (f = u - (h = u - this._lo));
      var y =
          (l = c + (m = (g = p - m + (this._hi - g)) + u)) +
          (m = (f = d - h + (this._lo - f)) + (m + (c - l))),
        v = m + (l - y);
      return (this._hi = y), (this._lo = v), this;
    }
  }),
  (rb.prototype.selfMultiply = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof rb) {
        var t = arguments[0];
        return this.selfMultiply(t._hi, t._lo);
      }
      if ("number" == typeof arguments[0]) {
        var e = arguments[0];
        return this.selfMultiply(e, 0);
      }
    } else if (2 === arguments.length) {
      var i,
        n,
        r = arguments[0],
        o = arguments[1],
        a = null,
        s = null,
        l = null,
        u = null;
      (a = (l = rb.SPLIT * this._hi) - this._hi),
        (u = rb.SPLIT * r),
        (a = l - a),
        (i = this._hi - a),
        (s = u - r);
      var c =
          (l = this._hi * r) +
          (u =
            a * (s = u - s) -
            l +
            a * (n = r - s) +
            i * s +
            i * n +
            (this._hi * o + this._lo * r)),
        h = u + (a = l - c);
      return (this._hi = c), (this._lo = h), this;
    }
  }),
  (rb.prototype.selfSqr = function () {
    return this.selfMultiply(this);
  }),
  (rb.prototype.floor = function () {
    if (this.isNaN()) return rb.NaN;
    var t = Math.floor(this._hi),
      e = 0;
    return t === this._hi && (e = Math.floor(this._lo)), new rb(t, e);
  }),
  (rb.prototype.negate = function () {
    return this.isNaN() ? this : new rb(-this._hi, -this._lo);
  }),
  (rb.prototype.clone = function () {}),
  (rb.prototype.multiply = function () {
    if (arguments[0] instanceof rb) {
      var t = arguments[0];
      return t.isNaN() ? rb.createNaN() : rb.copy(this).selfMultiply(t);
    }
    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return Gv.isNaN(e) ? rb.createNaN() : rb.copy(this).selfMultiply(e, 0);
    }
  }),
  (rb.prototype.isNaN = function () {
    return Gv.isNaN(this._hi);
  }),
  (rb.prototype.intValue = function () {
    return Math.trunc(this._hi);
  }),
  (rb.prototype.toString = function () {
    var t = rb.magnitude(this._hi);
    return t >= -3 && t <= 20
      ? this.toStandardNotation()
      : this.toSciNotation();
  }),
  (rb.prototype.toStandardNotation = function () {
    var t = this.getSpecialNumberString();
    if (null !== t) return t;
    var e = new Array(1).fill(null),
      i = this.extractSignificantDigits(!0, e),
      n = e[0] + 1,
      r = i;
    if ("." === i.charAt(0)) r = "0" + i;
    else if (n < 0) r = "0." + rb.stringOfChar("0", -n) + i;
    else if (-1 === i.indexOf(".")) {
      var o = n - i.length;
      r = i + rb.stringOfChar("0", o) + ".0";
    }
    return this.isNegative() ? "-" + r : r;
  }),
  (rb.prototype.reciprocal = function () {
    var t,
      e,
      i,
      n,
      r = null,
      o = null,
      a = null,
      s = null;
    (t = (i = 1 / this._hi) - (r = (a = rb.SPLIT * i) - (r = a - i))),
      (o = (s = rb.SPLIT * this._hi) - this._hi);
    var l =
      i +
      (a =
        (1 -
          (n = i * this._hi) -
          (s = r * (o = s - o) - n + r * (e = this._hi - o) + t * o + t * e) -
          i * this._lo) /
        this._hi);
    return new rb(l, i - l + a);
  }),
  (rb.prototype.toSciNotation = function () {
    if (this.isZero()) return rb.SCI_NOT_ZERO;
    var t = this.getSpecialNumberString();
    if (null !== t) return t;
    var e = new Array(1).fill(null),
      i = this.extractSignificantDigits(!1, e),
      n = rb.SCI_NOT_EXPONENT_CHAR + e[0];
    if ("0" === i.charAt(0)) throw new Error("Found leading zero: " + i);
    var r = "";
    i.length > 1 && (r = i.substring(1));
    var o = i.charAt(0) + "." + r;
    return this.isNegative() ? "-" + o + n : o + n;
  }),
  (rb.prototype.abs = function () {
    return this.isNaN()
      ? rb.NaN
      : this.isNegative()
      ? this.negate()
      : new rb(this);
  }),
  (rb.prototype.isPositive = function () {
    return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
  }),
  (rb.prototype.lt = function (t) {
    return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo;
  }),
  (rb.prototype.add = function () {
    if (arguments[0] instanceof rb) {
      var t = arguments[0];
      return rb.copy(this).selfAdd(t);
    }
    if ("number" == typeof arguments[0]) {
      var e = arguments[0];
      return rb.copy(this).selfAdd(e);
    }
  }),
  (rb.prototype.init = function () {
    if (1 === arguments.length) {
      if ("number" == typeof arguments[0]) {
        var t = arguments[0];
        (this._hi = t), (this._lo = 0);
      } else if (arguments[0] instanceof rb) {
        var e = arguments[0];
        (this._hi = e._hi), (this._lo = e._lo);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      (this._hi = i), (this._lo = n);
    }
  }),
  (rb.prototype.gt = function (t) {
    return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo;
  }),
  (rb.prototype.isNegative = function () {
    return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
  }),
  (rb.prototype.trunc = function () {
    return this.isNaN()
      ? rb.NaN
      : this.isPositive()
      ? this.floor()
      : this.ceil();
  }),
  (rb.prototype.signum = function () {
    return this._hi > 0
      ? 1
      : this._hi < 0
      ? -1
      : this._lo > 0
      ? 1
      : this._lo < 0
      ? -1
      : 0;
  }),
  (rb.prototype.interfaces_ = function () {
    return [Wv, jv, Hv];
  }),
  (rb.prototype.getClass = function () {
    return rb;
  }),
  (rb.sqr = function (t) {
    return rb.valueOf(t).selfMultiply(t);
  }),
  (rb.valueOf = function () {
    return "string" == typeof arguments[0]
      ? rb.parse(arguments[0])
      : "number" == typeof arguments[0]
      ? new rb(arguments[0])
      : void 0;
  }),
  (rb.sqrt = function (t) {
    return rb.valueOf(t).sqrt();
  }),
  (rb.parse = function (t) {
    for (var e = 0, i = t.length; nb.isWhitespace(t.charAt(e)); ) e++;
    var n = !1;
    if (e < i) {
      var r = t.charAt(e);
      ("-" !== r && "+" !== r) || (e++, "-" === r && (n = !0));
    }
    for (var o = new rb(), a = 0, s = 0, l = 0; !(e >= i); ) {
      var u = t.charAt(e);
      if ((e++, nb.isDigit(u))) {
        var c = u - "0";
        o.selfMultiply(rb.TEN), o.selfAdd(c), a++;
      } else {
        if ("." !== u) {
          if ("e" === u || "E" === u) {
            var h = t.substring(e);
            try {
              l = ib.parseInt(h);
            } catch (m) {
              throw m instanceof Error
                ? new Error("Invalid exponent " + h + " in string " + t)
                : m;
            }
            break;
          }
          throw new Error(
            "Unexpected character '" +
              u +
              "' at position " +
              e +
              " in string " +
              t
          );
        }
        s = a;
      }
    }
    var p = o,
      d = a - s - l;
    if (0 === d) p = o;
    else if (d > 0) {
      var f = rb.TEN.pow(d);
      p = o.divide(f);
    } else if (d < 0) {
      var g = rb.TEN.pow(-d);
      p = o.multiply(g);
    }
    return n ? p.negate() : p;
  }),
  (rb.createNaN = function () {
    return new rb(Gv.NaN, Gv.NaN);
  }),
  (rb.copy = function (t) {
    return new rb(t);
  }),
  (rb.magnitude = function (t) {
    var e = Math.abs(t),
      i = Math.log(e) / Math.log(10),
      n = Math.trunc(Math.floor(i));
    return 10 * Math.pow(10, n) <= e && (n += 1), n;
  }),
  (rb.stringOfChar = function (t, e) {
    for (var i = new eb(), n = 0; n < e; n++) i.append(t);
    return i.toString();
  }),
  (ob.PI.get = function () {
    return new rb(3.141592653589793, 12246467991473532e-32);
  }),
  (ob.TWO_PI.get = function () {
    return new rb(6.283185307179586, 24492935982947064e-32);
  }),
  (ob.PI_2.get = function () {
    return new rb(1.5707963267948966, 6123233995736766e-32);
  }),
  (ob.E.get = function () {
    return new rb(2.718281828459045, 14456468917292502e-32);
  }),
  (ob.NaN.get = function () {
    return new rb(Gv.NaN, Gv.NaN);
  }),
  (ob.EPS.get = function () {
    return 123259516440783e-46;
  }),
  (ob.SPLIT.get = function () {
    return 134217729;
  }),
  (ob.MAX_PRINT_DIGITS.get = function () {
    return 32;
  }),
  (ob.TEN.get = function () {
    return rb.valueOf(10);
  }),
  (ob.ONE.get = function () {
    return rb.valueOf(1);
  }),
  (ob.SCI_NOT_EXPONENT_CHAR.get = function () {
    return "E";
  }),
  (ob.SCI_NOT_ZERO.get = function () {
    return "0.0E0";
  }),
  Object.defineProperties(rb, ob);
var ab = function () {},
  sb = {
    DP_SAFE_EPSILON: {
      configurable: !0,
    },
  };
(ab.prototype.interfaces_ = function () {
  return [];
}),
  (ab.prototype.getClass = function () {
    return ab;
  }),
  (ab.orientationIndex = function (t, e, i) {
    var n = ab.orientationIndexFilter(t, e, i);
    if (n <= 1) return n;
    var r = rb.valueOf(e.x).selfAdd(-t.x),
      o = rb.valueOf(e.y).selfAdd(-t.y),
      a = rb.valueOf(i.x).selfAdd(-e.x),
      s = rb.valueOf(i.y).selfAdd(-e.y);
    return r.selfMultiply(s).selfSubtract(o.selfMultiply(a)).signum();
  }),
  (ab.signOfDet2x2 = function (t, e, i, n) {
    return t.multiply(n).selfSubtract(e.multiply(i)).signum();
  }),
  (ab.intersection = function (t, e, i, n) {
    var r = rb
        .valueOf(n.y)
        .selfSubtract(i.y)
        .selfMultiply(rb.valueOf(e.x).selfSubtract(t.x)),
      o = rb
        .valueOf(n.x)
        .selfSubtract(i.x)
        .selfMultiply(rb.valueOf(e.y).selfSubtract(t.y)),
      a = r.subtract(o),
      s = rb
        .valueOf(n.x)
        .selfSubtract(i.x)
        .selfMultiply(rb.valueOf(t.y).selfSubtract(i.y)),
      l = rb
        .valueOf(n.y)
        .selfSubtract(i.y)
        .selfMultiply(rb.valueOf(t.x).selfSubtract(i.x)),
      u = s.subtract(l).selfDivide(a).doubleValue(),
      c = rb
        .valueOf(t.x)
        .selfAdd(rb.valueOf(e.x).selfSubtract(t.x).selfMultiply(u))
        .doubleValue(),
      h = rb
        .valueOf(e.x)
        .selfSubtract(t.x)
        .selfMultiply(rb.valueOf(t.y).selfSubtract(i.y)),
      p = rb
        .valueOf(e.y)
        .selfSubtract(t.y)
        .selfMultiply(rb.valueOf(t.x).selfSubtract(i.x)),
      d = h.subtract(p).selfDivide(a).doubleValue(),
      f = rb
        .valueOf(i.y)
        .selfAdd(rb.valueOf(n.y).selfSubtract(i.y).selfMultiply(d))
        .doubleValue();
    return new qv(c, f);
  }),
  (ab.orientationIndexFilter = function (t, e, i) {
    var n = null,
      r = (t.x - i.x) * (e.y - i.y),
      o = (t.y - i.y) * (e.x - i.x),
      a = r - o;
    if (r > 0) {
      if (o <= 0) return ab.signum(a);
      n = r + o;
    } else {
      if (!(r < 0)) return ab.signum(a);
      if (o >= 0) return ab.signum(a);
      n = -r - o;
    }
    var s = ab.DP_SAFE_EPSILON * n;
    return a >= s || -a >= s ? ab.signum(a) : 2;
  }),
  (ab.signum = function (t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }),
  (sb.DP_SAFE_EPSILON.get = function () {
    return 1e-15;
  }),
  Object.defineProperties(ab, sb);
var lb = function () {},
  ub = {
    X: {
      configurable: !0,
    },
    Y: {
      configurable: !0,
    },
    Z: {
      configurable: !0,
    },
    M: {
      configurable: !0,
    },
  };
(ub.X.get = function () {
  return 0;
}),
  (ub.Y.get = function () {
    return 1;
  }),
  (ub.Z.get = function () {
    return 2;
  }),
  (ub.M.get = function () {
    return 3;
  }),
  (lb.prototype.setOrdinate = function (t, e, i) {}),
  (lb.prototype.size = function () {}),
  (lb.prototype.getOrdinate = function (t, e) {}),
  (lb.prototype.getCoordinate = function () {}),
  (lb.prototype.getCoordinateCopy = function (t) {}),
  (lb.prototype.getDimension = function () {}),
  (lb.prototype.getX = function (t) {}),
  (lb.prototype.clone = function () {}),
  (lb.prototype.expandEnvelope = function (t) {}),
  (lb.prototype.copy = function () {}),
  (lb.prototype.getY = function (t) {}),
  (lb.prototype.toCoordinateArray = function () {}),
  (lb.prototype.interfaces_ = function () {
    return [Hv];
  }),
  (lb.prototype.getClass = function () {
    return lb;
  }),
  Object.defineProperties(lb, ub);
var cb = function () {},
  hb = (function (t) {
    function e() {
      t.call(
        this,
        "Projective point not representable on the Cartesian plane."
      );
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(cb),
  pb = function () {};
(pb.arraycopy = function (t, e, i, n, r) {
  for (var o = 0, a = e; a < e + r; a++) (i[n + o] = t[a]), o++;
}),
  (pb.getProperty = function (t) {
    return {
      "line.separator": "\n",
    }[t];
  });
var db = function t() {
  if (
    ((this.x = null), (this.y = null), (this.w = null), 0 === arguments.length)
  )
    (this.x = 0), (this.y = 0), (this.w = 1);
  else if (1 === arguments.length) {
    var e = arguments[0];
    (this.x = e.x), (this.y = e.y), (this.w = 1);
  } else if (2 === arguments.length) {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var i = arguments[0],
        n = arguments[1];
      (this.x = i), (this.y = n), (this.w = 1);
    } else if (arguments[0] instanceof t && arguments[1] instanceof t) {
      var r = arguments[0],
        o = arguments[1];
      (this.x = r.y * o.w - o.y * r.w),
        (this.y = o.x * r.w - r.x * o.w),
        (this.w = r.x * o.y - o.x * r.y);
    } else if (arguments[0] instanceof qv && arguments[1] instanceof qv) {
      var a = arguments[0],
        s = arguments[1];
      (this.x = a.y - s.y),
        (this.y = s.x - a.x),
        (this.w = a.x * s.y - s.x * a.y);
    }
  } else if (3 === arguments.length) {
    var l = arguments[0],
      u = arguments[1],
      c = arguments[2];
    (this.x = l), (this.y = u), (this.w = c);
  } else if (4 === arguments.length) {
    var h = arguments[0],
      p = arguments[1],
      d = arguments[2],
      f = arguments[3],
      g = h.y - p.y,
      m = p.x - h.x,
      y = h.x * p.y - p.x * h.y,
      v = d.y - f.y,
      b = f.x - d.x,
      x = d.x * f.y - f.x * d.y;
    (this.x = m * x - b * y),
      (this.y = v * y - g * x),
      (this.w = g * b - v * m);
  }
};
(db.prototype.getY = function () {
  var t = this.y / this.w;
  if (Gv.isNaN(t) || Gv.isInfinite(t)) throw new hb();
  return t;
}),
  (db.prototype.getX = function () {
    var t = this.x / this.w;
    if (Gv.isNaN(t) || Gv.isInfinite(t)) throw new hb();
    return t;
  }),
  (db.prototype.getCoordinate = function () {
    var t = new qv();
    return (t.x = this.getX()), (t.y = this.getY()), t;
  }),
  (db.prototype.interfaces_ = function () {
    return [];
  }),
  (db.prototype.getClass = function () {
    return db;
  }),
  (db.intersection = function (t, e, i, n) {
    var r = t.y - e.y,
      o = e.x - t.x,
      a = t.x * e.y - e.x * t.y,
      s = i.y - n.y,
      l = n.x - i.x,
      u = i.x * n.y - n.x * i.y,
      c = r * l - s * o,
      h = (o * u - l * a) / c,
      p = (s * a - r * u) / c;
    if (Gv.isNaN(h) || Gv.isInfinite(h) || Gv.isNaN(p) || Gv.isInfinite(p))
      throw new hb();
    return new qv(h, p);
  });
var fb = function t() {
    if (
      ((this._minx = null),
      (this._maxx = null),
      (this._miny = null),
      (this._maxy = null),
      0 === arguments.length)
    )
      this.init();
    else if (1 === arguments.length) {
      if (arguments[0] instanceof qv) {
        var e = arguments[0];
        this.init(e.x, e.x, e.y, e.y);
      } else if (arguments[0] instanceof t) {
        var i = arguments[0];
        this.init(i);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
        r = arguments[1];
      this.init(n.x, r.x, n.y, r.y);
    } else if (4 === arguments.length) {
      var o = arguments[0],
        a = arguments[1],
        s = arguments[2],
        l = arguments[3];
      this.init(o, a, s, l);
    }
  },
  gb = {
    serialVersionUID: {
      configurable: !0,
    },
  };
(fb.prototype.getArea = function () {
  return this.getWidth() * this.getHeight();
}),
  (fb.prototype.equals = function (t) {
    if (!(t instanceof fb)) return !1;
    var e = t;
    return this.isNull()
      ? e.isNull()
      : this._maxx === e.getMaxX() &&
          this._maxy === e.getMaxY() &&
          this._minx === e.getMinX() &&
          this._miny === e.getMinY();
  }),
  (fb.prototype.intersection = function (t) {
    if (this.isNull() || t.isNull() || !this.intersects(t)) return new fb();
    var e = this._minx > t._minx ? this._minx : t._minx,
      i = this._miny > t._miny ? this._miny : t._miny,
      n = this._maxx < t._maxx ? this._maxx : t._maxx,
      r = this._maxy < t._maxy ? this._maxy : t._maxy;
    return new fb(e, n, i, r);
  }),
  (fb.prototype.isNull = function () {
    return this._maxx < this._minx;
  }),
  (fb.prototype.getMaxX = function () {
    return this._maxx;
  }),
  (fb.prototype.covers = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof qv) {
        var t = arguments[0];
        return this.covers(t.x, t.y);
      }
      if (arguments[0] instanceof fb) {
        var e = arguments[0];
        return (
          !this.isNull() &&
          !e.isNull() &&
          e.getMinX() >= this._minx &&
          e.getMaxX() <= this._maxx &&
          e.getMinY() >= this._miny &&
          e.getMaxY() <= this._maxy
        );
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      return (
        !this.isNull() &&
        i >= this._minx &&
        i <= this._maxx &&
        n >= this._miny &&
        n <= this._maxy
      );
    }
  }),
  (fb.prototype.intersects = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof fb) {
        var t = arguments[0];
        return (
          !this.isNull() &&
          !t.isNull() &&
          !(
            t._minx > this._maxx ||
            t._maxx < this._minx ||
            t._miny > this._maxy ||
            t._maxy < this._miny
          )
        );
      }
      if (arguments[0] instanceof qv) {
        var e = arguments[0];
        return this.intersects(e.x, e.y);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      return (
        !this.isNull() &&
        !(i > this._maxx || i < this._minx || n > this._maxy || n < this._miny)
      );
    }
  }),
  (fb.prototype.getMinY = function () {
    return this._miny;
  }),
  (fb.prototype.getMinX = function () {
    return this._minx;
  }),
  (fb.prototype.expandToInclude = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof qv) {
        var t = arguments[0];
        this.expandToInclude(t.x, t.y);
      } else if (arguments[0] instanceof fb) {
        var e = arguments[0];
        if (e.isNull()) return null;
        this.isNull()
          ? ((this._minx = e.getMinX()),
            (this._maxx = e.getMaxX()),
            (this._miny = e.getMinY()),
            (this._maxy = e.getMaxY()))
          : (e._minx < this._minx && (this._minx = e._minx),
            e._maxx > this._maxx && (this._maxx = e._maxx),
            e._miny < this._miny && (this._miny = e._miny),
            e._maxy > this._maxy && (this._maxy = e._maxy));
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      this.isNull()
        ? ((this._minx = i),
          (this._maxx = i),
          (this._miny = n),
          (this._maxy = n))
        : (i < this._minx && (this._minx = i),
          i > this._maxx && (this._maxx = i),
          n < this._miny && (this._miny = n),
          n > this._maxy && (this._maxy = n));
    }
  }),
  (fb.prototype.minExtent = function () {
    if (this.isNull()) return 0;
    var t = this.getWidth(),
      e = this.getHeight();
    return t < e ? t : e;
  }),
  (fb.prototype.getWidth = function () {
    return this.isNull() ? 0 : this._maxx - this._minx;
  }),
  (fb.prototype.compareTo = function (t) {
    var e = t;
    return this.isNull()
      ? e.isNull()
        ? 0
        : -1
      : e.isNull()
      ? 1
      : this._minx < e._minx
      ? -1
      : this._minx > e._minx
      ? 1
      : this._miny < e._miny
      ? -1
      : this._miny > e._miny
      ? 1
      : this._maxx < e._maxx
      ? -1
      : this._maxx > e._maxx
      ? 1
      : this._maxy < e._maxy
      ? -1
      : this._maxy > e._maxy
      ? 1
      : 0;
  }),
  (fb.prototype.translate = function (t, e) {
    if (this.isNull()) return null;
    this.init(
      this.getMinX() + t,
      this.getMaxX() + t,
      this.getMinY() + e,
      this.getMaxY() + e
    );
  }),
  (fb.prototype.toString = function () {
    return (
      "Env[" +
      this._minx +
      " : " +
      this._maxx +
      ", " +
      this._miny +
      " : " +
      this._maxy +
      "]"
    );
  }),
  (fb.prototype.setToNull = function () {
    (this._minx = 0), (this._maxx = -1), (this._miny = 0), (this._maxy = -1);
  }),
  (fb.prototype.getHeight = function () {
    return this.isNull() ? 0 : this._maxy - this._miny;
  }),
  (fb.prototype.maxExtent = function () {
    if (this.isNull()) return 0;
    var t = this.getWidth(),
      e = this.getHeight();
    return t > e ? t : e;
  }),
  (fb.prototype.expandBy = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.expandBy(t, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      if (this.isNull()) return null;
      (this._minx -= e),
        (this._maxx += e),
        (this._miny -= i),
        (this._maxy += i),
        (this._minx > this._maxx || this._miny > this._maxy) &&
          this.setToNull();
    }
  }),
  (fb.prototype.contains = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof fb) {
        var t = arguments[0];
        return this.covers(t);
      }
      if (arguments[0] instanceof qv) {
        var e = arguments[0];
        return this.covers(e);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      return this.covers(i, n);
    }
  }),
  (fb.prototype.centre = function () {
    return this.isNull()
      ? null
      : new qv(
          (this.getMinX() + this.getMaxX()) / 2,
          (this.getMinY() + this.getMaxY()) / 2
        );
  }),
  (fb.prototype.init = function () {
    if (0 === arguments.length) this.setToNull();
    else if (1 === arguments.length) {
      if (arguments[0] instanceof qv) {
        var t = arguments[0];
        this.init(t.x, t.x, t.y, t.y);
      } else if (arguments[0] instanceof fb) {
        var e = arguments[0];
        (this._minx = e._minx),
          (this._maxx = e._maxx),
          (this._miny = e._miny),
          (this._maxy = e._maxy);
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      this.init(i.x, n.x, i.y, n.y);
    } else if (4 === arguments.length) {
      var r = arguments[0],
        o = arguments[1],
        a = arguments[2],
        s = arguments[3];
      r < o
        ? ((this._minx = r), (this._maxx = o))
        : ((this._minx = o), (this._maxx = r)),
        a < s
          ? ((this._miny = a), (this._maxy = s))
          : ((this._miny = s), (this._maxy = a));
    }
  }),
  (fb.prototype.getMaxY = function () {
    return this._maxy;
  }),
  (fb.prototype.distance = function (t) {
    if (this.intersects(t)) return 0;
    var e = 0;
    this._maxx < t._minx
      ? (e = t._minx - this._maxx)
      : this._minx > t._maxx && (e = this._minx - t._maxx);
    var i = 0;
    return (
      this._maxy < t._miny
        ? (i = t._miny - this._maxy)
        : this._miny > t._maxy && (i = this._miny - t._maxy),
      0 === e ? i : 0 === i ? e : Math.sqrt(e * e + i * i)
    );
  }),
  (fb.prototype.hashCode = function () {
    var t = 17;
    return (t =
      37 *
        (t =
          37 *
            (t =
              37 * (t = 37 * t + qv.hashCode(this._minx)) +
              qv.hashCode(this._maxx)) +
          qv.hashCode(this._miny)) +
      qv.hashCode(this._maxy));
  }),
  (fb.prototype.interfaces_ = function () {
    return [jv, Wv];
  }),
  (fb.prototype.getClass = function () {
    return fb;
  }),
  (fb.intersects = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
        e = arguments[1],
        i = arguments[2];
      return (
        i.x >= (t.x < e.x ? t.x : e.x) &&
        i.x <= (t.x > e.x ? t.x : e.x) &&
        i.y >= (t.y < e.y ? t.y : e.y) &&
        i.y <= (t.y > e.y ? t.y : e.y)
      );
    }
    if (4 === arguments.length) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2],
        a = arguments[3],
        s = Math.min(o.x, a.x),
        l = Math.max(o.x, a.x),
        u = Math.min(n.x, r.x),
        c = Math.max(n.x, r.x);
      return (
        !(u > l) &&
        !(c < s) &&
        ((s = Math.min(o.y, a.y)),
        (l = Math.max(o.y, a.y)),
        (u = Math.min(n.y, r.y)),
        (c = Math.max(n.y, r.y)),
        !(u > l) && !(c < s))
      );
    }
  }),
  (gb.serialVersionUID.get = function () {
    return 0x51845cd552189800;
  }),
  Object.defineProperties(fb, gb);
var mb = {
    typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
    emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
    spaces: /\s+/,
    parenComma: /\)\s*,\s*\(/,
    doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
    trimParens: /^\s*\(?(.*?)\)?\s*$/,
  },
  yb = function (t) {
    this.geometryFactory = t || new i_();
  };
(yb.prototype.read = function (t) {
  var e, i, n;
  t = t.replace(/[\n\r]/g, " ");
  var r = mb.typeStr.exec(t);
  if (
    (-1 !== t.search("EMPTY") && ((r = mb.emptyTypeStr.exec(t))[2] = void 0),
    r &&
      ((i = r[1].toLowerCase()),
      (n = r[2]),
      bb[i] && (e = bb[i].apply(this, [n]))),
    void 0 === e)
  )
    throw new Error("Could not parse WKT " + t);
  return e;
}),
  (yb.prototype.write = function (t) {
    return this.extractGeometry(t);
  }),
  (yb.prototype.extractGeometry = function (t) {
    var e = t.getGeometryType().toLowerCase();
    if (!vb[e]) return null;
    var i = e.toUpperCase();
    return t.isEmpty() ? i + " EMPTY" : i + "(" + vb[e].apply(this, [t]) + ")";
  });
var vb = {
    coordinate: function (t) {
      return t.x + " " + t.y;
    },
    point: function (t) {
      return vb.coordinate.call(this, t._coordinates._coordinates[0]);
    },
    multipoint: function (t) {
      for (var e = [], i = 0, n = t._geometries.length; i < n; ++i)
        e.push("(" + vb.point.apply(this, [t._geometries[i]]) + ")");
      return e.join(",");
    },
    linestring: function (t) {
      for (var e = [], i = 0, n = t._points._coordinates.length; i < n; ++i)
        e.push(vb.coordinate.apply(this, [t._points._coordinates[i]]));
      return e.join(",");
    },
    linearring: function (t) {
      for (var e = [], i = 0, n = t._points._coordinates.length; i < n; ++i)
        e.push(vb.coordinate.apply(this, [t._points._coordinates[i]]));
      return e.join(",");
    },
    multilinestring: function (t) {
      for (var e = [], i = 0, n = t._geometries.length; i < n; ++i)
        e.push("(" + vb.linestring.apply(this, [t._geometries[i]]) + ")");
      return e.join(",");
    },
    polygon: function (t) {
      var e = [];
      e.push("(" + vb.linestring.apply(this, [t._shell]) + ")");
      for (var i = 0, n = t._holes.length; i < n; ++i)
        e.push("(" + vb.linestring.apply(this, [t._holes[i]]) + ")");
      return e.join(",");
    },
    multipolygon: function (t) {
      for (var e = [], i = 0, n = t._geometries.length; i < n; ++i)
        e.push("(" + vb.polygon.apply(this, [t._geometries[i]]) + ")");
      return e.join(",");
    },
    geometrycollection: function (t) {
      for (var e = [], i = 0, n = t._geometries.length; i < n; ++i)
        e.push(this.extractGeometry(t._geometries[i]));
      return e.join(",");
    },
  },
  bb = {
    point: function (t) {
      if (void 0 === t) return this.geometryFactory.createPoint();
      var e = t.trim().split(mb.spaces);
      return this.geometryFactory.createPoint(
        new qv(Number.parseFloat(e[0]), Number.parseFloat(e[1]))
      );
    },
    multipoint: function (t) {
      var e;
      if (void 0 === t) return this.geometryFactory.createMultiPoint();
      for (var i = t.trim().split(","), n = [], r = 0, o = i.length; r < o; ++r)
        (e = i[r].replace(mb.trimParens, "$1")),
          n.push(bb.point.apply(this, [e]));
      return this.geometryFactory.createMultiPoint(n);
    },
    linestring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLineString();
      for (
        var e, i = t.trim().split(","), n = [], r = 0, o = i.length;
        r < o;
        ++r
      )
        (e = i[r].trim().split(mb.spaces)),
          n.push(new qv(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
      return this.geometryFactory.createLineString(n);
    },
    linearring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLinearRing();
      for (
        var e, i = t.trim().split(","), n = [], r = 0, o = i.length;
        r < o;
        ++r
      )
        (e = i[r].trim().split(mb.spaces)),
          n.push(new qv(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
      return this.geometryFactory.createLinearRing(n);
    },
    multilinestring: function (t) {
      var e;
      if (void 0 === t) return this.geometryFactory.createMultiLineString();
      for (
        var i = t.trim().split(mb.parenComma), n = [], r = 0, o = i.length;
        r < o;
        ++r
      )
        (e = i[r].replace(mb.trimParens, "$1")),
          n.push(bb.linestring.apply(this, [e]));
      return this.geometryFactory.createMultiLineString(n);
    },
    polygon: function (t) {
      var e, i, n;
      if (void 0 === t) return this.geometryFactory.createPolygon();
      for (
        var r, o = t.trim().split(mb.parenComma), a = [], s = 0, l = o.length;
        s < l;
        ++s
      )
        (e = o[s].replace(mb.trimParens, "$1")),
          (i = bb.linestring.apply(this, [e])),
          (n = this.geometryFactory.createLinearRing(i._points)),
          0 === s ? (r = n) : a.push(n);
      return this.geometryFactory.createPolygon(r, a);
    },
    multipolygon: function (t) {
      var e;
      if (void 0 === t) return this.geometryFactory.createMultiPolygon();
      for (
        var i = t.trim().split(mb.doubleParenComma),
          n = [],
          r = 0,
          o = i.length;
        r < o;
        ++r
      )
        (e = i[r].replace(mb.trimParens, "$1")),
          n.push(bb.polygon.apply(this, [e]));
      return this.geometryFactory.createMultiPolygon(n);
    },
    geometrycollection: function (t) {
      if (void 0 === t) return this.geometryFactory.createGeometryCollection();
      for (
        var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"),
          i = [],
          n = 0,
          r = e.length;
        n < r;
        ++n
      )
        i.push(this.read(e[n]));
      return this.geometryFactory.createGeometryCollection(i);
    },
  },
  xb = function (t) {
    this.parser = new yb(t);
  };
(xb.prototype.write = function (t) {
  return this.parser.write(t);
}),
  (xb.toLineString = function (t, e) {
    if (2 !== arguments.length) throw new Error("Not implemented");
    return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
  });
var _b = (function (t) {
    function e(e) {
      t.call(this, e),
        (this.name = "RuntimeException"),
        (this.message = e),
        (this.stack = new t().stack);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      e
    );
  })(Error),
  Sb = (function (t) {
    function e() {
      if ((t.call(this), 0 === arguments.length)) t.call(this);
      else if (1 === arguments.length) {
        var e = arguments[0];
        t.call(this, e);
      }
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(_b),
  Mb = function () {};
(Mb.prototype.interfaces_ = function () {
  return [];
}),
  (Mb.prototype.getClass = function () {
    return Mb;
  }),
  (Mb.shouldNeverReachHere = function () {
    if (0 === arguments.length) Mb.shouldNeverReachHere(null);
    else if (1 === arguments.length) {
      var t = arguments[0];
      throw new Sb("Should never reach here" + (null !== t ? ": " + t : ""));
    }
  }),
  (Mb.isTrue = function () {
    var t;
    if (1 === arguments.length) Mb.isTrue(arguments[0], null);
    else if (2 === arguments.length && ((t = arguments[1]), !arguments[0]))
      throw null === t ? new Sb() : new Sb(t);
  }),
  (Mb.equals = function () {
    var t, e, i;
    if (2 === arguments.length)
      Mb.equals((t = arguments[0]), (e = arguments[1]), null);
    else if (
      3 === arguments.length &&
      ((t = arguments[0]), (i = arguments[2]), !(e = arguments[1]).equals(t))
    )
      throw new Sb(
        "Expected " + t + " but encountered " + e + (null !== i ? ": " + i : "")
      );
  });
var Cb = function () {
    (this._result = null),
      (this._inputLines = Array(2)
        .fill()
        .map(function () {
          return Array(2);
        })),
      (this._intPt = new Array(2).fill(null)),
      (this._intLineIndex = null),
      (this._isProper = null),
      (this._pa = null),
      (this._pb = null),
      (this._precisionModel = null),
      (this._intPt[0] = new qv()),
      (this._intPt[1] = new qv()),
      (this._pa = this._intPt[0]),
      (this._pb = this._intPt[1]),
      (this._result = 0);
  },
  wb = {
    DONT_INTERSECT: {
      configurable: !0,
    },
    DO_INTERSECT: {
      configurable: !0,
    },
    COLLINEAR: {
      configurable: !0,
    },
    NO_INTERSECTION: {
      configurable: !0,
    },
    POINT_INTERSECTION: {
      configurable: !0,
    },
    COLLINEAR_INTERSECTION: {
      configurable: !0,
    },
  };
(Cb.prototype.getIndexAlongSegment = function (t, e) {
  return this.computeIntLineIndex(), this._intLineIndex[t][e];
}),
  (Cb.prototype.getTopologySummary = function () {
    var t = new eb();
    return (
      this.isEndPoint() && t.append(" endpoint"),
      this._isProper && t.append(" proper"),
      this.isCollinear() && t.append(" collinear"),
      t.toString()
    );
  }),
  (Cb.prototype.computeIntersection = function (t, e, i, n) {
    (this._inputLines[0][0] = t),
      (this._inputLines[0][1] = e),
      (this._inputLines[1][0] = i),
      (this._inputLines[1][1] = n),
      (this._result = this.computeIntersect(t, e, i, n));
  }),
  (Cb.prototype.getIntersectionNum = function () {
    return this._result;
  }),
  (Cb.prototype.computeIntLineIndex = function () {
    if (0 === arguments.length)
      null === this._intLineIndex &&
        ((this._intLineIndex = Array(2)
          .fill()
          .map(function () {
            return Array(2);
          })),
        this.computeIntLineIndex(0),
        this.computeIntLineIndex(1));
    else if (1 === arguments.length) {
      var t = arguments[0];
      this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1)
        ? ((this._intLineIndex[t][0] = 0), (this._intLineIndex[t][1] = 1))
        : ((this._intLineIndex[t][0] = 1), (this._intLineIndex[t][1] = 0));
    }
  }),
  (Cb.prototype.isProper = function () {
    return this.hasIntersection() && this._isProper;
  }),
  (Cb.prototype.setPrecisionModel = function (t) {
    this._precisionModel = t;
  }),
  (Cb.prototype.isInteriorIntersection = function () {
    var t = this;
    if (0 === arguments.length)
      return (
        !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1)
      );
    if (1 === arguments.length) {
      for (var e = arguments[0], i = 0; i < this._result; i++)
        if (
          !t._intPt[i].equals2D(t._inputLines[e][0]) &&
          !t._intPt[i].equals2D(t._inputLines[e][1])
        )
          return !0;
      return !1;
    }
  }),
  (Cb.prototype.getIntersection = function (t) {
    return this._intPt[t];
  }),
  (Cb.prototype.isEndPoint = function () {
    return this.hasIntersection() && !this._isProper;
  }),
  (Cb.prototype.hasIntersection = function () {
    return this._result !== Cb.NO_INTERSECTION;
  }),
  (Cb.prototype.getEdgeDistance = function (t, e) {
    return Cb.computeEdgeDistance(
      this._intPt[e],
      this._inputLines[t][0],
      this._inputLines[t][1]
    );
  }),
  (Cb.prototype.isCollinear = function () {
    return this._result === Cb.COLLINEAR_INTERSECTION;
  }),
  (Cb.prototype.toString = function () {
    return (
      xb.toLineString(this._inputLines[0][0], this._inputLines[0][1]) +
      " - " +
      xb.toLineString(this._inputLines[1][0], this._inputLines[1][1]) +
      this.getTopologySummary()
    );
  }),
  (Cb.prototype.getEndpoint = function (t, e) {
    return this._inputLines[t][e];
  }),
  (Cb.prototype.isIntersection = function (t) {
    for (var e = 0; e < this._result; e++)
      if (this._intPt[e].equals2D(t)) return !0;
    return !1;
  }),
  (Cb.prototype.getIntersectionAlongSegment = function (t, e) {
    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];
  }),
  (Cb.prototype.interfaces_ = function () {
    return [];
  }),
  (Cb.prototype.getClass = function () {
    return Cb;
  }),
  (Cb.computeEdgeDistance = function (t, e, i) {
    var n = Math.abs(i.x - e.x),
      r = Math.abs(i.y - e.y),
      o = -1;
    if (t.equals(e)) o = 0;
    else if (t.equals(i)) o = n > r ? n : r;
    else {
      var a = Math.abs(t.x - e.x),
        s = Math.abs(t.y - e.y);
      0 !== (o = n > r ? a : s) || t.equals(e) || (o = Math.max(a, s));
    }
    return Mb.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o;
  }),
  (Cb.nonRobustComputeEdgeDistance = function (t, e, i) {
    var n = t.x - e.x,
      r = t.y - e.y,
      o = Math.sqrt(n * n + r * r);
    return (
      Mb.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
    );
  }),
  (wb.DONT_INTERSECT.get = function () {
    return 0;
  }),
  (wb.DO_INTERSECT.get = function () {
    return 1;
  }),
  (wb.COLLINEAR.get = function () {
    return 2;
  }),
  (wb.NO_INTERSECTION.get = function () {
    return 0;
  }),
  (wb.POINT_INTERSECTION.get = function () {
    return 1;
  }),
  (wb.COLLINEAR_INTERSECTION.get = function () {
    return 2;
  }),
  Object.defineProperties(Cb, wb);
var Ab = (function (t) {
    function e() {
      t.apply(this, arguments);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.isInSegmentEnvelopes = function (t) {
        var e = new fb(this._inputLines[0][0], this._inputLines[0][1]),
          i = new fb(this._inputLines[1][0], this._inputLines[1][1]);
        return e.contains(t) && i.contains(t);
      }),
      (e.prototype.computeIntersection = function () {
        if (3 !== arguments.length)
          return t.prototype.computeIntersection.apply(this, arguments);
        var e = arguments[0],
          i = arguments[1],
          n = arguments[2];
        if (
          ((this._isProper = !1),
          fb.intersects(i, n, e) &&
            0 === Tb.orientationIndex(i, n, e) &&
            0 === Tb.orientationIndex(n, i, e))
        )
          return (
            (this._isProper = !0),
            (e.equals(i) || e.equals(n)) && (this._isProper = !1),
            (this._result = t.POINT_INTERSECTION),
            null
          );
        this._result = t.NO_INTERSECTION;
      }),
      (e.prototype.normalizeToMinimum = function (t, e, i, n, r) {
        (r.x = this.smallestInAbsValue(t.x, e.x, i.x, n.x)),
          (r.y = this.smallestInAbsValue(t.y, e.y, i.y, n.y)),
          (t.x -= r.x),
          (t.y -= r.y),
          (e.x -= r.x),
          (e.y -= r.y),
          (i.x -= r.x),
          (i.y -= r.y),
          (n.x -= r.x),
          (n.y -= r.y);
      }),
      (e.prototype.safeHCoordinateIntersection = function (t, i, n, r) {
        var o = null;
        try {
          o = db.intersection(t, i, n, r);
        } catch (a) {
          if (!(a instanceof hb)) throw a;
          o = e.nearestEndpoint(t, i, n, r);
        }
        return o;
      }),
      (e.prototype.intersection = function (t, i, n, r) {
        var o = this.intersectionWithNormalization(t, i, n, r);
        return (
          this.isInSegmentEnvelopes(o) ||
            (o = new qv(e.nearestEndpoint(t, i, n, r))),
          null !== this._precisionModel && this._precisionModel.makePrecise(o),
          o
        );
      }),
      (e.prototype.smallestInAbsValue = function (t, e, i, n) {
        var r = t,
          o = Math.abs(r);
        return (
          Math.abs(e) < o && ((r = e), (o = Math.abs(e))),
          Math.abs(i) < o && ((r = i), (o = Math.abs(i))),
          Math.abs(n) < o && (r = n),
          r
        );
      }),
      (e.prototype.checkDD = function (t, e, i, n, r) {
        var o = ab.intersection(t, e, i, n),
          a = this.isInSegmentEnvelopes(o);
        pb.out.println("DD in env = " + a + "  --------------------- " + o),
          r.distance(o) > 1e-4 && pb.out.println("Distance = " + r.distance(o));
      }),
      (e.prototype.intersectionWithNormalization = function (t, e, i, n) {
        var r = new qv(t),
          o = new qv(e),
          a = new qv(i),
          s = new qv(n),
          l = new qv();
        this.normalizeToEnvCentre(r, o, a, s, l);
        var u = this.safeHCoordinateIntersection(r, o, a, s);
        return (u.x += l.x), (u.y += l.y), u;
      }),
      (e.prototype.computeCollinearIntersection = function (e, i, n, r) {
        var o = fb.intersects(e, i, n),
          a = fb.intersects(e, i, r),
          s = fb.intersects(n, r, e),
          l = fb.intersects(n, r, i);
        return o && a
          ? ((this._intPt[0] = n),
            (this._intPt[1] = r),
            t.COLLINEAR_INTERSECTION)
          : s && l
          ? ((this._intPt[0] = e),
            (this._intPt[1] = i),
            t.COLLINEAR_INTERSECTION)
          : o && s
          ? ((this._intPt[0] = n),
            (this._intPt[1] = e),
            !n.equals(e) || a || l
              ? t.COLLINEAR_INTERSECTION
              : t.POINT_INTERSECTION)
          : o && l
          ? ((this._intPt[0] = n),
            (this._intPt[1] = i),
            !n.equals(i) || a || s
              ? t.COLLINEAR_INTERSECTION
              : t.POINT_INTERSECTION)
          : a && s
          ? ((this._intPt[0] = r),
            (this._intPt[1] = e),
            !r.equals(e) || o || l
              ? t.COLLINEAR_INTERSECTION
              : t.POINT_INTERSECTION)
          : a && l
          ? ((this._intPt[0] = r),
            (this._intPt[1] = i),
            !r.equals(i) || o || s
              ? t.COLLINEAR_INTERSECTION
              : t.POINT_INTERSECTION)
          : t.NO_INTERSECTION;
      }),
      (e.prototype.normalizeToEnvCentre = function (t, e, i, n, r) {
        var o = t.x < e.x ? t.x : e.x,
          a = t.y < e.y ? t.y : e.y,
          s = t.x > e.x ? t.x : e.x,
          l = t.y > e.y ? t.y : e.y,
          u = i.x < n.x ? i.x : n.x,
          c = i.y < n.y ? i.y : n.y,
          h = i.x > n.x ? i.x : n.x,
          p = i.y > n.y ? i.y : n.y,
          d = ((o > u ? o : u) + (s < h ? s : h)) / 2,
          f = ((a > c ? a : c) + (l < p ? l : p)) / 2;
        (r.x = d),
          (r.y = f),
          (t.x -= r.x),
          (t.y -= r.y),
          (e.x -= r.x),
          (e.y -= r.y),
          (i.x -= r.x),
          (i.y -= r.y),
          (n.x -= r.x),
          (n.y -= r.y);
      }),
      (e.prototype.computeIntersect = function (e, i, n, r) {
        if (((this._isProper = !1), !fb.intersects(e, i, n, r)))
          return t.NO_INTERSECTION;
        var o = Tb.orientationIndex(e, i, n),
          a = Tb.orientationIndex(e, i, r);
        if ((o > 0 && a > 0) || (o < 0 && a < 0)) return t.NO_INTERSECTION;
        var s = Tb.orientationIndex(n, r, e),
          l = Tb.orientationIndex(n, r, i);
        return (s > 0 && l > 0) || (s < 0 && l < 0)
          ? t.NO_INTERSECTION
          : 0 === o && 0 === a && 0 === s && 0 === l
          ? this.computeCollinearIntersection(e, i, n, r)
          : (0 === o || 0 === a || 0 === s || 0 === l
              ? ((this._isProper = !1),
                e.equals2D(n) || e.equals2D(r)
                  ? (this._intPt[0] = e)
                  : i.equals2D(n) || i.equals2D(r)
                  ? (this._intPt[0] = i)
                  : 0 === o
                  ? (this._intPt[0] = new qv(n))
                  : 0 === a
                  ? (this._intPt[0] = new qv(r))
                  : 0 === s
                  ? (this._intPt[0] = new qv(e))
                  : 0 === l && (this._intPt[0] = new qv(i)))
              : ((this._isProper = !0),
                (this._intPt[0] = this.intersection(e, i, n, r))),
            t.POINT_INTERSECTION);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.nearestEndpoint = function (t, e, i, n) {
        var r = t,
          o = Tb.distancePointLine(t, i, n),
          a = Tb.distancePointLine(e, i, n);
        return (
          a < o && ((o = a), (r = e)),
          (a = Tb.distancePointLine(i, t, e)) < o && ((o = a), (r = i)),
          (a = Tb.distancePointLine(n, t, e)) < o && ((o = a), (r = n)),
          r
        );
      }),
      e
    );
  })(Cb),
  Eb = function () {};
(Eb.prototype.interfaces_ = function () {
  return [];
}),
  (Eb.prototype.getClass = function () {
    return Eb;
  }),
  (Eb.orientationIndex = function (t, e, i) {
    var n = e.x - t.x,
      r = e.y - t.y,
      o = i.x - e.x,
      a = i.y - e.y;
    return Eb.signOfDet2x2(n, r, o, a);
  }),
  (Eb.signOfDet2x2 = function (t, e, i, n) {
    var r = null,
      o = null,
      a = null;
    if (((r = 1), 0 === t || 0 === n))
      return 0 === e || 0 === i ? 0 : e > 0 ? (i > 0 ? -r : r) : i > 0 ? r : -r;
    if (0 === e || 0 === i) return n > 0 ? (t > 0 ? r : -r) : t > 0 ? -r : r;
    if (
      (e > 0
        ? n > 0
          ? e <= n ||
            ((r = -r), (o = t), (t = i), (i = o), (o = e), (e = n), (n = o))
          : e <= -n
          ? ((r = -r), (i = -i), (n = -n))
          : ((o = t), (t = -i), (i = o), (o = e), (e = -n), (n = o))
        : n > 0
        ? -e <= n
          ? ((r = -r), (t = -t), (e = -e))
          : ((o = -t), (t = i), (i = o), (o = -e), (e = n), (n = o))
        : e >= n
        ? ((t = -t), (e = -e), (i = -i), (n = -n))
        : ((r = -r), (o = -t), (t = -i), (i = o), (o = -e), (e = -n), (n = o)),
      t > 0)
    ) {
      if (!(i > 0)) return r;
      if (!(t <= i)) return r;
    } else {
      if (i > 0) return -r;
      if (!(t >= i)) return -r;
      (r = -r), (t = -t), (i = -i);
    }
    for (;;) {
      if ((n -= (a = Math.floor(i / t)) * e) < 0) return -r;
      if (n > e) return r;
      if (t > (i -= a * t) + i) {
        if (e < n + n) return r;
      } else {
        if (e > n + n) return -r;
        (i = t - i), (n = e - n), (r = -r);
      }
      if (0 === n) return 0 === i ? 0 : -r;
      if (0 === i) return r;
      if ((e -= (a = Math.floor(t / i)) * n) < 0) return r;
      if (e > n) return -r;
      if (i > (t -= a * i) + t) {
        if (n < e + e) return -r;
      } else {
        if (n > e + e) return r;
        (t = i - t), (e = n - e), (r = -r);
      }
      if (0 === e) return 0 === t ? 0 : r;
      if (0 === t) return -r;
    }
  });
var Db = function () {
  (this._p = null), (this._crossingCount = 0), (this._isPointOnSegment = !1);
  var t = arguments[0];
  this._p = t;
};
(Db.prototype.countSegment = function (t, e) {
  if (t.x < this._p.x && e.x < this._p.x) return null;
  if (this._p.x === e.x && this._p.y === e.y)
    return (this._isPointOnSegment = !0), null;
  if (t.y === this._p.y && e.y === this._p.y) {
    var i = t.x,
      n = e.x;
    return (
      i > n && ((i = e.x), (n = t.x)),
      this._p.x >= i && this._p.x <= n && (this._isPointOnSegment = !0),
      null
    );
  }
  if (
    (t.y > this._p.y && e.y <= this._p.y) ||
    (e.y > this._p.y && t.y <= this._p.y)
  ) {
    var r = t.x - this._p.x,
      o = t.y - this._p.y,
      a = e.x - this._p.x,
      s = e.y - this._p.y,
      l = Eb.signOfDet2x2(r, o, a, s);
    if (0 === l) return (this._isPointOnSegment = !0), null;
    s < o && (l = -l), l > 0 && this._crossingCount++;
  }
}),
  (Db.prototype.isPointInPolygon = function () {
    return this.getLocation() !== Zv.EXTERIOR;
  }),
  (Db.prototype.getLocation = function () {
    return this._isPointOnSegment
      ? Zv.BOUNDARY
      : this._crossingCount % 2 == 1
      ? Zv.INTERIOR
      : Zv.EXTERIOR;
  }),
  (Db.prototype.isOnSegment = function () {
    return this._isPointOnSegment;
  }),
  (Db.prototype.interfaces_ = function () {
    return [];
  }),
  (Db.prototype.getClass = function () {
    return Db;
  }),
  (Db.locatePointInRing = function () {
    if (arguments[0] instanceof qv && Kv(arguments[1], lb)) {
      for (
        var t = arguments[1],
          e = new Db(arguments[0]),
          i = new qv(),
          n = new qv(),
          r = 1;
        r < t.size();
        r++
      )
        if (
          (t.getCoordinate(r, i),
          t.getCoordinate(r - 1, n),
          e.countSegment(i, n),
          e.isOnSegment())
        )
          return e.getLocation();
      return e.getLocation();
    }
    if (arguments[0] instanceof qv && arguments[1] instanceof Array) {
      for (
        var o = arguments[1], a = new Db(arguments[0]), s = 1;
        s < o.length;
        s++
      ) {
        var l = o[s],
          u = o[s - 1];
        if ((a.countSegment(l, u), a.isOnSegment())) return a.getLocation();
      }
      return a.getLocation();
    }
  });
var Tb = function () {},
  Pb = {
    CLOCKWISE: {
      configurable: !0,
    },
    RIGHT: {
      configurable: !0,
    },
    COUNTERCLOCKWISE: {
      configurable: !0,
    },
    LEFT: {
      configurable: !0,
    },
    COLLINEAR: {
      configurable: !0,
    },
    STRAIGHT: {
      configurable: !0,
    },
  };
(Tb.prototype.interfaces_ = function () {
  return [];
}),
  (Tb.prototype.getClass = function () {
    return Tb;
  }),
  (Tb.orientationIndex = function (t, e, i) {
    return ab.orientationIndex(t, e, i);
  }),
  (Tb.signedArea = function () {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      if (t.length < 3) return 0;
      for (var e = 0, i = t[0].x, n = 1; n < t.length - 1; n++) {
        var r = t[n].x - i,
          o = t[n + 1].y;
        e += r * (t[n - 1].y - o);
      }
      return e / 2;
    }
    if (Kv(arguments[0], lb)) {
      var a = arguments[0],
        s = a.size();
      if (s < 3) return 0;
      var l = new qv(),
        u = new qv(),
        c = new qv();
      a.getCoordinate(0, u), a.getCoordinate(1, c);
      var h = u.x;
      c.x -= h;
      for (var p = 0, d = 1; d < s - 1; d++)
        (l.y = u.y),
          (u.x = c.x),
          (u.y = c.y),
          a.getCoordinate(d + 1, c),
          (c.x -= h),
          (p += u.x * (l.y - c.y));
      return p / 2;
    }
  }),
  (Tb.distanceLineLine = function (t, e, i, n) {
    if (t.equals(e)) return Tb.distancePointLine(t, i, n);
    if (i.equals(n)) return Tb.distancePointLine(n, t, e);
    var r = !1;
    if (fb.intersects(t, e, i, n)) {
      var o = (e.x - t.x) * (n.y - i.y) - (e.y - t.y) * (n.x - i.x);
      if (0 === o) r = !0;
      else {
        var a = (t.y - i.y) * (n.x - i.x) - (t.x - i.x) * (n.y - i.y),
          s = ((t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y)) / o,
          l = a / o;
        (l < 0 || l > 1 || s < 0 || s > 1) && (r = !0);
      }
    } else r = !0;
    return r
      ? $v.min(
          Tb.distancePointLine(t, i, n),
          Tb.distancePointLine(e, i, n),
          Tb.distancePointLine(i, t, e),
          Tb.distancePointLine(n, t, e)
        )
      : 0;
  }),
  (Tb.isPointInRing = function (t, e) {
    return Tb.locatePointInRing(t, e) !== Zv.EXTERIOR;
  }),
  (Tb.computeLength = function (t) {
    var e = t.size();
    if (e <= 1) return 0;
    var i = 0,
      n = new qv();
    t.getCoordinate(0, n);
    for (var r = n.x, o = n.y, a = 1; a < e; a++) {
      t.getCoordinate(a, n);
      var s = n.x,
        l = n.y,
        u = s - r,
        c = l - o;
      (i += Math.sqrt(u * u + c * c)), (r = s), (o = l);
    }
    return i;
  }),
  (Tb.isCCW = function (t) {
    var e = t.length - 1;
    if (e < 3)
      throw new Bv(
        "Ring has fewer than 4 points, so orientation cannot be determined"
      );
    for (var i = t[0], n = 0, r = 1; r <= e; r++) {
      var o = t[r];
      o.y > i.y && ((i = o), (n = r));
    }
    var a = n;
    do {
      (a -= 1) < 0 && (a = e);
    } while (t[a].equals2D(i) && a !== n);
    var s = n;
    do {
      s = (s + 1) % e;
    } while (t[s].equals2D(i) && s !== n);
    var l = t[a],
      u = t[s];
    if (l.equals2D(i) || u.equals2D(i) || l.equals2D(u)) return !1;
    var c = Tb.computeOrientation(l, i, u);
    return 0 === c ? l.x > u.x : c > 0;
  }),
  (Tb.locatePointInRing = function (t, e) {
    return Db.locatePointInRing(t, e);
  }),
  (Tb.distancePointLinePerpendicular = function (t, e, i) {
    var n = (i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y),
      r = ((e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)) / n;
    return Math.abs(r) * Math.sqrt(n);
  }),
  (Tb.computeOrientation = function (t, e, i) {
    return Tb.orientationIndex(t, e, i);
  }),
  (Tb.distancePointLine = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      if (0 === e.length)
        throw new Bv("Line array must contain at least one vertex");
      for (var i = t.distance(e[0]), n = 0; n < e.length - 1; n++) {
        var r = Tb.distancePointLine(t, e[n], e[n + 1]);
        r < i && (i = r);
      }
      return i;
    }
    if (3 === arguments.length) {
      var o = arguments[0],
        a = arguments[1],
        s = arguments[2];
      if (a.x === s.x && a.y === s.y) return o.distance(a);
      var l = (s.x - a.x) * (s.x - a.x) + (s.y - a.y) * (s.y - a.y),
        u = ((o.x - a.x) * (s.x - a.x) + (o.y - a.y) * (s.y - a.y)) / l;
      if (u <= 0) return o.distance(a);
      if (u >= 1) return o.distance(s);
      var c = ((a.y - o.y) * (s.x - a.x) - (a.x - o.x) * (s.y - a.y)) / l;
      return Math.abs(c) * Math.sqrt(l);
    }
  }),
  (Tb.isOnLine = function (t, e) {
    for (var i = new Ab(), n = 1; n < e.length; n++) {
      var r = e[n - 1],
        o = e[n];
      if ((i.computeIntersection(t, r, o), i.hasIntersection())) return !0;
    }
    return !1;
  }),
  (Pb.CLOCKWISE.get = function () {
    return -1;
  }),
  (Pb.RIGHT.get = function () {
    return Tb.CLOCKWISE;
  }),
  (Pb.COUNTERCLOCKWISE.get = function () {
    return 1;
  }),
  (Pb.LEFT.get = function () {
    return Tb.COUNTERCLOCKWISE;
  }),
  (Pb.COLLINEAR.get = function () {
    return 0;
  }),
  (Pb.STRAIGHT.get = function () {
    return Tb.COLLINEAR;
  }),
  Object.defineProperties(Tb, Pb);
var Lb = function () {};
(Lb.prototype.filter = function (t) {}),
  (Lb.prototype.interfaces_ = function () {
    return [];
  }),
  (Lb.prototype.getClass = function () {
    return Lb;
  });
var Ib = function () {
    var t = arguments[0];
    (this._envelope = null),
      (this._factory = null),
      (this._SRID = null),
      (this._userData = null),
      (this._factory = t),
      (this._SRID = t.getSRID());
  },
  Nb = {
    serialVersionUID: {
      configurable: !0,
    },
    SORTINDEX_POINT: {
      configurable: !0,
    },
    SORTINDEX_MULTIPOINT: {
      configurable: !0,
    },
    SORTINDEX_LINESTRING: {
      configurable: !0,
    },
    SORTINDEX_LINEARRING: {
      configurable: !0,
    },
    SORTINDEX_MULTILINESTRING: {
      configurable: !0,
    },
    SORTINDEX_POLYGON: {
      configurable: !0,
    },
    SORTINDEX_MULTIPOLYGON: {
      configurable: !0,
    },
    SORTINDEX_GEOMETRYCOLLECTION: {
      configurable: !0,
    },
    geometryChangedFilter: {
      configurable: !0,
    },
  };
(Ib.prototype.isGeometryCollection = function () {
  return this.getSortIndex() === Ib.SORTINDEX_GEOMETRYCOLLECTION;
}),
  (Ib.prototype.getFactory = function () {
    return this._factory;
  }),
  (Ib.prototype.getGeometryN = function (t) {
    return this;
  }),
  (Ib.prototype.getArea = function () {
    return 0;
  }),
  (Ib.prototype.isRectangle = function () {
    return !1;
  }),
  (Ib.prototype.equals = function () {
    if (arguments[0] instanceof Ib) {
      var t = arguments[0];
      return null !== t && this.equalsTopo(t);
    }
    if (arguments[0] instanceof Object) {
      var e = arguments[0];
      if (!(e instanceof Ib)) return !1;
      var i = e;
      return this.equalsExact(i);
    }
  }),
  (Ib.prototype.equalsExact = function (t) {
    return this === t || this.equalsExact(t, 0);
  }),
  (Ib.prototype.geometryChanged = function () {
    this.apply(Ib.geometryChangedFilter);
  }),
  (Ib.prototype.geometryChangedAction = function () {
    this._envelope = null;
  }),
  (Ib.prototype.equalsNorm = function (t) {
    return null !== t && this.norm().equalsExact(t.norm());
  }),
  (Ib.prototype.getLength = function () {
    return 0;
  }),
  (Ib.prototype.getNumGeometries = function () {
    return 1;
  }),
  (Ib.prototype.compareTo = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = t;
      return this.getSortIndex() !== e.getSortIndex()
        ? this.getSortIndex() - e.getSortIndex()
        : this.isEmpty() && e.isEmpty()
        ? 0
        : this.isEmpty()
        ? -1
        : e.isEmpty()
        ? 1
        : this.compareToSameClass(t);
    }
    if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      return this.getSortIndex() !== i.getSortIndex()
        ? this.getSortIndex() - i.getSortIndex()
        : this.isEmpty() && i.isEmpty()
        ? 0
        : this.isEmpty()
        ? -1
        : i.isEmpty()
        ? 1
        : this.compareToSameClass(i, n);
    }
  }),
  (Ib.prototype.getUserData = function () {
    return this._userData;
  }),
  (Ib.prototype.getSRID = function () {
    return this._SRID;
  }),
  (Ib.prototype.getEnvelope = function () {
    return this.getFactory().toGeometry(this.getEnvelopeInternal());
  }),
  (Ib.prototype.checkNotGeometryCollection = function (t) {
    if (t.getSortIndex() === Ib.SORTINDEX_GEOMETRYCOLLECTION)
      throw new Bv("This method does not support GeometryCollection arguments");
  }),
  (Ib.prototype.equal = function (t, e, i) {
    return 0 === i ? t.equals(e) : t.distance(e) <= i;
  }),
  (Ib.prototype.norm = function () {
    var t = this.copy();
    return t.normalize(), t;
  }),
  (Ib.prototype.getPrecisionModel = function () {
    return this._factory.getPrecisionModel();
  }),
  (Ib.prototype.getEnvelopeInternal = function () {
    return (
      null === this._envelope &&
        (this._envelope = this.computeEnvelopeInternal()),
      new fb(this._envelope)
    );
  }),
  (Ib.prototype.setSRID = function (t) {
    this._SRID = t;
  }),
  (Ib.prototype.setUserData = function (t) {
    this._userData = t;
  }),
  (Ib.prototype.compare = function (t, e) {
    for (var i = t.iterator(), n = e.iterator(); i.hasNext() && n.hasNext(); ) {
      var r = i.next(),
        o = n.next(),
        a = r.compareTo(o);
      if (0 !== a) return a;
    }
    return i.hasNext() ? 1 : n.hasNext() ? -1 : 0;
  }),
  (Ib.prototype.hashCode = function () {
    return this.getEnvelopeInternal().hashCode();
  }),
  (Ib.prototype.isGeometryCollectionOrDerived = function () {
    return (
      this.getSortIndex() === Ib.SORTINDEX_GEOMETRYCOLLECTION ||
      this.getSortIndex() === Ib.SORTINDEX_MULTIPOINT ||
      this.getSortIndex() === Ib.SORTINDEX_MULTILINESTRING ||
      this.getSortIndex() === Ib.SORTINDEX_MULTIPOLYGON
    );
  }),
  (Ib.prototype.interfaces_ = function () {
    return [Hv, jv, Wv];
  }),
  (Ib.prototype.getClass = function () {
    return Ib;
  }),
  (Ib.hasNonEmptyElements = function (t) {
    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
    return !1;
  }),
  (Ib.hasNullElements = function (t) {
    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;
    return !1;
  }),
  (Nb.serialVersionUID.get = function () {
    return 0x799ea46522854c00;
  }),
  (Nb.SORTINDEX_POINT.get = function () {
    return 0;
  }),
  (Nb.SORTINDEX_MULTIPOINT.get = function () {
    return 1;
  }),
  (Nb.SORTINDEX_LINESTRING.get = function () {
    return 2;
  }),
  (Nb.SORTINDEX_LINEARRING.get = function () {
    return 3;
  }),
  (Nb.SORTINDEX_MULTILINESTRING.get = function () {
    return 4;
  }),
  (Nb.SORTINDEX_POLYGON.get = function () {
    return 5;
  }),
  (Nb.SORTINDEX_MULTIPOLYGON.get = function () {
    return 6;
  }),
  (Nb.SORTINDEX_GEOMETRYCOLLECTION.get = function () {
    return 7;
  }),
  (Nb.geometryChangedFilter.get = function () {
    return Rb;
  }),
  Object.defineProperties(Ib, Nb);
var Rb = function () {};
(Rb.interfaces_ = function () {
  return [Lb];
}),
  (Rb.filter = function (t) {
    t.geometryChangedAction();
  });
var Ob = function () {};
(Ob.prototype.filter = function (t) {}),
  (Ob.prototype.interfaces_ = function () {
    return [];
  }),
  (Ob.prototype.getClass = function () {
    return Ob;
  });
var Fb = function () {},
  zb = {
    Mod2BoundaryNodeRule: {
      configurable: !0,
    },
    EndPointBoundaryNodeRule: {
      configurable: !0,
    },
    MultiValentEndPointBoundaryNodeRule: {
      configurable: !0,
    },
    MonoValentEndPointBoundaryNodeRule: {
      configurable: !0,
    },
    MOD2_BOUNDARY_RULE: {
      configurable: !0,
    },
    ENDPOINT_BOUNDARY_RULE: {
      configurable: !0,
    },
    MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {
      configurable: !0,
    },
    MONOVALENT_ENDPOINT_BOUNDARY_RULE: {
      configurable: !0,
    },
    OGC_SFS_BOUNDARY_RULE: {
      configurable: !0,
    },
  };
(Fb.prototype.isInBoundary = function (t) {}),
  (Fb.prototype.interfaces_ = function () {
    return [];
  }),
  (Fb.prototype.getClass = function () {
    return Fb;
  }),
  (zb.Mod2BoundaryNodeRule.get = function () {
    return kb;
  }),
  (zb.EndPointBoundaryNodeRule.get = function () {
    return Bb;
  }),
  (zb.MultiValentEndPointBoundaryNodeRule.get = function () {
    return Gb;
  }),
  (zb.MonoValentEndPointBoundaryNodeRule.get = function () {
    return Ub;
  }),
  (zb.MOD2_BOUNDARY_RULE.get = function () {
    return new kb();
  }),
  (zb.ENDPOINT_BOUNDARY_RULE.get = function () {
    return new Bb();
  }),
  (zb.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
    return new Gb();
  }),
  (zb.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {
    return new Ub();
  }),
  (zb.OGC_SFS_BOUNDARY_RULE.get = function () {
    return Fb.MOD2_BOUNDARY_RULE;
  }),
  Object.defineProperties(Fb, zb);
var kb = function () {};
(kb.prototype.isInBoundary = function (t) {
  return t % 2 == 1;
}),
  (kb.prototype.interfaces_ = function () {
    return [Fb];
  }),
  (kb.prototype.getClass = function () {
    return kb;
  });
var Bb = function () {};
(Bb.prototype.isInBoundary = function (t) {
  return t > 0;
}),
  (Bb.prototype.interfaces_ = function () {
    return [Fb];
  }),
  (Bb.prototype.getClass = function () {
    return Bb;
  });
var Gb = function () {};
(Gb.prototype.isInBoundary = function (t) {
  return t > 1;
}),
  (Gb.prototype.interfaces_ = function () {
    return [Fb];
  }),
  (Gb.prototype.getClass = function () {
    return Gb;
  });
var Ub = function () {};
(Ub.prototype.isInBoundary = function (t) {
  return 1 === t;
}),
  (Ub.prototype.interfaces_ = function () {
    return [Fb];
  }),
  (Ub.prototype.getClass = function () {
    return Ub;
  });
var jb = function () {};
function Hb(t) {
  this.message = t || "";
}
(jb.prototype.add = function () {}),
  (jb.prototype.addAll = function () {}),
  (jb.prototype.isEmpty = function () {}),
  (jb.prototype.iterator = function () {}),
  (jb.prototype.size = function () {}),
  (jb.prototype.toArray = function () {}),
  (jb.prototype.remove = function () {}),
  (Hb.prototype = new Error()),
  (Hb.prototype.name = "IndexOutOfBoundsException");
var Vb = function () {};
(Vb.prototype.hasNext = function () {}),
  (Vb.prototype.next = function () {}),
  (Vb.prototype.remove = function () {});
var Wb = (function (t) {
  function e() {
    t.apply(this, arguments);
  }
  return (
    t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e),
    (e.prototype.get = function () {}),
    (e.prototype.set = function () {}),
    (e.prototype.isEmpty = function () {}),
    e
  );
})(jb);
function qb(t) {
  this.message = t || "";
}
(qb.prototype = new Error()), (qb.prototype.name = "NoSuchElementException");
var Yb = (function (t) {
    function e() {
      t.call(this),
        (this.array_ = []),
        arguments[0] instanceof jb && this.addAll(arguments[0]);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.ensureCapacity = function () {}),
      (e.prototype.interfaces_ = function () {
        return [t, jb];
      }),
      (e.prototype.add = function (t) {
        return (
          1 === arguments.length
            ? this.array_.push(t)
            : this.array_.splice(arguments[0], arguments[1]),
          !0
        );
      }),
      (e.prototype.clear = function () {
        this.array_ = [];
      }),
      (e.prototype.addAll = function (t) {
        for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
        return !0;
      }),
      (e.prototype.set = function (t, e) {
        var i = this.array_[t];
        return (this.array_[t] = e), i;
      }),
      (e.prototype.iterator = function () {
        return new Xb(this);
      }),
      (e.prototype.get = function (t) {
        if (t < 0 || t >= this.size()) throw new Hb();
        return this.array_[t];
      }),
      (e.prototype.isEmpty = function () {
        return 0 === this.array_.length;
      }),
      (e.prototype.size = function () {
        return this.array_.length;
      }),
      (e.prototype.toArray = function () {
        for (var t = [], e = 0, i = this.array_.length; e < i; e++)
          t.push(this.array_[e]);
        return t;
      }),
      (e.prototype.remove = function (t) {
        for (var e = !1, i = 0, n = this.array_.length; i < n; i++)
          if (this.array_[i] === t) {
            this.array_.splice(i, 1), (e = !0);
            break;
          }
        return e;
      }),
      e
    );
  })(Wb),
  Xb = (function (t) {
    function e(e) {
      t.call(this), (this.arrayList_ = e), (this.position_ = 0);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.next = function () {
        if (this.position_ === this.arrayList_.size()) throw new qb();
        return this.arrayList_.get(this.position_++);
      }),
      (e.prototype.hasNext = function () {
        return this.position_ < this.arrayList_.size();
      }),
      (e.prototype.set = function (t) {
        return this.arrayList_.set(this.position_ - 1, t);
      }),
      (e.prototype.remove = function () {
        this.arrayList_.remove(this.arrayList_.get(this.position_));
      }),
      e
    );
  })(Vb),
  Qb = (function (t) {
    function e() {
      if ((t.call(this), 0 === arguments.length));
      else if (1 === arguments.length) {
        var e = arguments[0];
        this.ensureCapacity(e.length), this.add(e, !0);
      } else if (2 === arguments.length) {
        var i = arguments[0],
          n = arguments[1];
        this.ensureCapacity(i.length), this.add(i, n);
      }
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      coordArrayType: {
        configurable: !0,
      },
    };
    return (
      (i.coordArrayType.get = function () {
        return new Array(0).fill(null);
      }),
      (e.prototype.getCoordinate = function (t) {
        return this.get(t);
      }),
      (e.prototype.addAll = function () {
        if (2 === arguments.length) {
          for (
            var e = arguments[1], i = !1, n = arguments[0].iterator();
            n.hasNext();

          )
            this.add(n.next(), e), (i = !0);
          return i;
        }
        return t.prototype.addAll.apply(this, arguments);
      }),
      (e.prototype.clone = function () {
        for (var e = t.prototype.clone.call(this), i = 0; i < this.size(); i++)
          e.add(i, this.get(i).copy());
        return e;
      }),
      (e.prototype.toCoordinateArray = function () {
        return this.toArray(e.coordArrayType);
      }),
      (e.prototype.add = function () {
        var e = this;
        if (1 === arguments.length) {
          var i = arguments[0];
          t.prototype.add.call(this, i);
        } else if (2 === arguments.length) {
          if (
            arguments[0] instanceof Array &&
            "boolean" == typeof arguments[1]
          ) {
            var n = arguments[0],
              r = arguments[1];
            return this.add(n, r, !0), !0;
          }
          if (arguments[0] instanceof qv && "boolean" == typeof arguments[1]) {
            var o = arguments[0];
            if (!arguments[1])
              if (this.size() >= 1)
                if (this.get(this.size() - 1).equals2D(o)) return null;
            t.prototype.add.call(this, o);
          } else if (
            arguments[0] instanceof Object &&
            "boolean" == typeof arguments[1]
          ) {
            var a = arguments[0],
              s = arguments[1];
            return this.add(a, s), !0;
          }
        } else if (3 === arguments.length) {
          if (
            "boolean" == typeof arguments[2] &&
            arguments[0] instanceof Array &&
            "boolean" == typeof arguments[1]
          ) {
            var l = arguments[0],
              u = arguments[1];
            if (arguments[2]) for (var c = 0; c < l.length; c++) e.add(l[c], u);
            else for (var h = l.length - 1; h >= 0; h--) e.add(l[h], u);
            return !0;
          }
          if (
            "boolean" == typeof arguments[2] &&
            Number.isInteger(arguments[0]) &&
            arguments[1] instanceof qv
          ) {
            var p = arguments[0],
              d = arguments[1];
            if (!arguments[2]) {
              var f = this.size();
              if (f > 0) {
                if (p > 0) if (this.get(p - 1).equals2D(d)) return null;
                if (p < f) if (this.get(p).equals2D(d)) return null;
              }
            }
            t.prototype.add.call(this, p, d);
          }
        } else if (4 === arguments.length) {
          var g = arguments[0],
            m = arguments[1],
            y = arguments[2],
            v = arguments[3],
            b = 1;
          y > v && (b = -1);
          for (var x = y; x !== v; x += b) e.add(g[x], m);
          return !0;
        }
      }),
      (e.prototype.closeRing = function () {
        this.size() > 0 && this.add(new qv(this.get(0)), !1);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Yb),
  Zb = function () {},
  Jb = {
    ForwardComparator: {
      configurable: !0,
    },
    BidirectionalComparator: {
      configurable: !0,
    },
    coordArrayType: {
      configurable: !0,
    },
  };
(Jb.ForwardComparator.get = function () {
  return Kb;
}),
  (Jb.BidirectionalComparator.get = function () {
    return $b;
  }),
  (Jb.coordArrayType.get = function () {
    return new Array(0).fill(null);
  }),
  (Zb.prototype.interfaces_ = function () {
    return [];
  }),
  (Zb.prototype.getClass = function () {
    return Zb;
  }),
  (Zb.isRing = function (t) {
    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);
  }),
  (Zb.ptNotInList = function (t, e) {
    for (var i = 0; i < t.length; i++) {
      var n = t[i];
      if (Zb.indexOf(n, e) < 0) return n;
    }
    return null;
  }),
  (Zb.scroll = function (t, e) {
    var i = Zb.indexOf(e, t);
    if (i < 0) return null;
    var n = new Array(t.length).fill(null);
    pb.arraycopy(t, i, n, 0, t.length - i),
      pb.arraycopy(t, 0, n, t.length - i, i),
      pb.arraycopy(n, 0, t, 0, t.length);
  }),
  (Zb.equals = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      if (t === e) return !0;
      if (null === t || null === e) return !1;
      if (t.length !== e.length) return !1;
      for (var i = 0; i < t.length; i++) if (!t[i].equals(e[i])) return !1;
      return !0;
    }
    if (3 === arguments.length) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2];
      if (n === r) return !0;
      if (null === n || null === r) return !1;
      if (n.length !== r.length) return !1;
      for (var a = 0; a < n.length; a++)
        if (0 !== o.compare(n[a], r[a])) return !1;
      return !0;
    }
  }),
  (Zb.intersection = function (t, e) {
    for (var i = new Qb(), n = 0; n < t.length; n++)
      e.intersects(t[n]) && i.add(t[n], !0);
    return i.toCoordinateArray();
  }),
  (Zb.hasRepeatedPoints = function (t) {
    for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
    return !1;
  }),
  (Zb.removeRepeatedPoints = function (t) {
    return Zb.hasRepeatedPoints(t) ? new Qb(t, !1).toCoordinateArray() : t;
  }),
  (Zb.reverse = function (t) {
    for (var e = t.length - 1, i = Math.trunc(e / 2), n = 0; n <= i; n++) {
      var r = t[n];
      (t[n] = t[e - n]), (t[e - n] = r);
    }
  }),
  (Zb.removeNull = function (t) {
    for (var e = 0, i = 0; i < t.length; i++) null !== t[i] && e++;
    var n = new Array(e).fill(null);
    if (0 === e) return n;
    for (var r = 0, o = 0; o < t.length; o++) null !== t[o] && (n[r++] = t[o]);
    return n;
  }),
  (Zb.copyDeep = function () {
    if (1 === arguments.length) {
      for (
        var t = arguments[0], e = new Array(t.length).fill(null), i = 0;
        i < t.length;
        i++
      )
        e[i] = new qv(t[i]);
      return e;
    }
    if (5 === arguments.length)
      for (
        var n = arguments[0],
          r = arguments[1],
          o = arguments[2],
          a = arguments[3],
          s = arguments[4],
          l = 0;
        l < s;
        l++
      )
        o[a + l] = new qv(n[r + l]);
  }),
  (Zb.isEqualReversed = function (t, e) {
    for (var i = 0; i < t.length; i++) {
      var n = t[i],
        r = e[t.length - i - 1];
      if (0 !== n.compareTo(r)) return !1;
    }
    return !0;
  }),
  (Zb.envelope = function (t) {
    for (var e = new fb(), i = 0; i < t.length; i++) e.expandToInclude(t[i]);
    return e;
  }),
  (Zb.toCoordinateArray = function (t) {
    return t.toArray(Zb.coordArrayType);
  }),
  (Zb.atLeastNCoordinatesOrNothing = function (t, e) {
    return e.length >= t ? e : [];
  }),
  (Zb.indexOf = function (t, e) {
    for (var i = 0; i < e.length; i++) if (t.equals(e[i])) return i;
    return -1;
  }),
  (Zb.increasingDirection = function (t) {
    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
      var i = t.length - 1 - e,
        n = t[e].compareTo(t[i]);
      if (0 !== n) return n;
    }
    return 1;
  }),
  (Zb.compare = function (t, e) {
    for (var i = 0; i < t.length && i < e.length; ) {
      var n = t[i].compareTo(e[i]);
      if (0 !== n) return n;
      i++;
    }
    return i < e.length ? -1 : i < t.length ? 1 : 0;
  }),
  (Zb.minCoordinate = function (t) {
    for (var e = null, i = 0; i < t.length; i++)
      (null === e || e.compareTo(t[i]) > 0) && (e = t[i]);
    return e;
  }),
  (Zb.extract = function (t, e, i) {
    e = $v.clamp(e, 0, t.length);
    var n = (i = $v.clamp(i, -1, t.length)) - e + 1;
    i < 0 && (n = 0), e >= t.length && (n = 0), i < e && (n = 0);
    var r = new Array(n).fill(null);
    if (0 === n) return r;
    for (var o = 0, a = e; a <= i; a++) r[o++] = t[a];
    return r;
  }),
  Object.defineProperties(Zb, Jb);
var Kb = function () {};
(Kb.prototype.compare = function (t, e) {
  return Zb.compare(t, e);
}),
  (Kb.prototype.interfaces_ = function () {
    return [Vv];
  }),
  (Kb.prototype.getClass = function () {
    return Kb;
  });
var $b = function () {};
($b.prototype.compare = function (t, e) {
  var i = t,
    n = e;
  if (i.length < n.length) return -1;
  if (i.length > n.length) return 1;
  if (0 === i.length) return 0;
  var r = Zb.compare(i, n);
  return Zb.isEqualReversed(i, n) ? 0 : r;
}),
  ($b.prototype.OLDcompare = function (t, e) {
    var i = t,
      n = e;
    if (i.length < n.length) return -1;
    if (i.length > n.length) return 1;
    if (0 === i.length) return 0;
    for (
      var r = Zb.increasingDirection(i),
        o = Zb.increasingDirection(n),
        a = r > 0 ? 0 : i.length - 1,
        s = o > 0 ? 0 : i.length - 1,
        l = 0;
      l < i.length;
      l++
    ) {
      var u = i[a].compareTo(n[s]);
      if (0 !== u) return u;
      (a += r), (s += o);
    }
    return 0;
  }),
  ($b.prototype.interfaces_ = function () {
    return [Vv];
  }),
  ($b.prototype.getClass = function () {
    return $b;
  });
var tx = function () {};
(tx.prototype.get = function () {}),
  (tx.prototype.put = function () {}),
  (tx.prototype.size = function () {}),
  (tx.prototype.values = function () {}),
  (tx.prototype.entrySet = function () {});
var ex = (function (t) {
  function e() {
    t.apply(this, arguments);
  }
  return (
    t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e),
    e
  );
})(tx);
function ix(t) {
  this.message = t || "";
}
function nx() {}
(ix.prototype = new Error()),
  (ix.prototype.name = "OperationNotSupported"),
  (nx.prototype = new jb()),
  (nx.prototype.contains = function () {});
var rx = (function (t) {
    function e() {
      t.call(this),
        (this.array_ = []),
        arguments[0] instanceof jb && this.addAll(arguments[0]);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.contains = function (t) {
        for (var e = 0, i = this.array_.length; e < i; e++) {
          if (this.array_[e] === t) return !0;
        }
        return !1;
      }),
      (e.prototype.add = function (t) {
        return !this.contains(t) && (this.array_.push(t), !0);
      }),
      (e.prototype.addAll = function (t) {
        for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
        return !0;
      }),
      (e.prototype.remove = function (t) {
        throw new Error();
      }),
      (e.prototype.size = function () {
        return this.array_.length;
      }),
      (e.prototype.isEmpty = function () {
        return 0 === this.array_.length;
      }),
      (e.prototype.toArray = function () {
        for (var t = [], e = 0, i = this.array_.length; e < i; e++)
          t.push(this.array_[e]);
        return t;
      }),
      (e.prototype.iterator = function () {
        return new ox(this);
      }),
      e
    );
  })(nx),
  ox = (function (t) {
    function e(e) {
      t.call(this), (this.hashSet_ = e), (this.position_ = 0);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.next = function () {
        if (this.position_ === this.hashSet_.size()) throw new qb();
        return this.hashSet_.array_[this.position_++];
      }),
      (e.prototype.hasNext = function () {
        return this.position_ < this.hashSet_.size();
      }),
      (e.prototype.remove = function () {
        throw new ix();
      }),
      e
    );
  })(Vb);
function ax(t) {
  return null === t ? 0 : t.color;
}
function sx(t) {
  return null === t ? null : t.parent;
}
function lx(t, e) {
  null !== t && (t.color = e);
}
function ux(t) {
  return null === t ? null : t.left;
}
function cx(t) {
  return null === t ? null : t.right;
}
function hx() {
  (this.root_ = null), (this.size_ = 0);
}
(hx.prototype = new ex()),
  (hx.prototype.get = function (t) {
    for (var e = this.root_; null !== e; ) {
      var i = t.compareTo(e.key);
      if (i < 0) e = e.left;
      else {
        if (!(i > 0)) return e.value;
        e = e.right;
      }
    }
    return null;
  }),
  (hx.prototype.put = function (t, e) {
    if (null === this.root_)
      return (
        (this.root_ = {
          key: t,
          value: e,
          left: null,
          right: null,
          parent: null,
          color: 0,
          getValue: function () {
            return this.value;
          },
          getKey: function () {
            return this.key;
          },
        }),
        (this.size_ = 1),
        null
      );
    var i,
      n,
      r = this.root_;
    do {
      if (((i = r), (n = t.compareTo(r.key)) < 0)) r = r.left;
      else {
        if (!(n > 0)) {
          var o = r.value;
          return (r.value = e), o;
        }
        r = r.right;
      }
    } while (null !== r);
    var a = {
      key: t,
      left: null,
      right: null,
      value: e,
      parent: i,
      color: 0,
      getValue: function () {
        return this.value;
      },
      getKey: function () {
        return this.key;
      },
    };
    return (
      n < 0 ? (i.left = a) : (i.right = a),
      this.fixAfterInsertion(a),
      this.size_++,
      null
    );
  }),
  (hx.prototype.fixAfterInsertion = function (t) {
    var e = this;
    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color; )
      if (sx(t) === ux(sx(sx(t)))) {
        var i = cx(sx(sx(t)));
        1 === ax(i)
          ? (lx(sx(t), 0), lx(i, 0), lx(sx(sx(t)), 1), (t = sx(sx(t))))
          : (t === cx(sx(t)) && ((t = sx(t)), e.rotateLeft(t)),
            lx(sx(t), 0),
            lx(sx(sx(t)), 1),
            e.rotateRight(sx(sx(t))));
      } else {
        var n = ux(sx(sx(t)));
        1 === ax(n)
          ? (lx(sx(t), 0), lx(n, 0), lx(sx(sx(t)), 1), (t = sx(sx(t))))
          : (t === ux(sx(t)) && ((t = sx(t)), e.rotateRight(t)),
            lx(sx(t), 0),
            lx(sx(sx(t)), 1),
            e.rotateLeft(sx(sx(t))));
      }
    this.root_.color = 0;
  }),
  (hx.prototype.values = function () {
    var t = new Yb(),
      e = this.getFirstEntry();
    if (null !== e)
      for (t.add(e.value); null !== (e = hx.successor(e)); ) t.add(e.value);
    return t;
  }),
  (hx.prototype.entrySet = function () {
    var t = new rx(),
      e = this.getFirstEntry();
    if (null !== e) for (t.add(e); null !== (e = hx.successor(e)); ) t.add(e);
    return t;
  }),
  (hx.prototype.rotateLeft = function (t) {
    if (null != t) {
      var e = t.right;
      (t.right = e.left),
        null != e.left && (e.left.parent = t),
        (e.parent = t.parent),
        null === t.parent
          ? (this.root_ = e)
          : t.parent.left === t
          ? (t.parent.left = e)
          : (t.parent.right = e),
        (e.left = t),
        (t.parent = e);
    }
  }),
  (hx.prototype.rotateRight = function (t) {
    if (null != t) {
      var e = t.left;
      (t.left = e.right),
        null != e.right && (e.right.parent = t),
        (e.parent = t.parent),
        null === t.parent
          ? (this.root_ = e)
          : t.parent.right === t
          ? (t.parent.right = e)
          : (t.parent.left = e),
        (e.right = t),
        (t.parent = e);
    }
  }),
  (hx.prototype.getFirstEntry = function () {
    var t = this.root_;
    if (null != t) for (; null != t.left; ) t = t.left;
    return t;
  }),
  (hx.successor = function (t) {
    if (null === t) return null;
    if (null !== t.right) {
      for (var e = t.right; null !== e.left; ) e = e.left;
      return e;
    }
    for (var i = t.parent, n = t; null !== i && n === i.right; )
      (n = i), (i = i.parent);
    return i;
  }),
  (hx.prototype.size = function () {
    return this.size_;
  });
var px = function () {};
function dx() {}
function fx() {
  (this.array_ = []), arguments[0] instanceof jb && this.addAll(arguments[0]);
}
(px.prototype.interfaces_ = function () {
  return [];
}),
  (px.prototype.getClass = function () {
    return px;
  }),
  (dx.prototype = new nx()),
  (fx.prototype = new dx()),
  (fx.prototype.contains = function (t) {
    for (var e = 0, i = this.array_.length; e < i; e++) {
      if (0 === this.array_[e].compareTo(t)) return !0;
    }
    return !1;
  }),
  (fx.prototype.add = function (t) {
    if (this.contains(t)) return !1;
    for (var e = 0, i = this.array_.length; e < i; e++) {
      if (1 === this.array_[e].compareTo(t))
        return this.array_.splice(e, 0, t), !0;
    }
    return this.array_.push(t), !0;
  }),
  (fx.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
    return !0;
  }),
  (fx.prototype.remove = function (t) {
    throw new ix();
  }),
  (fx.prototype.size = function () {
    return this.array_.length;
  }),
  (fx.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }),
  (fx.prototype.toArray = function () {
    for (var t = [], e = 0, i = this.array_.length; e < i; e++)
      t.push(this.array_[e]);
    return t;
  }),
  (fx.prototype.iterator = function () {
    return new gx(this);
  });
var gx = function (t) {
  (this.treeSet_ = t), (this.position_ = 0);
};
(gx.prototype.next = function () {
  if (this.position_ === this.treeSet_.size()) throw new qb();
  return this.treeSet_.array_[this.position_++];
}),
  (gx.prototype.hasNext = function () {
    return this.position_ < this.treeSet_.size();
  }),
  (gx.prototype.remove = function () {
    throw new ix();
  });
var mx = function () {};
(mx.sort = function () {
  var t,
    e,
    i,
    n,
    r = arguments[0];
  if (1 === arguments.length)
    (n = function (t, e) {
      return t.compareTo(e);
    }),
      r.sort(n);
  else if (2 === arguments.length)
    (i = arguments[1]),
      (n = function (t, e) {
        return i.compare(t, e);
      }),
      r.sort(n);
  else if (3 === arguments.length) {
    (e = r.slice(arguments[1], arguments[2])).sort();
    var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));
    for (r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);
  } else if (4 === arguments.length)
    for (
      e = r.slice(arguments[1], arguments[2]),
        i = arguments[3],
        n = function (t, e) {
          return i.compare(t, e);
        },
        e.sort(n),
        o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)),
        r.splice(0, r.length),
        t = 0;
      t < o.length;
      t++
    )
      r.push(o[t]);
}),
  (mx.asList = function (t) {
    for (var e = new Yb(), i = 0, n = t.length; i < n; i++) e.add(t[i]);
    return e;
  });
var yx = function () {},
  vx = {
    P: {
      configurable: !0,
    },
    L: {
      configurable: !0,
    },
    A: {
      configurable: !0,
    },
    FALSE: {
      configurable: !0,
    },
    TRUE: {
      configurable: !0,
    },
    DONTCARE: {
      configurable: !0,
    },
    SYM_FALSE: {
      configurable: !0,
    },
    SYM_TRUE: {
      configurable: !0,
    },
    SYM_DONTCARE: {
      configurable: !0,
    },
    SYM_P: {
      configurable: !0,
    },
    SYM_L: {
      configurable: !0,
    },
    SYM_A: {
      configurable: !0,
    },
  };
(vx.P.get = function () {
  return 0;
}),
  (vx.L.get = function () {
    return 1;
  }),
  (vx.A.get = function () {
    return 2;
  }),
  (vx.FALSE.get = function () {
    return -1;
  }),
  (vx.TRUE.get = function () {
    return -2;
  }),
  (vx.DONTCARE.get = function () {
    return -3;
  }),
  (vx.SYM_FALSE.get = function () {
    return "F";
  }),
  (vx.SYM_TRUE.get = function () {
    return "T";
  }),
  (vx.SYM_DONTCARE.get = function () {
    return "*";
  }),
  (vx.SYM_P.get = function () {
    return "0";
  }),
  (vx.SYM_L.get = function () {
    return "1";
  }),
  (vx.SYM_A.get = function () {
    return "2";
  }),
  (yx.prototype.interfaces_ = function () {
    return [];
  }),
  (yx.prototype.getClass = function () {
    return yx;
  }),
  (yx.toDimensionSymbol = function (t) {
    switch (t) {
      case yx.FALSE:
        return yx.SYM_FALSE;
      case yx.TRUE:
        return yx.SYM_TRUE;
      case yx.DONTCARE:
        return yx.SYM_DONTCARE;
      case yx.P:
        return yx.SYM_P;
      case yx.L:
        return yx.SYM_L;
      case yx.A:
        return yx.SYM_A;
    }
    throw new Bv("Unknown dimension value: " + t);
  }),
  (yx.toDimensionValue = function (t) {
    switch (nb.toUpperCase(t)) {
      case yx.SYM_FALSE:
        return yx.FALSE;
      case yx.SYM_TRUE:
        return yx.TRUE;
      case yx.SYM_DONTCARE:
        return yx.DONTCARE;
      case yx.SYM_P:
        return yx.P;
      case yx.SYM_L:
        return yx.L;
      case yx.SYM_A:
        return yx.A;
    }
    throw new Bv("Unknown dimension symbol: " + t);
  }),
  Object.defineProperties(yx, vx);
var bx = function () {};
(bx.prototype.filter = function (t) {}),
  (bx.prototype.interfaces_ = function () {
    return [];
  }),
  (bx.prototype.getClass = function () {
    return bx;
  });
var xx = function () {};
(xx.prototype.filter = function (t, e) {}),
  (xx.prototype.isDone = function () {}),
  (xx.prototype.isGeometryChanged = function () {}),
  (xx.prototype.interfaces_ = function () {
    return [];
  }),
  (xx.prototype.getClass = function () {
    return xx;
  });
var _x = (function (t) {
    function e(e, i) {
      if (
        (t.call(this, i),
        (this._geometries = e || []),
        t.hasNullElements(this._geometries))
      )
        throw new Bv("geometries must not contain null elements");
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.computeEnvelopeInternal = function () {
        for (var t = new fb(), e = 0; e < this._geometries.length; e++)
          t.expandToInclude(this._geometries[e].getEnvelopeInternal());
        return t;
      }),
      (e.prototype.getGeometryN = function (t) {
        return this._geometries[t];
      }),
      (e.prototype.getSortIndex = function () {
        return t.SORTINDEX_GEOMETRYCOLLECTION;
      }),
      (e.prototype.getCoordinates = function () {
        for (
          var t = new Array(this.getNumPoints()).fill(null), e = -1, i = 0;
          i < this._geometries.length;
          i++
        )
          for (
            var n = this._geometries[i].getCoordinates(), r = 0;
            r < n.length;
            r++
          )
            t[++e] = n[r];
        return t;
      }),
      (e.prototype.getArea = function () {
        for (var t = 0, e = 0; e < this._geometries.length; e++)
          t += this._geometries[e].getArea();
        return t;
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          if (!this.isEquivalentClass(e)) return !1;
          var n = e;
          if (this._geometries.length !== n._geometries.length) return !1;
          for (var r = 0; r < this._geometries.length; r++)
            if (!this._geometries[r].equalsExact(n._geometries[r], i))
              return !1;
          return !0;
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.normalize = function () {
        for (var t = 0; t < this._geometries.length; t++)
          this._geometries[t].normalize();
        mx.sort(this._geometries);
      }),
      (e.prototype.getCoordinate = function () {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate();
      }),
      (e.prototype.getBoundaryDimension = function () {
        for (var t = yx.FALSE, e = 0; e < this._geometries.length; e++)
          t = Math.max(t, this._geometries[e].getBoundaryDimension());
        return t;
      }),
      (e.prototype.getDimension = function () {
        for (var t = yx.FALSE, e = 0; e < this._geometries.length; e++)
          t = Math.max(t, this._geometries[e].getDimension());
        return t;
      }),
      (e.prototype.getLength = function () {
        for (var t = 0, e = 0; e < this._geometries.length; e++)
          t += this._geometries[e].getLength();
        return t;
      }),
      (e.prototype.getNumPoints = function () {
        for (var t = 0, e = 0; e < this._geometries.length; e++)
          t += this._geometries[e].getNumPoints();
        return t;
      }),
      (e.prototype.getNumGeometries = function () {
        return this._geometries.length;
      }),
      (e.prototype.reverse = function () {
        for (
          var t = this._geometries.length, e = new Array(t).fill(null), i = 0;
          i < this._geometries.length;
          i++
        )
          e[i] = this._geometries[i].reverse();
        return this.getFactory().createGeometryCollection(e);
      }),
      (e.prototype.compareToSameClass = function () {
        if (1 === arguments.length) {
          var t = arguments[0],
            e = new fx(mx.asList(this._geometries)),
            i = new fx(mx.asList(t._geometries));
          return this.compare(e, i);
        }
        if (2 === arguments.length) {
          for (
            var n = arguments[1],
              r = arguments[0],
              o = this.getNumGeometries(),
              a = r.getNumGeometries(),
              s = 0;
            s < o && s < a;

          ) {
            var l = this.getGeometryN(s),
              u = r.getGeometryN(s),
              c = l.compareToSameClass(u, n);
            if (0 !== c) return c;
            s++;
          }
          return s < o ? 1 : s < a ? -1 : 0;
        }
      }),
      (e.prototype.apply = function () {
        var t = this;
        if (Kv(arguments[0], Ob))
          for (var e = arguments[0], i = 0; i < this._geometries.length; i++)
            t._geometries[i].apply(e);
        else if (Kv(arguments[0], xx)) {
          var n = arguments[0];
          if (0 === this._geometries.length) return null;
          for (
            var r = 0;
            r < this._geometries.length &&
            (t._geometries[r].apply(n), !n.isDone());
            r++
          );
          n.isGeometryChanged() && this.geometryChanged();
        } else if (Kv(arguments[0], bx)) {
          var o = arguments[0];
          o.filter(this);
          for (var a = 0; a < this._geometries.length; a++)
            t._geometries[a].apply(o);
        } else if (Kv(arguments[0], Lb)) {
          var s = arguments[0];
          s.filter(this);
          for (var l = 0; l < this._geometries.length; l++)
            t._geometries[l].apply(s);
        }
      }),
      (e.prototype.getBoundary = function () {
        return (
          this.checkNotGeometryCollection(this), Mb.shouldNeverReachHere(), null
        );
      }),
      (e.prototype.clone = function () {
        var e = t.prototype.clone.call(this);
        e._geometries = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < this._geometries.length; i++)
          e._geometries[i] = this._geometries[i].clone();
        return e;
      }),
      (e.prototype.getGeometryType = function () {
        return "GeometryCollection";
      }),
      (e.prototype.copy = function () {
        for (
          var t = new Array(this._geometries.length).fill(null), i = 0;
          i < t.length;
          i++
        )
          t[i] = this._geometries[i].copy();
        return new e(t, this._factory);
      }),
      (e.prototype.isEmpty = function () {
        for (var t = 0; t < this._geometries.length; t++)
          if (!this._geometries[t].isEmpty()) return !1;
        return !0;
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return -0x4f07bcb1f857d800;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Ib),
  Sx = (function (t) {
    function e() {
      t.apply(this, arguments);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.getSortIndex = function () {
        return Ib.SORTINDEX_MULTILINESTRING;
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          return (
            !!this.isEquivalentClass(e) &&
            t.prototype.equalsExact.call(this, e, i)
          );
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.getBoundaryDimension = function () {
        return this.isClosed() ? yx.FALSE : 0;
      }),
      (e.prototype.isClosed = function () {
        if (this.isEmpty()) return !1;
        for (var t = 0; t < this._geometries.length; t++)
          if (!this._geometries[t].isClosed()) return !1;
        return !0;
      }),
      (e.prototype.getDimension = function () {
        return 1;
      }),
      (e.prototype.reverse = function () {
        for (
          var t = this._geometries.length, e = new Array(t).fill(null), i = 0;
          i < this._geometries.length;
          i++
        )
          e[t - 1 - i] = this._geometries[i].reverse();
        return this.getFactory().createMultiLineString(e);
      }),
      (e.prototype.getBoundary = function () {
        return new Mx(this).getBoundary();
      }),
      (e.prototype.getGeometryType = function () {
        return "MultiLineString";
      }),
      (e.prototype.copy = function () {
        for (
          var t = new Array(this._geometries.length).fill(null), i = 0;
          i < t.length;
          i++
        )
          t[i] = this._geometries[i].copy();
        return new e(t, this._factory);
      }),
      (e.prototype.interfaces_ = function () {
        return [px];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return 0x7155d2ab4afa8000;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(_x),
  Mx = function () {
    if (
      ((this._geom = null),
      (this._geomFact = null),
      (this._bnRule = null),
      (this._endpointMap = null),
      1 === arguments.length)
    ) {
      var t = arguments[0],
        e = Fb.MOD2_BOUNDARY_RULE;
      (this._geom = t), (this._geomFact = t.getFactory()), (this._bnRule = e);
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      (this._geom = i), (this._geomFact = i.getFactory()), (this._bnRule = n);
    }
  };
(Mx.prototype.boundaryMultiLineString = function (t) {
  if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
  var e = this.computeBoundaryCoordinates(t);
  return 1 === e.length
    ? this._geomFact.createPoint(e[0])
    : this._geomFact.createMultiPointFromCoords(e);
}),
  (Mx.prototype.getBoundary = function () {
    return this._geom instanceof Rx
      ? this.boundaryLineString(this._geom)
      : this._geom instanceof Sx
      ? this.boundaryMultiLineString(this._geom)
      : this._geom.getBoundary();
  }),
  (Mx.prototype.boundaryLineString = function (t) {
    return this._geom.isEmpty()
      ? this.getEmptyMultiPoint()
      : t.isClosed()
      ? this._bnRule.isInBoundary(2)
        ? t.getStartPoint()
        : this._geomFact.createMultiPoint()
      : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
  }),
  (Mx.prototype.getEmptyMultiPoint = function () {
    return this._geomFact.createMultiPoint();
  }),
  (Mx.prototype.computeBoundaryCoordinates = function (t) {
    var e = this,
      i = new Yb();
    this._endpointMap = new hx();
    for (var n = 0; n < t.getNumGeometries(); n++) {
      var r = t.getGeometryN(n);
      0 !== r.getNumPoints() &&
        (e.addEndpoint(r.getCoordinateN(0)),
        e.addEndpoint(r.getCoordinateN(r.getNumPoints() - 1)));
    }
    for (var o = this._endpointMap.entrySet().iterator(); o.hasNext(); ) {
      var a = o.next(),
        s = a.getValue().count;
      e._bnRule.isInBoundary(s) && i.add(a.getKey());
    }
    return Zb.toCoordinateArray(i);
  }),
  (Mx.prototype.addEndpoint = function (t) {
    var e = this._endpointMap.get(t);
    null === e && ((e = new Cx()), this._endpointMap.put(t, e)), e.count++;
  }),
  (Mx.prototype.interfaces_ = function () {
    return [];
  }),
  (Mx.prototype.getClass = function () {
    return Mx;
  }),
  (Mx.getBoundary = function () {
    return 1 === arguments.length
      ? new Mx(arguments[0]).getBoundary()
      : 2 === arguments.length
      ? new Mx(arguments[0], arguments[1]).getBoundary()
      : void 0;
  });
var Cx = function () {
  this.count = null;
};
function wx() {}
function Ax() {}
(Cx.prototype.interfaces_ = function () {
  return [];
}),
  (Cx.prototype.getClass = function () {
    return Cx;
  });
var Ex = function () {};
function Dx() {}
function Tx() {}
function Px() {}
var Lx = function () {},
  Ix = {
    NEWLINE: {
      configurable: !0,
    },
    SIMPLE_ORDINATE_FORMAT: {
      configurable: !0,
    },
  };
(Lx.prototype.interfaces_ = function () {
  return [];
}),
  (Lx.prototype.getClass = function () {
    return Lx;
  }),
  (Lx.chars = function (t, e) {
    for (var i = new Array(e).fill(null), n = 0; n < e; n++) i[n] = t;
    return String(i);
  }),
  (Lx.getStackTrace = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = new Dx(),
        i = new wx();
      return t.printStackTrace(i), e.toString();
    }
    if (2 === arguments.length) {
      var n = arguments[1],
        r = "";
      new Ax(Lx.getStackTrace(arguments[0]));
      for (var o = new Px(), a = 0; a < n; a++)
        try {
          r += o.readLine() + Lx.NEWLINE;
        } catch (s) {
          if (!(s instanceof Tx)) throw s;
          Mb.shouldNeverReachHere();
        }
      return r;
    }
  }),
  (Lx.split = function (t, e) {
    for (
      var i = e.length, n = new Yb(), r = "" + t, o = r.indexOf(e);
      o >= 0;

    ) {
      var a = r.substring(0, o);
      n.add(a), (o = (r = r.substring(o + i)).indexOf(e));
    }
    r.length > 0 && n.add(r);
    for (var s = new Array(n.size()).fill(null), l = 0; l < s.length; l++)
      s[l] = n.get(l);
    return s;
  }),
  (Lx.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return Lx.SIMPLE_ORDINATE_FORMAT.format(t);
    }
  }),
  (Lx.spaces = function (t) {
    return Lx.chars(" ", t);
  }),
  (Ix.NEWLINE.get = function () {
    return pb.getProperty("line.separator");
  }),
  (Ix.SIMPLE_ORDINATE_FORMAT.get = function () {
    return new Ex();
  }),
  Object.defineProperties(Lx, Ix);
var Nx = function () {};
(Nx.prototype.interfaces_ = function () {
  return [];
}),
  (Nx.prototype.getClass = function () {
    return Nx;
  }),
  (Nx.copyCoord = function (t, e, i, n) {
    for (
      var r = Math.min(t.getDimension(), i.getDimension()), o = 0;
      o < r;
      o++
    )
      i.setOrdinate(n, o, t.getOrdinate(e, o));
  }),
  (Nx.isRing = function (t) {
    var e = t.size();
    return (
      0 === e ||
      (!(e <= 3) &&
        t.getOrdinate(0, lb.X) === t.getOrdinate(e - 1, lb.X) &&
        t.getOrdinate(0, lb.Y) === t.getOrdinate(e - 1, lb.Y))
    );
  }),
  (Nx.isEqual = function (t, e) {
    var i = t.size();
    if (i !== e.size()) return !1;
    for (
      var n = Math.min(t.getDimension(), e.getDimension()), r = 0;
      r < i;
      r++
    )
      for (var o = 0; o < n; o++) {
        var a = t.getOrdinate(r, o),
          s = e.getOrdinate(r, o);
        if (
          t.getOrdinate(r, o) !== e.getOrdinate(r, o) &&
          (!Gv.isNaN(a) || !Gv.isNaN(s))
        )
          return !1;
      }
    return !0;
  }),
  (Nx.extend = function (t, e, i) {
    var n = t.create(i, e.getDimension()),
      r = e.size();
    if ((Nx.copy(e, 0, n, 0, r), r > 0))
      for (var o = r; o < i; o++) Nx.copy(e, r - 1, n, o, 1);
    return n;
  }),
  (Nx.reverse = function (t) {
    for (var e = t.size() - 1, i = Math.trunc(e / 2), n = 0; n <= i; n++)
      Nx.swap(t, n, e - n);
  }),
  (Nx.swap = function (t, e, i) {
    if (e === i) return null;
    for (var n = 0; n < t.getDimension(); n++) {
      var r = t.getOrdinate(e, n);
      t.setOrdinate(e, n, t.getOrdinate(i, n)), t.setOrdinate(i, n, r);
    }
  }),
  (Nx.copy = function (t, e, i, n, r) {
    for (var o = 0; o < r; o++) Nx.copyCoord(t, e + o, i, n + o);
  }),
  (Nx.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = t.size();
      if (0 === e) return "()";
      var i = t.getDimension(),
        n = new eb();
      n.append("(");
      for (var r = 0; r < e; r++) {
        r > 0 && n.append(" ");
        for (var o = 0; o < i; o++)
          o > 0 && n.append(","), n.append(Lx.toString(t.getOrdinate(r, o)));
      }
      return n.append(")"), n.toString();
    }
  }),
  (Nx.ensureValidRing = function (t, e) {
    var i = e.size();
    return 0 === i
      ? e
      : i <= 3
      ? Nx.createClosedRing(t, e, 4)
      : e.getOrdinate(0, lb.X) === e.getOrdinate(i - 1, lb.X) &&
        e.getOrdinate(0, lb.Y) === e.getOrdinate(i - 1, lb.Y)
      ? e
      : Nx.createClosedRing(t, e, i + 1);
  }),
  (Nx.createClosedRing = function (t, e, i) {
    var n = t.create(i, e.getDimension()),
      r = e.size();
    Nx.copy(e, 0, n, 0, r);
    for (var o = r; o < i; o++) Nx.copy(e, 0, n, o, 1);
    return n;
  });
var Rx = (function (t) {
    function e(e, i) {
      t.call(this, i), (this._points = null), this.init(e);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.computeEnvelopeInternal = function () {
        return this.isEmpty()
          ? new fb()
          : this._points.expandEnvelope(new fb());
      }),
      (e.prototype.isRing = function () {
        return this.isClosed() && this.isSimple();
      }),
      (e.prototype.getSortIndex = function () {
        return t.SORTINDEX_LINESTRING;
      }),
      (e.prototype.getCoordinates = function () {
        return this._points.toCoordinateArray();
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          if (!this.isEquivalentClass(e)) return !1;
          var n = e;
          if (this._points.size() !== n._points.size()) return !1;
          for (var r = 0; r < this._points.size(); r++)
            if (
              !this.equal(
                this._points.getCoordinate(r),
                n._points.getCoordinate(r),
                i
              )
            )
              return !1;
          return !0;
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.normalize = function () {
        for (
          var t = this, e = 0;
          e < Math.trunc(this._points.size() / 2);
          e++
        ) {
          var i = t._points.size() - 1 - e;
          if (!t._points.getCoordinate(e).equals(t._points.getCoordinate(i)))
            return (
              t._points.getCoordinate(e).compareTo(t._points.getCoordinate(i)) >
                0 && Nx.reverse(t._points),
              null
            );
        }
      }),
      (e.prototype.getCoordinate = function () {
        return this.isEmpty() ? null : this._points.getCoordinate(0);
      }),
      (e.prototype.getBoundaryDimension = function () {
        return this.isClosed() ? yx.FALSE : 0;
      }),
      (e.prototype.isClosed = function () {
        return (
          !this.isEmpty() &&
          this.getCoordinateN(0).equals2D(
            this.getCoordinateN(this.getNumPoints() - 1)
          )
        );
      }),
      (e.prototype.getEndPoint = function () {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      }),
      (e.prototype.getDimension = function () {
        return 1;
      }),
      (e.prototype.getLength = function () {
        return Tb.computeLength(this._points);
      }),
      (e.prototype.getNumPoints = function () {
        return this._points.size();
      }),
      (e.prototype.reverse = function () {
        var t = this._points.copy();
        return Nx.reverse(t), this.getFactory().createLineString(t);
      }),
      (e.prototype.compareToSameClass = function () {
        if (1 === arguments.length) {
          for (
            var t = arguments[0], e = 0, i = 0;
            e < this._points.size() && i < t._points.size();

          ) {
            var n = this._points
              .getCoordinate(e)
              .compareTo(t._points.getCoordinate(i));
            if (0 !== n) return n;
            e++, i++;
          }
          return e < this._points.size() ? 1 : i < t._points.size() ? -1 : 0;
        }
        if (2 === arguments.length) {
          var r = arguments[0];
          return arguments[1].compare(this._points, r._points);
        }
      }),
      (e.prototype.apply = function () {
        if (Kv(arguments[0], Ob))
          for (var t = arguments[0], e = 0; e < this._points.size(); e++)
            t.filter(this._points.getCoordinate(e));
        else if (Kv(arguments[0], xx)) {
          var i = arguments[0];
          if (0 === this._points.size()) return null;
          for (
            var n = 0;
            n < this._points.size() && (i.filter(this._points, n), !i.isDone());
            n++
          );
          i.isGeometryChanged() && this.geometryChanged();
        } else if (Kv(arguments[0], bx)) {
          arguments[0].filter(this);
        } else if (Kv(arguments[0], Lb)) {
          arguments[0].filter(this);
        }
      }),
      (e.prototype.getBoundary = function () {
        return new Mx(this).getBoundary();
      }),
      (e.prototype.isEquivalentClass = function (t) {
        return t instanceof e;
      }),
      (e.prototype.clone = function () {
        var e = t.prototype.clone.call(this);
        return (e._points = this._points.clone()), e;
      }),
      (e.prototype.getCoordinateN = function (t) {
        return this._points.getCoordinate(t);
      }),
      (e.prototype.getGeometryType = function () {
        return "LineString";
      }),
      (e.prototype.copy = function () {
        return new e(this._points.copy(), this._factory);
      }),
      (e.prototype.getCoordinateSequence = function () {
        return this._points;
      }),
      (e.prototype.isEmpty = function () {
        return 0 === this._points.size();
      }),
      (e.prototype.init = function (t) {
        if (
          (null === t &&
            (t = this.getFactory().getCoordinateSequenceFactory().create([])),
          1 === t.size())
        )
          throw new Bv(
            "Invalid number of points in LineString (found " +
              t.size() +
              " - must be 0 or >= 2)"
          );
        this._points = t;
      }),
      (e.prototype.isCoordinate = function (t) {
        for (var e = 0; e < this._points.size(); e++)
          if (this._points.getCoordinate(e).equals(t)) return !0;
        return !1;
      }),
      (e.prototype.getStartPoint = function () {
        return this.isEmpty() ? null : this.getPointN(0);
      }),
      (e.prototype.getPointN = function (t) {
        return this.getFactory().createPoint(this._points.getCoordinate(t));
      }),
      (e.prototype.interfaces_ = function () {
        return [px];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return 0x2b2b51ba435c8e00;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Ib),
  Ox = function () {};
(Ox.prototype.interfaces_ = function () {
  return [];
}),
  (Ox.prototype.getClass = function () {
    return Ox;
  });
var Fx = (function (t) {
    function e(e, i) {
      t.call(this, i),
        (this._coordinates = e || null),
        this.init(this._coordinates);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.computeEnvelopeInternal = function () {
        if (this.isEmpty()) return new fb();
        var t = new fb();
        return (
          t.expandToInclude(
            this._coordinates.getX(0),
            this._coordinates.getY(0)
          ),
          t
        );
      }),
      (e.prototype.getSortIndex = function () {
        return t.SORTINDEX_POINT;
      }),
      (e.prototype.getCoordinates = function () {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          return (
            !!this.isEquivalentClass(e) &&
            (!(!this.isEmpty() || !e.isEmpty()) ||
              (this.isEmpty() === e.isEmpty() &&
                this.equal(e.getCoordinate(), this.getCoordinate(), i)))
          );
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.normalize = function () {}),
      (e.prototype.getCoordinate = function () {
        return 0 !== this._coordinates.size()
          ? this._coordinates.getCoordinate(0)
          : null;
      }),
      (e.prototype.getBoundaryDimension = function () {
        return yx.FALSE;
      }),
      (e.prototype.getDimension = function () {
        return 0;
      }),
      (e.prototype.getNumPoints = function () {
        return this.isEmpty() ? 0 : 1;
      }),
      (e.prototype.reverse = function () {
        return this.copy();
      }),
      (e.prototype.getX = function () {
        if (null === this.getCoordinate())
          throw new Error("getX called on empty Point");
        return this.getCoordinate().x;
      }),
      (e.prototype.compareToSameClass = function () {
        if (1 === arguments.length) {
          var t = arguments[0];
          return this.getCoordinate().compareTo(t.getCoordinate());
        }
        if (2 === arguments.length) {
          var e = arguments[0];
          return arguments[1].compare(this._coordinates, e._coordinates);
        }
      }),
      (e.prototype.apply = function () {
        if (Kv(arguments[0], Ob)) {
          var t = arguments[0];
          if (this.isEmpty()) return null;
          t.filter(this.getCoordinate());
        } else if (Kv(arguments[0], xx)) {
          var e = arguments[0];
          if (this.isEmpty()) return null;
          e.filter(this._coordinates, 0),
            e.isGeometryChanged() && this.geometryChanged();
        } else if (Kv(arguments[0], bx)) {
          arguments[0].filter(this);
        } else if (Kv(arguments[0], Lb)) {
          arguments[0].filter(this);
        }
      }),
      (e.prototype.getBoundary = function () {
        return this.getFactory().createGeometryCollection(null);
      }),
      (e.prototype.clone = function () {
        var e = t.prototype.clone.call(this);
        return (e._coordinates = this._coordinates.clone()), e;
      }),
      (e.prototype.getGeometryType = function () {
        return "Point";
      }),
      (e.prototype.copy = function () {
        return new e(this._coordinates.copy(), this._factory);
      }),
      (e.prototype.getCoordinateSequence = function () {
        return this._coordinates;
      }),
      (e.prototype.getY = function () {
        if (null === this.getCoordinate())
          throw new Error("getY called on empty Point");
        return this.getCoordinate().y;
      }),
      (e.prototype.isEmpty = function () {
        return 0 === this._coordinates.size();
      }),
      (e.prototype.init = function (t) {
        null === t &&
          (t = this.getFactory().getCoordinateSequenceFactory().create([])),
          Mb.isTrue(t.size() <= 1),
          (this._coordinates = t);
      }),
      (e.prototype.isSimple = function () {
        return !0;
      }),
      (e.prototype.interfaces_ = function () {
        return [Ox];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return 0x44077bad161cbc00;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Ib),
  zx = function () {};
(zx.prototype.interfaces_ = function () {
  return [];
}),
  (zx.prototype.getClass = function () {
    return zx;
  });
var kx = (function (t) {
    function e(e, i, n) {
      if (
        (t.call(this, n),
        (this._shell = null),
        (this._holes = null),
        null === e && (e = this.getFactory().createLinearRing()),
        null === i && (i = []),
        t.hasNullElements(i))
      )
        throw new Bv("holes must not contain null elements");
      if (e.isEmpty() && t.hasNonEmptyElements(i))
        throw new Bv("shell is empty but holes are not");
      (this._shell = e), (this._holes = i);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.computeEnvelopeInternal = function () {
        return this._shell.getEnvelopeInternal();
      }),
      (e.prototype.getSortIndex = function () {
        return t.SORTINDEX_POLYGON;
      }),
      (e.prototype.getCoordinates = function () {
        if (this.isEmpty()) return [];
        for (
          var t = new Array(this.getNumPoints()).fill(null),
            e = -1,
            i = this._shell.getCoordinates(),
            n = 0;
          n < i.length;
          n++
        )
          t[++e] = i[n];
        for (var r = 0; r < this._holes.length; r++)
          for (
            var o = this._holes[r].getCoordinates(), a = 0;
            a < o.length;
            a++
          )
            t[++e] = o[a];
        return t;
      }),
      (e.prototype.getArea = function () {
        var t = 0;
        t += Math.abs(Tb.signedArea(this._shell.getCoordinateSequence()));
        for (var e = 0; e < this._holes.length; e++)
          t -= Math.abs(Tb.signedArea(this._holes[e].getCoordinateSequence()));
        return t;
      }),
      (e.prototype.isRectangle = function () {
        if (0 !== this.getNumInteriorRing()) return !1;
        if (null === this._shell) return !1;
        if (5 !== this._shell.getNumPoints()) return !1;
        for (
          var t = this._shell.getCoordinateSequence(),
            e = this.getEnvelopeInternal(),
            i = 0;
          i < 5;
          i++
        ) {
          var n = t.getX(i);
          if (n !== e.getMinX() && n !== e.getMaxX()) return !1;
          var r = t.getY(i);
          if (r !== e.getMinY() && r !== e.getMaxY()) return !1;
        }
        for (var o = t.getX(0), a = t.getY(0), s = 1; s <= 4; s++) {
          var l = t.getX(s),
            u = t.getY(s);
          if ((l !== o) === (u !== a)) return !1;
          (o = l), (a = u);
        }
        return !0;
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          if (!this.isEquivalentClass(e)) return !1;
          var n = e,
            r = this._shell,
            o = n._shell;
          if (!r.equalsExact(o, i)) return !1;
          if (this._holes.length !== n._holes.length) return !1;
          for (var a = 0; a < this._holes.length; a++)
            if (!this._holes[a].equalsExact(n._holes[a], i)) return !1;
          return !0;
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.normalize = function () {
        if (0 === arguments.length) {
          this.normalize(this._shell, !0);
          for (var t = 0; t < this._holes.length; t++)
            this.normalize(this._holes[t], !1);
          mx.sort(this._holes);
        } else if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          if (e.isEmpty()) return null;
          var n = new Array(e.getCoordinates().length - 1).fill(null);
          pb.arraycopy(e.getCoordinates(), 0, n, 0, n.length);
          var r = Zb.minCoordinate(e.getCoordinates());
          Zb.scroll(n, r),
            pb.arraycopy(n, 0, e.getCoordinates(), 0, n.length),
            (e.getCoordinates()[n.length] = n[0]),
            Tb.isCCW(e.getCoordinates()) === i &&
              Zb.reverse(e.getCoordinates());
        }
      }),
      (e.prototype.getCoordinate = function () {
        return this._shell.getCoordinate();
      }),
      (e.prototype.getNumInteriorRing = function () {
        return this._holes.length;
      }),
      (e.prototype.getBoundaryDimension = function () {
        return 1;
      }),
      (e.prototype.getDimension = function () {
        return 2;
      }),
      (e.prototype.getLength = function () {
        var t = 0;
        t += this._shell.getLength();
        for (var e = 0; e < this._holes.length; e++)
          t += this._holes[e].getLength();
        return t;
      }),
      (e.prototype.getNumPoints = function () {
        for (
          var t = this._shell.getNumPoints(), e = 0;
          e < this._holes.length;
          e++
        )
          t += this._holes[e].getNumPoints();
        return t;
      }),
      (e.prototype.reverse = function () {
        var t = this.copy();
        (t._shell = this._shell.copy().reverse()),
          (t._holes = new Array(this._holes.length).fill(null));
        for (var e = 0; e < this._holes.length; e++)
          t._holes[e] = this._holes[e].copy().reverse();
        return t;
      }),
      (e.prototype.convexHull = function () {
        return this.getExteriorRing().convexHull();
      }),
      (e.prototype.compareToSameClass = function () {
        if (1 === arguments.length) {
          var t = arguments[0],
            e = this._shell,
            i = t._shell;
          return e.compareToSameClass(i);
        }
        if (2 === arguments.length) {
          var n = arguments[1],
            r = arguments[0],
            o = this._shell,
            a = r._shell,
            s = o.compareToSameClass(a, n);
          if (0 !== s) return s;
          for (
            var l = this.getNumInteriorRing(),
              u = r.getNumInteriorRing(),
              c = 0;
            c < l && c < u;

          ) {
            var h = this.getInteriorRingN(c),
              p = r.getInteriorRingN(c),
              d = h.compareToSameClass(p, n);
            if (0 !== d) return d;
            c++;
          }
          return c < l ? 1 : c < u ? -1 : 0;
        }
      }),
      (e.prototype.apply = function (t) {
        var e = this;
        if (Kv(t, Ob)) {
          this._shell.apply(t);
          for (var i = 0; i < this._holes.length; i++) e._holes[i].apply(t);
        } else if (Kv(t, xx)) {
          if ((this._shell.apply(t), !t.isDone()))
            for (
              var n = 0;
              n < this._holes.length && (e._holes[n].apply(t), !t.isDone());
              n++
            );
          t.isGeometryChanged() && this.geometryChanged();
        } else if (Kv(t, bx)) t.filter(this);
        else if (Kv(t, Lb)) {
          t.filter(this), this._shell.apply(t);
          for (var r = 0; r < this._holes.length; r++) e._holes[r].apply(t);
        }
      }),
      (e.prototype.getBoundary = function () {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var t = new Array(this._holes.length + 1).fill(null);
        t[0] = this._shell;
        for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
        return t.length <= 1
          ? this.getFactory().createLinearRing(t[0].getCoordinateSequence())
          : this.getFactory().createMultiLineString(t);
      }),
      (e.prototype.clone = function () {
        var e = t.prototype.clone.call(this);
        (e._shell = this._shell.clone()),
          (e._holes = new Array(this._holes.length).fill(null));
        for (var i = 0; i < this._holes.length; i++)
          e._holes[i] = this._holes[i].clone();
        return e;
      }),
      (e.prototype.getGeometryType = function () {
        return "Polygon";
      }),
      (e.prototype.copy = function () {
        for (
          var t = this._shell.copy(),
            i = new Array(this._holes.length).fill(null),
            n = 0;
          n < i.length;
          n++
        )
          i[n] = this._holes[n].copy();
        return new e(t, i, this._factory);
      }),
      (e.prototype.getExteriorRing = function () {
        return this._shell;
      }),
      (e.prototype.isEmpty = function () {
        return this._shell.isEmpty();
      }),
      (e.prototype.getInteriorRingN = function (t) {
        return this._holes[t];
      }),
      (e.prototype.interfaces_ = function () {
        return [zx];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return -0x307ffefd8dc97200;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Ib),
  Bx = (function (t) {
    function e() {
      t.apply(this, arguments);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.getSortIndex = function () {
        return Ib.SORTINDEX_MULTIPOINT;
      }),
      (e.prototype.isValid = function () {
        return !0;
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          return (
            !!this.isEquivalentClass(e) &&
            t.prototype.equalsExact.call(this, e, i)
          );
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.getCoordinate = function () {
        if (1 === arguments.length) {
          var e = arguments[0];
          return this._geometries[e].getCoordinate();
        }
        return t.prototype.getCoordinate.apply(this, arguments);
      }),
      (e.prototype.getBoundaryDimension = function () {
        return yx.FALSE;
      }),
      (e.prototype.getDimension = function () {
        return 0;
      }),
      (e.prototype.getBoundary = function () {
        return this.getFactory().createGeometryCollection(null);
      }),
      (e.prototype.getGeometryType = function () {
        return "MultiPoint";
      }),
      (e.prototype.copy = function () {
        for (
          var t = new Array(this._geometries.length).fill(null), i = 0;
          i < t.length;
          i++
        )
          t[i] = this._geometries[i].copy();
        return new e(t, this._factory);
      }),
      (e.prototype.interfaces_ = function () {
        return [Ox];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return -0x6fb1ed4162e0fc00;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(_x),
  Gx = (function (t) {
    function e(e, i) {
      e instanceof qv &&
        i instanceof i_ &&
        (e = i.getCoordinateSequenceFactory().create(e)),
        t.call(this, e, i),
        this.validateConstruction();
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      MINIMUM_VALID_SIZE: {
        configurable: !0,
      },
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.getSortIndex = function () {
        return Ib.SORTINDEX_LINEARRING;
      }),
      (e.prototype.getBoundaryDimension = function () {
        return yx.FALSE;
      }),
      (e.prototype.isClosed = function () {
        return !!this.isEmpty() || t.prototype.isClosed.call(this);
      }),
      (e.prototype.reverse = function () {
        var t = this._points.copy();
        return Nx.reverse(t), this.getFactory().createLinearRing(t);
      }),
      (e.prototype.validateConstruction = function () {
        if (!this.isEmpty() && !t.prototype.isClosed.call(this))
          throw new Bv("Points of LinearRing do not form a closed linestring");
        if (
          this.getCoordinateSequence().size() >= 1 &&
          this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE
        )
          throw new Bv(
            "Invalid number of points in LinearRing (found " +
              this.getCoordinateSequence().size() +
              " - must be 0 or >= 4)"
          );
      }),
      (e.prototype.getGeometryType = function () {
        return "LinearRing";
      }),
      (e.prototype.copy = function () {
        return new e(this._points.copy(), this._factory);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.MINIMUM_VALID_SIZE.get = function () {
        return 4;
      }),
      (i.serialVersionUID.get = function () {
        return -0x3b229e262367a600;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(Rx),
  Ux = (function (t) {
    function e() {
      t.apply(this, arguments);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      serialVersionUID: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.getSortIndex = function () {
        return Ib.SORTINDEX_MULTIPOLYGON;
      }),
      (e.prototype.equalsExact = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          return (
            !!this.isEquivalentClass(e) &&
            t.prototype.equalsExact.call(this, e, i)
          );
        }
        return t.prototype.equalsExact.apply(this, arguments);
      }),
      (e.prototype.getBoundaryDimension = function () {
        return 1;
      }),
      (e.prototype.getDimension = function () {
        return 2;
      }),
      (e.prototype.reverse = function () {
        for (
          var t = this._geometries.length, e = new Array(t).fill(null), i = 0;
          i < this._geometries.length;
          i++
        )
          e[i] = this._geometries[i].reverse();
        return this.getFactory().createMultiPolygon(e);
      }),
      (e.prototype.getBoundary = function () {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        for (var t = new Yb(), e = 0; e < this._geometries.length; e++)
          for (
            var i = this._geometries[e].getBoundary(), n = 0;
            n < i.getNumGeometries();
            n++
          )
            t.add(i.getGeometryN(n));
        var r = new Array(t.size()).fill(null);
        return this.getFactory().createMultiLineString(t.toArray(r));
      }),
      (e.prototype.getGeometryType = function () {
        return "MultiPolygon";
      }),
      (e.prototype.copy = function () {
        for (
          var t = new Array(this._geometries.length).fill(null), i = 0;
          i < t.length;
          i++
        )
          t[i] = this._geometries[i].copy();
        return new e(t, this._factory);
      }),
      (e.prototype.interfaces_ = function () {
        return [zx];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.serialVersionUID.get = function () {
        return -0x7a5aa1369171980;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(_x),
  jx = function (t) {
    (this._factory = t || null), (this._isUserDataCopied = !1);
  },
  Hx = {
    NoOpGeometryOperation: {
      configurable: !0,
    },
    CoordinateOperation: {
      configurable: !0,
    },
    CoordinateSequenceOperation: {
      configurable: !0,
    },
  };
(jx.prototype.setCopyUserData = function (t) {
  this._isUserDataCopied = t;
}),
  (jx.prototype.edit = function (t, e) {
    if (null === t) return null;
    var i = this.editInternal(t, e);
    return this._isUserDataCopied && i.setUserData(t.getUserData()), i;
  }),
  (jx.prototype.editInternal = function (t, e) {
    return (
      null === this._factory && (this._factory = t.getFactory()),
      t instanceof _x
        ? this.editGeometryCollection(t, e)
        : t instanceof kx
        ? this.editPolygon(t, e)
        : t instanceof Fx || t instanceof Rx
        ? e.edit(t, this._factory)
        : (Mb.shouldNeverReachHere(
            "Unsupported Geometry class: " + t.getClass().getName()
          ),
          null)
    );
  }),
  (jx.prototype.editGeometryCollection = function (t, e) {
    for (
      var i = e.edit(t, this._factory), n = new Yb(), r = 0;
      r < i.getNumGeometries();
      r++
    ) {
      var o = this.edit(i.getGeometryN(r), e);
      null === o || o.isEmpty() || n.add(o);
    }
    return i.getClass() === Bx
      ? this._factory.createMultiPoint(n.toArray([]))
      : i.getClass() === Sx
      ? this._factory.createMultiLineString(n.toArray([]))
      : i.getClass() === Ux
      ? this._factory.createMultiPolygon(n.toArray([]))
      : this._factory.createGeometryCollection(n.toArray([]));
  }),
  (jx.prototype.editPolygon = function (t, e) {
    var i = e.edit(t, this._factory);
    if ((null === i && (i = this._factory.createPolygon(null)), i.isEmpty()))
      return i;
    var n = this.edit(i.getExteriorRing(), e);
    if (null === n || n.isEmpty()) return this._factory.createPolygon();
    for (var r = new Yb(), o = 0; o < i.getNumInteriorRing(); o++) {
      var a = this.edit(i.getInteriorRingN(o), e);
      null === a || a.isEmpty() || r.add(a);
    }
    return this._factory.createPolygon(n, r.toArray([]));
  }),
  (jx.prototype.interfaces_ = function () {
    return [];
  }),
  (jx.prototype.getClass = function () {
    return jx;
  }),
  (jx.GeometryEditorOperation = function () {}),
  (Hx.NoOpGeometryOperation.get = function () {
    return Vx;
  }),
  (Hx.CoordinateOperation.get = function () {
    return Wx;
  }),
  (Hx.CoordinateSequenceOperation.get = function () {
    return qx;
  }),
  Object.defineProperties(jx, Hx);
var Vx = function () {};
(Vx.prototype.edit = function (t, e) {
  return t;
}),
  (Vx.prototype.interfaces_ = function () {
    return [jx.GeometryEditorOperation];
  }),
  (Vx.prototype.getClass = function () {
    return Vx;
  });
var Wx = function () {};
(Wx.prototype.edit = function (t, e) {
  var i = this.editCoordinates(t.getCoordinates(), t);
  return null === i
    ? t
    : t instanceof Gx
    ? e.createLinearRing(i)
    : t instanceof Rx
    ? e.createLineString(i)
    : t instanceof Fx
    ? i.length > 0
      ? e.createPoint(i[0])
      : e.createPoint()
    : t;
}),
  (Wx.prototype.interfaces_ = function () {
    return [jx.GeometryEditorOperation];
  }),
  (Wx.prototype.getClass = function () {
    return Wx;
  });
var qx = function () {};
(qx.prototype.edit = function (t, e) {
  return t instanceof Gx
    ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t))
    : t instanceof Rx
    ? e.createLineString(this.edit(t.getCoordinateSequence(), t))
    : t instanceof Fx
    ? e.createPoint(this.edit(t.getCoordinateSequence(), t))
    : t;
}),
  (qx.prototype.interfaces_ = function () {
    return [jx.GeometryEditorOperation];
  }),
  (qx.prototype.getClass = function () {
    return qx;
  });
var Yx = function () {
    var t = this;
    if (
      ((this._dimension = 3),
      (this._coordinates = null),
      1 === arguments.length)
    ) {
      if (arguments[0] instanceof Array)
        (this._coordinates = arguments[0]), (this._dimension = 3);
      else if (Number.isInteger(arguments[0])) {
        var e = arguments[0];
        this._coordinates = new Array(e).fill(null);
        for (var i = 0; i < e; i++) t._coordinates[i] = new qv();
      } else if (Kv(arguments[0], lb)) {
        var n = arguments[0];
        if (null === n)
          return (this._coordinates = new Array(0).fill(null)), null;
        (this._dimension = n.getDimension()),
          (this._coordinates = new Array(n.size()).fill(null));
        for (var r = 0; r < this._coordinates.length; r++)
          t._coordinates[r] = n.getCoordinateCopy(r);
      }
    } else if (2 === arguments.length)
      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
        var o = arguments[0],
          a = arguments[1];
        (this._coordinates = o),
          (this._dimension = a),
          null === o && (this._coordinates = new Array(0).fill(null));
      } else if (
        Number.isInteger(arguments[0]) &&
        Number.isInteger(arguments[1])
      ) {
        var s = arguments[0],
          l = arguments[1];
        (this._coordinates = new Array(s).fill(null)), (this._dimension = l);
        for (var u = 0; u < s; u++) t._coordinates[u] = new qv();
      }
  },
  Xx = {
    serialVersionUID: {
      configurable: !0,
    },
  };
(Yx.prototype.setOrdinate = function (t, e, i) {
  switch (e) {
    case lb.X:
      this._coordinates[t].x = i;
      break;
    case lb.Y:
      this._coordinates[t].y = i;
      break;
    case lb.Z:
      this._coordinates[t].z = i;
      break;
    default:
      throw new Bv("invalid ordinateIndex");
  }
}),
  (Yx.prototype.size = function () {
    return this._coordinates.length;
  }),
  (Yx.prototype.getOrdinate = function (t, e) {
    switch (e) {
      case lb.X:
        return this._coordinates[t].x;
      case lb.Y:
        return this._coordinates[t].y;
      case lb.Z:
        return this._coordinates[t].z;
    }
    return Gv.NaN;
  }),
  (Yx.prototype.getCoordinate = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this._coordinates[t];
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      (i.x = this._coordinates[e].x),
        (i.y = this._coordinates[e].y),
        (i.z = this._coordinates[e].z);
    }
  }),
  (Yx.prototype.getCoordinateCopy = function (t) {
    return new qv(this._coordinates[t]);
  }),
  (Yx.prototype.getDimension = function () {
    return this._dimension;
  }),
  (Yx.prototype.getX = function (t) {
    return this._coordinates[t].x;
  }),
  (Yx.prototype.clone = function () {
    for (
      var t = new Array(this.size()).fill(null), e = 0;
      e < this._coordinates.length;
      e++
    )
      t[e] = this._coordinates[e].clone();
    return new Yx(t, this._dimension);
  }),
  (Yx.prototype.expandEnvelope = function (t) {
    for (var e = 0; e < this._coordinates.length; e++)
      t.expandToInclude(this._coordinates[e]);
    return t;
  }),
  (Yx.prototype.copy = function () {
    for (
      var t = new Array(this.size()).fill(null), e = 0;
      e < this._coordinates.length;
      e++
    )
      t[e] = this._coordinates[e].copy();
    return new Yx(t, this._dimension);
  }),
  (Yx.prototype.toString = function () {
    if (this._coordinates.length > 0) {
      var t = new eb(17 * this._coordinates.length);
      t.append("("), t.append(this._coordinates[0]);
      for (var e = 1; e < this._coordinates.length; e++)
        t.append(", "), t.append(this._coordinates[e]);
      return t.append(")"), t.toString();
    }
    return "()";
  }),
  (Yx.prototype.getY = function (t) {
    return this._coordinates[t].y;
  }),
  (Yx.prototype.toCoordinateArray = function () {
    return this._coordinates;
  }),
  (Yx.prototype.interfaces_ = function () {
    return [lb, Wv];
  }),
  (Yx.prototype.getClass = function () {
    return Yx;
  }),
  (Xx.serialVersionUID.get = function () {
    return -0xcb44a778db18e00;
  }),
  Object.defineProperties(Yx, Xx);
var Qx = function () {},
  Zx = {
    serialVersionUID: {
      configurable: !0,
    },
    instanceObject: {
      configurable: !0,
    },
  };
(Qx.prototype.readResolve = function () {
  return Qx.instance();
}),
  (Qx.prototype.create = function () {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) return new Yx(arguments[0]);
      if (Kv(arguments[0], lb)) return new Yx(arguments[0]);
    } else if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      return e > 3 && (e = 3), e < 2 ? new Yx(t) : new Yx(t, e);
    }
  }),
  (Qx.prototype.interfaces_ = function () {
    return [Qv, Wv];
  }),
  (Qx.prototype.getClass = function () {
    return Qx;
  }),
  (Qx.instance = function () {
    return Qx.instanceObject;
  }),
  (Zx.serialVersionUID.get = function () {
    return -0x38e49fa6cf6f2e00;
  }),
  (Zx.instanceObject.get = function () {
    return new Qx();
  }),
  Object.defineProperties(Qx, Zx);
var Jx = (function (t) {
    function e() {
      t.call(this), (this.map_ = new Map());
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.get = function (t) {
        return this.map_.get(t) || null;
      }),
      (e.prototype.put = function (t, e) {
        return this.map_.set(t, e), e;
      }),
      (e.prototype.values = function () {
        for (var t = new Yb(), e = this.map_.values(), i = e.next(); !i.done; )
          t.add(i.value), (i = e.next());
        return t;
      }),
      (e.prototype.entrySet = function () {
        var t = new rx();
        return (
          this.map_.entries().forEach(function (e) {
            return t.add(e);
          }),
          t
        );
      }),
      (e.prototype.size = function () {
        return this.map_.size();
      }),
      e
    );
  })(tx),
  Kx = function t() {
    if (
      ((this._modelType = null), (this._scale = null), 0 === arguments.length)
    )
      this._modelType = t.FLOATING;
    else if (1 === arguments.length)
      if (arguments[0] instanceof t_) {
        var e = arguments[0];
        (this._modelType = e), e === t.FIXED && this.setScale(1);
      } else if ("number" == typeof arguments[0]) {
        var i = arguments[0];
        (this._modelType = t.FIXED), this.setScale(i);
      } else if (arguments[0] instanceof t) {
        var n = arguments[0];
        (this._modelType = n._modelType), (this._scale = n._scale);
      }
  },
  $x = {
    serialVersionUID: {
      configurable: !0,
    },
    maximumPreciseValue: {
      configurable: !0,
    },
  };
(Kx.prototype.equals = function (t) {
  if (!(t instanceof Kx)) return !1;
  var e = t;
  return this._modelType === e._modelType && this._scale === e._scale;
}),
  (Kx.prototype.compareTo = function (t) {
    var e = t,
      i = this.getMaximumSignificantDigits(),
      n = e.getMaximumSignificantDigits();
    return new ib(i).compareTo(new ib(n));
  }),
  (Kx.prototype.getScale = function () {
    return this._scale;
  }),
  (Kx.prototype.isFloating = function () {
    return (
      this._modelType === Kx.FLOATING || this._modelType === Kx.FLOATING_SINGLE
    );
  }),
  (Kx.prototype.getType = function () {
    return this._modelType;
  }),
  (Kx.prototype.toString = function () {
    var t = "UNKNOWN";
    return (
      this._modelType === Kx.FLOATING
        ? (t = "Floating")
        : this._modelType === Kx.FLOATING_SINGLE
        ? (t = "Floating-Single")
        : this._modelType === Kx.FIXED &&
          (t = "Fixed (Scale=" + this.getScale() + ")"),
      t
    );
  }),
  (Kx.prototype.makePrecise = function () {
    if ("number" == typeof arguments[0]) {
      var t = arguments[0];
      return Gv.isNaN(t) || this._modelType === Kx.FLOATING_SINGLE
        ? t
        : this._modelType === Kx.FIXED
        ? Math.round(t * this._scale) / this._scale
        : t;
    }
    if (arguments[0] instanceof qv) {
      var e = arguments[0];
      if (this._modelType === Kx.FLOATING) return null;
      (e.x = this.makePrecise(e.x)), (e.y = this.makePrecise(e.y));
    }
  }),
  (Kx.prototype.getMaximumSignificantDigits = function () {
    var t = 16;
    return (
      this._modelType === Kx.FLOATING
        ? (t = 16)
        : this._modelType === Kx.FLOATING_SINGLE
        ? (t = 6)
        : this._modelType === Kx.FIXED &&
          (t =
            1 +
            Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))),
      t
    );
  }),
  (Kx.prototype.setScale = function (t) {
    this._scale = Math.abs(t);
  }),
  (Kx.prototype.interfaces_ = function () {
    return [Wv, jv];
  }),
  (Kx.prototype.getClass = function () {
    return Kx;
  }),
  (Kx.mostPrecise = function (t, e) {
    return t.compareTo(e) >= 0 ? t : e;
  }),
  ($x.serialVersionUID.get = function () {
    return 0x6bee6404e9a25c00;
  }),
  ($x.maximumPreciseValue.get = function () {
    return 9007199254740992;
  }),
  Object.defineProperties(Kx, $x);
var t_ = function t(e) {
    (this._name = e || null), t.nameToTypeMap.put(e, this);
  },
  e_ = {
    serialVersionUID: {
      configurable: !0,
    },
    nameToTypeMap: {
      configurable: !0,
    },
  };
(t_.prototype.readResolve = function () {
  return t_.nameToTypeMap.get(this._name);
}),
  (t_.prototype.toString = function () {
    return this._name;
  }),
  (t_.prototype.interfaces_ = function () {
    return [Wv];
  }),
  (t_.prototype.getClass = function () {
    return t_;
  }),
  (e_.serialVersionUID.get = function () {
    return -552860263173159e4;
  }),
  (e_.nameToTypeMap.get = function () {
    return new Jx();
  }),
  Object.defineProperties(t_, e_),
  (Kx.Type = t_),
  (Kx.FIXED = new t_("FIXED")),
  (Kx.FLOATING = new t_("FLOATING")),
  (Kx.FLOATING_SINGLE = new t_("FLOATING SINGLE"));
var i_ = function t() {
    (this._precisionModel = new Kx()),
      (this._SRID = 0),
      (this._coordinateSequenceFactory =
        t.getDefaultCoordinateSequenceFactory()),
      0 === arguments.length ||
        (1 === arguments.length
          ? Kv(arguments[0], Qv)
            ? (this._coordinateSequenceFactory = arguments[0])
            : arguments[0] instanceof Kx &&
              (this._precisionModel = arguments[0])
          : 2 === arguments.length
          ? ((this._precisionModel = arguments[0]), (this._SRID = arguments[1]))
          : 3 === arguments.length &&
            ((this._precisionModel = arguments[0]),
            (this._SRID = arguments[1]),
            (this._coordinateSequenceFactory = arguments[2])));
  },
  n_ = {
    serialVersionUID: {
      configurable: !0,
    },
  };
(i_.prototype.toGeometry = function (t) {
  return t.isNull()
    ? this.createPoint(null)
    : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY()
    ? this.createPoint(new qv(t.getMinX(), t.getMinY()))
    : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY()
    ? this.createLineString([
        new qv(t.getMinX(), t.getMinY()),
        new qv(t.getMaxX(), t.getMaxY()),
      ])
    : this.createPolygon(
        this.createLinearRing([
          new qv(t.getMinX(), t.getMinY()),
          new qv(t.getMinX(), t.getMaxY()),
          new qv(t.getMaxX(), t.getMaxY()),
          new qv(t.getMaxX(), t.getMinY()),
          new qv(t.getMinX(), t.getMinY()),
        ]),
        null
      );
}),
  (i_.prototype.createLineString = function (t) {
    return t
      ? t instanceof Array
        ? new Rx(this.getCoordinateSequenceFactory().create(t), this)
        : Kv(t, lb)
        ? new Rx(t, this)
        : void 0
      : new Rx(this.getCoordinateSequenceFactory().create([]), this);
  }),
  (i_.prototype.createMultiLineString = function () {
    return 0 === arguments.length
      ? new Sx(null, this)
      : 1 === arguments.length
      ? new Sx(arguments[0], this)
      : void 0;
  }),
  (i_.prototype.buildGeometry = function (t) {
    for (var e = null, i = !1, n = !1, r = t.iterator(); r.hasNext(); ) {
      var o = r.next(),
        a = o.getClass();
      null === e && (e = a),
        a !== e && (i = !0),
        o.isGeometryCollectionOrDerived() && (n = !0);
    }
    if (null === e) return this.createGeometryCollection();
    if (i || n) return this.createGeometryCollection(i_.toGeometryArray(t));
    var s = t.iterator().next();
    if (t.size() > 1) {
      if (s instanceof kx) return this.createMultiPolygon(i_.toPolygonArray(t));
      if (s instanceof Rx)
        return this.createMultiLineString(i_.toLineStringArray(t));
      if (s instanceof Fx) return this.createMultiPoint(i_.toPointArray(t));
      Mb.shouldNeverReachHere("Unhandled class: " + s.getClass().getName());
    }
    return s;
  }),
  (i_.prototype.createMultiPointFromCoords = function (t) {
    return this.createMultiPoint(
      null !== t ? this.getCoordinateSequenceFactory().create(t) : null
    );
  }),
  (i_.prototype.createPoint = function () {
    if (0 === arguments.length)
      return this.createPoint(this.getCoordinateSequenceFactory().create([]));
    if (1 === arguments.length) {
      if (arguments[0] instanceof qv) {
        var t = arguments[0];
        return this.createPoint(
          null !== t ? this.getCoordinateSequenceFactory().create([t]) : null
        );
      }
      if (Kv(arguments[0], lb)) return new Fx(arguments[0], this);
    }
  }),
  (i_.prototype.getCoordinateSequenceFactory = function () {
    return this._coordinateSequenceFactory;
  }),
  (i_.prototype.createPolygon = function () {
    if (0 === arguments.length) return new kx(null, null, this);
    if (1 === arguments.length) {
      if (Kv(arguments[0], lb)) {
        var t = arguments[0];
        return this.createPolygon(this.createLinearRing(t));
      }
      if (arguments[0] instanceof Array) {
        var e = arguments[0];
        return this.createPolygon(this.createLinearRing(e));
      }
      if (arguments[0] instanceof Gx) {
        var i = arguments[0];
        return this.createPolygon(i, null);
      }
    } else if (2 === arguments.length) {
      return new kx(arguments[0], arguments[1], this);
    }
  }),
  (i_.prototype.getSRID = function () {
    return this._SRID;
  }),
  (i_.prototype.createGeometryCollection = function () {
    return 0 === arguments.length
      ? new _x(null, this)
      : 1 === arguments.length
      ? new _x(arguments[0], this)
      : void 0;
  }),
  (i_.prototype.createGeometry = function (t) {
    return new jx(this).edit(t, {
      edit: function () {
        if (2 === arguments.length) {
          var t = arguments[0];
          return this._coordinateSequenceFactory.create(t);
        }
      },
    });
  }),
  (i_.prototype.getPrecisionModel = function () {
    return this._precisionModel;
  }),
  (i_.prototype.createLinearRing = function () {
    if (0 === arguments.length)
      return this.createLinearRing(
        this.getCoordinateSequenceFactory().create([])
      );
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];
        return this.createLinearRing(
          null !== t ? this.getCoordinateSequenceFactory().create(t) : null
        );
      }
      if (Kv(arguments[0], lb)) return new Gx(arguments[0], this);
    }
  }),
  (i_.prototype.createMultiPolygon = function () {
    return 0 === arguments.length
      ? new Ux(null, this)
      : 1 === arguments.length
      ? new Ux(arguments[0], this)
      : void 0;
  }),
  (i_.prototype.createMultiPoint = function () {
    if (0 === arguments.length) return new Bx(null, this);
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) return new Bx(arguments[0], this);
      if (arguments[0] instanceof Array) {
        var t = arguments[0];
        return this.createMultiPoint(
          null !== t ? this.getCoordinateSequenceFactory().create(t) : null
        );
      }
      if (Kv(arguments[0], lb)) {
        var e = arguments[0];
        if (null === e) return this.createMultiPoint(new Array(0).fill(null));
        for (var i = new Array(e.size()).fill(null), n = 0; n < e.size(); n++) {
          var r = this.getCoordinateSequenceFactory().create(
            1,
            e.getDimension()
          );
          Nx.copy(e, n, r, 0, 1), (i[n] = this.createPoint(r));
        }
        return this.createMultiPoint(i);
      }
    }
  }),
  (i_.prototype.interfaces_ = function () {
    return [Wv];
  }),
  (i_.prototype.getClass = function () {
    return i_;
  }),
  (i_.toMultiPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toGeometryArray = function (t) {
    if (null === t) return null;
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.getDefaultCoordinateSequenceFactory = function () {
    return Qx.instance();
  }),
  (i_.toMultiLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toMultiPointArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toLinearRingArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toPointArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.toPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);
    return t.toArray(e);
  }),
  (i_.createPointFromInternalCoord = function (t, e) {
    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
  }),
  (n_.serialVersionUID.get = function () {
    return -0x5ea75f2051eeb400;
  }),
  Object.defineProperties(i_, n_);
var r_ = [
    "Point",
    "MultiPoint",
    "LineString",
    "MultiLineString",
    "Polygon",
    "MultiPolygon",
  ],
  o_ = function (t) {
    this.geometryFactory = t || new i_();
  };
(o_.prototype.read = function (t) {
  var e,
    i = (e = "string" == typeof t ? JSON.parse(t) : t).type;
  if (!a_[i]) throw new Error("Unknown GeoJSON type: " + e.type);
  return -1 !== r_.indexOf(i)
    ? a_[i].apply(this, [e.coordinates])
    : "GeometryCollection" === i
    ? a_[i].apply(this, [e.geometries])
    : a_[i].apply(this, [e]);
}),
  (o_.prototype.write = function (t) {
    var e = t.getGeometryType();
    if (!s_[e]) throw new Error("Geometry is not supported");
    return s_[e].apply(this, [t]);
  });
var a_ = {
    Feature: function (t) {
      var e = {};
      for (var i in t) e[i] = t[i];
      if (t.geometry) {
        var n = t.geometry.type;
        if (!a_[n]) throw new Error("Unknown GeoJSON type: " + t.type);
        e.geometry = this.read(t.geometry);
      }
      return t.bbox && (e.bbox = a_.bbox.apply(this, [t.bbox])), e;
    },
    FeatureCollection: function (t) {
      var e = {};
      if (t.features) {
        e.features = [];
        for (var i = 0; i < t.features.length; ++i)
          e.features.push(this.read(t.features[i]));
      }
      return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;
    },
    coordinates: function (t) {
      for (var e = [], i = 0; i < t.length; ++i) {
        var n = t[i];
        e.push(new qv(n[0], n[1]));
      }
      return e;
    },
    bbox: function (t) {
      return this.geometryFactory.createLinearRing([
        new qv(t[0], t[1]),
        new qv(t[2], t[1]),
        new qv(t[2], t[3]),
        new qv(t[0], t[3]),
        new qv(t[0], t[1]),
      ]);
    },
    Point: function (t) {
      var e = new qv(t[0], t[1]);
      return this.geometryFactory.createPoint(e);
    },
    MultiPoint: function (t) {
      for (var e = [], i = 0; i < t.length; ++i)
        e.push(a_.Point.apply(this, [t[i]]));
      return this.geometryFactory.createMultiPoint(e);
    },
    LineString: function (t) {
      var e = a_.coordinates.apply(this, [t]);
      return this.geometryFactory.createLineString(e);
    },
    MultiLineString: function (t) {
      for (var e = [], i = 0; i < t.length; ++i)
        e.push(a_.LineString.apply(this, [t[i]]));
      return this.geometryFactory.createMultiLineString(e);
    },
    Polygon: function (t) {
      for (
        var e = a_.coordinates.apply(this, [t[0]]),
          i = this.geometryFactory.createLinearRing(e),
          n = [],
          r = 1;
        r < t.length;
        ++r
      ) {
        var o = t[r],
          a = a_.coordinates.apply(this, [o]),
          s = this.geometryFactory.createLinearRing(a);
        n.push(s);
      }
      return this.geometryFactory.createPolygon(i, n);
    },
    MultiPolygon: function (t) {
      for (var e = [], i = 0; i < t.length; ++i) {
        var n = t[i];
        e.push(a_.Polygon.apply(this, [n]));
      }
      return this.geometryFactory.createMultiPolygon(e);
    },
    GeometryCollection: function (t) {
      for (var e = [], i = 0; i < t.length; ++i) {
        var n = t[i];
        e.push(this.read(n));
      }
      return this.geometryFactory.createGeometryCollection(e);
    },
  },
  s_ = {
    coordinate: function (t) {
      return [t.x, t.y];
    },
    Point: function (t) {
      return {
        type: "Point",
        coordinates: s_.coordinate.apply(this, [t.getCoordinate()]),
      };
    },
    MultiPoint: function (t) {
      for (var e = [], i = 0; i < t._geometries.length; ++i) {
        var n = t._geometries[i],
          r = s_.Point.apply(this, [n]);
        e.push(r.coordinates);
      }
      return {
        type: "MultiPoint",
        coordinates: e,
      };
    },
    LineString: function (t) {
      for (var e = [], i = t.getCoordinates(), n = 0; n < i.length; ++n) {
        var r = i[n];
        e.push(s_.coordinate.apply(this, [r]));
      }
      return {
        type: "LineString",
        coordinates: e,
      };
    },
    MultiLineString: function (t) {
      for (var e = [], i = 0; i < t._geometries.length; ++i) {
        var n = t._geometries[i],
          r = s_.LineString.apply(this, [n]);
        e.push(r.coordinates);
      }
      return {
        type: "MultiLineString",
        coordinates: e,
      };
    },
    Polygon: function (t) {
      var e = [],
        i = s_.LineString.apply(this, [t._shell]);
      e.push(i.coordinates);
      for (var n = 0; n < t._holes.length; ++n) {
        var r = t._holes[n],
          o = s_.LineString.apply(this, [r]);
        e.push(o.coordinates);
      }
      return {
        type: "Polygon",
        coordinates: e,
      };
    },
    MultiPolygon: function (t) {
      for (var e = [], i = 0; i < t._geometries.length; ++i) {
        var n = t._geometries[i],
          r = s_.Polygon.apply(this, [n]);
        e.push(r.coordinates);
      }
      return {
        type: "MultiPolygon",
        coordinates: e,
      };
    },
    GeometryCollection: function (t) {
      for (var e = [], i = 0; i < t._geometries.length; ++i) {
        var n = t._geometries[i],
          r = n.getGeometryType();
        e.push(s_[r].apply(this, [n]));
      }
      return {
        type: "GeometryCollection",
        geometries: e,
      };
    },
  },
  l_ = function (t) {
    (this.geometryFactory = t || new i_()),
      (this.precisionModel = this.geometryFactory.getPrecisionModel()),
      (this.parser = new o_(this.geometryFactory));
  };
(l_.prototype.read = function (t) {
  var e = this.parser.read(t);
  return (
    this.precisionModel.getType() === Kx.FIXED && this.reducePrecision(e), e
  );
}),
  (l_.prototype.reducePrecision = function (t) {
    var e, i;
    if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
    else if (t.points)
      for (e = 0, i = t.points.length; e < i; e++)
        this.precisionModel.makePrecise(t.points[e]);
    else if (t.geometries)
      for (e = 0, i = t.geometries.length; e < i; e++)
        this.reducePrecision(t.geometries[e]);
  });
var u_ = function () {
  this.parser = new o_(this.geometryFactory);
};
u_.prototype.write = function (t) {
  return this.parser.write(t);
};
var c_ = function () {},
  h_ = {
    ON: {
      configurable: !0,
    },
    LEFT: {
      configurable: !0,
    },
    RIGHT: {
      configurable: !0,
    },
  };
function p_(t) {
  this.message = t || "";
}
function d_() {
  this.array_ = [];
}
(c_.prototype.interfaces_ = function () {
  return [];
}),
  (c_.prototype.getClass = function () {
    return c_;
  }),
  (c_.opposite = function (t) {
    return t === c_.LEFT ? c_.RIGHT : t === c_.RIGHT ? c_.LEFT : t;
  }),
  (h_.ON.get = function () {
    return 0;
  }),
  (h_.LEFT.get = function () {
    return 1;
  }),
  (h_.RIGHT.get = function () {
    return 2;
  }),
  Object.defineProperties(c_, h_),
  (p_.prototype = new Error()),
  (p_.prototype.name = "EmptyStackException"),
  (d_.prototype = new Wb()),
  (d_.prototype.add = function (t) {
    return this.array_.push(t), !0;
  }),
  (d_.prototype.get = function (t) {
    if (t < 0 || t >= this.size()) throw new Error();
    return this.array_[t];
  }),
  (d_.prototype.push = function (t) {
    return this.array_.push(t), t;
  }),
  (d_.prototype.pop = function (t) {
    if (0 === this.array_.length) throw new p_();
    return this.array_.pop();
  }),
  (d_.prototype.peek = function () {
    if (0 === this.array_.length) throw new p_();
    return this.array_[this.array_.length - 1];
  }),
  (d_.prototype.empty = function () {
    return 0 === this.array_.length;
  }),
  (d_.prototype.isEmpty = function () {
    return this.empty();
  }),
  (d_.prototype.search = function (t) {
    return this.array_.indexOf(t);
  }),
  (d_.prototype.size = function () {
    return this.array_.length;
  }),
  (d_.prototype.toArray = function () {
    for (var t = [], e = 0, i = this.array_.length; e < i; e++)
      t.push(this.array_[e]);
    return t;
  });
var f_ = function () {
  (this._minIndex = -1),
    (this._minCoord = null),
    (this._minDe = null),
    (this._orientedDe = null);
};
(f_.prototype.getCoordinate = function () {
  return this._minCoord;
}),
  (f_.prototype.getRightmostSide = function (t, e) {
    var i = this.getRightmostSideOfSegment(t, e);
    return (
      i < 0 && (i = this.getRightmostSideOfSegment(t, e - 1)),
      i < 0 && ((this._minCoord = null), this.checkForRightmostCoordinate(t)),
      i
    );
  }),
  (f_.prototype.findRightmostEdgeAtVertex = function () {
    var t = this._minDe.getEdge().getCoordinates();
    Mb.isTrue(
      this._minIndex > 0 && this._minIndex < t.length,
      "rightmost point expected to be interior vertex of edge"
    );
    var e = t[this._minIndex - 1],
      i = t[this._minIndex + 1],
      n = Tb.computeOrientation(this._minCoord, i, e),
      r = !1;
    ((e.y < this._minCoord.y &&
      i.y < this._minCoord.y &&
      n === Tb.COUNTERCLOCKWISE) ||
      (e.y > this._minCoord.y &&
        i.y > this._minCoord.y &&
        n === Tb.CLOCKWISE)) &&
      (r = !0),
      r && (this._minIndex = this._minIndex - 1);
  }),
  (f_.prototype.getRightmostSideOfSegment = function (t, e) {
    var i = t.getEdge().getCoordinates();
    if (e < 0 || e + 1 >= i.length) return -1;
    if (i[e].y === i[e + 1].y) return -1;
    var n = c_.LEFT;
    return i[e].y < i[e + 1].y && (n = c_.RIGHT), n;
  }),
  (f_.prototype.getEdge = function () {
    return this._orientedDe;
  }),
  (f_.prototype.checkForRightmostCoordinate = function (t) {
    for (
      var e = this, i = t.getEdge().getCoordinates(), n = 0;
      n < i.length - 1;
      n++
    )
      (null === e._minCoord || i[n].x > e._minCoord.x) &&
        ((e._minDe = t), (e._minIndex = n), (e._minCoord = i[n]));
  }),
  (f_.prototype.findRightmostEdgeAtNode = function () {
    var t = this._minDe.getNode().getEdges();
    (this._minDe = t.getRightmostEdge()),
      this._minDe.isForward() ||
        ((this._minDe = this._minDe.getSym()),
        (this._minIndex = this._minDe.getEdge().getCoordinates().length - 1));
  }),
  (f_.prototype.findEdge = function (t) {
    for (var e = t.iterator(); e.hasNext(); ) {
      var i = e.next();
      i.isForward() && this.checkForRightmostCoordinate(i);
    }
    Mb.isTrue(
      0 !== this._minIndex ||
        this._minCoord.equals(this._minDe.getCoordinate()),
      "inconsistency in rightmost processing"
    ),
      0 === this._minIndex
        ? this.findRightmostEdgeAtNode()
        : this.findRightmostEdgeAtVertex(),
      (this._orientedDe = this._minDe),
      this.getRightmostSide(this._minDe, this._minIndex) === c_.LEFT &&
        (this._orientedDe = this._minDe.getSym());
  }),
  (f_.prototype.interfaces_ = function () {
    return [];
  }),
  (f_.prototype.getClass = function () {
    return f_;
  });
var g_ = (function (t) {
    function e(i, n) {
      t.call(this, e.msgWithCoord(i, n)),
        (this.pt = n ? new qv(n) : null),
        (this.name = "TopologyException");
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.getCoordinate = function () {
        return this.pt;
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.msgWithCoord = function (t, e) {
        return e ? t : t + " [ " + e + " ]";
      }),
      e
    );
  })(_b),
  m_ = function () {
    this.array_ = [];
  };
(m_.prototype.addLast = function (t) {
  this.array_.push(t);
}),
  (m_.prototype.removeFirst = function () {
    return this.array_.shift();
  }),
  (m_.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  });
var y_ = function () {
  (this._finder = null),
    (this._dirEdgeList = new Yb()),
    (this._nodes = new Yb()),
    (this._rightMostCoord = null),
    (this._env = null),
    (this._finder = new f_());
};
(y_.prototype.clearVisitedEdges = function () {
  for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) {
    t.next().setVisited(!1);
  }
}),
  (y_.prototype.getRightmostCoordinate = function () {
    return this._rightMostCoord;
  }),
  (y_.prototype.computeNodeDepth = function (t) {
    for (var e = null, i = t.getEdges().iterator(); i.hasNext(); ) {
      var n = i.next();
      if (n.isVisited() || n.getSym().isVisited()) {
        e = n;
        break;
      }
    }
    if (null === e)
      throw new g_(
        "unable to find edge to compute depths at " + t.getCoordinate()
      );
    t.getEdges().computeDepths(e);
    for (var r = t.getEdges().iterator(); r.hasNext(); ) {
      var o = r.next();
      o.setVisited(!0), this.copySymDepths(o);
    }
  }),
  (y_.prototype.computeDepth = function (t) {
    this.clearVisitedEdges();
    var e = this._finder.getEdge();
    e.setEdgeDepths(c_.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
  }),
  (y_.prototype.create = function (t) {
    this.addReachable(t),
      this._finder.findEdge(this._dirEdgeList),
      (this._rightMostCoord = this._finder.getCoordinate());
  }),
  (y_.prototype.findResultEdges = function () {
    for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) {
      var e = t.next();
      e.getDepth(c_.RIGHT) >= 1 &&
        e.getDepth(c_.LEFT) <= 0 &&
        !e.isInteriorAreaEdge() &&
        e.setInResult(!0);
    }
  }),
  (y_.prototype.computeDepths = function (t) {
    var e = new rx(),
      i = new m_(),
      n = t.getNode();
    for (i.addLast(n), e.add(n), t.setVisited(!0); !i.isEmpty(); ) {
      var r = i.removeFirst();
      e.add(r), this.computeNodeDepth(r);
      for (var o = r.getEdges().iterator(); o.hasNext(); ) {
        var a = o.next().getSym();
        if (!a.isVisited()) {
          var s = a.getNode();
          e.contains(s) || (i.addLast(s), e.add(s));
        }
      }
    }
  }),
  (y_.prototype.compareTo = function (t) {
    var e = t;
    return this._rightMostCoord.x < e._rightMostCoord.x
      ? -1
      : this._rightMostCoord.x > e._rightMostCoord.x
      ? 1
      : 0;
  }),
  (y_.prototype.getEnvelope = function () {
    if (null === this._env) {
      for (var t = new fb(), e = this._dirEdgeList.iterator(); e.hasNext(); )
        for (
          var i = e.next().getEdge().getCoordinates(), n = 0;
          n < i.length - 1;
          n++
        )
          t.expandToInclude(i[n]);
      this._env = t;
    }
    return this._env;
  }),
  (y_.prototype.addReachable = function (t) {
    var e = new d_();
    for (e.add(t); !e.empty(); ) {
      var i = e.pop();
      this.add(i, e);
    }
  }),
  (y_.prototype.copySymDepths = function (t) {
    var e = t.getSym();
    e.setDepth(c_.LEFT, t.getDepth(c_.RIGHT)),
      e.setDepth(c_.RIGHT, t.getDepth(c_.LEFT));
  }),
  (y_.prototype.add = function (t, e) {
    t.setVisited(!0), this._nodes.add(t);
    for (var i = t.getEdges().iterator(); i.hasNext(); ) {
      var n = i.next();
      this._dirEdgeList.add(n);
      var r = n.getSym().getNode();
      r.isVisited() || e.push(r);
    }
  }),
  (y_.prototype.getNodes = function () {
    return this._nodes;
  }),
  (y_.prototype.getDirectedEdges = function () {
    return this._dirEdgeList;
  }),
  (y_.prototype.interfaces_ = function () {
    return [jv];
  }),
  (y_.prototype.getClass = function () {
    return y_;
  });
var v_ = function t() {
  if (((this.location = null), 1 === arguments.length)) {
    if (arguments[0] instanceof Array) {
      var e = arguments[0];
      this.init(e.length);
    } else if (Number.isInteger(arguments[0])) {
      var i = arguments[0];
      this.init(1), (this.location[c_.ON] = i);
    } else if (arguments[0] instanceof t) {
      var n = arguments[0];
      if ((this.init(n.location.length), null !== n))
        for (var r = 0; r < this.location.length; r++)
          this.location[r] = n.location[r];
    }
  } else if (3 === arguments.length) {
    var o = arguments[0],
      a = arguments[1],
      s = arguments[2];
    this.init(3),
      (this.location[c_.ON] = o),
      (this.location[c_.LEFT] = a),
      (this.location[c_.RIGHT] = s);
  }
};
(v_.prototype.setAllLocations = function (t) {
  for (var e = 0; e < this.location.length; e++) this.location[e] = t;
}),
  (v_.prototype.isNull = function () {
    for (var t = 0; t < this.location.length; t++)
      if (this.location[t] !== Zv.NONE) return !1;
    return !0;
  }),
  (v_.prototype.setAllLocationsIfNull = function (t) {
    for (var e = 0; e < this.location.length; e++)
      this.location[e] === Zv.NONE && (this.location[e] = t);
  }),
  (v_.prototype.isLine = function () {
    return 1 === this.location.length;
  }),
  (v_.prototype.merge = function (t) {
    if (t.location.length > this.location.length) {
      var e = new Array(3).fill(null);
      (e[c_.ON] = this.location[c_.ON]),
        (e[c_.LEFT] = Zv.NONE),
        (e[c_.RIGHT] = Zv.NONE),
        (this.location = e);
    }
    for (var i = 0; i < this.location.length; i++)
      this.location[i] === Zv.NONE &&
        i < t.location.length &&
        (this.location[i] = t.location[i]);
  }),
  (v_.prototype.getLocations = function () {
    return this.location;
  }),
  (v_.prototype.flip = function () {
    if (this.location.length <= 1) return null;
    var t = this.location[c_.LEFT];
    (this.location[c_.LEFT] = this.location[c_.RIGHT]),
      (this.location[c_.RIGHT] = t);
  }),
  (v_.prototype.toString = function () {
    var t = new eb();
    return (
      this.location.length > 1 &&
        t.append(Zv.toLocationSymbol(this.location[c_.LEFT])),
      t.append(Zv.toLocationSymbol(this.location[c_.ON])),
      this.location.length > 1 &&
        t.append(Zv.toLocationSymbol(this.location[c_.RIGHT])),
      t.toString()
    );
  }),
  (v_.prototype.setLocations = function (t, e, i) {
    (this.location[c_.ON] = t),
      (this.location[c_.LEFT] = e),
      (this.location[c_.RIGHT] = i);
  }),
  (v_.prototype.get = function (t) {
    return t < this.location.length ? this.location[t] : Zv.NONE;
  }),
  (v_.prototype.isArea = function () {
    return this.location.length > 1;
  }),
  (v_.prototype.isAnyNull = function () {
    for (var t = 0; t < this.location.length; t++)
      if (this.location[t] === Zv.NONE) return !0;
    return !1;
  }),
  (v_.prototype.setLocation = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setLocation(c_.ON, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      this.location[e] = i;
    }
  }),
  (v_.prototype.init = function (t) {
    (this.location = new Array(t).fill(null)), this.setAllLocations(Zv.NONE);
  }),
  (v_.prototype.isEqualOnSide = function (t, e) {
    return this.location[e] === t.location[e];
  }),
  (v_.prototype.allPositionsEqual = function (t) {
    for (var e = 0; e < this.location.length; e++)
      if (this.location[e] !== t) return !1;
    return !0;
  }),
  (v_.prototype.interfaces_ = function () {
    return [];
  }),
  (v_.prototype.getClass = function () {
    return v_;
  });
var b_ = function t() {
  if (((this.elt = new Array(2).fill(null)), 1 === arguments.length)) {
    if (Number.isInteger(arguments[0])) {
      var e = arguments[0];
      (this.elt[0] = new v_(e)), (this.elt[1] = new v_(e));
    } else if (arguments[0] instanceof t) {
      var i = arguments[0];
      (this.elt[0] = new v_(i.elt[0])), (this.elt[1] = new v_(i.elt[1]));
    }
  } else if (2 === arguments.length) {
    var n = arguments[0],
      r = arguments[1];
    (this.elt[0] = new v_(Zv.NONE)),
      (this.elt[1] = new v_(Zv.NONE)),
      this.elt[n].setLocation(r);
  } else if (3 === arguments.length) {
    var o = arguments[0],
      a = arguments[1],
      s = arguments[2];
    (this.elt[0] = new v_(o, a, s)), (this.elt[1] = new v_(o, a, s));
  } else if (4 === arguments.length) {
    var l = arguments[0],
      u = arguments[1],
      c = arguments[2],
      h = arguments[3];
    (this.elt[0] = new v_(Zv.NONE, Zv.NONE, Zv.NONE)),
      (this.elt[1] = new v_(Zv.NONE, Zv.NONE, Zv.NONE)),
      this.elt[l].setLocations(u, c, h);
  }
};
(b_.prototype.getGeometryCount = function () {
  var t = 0;
  return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
}),
  (b_.prototype.setAllLocations = function (t, e) {
    this.elt[t].setAllLocations(e);
  }),
  (b_.prototype.isNull = function (t) {
    return this.elt[t].isNull();
  }),
  (b_.prototype.setAllLocationsIfNull = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      this.elt[e].setAllLocationsIfNull(i);
    }
  }),
  (b_.prototype.isLine = function (t) {
    return this.elt[t].isLine();
  }),
  (b_.prototype.merge = function (t) {
    for (var e = this, i = 0; i < 2; i++)
      null === e.elt[i] && null !== t.elt[i]
        ? (e.elt[i] = new v_(t.elt[i]))
        : e.elt[i].merge(t.elt[i]);
  }),
  (b_.prototype.flip = function () {
    this.elt[0].flip(), this.elt[1].flip();
  }),
  (b_.prototype.getLocation = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.elt[t].get(c_.ON);
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      return this.elt[e].get(i);
    }
  }),
  (b_.prototype.toString = function () {
    var t = new eb();
    return (
      null !== this.elt[0] &&
        (t.append("A:"), t.append(this.elt[0].toString())),
      null !== this.elt[1] &&
        (t.append(" B:"), t.append(this.elt[1].toString())),
      t.toString()
    );
  }),
  (b_.prototype.isArea = function () {
    if (0 === arguments.length)
      return this.elt[0].isArea() || this.elt[1].isArea();
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.elt[t].isArea();
    }
  }),
  (b_.prototype.isAnyNull = function (t) {
    return this.elt[t].isAnyNull();
  }),
  (b_.prototype.setLocation = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      this.elt[t].setLocation(c_.ON, e);
    } else if (3 === arguments.length) {
      var i = arguments[0],
        n = arguments[1],
        r = arguments[2];
      this.elt[i].setLocation(n, r);
    }
  }),
  (b_.prototype.isEqualOnSide = function (t, e) {
    return (
      this.elt[0].isEqualOnSide(t.elt[0], e) &&
      this.elt[1].isEqualOnSide(t.elt[1], e)
    );
  }),
  (b_.prototype.allPositionsEqual = function (t, e) {
    return this.elt[t].allPositionsEqual(e);
  }),
  (b_.prototype.toLine = function (t) {
    this.elt[t].isArea() && (this.elt[t] = new v_(this.elt[t].location[0]));
  }),
  (b_.prototype.interfaces_ = function () {
    return [];
  }),
  (b_.prototype.getClass = function () {
    return b_;
  }),
  (b_.toLineLabel = function (t) {
    for (var e = new b_(Zv.NONE), i = 0; i < 2; i++)
      e.setLocation(i, t.getLocation(i));
    return e;
  });
var x_ = function () {
  (this._startDe = null),
    (this._maxNodeDegree = -1),
    (this._edges = new Yb()),
    (this._pts = new Yb()),
    (this._label = new b_(Zv.NONE)),
    (this._ring = null),
    (this._isHole = null),
    (this._shell = null),
    (this._holes = new Yb()),
    (this._geometryFactory = null);
  var t = arguments[0],
    e = arguments[1];
  (this._geometryFactory = e), this.computePoints(t), this.computeRing();
};
(x_.prototype.computeRing = function () {
  if (null !== this._ring) return null;
  for (
    var t = new Array(this._pts.size()).fill(null), e = 0;
    e < this._pts.size();
    e++
  )
    t[e] = this._pts.get(e);
  (this._ring = this._geometryFactory.createLinearRing(t)),
    (this._isHole = Tb.isCCW(this._ring.getCoordinates()));
}),
  (x_.prototype.isIsolated = function () {
    return 1 === this._label.getGeometryCount();
  }),
  (x_.prototype.computePoints = function (t) {
    var e = this;
    this._startDe = t;
    var i = t,
      n = !0;
    do {
      if (null === i) throw new g_("Found null DirectedEdge");
      if (i.getEdgeRing() === e)
        throw new g_(
          "Directed Edge visited twice during ring-building at " +
            i.getCoordinate()
        );
      e._edges.add(i);
      var r = i.getLabel();
      Mb.isTrue(r.isArea()),
        e.mergeLabel(r),
        e.addPoints(i.getEdge(), i.isForward(), n),
        (n = !1),
        e.setEdgeRing(i, e),
        (i = e.getNext(i));
    } while (i !== this._startDe);
  }),
  (x_.prototype.getLinearRing = function () {
    return this._ring;
  }),
  (x_.prototype.getCoordinate = function (t) {
    return this._pts.get(t);
  }),
  (x_.prototype.computeMaxNodeDegree = function () {
    var t = this;
    this._maxNodeDegree = 0;
    var e = this._startDe;
    do {
      var i = e.getNode().getEdges().getOutgoingDegree(t);
      i > t._maxNodeDegree && (t._maxNodeDegree = i), (e = t.getNext(e));
    } while (e !== this._startDe);
    this._maxNodeDegree *= 2;
  }),
  (x_.prototype.addPoints = function (t, e, i) {
    var n = t.getCoordinates();
    if (e) {
      var r = 1;
      i && (r = 0);
      for (var o = r; o < n.length; o++) this._pts.add(n[o]);
    } else {
      var a = n.length - 2;
      i && (a = n.length - 1);
      for (var s = a; s >= 0; s--) this._pts.add(n[s]);
    }
  }),
  (x_.prototype.isHole = function () {
    return this._isHole;
  }),
  (x_.prototype.setInResult = function () {
    var t = this._startDe;
    do {
      t.getEdge().setInResult(!0), (t = t.getNext());
    } while (t !== this._startDe);
  }),
  (x_.prototype.containsPoint = function (t) {
    var e = this.getLinearRing();
    if (!e.getEnvelopeInternal().contains(t)) return !1;
    if (!Tb.isPointInRing(t, e.getCoordinates())) return !1;
    for (var i = this._holes.iterator(); i.hasNext(); ) {
      if (i.next().containsPoint(t)) return !1;
    }
    return !0;
  }),
  (x_.prototype.addHole = function (t) {
    this._holes.add(t);
  }),
  (x_.prototype.isShell = function () {
    return null === this._shell;
  }),
  (x_.prototype.getLabel = function () {
    return this._label;
  }),
  (x_.prototype.getEdges = function () {
    return this._edges;
  }),
  (x_.prototype.getMaxNodeDegree = function () {
    return (
      this._maxNodeDegree < 0 && this.computeMaxNodeDegree(),
      this._maxNodeDegree
    );
  }),
  (x_.prototype.getShell = function () {
    return this._shell;
  }),
  (x_.prototype.mergeLabel = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.mergeLabel(t, 0), this.mergeLabel(t, 1);
    } else if (2 === arguments.length) {
      var e = arguments[1],
        i = arguments[0].getLocation(e, c_.RIGHT);
      if (i === Zv.NONE) return null;
      if (this._label.getLocation(e) === Zv.NONE)
        return this._label.setLocation(e, i), null;
    }
  }),
  (x_.prototype.setShell = function (t) {
    (this._shell = t), null !== t && t.addHole(this);
  }),
  (x_.prototype.toPolygon = function (t) {
    for (
      var e = new Array(this._holes.size()).fill(null), i = 0;
      i < this._holes.size();
      i++
    )
      e[i] = this._holes.get(i).getLinearRing();
    return t.createPolygon(this.getLinearRing(), e);
  }),
  (x_.prototype.interfaces_ = function () {
    return [];
  }),
  (x_.prototype.getClass = function () {
    return x_;
  });
var __ = (function (t) {
    function e() {
      var e = arguments[0],
        i = arguments[1];
      t.call(this, e, i);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.setEdgeRing = function (t, e) {
        t.setMinEdgeRing(e);
      }),
      (e.prototype.getNext = function (t) {
        return t.getNextMin();
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(x_),
  S_ = (function (t) {
    function e() {
      var e = arguments[0],
        i = arguments[1];
      t.call(this, e, i);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.buildMinimalRings = function () {
        var t = new Yb(),
          e = this._startDe;
        do {
          if (null === e.getMinEdgeRing()) {
            var i = new __(e, this._geometryFactory);
            t.add(i);
          }
          e = e.getNext();
        } while (e !== this._startDe);
        return t;
      }),
      (e.prototype.setEdgeRing = function (t, e) {
        t.setEdgeRing(e);
      }),
      (e.prototype.linkDirectedEdgesForMinimalEdgeRings = function () {
        var t = this._startDe;
        do {
          t.getNode().getEdges().linkMinimalDirectedEdges(this),
            (t = t.getNext());
        } while (t !== this._startDe);
      }),
      (e.prototype.getNext = function (t) {
        return t.getNext();
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(x_),
  M_ = function () {
    if (
      ((this._label = null),
      (this._isInResult = !1),
      (this._isCovered = !1),
      (this._isCoveredSet = !1),
      (this._isVisited = !1),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      var t = arguments[0];
      this._label = t;
    }
  };
(M_.prototype.setVisited = function (t) {
  this._isVisited = t;
}),
  (M_.prototype.setInResult = function (t) {
    this._isInResult = t;
  }),
  (M_.prototype.isCovered = function () {
    return this._isCovered;
  }),
  (M_.prototype.isCoveredSet = function () {
    return this._isCoveredSet;
  }),
  (M_.prototype.setLabel = function (t) {
    this._label = t;
  }),
  (M_.prototype.getLabel = function () {
    return this._label;
  }),
  (M_.prototype.setCovered = function (t) {
    (this._isCovered = t), (this._isCoveredSet = !0);
  }),
  (M_.prototype.updateIM = function (t) {
    Mb.isTrue(this._label.getGeometryCount() >= 2, "found partial label"),
      this.computeIM(t);
  }),
  (M_.prototype.isInResult = function () {
    return this._isInResult;
  }),
  (M_.prototype.isVisited = function () {
    return this._isVisited;
  }),
  (M_.prototype.interfaces_ = function () {
    return [];
  }),
  (M_.prototype.getClass = function () {
    return M_;
  });
var C_ = (function (t) {
    function e() {
      t.call(this), (this._coord = null), (this._edges = null);
      var e = arguments[0],
        i = arguments[1];
      (this._coord = e), (this._edges = i), (this._label = new b_(0, Zv.NONE));
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.isIncidentEdgeInResult = function () {
        for (var t = this.getEdges().getEdges().iterator(); t.hasNext(); ) {
          if (t.next().getEdge().isInResult()) return !0;
        }
        return !1;
      }),
      (e.prototype.isIsolated = function () {
        return 1 === this._label.getGeometryCount();
      }),
      (e.prototype.getCoordinate = function () {
        return this._coord;
      }),
      (e.prototype.print = function (t) {
        t.println("node " + this._coord + " lbl: " + this._label);
      }),
      (e.prototype.computeIM = function (t) {}),
      (e.prototype.computeMergedLocation = function (t, e) {
        var i = Zv.NONE;
        if (((i = this._label.getLocation(e)), !t.isNull(e))) {
          var n = t.getLocation(e);
          i !== Zv.BOUNDARY && (i = n);
        }
        return i;
      }),
      (e.prototype.setLabel = function () {
        if (2 !== arguments.length)
          return t.prototype.setLabel.apply(this, arguments);
        var e = arguments[0],
          i = arguments[1];
        null === this._label
          ? (this._label = new b_(e, i))
          : this._label.setLocation(e, i);
      }),
      (e.prototype.getEdges = function () {
        return this._edges;
      }),
      (e.prototype.mergeLabel = function () {
        var t = this;
        if (arguments[0] instanceof e) {
          var i = arguments[0];
          this.mergeLabel(i._label);
        } else if (arguments[0] instanceof b_)
          for (var n = arguments[0], r = 0; r < 2; r++) {
            var o = t.computeMergedLocation(n, r);
            t._label.getLocation(r) === Zv.NONE && t._label.setLocation(r, o);
          }
      }),
      (e.prototype.add = function (t) {
        this._edges.insert(t), t.setNode(this);
      }),
      (e.prototype.setLabelBoundary = function (t) {
        if (null === this._label) return null;
        var e = Zv.NONE;
        null !== this._label && (e = this._label.getLocation(t));
        var i = null;
        if (e === Zv.BOUNDARY) i = Zv.INTERIOR;
        else i = Zv.BOUNDARY;
        this._label.setLocation(t, i);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(M_),
  w_ = function () {
    (this.nodeMap = new hx()), (this.nodeFact = null);
    var t = arguments[0];
    this.nodeFact = t;
  };
(w_.prototype.find = function (t) {
  return this.nodeMap.get(t);
}),
  (w_.prototype.addNode = function () {
    if (arguments[0] instanceof qv) {
      var t = arguments[0],
        e = this.nodeMap.get(t);
      return (
        null === e &&
          ((e = this.nodeFact.createNode(t)), this.nodeMap.put(t, e)),
        e
      );
    }
    if (arguments[0] instanceof C_) {
      var i = arguments[0],
        n = this.nodeMap.get(i.getCoordinate());
      return null === n
        ? (this.nodeMap.put(i.getCoordinate(), i), i)
        : (n.mergeLabel(i), n);
    }
  }),
  (w_.prototype.print = function (t) {
    for (var e = this.iterator(); e.hasNext(); ) {
      e.next().print(t);
    }
  }),
  (w_.prototype.iterator = function () {
    return this.nodeMap.values().iterator();
  }),
  (w_.prototype.values = function () {
    return this.nodeMap.values();
  }),
  (w_.prototype.getBoundaryNodes = function (t) {
    for (var e = new Yb(), i = this.iterator(); i.hasNext(); ) {
      var n = i.next();
      n.getLabel().getLocation(t) === Zv.BOUNDARY && e.add(n);
    }
    return e;
  }),
  (w_.prototype.add = function (t) {
    var e = t.getCoordinate();
    this.addNode(e).add(t);
  }),
  (w_.prototype.interfaces_ = function () {
    return [];
  }),
  (w_.prototype.getClass = function () {
    return w_;
  });
var A_ = function () {},
  E_ = {
    NE: {
      configurable: !0,
    },
    NW: {
      configurable: !0,
    },
    SW: {
      configurable: !0,
    },
    SE: {
      configurable: !0,
    },
  };
(A_.prototype.interfaces_ = function () {
  return [];
}),
  (A_.prototype.getClass = function () {
    return A_;
  }),
  (A_.isNorthern = function (t) {
    return t === A_.NE || t === A_.NW;
  }),
  (A_.isOpposite = function (t, e) {
    return t !== e && 2 === (t - e + 4) % 4;
  }),
  (A_.commonHalfPlane = function (t, e) {
    if (t === e) return t;
    if (2 === (t - e + 4) % 4) return -1;
    var i = t < e ? t : e;
    return 0 === i && 3 === (t > e ? t : e) ? 3 : i;
  }),
  (A_.isInHalfPlane = function (t, e) {
    return e === A_.SE ? t === A_.SE || t === A_.SW : t === e || t === e + 1;
  }),
  (A_.quadrant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
        e = arguments[1];
      if (0 === t && 0 === e)
        throw new Bv(
          "Cannot compute the quadrant for point ( " + t + ", " + e + " )"
        );
      return t >= 0 ? (e >= 0 ? A_.NE : A_.SE) : e >= 0 ? A_.NW : A_.SW;
    }
    if (arguments[0] instanceof qv && arguments[1] instanceof qv) {
      var i = arguments[0],
        n = arguments[1];
      if (n.x === i.x && n.y === i.y)
        throw new Bv(
          "Cannot compute the quadrant for two identical points " + i
        );
      return n.x >= i.x
        ? n.y >= i.y
          ? A_.NE
          : A_.SE
        : n.y >= i.y
        ? A_.NW
        : A_.SW;
    }
  }),
  (E_.NE.get = function () {
    return 0;
  }),
  (E_.NW.get = function () {
    return 1;
  }),
  (E_.SW.get = function () {
    return 2;
  }),
  (E_.SE.get = function () {
    return 3;
  }),
  Object.defineProperties(A_, E_);
var D_ = function () {
  if (
    ((this._edge = null),
    (this._label = null),
    (this._node = null),
    (this._p0 = null),
    (this._p1 = null),
    (this._dx = null),
    (this._dy = null),
    (this._quadrant = null),
    1 === arguments.length)
  ) {
    var t = arguments[0];
    this._edge = t;
  } else if (3 === arguments.length) {
    var e = arguments[0],
      i = arguments[1],
      n = arguments[2];
    (this._edge = e), this.init(i, n), (this._label = null);
  } else if (4 === arguments.length) {
    var r = arguments[0],
      o = arguments[1],
      a = arguments[2],
      s = arguments[3];
    (this._edge = r), this.init(o, a), (this._label = s);
  }
};
(D_.prototype.compareDirection = function (t) {
  return this._dx === t._dx && this._dy === t._dy
    ? 0
    : this._quadrant > t._quadrant
    ? 1
    : this._quadrant < t._quadrant
    ? -1
    : Tb.computeOrientation(t._p0, t._p1, this._p1);
}),
  (D_.prototype.getDy = function () {
    return this._dy;
  }),
  (D_.prototype.getCoordinate = function () {
    return this._p0;
  }),
  (D_.prototype.setNode = function (t) {
    this._node = t;
  }),
  (D_.prototype.print = function (t) {
    var e = Math.atan2(this._dy, this._dx),
      i = this.getClass().getName(),
      n = i.lastIndexOf("."),
      r = i.substring(n + 1);
    t.print(
      "  " +
        r +
        ": " +
        this._p0 +
        " - " +
        this._p1 +
        " " +
        this._quadrant +
        ":" +
        e +
        "   " +
        this._label
    );
  }),
  (D_.prototype.compareTo = function (t) {
    var e = t;
    return this.compareDirection(e);
  }),
  (D_.prototype.getDirectedCoordinate = function () {
    return this._p1;
  }),
  (D_.prototype.getDx = function () {
    return this._dx;
  }),
  (D_.prototype.getLabel = function () {
    return this._label;
  }),
  (D_.prototype.getEdge = function () {
    return this._edge;
  }),
  (D_.prototype.getQuadrant = function () {
    return this._quadrant;
  }),
  (D_.prototype.getNode = function () {
    return this._node;
  }),
  (D_.prototype.toString = function () {
    var t = Math.atan2(this._dy, this._dx),
      e = this.getClass().getName(),
      i = e.lastIndexOf(".");
    return (
      "  " +
      e.substring(i + 1) +
      ": " +
      this._p0 +
      " - " +
      this._p1 +
      " " +
      this._quadrant +
      ":" +
      t +
      "   " +
      this._label
    );
  }),
  (D_.prototype.computeLabel = function (t) {}),
  (D_.prototype.init = function (t, e) {
    (this._p0 = t),
      (this._p1 = e),
      (this._dx = e.x - t.x),
      (this._dy = e.y - t.y),
      (this._quadrant = A_.quadrant(this._dx, this._dy)),
      Mb.isTrue(
        !(0 === this._dx && 0 === this._dy),
        "EdgeEnd with identical endpoints found"
      );
  }),
  (D_.prototype.interfaces_ = function () {
    return [jv];
  }),
  (D_.prototype.getClass = function () {
    return D_;
  });
var T_ = (function (t) {
    function e() {
      var e = arguments[0],
        i = arguments[1];
      if (
        (t.call(this, e),
        (this._isForward = null),
        (this._isInResult = !1),
        (this._isVisited = !1),
        (this._sym = null),
        (this._next = null),
        (this._nextMin = null),
        (this._edgeRing = null),
        (this._minEdgeRing = null),
        (this._depth = [0, -999, -999]),
        (this._isForward = i),
        i)
      )
        this.init(e.getCoordinate(0), e.getCoordinate(1));
      else {
        var n = e.getNumPoints() - 1;
        this.init(e.getCoordinate(n), e.getCoordinate(n - 1));
      }
      this.computeDirectedLabel();
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.getNextMin = function () {
        return this._nextMin;
      }),
      (e.prototype.getDepth = function (t) {
        return this._depth[t];
      }),
      (e.prototype.setVisited = function (t) {
        this._isVisited = t;
      }),
      (e.prototype.computeDirectedLabel = function () {
        (this._label = new b_(this._edge.getLabel())),
          this._isForward || this._label.flip();
      }),
      (e.prototype.getNext = function () {
        return this._next;
      }),
      (e.prototype.setDepth = function (t, e) {
        if (-999 !== this._depth[t] && this._depth[t] !== e)
          throw new g_("assigned depths do not match", this.getCoordinate());
        this._depth[t] = e;
      }),
      (e.prototype.isInteriorAreaEdge = function () {
        for (var t = this, e = !0, i = 0; i < 2; i++)
          (t._label.isArea(i) &&
            t._label.getLocation(i, c_.LEFT) === Zv.INTERIOR &&
            t._label.getLocation(i, c_.RIGHT) === Zv.INTERIOR) ||
            (e = !1);
        return e;
      }),
      (e.prototype.setNextMin = function (t) {
        this._nextMin = t;
      }),
      (e.prototype.print = function (e) {
        t.prototype.print.call(this, e),
          e.print(" " + this._depth[c_.LEFT] + "/" + this._depth[c_.RIGHT]),
          e.print(" (" + this.getDepthDelta() + ")"),
          this._isInResult && e.print(" inResult");
      }),
      (e.prototype.setMinEdgeRing = function (t) {
        this._minEdgeRing = t;
      }),
      (e.prototype.isLineEdge = function () {
        var t = this._label.isLine(0) || this._label.isLine(1),
          e =
            !this._label.isArea(0) ||
            this._label.allPositionsEqual(0, Zv.EXTERIOR),
          i =
            !this._label.isArea(1) ||
            this._label.allPositionsEqual(1, Zv.EXTERIOR);
        return t && e && i;
      }),
      (e.prototype.setEdgeRing = function (t) {
        this._edgeRing = t;
      }),
      (e.prototype.getMinEdgeRing = function () {
        return this._minEdgeRing;
      }),
      (e.prototype.getDepthDelta = function () {
        var t = this._edge.getDepthDelta();
        return this._isForward || (t = -t), t;
      }),
      (e.prototype.setInResult = function (t) {
        this._isInResult = t;
      }),
      (e.prototype.getSym = function () {
        return this._sym;
      }),
      (e.prototype.isForward = function () {
        return this._isForward;
      }),
      (e.prototype.getEdge = function () {
        return this._edge;
      }),
      (e.prototype.printEdge = function (t) {
        this.print(t),
          t.print(" "),
          this._isForward ? this._edge.print(t) : this._edge.printReverse(t);
      }),
      (e.prototype.setSym = function (t) {
        this._sym = t;
      }),
      (e.prototype.setVisitedEdge = function (t) {
        this.setVisited(t), this._sym.setVisited(t);
      }),
      (e.prototype.setEdgeDepths = function (t, e) {
        var i = this.getEdge().getDepthDelta();
        this._isForward || (i = -i);
        var n = 1;
        t === c_.LEFT && (n = -1);
        var r = c_.opposite(t),
          o = e + i * n;
        this.setDepth(t, e), this.setDepth(r, o);
      }),
      (e.prototype.getEdgeRing = function () {
        return this._edgeRing;
      }),
      (e.prototype.isInResult = function () {
        return this._isInResult;
      }),
      (e.prototype.setNext = function (t) {
        this._next = t;
      }),
      (e.prototype.isVisited = function () {
        return this._isVisited;
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.depthFactor = function (t, e) {
        return t === Zv.EXTERIOR && e === Zv.INTERIOR
          ? 1
          : t === Zv.INTERIOR && e === Zv.EXTERIOR
          ? -1
          : 0;
      }),
      e
    );
  })(D_),
  P_ = function () {};
(P_.prototype.createNode = function (t) {
  return new C_(t, null);
}),
  (P_.prototype.interfaces_ = function () {
    return [];
  }),
  (P_.prototype.getClass = function () {
    return P_;
  });
var L_ = function () {
  if (
    ((this._edges = new Yb()),
    (this._nodes = null),
    (this._edgeEndList = new Yb()),
    0 === arguments.length)
  )
    this._nodes = new w_(new P_());
  else if (1 === arguments.length) {
    var t = arguments[0];
    this._nodes = new w_(t);
  }
};
(L_.prototype.printEdges = function (t) {
  t.println("Edges:");
  for (var e = 0; e < this._edges.size(); e++) {
    t.println("edge " + e + ":");
    var i = this._edges.get(e);
    i.print(t), i.eiList.print(t);
  }
}),
  (L_.prototype.find = function (t) {
    return this._nodes.find(t);
  }),
  (L_.prototype.addNode = function () {
    if (arguments[0] instanceof C_) {
      var t = arguments[0];
      return this._nodes.addNode(t);
    }
    if (arguments[0] instanceof qv) {
      var e = arguments[0];
      return this._nodes.addNode(e);
    }
  }),
  (L_.prototype.getNodeIterator = function () {
    return this._nodes.iterator();
  }),
  (L_.prototype.linkResultDirectedEdges = function () {
    for (var t = this._nodes.iterator(); t.hasNext(); ) {
      t.next().getEdges().linkResultDirectedEdges();
    }
  }),
  (L_.prototype.debugPrintln = function (t) {
    pb.out.println(t);
  }),
  (L_.prototype.isBoundaryNode = function (t, e) {
    var i = this._nodes.find(e);
    if (null === i) return !1;
    var n = i.getLabel();
    return null !== n && n.getLocation(t) === Zv.BOUNDARY;
  }),
  (L_.prototype.linkAllDirectedEdges = function () {
    for (var t = this._nodes.iterator(); t.hasNext(); ) {
      t.next().getEdges().linkAllDirectedEdges();
    }
  }),
  (L_.prototype.matchInSameDirection = function (t, e, i, n) {
    return (
      !!t.equals(i) &&
      Tb.computeOrientation(t, e, n) === Tb.COLLINEAR &&
      A_.quadrant(t, e) === A_.quadrant(i, n)
    );
  }),
  (L_.prototype.getEdgeEnds = function () {
    return this._edgeEndList;
  }),
  (L_.prototype.debugPrint = function (t) {
    pb.out.print(t);
  }),
  (L_.prototype.getEdgeIterator = function () {
    return this._edges.iterator();
  }),
  (L_.prototype.findEdgeInSameDirection = function (t, e) {
    for (var i = this, n = 0; n < this._edges.size(); n++) {
      var r = i._edges.get(n),
        o = r.getCoordinates();
      if (i.matchInSameDirection(t, e, o[0], o[1])) return r;
      if (i.matchInSameDirection(t, e, o[o.length - 1], o[o.length - 2]))
        return r;
    }
    return null;
  }),
  (L_.prototype.insertEdge = function (t) {
    this._edges.add(t);
  }),
  (L_.prototype.findEdgeEnd = function (t) {
    for (var e = this.getEdgeEnds().iterator(); e.hasNext(); ) {
      var i = e.next();
      if (i.getEdge() === t) return i;
    }
    return null;
  }),
  (L_.prototype.addEdges = function (t) {
    for (var e = this, i = t.iterator(); i.hasNext(); ) {
      var n = i.next();
      e._edges.add(n);
      var r = new T_(n, !0),
        o = new T_(n, !1);
      r.setSym(o), o.setSym(r), e.add(r), e.add(o);
    }
  }),
  (L_.prototype.add = function (t) {
    this._nodes.add(t), this._edgeEndList.add(t);
  }),
  (L_.prototype.getNodes = function () {
    return this._nodes.values();
  }),
  (L_.prototype.findEdge = function (t, e) {
    for (var i = 0; i < this._edges.size(); i++) {
      var n = this._edges.get(i),
        r = n.getCoordinates();
      if (t.equals(r[0]) && e.equals(r[1])) return n;
    }
    return null;
  }),
  (L_.prototype.interfaces_ = function () {
    return [];
  }),
  (L_.prototype.getClass = function () {
    return L_;
  }),
  (L_.linkResultDirectedEdges = function (t) {
    for (var e = t.iterator(); e.hasNext(); ) {
      e.next().getEdges().linkResultDirectedEdges();
    }
  });
var I_ = function () {
  (this._geometryFactory = null), (this._shellList = new Yb());
  var t = arguments[0];
  this._geometryFactory = t;
};
(I_.prototype.sortShellsAndHoles = function (t, e, i) {
  for (var n = t.iterator(); n.hasNext(); ) {
    var r = n.next();
    r.isHole() ? i.add(r) : e.add(r);
  }
}),
  (I_.prototype.computePolygons = function (t) {
    for (var e = new Yb(), i = t.iterator(); i.hasNext(); ) {
      var n = i.next().toPolygon(this._geometryFactory);
      e.add(n);
    }
    return e;
  }),
  (I_.prototype.placeFreeHoles = function (t, e) {
    for (var i = e.iterator(); i.hasNext(); ) {
      var n = i.next();
      if (null === n.getShell()) {
        var r = this.findEdgeRingContaining(n, t);
        if (null === r)
          throw new g_("unable to assign hole to a shell", n.getCoordinate(0));
        n.setShell(r);
      }
    }
  }),
  (I_.prototype.buildMinimalEdgeRings = function (t, e, i) {
    for (var n = new Yb(), r = t.iterator(); r.hasNext(); ) {
      var o = r.next();
      if (o.getMaxNodeDegree() > 2) {
        o.linkDirectedEdgesForMinimalEdgeRings();
        var a = o.buildMinimalRings(),
          s = this.findShell(a);
        null !== s ? (this.placePolygonHoles(s, a), e.add(s)) : i.addAll(a);
      } else n.add(o);
    }
    return n;
  }),
  (I_.prototype.containsPoint = function (t) {
    for (var e = this._shellList.iterator(); e.hasNext(); ) {
      if (e.next().containsPoint(t)) return !0;
    }
    return !1;
  }),
  (I_.prototype.buildMaximalEdgeRings = function (t) {
    for (var e = new Yb(), i = t.iterator(); i.hasNext(); ) {
      var n = i.next();
      if (n.isInResult() && n.getLabel().isArea() && null === n.getEdgeRing()) {
        var r = new S_(n, this._geometryFactory);
        e.add(r), r.setInResult();
      }
    }
    return e;
  }),
  (I_.prototype.placePolygonHoles = function (t, e) {
    for (var i = e.iterator(); i.hasNext(); ) {
      var n = i.next();
      n.isHole() && n.setShell(t);
    }
  }),
  (I_.prototype.getPolygons = function () {
    return this.computePolygons(this._shellList);
  }),
  (I_.prototype.findEdgeRingContaining = function (t, e) {
    for (
      var i = t.getLinearRing(),
        n = i.getEnvelopeInternal(),
        r = i.getCoordinateN(0),
        o = null,
        a = null,
        s = e.iterator();
      s.hasNext();

    ) {
      var l = s.next(),
        u = l.getLinearRing(),
        c = u.getEnvelopeInternal();
      null !== o && (a = o.getLinearRing().getEnvelopeInternal());
      var h = !1;
      c.contains(n) && Tb.isPointInRing(r, u.getCoordinates()) && (h = !0),
        h && (null === o || a.contains(c)) && (o = l);
    }
    return o;
  }),
  (I_.prototype.findShell = function (t) {
    for (var e = 0, i = null, n = t.iterator(); n.hasNext(); ) {
      var r = n.next();
      r.isHole() || ((i = r), e++);
    }
    return Mb.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), i;
  }),
  (I_.prototype.add = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.add(t.getEdgeEnds(), t.getNodes());
    } else if (2 === arguments.length) {
      var e = arguments[0];
      L_.linkResultDirectedEdges(arguments[1]);
      var i = this.buildMaximalEdgeRings(e),
        n = new Yb(),
        r = this.buildMinimalEdgeRings(i, this._shellList, n);
      this.sortShellsAndHoles(r, this._shellList, n),
        this.placeFreeHoles(this._shellList, n);
    }
  }),
  (I_.prototype.interfaces_ = function () {
    return [];
  }),
  (I_.prototype.getClass = function () {
    return I_;
  });
var N_ = function () {};
(N_.prototype.getBounds = function () {}),
  (N_.prototype.interfaces_ = function () {
    return [];
  }),
  (N_.prototype.getClass = function () {
    return N_;
  });
var R_ = function () {
  (this._bounds = null), (this._item = null);
  var t = arguments[0],
    e = arguments[1];
  (this._bounds = t), (this._item = e);
};
(R_.prototype.getItem = function () {
  return this._item;
}),
  (R_.prototype.getBounds = function () {
    return this._bounds;
  }),
  (R_.prototype.interfaces_ = function () {
    return [N_, Wv];
  }),
  (R_.prototype.getClass = function () {
    return R_;
  });
var O_ = function () {
  (this._size = null),
    (this._items = null),
    (this._size = 0),
    (this._items = new Yb()),
    this._items.add(null);
};
(O_.prototype.poll = function () {
  if (this.isEmpty()) return null;
  var t = this._items.get(1);
  return (
    this._items.set(1, this._items.get(this._size)),
    (this._size -= 1),
    this.reorder(1),
    t
  );
}),
  (O_.prototype.size = function () {
    return this._size;
  }),
  (O_.prototype.reorder = function (t) {
    for (
      var e = this, i = null, n = this._items.get(t);
      2 * t <= this._size &&
      ((i = 2 * t) !== e._size &&
        e._items.get(i + 1).compareTo(e._items.get(i)) < 0 &&
        i++,
      e._items.get(i).compareTo(n) < 0);
      t = i
    )
      e._items.set(t, e._items.get(i));
    this._items.set(t, n);
  }),
  (O_.prototype.clear = function () {
    (this._size = 0), this._items.clear();
  }),
  (O_.prototype.isEmpty = function () {
    return 0 === this._size;
  }),
  (O_.prototype.add = function (t) {
    this._items.add(null), (this._size += 1);
    var e = this._size;
    for (
      this._items.set(0, t);
      t.compareTo(this._items.get(Math.trunc(e / 2))) < 0;
      e /= 2
    )
      this._items.set(e, this._items.get(Math.trunc(e / 2)));
    this._items.set(e, t);
  }),
  (O_.prototype.interfaces_ = function () {
    return [];
  }),
  (O_.prototype.getClass = function () {
    return O_;
  });
var F_ = function () {};
(F_.prototype.visitItem = function (t) {}),
  (F_.prototype.interfaces_ = function () {
    return [];
  }),
  (F_.prototype.getClass = function () {
    return F_;
  });
var z_ = function () {};
(z_.prototype.insert = function (t, e) {}),
  (z_.prototype.remove = function (t, e) {}),
  (z_.prototype.query = function () {}),
  (z_.prototype.interfaces_ = function () {
    return [];
  }),
  (z_.prototype.getClass = function () {
    return z_;
  });
var k_ = function () {
    if (
      ((this._childBoundables = new Yb()),
      (this._bounds = null),
      (this._level = null),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      var t = arguments[0];
      this._level = t;
    }
  },
  B_ = {
    serialVersionUID: {
      configurable: !0,
    },
  };
(k_.prototype.getLevel = function () {
  return this._level;
}),
  (k_.prototype.size = function () {
    return this._childBoundables.size();
  }),
  (k_.prototype.getChildBoundables = function () {
    return this._childBoundables;
  }),
  (k_.prototype.addChildBoundable = function (t) {
    Mb.isTrue(null === this._bounds), this._childBoundables.add(t);
  }),
  (k_.prototype.isEmpty = function () {
    return this._childBoundables.isEmpty();
  }),
  (k_.prototype.getBounds = function () {
    return (
      null === this._bounds && (this._bounds = this.computeBounds()),
      this._bounds
    );
  }),
  (k_.prototype.interfaces_ = function () {
    return [N_, Wv];
  }),
  (k_.prototype.getClass = function () {
    return k_;
  }),
  (B_.serialVersionUID.get = function () {
    return 0x5a1e55ec41369800;
  }),
  Object.defineProperties(k_, B_);
var G_ = function () {};
(G_.reverseOrder = function () {
  return {
    compare: function (t, e) {
      return e.compareTo(t);
    },
  };
}),
  (G_.min = function (t) {
    return G_.sort(t), t.get(0);
  }),
  (G_.sort = function (t, e) {
    var i = t.toArray();
    e ? mx.sort(i, e) : mx.sort(i);
    for (var n = t.iterator(), r = 0, o = i.length; r < o; r++)
      n.next(), n.set(i[r]);
  }),
  (G_.singletonList = function (t) {
    var e = new Yb();
    return e.add(t), e;
  });
var U_ = function () {
  (this._boundable1 = null),
    (this._boundable2 = null),
    (this._distance = null),
    (this._itemDistance = null);
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2];
  (this._boundable1 = t),
    (this._boundable2 = e),
    (this._itemDistance = i),
    (this._distance = this.distance());
};
(U_.prototype.expandToQueue = function (t, e) {
  var i = U_.isComposite(this._boundable1),
    n = U_.isComposite(this._boundable2);
  if (i && n)
    return U_.area(this._boundable1) > U_.area(this._boundable2)
      ? (this.expand(this._boundable1, this._boundable2, t, e), null)
      : (this.expand(this._boundable2, this._boundable1, t, e), null);
  if (i) return this.expand(this._boundable1, this._boundable2, t, e), null;
  if (n) return this.expand(this._boundable2, this._boundable1, t, e), null;
  throw new Bv("neither boundable is composite");
}),
  (U_.prototype.isLeaves = function () {
    return !(
      U_.isComposite(this._boundable1) || U_.isComposite(this._boundable2)
    );
  }),
  (U_.prototype.compareTo = function (t) {
    var e = t;
    return this._distance < e._distance
      ? -1
      : this._distance > e._distance
      ? 1
      : 0;
  }),
  (U_.prototype.expand = function (t, e, i, n) {
    for (var r = t.getChildBoundables().iterator(); r.hasNext(); ) {
      var o = r.next(),
        a = new U_(o, e, this._itemDistance);
      a.getDistance() < n && i.add(a);
    }
  }),
  (U_.prototype.getBoundable = function (t) {
    return 0 === t ? this._boundable1 : this._boundable2;
  }),
  (U_.prototype.getDistance = function () {
    return this._distance;
  }),
  (U_.prototype.distance = function () {
    return this.isLeaves()
      ? this._itemDistance.distance(this._boundable1, this._boundable2)
      : this._boundable1.getBounds().distance(this._boundable2.getBounds());
  }),
  (U_.prototype.interfaces_ = function () {
    return [jv];
  }),
  (U_.prototype.getClass = function () {
    return U_;
  }),
  (U_.area = function (t) {
    return t.getBounds().getArea();
  }),
  (U_.isComposite = function (t) {
    return t instanceof k_;
  });
var j_ = function t() {
    if (
      ((this._root = null),
      (this._built = !1),
      (this._itemBoundables = new Yb()),
      (this._nodeCapacity = null),
      0 === arguments.length)
    ) {
      var e = t.DEFAULT_NODE_CAPACITY;
      this._nodeCapacity = e;
    } else if (1 === arguments.length) {
      var i = arguments[0];
      Mb.isTrue(i > 1, "Node capacity must be greater than 1"),
        (this._nodeCapacity = i);
    }
  },
  H_ = {
    IntersectsOp: {
      configurable: !0,
    },
    serialVersionUID: {
      configurable: !0,
    },
    DEFAULT_NODE_CAPACITY: {
      configurable: !0,
    },
  };
(j_.prototype.getNodeCapacity = function () {
  return this._nodeCapacity;
}),
  (j_.prototype.lastNode = function (t) {
    return t.get(t.size() - 1);
  }),
  (j_.prototype.size = function () {
    if (0 === arguments.length)
      return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
    if (1 === arguments.length) {
      for (
        var t = 0, e = arguments[0].getChildBoundables().iterator();
        e.hasNext();

      ) {
        var i = e.next();
        i instanceof k_ ? (t += this.size(i)) : i instanceof R_ && (t += 1);
      }
      return t;
    }
  }),
  (j_.prototype.removeItem = function (t, e) {
    for (var i = null, n = t.getChildBoundables().iterator(); n.hasNext(); ) {
      var r = n.next();
      r instanceof R_ && r.getItem() === e && (i = r);
    }
    return null !== i && (t.getChildBoundables().remove(i), !0);
  }),
  (j_.prototype.itemsTree = function () {
    if (0 === arguments.length) {
      this.build();
      var t = this.itemsTree(this._root);
      return null === t ? new Yb() : t;
    }
    if (1 === arguments.length) {
      for (
        var e = arguments[0],
          i = new Yb(),
          n = e.getChildBoundables().iterator();
        n.hasNext();

      ) {
        var r = n.next();
        if (r instanceof k_) {
          var o = this.itemsTree(r);
          null !== o && i.add(o);
        } else r instanceof R_ ? i.add(r.getItem()) : Mb.shouldNeverReachHere();
      }
      return i.size() <= 0 ? null : i;
    }
  }),
  (j_.prototype.insert = function (t, e) {
    Mb.isTrue(
      !this._built,
      "Cannot insert items into an STR packed R-tree after it has been built."
    ),
      this._itemBoundables.add(new R_(t, e));
  }),
  (j_.prototype.boundablesAtLevel = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = new Yb();
      return this.boundablesAtLevel(t, this._root, e), e;
    }
    if (3 === arguments.length) {
      var i = arguments[0],
        n = arguments[1],
        r = arguments[2];
      if ((Mb.isTrue(i > -2), n.getLevel() === i)) return r.add(n), null;
      for (var o = n.getChildBoundables().iterator(); o.hasNext(); ) {
        var a = o.next();
        a instanceof k_
          ? this.boundablesAtLevel(i, a, r)
          : (Mb.isTrue(a instanceof R_), -1 === i && r.add(a));
      }
      return null;
    }
  }),
  (j_.prototype.query = function () {
    var t = this;
    if (1 === arguments.length) {
      var e = arguments[0];
      this.build();
      var i = new Yb();
      return (
        this.isEmpty() ||
          (this.getIntersectsOp().intersects(this._root.getBounds(), e) &&
            this.query(e, this._root, i)),
        i
      );
    }
    if (2 === arguments.length) {
      var n = arguments[0],
        r = arguments[1];
      if ((this.build(), this.isEmpty())) return null;
      this.getIntersectsOp().intersects(this._root.getBounds(), n) &&
        this.query(n, this._root, r);
    } else if (3 === arguments.length)
      if (
        Kv(arguments[2], F_) &&
        arguments[0] instanceof Object &&
        arguments[1] instanceof k_
      )
        for (
          var o = arguments[0],
            a = arguments[2],
            s = arguments[1].getChildBoundables(),
            l = 0;
          l < s.size();
          l++
        ) {
          var u = s.get(l);
          t.getIntersectsOp().intersects(u.getBounds(), o) &&
            (u instanceof k_
              ? t.query(o, u, a)
              : u instanceof R_
              ? a.visitItem(u.getItem())
              : Mb.shouldNeverReachHere());
        }
      else if (
        Kv(arguments[2], Wb) &&
        arguments[0] instanceof Object &&
        arguments[1] instanceof k_
      )
        for (
          var c = arguments[0],
            h = arguments[2],
            p = arguments[1].getChildBoundables(),
            d = 0;
          d < p.size();
          d++
        ) {
          var f = p.get(d);
          t.getIntersectsOp().intersects(f.getBounds(), c) &&
            (f instanceof k_
              ? t.query(c, f, h)
              : f instanceof R_
              ? h.add(f.getItem())
              : Mb.shouldNeverReachHere());
        }
  }),
  (j_.prototype.build = function () {
    if (this._built) return null;
    (this._root = this._itemBoundables.isEmpty()
      ? this.createNode(0)
      : this.createHigherLevels(this._itemBoundables, -1)),
      (this._itemBoundables = null),
      (this._built = !0);
  }),
  (j_.prototype.getRoot = function () {
    return this.build(), this._root;
  }),
  (j_.prototype.remove = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      return (
        this.build(),
        !!this.getIntersectsOp().intersects(this._root.getBounds(), t) &&
          this.remove(t, this._root, e)
      );
    }
    if (3 === arguments.length) {
      var i = arguments[0],
        n = arguments[1],
        r = arguments[2],
        o = this.removeItem(n, r);
      if (o) return !0;
      for (var a = null, s = n.getChildBoundables().iterator(); s.hasNext(); ) {
        var l = s.next();
        if (
          this.getIntersectsOp().intersects(l.getBounds(), i) &&
          l instanceof k_ &&
          (o = this.remove(i, l, r))
        ) {
          a = l;
          break;
        }
      }
      return (
        null !== a &&
          a.getChildBoundables().isEmpty() &&
          n.getChildBoundables().remove(a),
        o
      );
    }
  }),
  (j_.prototype.createHigherLevels = function (t, e) {
    Mb.isTrue(!t.isEmpty());
    var i = this.createParentBoundables(t, e + 1);
    return 1 === i.size() ? i.get(0) : this.createHigherLevels(i, e + 1);
  }),
  (j_.prototype.depth = function () {
    if (0 === arguments.length)
      return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
    if (1 === arguments.length) {
      for (
        var t = 0, e = arguments[0].getChildBoundables().iterator();
        e.hasNext();

      ) {
        var i = e.next();
        if (i instanceof k_) {
          var n = this.depth(i);
          n > t && (t = n);
        }
      }
      return t + 1;
    }
  }),
  (j_.prototype.createParentBoundables = function (t, e) {
    var i = this;
    Mb.isTrue(!t.isEmpty());
    var n = new Yb();
    n.add(this.createNode(e));
    var r = new Yb(t);
    G_.sort(r, this.getComparator());
    for (var o = r.iterator(); o.hasNext(); ) {
      var a = o.next();
      i.lastNode(n).getChildBoundables().size() === i.getNodeCapacity() &&
        n.add(i.createNode(e)),
        i.lastNode(n).addChildBoundable(a);
    }
    return n;
  }),
  (j_.prototype.isEmpty = function () {
    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
  }),
  (j_.prototype.interfaces_ = function () {
    return [Wv];
  }),
  (j_.prototype.getClass = function () {
    return j_;
  }),
  (j_.compareDoubles = function (t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }),
  (H_.IntersectsOp.get = function () {
    return V_;
  }),
  (H_.serialVersionUID.get = function () {
    return -0x35ef64c82d4c5400;
  }),
  (H_.DEFAULT_NODE_CAPACITY.get = function () {
    return 10;
  }),
  Object.defineProperties(j_, H_);
var V_ = function () {},
  W_ = function () {};
(W_.prototype.distance = function (t, e) {}),
  (W_.prototype.interfaces_ = function () {
    return [];
  }),
  (W_.prototype.getClass = function () {
    return W_;
  });
var q_ = (function (t) {
    function e(i) {
      (i = i || e.DEFAULT_NODE_CAPACITY), t.call(this, i);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      STRtreeNode: {
        configurable: !0,
      },
      serialVersionUID: {
        configurable: !0,
      },
      xComparator: {
        configurable: !0,
      },
      yComparator: {
        configurable: !0,
      },
      intersectsOp: {
        configurable: !0,
      },
      DEFAULT_NODE_CAPACITY: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.createParentBoundablesFromVerticalSlices = function (t, e) {
        Mb.isTrue(t.length > 0);
        for (var i = new Yb(), n = 0; n < t.length; n++)
          i.addAll(this.createParentBoundablesFromVerticalSlice(t[n], e));
        return i;
      }),
      (e.prototype.createNode = function (t) {
        return new Y_(t);
      }),
      (e.prototype.size = function () {
        return 0 === arguments.length
          ? t.prototype.size.call(this)
          : t.prototype.size.apply(this, arguments);
      }),
      (e.prototype.insert = function () {
        if (2 !== arguments.length)
          return t.prototype.insert.apply(this, arguments);
        var e = arguments[0],
          i = arguments[1];
        if (e.isNull()) return null;
        t.prototype.insert.call(this, e, i);
      }),
      (e.prototype.getIntersectsOp = function () {
        return e.intersectsOp;
      }),
      (e.prototype.verticalSlices = function (t, e) {
        for (
          var i = Math.trunc(Math.ceil(t.size() / e)),
            n = new Array(e).fill(null),
            r = t.iterator(),
            o = 0;
          o < e;
          o++
        ) {
          n[o] = new Yb();
          for (var a = 0; r.hasNext() && a < i; ) {
            var s = r.next();
            n[o].add(s), a++;
          }
        }
        return n;
      }),
      (e.prototype.query = function () {
        if (1 === arguments.length) {
          var e = arguments[0];
          return t.prototype.query.call(this, e);
        }
        if (2 === arguments.length) {
          var i = arguments[0],
            n = arguments[1];
          t.prototype.query.call(this, i, n);
        } else if (3 === arguments.length)
          if (
            Kv(arguments[2], F_) &&
            arguments[0] instanceof Object &&
            arguments[1] instanceof k_
          ) {
            var r = arguments[0],
              o = arguments[1],
              a = arguments[2];
            t.prototype.query.call(this, r, o, a);
          } else if (
            Kv(arguments[2], Wb) &&
            arguments[0] instanceof Object &&
            arguments[1] instanceof k_
          ) {
            var s = arguments[0],
              l = arguments[1],
              u = arguments[2];
            t.prototype.query.call(this, s, l, u);
          }
      }),
      (e.prototype.getComparator = function () {
        return e.yComparator;
      }),
      (e.prototype.createParentBoundablesFromVerticalSlice = function (e, i) {
        return t.prototype.createParentBoundables.call(this, e, i);
      }),
      (e.prototype.remove = function () {
        if (2 === arguments.length) {
          var e = arguments[0],
            i = arguments[1];
          return t.prototype.remove.call(this, e, i);
        }
        return t.prototype.remove.apply(this, arguments);
      }),
      (e.prototype.depth = function () {
        return 0 === arguments.length
          ? t.prototype.depth.call(this)
          : t.prototype.depth.apply(this, arguments);
      }),
      (e.prototype.createParentBoundables = function (t, i) {
        Mb.isTrue(!t.isEmpty());
        var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
          r = new Yb(t);
        G_.sort(r, e.xComparator);
        var o = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));
        return this.createParentBoundablesFromVerticalSlices(o, i);
      }),
      (e.prototype.nearestNeighbour = function () {
        if (1 === arguments.length) {
          if (Kv(arguments[0], W_)) {
            var t = arguments[0],
              i = new U_(this.getRoot(), this.getRoot(), t);
            return this.nearestNeighbour(i);
          }
          if (arguments[0] instanceof U_) {
            var n = arguments[0];
            return this.nearestNeighbour(n, Gv.POSITIVE_INFINITY);
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof e && Kv(arguments[1], W_)) {
            var r = arguments[0],
              o = arguments[1],
              a = new U_(this.getRoot(), r.getRoot(), o);
            return this.nearestNeighbour(a);
          }
          if (arguments[0] instanceof U_ && "number" == typeof arguments[1]) {
            var s = arguments[0],
              l = arguments[1],
              u = null,
              c = new O_();
            for (c.add(s); !c.isEmpty() && l > 0; ) {
              var h = c.poll(),
                p = h.getDistance();
              if (p >= l) break;
              h.isLeaves() ? ((l = p), (u = h)) : h.expandToQueue(c, l);
            }
            return [u.getBoundable(0).getItem(), u.getBoundable(1).getItem()];
          }
        } else if (3 === arguments.length) {
          var d = arguments[2],
            f = new R_(arguments[0], arguments[1]),
            g = new U_(this.getRoot(), f, d);
          return this.nearestNeighbour(g)[0];
        }
      }),
      (e.prototype.interfaces_ = function () {
        return [z_, Wv];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.centreX = function (t) {
        return e.avg(t.getMinX(), t.getMaxX());
      }),
      (e.avg = function (t, e) {
        return (t + e) / 2;
      }),
      (e.centreY = function (t) {
        return e.avg(t.getMinY(), t.getMaxY());
      }),
      (i.STRtreeNode.get = function () {
        return Y_;
      }),
      (i.serialVersionUID.get = function () {
        return 0x39920f7d5f261e0;
      }),
      (i.xComparator.get = function () {
        return {
          interfaces_: function () {
            return [Vv];
          },
          compare: function (i, n) {
            return t.compareDoubles(
              e.centreX(i.getBounds()),
              e.centreX(n.getBounds())
            );
          },
        };
      }),
      (i.yComparator.get = function () {
        return {
          interfaces_: function () {
            return [Vv];
          },
          compare: function (i, n) {
            return t.compareDoubles(
              e.centreY(i.getBounds()),
              e.centreY(n.getBounds())
            );
          },
        };
      }),
      (i.intersectsOp.get = function () {
        return {
          interfaces_: function () {
            return [t.IntersectsOp];
          },
          intersects: function (t, e) {
            return t.intersects(e);
          },
        };
      }),
      (i.DEFAULT_NODE_CAPACITY.get = function () {
        return 10;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(j_),
  Y_ = (function (t) {
    function e() {
      var e = arguments[0];
      t.call(this, e);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.computeBounds = function () {
        for (
          var t = null, e = this.getChildBoundables().iterator();
          e.hasNext();

        ) {
          var i = e.next();
          null === t
            ? (t = new fb(i.getBounds()))
            : t.expandToInclude(i.getBounds());
        }
        return t;
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(k_),
  X_ = function () {};
(X_.prototype.interfaces_ = function () {
  return [];
}),
  (X_.prototype.getClass = function () {
    return X_;
  }),
  (X_.relativeSign = function (t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }),
  (X_.compare = function (t, e, i) {
    if (e.equals2D(i)) return 0;
    var n = X_.relativeSign(e.x, i.x),
      r = X_.relativeSign(e.y, i.y);
    switch (t) {
      case 0:
        return X_.compareValue(n, r);
      case 1:
        return X_.compareValue(r, n);
      case 2:
        return X_.compareValue(r, -n);
      case 3:
        return X_.compareValue(-n, r);
      case 4:
        return X_.compareValue(-n, -r);
      case 5:
        return X_.compareValue(-r, -n);
      case 6:
        return X_.compareValue(-r, n);
      case 7:
        return X_.compareValue(n, -r);
    }
    return Mb.shouldNeverReachHere("invalid octant value"), 0;
  }),
  (X_.compareValue = function (t, e) {
    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
  });
var Q_ = function () {
  (this._segString = null),
    (this.coord = null),
    (this.segmentIndex = null),
    (this._segmentOctant = null),
    (this._isInterior = null);
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2],
    n = arguments[3];
  (this._segString = t),
    (this.coord = new qv(e)),
    (this.segmentIndex = i),
    (this._segmentOctant = n),
    (this._isInterior = !e.equals2D(t.getCoordinate(i)));
};
(Q_.prototype.getCoordinate = function () {
  return this.coord;
}),
  (Q_.prototype.print = function (t) {
    t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
  }),
  (Q_.prototype.compareTo = function (t) {
    var e = t;
    return this.segmentIndex < e.segmentIndex
      ? -1
      : this.segmentIndex > e.segmentIndex
      ? 1
      : this.coord.equals2D(e.coord)
      ? 0
      : X_.compare(this._segmentOctant, this.coord, e.coord);
  }),
  (Q_.prototype.isEndPoint = function (t) {
    return (
      (0 === this.segmentIndex && !this._isInterior) || this.segmentIndex === t
    );
  }),
  (Q_.prototype.isInterior = function () {
    return this._isInterior;
  }),
  (Q_.prototype.interfaces_ = function () {
    return [jv];
  }),
  (Q_.prototype.getClass = function () {
    return Q_;
  });
var Z_ = function () {
  (this._nodeMap = new hx()), (this._edge = null);
  var t = arguments[0];
  this._edge = t;
};
(Z_.prototype.getSplitCoordinates = function () {
  var t = new Qb();
  this.addEndpoints();
  for (var e = this.iterator(), i = e.next(); e.hasNext(); ) {
    var n = e.next();
    this.addEdgeCoordinates(i, n, t), (i = n);
  }
  return t.toCoordinateArray();
}),
  (Z_.prototype.addCollapsedNodes = function () {
    var t = new Yb();
    this.findCollapsesFromInsertedNodes(t),
      this.findCollapsesFromExistingVertices(t);
    for (var e = t.iterator(); e.hasNext(); ) {
      var i = e.next().intValue();
      this.add(this._edge.getCoordinate(i), i);
    }
  }),
  (Z_.prototype.print = function (t) {
    t.println("Intersections:");
    for (var e = this.iterator(); e.hasNext(); ) {
      e.next().print(t);
    }
  }),
  (Z_.prototype.findCollapsesFromExistingVertices = function (t) {
    for (var e = 0; e < this._edge.size() - 2; e++) {
      var i = this._edge.getCoordinate(e),
        n = this._edge.getCoordinate(e + 2);
      i.equals2D(n) && t.add(new ib(e + 1));
    }
  }),
  (Z_.prototype.addEdgeCoordinates = function (t, e, i) {
    var n = this._edge.getCoordinate(e.segmentIndex),
      r = e.isInterior() || !e.coord.equals2D(n);
    i.add(new qv(t.coord), !1);
    for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++)
      i.add(this._edge.getCoordinate(o));
    r && i.add(new qv(e.coord));
  }),
  (Z_.prototype.iterator = function () {
    return this._nodeMap.values().iterator();
  }),
  (Z_.prototype.addSplitEdges = function (t) {
    this.addEndpoints(), this.addCollapsedNodes();
    for (var e = this.iterator(), i = e.next(); e.hasNext(); ) {
      var n = e.next(),
        r = this.createSplitEdge(i, n);
      t.add(r), (i = n);
    }
  }),
  (Z_.prototype.findCollapseIndex = function (t, e, i) {
    if (!t.coord.equals2D(e.coord)) return !1;
    var n = e.segmentIndex - t.segmentIndex;
    return e.isInterior() || n--, 1 === n && ((i[0] = t.segmentIndex + 1), !0);
  }),
  (Z_.prototype.findCollapsesFromInsertedNodes = function (t) {
    for (
      var e = new Array(1).fill(null), i = this.iterator(), n = i.next();
      i.hasNext();

    ) {
      var r = i.next();
      this.findCollapseIndex(n, r, e) && t.add(new ib(e[0])), (n = r);
    }
  }),
  (Z_.prototype.getEdge = function () {
    return this._edge;
  }),
  (Z_.prototype.addEndpoints = function () {
    var t = this._edge.size() - 1;
    this.add(this._edge.getCoordinate(0), 0),
      this.add(this._edge.getCoordinate(t), t);
  }),
  (Z_.prototype.createSplitEdge = function (t, e) {
    var i = e.segmentIndex - t.segmentIndex + 2,
      n = this._edge.getCoordinate(e.segmentIndex),
      r = e.isInterior() || !e.coord.equals2D(n);
    r || i--;
    var o = new Array(i).fill(null),
      a = 0;
    o[a++] = new qv(t.coord);
    for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++)
      o[a++] = this._edge.getCoordinate(s);
    return r && (o[a] = new qv(e.coord)), new tS(o, this._edge.getData());
  }),
  (Z_.prototype.add = function (t, e) {
    var i = new Q_(this._edge, t, e, this._edge.getSegmentOctant(e)),
      n = this._nodeMap.get(i);
    return null !== n
      ? (Mb.isTrue(
          n.coord.equals2D(t),
          "Found equal nodes with different coordinates"
        ),
        n)
      : (this._nodeMap.put(i, i), i);
  }),
  (Z_.prototype.checkSplitEdgesCorrectness = function (t) {
    var e = this._edge.getCoordinates(),
      i = t.get(0).getCoordinate(0);
    if (!i.equals2D(e[0])) throw new _b("bad split edge start point at " + i);
    var n = t.get(t.size() - 1).getCoordinates(),
      r = n[n.length - 1];
    if (!r.equals2D(e[e.length - 1]))
      throw new _b("bad split edge end point at " + r);
  }),
  (Z_.prototype.interfaces_ = function () {
    return [];
  }),
  (Z_.prototype.getClass = function () {
    return Z_;
  });
var J_ = function () {};
(J_.prototype.interfaces_ = function () {
  return [];
}),
  (J_.prototype.getClass = function () {
    return J_;
  }),
  (J_.octant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
        e = arguments[1];
      if (0 === t && 0 === e)
        throw new Bv(
          "Cannot compute the octant for point ( " + t + ", " + e + " )"
        );
      var i = Math.abs(t),
        n = Math.abs(e);
      return t >= 0
        ? e >= 0
          ? i >= n
            ? 0
            : 1
          : i >= n
          ? 7
          : 6
        : e >= 0
        ? i >= n
          ? 3
          : 2
        : i >= n
        ? 4
        : 5;
    }
    if (arguments[0] instanceof qv && arguments[1] instanceof qv) {
      var r = arguments[0],
        o = arguments[1],
        a = o.x - r.x,
        s = o.y - r.y;
      if (0 === a && 0 === s)
        throw new Bv("Cannot compute the octant for two identical points " + r);
      return J_.octant(a, s);
    }
  });
var K_ = function () {};
(K_.prototype.getCoordinates = function () {}),
  (K_.prototype.size = function () {}),
  (K_.prototype.getCoordinate = function (t) {}),
  (K_.prototype.isClosed = function () {}),
  (K_.prototype.setData = function (t) {}),
  (K_.prototype.getData = function () {}),
  (K_.prototype.interfaces_ = function () {
    return [];
  }),
  (K_.prototype.getClass = function () {
    return K_;
  });
var $_ = function () {};
($_.prototype.addIntersection = function (t, e) {}),
  ($_.prototype.interfaces_ = function () {
    return [K_];
  }),
  ($_.prototype.getClass = function () {
    return $_;
  });
var tS = function () {
  (this._nodeList = new Z_(this)), (this._pts = null), (this._data = null);
  var t = arguments[0],
    e = arguments[1];
  (this._pts = t), (this._data = e);
};
(tS.prototype.getCoordinates = function () {
  return this._pts;
}),
  (tS.prototype.size = function () {
    return this._pts.length;
  }),
  (tS.prototype.getCoordinate = function (t) {
    return this._pts[t];
  }),
  (tS.prototype.isClosed = function () {
    return this._pts[0].equals(this._pts[this._pts.length - 1]);
  }),
  (tS.prototype.getSegmentOctant = function (t) {
    return t === this._pts.length - 1
      ? -1
      : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
  }),
  (tS.prototype.setData = function (t) {
    this._data = t;
  }),
  (tS.prototype.safeOctant = function (t, e) {
    return t.equals2D(e) ? 0 : J_.octant(t, e);
  }),
  (tS.prototype.getData = function () {
    return this._data;
  }),
  (tS.prototype.addIntersection = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      this.addIntersectionNode(t, e);
    } else if (4 === arguments.length) {
      var i = arguments[1],
        n = arguments[3],
        r = new qv(arguments[0].getIntersection(n));
      this.addIntersection(r, i);
    }
  }),
  (tS.prototype.toString = function () {
    return xb.toLineString(new Yx(this._pts));
  }),
  (tS.prototype.getNodeList = function () {
    return this._nodeList;
  }),
  (tS.prototype.addIntersectionNode = function (t, e) {
    var i = e,
      n = i + 1;
    if (n < this._pts.length) {
      var r = this._pts[n];
      t.equals2D(r) && (i = n);
    }
    return this._nodeList.add(t, i);
  }),
  (tS.prototype.addIntersections = function (t, e, i) {
    for (var n = 0; n < t.getIntersectionNum(); n++)
      this.addIntersection(t, e, i, n);
  }),
  (tS.prototype.interfaces_ = function () {
    return [$_];
  }),
  (tS.prototype.getClass = function () {
    return tS;
  }),
  (tS.getNodedSubstrings = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = new Yb();
      return tS.getNodedSubstrings(t, e), e;
    }
    if (2 === arguments.length)
      for (var i = arguments[1], n = arguments[0].iterator(); n.hasNext(); ) {
        n.next().getNodeList().addSplitEdges(i);
      }
  });
var eS = function () {
    if (((this.p0 = null), (this.p1 = null), 0 === arguments.length))
      (this.p0 = new qv()), (this.p1 = new qv());
    else if (1 === arguments.length) {
      var t = arguments[0];
      (this.p0 = new qv(t.p0)), (this.p1 = new qv(t.p1));
    } else if (2 === arguments.length)
      (this.p0 = arguments[0]), (this.p1 = arguments[1]);
    else if (4 === arguments.length) {
      var e = arguments[0],
        i = arguments[1],
        n = arguments[2],
        r = arguments[3];
      (this.p0 = new qv(e, i)), (this.p1 = new qv(n, r));
    }
  },
  iS = {
    serialVersionUID: {
      configurable: !0,
    },
  };
(eS.prototype.minX = function () {
  return Math.min(this.p0.x, this.p1.x);
}),
  (eS.prototype.orientationIndex = function () {
    if (arguments[0] instanceof eS) {
      var t = arguments[0],
        e = Tb.orientationIndex(this.p0, this.p1, t.p0),
        i = Tb.orientationIndex(this.p0, this.p1, t.p1);
      return (e >= 0 && i >= 0) || (e <= 0 && i <= 0) ? Math.max(e, i) : 0;
    }
    if (arguments[0] instanceof qv) {
      var n = arguments[0];
      return Tb.orientationIndex(this.p0, this.p1, n);
    }
  }),
  (eS.prototype.toGeometry = function (t) {
    return t.createLineString([this.p0, this.p1]);
  }),
  (eS.prototype.isVertical = function () {
    return this.p0.x === this.p1.x;
  }),
  (eS.prototype.equals = function (t) {
    if (!(t instanceof eS)) return !1;
    var e = t;
    return this.p0.equals(e.p0) && this.p1.equals(e.p1);
  }),
  (eS.prototype.intersection = function (t) {
    var e = new Ab();
    return (
      e.computeIntersection(this.p0, this.p1, t.p0, t.p1),
      e.hasIntersection() ? e.getIntersection(0) : null
    );
  }),
  (eS.prototype.project = function () {
    if (arguments[0] instanceof qv) {
      var t = arguments[0];
      if (t.equals(this.p0) || t.equals(this.p1)) return new qv(t);
      var e = this.projectionFactor(t),
        i = new qv();
      return (
        (i.x = this.p0.x + e * (this.p1.x - this.p0.x)),
        (i.y = this.p0.y + e * (this.p1.y - this.p0.y)),
        i
      );
    }
    if (arguments[0] instanceof eS) {
      var n = arguments[0],
        r = this.projectionFactor(n.p0),
        o = this.projectionFactor(n.p1);
      if (r >= 1 && o >= 1) return null;
      if (r <= 0 && o <= 0) return null;
      var a = this.project(n.p0);
      r < 0 && (a = this.p0), r > 1 && (a = this.p1);
      var s = this.project(n.p1);
      return o < 0 && (s = this.p0), o > 1 && (s = this.p1), new eS(a, s);
    }
  }),
  (eS.prototype.normalize = function () {
    this.p1.compareTo(this.p0) < 0 && this.reverse();
  }),
  (eS.prototype.angle = function () {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
  }),
  (eS.prototype.getCoordinate = function (t) {
    return 0 === t ? this.p0 : this.p1;
  }),
  (eS.prototype.distancePerpendicular = function (t) {
    return Tb.distancePointLinePerpendicular(t, this.p0, this.p1);
  }),
  (eS.prototype.minY = function () {
    return Math.min(this.p0.y, this.p1.y);
  }),
  (eS.prototype.midPoint = function () {
    return eS.midPoint(this.p0, this.p1);
  }),
  (eS.prototype.projectionFactor = function (t) {
    if (t.equals(this.p0)) return 0;
    if (t.equals(this.p1)) return 1;
    var e = this.p1.x - this.p0.x,
      i = this.p1.y - this.p0.y,
      n = e * e + i * i;
    return n <= 0
      ? Gv.NaN
      : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * i) / n;
  }),
  (eS.prototype.closestPoints = function (t) {
    var e = this.intersection(t);
    if (null !== e) return [e, e];
    var i = new Array(2).fill(null),
      n = Gv.MAX_VALUE,
      r = null,
      o = this.closestPoint(t.p0);
    (n = o.distance(t.p0)), (i[0] = o), (i[1] = t.p0);
    var a = this.closestPoint(t.p1);
    (r = a.distance(t.p1)) < n && ((n = r), (i[0] = a), (i[1] = t.p1));
    var s = t.closestPoint(this.p0);
    (r = s.distance(this.p0)) < n && ((n = r), (i[0] = this.p0), (i[1] = s));
    var l = t.closestPoint(this.p1);
    return (
      (r = l.distance(this.p1)) < n && ((n = r), (i[0] = this.p1), (i[1] = l)),
      i
    );
  }),
  (eS.prototype.closestPoint = function (t) {
    var e = this.projectionFactor(t);
    return e > 0 && e < 1
      ? this.project(t)
      : this.p0.distance(t) < this.p1.distance(t)
      ? this.p0
      : this.p1;
  }),
  (eS.prototype.maxX = function () {
    return Math.max(this.p0.x, this.p1.x);
  }),
  (eS.prototype.getLength = function () {
    return this.p0.distance(this.p1);
  }),
  (eS.prototype.compareTo = function (t) {
    var e = t,
      i = this.p0.compareTo(e.p0);
    return 0 !== i ? i : this.p1.compareTo(e.p1);
  }),
  (eS.prototype.reverse = function () {
    var t = this.p0;
    (this.p0 = this.p1), (this.p1 = t);
  }),
  (eS.prototype.equalsTopo = function (t) {
    return (
      this.p0.equals(t.p0) &&
      (this.p1.equals(t.p1) || this.p0.equals(t.p1)) &&
      this.p1.equals(t.p0)
    );
  }),
  (eS.prototype.lineIntersection = function (t) {
    try {
      return db.intersection(this.p0, this.p1, t.p0, t.p1);
    } catch (e) {
      if (!(e instanceof hb)) throw e;
    }
    return null;
  }),
  (eS.prototype.maxY = function () {
    return Math.max(this.p0.y, this.p1.y);
  }),
  (eS.prototype.pointAlongOffset = function (t, e) {
    var i = this.p0.x + t * (this.p1.x - this.p0.x),
      n = this.p0.y + t * (this.p1.y - this.p0.y),
      r = this.p1.x - this.p0.x,
      o = this.p1.y - this.p0.y,
      a = Math.sqrt(r * r + o * o),
      s = 0,
      l = 0;
    if (0 !== e) {
      if (a <= 0)
        throw new Error("Cannot compute offset from zero-length line segment");
      (s = (e * r) / a), (l = (e * o) / a);
    }
    return new qv(i - l, n + s);
  }),
  (eS.prototype.setCoordinates = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setCoordinates(t.p0, t.p1);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      (this.p0.x = e.x),
        (this.p0.y = e.y),
        (this.p1.x = i.x),
        (this.p1.y = i.y);
    }
  }),
  (eS.prototype.segmentFraction = function (t) {
    var e = this.projectionFactor(t);
    return e < 0 ? (e = 0) : (e > 1 || Gv.isNaN(e)) && (e = 1), e;
  }),
  (eS.prototype.toString = function () {
    return (
      "LINESTRING( " +
      this.p0.x +
      " " +
      this.p0.y +
      ", " +
      this.p1.x +
      " " +
      this.p1.y +
      ")"
    );
  }),
  (eS.prototype.isHorizontal = function () {
    return this.p0.y === this.p1.y;
  }),
  (eS.prototype.distance = function () {
    if (arguments[0] instanceof eS) {
      var t = arguments[0];
      return Tb.distanceLineLine(this.p0, this.p1, t.p0, t.p1);
    }
    if (arguments[0] instanceof qv) {
      var e = arguments[0];
      return Tb.distancePointLine(e, this.p0, this.p1);
    }
  }),
  (eS.prototype.pointAlong = function (t) {
    var e = new qv();
    return (
      (e.x = this.p0.x + t * (this.p1.x - this.p0.x)),
      (e.y = this.p0.y + t * (this.p1.y - this.p0.y)),
      e
    );
  }),
  (eS.prototype.hashCode = function () {
    var t = Gv.doubleToLongBits(this.p0.x);
    t ^= 31 * Gv.doubleToLongBits(this.p0.y);
    var e = Math.trunc(t) ^ Math.trunc(t >> 32),
      i = Gv.doubleToLongBits(this.p1.x);
    return (
      (i ^= 31 * Gv.doubleToLongBits(this.p1.y)),
      e ^ (Math.trunc(i) ^ Math.trunc(i >> 32))
    );
  }),
  (eS.prototype.interfaces_ = function () {
    return [jv, Wv];
  }),
  (eS.prototype.getClass = function () {
    return eS;
  }),
  (eS.midPoint = function (t, e) {
    return new qv((t.x + e.x) / 2, (t.y + e.y) / 2);
  }),
  (iS.serialVersionUID.get = function () {
    return 0x2d2172135f411c00;
  }),
  Object.defineProperties(eS, iS);
var nS = function () {
  (this.tempEnv1 = new fb()),
    (this.tempEnv2 = new fb()),
    (this._overlapSeg1 = new eS()),
    (this._overlapSeg2 = new eS());
};
(nS.prototype.overlap = function () {
  if (2 === arguments.length);
  else if (4 === arguments.length) {
    var t = arguments[1],
      e = arguments[2],
      i = arguments[3];
    arguments[0].getLineSegment(t, this._overlapSeg1),
      e.getLineSegment(i, this._overlapSeg2),
      this.overlap(this._overlapSeg1, this._overlapSeg2);
  }
}),
  (nS.prototype.interfaces_ = function () {
    return [];
  }),
  (nS.prototype.getClass = function () {
    return nS;
  });
var rS = function () {
  (this._pts = null),
    (this._start = null),
    (this._end = null),
    (this._env = null),
    (this._context = null),
    (this._id = null);
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2],
    n = arguments[3];
  (this._pts = t), (this._start = e), (this._end = i), (this._context = n);
};
(rS.prototype.getLineSegment = function (t, e) {
  (e.p0 = this._pts[t]), (e.p1 = this._pts[t + 1]);
}),
  (rS.prototype.computeSelect = function (t, e, i, n) {
    var r = this._pts[e],
      o = this._pts[i];
    if ((n.tempEnv1.init(r, o), i - e == 1)) return n.select(this, e), null;
    if (!t.intersects(n.tempEnv1)) return null;
    var a = Math.trunc((e + i) / 2);
    e < a && this.computeSelect(t, e, a, n),
      a < i && this.computeSelect(t, a, i, n);
  }),
  (rS.prototype.getCoordinates = function () {
    for (
      var t = new Array(this._end - this._start + 1).fill(null),
        e = 0,
        i = this._start;
      i <= this._end;
      i++
    )
      t[e++] = this._pts[i];
    return t;
  }),
  (rS.prototype.computeOverlaps = function (t, e) {
    this.computeOverlapsInternal(
      this._start,
      this._end,
      t,
      t._start,
      t._end,
      e
    );
  }),
  (rS.prototype.setId = function (t) {
    this._id = t;
  }),
  (rS.prototype.select = function (t, e) {
    this.computeSelect(t, this._start, this._end, e);
  }),
  (rS.prototype.getEnvelope = function () {
    if (null === this._env) {
      var t = this._pts[this._start],
        e = this._pts[this._end];
      this._env = new fb(t, e);
    }
    return this._env;
  }),
  (rS.prototype.getEndIndex = function () {
    return this._end;
  }),
  (rS.prototype.getStartIndex = function () {
    return this._start;
  }),
  (rS.prototype.getContext = function () {
    return this._context;
  }),
  (rS.prototype.getId = function () {
    return this._id;
  }),
  (rS.prototype.computeOverlapsInternal = function (t, e, i, n, r, o) {
    var a = this._pts[t],
      s = this._pts[e],
      l = i._pts[n],
      u = i._pts[r];
    if (e - t == 1 && r - n == 1) return o.overlap(this, t, i, n), null;
    if (
      (o.tempEnv1.init(a, s),
      o.tempEnv2.init(l, u),
      !o.tempEnv1.intersects(o.tempEnv2))
    )
      return null;
    var c = Math.trunc((t + e) / 2),
      h = Math.trunc((n + r) / 2);
    t < c &&
      (n < h && this.computeOverlapsInternal(t, c, i, n, h, o),
      h < r && this.computeOverlapsInternal(t, c, i, h, r, o)),
      c < e &&
        (n < h && this.computeOverlapsInternal(c, e, i, n, h, o),
        h < r && this.computeOverlapsInternal(c, e, i, h, r, o));
  }),
  (rS.prototype.interfaces_ = function () {
    return [];
  }),
  (rS.prototype.getClass = function () {
    return rS;
  });
var oS = function () {};
(oS.prototype.interfaces_ = function () {
  return [];
}),
  (oS.prototype.getClass = function () {
    return oS;
  }),
  (oS.getChainStartIndices = function (t) {
    var e = 0,
      i = new Yb();
    i.add(new ib(e));
    do {
      var n = oS.findChainEnd(t, e);
      i.add(new ib(n)), (e = n);
    } while (e < t.length - 1);
    return oS.toIntArray(i);
  }),
  (oS.findChainEnd = function (t, e) {
    for (var i = e; i < t.length - 1 && t[i].equals2D(t[i + 1]); ) i++;
    if (i >= t.length - 1) return t.length - 1;
    for (var n = A_.quadrant(t[i], t[i + 1]), r = e + 1; r < t.length; ) {
      if (!t[r - 1].equals2D(t[r]))
        if (A_.quadrant(t[r - 1], t[r]) !== n) break;
      r++;
    }
    return r - 1;
  }),
  (oS.getChains = function () {
    if (1 === arguments.length) return oS.getChains(arguments[0], null);
    if (2 === arguments.length) {
      for (
        var t = arguments[0],
          e = arguments[1],
          i = new Yb(),
          n = oS.getChainStartIndices(t),
          r = 0;
        r < n.length - 1;
        r++
      ) {
        var o = new rS(t, n[r], n[r + 1], e);
        i.add(o);
      }
      return i;
    }
  }),
  (oS.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++)
      e[i] = t.get(i).intValue();
    return e;
  });
var aS = function () {};
(aS.prototype.computeNodes = function (t) {}),
  (aS.prototype.getNodedSubstrings = function () {}),
  (aS.prototype.interfaces_ = function () {
    return [];
  }),
  (aS.prototype.getClass = function () {
    return aS;
  });
var sS = function () {
  if (((this._segInt = null), 0 === arguments.length));
  else if (1 === arguments.length) {
    var t = arguments[0];
    this.setSegmentIntersector(t);
  }
};
(sS.prototype.setSegmentIntersector = function (t) {
  this._segInt = t;
}),
  (sS.prototype.interfaces_ = function () {
    return [aS];
  }),
  (sS.prototype.getClass = function () {
    return sS;
  });
var lS = (function (t) {
    function e(e) {
      e ? t.call(this, e) : t.call(this),
        (this._monoChains = new Yb()),
        (this._index = new q_()),
        (this._idCounter = 0),
        (this._nodedSegStrings = null),
        (this._nOverlaps = 0);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var i = {
      SegmentOverlapAction: {
        configurable: !0,
      },
    };
    return (
      (e.prototype.getMonotoneChains = function () {
        return this._monoChains;
      }),
      (e.prototype.getNodedSubstrings = function () {
        return tS.getNodedSubstrings(this._nodedSegStrings);
      }),
      (e.prototype.getIndex = function () {
        return this._index;
      }),
      (e.prototype.add = function (t) {
        for (
          var e = this, i = oS.getChains(t.getCoordinates(), t).iterator();
          i.hasNext();

        ) {
          var n = i.next();
          n.setId(e._idCounter++),
            e._index.insert(n.getEnvelope(), n),
            e._monoChains.add(n);
        }
      }),
      (e.prototype.computeNodes = function (t) {
        this._nodedSegStrings = t;
        for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
        this.intersectChains();
      }),
      (e.prototype.intersectChains = function () {
        for (
          var t = this,
            e = new uS(this._segInt),
            i = this._monoChains.iterator();
          i.hasNext();

        )
          for (
            var n = i.next(), r = t._index.query(n.getEnvelope()).iterator();
            r.hasNext();

          ) {
            var o = r.next();
            if (
              (o.getId() > n.getId() &&
                (n.computeOverlaps(o, e), t._nOverlaps++),
              t._segInt.isDone())
            )
              return null;
          }
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (i.SegmentOverlapAction.get = function () {
        return uS;
      }),
      Object.defineProperties(e, i),
      e
    );
  })(sS),
  uS = (function (t) {
    function e() {
      t.call(this), (this._si = null);
      var e = arguments[0];
      this._si = e;
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.overlap = function () {
        if (4 !== arguments.length)
          return t.prototype.overlap.apply(this, arguments);
        var e = arguments[1],
          i = arguments[2],
          n = arguments[3],
          r = arguments[0].getContext(),
          o = i.getContext();
        this._si.processIntersections(r, e, o, n);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(nS),
  cS = function t() {
    if (
      ((this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS),
      (this._endCapStyle = t.CAP_ROUND),
      (this._joinStyle = t.JOIN_ROUND),
      (this._mitreLimit = t.DEFAULT_MITRE_LIMIT),
      (this._isSingleSided = !1),
      (this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      var e = arguments[0];
      this.setQuadrantSegments(e);
    } else if (2 === arguments.length) {
      var i = arguments[0],
        n = arguments[1];
      this.setQuadrantSegments(i), this.setEndCapStyle(n);
    } else if (4 === arguments.length) {
      var r = arguments[0],
        o = arguments[1],
        a = arguments[2],
        s = arguments[3];
      this.setQuadrantSegments(r),
        this.setEndCapStyle(o),
        this.setJoinStyle(a),
        this.setMitreLimit(s);
    }
  },
  hS = {
    CAP_ROUND: {
      configurable: !0,
    },
    CAP_FLAT: {
      configurable: !0,
    },
    CAP_SQUARE: {
      configurable: !0,
    },
    JOIN_ROUND: {
      configurable: !0,
    },
    JOIN_MITRE: {
      configurable: !0,
    },
    JOIN_BEVEL: {
      configurable: !0,
    },
    DEFAULT_QUADRANT_SEGMENTS: {
      configurable: !0,
    },
    DEFAULT_MITRE_LIMIT: {
      configurable: !0,
    },
    DEFAULT_SIMPLIFY_FACTOR: {
      configurable: !0,
    },
  };
(cS.prototype.getEndCapStyle = function () {
  return this._endCapStyle;
}),
  (cS.prototype.isSingleSided = function () {
    return this._isSingleSided;
  }),
  (cS.prototype.setQuadrantSegments = function (t) {
    (this._quadrantSegments = t),
      0 === this._quadrantSegments && (this._joinStyle = cS.JOIN_BEVEL),
      this._quadrantSegments < 0 &&
        ((this._joinStyle = cS.JOIN_MITRE),
        (this._mitreLimit = Math.abs(this._quadrantSegments))),
      t <= 0 && (this._quadrantSegments = 1),
      this._joinStyle !== cS.JOIN_ROUND &&
        (this._quadrantSegments = cS.DEFAULT_QUADRANT_SEGMENTS);
  }),
  (cS.prototype.getJoinStyle = function () {
    return this._joinStyle;
  }),
  (cS.prototype.setJoinStyle = function (t) {
    this._joinStyle = t;
  }),
  (cS.prototype.setSimplifyFactor = function (t) {
    this._simplifyFactor = t < 0 ? 0 : t;
  }),
  (cS.prototype.getSimplifyFactor = function () {
    return this._simplifyFactor;
  }),
  (cS.prototype.getQuadrantSegments = function () {
    return this._quadrantSegments;
  }),
  (cS.prototype.setEndCapStyle = function (t) {
    this._endCapStyle = t;
  }),
  (cS.prototype.getMitreLimit = function () {
    return this._mitreLimit;
  }),
  (cS.prototype.setMitreLimit = function (t) {
    this._mitreLimit = t;
  }),
  (cS.prototype.setSingleSided = function (t) {
    this._isSingleSided = t;
  }),
  (cS.prototype.interfaces_ = function () {
    return [];
  }),
  (cS.prototype.getClass = function () {
    return cS;
  }),
  (cS.bufferDistanceError = function (t) {
    var e = Math.PI / 2 / t;
    return 1 - Math.cos(e / 2);
  }),
  (hS.CAP_ROUND.get = function () {
    return 1;
  }),
  (hS.CAP_FLAT.get = function () {
    return 2;
  }),
  (hS.CAP_SQUARE.get = function () {
    return 3;
  }),
  (hS.JOIN_ROUND.get = function () {
    return 1;
  }),
  (hS.JOIN_MITRE.get = function () {
    return 2;
  }),
  (hS.JOIN_BEVEL.get = function () {
    return 3;
  }),
  (hS.DEFAULT_QUADRANT_SEGMENTS.get = function () {
    return 8;
  }),
  (hS.DEFAULT_MITRE_LIMIT.get = function () {
    return 5;
  }),
  (hS.DEFAULT_SIMPLIFY_FACTOR.get = function () {
    return 0.01;
  }),
  Object.defineProperties(cS, hS);
var pS = function (t) {
    (this._distanceTol = null),
      (this._isDeleted = null),
      (this._angleOrientation = Tb.COUNTERCLOCKWISE),
      (this._inputLine = t || null);
  },
  dS = {
    INIT: {
      configurable: !0,
    },
    DELETE: {
      configurable: !0,
    },
    KEEP: {
      configurable: !0,
    },
    NUM_PTS_TO_CHECK: {
      configurable: !0,
    },
  };
(pS.prototype.isDeletable = function (t, e, i, n) {
  var r = this._inputLine[t],
    o = this._inputLine[e],
    a = this._inputLine[i];
  return (
    !!this.isConcave(r, o, a) &&
    !!this.isShallow(r, o, a, n) &&
    this.isShallowSampled(r, o, t, i, n)
  );
}),
  (pS.prototype.deleteShallowConcavities = function () {
    for (
      var t = this,
        e = 1,
        i = this.findNextNonDeletedIndex(e),
        n = this.findNextNonDeletedIndex(i),
        r = !1;
      n < this._inputLine.length;

    ) {
      var o = !1;
      t.isDeletable(e, i, n, t._distanceTol) &&
        ((t._isDeleted[i] = pS.DELETE), (o = !0), (r = !0)),
        (e = o ? n : i),
        (i = t.findNextNonDeletedIndex(e)),
        (n = t.findNextNonDeletedIndex(i));
    }
    return r;
  }),
  (pS.prototype.isShallowConcavity = function (t, e, i, n) {
    return (
      Tb.computeOrientation(t, e, i) === this._angleOrientation &&
      Tb.distancePointLine(e, t, i) < n
    );
  }),
  (pS.prototype.isShallowSampled = function (t, e, i, n, r) {
    var o = Math.trunc((n - i) / pS.NUM_PTS_TO_CHECK);
    o <= 0 && (o = 1);
    for (var a = i; a < n; a += o)
      if (!this.isShallow(t, e, this._inputLine[a], r)) return !1;
    return !0;
  }),
  (pS.prototype.isConcave = function (t, e, i) {
    return Tb.computeOrientation(t, e, i) === this._angleOrientation;
  }),
  (pS.prototype.simplify = function (t) {
    (this._distanceTol = Math.abs(t)),
      t < 0 && (this._angleOrientation = Tb.CLOCKWISE),
      (this._isDeleted = new Array(this._inputLine.length).fill(null));
    var e = !1;
    do {
      e = this.deleteShallowConcavities();
    } while (e);
    return this.collapseLine();
  }),
  (pS.prototype.findNextNonDeletedIndex = function (t) {
    for (
      var e = t + 1;
      e < this._inputLine.length && this._isDeleted[e] === pS.DELETE;

    )
      e++;
    return e;
  }),
  (pS.prototype.isShallow = function (t, e, i, n) {
    return Tb.distancePointLine(e, t, i) < n;
  }),
  (pS.prototype.collapseLine = function () {
    for (var t = new Qb(), e = 0; e < this._inputLine.length; e++)
      this._isDeleted[e] !== pS.DELETE && t.add(this._inputLine[e]);
    return t.toCoordinateArray();
  }),
  (pS.prototype.interfaces_ = function () {
    return [];
  }),
  (pS.prototype.getClass = function () {
    return pS;
  }),
  (pS.simplify = function (t, e) {
    return new pS(t).simplify(e);
  }),
  (dS.INIT.get = function () {
    return 0;
  }),
  (dS.DELETE.get = function () {
    return 1;
  }),
  (dS.KEEP.get = function () {
    return 1;
  }),
  (dS.NUM_PTS_TO_CHECK.get = function () {
    return 10;
  }),
  Object.defineProperties(pS, dS);
var fS = function () {
    (this._ptList = null),
      (this._precisionModel = null),
      (this._minimimVertexDistance = 0),
      (this._ptList = new Yb());
  },
  gS = {
    COORDINATE_ARRAY_TYPE: {
      configurable: !0,
    },
  };
(fS.prototype.getCoordinates = function () {
  return this._ptList.toArray(fS.COORDINATE_ARRAY_TYPE);
}),
  (fS.prototype.setPrecisionModel = function (t) {
    this._precisionModel = t;
  }),
  (fS.prototype.addPt = function (t) {
    var e = new qv(t);
    if ((this._precisionModel.makePrecise(e), this.isRedundant(e))) return null;
    this._ptList.add(e);
  }),
  (fS.prototype.revere = function () {}),
  (fS.prototype.addPts = function (t, e) {
    if (e) for (var i = 0; i < t.length; i++) this.addPt(t[i]);
    else for (var n = t.length - 1; n >= 0; n--) this.addPt(t[n]);
  }),
  (fS.prototype.isRedundant = function (t) {
    if (this._ptList.size() < 1) return !1;
    var e = this._ptList.get(this._ptList.size() - 1);
    return t.distance(e) < this._minimimVertexDistance;
  }),
  (fS.prototype.toString = function () {
    return new i_().createLineString(this.getCoordinates()).toString();
  }),
  (fS.prototype.closeRing = function () {
    if (this._ptList.size() < 1) return null;
    var t = new qv(this._ptList.get(0)),
      e = this._ptList.get(this._ptList.size() - 1);
    if (t.equals(e)) return null;
    this._ptList.add(t);
  }),
  (fS.prototype.setMinimumVertexDistance = function (t) {
    this._minimimVertexDistance = t;
  }),
  (fS.prototype.interfaces_ = function () {
    return [];
  }),
  (fS.prototype.getClass = function () {
    return fS;
  }),
  (gS.COORDINATE_ARRAY_TYPE.get = function () {
    return new Array(0).fill(null);
  }),
  Object.defineProperties(fS, gS);
var mS = function () {},
  yS = {
    PI_TIMES_2: {
      configurable: !0,
    },
    PI_OVER_2: {
      configurable: !0,
    },
    PI_OVER_4: {
      configurable: !0,
    },
    COUNTERCLOCKWISE: {
      configurable: !0,
    },
    CLOCKWISE: {
      configurable: !0,
    },
    NONE: {
      configurable: !0,
    },
  };
(mS.prototype.interfaces_ = function () {
  return [];
}),
  (mS.prototype.getClass = function () {
    return mS;
  }),
  (mS.toDegrees = function (t) {
    return (180 * t) / Math.PI;
  }),
  (mS.normalize = function (t) {
    for (; t > Math.PI; ) t -= mS.PI_TIMES_2;
    for (; t <= -Math.PI; ) t += mS.PI_TIMES_2;
    return t;
  }),
  (mS.angle = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return Math.atan2(t.y, t.x);
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1],
        n = i.x - e.x,
        r = i.y - e.y;
      return Math.atan2(r, n);
    }
  }),
  (mS.isAcute = function (t, e, i) {
    var n = t.x - e.x,
      r = t.y - e.y;
    return n * (i.x - e.x) + r * (i.y - e.y) > 0;
  }),
  (mS.isObtuse = function (t, e, i) {
    var n = t.x - e.x,
      r = t.y - e.y;
    return n * (i.x - e.x) + r * (i.y - e.y) < 0;
  }),
  (mS.interiorAngle = function (t, e, i) {
    var n = mS.angle(e, t),
      r = mS.angle(e, i);
    return Math.abs(r - n);
  }),
  (mS.normalizePositive = function (t) {
    if (t < 0) {
      for (; t < 0; ) t += mS.PI_TIMES_2;
      t >= mS.PI_TIMES_2 && (t = 0);
    } else {
      for (; t >= mS.PI_TIMES_2; ) t -= mS.PI_TIMES_2;
      t < 0 && (t = 0);
    }
    return t;
  }),
  (mS.angleBetween = function (t, e, i) {
    var n = mS.angle(e, t),
      r = mS.angle(e, i);
    return mS.diff(n, r);
  }),
  (mS.diff = function (t, e) {
    var i = null;
    return (i = t < e ? e - t : t - e) > Math.PI && (i = 2 * Math.PI - i), i;
  }),
  (mS.toRadians = function (t) {
    return (t * Math.PI) / 180;
  }),
  (mS.getTurn = function (t, e) {
    var i = Math.sin(e - t);
    return i > 0 ? mS.COUNTERCLOCKWISE : i < 0 ? mS.CLOCKWISE : mS.NONE;
  }),
  (mS.angleBetweenOriented = function (t, e, i) {
    var n = mS.angle(e, t),
      r = mS.angle(e, i) - n;
    return r <= -Math.PI
      ? r + mS.PI_TIMES_2
      : r > Math.PI
      ? r - mS.PI_TIMES_2
      : r;
  }),
  (yS.PI_TIMES_2.get = function () {
    return 2 * Math.PI;
  }),
  (yS.PI_OVER_2.get = function () {
    return Math.PI / 2;
  }),
  (yS.PI_OVER_4.get = function () {
    return Math.PI / 4;
  }),
  (yS.COUNTERCLOCKWISE.get = function () {
    return Tb.COUNTERCLOCKWISE;
  }),
  (yS.CLOCKWISE.get = function () {
    return Tb.CLOCKWISE;
  }),
  (yS.NONE.get = function () {
    return Tb.COLLINEAR;
  }),
  Object.defineProperties(mS, yS);
var vS = function t() {
    (this._maxCurveSegmentError = 0),
      (this._filletAngleQuantum = null),
      (this._closingSegLengthFactor = 1),
      (this._segList = null),
      (this._distance = 0),
      (this._precisionModel = null),
      (this._bufParams = null),
      (this._li = null),
      (this._s0 = null),
      (this._s1 = null),
      (this._s2 = null),
      (this._seg0 = new eS()),
      (this._seg1 = new eS()),
      (this._offset0 = new eS()),
      (this._offset1 = new eS()),
      (this._side = 0),
      (this._hasNarrowConcaveAngle = !1);
    var e = arguments[0],
      i = arguments[1],
      n = arguments[2];
    (this._precisionModel = e),
      (this._bufParams = i),
      (this._li = new Ab()),
      (this._filletAngleQuantum = Math.PI / 2 / i.getQuadrantSegments()),
      i.getQuadrantSegments() >= 8 &&
        i.getJoinStyle() === cS.JOIN_ROUND &&
        (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR),
      this.init(n);
  },
  bS = {
    OFFSET_SEGMENT_SEPARATION_FACTOR: {
      configurable: !0,
    },
    INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {
      configurable: !0,
    },
    CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {
      configurable: !0,
    },
    MAX_CLOSING_SEG_LEN_FACTOR: {
      configurable: !0,
    },
  };
(vS.prototype.addNextSegment = function (t, e) {
  if (
    ((this._s0 = this._s1),
    (this._s1 = this._s2),
    (this._s2 = t),
    this._seg0.setCoordinates(this._s0, this._s1),
    this.computeOffsetSegment(
      this._seg0,
      this._side,
      this._distance,
      this._offset0
    ),
    this._seg1.setCoordinates(this._s1, this._s2),
    this.computeOffsetSegment(
      this._seg1,
      this._side,
      this._distance,
      this._offset1
    ),
    this._s1.equals(this._s2))
  )
    return null;
  var i = Tb.computeOrientation(this._s0, this._s1, this._s2),
    n =
      (i === Tb.CLOCKWISE && this._side === c_.LEFT) ||
      (i === Tb.COUNTERCLOCKWISE && this._side === c_.RIGHT);
  0 === i
    ? this.addCollinear(e)
    : n
    ? this.addOutsideTurn(i, e)
    : this.addInsideTurn(i, e);
}),
  (vS.prototype.addLineEndCap = function (t, e) {
    var i = new eS(t, e),
      n = new eS();
    this.computeOffsetSegment(i, c_.LEFT, this._distance, n);
    var r = new eS();
    this.computeOffsetSegment(i, c_.RIGHT, this._distance, r);
    var o = e.x - t.x,
      a = e.y - t.y,
      s = Math.atan2(a, o);
    switch (this._bufParams.getEndCapStyle()) {
      case cS.CAP_ROUND:
        this._segList.addPt(n.p1),
          this.addFilletArc(
            e,
            s + Math.PI / 2,
            s - Math.PI / 2,
            Tb.CLOCKWISE,
            this._distance
          ),
          this._segList.addPt(r.p1);
        break;
      case cS.CAP_FLAT:
        this._segList.addPt(n.p1), this._segList.addPt(r.p1);
        break;
      case cS.CAP_SQUARE:
        var l = new qv();
        (l.x = Math.abs(this._distance) * Math.cos(s)),
          (l.y = Math.abs(this._distance) * Math.sin(s));
        var u = new qv(n.p1.x + l.x, n.p1.y + l.y),
          c = new qv(r.p1.x + l.x, r.p1.y + l.y);
        this._segList.addPt(u), this._segList.addPt(c);
    }
  }),
  (vS.prototype.getCoordinates = function () {
    return this._segList.getCoordinates();
  }),
  (vS.prototype.addMitreJoin = function (t, e, i, n) {
    var r = !0,
      o = null;
    try {
      (o = db.intersection(e.p0, e.p1, i.p0, i.p1)),
        (n <= 0 ? 1 : o.distance(t) / Math.abs(n)) >
          this._bufParams.getMitreLimit() && (r = !1);
    } catch (a) {
      if (!(a instanceof hb)) throw a;
      (o = new qv(0, 0)), (r = !1);
    }
    r
      ? this._segList.addPt(o)
      : this.addLimitedMitreJoin(e, i, n, this._bufParams.getMitreLimit());
  }),
  (vS.prototype.addFilletCorner = function (t, e, i, n, r) {
    var o = e.x - t.x,
      a = e.y - t.y,
      s = Math.atan2(a, o),
      l = i.x - t.x,
      u = i.y - t.y,
      c = Math.atan2(u, l);
    n === Tb.CLOCKWISE
      ? s <= c && (s += 2 * Math.PI)
      : s >= c && (s -= 2 * Math.PI),
      this._segList.addPt(e),
      this.addFilletArc(t, s, c, n, r),
      this._segList.addPt(i);
  }),
  (vS.prototype.addOutsideTurn = function (t, e) {
    if (
      this._offset0.p1.distance(this._offset1.p0) <
      this._distance * vS.OFFSET_SEGMENT_SEPARATION_FACTOR
    )
      return this._segList.addPt(this._offset0.p1), null;
    this._bufParams.getJoinStyle() === cS.JOIN_MITRE
      ? this.addMitreJoin(
          this._s1,
          this._offset0,
          this._offset1,
          this._distance
        )
      : this._bufParams.getJoinStyle() === cS.JOIN_BEVEL
      ? this.addBevelJoin(this._offset0, this._offset1)
      : (e && this._segList.addPt(this._offset0.p1),
        this.addFilletCorner(
          this._s1,
          this._offset0.p1,
          this._offset1.p0,
          t,
          this._distance
        ),
        this._segList.addPt(this._offset1.p0));
  }),
  (vS.prototype.createSquare = function (t) {
    this._segList.addPt(new qv(t.x + this._distance, t.y + this._distance)),
      this._segList.addPt(new qv(t.x + this._distance, t.y - this._distance)),
      this._segList.addPt(new qv(t.x - this._distance, t.y - this._distance)),
      this._segList.addPt(new qv(t.x - this._distance, t.y + this._distance)),
      this._segList.closeRing();
  }),
  (vS.prototype.addSegments = function (t, e) {
    this._segList.addPts(t, e);
  }),
  (vS.prototype.addFirstSegment = function () {
    this._segList.addPt(this._offset1.p0);
  }),
  (vS.prototype.addLastSegment = function () {
    this._segList.addPt(this._offset1.p1);
  }),
  (vS.prototype.initSideSegments = function (t, e, i) {
    (this._s1 = t),
      (this._s2 = e),
      (this._side = i),
      this._seg1.setCoordinates(t, e),
      this.computeOffsetSegment(this._seg1, i, this._distance, this._offset1);
  }),
  (vS.prototype.addLimitedMitreJoin = function (t, e, i, n) {
    var r = this._seg0.p1,
      o = mS.angle(r, this._seg0.p0),
      a = mS.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2,
      s = mS.normalize(o + a),
      l = mS.normalize(s + Math.PI),
      u = n * i,
      c = i - u * Math.abs(Math.sin(a)),
      h = r.x + u * Math.cos(l),
      p = r.y + u * Math.sin(l),
      d = new qv(h, p),
      f = new eS(r, d),
      g = f.pointAlongOffset(1, c),
      m = f.pointAlongOffset(1, -c);
    this._side === c_.LEFT
      ? (this._segList.addPt(g), this._segList.addPt(m))
      : (this._segList.addPt(m), this._segList.addPt(g));
  }),
  (vS.prototype.computeOffsetSegment = function (t, e, i, n) {
    var r = e === c_.LEFT ? 1 : -1,
      o = t.p1.x - t.p0.x,
      a = t.p1.y - t.p0.y,
      s = Math.sqrt(o * o + a * a),
      l = (r * i * o) / s,
      u = (r * i * a) / s;
    (n.p0.x = t.p0.x - u),
      (n.p0.y = t.p0.y + l),
      (n.p1.x = t.p1.x - u),
      (n.p1.y = t.p1.y + l);
  }),
  (vS.prototype.addFilletArc = function (t, e, i, n, r) {
    var o = n === Tb.CLOCKWISE ? -1 : 1,
      a = Math.abs(e - i),
      s = Math.trunc(a / this._filletAngleQuantum + 0.5);
    if (s < 1) return null;
    for (var l = a / s, u = 0, c = new qv(); u < a; ) {
      var h = e + o * u;
      (c.x = t.x + r * Math.cos(h)),
        (c.y = t.y + r * Math.sin(h)),
        this._segList.addPt(c),
        (u += l);
    }
  }),
  (vS.prototype.addInsideTurn = function (t, e) {
    if (
      (this._li.computeIntersection(
        this._offset0.p0,
        this._offset0.p1,
        this._offset1.p0,
        this._offset1.p1
      ),
      this._li.hasIntersection())
    )
      this._segList.addPt(this._li.getIntersection(0));
    else if (
      ((this._hasNarrowConcaveAngle = !0),
      this._offset0.p1.distance(this._offset1.p0) <
        this._distance * vS.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
    )
      this._segList.addPt(this._offset0.p1);
    else {
      if (
        (this._segList.addPt(this._offset0.p1),
        this._closingSegLengthFactor > 0)
      ) {
        var i = new qv(
          (this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) /
            (this._closingSegLengthFactor + 1),
          (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) /
            (this._closingSegLengthFactor + 1)
        );
        this._segList.addPt(i);
        var n = new qv(
          (this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) /
            (this._closingSegLengthFactor + 1),
          (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) /
            (this._closingSegLengthFactor + 1)
        );
        this._segList.addPt(n);
      } else this._segList.addPt(this._s1);
      this._segList.addPt(this._offset1.p0);
    }
  }),
  (vS.prototype.createCircle = function (t) {
    var e = new qv(t.x + this._distance, t.y);
    this._segList.addPt(e),
      this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance),
      this._segList.closeRing();
  }),
  (vS.prototype.addBevelJoin = function (t, e) {
    this._segList.addPt(t.p1), this._segList.addPt(e.p0);
  }),
  (vS.prototype.init = function (t) {
    (this._distance = t),
      (this._maxCurveSegmentError =
        t * (1 - Math.cos(this._filletAngleQuantum / 2))),
      (this._segList = new fS()),
      this._segList.setPrecisionModel(this._precisionModel),
      this._segList.setMinimumVertexDistance(
        t * vS.CURVE_VERTEX_SNAP_DISTANCE_FACTOR
      );
  }),
  (vS.prototype.addCollinear = function (t) {
    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2),
      this._li.getIntersectionNum() >= 2 &&
        (this._bufParams.getJoinStyle() === cS.JOIN_BEVEL ||
        this._bufParams.getJoinStyle() === cS.JOIN_MITRE
          ? (t && this._segList.addPt(this._offset0.p1),
            this._segList.addPt(this._offset1.p0))
          : this.addFilletCorner(
              this._s1,
              this._offset0.p1,
              this._offset1.p0,
              Tb.CLOCKWISE,
              this._distance
            ));
  }),
  (vS.prototype.closeRing = function () {
    this._segList.closeRing();
  }),
  (vS.prototype.hasNarrowConcaveAngle = function () {
    return this._hasNarrowConcaveAngle;
  }),
  (vS.prototype.interfaces_ = function () {
    return [];
  }),
  (vS.prototype.getClass = function () {
    return vS;
  }),
  (bS.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () {
    return 0.001;
  }),
  (bS.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
    return 0.001;
  }),
  (bS.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {
    return 1e-6;
  }),
  (bS.MAX_CLOSING_SEG_LEN_FACTOR.get = function () {
    return 80;
  }),
  Object.defineProperties(vS, bS);
var xS = function () {
  (this._distance = 0), (this._precisionModel = null), (this._bufParams = null);
  var t = arguments[0],
    e = arguments[1];
  (this._precisionModel = t), (this._bufParams = e);
};
(xS.prototype.getOffsetCurve = function (t, e) {
  if (((this._distance = e), 0 === e)) return null;
  var i = e < 0,
    n = Math.abs(e),
    r = this.getSegGen(n);
  t.length <= 1
    ? this.computePointCurve(t[0], r)
    : this.computeOffsetCurve(t, i, r);
  var o = r.getCoordinates();
  return i && Zb.reverse(o), o;
}),
  (xS.prototype.computeSingleSidedBufferCurve = function (t, e, i) {
    var n = this.simplifyTolerance(this._distance);
    if (e) {
      i.addSegments(t, !0);
      var r = pS.simplify(t, -n),
        o = r.length - 1;
      i.initSideSegments(r[o], r[o - 1], c_.LEFT), i.addFirstSegment();
      for (var a = o - 2; a >= 0; a--) i.addNextSegment(r[a], !0);
    } else {
      i.addSegments(t, !1);
      var s = pS.simplify(t, n),
        l = s.length - 1;
      i.initSideSegments(s[0], s[1], c_.LEFT), i.addFirstSegment();
      for (var u = 2; u <= l; u++) i.addNextSegment(s[u], !0);
    }
    i.addLastSegment(), i.closeRing();
  }),
  (xS.prototype.computeRingBufferCurve = function (t, e, i) {
    var n = this.simplifyTolerance(this._distance);
    e === c_.RIGHT && (n = -n);
    var r = pS.simplify(t, n),
      o = r.length - 1;
    i.initSideSegments(r[o - 1], r[0], e);
    for (var a = 1; a <= o; a++) {
      var s = 1 !== a;
      i.addNextSegment(r[a], s);
    }
    i.closeRing();
  }),
  (xS.prototype.computeLineBufferCurve = function (t, e) {
    var i = this.simplifyTolerance(this._distance),
      n = pS.simplify(t, i),
      r = n.length - 1;
    e.initSideSegments(n[0], n[1], c_.LEFT);
    for (var o = 2; o <= r; o++) e.addNextSegment(n[o], !0);
    e.addLastSegment(), e.addLineEndCap(n[r - 1], n[r]);
    var a = pS.simplify(t, -i),
      s = a.length - 1;
    e.initSideSegments(a[s], a[s - 1], c_.LEFT);
    for (var l = s - 2; l >= 0; l--) e.addNextSegment(a[l], !0);
    e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing();
  }),
  (xS.prototype.computePointCurve = function (t, e) {
    switch (this._bufParams.getEndCapStyle()) {
      case cS.CAP_ROUND:
        e.createCircle(t);
        break;
      case cS.CAP_SQUARE:
        e.createSquare(t);
    }
  }),
  (xS.prototype.getLineCurve = function (t, e) {
    if (((this._distance = e), e < 0 && !this._bufParams.isSingleSided()))
      return null;
    if (0 === e) return null;
    var i = Math.abs(e),
      n = this.getSegGen(i);
    if (t.length <= 1) this.computePointCurve(t[0], n);
    else if (this._bufParams.isSingleSided()) {
      var r = e < 0;
      this.computeSingleSidedBufferCurve(t, r, n);
    } else this.computeLineBufferCurve(t, n);
    return n.getCoordinates();
  }),
  (xS.prototype.getBufferParameters = function () {
    return this._bufParams;
  }),
  (xS.prototype.simplifyTolerance = function (t) {
    return t * this._bufParams.getSimplifyFactor();
  }),
  (xS.prototype.getRingCurve = function (t, e, i) {
    if (((this._distance = i), t.length <= 2)) return this.getLineCurve(t, i);
    if (0 === i) return xS.copyCoordinates(t);
    var n = this.getSegGen(i);
    return this.computeRingBufferCurve(t, e, n), n.getCoordinates();
  }),
  (xS.prototype.computeOffsetCurve = function (t, e, i) {
    var n = this.simplifyTolerance(this._distance);
    if (e) {
      var r = pS.simplify(t, -n),
        o = r.length - 1;
      i.initSideSegments(r[o], r[o - 1], c_.LEFT), i.addFirstSegment();
      for (var a = o - 2; a >= 0; a--) i.addNextSegment(r[a], !0);
    } else {
      var s = pS.simplify(t, n),
        l = s.length - 1;
      i.initSideSegments(s[0], s[1], c_.LEFT), i.addFirstSegment();
      for (var u = 2; u <= l; u++) i.addNextSegment(s[u], !0);
    }
    i.addLastSegment();
  }),
  (xS.prototype.getSegGen = function (t) {
    return new vS(this._precisionModel, this._bufParams, t);
  }),
  (xS.prototype.interfaces_ = function () {
    return [];
  }),
  (xS.prototype.getClass = function () {
    return xS;
  }),
  (xS.copyCoordinates = function (t) {
    for (var e = new Array(t.length).fill(null), i = 0; i < e.length; i++)
      e[i] = new qv(t[i]);
    return e;
  });
var _S = function () {
    (this._subgraphs = null), (this._seg = new eS()), (this._cga = new Tb());
    var t = arguments[0];
    this._subgraphs = t;
  },
  SS = {
    DepthSegment: {
      configurable: !0,
    },
  };
(_S.prototype.findStabbedSegments = function () {
  var t = this;
  if (1 === arguments.length) {
    for (
      var e = arguments[0], i = new Yb(), n = this._subgraphs.iterator();
      n.hasNext();

    ) {
      var r = n.next(),
        o = r.getEnvelope();
      e.y < o.getMinY() ||
        e.y > o.getMaxY() ||
        t.findStabbedSegments(e, r.getDirectedEdges(), i);
    }
    return i;
  }
  if (3 === arguments.length)
    if (
      Kv(arguments[2], Wb) &&
      arguments[0] instanceof qv &&
      arguments[1] instanceof T_
    )
      for (
        var a = arguments[0],
          s = arguments[1],
          l = arguments[2],
          u = s.getEdge().getCoordinates(),
          c = 0;
        c < u.length - 1;
        c++
      ) {
        if (
          ((t._seg.p0 = u[c]),
          (t._seg.p1 = u[c + 1]),
          t._seg.p0.y > t._seg.p1.y && t._seg.reverse(),
          !(
            Math.max(t._seg.p0.x, t._seg.p1.x) < a.x ||
            t._seg.isHorizontal() ||
            a.y < t._seg.p0.y ||
            a.y > t._seg.p1.y ||
            Tb.computeOrientation(t._seg.p0, t._seg.p1, a) === Tb.RIGHT
          ))
        ) {
          var h = s.getDepth(c_.LEFT);
          t._seg.p0.equals(u[c]) || (h = s.getDepth(c_.RIGHT));
          var p = new MS(t._seg, h);
          l.add(p);
        }
      }
    else if (
      Kv(arguments[2], Wb) &&
      arguments[0] instanceof qv &&
      Kv(arguments[1], Wb)
    )
      for (
        var d = arguments[0], f = arguments[2], g = arguments[1].iterator();
        g.hasNext();

      ) {
        var m = g.next();
        m.isForward() && t.findStabbedSegments(d, m, f);
      }
}),
  (_S.prototype.getDepth = function (t) {
    var e = this.findStabbedSegments(t);
    return 0 === e.size() ? 0 : G_.min(e)._leftDepth;
  }),
  (_S.prototype.interfaces_ = function () {
    return [];
  }),
  (_S.prototype.getClass = function () {
    return _S;
  }),
  (SS.DepthSegment.get = function () {
    return MS;
  }),
  Object.defineProperties(_S, SS);
var MS = function () {
  (this._upwardSeg = null), (this._leftDepth = null);
  var t = arguments[0],
    e = arguments[1];
  (this._upwardSeg = new eS(t)), (this._leftDepth = e);
};
(MS.prototype.compareTo = function (t) {
  var e = t;
  if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
  if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
  var i = this._upwardSeg.orientationIndex(e._upwardSeg);
  return 0 !== i ||
    0 !== (i = -1 * e._upwardSeg.orientationIndex(this._upwardSeg))
    ? i
    : this._upwardSeg.compareTo(e._upwardSeg);
}),
  (MS.prototype.compareX = function (t, e) {
    var i = t.p0.compareTo(e.p0);
    return 0 !== i ? i : t.p1.compareTo(e.p1);
  }),
  (MS.prototype.toString = function () {
    return this._upwardSeg.toString();
  }),
  (MS.prototype.interfaces_ = function () {
    return [jv];
  }),
  (MS.prototype.getClass = function () {
    return MS;
  });
var CS = function (t, e, i) {
  (this.p0 = t || null), (this.p1 = e || null), (this.p2 = i || null);
};
(CS.prototype.area = function () {
  return CS.area(this.p0, this.p1, this.p2);
}),
  (CS.prototype.signedArea = function () {
    return CS.signedArea(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.interpolateZ = function (t) {
    if (null === t) throw new Bv("Supplied point is null.");
    return CS.interpolateZ(t, this.p0, this.p1, this.p2);
  }),
  (CS.prototype.longestSideLength = function () {
    return CS.longestSideLength(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.isAcute = function () {
    return CS.isAcute(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.circumcentre = function () {
    return CS.circumcentre(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.area3D = function () {
    return CS.area3D(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.centroid = function () {
    return CS.centroid(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.inCentre = function () {
    return CS.inCentre(this.p0, this.p1, this.p2);
  }),
  (CS.prototype.interfaces_ = function () {
    return [];
  }),
  (CS.prototype.getClass = function () {
    return CS;
  }),
  (CS.area = function (t, e, i) {
    return Math.abs(
      ((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2
    );
  }),
  (CS.signedArea = function (t, e, i) {
    return ((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2;
  }),
  (CS.det = function (t, e, i, n) {
    return t * n - e * i;
  }),
  (CS.interpolateZ = function (t, e, i, n) {
    var r = e.x,
      o = e.y,
      a = i.x - r,
      s = n.x - r,
      l = i.y - o,
      u = n.y - o,
      c = a * u - s * l,
      h = t.x - r,
      p = t.y - o,
      d = (u * h - s * p) / c,
      f = (-l * h + a * p) / c;
    return e.z + d * (i.z - e.z) + f * (n.z - e.z);
  }),
  (CS.longestSideLength = function (t, e, i) {
    var n = t.distance(e),
      r = e.distance(i),
      o = i.distance(t),
      a = n;
    return r > a && (a = r), o > a && (a = o), a;
  }),
  (CS.isAcute = function (t, e, i) {
    return (
      !!mS.isAcute(t, e, i) && !!mS.isAcute(e, i, t) && !!mS.isAcute(i, t, e)
    );
  }),
  (CS.circumcentre = function (t, e, i) {
    var n = i.x,
      r = i.y,
      o = t.x - n,
      a = t.y - r,
      s = e.x - n,
      l = e.y - r,
      u = 2 * CS.det(o, a, s, l),
      c = CS.det(a, o * o + a * a, l, s * s + l * l),
      h = CS.det(o, o * o + a * a, s, s * s + l * l);
    return new qv(n - c / u, r + h / u);
  }),
  (CS.perpendicularBisector = function (t, e) {
    var i = e.x - t.x,
      n = e.y - t.y,
      r = new db(t.x + i / 2, t.y + n / 2, 1),
      o = new db(t.x - n + i / 2, t.y + i + n / 2, 1);
    return new db(r, o);
  }),
  (CS.angleBisector = function (t, e, i) {
    var n = e.distance(t),
      r = n / (n + e.distance(i)),
      o = i.x - t.x,
      a = i.y - t.y;
    return new qv(t.x + r * o, t.y + r * a);
  }),
  (CS.area3D = function (t, e, i) {
    var n = e.x - t.x,
      r = e.y - t.y,
      o = e.z - t.z,
      a = i.x - t.x,
      s = i.y - t.y,
      l = i.z - t.z,
      u = r * l - o * s,
      c = o * a - n * l,
      h = n * s - r * a,
      p = u * u + c * c + h * h;
    return Math.sqrt(p) / 2;
  }),
  (CS.centroid = function (t, e, i) {
    var n = (t.x + e.x + i.x) / 3,
      r = (t.y + e.y + i.y) / 3;
    return new qv(n, r);
  }),
  (CS.inCentre = function (t, e, i) {
    var n = e.distance(i),
      r = t.distance(i),
      o = t.distance(e),
      a = n + r + o,
      s = (n * t.x + r * e.x + o * i.x) / a,
      l = (n * t.y + r * e.y + o * i.y) / a;
    return new qv(s, l);
  });
var wS = function () {
  (this._inputGeom = null),
    (this._distance = null),
    (this._curveBuilder = null),
    (this._curveList = new Yb());
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2];
  (this._inputGeom = t), (this._distance = e), (this._curveBuilder = i);
};
(wS.prototype.addPoint = function (t) {
  if (this._distance <= 0) return null;
  var e = t.getCoordinates(),
    i = this._curveBuilder.getLineCurve(e, this._distance);
  this.addCurve(i, Zv.EXTERIOR, Zv.INTERIOR);
}),
  (wS.prototype.addPolygon = function (t) {
    var e = this,
      i = this._distance,
      n = c_.LEFT;
    this._distance < 0 && ((i = -this._distance), (n = c_.RIGHT));
    var r = t.getExteriorRing(),
      o = Zb.removeRepeatedPoints(r.getCoordinates());
    if (this._distance < 0 && this.isErodedCompletely(r, this._distance))
      return null;
    if (this._distance <= 0 && o.length < 3) return null;
    this.addPolygonRing(o, i, n, Zv.EXTERIOR, Zv.INTERIOR);
    for (var a = 0; a < t.getNumInteriorRing(); a++) {
      var s = t.getInteriorRingN(a),
        l = Zb.removeRepeatedPoints(s.getCoordinates());
      (e._distance > 0 && e.isErodedCompletely(s, -e._distance)) ||
        e.addPolygonRing(l, i, c_.opposite(n), Zv.INTERIOR, Zv.EXTERIOR);
    }
  }),
  (wS.prototype.isTriangleErodedCompletely = function (t, e) {
    var i = new CS(t[0], t[1], t[2]),
      n = i.inCentre();
    return Tb.distancePointLine(n, i.p0, i.p1) < Math.abs(e);
  }),
  (wS.prototype.addLineString = function (t) {
    if (
      this._distance <= 0 &&
      !this._curveBuilder.getBufferParameters().isSingleSided()
    )
      return null;
    var e = Zb.removeRepeatedPoints(t.getCoordinates()),
      i = this._curveBuilder.getLineCurve(e, this._distance);
    this.addCurve(i, Zv.EXTERIOR, Zv.INTERIOR);
  }),
  (wS.prototype.addCurve = function (t, e, i) {
    if (null === t || t.length < 2) return null;
    var n = new tS(t, new b_(0, Zv.BOUNDARY, e, i));
    this._curveList.add(n);
  }),
  (wS.prototype.getCurves = function () {
    return this.add(this._inputGeom), this._curveList;
  }),
  (wS.prototype.addPolygonRing = function (t, e, i, n, r) {
    if (0 === e && t.length < Gx.MINIMUM_VALID_SIZE) return null;
    var o = n,
      a = r;
    t.length >= Gx.MINIMUM_VALID_SIZE &&
      Tb.isCCW(t) &&
      ((o = r), (a = n), (i = c_.opposite(i)));
    var s = this._curveBuilder.getRingCurve(t, i, e);
    this.addCurve(s, o, a);
  }),
  (wS.prototype.add = function (t) {
    if (t.isEmpty()) return null;
    t instanceof kx
      ? this.addPolygon(t)
      : t instanceof Rx
      ? this.addLineString(t)
      : t instanceof Fx
      ? this.addPoint(t)
      : (t instanceof Bx ||
          t instanceof Sx ||
          t instanceof Ux ||
          t instanceof _x) &&
        this.addCollection(t);
  }),
  (wS.prototype.isErodedCompletely = function (t, e) {
    var i = t.getCoordinates();
    if (i.length < 4) return e < 0;
    if (4 === i.length) return this.isTriangleErodedCompletely(i, e);
    var n = t.getEnvelopeInternal(),
      r = Math.min(n.getHeight(), n.getWidth());
    return e < 0 && 2 * Math.abs(e) > r;
  }),
  (wS.prototype.addCollection = function (t) {
    for (var e = 0; e < t.getNumGeometries(); e++) {
      var i = t.getGeometryN(e);
      this.add(i);
    }
  }),
  (wS.prototype.interfaces_ = function () {
    return [];
  }),
  (wS.prototype.getClass = function () {
    return wS;
  });
var AS = function () {};
(AS.prototype.locate = function (t) {}),
  (AS.prototype.interfaces_ = function () {
    return [];
  }),
  (AS.prototype.getClass = function () {
    return AS;
  });
var ES = function () {
  (this._parent = null),
    (this._atStart = null),
    (this._max = null),
    (this._index = null),
    (this._subcollectionIterator = null);
  var t = arguments[0];
  (this._parent = t),
    (this._atStart = !0),
    (this._index = 0),
    (this._max = t.getNumGeometries());
};
(ES.prototype.next = function () {
  if (this._atStart)
    return (
      (this._atStart = !1),
      ES.isAtomic(this._parent) && this._index++,
      this._parent
    );
  if (null !== this._subcollectionIterator) {
    if (this._subcollectionIterator.hasNext())
      return this._subcollectionIterator.next();
    this._subcollectionIterator = null;
  }
  if (this._index >= this._max) throw new qb();
  var t = this._parent.getGeometryN(this._index++);
  return t instanceof _x
    ? ((this._subcollectionIterator = new ES(t)),
      this._subcollectionIterator.next())
    : t;
}),
  (ES.prototype.remove = function () {
    throw new Error(this.getClass().getName());
  }),
  (ES.prototype.hasNext = function () {
    if (this._atStart) return !0;
    if (null !== this._subcollectionIterator) {
      if (this._subcollectionIterator.hasNext()) return !0;
      this._subcollectionIterator = null;
    }
    return !(this._index >= this._max);
  }),
  (ES.prototype.interfaces_ = function () {
    return [Vb];
  }),
  (ES.prototype.getClass = function () {
    return ES;
  }),
  (ES.isAtomic = function (t) {
    return !(t instanceof _x);
  });
var DS = function () {
  this._geom = null;
  var t = arguments[0];
  this._geom = t;
};
(DS.prototype.locate = function (t) {
  return DS.locate(t, this._geom);
}),
  (DS.prototype.interfaces_ = function () {
    return [AS];
  }),
  (DS.prototype.getClass = function () {
    return DS;
  }),
  (DS.isPointInRing = function (t, e) {
    return (
      !!e.getEnvelopeInternal().intersects(t) &&
      Tb.isPointInRing(t, e.getCoordinates())
    );
  }),
  (DS.containsPointInPolygon = function (t, e) {
    if (e.isEmpty()) return !1;
    var i = e.getExteriorRing();
    if (!DS.isPointInRing(t, i)) return !1;
    for (var n = 0; n < e.getNumInteriorRing(); n++) {
      var r = e.getInteriorRingN(n);
      if (DS.isPointInRing(t, r)) return !1;
    }
    return !0;
  }),
  (DS.containsPoint = function (t, e) {
    if (e instanceof kx) return DS.containsPointInPolygon(t, e);
    if (e instanceof _x)
      for (var i = new ES(e); i.hasNext(); ) {
        var n = i.next();
        if (n !== e && DS.containsPoint(t, n)) return !0;
      }
    return !1;
  }),
  (DS.locate = function (t, e) {
    return e.isEmpty()
      ? Zv.EXTERIOR
      : DS.containsPoint(t, e)
      ? Zv.INTERIOR
      : Zv.EXTERIOR;
  });
var TS = function () {
  (this._edgeMap = new hx()),
    (this._edgeList = null),
    (this._ptInAreaLocation = [Zv.NONE, Zv.NONE]);
};
(TS.prototype.getNextCW = function (t) {
  this.getEdges();
  var e = this._edgeList.indexOf(t),
    i = e - 1;
  return 0 === e && (i = this._edgeList.size() - 1), this._edgeList.get(i);
}),
  (TS.prototype.propagateSideLabels = function (t) {
    for (var e = Zv.NONE, i = this.iterator(); i.hasNext(); ) {
      var n = i.next().getLabel();
      n.isArea(t) &&
        n.getLocation(t, c_.LEFT) !== Zv.NONE &&
        (e = n.getLocation(t, c_.LEFT));
    }
    if (e === Zv.NONE) return null;
    for (var r = e, o = this.iterator(); o.hasNext(); ) {
      var a = o.next(),
        s = a.getLabel();
      if (
        (s.getLocation(t, c_.ON) === Zv.NONE && s.setLocation(t, c_.ON, r),
        s.isArea(t))
      ) {
        var l = s.getLocation(t, c_.LEFT),
          u = s.getLocation(t, c_.RIGHT);
        if (u !== Zv.NONE) {
          if (u !== r)
            throw new g_("side location conflict", a.getCoordinate());
          l === Zv.NONE &&
            Mb.shouldNeverReachHere(
              "found single null side (at " + a.getCoordinate() + ")"
            ),
            (r = l);
        } else
          Mb.isTrue(
            s.getLocation(t, c_.LEFT) === Zv.NONE,
            "found single null side"
          ),
            s.setLocation(t, c_.RIGHT, r),
            s.setLocation(t, c_.LEFT, r);
      }
    }
  }),
  (TS.prototype.getCoordinate = function () {
    var t = this.iterator();
    return t.hasNext() ? t.next().getCoordinate() : null;
  }),
  (TS.prototype.print = function (t) {
    pb.out.println("EdgeEndStar:   " + this.getCoordinate());
    for (var e = this.iterator(); e.hasNext(); ) {
      e.next().print(t);
    }
  }),
  (TS.prototype.isAreaLabelsConsistent = function (t) {
    return (
      this.computeEdgeEndLabels(t.getBoundaryNodeRule()),
      this.checkAreaLabelsConsistent(0)
    );
  }),
  (TS.prototype.checkAreaLabelsConsistent = function (t) {
    var e = this.getEdges();
    if (e.size() <= 0) return !0;
    var i = e.size() - 1,
      n = e.get(i).getLabel().getLocation(t, c_.LEFT);
    Mb.isTrue(n !== Zv.NONE, "Found unlabelled area edge");
    for (var r = n, o = this.iterator(); o.hasNext(); ) {
      var a = o.next().getLabel();
      Mb.isTrue(a.isArea(t), "Found non-area edge");
      var s = a.getLocation(t, c_.LEFT),
        l = a.getLocation(t, c_.RIGHT);
      if (s === l) return !1;
      if (l !== r) return !1;
      r = s;
    }
    return !0;
  }),
  (TS.prototype.findIndex = function (t) {
    this.iterator();
    for (var e = 0; e < this._edgeList.size(); e++) {
      if (this._edgeList.get(e) === t) return e;
    }
    return -1;
  }),
  (TS.prototype.iterator = function () {
    return this.getEdges().iterator();
  }),
  (TS.prototype.getEdges = function () {
    return (
      null === this._edgeList &&
        (this._edgeList = new Yb(this._edgeMap.values())),
      this._edgeList
    );
  }),
  (TS.prototype.getLocation = function (t, e, i) {
    return (
      this._ptInAreaLocation[t] === Zv.NONE &&
        (this._ptInAreaLocation[t] = DS.locate(e, i[t].getGeometry())),
      this._ptInAreaLocation[t]
    );
  }),
  (TS.prototype.toString = function () {
    var t = new eb();
    t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
    for (var e = this.iterator(); e.hasNext(); ) {
      var i = e.next();
      t.append(i), t.append("\n");
    }
    return t.toString();
  }),
  (TS.prototype.computeEdgeEndLabels = function (t) {
    for (var e = this.iterator(); e.hasNext(); ) {
      e.next().computeLabel(t);
    }
  }),
  (TS.prototype.computeLabelling = function (t) {
    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),
      this.propagateSideLabels(0),
      this.propagateSideLabels(1);
    for (var e = [!1, !1], i = this.iterator(); i.hasNext(); )
      for (var n = i.next().getLabel(), r = 0; r < 2; r++)
        n.isLine(r) && n.getLocation(r) === Zv.BOUNDARY && (e[r] = !0);
    for (var o = this.iterator(); o.hasNext(); )
      for (var a = o.next(), s = a.getLabel(), l = 0; l < 2; l++)
        if (s.isAnyNull(l)) {
          var u = Zv.NONE;
          if (e[l]) u = Zv.EXTERIOR;
          else {
            var c = a.getCoordinate();
            u = this.getLocation(l, c, t);
          }
          s.setAllLocationsIfNull(l, u);
        }
  }),
  (TS.prototype.getDegree = function () {
    return this._edgeMap.size();
  }),
  (TS.prototype.insertEdgeEnd = function (t, e) {
    this._edgeMap.put(t, e), (this._edgeList = null);
  }),
  (TS.prototype.interfaces_ = function () {
    return [];
  }),
  (TS.prototype.getClass = function () {
    return TS;
  });
var PS = (function (t) {
    function e() {
      t.call(this),
        (this._resultAreaEdgeList = null),
        (this._label = null),
        (this._SCANNING_FOR_INCOMING = 1),
        (this._LINKING_TO_OUTGOING = 2);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.linkResultDirectedEdges = function () {
        var t = this;
        this.getResultAreaEdges();
        for (
          var e = null, i = null, n = this._SCANNING_FOR_INCOMING, r = 0;
          r < this._resultAreaEdgeList.size();
          r++
        ) {
          var o = t._resultAreaEdgeList.get(r),
            a = o.getSym();
          if (o.getLabel().isArea())
            switch ((null === e && o.isInResult() && (e = o), n)) {
              case t._SCANNING_FOR_INCOMING:
                if (!a.isInResult()) continue;
                (i = a), (n = t._LINKING_TO_OUTGOING);
                break;
              case t._LINKING_TO_OUTGOING:
                if (!o.isInResult()) continue;
                i.setNext(o), (n = t._SCANNING_FOR_INCOMING);
            }
        }
        if (n === this._LINKING_TO_OUTGOING) {
          if (null === e)
            throw new g_("no outgoing dirEdge found", this.getCoordinate());
          Mb.isTrue(e.isInResult(), "unable to link last incoming dirEdge"),
            i.setNext(e);
        }
      }),
      (e.prototype.insert = function (t) {
        var e = t;
        this.insertEdgeEnd(e, e);
      }),
      (e.prototype.getRightmostEdge = function () {
        var t = this.getEdges(),
          e = t.size();
        if (e < 1) return null;
        var i = t.get(0);
        if (1 === e) return i;
        var n = t.get(e - 1),
          r = i.getQuadrant(),
          o = n.getQuadrant();
        return A_.isNorthern(r) && A_.isNorthern(o)
          ? i
          : A_.isNorthern(r) || A_.isNorthern(o)
          ? 0 !== i.getDy()
            ? i
            : 0 !== n.getDy()
            ? n
            : (Mb.shouldNeverReachHere(
                "found two horizontal edges incident on node"
              ),
              null)
          : n;
      }),
      (e.prototype.print = function (t) {
        pb.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var e = this.iterator(); e.hasNext(); ) {
          var i = e.next();
          t.print("out "),
            i.print(t),
            t.println(),
            t.print("in "),
            i.getSym().print(t),
            t.println();
        }
      }),
      (e.prototype.getResultAreaEdges = function () {
        if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new Yb();
        for (var t = this.iterator(); t.hasNext(); ) {
          var e = t.next();
          (e.isInResult() || e.getSym().isInResult()) &&
            this._resultAreaEdgeList.add(e);
        }
        return this._resultAreaEdgeList;
      }),
      (e.prototype.updateLabelling = function (t) {
        for (var e = this.iterator(); e.hasNext(); ) {
          var i = e.next().getLabel();
          i.setAllLocationsIfNull(0, t.getLocation(0)),
            i.setAllLocationsIfNull(1, t.getLocation(1));
        }
      }),
      (e.prototype.linkAllDirectedEdges = function () {
        this.getEdges();
        for (
          var t = null, e = null, i = this._edgeList.size() - 1;
          i >= 0;
          i--
        ) {
          var n = this._edgeList.get(i),
            r = n.getSym();
          null === e && (e = r), null !== t && r.setNext(t), (t = n);
        }
        e.setNext(t);
      }),
      (e.prototype.computeDepths = function () {
        if (1 === arguments.length) {
          var t = arguments[0],
            e = this.findIndex(t),
            i = t.getDepth(c_.LEFT),
            n = t.getDepth(c_.RIGHT),
            r = this.computeDepths(e + 1, this._edgeList.size(), i);
          if (this.computeDepths(0, e, r) !== n)
            throw new g_("depth mismatch at " + t.getCoordinate());
        } else if (3 === arguments.length) {
          for (
            var o = arguments[1], a = arguments[2], s = arguments[0];
            s < o;
            s++
          ) {
            var l = this._edgeList.get(s);
            l.setEdgeDepths(c_.RIGHT, a), (a = l.getDepth(c_.LEFT));
          }
          return a;
        }
      }),
      (e.prototype.mergeSymLabels = function () {
        for (var t = this.iterator(); t.hasNext(); ) {
          var e = t.next();
          e.getLabel().merge(e.getSym().getLabel());
        }
      }),
      (e.prototype.linkMinimalDirectedEdges = function (t) {
        for (
          var e = this,
            i = null,
            n = null,
            r = this._SCANNING_FOR_INCOMING,
            o = this._resultAreaEdgeList.size() - 1;
          o >= 0;
          o--
        ) {
          var a = e._resultAreaEdgeList.get(o),
            s = a.getSym();
          switch ((null === i && a.getEdgeRing() === t && (i = a), r)) {
            case e._SCANNING_FOR_INCOMING:
              if (s.getEdgeRing() !== t) continue;
              (n = s), (r = e._LINKING_TO_OUTGOING);
              break;
            case e._LINKING_TO_OUTGOING:
              if (a.getEdgeRing() !== t) continue;
              n.setNextMin(a), (r = e._SCANNING_FOR_INCOMING);
          }
        }
        r === this._LINKING_TO_OUTGOING &&
          (Mb.isTrue(null !== i, "found null for first outgoing dirEdge"),
          Mb.isTrue(
            i.getEdgeRing() === t,
            "unable to link last incoming dirEdge"
          ),
          n.setNextMin(i));
      }),
      (e.prototype.getOutgoingDegree = function () {
        if (0 === arguments.length) {
          for (var t = 0, e = this.iterator(); e.hasNext(); ) {
            e.next().isInResult() && t++;
          }
          return t;
        }
        if (1 === arguments.length) {
          for (
            var i = arguments[0], n = 0, r = this.iterator();
            r.hasNext();

          ) {
            r.next().getEdgeRing() === i && n++;
          }
          return n;
        }
      }),
      (e.prototype.getLabel = function () {
        return this._label;
      }),
      (e.prototype.findCoveredLineEdges = function () {
        for (var t = Zv.NONE, e = this.iterator(); e.hasNext(); ) {
          var i = e.next(),
            n = i.getSym();
          if (!i.isLineEdge()) {
            if (i.isInResult()) {
              t = Zv.INTERIOR;
              break;
            }
            if (n.isInResult()) {
              t = Zv.EXTERIOR;
              break;
            }
          }
        }
        if (t === Zv.NONE) return null;
        for (var r = t, o = this.iterator(); o.hasNext(); ) {
          var a = o.next(),
            s = a.getSym();
          a.isLineEdge()
            ? a.getEdge().setCovered(r === Zv.INTERIOR)
            : (a.isInResult() && (r = Zv.EXTERIOR),
              s.isInResult() && (r = Zv.INTERIOR));
        }
      }),
      (e.prototype.computeLabelling = function (e) {
        t.prototype.computeLabelling.call(this, e),
          (this._label = new b_(Zv.NONE));
        for (var i = this.iterator(); i.hasNext(); )
          for (var n = i.next().getEdge().getLabel(), r = 0; r < 2; r++) {
            var o = n.getLocation(r);
            (o !== Zv.INTERIOR && o !== Zv.BOUNDARY) ||
              this._label.setLocation(r, Zv.INTERIOR);
          }
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(TS),
  LS = (function (t) {
    function e() {
      t.apply(this, arguments);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.createNode = function (t) {
        return new C_(t, new PS());
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(P_),
  IS = function t() {
    (this._pts = null), (this._orientation = null);
    var e = arguments[0];
    (this._pts = e), (this._orientation = t.orientation(e));
  };
(IS.prototype.compareTo = function (t) {
  var e = t;
  return IS.compareOriented(
    this._pts,
    this._orientation,
    e._pts,
    e._orientation
  );
}),
  (IS.prototype.interfaces_ = function () {
    return [jv];
  }),
  (IS.prototype.getClass = function () {
    return IS;
  }),
  (IS.orientation = function (t) {
    return 1 === Zb.increasingDirection(t);
  }),
  (IS.compareOriented = function (t, e, i, n) {
    for (
      var r = e ? 1 : -1,
        o = n ? 1 : -1,
        a = e ? t.length : -1,
        s = n ? i.length : -1,
        l = e ? 0 : t.length - 1,
        u = n ? 0 : i.length - 1;
      ;

    ) {
      var c = t[l].compareTo(i[u]);
      if (0 !== c) return c;
      var h = (l += r) === a,
        p = (u += o) === s;
      if (h && !p) return -1;
      if (!h && p) return 1;
      if (h && p) return 0;
    }
  });
var NS = function () {
  (this._edges = new Yb()), (this._ocaMap = new hx());
};
(NS.prototype.print = function (t) {
  t.print("MULTILINESTRING ( ");
  for (var e = 0; e < this._edges.size(); e++) {
    var i = this._edges.get(e);
    e > 0 && t.print(","), t.print("(");
    for (var n = i.getCoordinates(), r = 0; r < n.length; r++)
      r > 0 && t.print(","), t.print(n[r].x + " " + n[r].y);
    t.println(")");
  }
  t.print(")  ");
}),
  (NS.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
  }),
  (NS.prototype.findEdgeIndex = function (t) {
    for (var e = 0; e < this._edges.size(); e++)
      if (this._edges.get(e).equals(t)) return e;
    return -1;
  }),
  (NS.prototype.iterator = function () {
    return this._edges.iterator();
  }),
  (NS.prototype.getEdges = function () {
    return this._edges;
  }),
  (NS.prototype.get = function (t) {
    return this._edges.get(t);
  }),
  (NS.prototype.findEqualEdge = function (t) {
    var e = new IS(t.getCoordinates());
    return this._ocaMap.get(e);
  }),
  (NS.prototype.add = function (t) {
    this._edges.add(t);
    var e = new IS(t.getCoordinates());
    this._ocaMap.put(e, t);
  }),
  (NS.prototype.interfaces_ = function () {
    return [];
  }),
  (NS.prototype.getClass = function () {
    return NS;
  });
var RS = function () {};
(RS.prototype.processIntersections = function (t, e, i, n) {}),
  (RS.prototype.isDone = function () {}),
  (RS.prototype.interfaces_ = function () {
    return [];
  }),
  (RS.prototype.getClass = function () {
    return RS;
  });
var OS = function () {
  (this._hasIntersection = !1),
    (this._hasProper = !1),
    (this._hasProperInterior = !1),
    (this._hasInterior = !1),
    (this._properIntersectionPoint = null),
    (this._li = null),
    (this._isSelfIntersection = null),
    (this.numIntersections = 0),
    (this.numInteriorIntersections = 0),
    (this.numProperIntersections = 0),
    (this.numTests = 0);
  var t = arguments[0];
  this._li = t;
};
(OS.prototype.isTrivialIntersection = function (t, e, i, n) {
  if (t === i && 1 === this._li.getIntersectionNum()) {
    if (OS.isAdjacentSegments(e, n)) return !0;
    if (t.isClosed()) {
      var r = t.size() - 1;
      if ((0 === e && n === r) || (0 === n && e === r)) return !0;
    }
  }
  return !1;
}),
  (OS.prototype.getProperIntersectionPoint = function () {
    return this._properIntersectionPoint;
  }),
  (OS.prototype.hasProperInteriorIntersection = function () {
    return this._hasProperInterior;
  }),
  (OS.prototype.getLineIntersector = function () {
    return this._li;
  }),
  (OS.prototype.hasProperIntersection = function () {
    return this._hasProper;
  }),
  (OS.prototype.processIntersections = function (t, e, i, n) {
    if (t === i && e === n) return null;
    this.numTests++;
    var r = t.getCoordinates()[e],
      o = t.getCoordinates()[e + 1],
      a = i.getCoordinates()[n],
      s = i.getCoordinates()[n + 1];
    this._li.computeIntersection(r, o, a, s),
      this._li.hasIntersection() &&
        (this.numIntersections++,
        this._li.isInteriorIntersection() &&
          (this.numInteriorIntersections++, (this._hasInterior = !0)),
        this.isTrivialIntersection(t, e, i, n) ||
          ((this._hasIntersection = !0),
          t.addIntersections(this._li, e, 0),
          i.addIntersections(this._li, n, 1),
          this._li.isProper() &&
            (this.numProperIntersections++,
            (this._hasProper = !0),
            (this._hasProperInterior = !0))));
  }),
  (OS.prototype.hasIntersection = function () {
    return this._hasIntersection;
  }),
  (OS.prototype.isDone = function () {
    return !1;
  }),
  (OS.prototype.hasInteriorIntersection = function () {
    return this._hasInterior;
  }),
  (OS.prototype.interfaces_ = function () {
    return [RS];
  }),
  (OS.prototype.getClass = function () {
    return OS;
  }),
  (OS.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  });
var FS = function () {
  (this.coord = null), (this.segmentIndex = null), (this.dist = null);
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2];
  (this.coord = new qv(t)), (this.segmentIndex = e), (this.dist = i);
};
(FS.prototype.getSegmentIndex = function () {
  return this.segmentIndex;
}),
  (FS.prototype.getCoordinate = function () {
    return this.coord;
  }),
  (FS.prototype.print = function (t) {
    t.print(this.coord),
      t.print(" seg # = " + this.segmentIndex),
      t.println(" dist = " + this.dist);
  }),
  (FS.prototype.compareTo = function (t) {
    var e = t;
    return this.compare(e.segmentIndex, e.dist);
  }),
  (FS.prototype.isEndPoint = function (t) {
    return (
      (0 === this.segmentIndex && 0 === this.dist) || this.segmentIndex === t
    );
  }),
  (FS.prototype.toString = function () {
    return (
      this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
    );
  }),
  (FS.prototype.getDistance = function () {
    return this.dist;
  }),
  (FS.prototype.compare = function (t, e) {
    return this.segmentIndex < t
      ? -1
      : this.segmentIndex > t
      ? 1
      : this.dist < e
      ? -1
      : this.dist > e
      ? 1
      : 0;
  }),
  (FS.prototype.interfaces_ = function () {
    return [jv];
  }),
  (FS.prototype.getClass = function () {
    return FS;
  });
var zS = function () {
  (this._nodeMap = new hx()), (this.edge = null);
  var t = arguments[0];
  this.edge = t;
};
(zS.prototype.print = function (t) {
  t.println("Intersections:");
  for (var e = this.iterator(); e.hasNext(); ) {
    e.next().print(t);
  }
}),
  (zS.prototype.iterator = function () {
    return this._nodeMap.values().iterator();
  }),
  (zS.prototype.addSplitEdges = function (t) {
    this.addEndpoints();
    for (var e = this.iterator(), i = e.next(); e.hasNext(); ) {
      var n = e.next(),
        r = this.createSplitEdge(i, n);
      t.add(r), (i = n);
    }
  }),
  (zS.prototype.addEndpoints = function () {
    var t = this.edge.pts.length - 1;
    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
  }),
  (zS.prototype.createSplitEdge = function (t, e) {
    var i = e.segmentIndex - t.segmentIndex + 2,
      n = this.edge.pts[e.segmentIndex],
      r = e.dist > 0 || !e.coord.equals2D(n);
    r || i--;
    var o = new Array(i).fill(null),
      a = 0;
    o[a++] = new qv(t.coord);
    for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++)
      o[a++] = this.edge.pts[s];
    return r && (o[a] = e.coord), new jS(o, new b_(this.edge._label));
  }),
  (zS.prototype.add = function (t, e, i) {
    var n = new FS(t, e, i),
      r = this._nodeMap.get(n);
    return null !== r ? r : (this._nodeMap.put(n, n), n);
  }),
  (zS.prototype.isIntersection = function (t) {
    for (var e = this.iterator(); e.hasNext(); ) {
      if (e.next().coord.equals(t)) return !0;
    }
    return !1;
  }),
  (zS.prototype.interfaces_ = function () {
    return [];
  }),
  (zS.prototype.getClass = function () {
    return zS;
  });
var kS = function () {};
(kS.prototype.getChainStartIndices = function (t) {
  var e = 0,
    i = new Yb();
  i.add(new ib(e));
  do {
    var n = this.findChainEnd(t, e);
    i.add(new ib(n)), (e = n);
  } while (e < t.length - 1);
  return kS.toIntArray(i);
}),
  (kS.prototype.findChainEnd = function (t, e) {
    for (var i = A_.quadrant(t[e], t[e + 1]), n = e + 1; n < t.length; ) {
      if (A_.quadrant(t[n - 1], t[n]) !== i) break;
      n++;
    }
    return n - 1;
  }),
  (kS.prototype.interfaces_ = function () {
    return [];
  }),
  (kS.prototype.getClass = function () {
    return kS;
  }),
  (kS.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++)
      e[i] = t.get(i).intValue();
    return e;
  });
var BS = function () {
  (this.e = null),
    (this.pts = null),
    (this.startIndex = null),
    (this.env1 = new fb()),
    (this.env2 = new fb());
  var t = arguments[0];
  (this.e = t), (this.pts = t.getCoordinates());
  var e = new kS();
  this.startIndex = e.getChainStartIndices(this.pts);
};
(BS.prototype.getCoordinates = function () {
  return this.pts;
}),
  (BS.prototype.getMaxX = function (t) {
    var e = this.pts[this.startIndex[t]].x,
      i = this.pts[this.startIndex[t + 1]].x;
    return e > i ? e : i;
  }),
  (BS.prototype.getMinX = function (t) {
    var e = this.pts[this.startIndex[t]].x,
      i = this.pts[this.startIndex[t + 1]].x;
    return e < i ? e : i;
  }),
  (BS.prototype.computeIntersectsForChain = function () {
    if (4 === arguments.length) {
      var t = arguments[0],
        e = arguments[1],
        i = arguments[2],
        n = arguments[3];
      this.computeIntersectsForChain(
        this.startIndex[t],
        this.startIndex[t + 1],
        e,
        e.startIndex[i],
        e.startIndex[i + 1],
        n
      );
    } else if (6 === arguments.length) {
      var r = arguments[0],
        o = arguments[1],
        a = arguments[2],
        s = arguments[3],
        l = arguments[4],
        u = arguments[5],
        c = this.pts[r],
        h = this.pts[o],
        p = a.pts[s],
        d = a.pts[l];
      if (o - r == 1 && l - s == 1)
        return u.addIntersections(this.e, r, a.e, s), null;
      if (
        (this.env1.init(c, h),
        this.env2.init(p, d),
        !this.env1.intersects(this.env2))
      )
        return null;
      var f = Math.trunc((r + o) / 2),
        g = Math.trunc((s + l) / 2);
      r < f &&
        (s < g && this.computeIntersectsForChain(r, f, a, s, g, u),
        g < l && this.computeIntersectsForChain(r, f, a, g, l, u)),
        f < o &&
          (s < g && this.computeIntersectsForChain(f, o, a, s, g, u),
          g < l && this.computeIntersectsForChain(f, o, a, g, l, u));
    }
  }),
  (BS.prototype.getStartIndexes = function () {
    return this.startIndex;
  }),
  (BS.prototype.computeIntersects = function (t, e) {
    for (var i = 0; i < this.startIndex.length - 1; i++)
      for (var n = 0; n < t.startIndex.length - 1; n++)
        this.computeIntersectsForChain(i, t, n, e);
  }),
  (BS.prototype.interfaces_ = function () {
    return [];
  }),
  (BS.prototype.getClass = function () {
    return BS;
  });
var GS = function t() {
    this._depth = Array(2)
      .fill()
      .map(function () {
        return Array(3);
      });
    for (var e = 0; e < 2; e++)
      for (var i = 0; i < 3; i++) this._depth[e][i] = t.NULL_VALUE;
  },
  US = {
    NULL_VALUE: {
      configurable: !0,
    },
  };
(GS.prototype.getDepth = function (t, e) {
  return this._depth[t][e];
}),
  (GS.prototype.setDepth = function (t, e, i) {
    this._depth[t][e] = i;
  }),
  (GS.prototype.isNull = function () {
    if (0 === arguments.length) {
      for (var t = 0; t < 2; t++)
        for (var e = 0; e < 3; e++)
          if (this._depth[t][e] !== GS.NULL_VALUE) return !1;
      return !0;
    }
    if (1 === arguments.length) {
      var i = arguments[0];
      return this._depth[i][1] === GS.NULL_VALUE;
    }
    if (2 === arguments.length) {
      var n = arguments[0],
        r = arguments[1];
      return this._depth[n][r] === GS.NULL_VALUE;
    }
  }),
  (GS.prototype.normalize = function () {
    for (var t = this, e = 0; e < 2; e++)
      if (!t.isNull(e)) {
        var i = t._depth[e][1];
        t._depth[e][2] < i && (i = t._depth[e][2]), i < 0 && (i = 0);
        for (var n = 1; n < 3; n++) {
          var r = 0;
          t._depth[e][n] > i && (r = 1), (t._depth[e][n] = r);
        }
      }
  }),
  (GS.prototype.getDelta = function (t) {
    return this._depth[t][c_.RIGHT] - this._depth[t][c_.LEFT];
  }),
  (GS.prototype.getLocation = function (t, e) {
    return this._depth[t][e] <= 0 ? Zv.EXTERIOR : Zv.INTERIOR;
  }),
  (GS.prototype.toString = function () {
    return (
      "A: " +
      this._depth[0][1] +
      "," +
      this._depth[0][2] +
      " B: " +
      this._depth[1][1] +
      "," +
      this._depth[1][2]
    );
  }),
  (GS.prototype.add = function () {
    var t = this;
    if (1 === arguments.length)
      for (var e = arguments[0], i = 0; i < 2; i++)
        for (var n = 1; n < 3; n++) {
          var r = e.getLocation(i, n);
          (r !== Zv.EXTERIOR && r !== Zv.INTERIOR) ||
            (t.isNull(i, n)
              ? (t._depth[i][n] = GS.depthAtLocation(r))
              : (t._depth[i][n] += GS.depthAtLocation(r)));
        }
    else if (3 === arguments.length) {
      var o = arguments[0],
        a = arguments[1];
      arguments[2] === Zv.INTERIOR && this._depth[o][a]++;
    }
  }),
  (GS.prototype.interfaces_ = function () {
    return [];
  }),
  (GS.prototype.getClass = function () {
    return GS;
  }),
  (GS.depthAtLocation = function (t) {
    return t === Zv.EXTERIOR ? 0 : t === Zv.INTERIOR ? 1 : GS.NULL_VALUE;
  }),
  (US.NULL_VALUE.get = function () {
    return -1;
  }),
  Object.defineProperties(GS, US);
var jS = (function (t) {
    function e() {
      if (
        (t.call(this),
        (this.pts = null),
        (this._env = null),
        (this.eiList = new zS(this)),
        (this._name = null),
        (this._mce = null),
        (this._isIsolated = !0),
        (this._depth = new GS()),
        (this._depthDelta = 0),
        1 === arguments.length)
      ) {
        var i = arguments[0];
        e.call(this, i, null);
      } else if (2 === arguments.length) {
        var n = arguments[0],
          r = arguments[1];
        (this.pts = n), (this._label = r);
      }
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.getDepth = function () {
        return this._depth;
      }),
      (e.prototype.getCollapsedEdge = function () {
        var t = new Array(2).fill(null);
        return (
          (t[0] = this.pts[0]),
          (t[1] = this.pts[1]),
          new e(t, b_.toLineLabel(this._label))
        );
      }),
      (e.prototype.isIsolated = function () {
        return this._isIsolated;
      }),
      (e.prototype.getCoordinates = function () {
        return this.pts;
      }),
      (e.prototype.setIsolated = function (t) {
        this._isIsolated = t;
      }),
      (e.prototype.setName = function (t) {
        this._name = t;
      }),
      (e.prototype.equals = function (t) {
        if (!(t instanceof e)) return !1;
        var i = t;
        if (this.pts.length !== i.pts.length) return !1;
        for (
          var n = !0, r = !0, o = this.pts.length, a = 0;
          a < this.pts.length;
          a++
        )
          if (
            (this.pts[a].equals2D(i.pts[a]) || (n = !1),
            this.pts[a].equals2D(i.pts[--o]) || (r = !1),
            !n && !r)
          )
            return !1;
        return !0;
      }),
      (e.prototype.getCoordinate = function () {
        if (0 === arguments.length)
          return this.pts.length > 0 ? this.pts[0] : null;
        if (1 === arguments.length) {
          var t = arguments[0];
          return this.pts[t];
        }
      }),
      (e.prototype.print = function (t) {
        t.print("edge " + this._name + ": "), t.print("LINESTRING (");
        for (var e = 0; e < this.pts.length; e++)
          e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
        t.print(")  " + this._label + " " + this._depthDelta);
      }),
      (e.prototype.computeIM = function (t) {
        e.updateIM(this._label, t);
      }),
      (e.prototype.isCollapsed = function () {
        return (
          !!this._label.isArea() &&
          3 === this.pts.length &&
          !!this.pts[0].equals(this.pts[2])
        );
      }),
      (e.prototype.isClosed = function () {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }),
      (e.prototype.getMaximumSegmentIndex = function () {
        return this.pts.length - 1;
      }),
      (e.prototype.getDepthDelta = function () {
        return this._depthDelta;
      }),
      (e.prototype.getNumPoints = function () {
        return this.pts.length;
      }),
      (e.prototype.printReverse = function (t) {
        t.print("edge " + this._name + ": ");
        for (var e = this.pts.length - 1; e >= 0; e--)
          t.print(this.pts[e] + " ");
        t.println("");
      }),
      (e.prototype.getMonotoneChainEdge = function () {
        return null === this._mce && (this._mce = new BS(this)), this._mce;
      }),
      (e.prototype.getEnvelope = function () {
        if (null === this._env) {
          this._env = new fb();
          for (var t = 0; t < this.pts.length; t++)
            this._env.expandToInclude(this.pts[t]);
        }
        return this._env;
      }),
      (e.prototype.addIntersection = function (t, e, i, n) {
        var r = new qv(t.getIntersection(n)),
          o = e,
          a = t.getEdgeDistance(i, n),
          s = o + 1;
        if (s < this.pts.length) {
          var l = this.pts[s];
          r.equals2D(l) && ((o = s), (a = 0));
        }
        this.eiList.add(r, o, a);
      }),
      (e.prototype.toString = function () {
        var t = new eb();
        t.append("edge " + this._name + ": "), t.append("LINESTRING (");
        for (var e = 0; e < this.pts.length; e++)
          e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
        return (
          t.append(")  " + this._label + " " + this._depthDelta), t.toString()
        );
      }),
      (e.prototype.isPointwiseEqual = function (t) {
        if (this.pts.length !== t.pts.length) return !1;
        for (var e = 0; e < this.pts.length; e++)
          if (!this.pts[e].equals2D(t.pts[e])) return !1;
        return !0;
      }),
      (e.prototype.setDepthDelta = function (t) {
        this._depthDelta = t;
      }),
      (e.prototype.getEdgeIntersectionList = function () {
        return this.eiList;
      }),
      (e.prototype.addIntersections = function (t, e, i) {
        for (var n = 0; n < t.getIntersectionNum(); n++)
          this.addIntersection(t, e, i, n);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.updateIM = function () {
        if (2 !== arguments.length)
          return t.prototype.updateIM.apply(this, arguments);
        var e = arguments[0],
          i = arguments[1];
        i.setAtLeastIfValid(
          e.getLocation(0, c_.ON),
          e.getLocation(1, c_.ON),
          1
        ),
          e.isArea() &&
            (i.setAtLeastIfValid(
              e.getLocation(0, c_.LEFT),
              e.getLocation(1, c_.LEFT),
              2
            ),
            i.setAtLeastIfValid(
              e.getLocation(0, c_.RIGHT),
              e.getLocation(1, c_.RIGHT),
              2
            ));
      }),
      e
    );
  })(M_),
  HS = function (t) {
    (this._workingPrecisionModel = null),
      (this._workingNoder = null),
      (this._geomFact = null),
      (this._graph = null),
      (this._edgeList = new NS()),
      (this._bufParams = t || null);
  };
(HS.prototype.setWorkingPrecisionModel = function (t) {
  this._workingPrecisionModel = t;
}),
  (HS.prototype.insertUniqueEdge = function (t) {
    var e = this._edgeList.findEqualEdge(t);
    if (null !== e) {
      var i = e.getLabel(),
        n = t.getLabel();
      e.isPointwiseEqual(t) || (n = new b_(t.getLabel())).flip(), i.merge(n);
      var r = HS.depthDelta(n),
        o = e.getDepthDelta() + r;
      e.setDepthDelta(o);
    } else this._edgeList.add(t), t.setDepthDelta(HS.depthDelta(t.getLabel()));
  }),
  (HS.prototype.buildSubgraphs = function (t, e) {
    for (var i = new Yb(), n = t.iterator(); n.hasNext(); ) {
      var r = n.next(),
        o = r.getRightmostCoordinate(),
        a = new _S(i).getDepth(o);
      r.computeDepth(a),
        r.findResultEdges(),
        i.add(r),
        e.add(r.getDirectedEdges(), r.getNodes());
    }
  }),
  (HS.prototype.createSubgraphs = function (t) {
    for (var e = new Yb(), i = t.getNodes().iterator(); i.hasNext(); ) {
      var n = i.next();
      if (!n.isVisited()) {
        var r = new y_();
        r.create(n), e.add(r);
      }
    }
    return G_.sort(e, G_.reverseOrder()), e;
  }),
  (HS.prototype.createEmptyResultGeometry = function () {
    return this._geomFact.createPolygon();
  }),
  (HS.prototype.getNoder = function (t) {
    if (null !== this._workingNoder) return this._workingNoder;
    var e = new lS(),
      i = new Ab();
    return i.setPrecisionModel(t), e.setSegmentIntersector(new OS(i)), e;
  }),
  (HS.prototype.buffer = function (t, e) {
    var i = this._workingPrecisionModel;
    null === i && (i = t.getPrecisionModel()),
      (this._geomFact = t.getFactory());
    var n = new xS(i, this._bufParams),
      r = new wS(t, e, n).getCurves();
    if (r.size() <= 0) return this.createEmptyResultGeometry();
    this.computeNodedEdges(r, i),
      (this._graph = new L_(new LS())),
      this._graph.addEdges(this._edgeList.getEdges());
    var o = this.createSubgraphs(this._graph),
      a = new I_(this._geomFact);
    this.buildSubgraphs(o, a);
    var s = a.getPolygons();
    return s.size() <= 0
      ? this.createEmptyResultGeometry()
      : this._geomFact.buildGeometry(s);
  }),
  (HS.prototype.computeNodedEdges = function (t, e) {
    var i = this.getNoder(e);
    i.computeNodes(t);
    for (var n = i.getNodedSubstrings().iterator(); n.hasNext(); ) {
      var r = n.next(),
        o = r.getCoordinates();
      if (2 !== o.length || !o[0].equals2D(o[1])) {
        var a = r.getData(),
          s = new jS(r.getCoordinates(), new b_(a));
        this.insertUniqueEdge(s);
      }
    }
  }),
  (HS.prototype.setNoder = function (t) {
    this._workingNoder = t;
  }),
  (HS.prototype.interfaces_ = function () {
    return [];
  }),
  (HS.prototype.getClass = function () {
    return HS;
  }),
  (HS.depthDelta = function (t) {
    var e = t.getLocation(0, c_.LEFT),
      i = t.getLocation(0, c_.RIGHT);
    return e === Zv.INTERIOR && i === Zv.EXTERIOR
      ? 1
      : e === Zv.EXTERIOR && i === Zv.INTERIOR
      ? -1
      : 0;
  }),
  (HS.convertSegStrings = function (t) {
    for (var e = new i_(), i = new Yb(); t.hasNext(); ) {
      var n = t.next(),
        r = e.createLineString(n.getCoordinates());
      i.add(r);
    }
    return e.buildGeometry(i);
  });
var VS = function () {
  if (
    ((this._noder = null),
    (this._scaleFactor = null),
    (this._offsetX = null),
    (this._offsetY = null),
    (this._isScaled = !1),
    2 === arguments.length)
  ) {
    var t = arguments[0],
      e = arguments[1];
    (this._noder = t),
      (this._scaleFactor = e),
      (this._offsetX = 0),
      (this._offsetY = 0),
      (this._isScaled = !this.isIntegerPrecision());
  } else if (4 === arguments.length) {
    var i = arguments[0],
      n = arguments[1],
      r = arguments[2],
      o = arguments[3];
    (this._noder = i),
      (this._scaleFactor = n),
      (this._offsetX = r),
      (this._offsetY = o),
      (this._isScaled = !this.isIntegerPrecision());
  }
};
(VS.prototype.rescale = function () {
  var t = this;
  if (Kv(arguments[0], jb))
    for (var e = arguments[0].iterator(); e.hasNext(); ) {
      var i = e.next();
      t.rescale(i.getCoordinates());
    }
  else if (arguments[0] instanceof Array) {
    for (var n = arguments[0], r = 0; r < n.length; r++)
      (n[r].x = n[r].x / t._scaleFactor + t._offsetX),
        (n[r].y = n[r].y / t._scaleFactor + t._offsetY);
    2 === n.length && n[0].equals2D(n[1]) && pb.out.println(n);
  }
}),
  (VS.prototype.scale = function () {
    var t = this;
    if (Kv(arguments[0], jb)) {
      for (
        var e = arguments[0], i = new Yb(), n = e.iterator();
        n.hasNext();

      ) {
        var r = n.next();
        i.add(new tS(t.scale(r.getCoordinates()), r.getData()));
      }
      return i;
    }
    if (arguments[0] instanceof Array) {
      for (
        var o = arguments[0], a = new Array(o.length).fill(null), s = 0;
        s < o.length;
        s++
      )
        a[s] = new qv(
          Math.round((o[s].x - t._offsetX) * t._scaleFactor),
          Math.round((o[s].y - t._offsetY) * t._scaleFactor),
          o[s].z
        );
      return Zb.removeRepeatedPoints(a);
    }
  }),
  (VS.prototype.isIntegerPrecision = function () {
    return 1 === this._scaleFactor;
  }),
  (VS.prototype.getNodedSubstrings = function () {
    var t = this._noder.getNodedSubstrings();
    return this._isScaled && this.rescale(t), t;
  }),
  (VS.prototype.computeNodes = function (t) {
    var e = t;
    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);
  }),
  (VS.prototype.interfaces_ = function () {
    return [aS];
  }),
  (VS.prototype.getClass = function () {
    return VS;
  });
var WS = function () {
    (this._li = new Ab()), (this._segStrings = null);
    var t = arguments[0];
    this._segStrings = t;
  },
  qS = {
    fact: {
      configurable: !0,
    },
  };
(WS.prototype.checkEndPtVertexIntersections = function () {
  var t = this;
  if (0 === arguments.length)
    for (var e = this._segStrings.iterator(); e.hasNext(); ) {
      var i = e.next().getCoordinates();
      t.checkEndPtVertexIntersections(i[0], t._segStrings),
        t.checkEndPtVertexIntersections(i[i.length - 1], t._segStrings);
    }
  else if (2 === arguments.length)
    for (var n = arguments[0], r = arguments[1].iterator(); r.hasNext(); )
      for (var o = r.next().getCoordinates(), a = 1; a < o.length - 1; a++)
        if (o[a].equals(n))
          throw new _b(
            "found endpt/interior pt intersection at index " + a + " :pt " + n
          );
}),
  (WS.prototype.checkInteriorIntersections = function () {
    if (0 === arguments.length)
      for (var t = this._segStrings.iterator(); t.hasNext(); )
        for (var e = t.next(), i = this._segStrings.iterator(); i.hasNext(); ) {
          var n = i.next();
          this.checkInteriorIntersections(e, n);
        }
    else if (2 === arguments.length)
      for (
        var r = arguments[0],
          o = arguments[1],
          a = r.getCoordinates(),
          s = o.getCoordinates(),
          l = 0;
        l < a.length - 1;
        l++
      )
        for (var u = 0; u < s.length - 1; u++)
          this.checkInteriorIntersections(r, l, o, u);
    else if (4 === arguments.length) {
      var c = arguments[0],
        h = arguments[1],
        p = arguments[2],
        d = arguments[3];
      if (c === p && h === d) return null;
      var f = c.getCoordinates()[h],
        g = c.getCoordinates()[h + 1],
        m = p.getCoordinates()[d],
        y = p.getCoordinates()[d + 1];
      if (
        (this._li.computeIntersection(f, g, m, y),
        this._li.hasIntersection() &&
          (this._li.isProper() ||
            this.hasInteriorIntersection(this._li, f, g) ||
            this.hasInteriorIntersection(this._li, m, y)))
      )
        throw new _b(
          "found non-noded intersection at " +
            f +
            "-" +
            g +
            " and " +
            m +
            "-" +
            y
        );
    }
  }),
  (WS.prototype.checkValid = function () {
    this.checkEndPtVertexIntersections(),
      this.checkInteriorIntersections(),
      this.checkCollapses();
  }),
  (WS.prototype.checkCollapses = function () {
    if (0 === arguments.length)
      for (var t = this._segStrings.iterator(); t.hasNext(); ) {
        var e = t.next();
        this.checkCollapses(e);
      }
    else if (1 === arguments.length)
      for (var i = arguments[0].getCoordinates(), n = 0; n < i.length - 2; n++)
        this.checkCollapse(i[n], i[n + 1], i[n + 2]);
  }),
  (WS.prototype.hasInteriorIntersection = function (t, e, i) {
    for (var n = 0; n < t.getIntersectionNum(); n++) {
      var r = t.getIntersection(n);
      if (!r.equals(e) && !r.equals(i)) return !0;
    }
    return !1;
  }),
  (WS.prototype.checkCollapse = function (t, e, i) {
    if (t.equals(i))
      throw new _b(
        "found non-noded collapse at " + WS.fact.createLineString([t, e, i])
      );
  }),
  (WS.prototype.interfaces_ = function () {
    return [];
  }),
  (WS.prototype.getClass = function () {
    return WS;
  }),
  (qS.fact.get = function () {
    return new i_();
  }),
  Object.defineProperties(WS, qS);
var YS = function () {
    (this._li = null),
      (this._pt = null),
      (this._originalPt = null),
      (this._ptScaled = null),
      (this._p0Scaled = null),
      (this._p1Scaled = null),
      (this._scaleFactor = null),
      (this._minx = null),
      (this._maxx = null),
      (this._miny = null),
      (this._maxy = null),
      (this._corner = new Array(4).fill(null)),
      (this._safeEnv = null);
    var t = arguments[0],
      e = arguments[1],
      i = arguments[2];
    if (
      ((this._originalPt = t),
      (this._pt = t),
      (this._scaleFactor = e),
      (this._li = i),
      e <= 0)
    )
      throw new Bv("Scale factor must be non-zero");
    1 !== e &&
      ((this._pt = new qv(this.scale(t.x), this.scale(t.y))),
      (this._p0Scaled = new qv()),
      (this._p1Scaled = new qv())),
      this.initCorners(this._pt);
  },
  XS = {
    SAFE_ENV_EXPANSION_FACTOR: {
      configurable: !0,
    },
  };
(YS.prototype.intersectsScaled = function (t, e) {
  var i = Math.min(t.x, e.x),
    n = Math.max(t.x, e.x),
    r = Math.min(t.y, e.y),
    o = Math.max(t.y, e.y),
    a = this._maxx < i || this._minx > n || this._maxy < r || this._miny > o;
  if (a) return !1;
  var s = this.intersectsToleranceSquare(t, e);
  return Mb.isTrue(!(a && s), "Found bad envelope test"), s;
}),
  (YS.prototype.initCorners = function (t) {
    var e = 0.5;
    (this._minx = t.x - e),
      (this._maxx = t.x + e),
      (this._miny = t.y - e),
      (this._maxy = t.y + e),
      (this._corner[0] = new qv(this._maxx, this._maxy)),
      (this._corner[1] = new qv(this._minx, this._maxy)),
      (this._corner[2] = new qv(this._minx, this._miny)),
      (this._corner[3] = new qv(this._maxx, this._miny));
  }),
  (YS.prototype.intersects = function (t, e) {
    return 1 === this._scaleFactor
      ? this.intersectsScaled(t, e)
      : (this.copyScaled(t, this._p0Scaled),
        this.copyScaled(e, this._p1Scaled),
        this.intersectsScaled(this._p0Scaled, this._p1Scaled));
  }),
  (YS.prototype.scale = function (t) {
    return Math.round(t * this._scaleFactor);
  }),
  (YS.prototype.getCoordinate = function () {
    return this._originalPt;
  }),
  (YS.prototype.copyScaled = function (t, e) {
    (e.x = this.scale(t.x)), (e.y = this.scale(t.y));
  }),
  (YS.prototype.getSafeEnvelope = function () {
    if (null === this._safeEnv) {
      var t = YS.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
      this._safeEnv = new fb(
        this._originalPt.x - t,
        this._originalPt.x + t,
        this._originalPt.y - t,
        this._originalPt.y + t
      );
    }
    return this._safeEnv;
  }),
  (YS.prototype.intersectsPixelClosure = function (t, e) {
    return (
      this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
      !!this._li.hasIntersection() ||
        (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
        !!this._li.hasIntersection() ||
          (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
          !!this._li.hasIntersection() ||
            (this._li.computeIntersection(
              t,
              e,
              this._corner[3],
              this._corner[0]
            ),
            !!this._li.hasIntersection())))
    );
  }),
  (YS.prototype.intersectsToleranceSquare = function (t, e) {
    var i = !1,
      n = !1;
    return (
      this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
      !!this._li.isProper() ||
        (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
        !!this._li.isProper() ||
          (this._li.hasIntersection() && (i = !0),
          this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
          !!this._li.isProper() ||
            (this._li.hasIntersection() && (n = !0),
            this._li.computeIntersection(
              t,
              e,
              this._corner[3],
              this._corner[0]
            ),
            !!this._li.isProper() ||
              !(!i || !n) ||
              !!t.equals(this._pt) ||
              !!e.equals(this._pt))))
    );
  }),
  (YS.prototype.addSnappedNode = function (t, e) {
    var i = t.getCoordinate(e),
      n = t.getCoordinate(e + 1);
    return (
      !!this.intersects(i, n) &&
      (t.addIntersection(this.getCoordinate(), e), !0)
    );
  }),
  (YS.prototype.interfaces_ = function () {
    return [];
  }),
  (YS.prototype.getClass = function () {
    return YS;
  }),
  (XS.SAFE_ENV_EXPANSION_FACTOR.get = function () {
    return 0.75;
  }),
  Object.defineProperties(YS, XS);
var QS = function () {
  (this.tempEnv1 = new fb()), (this.selectedSegment = new eS());
};
(QS.prototype.select = function () {
  if (1 === arguments.length);
  else if (2 === arguments.length) {
    var t = arguments[1];
    arguments[0].getLineSegment(t, this.selectedSegment),
      this.select(this.selectedSegment);
  }
}),
  (QS.prototype.interfaces_ = function () {
    return [];
  }),
  (QS.prototype.getClass = function () {
    return QS;
  });
var ZS = function () {
    this._index = null;
    var t = arguments[0];
    this._index = t;
  },
  JS = {
    HotPixelSnapAction: {
      configurable: !0,
    },
  };
(ZS.prototype.snap = function () {
  if (1 === arguments.length) {
    var t = arguments[0];
    return this.snap(t, null, -1);
  }
  if (3 === arguments.length) {
    var e = arguments[0],
      i = arguments[1],
      n = arguments[2],
      r = e.getSafeEnvelope(),
      o = new KS(e, i, n);
    return (
      this._index.query(r, {
        interfaces_: function () {
          return [F_];
        },
        visitItem: function (t) {
          t.select(r, o);
        },
      }),
      o.isNodeAdded()
    );
  }
}),
  (ZS.prototype.interfaces_ = function () {
    return [];
  }),
  (ZS.prototype.getClass = function () {
    return ZS;
  }),
  (JS.HotPixelSnapAction.get = function () {
    return KS;
  }),
  Object.defineProperties(ZS, JS);
var KS = (function (t) {
    function e() {
      t.call(this),
        (this._hotPixel = null),
        (this._parentEdge = null),
        (this._hotPixelVertexIndex = null),
        (this._isNodeAdded = !1);
      var e = arguments[0],
        i = arguments[1],
        n = arguments[2];
      (this._hotPixel = e),
        (this._parentEdge = i),
        (this._hotPixelVertexIndex = n);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.isNodeAdded = function () {
        return this._isNodeAdded;
      }),
      (e.prototype.select = function () {
        if (2 !== arguments.length)
          return t.prototype.select.apply(this, arguments);
        var e = arguments[1],
          i = arguments[0].getContext();
        if (
          null !== this._parentEdge &&
          i === this._parentEdge &&
          e === this._hotPixelVertexIndex
        )
          return null;
        this._isNodeAdded = this._hotPixel.addSnappedNode(i, e);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(QS),
  $S = function () {
    (this._li = null), (this._interiorIntersections = null);
    var t = arguments[0];
    (this._li = t), (this._interiorIntersections = new Yb());
  };
($S.prototype.processIntersections = function (t, e, i, n) {
  if (t === i && e === n) return null;
  var r = t.getCoordinates()[e],
    o = t.getCoordinates()[e + 1],
    a = i.getCoordinates()[n],
    s = i.getCoordinates()[n + 1];
  if (
    (this._li.computeIntersection(r, o, a, s),
    this._li.hasIntersection() && this._li.isInteriorIntersection())
  ) {
    for (var l = 0; l < this._li.getIntersectionNum(); l++)
      this._interiorIntersections.add(this._li.getIntersection(l));
    t.addIntersections(this._li, e, 0), i.addIntersections(this._li, n, 1);
  }
}),
  ($S.prototype.isDone = function () {
    return !1;
  }),
  ($S.prototype.getInteriorIntersections = function () {
    return this._interiorIntersections;
  }),
  ($S.prototype.interfaces_ = function () {
    return [RS];
  }),
  ($S.prototype.getClass = function () {
    return $S;
  });
var tM = function () {
  (this._pm = null),
    (this._li = null),
    (this._scaleFactor = null),
    (this._noder = null),
    (this._pointSnapper = null),
    (this._nodedSegStrings = null);
  var t = arguments[0];
  (this._pm = t),
    (this._li = new Ab()),
    this._li.setPrecisionModel(t),
    (this._scaleFactor = t.getScale());
};
(tM.prototype.checkCorrectness = function (t) {
  var e = tS.getNodedSubstrings(t),
    i = new WS(e);
  try {
    i.checkValid();
  } catch (n) {
    if (!(n instanceof cb)) throw n;
    n.printStackTrace();
  }
}),
  (tM.prototype.getNodedSubstrings = function () {
    return tS.getNodedSubstrings(this._nodedSegStrings);
  }),
  (tM.prototype.snapRound = function (t, e) {
    var i = this.findInteriorIntersections(t, e);
    this.computeIntersectionSnaps(i), this.computeVertexSnaps(t);
  }),
  (tM.prototype.findInteriorIntersections = function (t, e) {
    var i = new $S(e);
    return (
      this._noder.setSegmentIntersector(i),
      this._noder.computeNodes(t),
      i.getInteriorIntersections()
    );
  }),
  (tM.prototype.computeVertexSnaps = function () {
    var t = this;
    if (Kv(arguments[0], jb))
      for (var e = arguments[0].iterator(); e.hasNext(); ) {
        var i = e.next();
        t.computeVertexSnaps(i);
      }
    else if (arguments[0] instanceof tS)
      for (
        var n = arguments[0], r = n.getCoordinates(), o = 0;
        o < r.length;
        o++
      ) {
        var a = new YS(r[o], t._scaleFactor, t._li);
        t._pointSnapper.snap(a, n, o) && n.addIntersection(r[o], o);
      }
  }),
  (tM.prototype.computeNodes = function (t) {
    (this._nodedSegStrings = t),
      (this._noder = new lS()),
      (this._pointSnapper = new ZS(this._noder.getIndex())),
      this.snapRound(t, this._li);
  }),
  (tM.prototype.computeIntersectionSnaps = function (t) {
    for (var e = this, i = t.iterator(); i.hasNext(); ) {
      var n = i.next(),
        r = new YS(n, e._scaleFactor, e._li);
      e._pointSnapper.snap(r);
    }
  }),
  (tM.prototype.interfaces_ = function () {
    return [aS];
  }),
  (tM.prototype.getClass = function () {
    return tM;
  });
var eM = function () {
    if (
      ((this._argGeom = null),
      (this._distance = null),
      (this._bufParams = new cS()),
      (this._resultGeometry = null),
      (this._saveException = null),
      1 === arguments.length)
    ) {
      var t = arguments[0];
      this._argGeom = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      (this._argGeom = e), (this._bufParams = i);
    }
  },
  iM = {
    CAP_ROUND: {
      configurable: !0,
    },
    CAP_BUTT: {
      configurable: !0,
    },
    CAP_FLAT: {
      configurable: !0,
    },
    CAP_SQUARE: {
      configurable: !0,
    },
    MAX_PRECISION_DIGITS: {
      configurable: !0,
    },
  };
(eM.prototype.bufferFixedPrecision = function (t) {
  var e = new VS(new tM(new Kx(1)), t.getScale()),
    i = new HS(this._bufParams);
  i.setWorkingPrecisionModel(t),
    i.setNoder(e),
    (this._resultGeometry = i.buffer(this._argGeom, this._distance));
}),
  (eM.prototype.bufferReducedPrecision = function () {
    var t = this;
    if (0 === arguments.length) {
      for (var e = eM.MAX_PRECISION_DIGITS; e >= 0; e--) {
        try {
          t.bufferReducedPrecision(e);
        } catch (o) {
          if (!(o instanceof g_)) throw o;
          t._saveException = o;
        }
        if (null !== t._resultGeometry) return null;
      }
      throw this._saveException;
    }
    if (1 === arguments.length) {
      var i = arguments[0],
        n = eM.precisionScaleFactor(this._argGeom, this._distance, i),
        r = new Kx(n);
      this.bufferFixedPrecision(r);
    }
  }),
  (eM.prototype.computeGeometry = function () {
    if ((this.bufferOriginalPrecision(), null !== this._resultGeometry))
      return null;
    var t = this._argGeom.getFactory().getPrecisionModel();
    t.getType() === Kx.FIXED
      ? this.bufferFixedPrecision(t)
      : this.bufferReducedPrecision();
  }),
  (eM.prototype.setQuadrantSegments = function (t) {
    this._bufParams.setQuadrantSegments(t);
  }),
  (eM.prototype.bufferOriginalPrecision = function () {
    try {
      var t = new HS(this._bufParams);
      this._resultGeometry = t.buffer(this._argGeom, this._distance);
    } catch (e) {
      if (!(e instanceof _b)) throw e;
      this._saveException = e;
    }
  }),
  (eM.prototype.getResultGeometry = function (t) {
    return (this._distance = t), this.computeGeometry(), this._resultGeometry;
  }),
  (eM.prototype.setEndCapStyle = function (t) {
    this._bufParams.setEndCapStyle(t);
  }),
  (eM.prototype.interfaces_ = function () {
    return [];
  }),
  (eM.prototype.getClass = function () {
    return eM;
  }),
  (eM.bufferOp = function () {
    if (2 === arguments.length) {
      var t = arguments[1];
      return new eM(arguments[0]).getResultGeometry(t);
    }
    if (3 === arguments.length) {
      if (
        Number.isInteger(arguments[2]) &&
        arguments[0] instanceof Ib &&
        "number" == typeof arguments[1]
      ) {
        var e = arguments[1],
          i = arguments[2],
          n = new eM(arguments[0]);
        return n.setQuadrantSegments(i), n.getResultGeometry(e);
      }
      if (
        arguments[2] instanceof cS &&
        arguments[0] instanceof Ib &&
        "number" == typeof arguments[1]
      ) {
        var r = arguments[1];
        return new eM(arguments[0], arguments[2]).getResultGeometry(r);
      }
    } else if (4 === arguments.length) {
      var o = arguments[1],
        a = arguments[2],
        s = arguments[3],
        l = new eM(arguments[0]);
      return (
        l.setQuadrantSegments(a), l.setEndCapStyle(s), l.getResultGeometry(o)
      );
    }
  }),
  (eM.precisionScaleFactor = function (t, e, i) {
    var n = t.getEnvelopeInternal(),
      r =
        $v.max(
          Math.abs(n.getMaxX()),
          Math.abs(n.getMaxY()),
          Math.abs(n.getMinX()),
          Math.abs(n.getMinY())
        ) +
        2 * (e > 0 ? e : 0),
      o = i - Math.trunc(Math.log(r) / Math.log(10) + 1);
    return Math.pow(10, o);
  }),
  (iM.CAP_ROUND.get = function () {
    return cS.CAP_ROUND;
  }),
  (iM.CAP_BUTT.get = function () {
    return cS.CAP_FLAT;
  }),
  (iM.CAP_FLAT.get = function () {
    return cS.CAP_FLAT;
  }),
  (iM.CAP_SQUARE.get = function () {
    return cS.CAP_SQUARE;
  }),
  (iM.MAX_PRECISION_DIGITS.get = function () {
    return 12;
  }),
  Object.defineProperties(eM, iM);
var nM = function () {
  (this._pt = [new qv(), new qv()]),
    (this._distance = Gv.NaN),
    (this._isNull = !0);
};
(nM.prototype.getCoordinates = function () {
  return this._pt;
}),
  (nM.prototype.getCoordinate = function (t) {
    return this._pt[t];
  }),
  (nM.prototype.setMinimum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMinimum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      if (this._isNull) return this.initialize(e, i), null;
      var n = e.distance(i);
      n < this._distance && this.initialize(e, i, n);
    }
  }),
  (nM.prototype.initialize = function () {
    if (0 === arguments.length) this._isNull = !0;
    else if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      this._pt[0].setCoordinate(t),
        this._pt[1].setCoordinate(e),
        (this._distance = t.distance(e)),
        (this._isNull = !1);
    } else if (3 === arguments.length) {
      var i = arguments[0],
        n = arguments[1],
        r = arguments[2];
      this._pt[0].setCoordinate(i),
        this._pt[1].setCoordinate(n),
        (this._distance = r),
        (this._isNull = !1);
    }
  }),
  (nM.prototype.getDistance = function () {
    return this._distance;
  }),
  (nM.prototype.setMaximum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMaximum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      if (this._isNull) return this.initialize(e, i), null;
      var n = e.distance(i);
      n > this._distance && this.initialize(e, i, n);
    }
  }),
  (nM.prototype.interfaces_ = function () {
    return [];
  }),
  (nM.prototype.getClass = function () {
    return nM;
  });
var rM = function () {};
(rM.prototype.interfaces_ = function () {
  return [];
}),
  (rM.prototype.getClass = function () {
    return rM;
  }),
  (rM.computeDistance = function () {
    if (
      arguments[2] instanceof nM &&
      arguments[0] instanceof Rx &&
      arguments[1] instanceof qv
    )
      for (
        var t = arguments[1],
          e = arguments[2],
          i = arguments[0].getCoordinates(),
          n = new eS(),
          r = 0;
        r < i.length - 1;
        r++
      ) {
        n.setCoordinates(i[r], i[r + 1]);
        var o = n.closestPoint(t);
        e.setMinimum(o, t);
      }
    else if (
      arguments[2] instanceof nM &&
      arguments[0] instanceof kx &&
      arguments[1] instanceof qv
    ) {
      var a = arguments[0],
        s = arguments[1],
        l = arguments[2];
      rM.computeDistance(a.getExteriorRing(), s, l);
      for (var u = 0; u < a.getNumInteriorRing(); u++)
        rM.computeDistance(a.getInteriorRingN(u), s, l);
    } else if (
      arguments[2] instanceof nM &&
      arguments[0] instanceof Ib &&
      arguments[1] instanceof qv
    ) {
      var c = arguments[0],
        h = arguments[1],
        p = arguments[2];
      if (c instanceof Rx) rM.computeDistance(c, h, p);
      else if (c instanceof kx) rM.computeDistance(c, h, p);
      else if (c instanceof _x)
        for (var d = c, f = 0; f < d.getNumGeometries(); f++) {
          var g = d.getGeometryN(f);
          rM.computeDistance(g, h, p);
        }
      else p.setMinimum(c.getCoordinate(), h);
    } else if (
      arguments[2] instanceof nM &&
      arguments[0] instanceof eS &&
      arguments[1] instanceof qv
    ) {
      var m = arguments[1],
        y = arguments[2],
        v = arguments[0].closestPoint(m);
      y.setMinimum(v, m);
    }
  });
var oM = function (t) {
    (this._maxPtDist = new nM()), (this._inputGeom = t || null);
  },
  aM = {
    MaxPointDistanceFilter: {
      configurable: !0,
    },
    MaxMidpointDistanceFilter: {
      configurable: !0,
    },
  };
(oM.prototype.computeMaxMidpointDistance = function (t) {
  var e = new lM(this._inputGeom);
  t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
}),
  (oM.prototype.computeMaxVertexDistance = function (t) {
    var e = new sM(this._inputGeom);
    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
  }),
  (oM.prototype.findDistance = function (t) {
    return (
      this.computeMaxVertexDistance(t),
      this.computeMaxMidpointDistance(t),
      this._maxPtDist.getDistance()
    );
  }),
  (oM.prototype.getDistancePoints = function () {
    return this._maxPtDist;
  }),
  (oM.prototype.interfaces_ = function () {
    return [];
  }),
  (oM.prototype.getClass = function () {
    return oM;
  }),
  (aM.MaxPointDistanceFilter.get = function () {
    return sM;
  }),
  (aM.MaxMidpointDistanceFilter.get = function () {
    return lM;
  }),
  Object.defineProperties(oM, aM);
var sM = function (t) {
  (this._maxPtDist = new nM()),
    (this._minPtDist = new nM()),
    (this._geom = t || null);
};
(sM.prototype.filter = function (t) {
  this._minPtDist.initialize(),
    rM.computeDistance(this._geom, t, this._minPtDist),
    this._maxPtDist.setMaximum(this._minPtDist);
}),
  (sM.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }),
  (sM.prototype.interfaces_ = function () {
    return [Ob];
  }),
  (sM.prototype.getClass = function () {
    return sM;
  });
var lM = function (t) {
  (this._maxPtDist = new nM()),
    (this._minPtDist = new nM()),
    (this._geom = t || null);
};
(lM.prototype.filter = function (t, e) {
  if (0 === e) return null;
  var i = t.getCoordinate(e - 1),
    n = t.getCoordinate(e),
    r = new qv((i.x + n.x) / 2, (i.y + n.y) / 2);
  this._minPtDist.initialize(),
    rM.computeDistance(this._geom, r, this._minPtDist),
    this._maxPtDist.setMaximum(this._minPtDist);
}),
  (lM.prototype.isDone = function () {
    return !1;
  }),
  (lM.prototype.isGeometryChanged = function () {
    return !1;
  }),
  (lM.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }),
  (lM.prototype.interfaces_ = function () {
    return [xx];
  }),
  (lM.prototype.getClass = function () {
    return lM;
  });
var uM = function (t) {
  this._comps = t || null;
};
(uM.prototype.filter = function (t) {
  t instanceof kx && this._comps.add(t);
}),
  (uM.prototype.interfaces_ = function () {
    return [bx];
  }),
  (uM.prototype.getClass = function () {
    return uM;
  }),
  (uM.getPolygons = function () {
    if (1 === arguments.length) return uM.getPolygons(arguments[0], new Yb());
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      return (
        t instanceof kx ? e.add(t) : t instanceof _x && t.apply(new uM(e)), e
      );
    }
  });
var cM = function () {
  if (
    ((this._lines = null),
    (this._isForcedToLineString = !1),
    1 === arguments.length)
  ) {
    var t = arguments[0];
    this._lines = t;
  } else if (2 === arguments.length) {
    var e = arguments[0],
      i = arguments[1];
    (this._lines = e), (this._isForcedToLineString = i);
  }
};
(cM.prototype.filter = function (t) {
  if (this._isForcedToLineString && t instanceof Gx) {
    var e = t.getFactory().createLineString(t.getCoordinateSequence());
    return this._lines.add(e), null;
  }
  t instanceof Rx && this._lines.add(t);
}),
  (cM.prototype.setForceToLineString = function (t) {
    this._isForcedToLineString = t;
  }),
  (cM.prototype.interfaces_ = function () {
    return [Lb];
  }),
  (cM.prototype.getClass = function () {
    return cM;
  }),
  (cM.getGeometry = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t.getFactory().buildGeometry(cM.getLines(t));
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      return e.getFactory().buildGeometry(cM.getLines(e, i));
    }
  }),
  (cM.getLines = function () {
    if (1 === arguments.length) return cM.getLines(arguments[0], !1);
    if (2 === arguments.length) {
      if (Kv(arguments[0], jb) && Kv(arguments[1], jb)) {
        for (var t = arguments[1], e = arguments[0].iterator(); e.hasNext(); ) {
          var i = e.next();
          cM.getLines(i, t);
        }
        return t;
      }
      if (arguments[0] instanceof Ib && "boolean" == typeof arguments[1]) {
        var n = arguments[0],
          r = arguments[1],
          o = new Yb();
        return n.apply(new cM(o, r)), o;
      }
      if (arguments[0] instanceof Ib && Kv(arguments[1], jb)) {
        var a = arguments[0],
          s = arguments[1];
        return a instanceof Rx ? s.add(a) : a.apply(new cM(s)), s;
      }
    } else if (3 === arguments.length) {
      if (
        "boolean" == typeof arguments[2] &&
        Kv(arguments[0], jb) &&
        Kv(arguments[1], jb)
      ) {
        for (
          var l = arguments[1], u = arguments[2], c = arguments[0].iterator();
          c.hasNext();

        ) {
          var h = c.next();
          cM.getLines(h, l, u);
        }
        return l;
      }
      if (
        "boolean" == typeof arguments[2] &&
        arguments[0] instanceof Ib &&
        Kv(arguments[1], jb)
      ) {
        var p = arguments[1],
          d = arguments[2];
        return arguments[0].apply(new cM(p, d)), p;
      }
    }
  });
var hM = function () {
  if (
    ((this._boundaryRule = Fb.OGC_SFS_BOUNDARY_RULE),
    (this._isIn = null),
    (this._numBoundaries = null),
    0 === arguments.length)
  );
  else if (1 === arguments.length) {
    var t = arguments[0];
    if (null === t) throw new Bv("Rule must be non-null");
    this._boundaryRule = t;
  }
};
(hM.prototype.locateInternal = function () {
  if (arguments[0] instanceof qv && arguments[1] instanceof kx) {
    var t = arguments[0],
      e = arguments[1];
    if (e.isEmpty()) return Zv.EXTERIOR;
    var i = e.getExteriorRing(),
      n = this.locateInPolygonRing(t, i);
    if (n === Zv.EXTERIOR) return Zv.EXTERIOR;
    if (n === Zv.BOUNDARY) return Zv.BOUNDARY;
    for (var r = 0; r < e.getNumInteriorRing(); r++) {
      var o = e.getInteriorRingN(r),
        a = this.locateInPolygonRing(t, o);
      if (a === Zv.INTERIOR) return Zv.EXTERIOR;
      if (a === Zv.BOUNDARY) return Zv.BOUNDARY;
    }
    return Zv.INTERIOR;
  }
  if (arguments[0] instanceof qv && arguments[1] instanceof Rx) {
    var s = arguments[0],
      l = arguments[1];
    if (!l.getEnvelopeInternal().intersects(s)) return Zv.EXTERIOR;
    var u = l.getCoordinates();
    return l.isClosed() || (!s.equals(u[0]) && !s.equals(u[u.length - 1]))
      ? Tb.isOnLine(s, u)
        ? Zv.INTERIOR
        : Zv.EXTERIOR
      : Zv.BOUNDARY;
  }
  if (arguments[0] instanceof qv && arguments[1] instanceof Fx) {
    var c = arguments[0];
    return arguments[1].getCoordinate().equals2D(c) ? Zv.INTERIOR : Zv.EXTERIOR;
  }
}),
  (hM.prototype.locateInPolygonRing = function (t, e) {
    return e.getEnvelopeInternal().intersects(t)
      ? Tb.locatePointInRing(t, e.getCoordinates())
      : Zv.EXTERIOR;
  }),
  (hM.prototype.intersects = function (t, e) {
    return this.locate(t, e) !== Zv.EXTERIOR;
  }),
  (hM.prototype.updateLocationInfo = function (t) {
    t === Zv.INTERIOR && (this._isIn = !0),
      t === Zv.BOUNDARY && this._numBoundaries++;
  }),
  (hM.prototype.computeLocation = function (t, e) {
    var i = this;
    if (
      (e instanceof Fx && this.updateLocationInfo(this.locateInternal(t, e)),
      e instanceof Rx)
    )
      this.updateLocationInfo(this.locateInternal(t, e));
    else if (e instanceof kx)
      this.updateLocationInfo(this.locateInternal(t, e));
    else if (e instanceof Sx)
      for (var n = e, r = 0; r < n.getNumGeometries(); r++) {
        var o = n.getGeometryN(r);
        i.updateLocationInfo(i.locateInternal(t, o));
      }
    else if (e instanceof Ux)
      for (var a = e, s = 0; s < a.getNumGeometries(); s++) {
        var l = a.getGeometryN(s);
        i.updateLocationInfo(i.locateInternal(t, l));
      }
    else if (e instanceof _x)
      for (var u = new ES(e); u.hasNext(); ) {
        var c = u.next();
        c !== e && i.computeLocation(t, c);
      }
  }),
  (hM.prototype.locate = function (t, e) {
    return e.isEmpty()
      ? Zv.EXTERIOR
      : e instanceof Rx || e instanceof kx
      ? this.locateInternal(t, e)
      : ((this._isIn = !1),
        (this._numBoundaries = 0),
        this.computeLocation(t, e),
        this._boundaryRule.isInBoundary(this._numBoundaries)
          ? Zv.BOUNDARY
          : this._numBoundaries > 0 || this._isIn
          ? Zv.INTERIOR
          : Zv.EXTERIOR);
  }),
  (hM.prototype.interfaces_ = function () {
    return [];
  }),
  (hM.prototype.getClass = function () {
    return hM;
  });
var pM = function t() {
    if (
      ((this._component = null),
      (this._segIndex = null),
      (this._pt = null),
      2 === arguments.length)
    )
      t.call(this, arguments[0], t.INSIDE_AREA, arguments[1]);
    else if (3 === arguments.length) {
      var e = arguments[0],
        i = arguments[1],
        n = arguments[2];
      (this._component = e), (this._segIndex = i), (this._pt = n);
    }
  },
  dM = {
    INSIDE_AREA: {
      configurable: !0,
    },
  };
(pM.prototype.isInsideArea = function () {
  return this._segIndex === pM.INSIDE_AREA;
}),
  (pM.prototype.getCoordinate = function () {
    return this._pt;
  }),
  (pM.prototype.getGeometryComponent = function () {
    return this._component;
  }),
  (pM.prototype.getSegmentIndex = function () {
    return this._segIndex;
  }),
  (pM.prototype.interfaces_ = function () {
    return [];
  }),
  (pM.prototype.getClass = function () {
    return pM;
  }),
  (dM.INSIDE_AREA.get = function () {
    return -1;
  }),
  Object.defineProperties(pM, dM);
var fM = function (t) {
  this._pts = t || null;
};
(fM.prototype.filter = function (t) {
  t instanceof Fx && this._pts.add(t);
}),
  (fM.prototype.interfaces_ = function () {
    return [bx];
  }),
  (fM.prototype.getClass = function () {
    return fM;
  }),
  (fM.getPoints = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t instanceof Fx ? G_.singletonList(t) : fM.getPoints(t, new Yb());
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      return (
        e instanceof Fx ? i.add(e) : e instanceof _x && e.apply(new fM(i)), i
      );
    }
  });
var gM = function () {
  this._locations = null;
  var t = arguments[0];
  this._locations = t;
};
(gM.prototype.filter = function (t) {
  (t instanceof Fx || t instanceof Rx || t instanceof kx) &&
    this._locations.add(new pM(t, 0, t.getCoordinate()));
}),
  (gM.prototype.interfaces_ = function () {
    return [bx];
  }),
  (gM.prototype.getClass = function () {
    return gM;
  }),
  (gM.getLocations = function (t) {
    var e = new Yb();
    return t.apply(new gM(e)), e;
  });
var mM = function () {
  if (
    ((this._geom = null),
    (this._terminateDistance = 0),
    (this._ptLocator = new hM()),
    (this._minDistanceLocation = null),
    (this._minDistance = Gv.MAX_VALUE),
    2 === arguments.length)
  ) {
    var t = arguments[0],
      e = arguments[1];
    (this._geom = [t, e]), (this._terminateDistance = 0);
  } else if (3 === arguments.length) {
    var i = arguments[0],
      n = arguments[1],
      r = arguments[2];
    (this._geom = new Array(2).fill(null)),
      (this._geom[0] = i),
      (this._geom[1] = n),
      (this._terminateDistance = r);
  }
};
(mM.prototype.computeContainmentDistance = function () {
  var t = this;
  if (0 === arguments.length) {
    var e = new Array(2).fill(null);
    if (
      (this.computeContainmentDistance(0, e),
      this._minDistance <= this._terminateDistance)
    )
      return null;
    this.computeContainmentDistance(1, e);
  } else if (2 === arguments.length) {
    var i = arguments[0],
      n = arguments[1],
      r = 1 - i,
      o = uM.getPolygons(this._geom[i]);
    if (o.size() > 0) {
      var a = gM.getLocations(this._geom[r]);
      if (
        (this.computeContainmentDistance(a, o, n),
        this._minDistance <= this._terminateDistance)
      )
        return (
          (this._minDistanceLocation[r] = n[0]),
          (this._minDistanceLocation[i] = n[1]),
          null
        );
    }
  } else if (3 === arguments.length)
    if (
      arguments[2] instanceof Array &&
      Kv(arguments[0], Wb) &&
      Kv(arguments[1], Wb)
    ) {
      for (
        var s = arguments[0], l = arguments[1], u = arguments[2], c = 0;
        c < s.size();
        c++
      )
        for (var h = s.get(c), p = 0; p < l.size(); p++)
          if (
            (t.computeContainmentDistance(h, l.get(p), u),
            t._minDistance <= t._terminateDistance)
          )
            return null;
    } else if (
      arguments[2] instanceof Array &&
      arguments[0] instanceof pM &&
      arguments[1] instanceof kx
    ) {
      var d = arguments[0],
        f = arguments[1],
        g = arguments[2],
        m = d.getCoordinate();
      if (Zv.EXTERIOR !== this._ptLocator.locate(m, f))
        return (this._minDistance = 0), (g[0] = d), (g[1] = new pM(f, m)), null;
    }
}),
  (mM.prototype.computeMinDistanceLinesPoints = function (t, e, i) {
    for (var n = this, r = 0; r < t.size(); r++)
      for (var o = t.get(r), a = 0; a < e.size(); a++) {
        var s = e.get(a);
        if (
          (n.computeMinDistance(o, s, i),
          n._minDistance <= n._terminateDistance)
        )
          return null;
      }
  }),
  (mM.prototype.computeFacetDistance = function () {
    var t = new Array(2).fill(null),
      e = cM.getLines(this._geom[0]),
      i = cM.getLines(this._geom[1]),
      n = fM.getPoints(this._geom[0]),
      r = fM.getPoints(this._geom[1]);
    return (
      this.computeMinDistanceLines(e, i, t),
      this.updateMinDistance(t, !1),
      this._minDistance <= this._terminateDistance
        ? null
        : ((t[0] = null),
          (t[1] = null),
          this.computeMinDistanceLinesPoints(e, r, t),
          this.updateMinDistance(t, !1),
          this._minDistance <= this._terminateDistance
            ? null
            : ((t[0] = null),
              (t[1] = null),
              this.computeMinDistanceLinesPoints(i, n, t),
              this.updateMinDistance(t, !0),
              this._minDistance <= this._terminateDistance
                ? null
                : ((t[0] = null),
                  (t[1] = null),
                  this.computeMinDistancePoints(n, r, t),
                  void this.updateMinDistance(t, !1))))
    );
  }),
  (mM.prototype.nearestLocations = function () {
    return this.computeMinDistance(), this._minDistanceLocation;
  }),
  (mM.prototype.updateMinDistance = function (t, e) {
    if (null === t[0]) return null;
    e
      ? ((this._minDistanceLocation[0] = t[1]),
        (this._minDistanceLocation[1] = t[0]))
      : ((this._minDistanceLocation[0] = t[0]),
        (this._minDistanceLocation[1] = t[1]));
  }),
  (mM.prototype.nearestPoints = function () {
    return (
      this.computeMinDistance(),
      [
        this._minDistanceLocation[0].getCoordinate(),
        this._minDistanceLocation[1].getCoordinate(),
      ]
    );
  }),
  (mM.prototype.computeMinDistance = function () {
    var t = this;
    if (0 === arguments.length) {
      if (null !== this._minDistanceLocation) return null;
      if (
        ((this._minDistanceLocation = new Array(2).fill(null)),
        this.computeContainmentDistance(),
        this._minDistance <= this._terminateDistance)
      )
        return null;
      this.computeFacetDistance();
    } else if (3 === arguments.length)
      if (
        arguments[2] instanceof Array &&
        arguments[0] instanceof Rx &&
        arguments[1] instanceof Fx
      ) {
        var e = arguments[0],
          i = arguments[1],
          n = arguments[2];
        if (
          e.getEnvelopeInternal().distance(i.getEnvelopeInternal()) >
          this._minDistance
        )
          return null;
        for (
          var r = e.getCoordinates(), o = i.getCoordinate(), a = 0;
          a < r.length - 1;
          a++
        ) {
          var s = Tb.distancePointLine(o, r[a], r[a + 1]);
          if (s < t._minDistance) {
            t._minDistance = s;
            var l = new eS(r[a], r[a + 1]).closestPoint(o);
            (n[0] = new pM(e, a, l)), (n[1] = new pM(i, 0, o));
          }
          if (t._minDistance <= t._terminateDistance) return null;
        }
      } else if (
        arguments[2] instanceof Array &&
        arguments[0] instanceof Rx &&
        arguments[1] instanceof Rx
      ) {
        var u = arguments[0],
          c = arguments[1],
          h = arguments[2];
        if (
          u.getEnvelopeInternal().distance(c.getEnvelopeInternal()) >
          this._minDistance
        )
          return null;
        for (
          var p = u.getCoordinates(), d = c.getCoordinates(), f = 0;
          f < p.length - 1;
          f++
        )
          for (var g = 0; g < d.length - 1; g++) {
            var m = Tb.distanceLineLine(p[f], p[f + 1], d[g], d[g + 1]);
            if (m < t._minDistance) {
              t._minDistance = m;
              var y = new eS(p[f], p[f + 1]),
                v = new eS(d[g], d[g + 1]),
                b = y.closestPoints(v);
              (h[0] = new pM(u, f, b[0])), (h[1] = new pM(c, g, b[1]));
            }
            if (t._minDistance <= t._terminateDistance) return null;
          }
      }
  }),
  (mM.prototype.computeMinDistancePoints = function (t, e, i) {
    for (var n = this, r = 0; r < t.size(); r++)
      for (var o = t.get(r), a = 0; a < e.size(); a++) {
        var s = e.get(a),
          l = o.getCoordinate().distance(s.getCoordinate());
        if (
          (l < n._minDistance &&
            ((n._minDistance = l),
            (i[0] = new pM(o, 0, o.getCoordinate())),
            (i[1] = new pM(s, 0, s.getCoordinate()))),
          n._minDistance <= n._terminateDistance)
        )
          return null;
      }
  }),
  (mM.prototype.distance = function () {
    if (null === this._geom[0] || null === this._geom[1])
      throw new Bv("null geometries are not supported");
    return this._geom[0].isEmpty() || this._geom[1].isEmpty()
      ? 0
      : (this.computeMinDistance(), this._minDistance);
  }),
  (mM.prototype.computeMinDistanceLines = function (t, e, i) {
    for (var n = this, r = 0; r < t.size(); r++)
      for (var o = t.get(r), a = 0; a < e.size(); a++) {
        var s = e.get(a);
        if (
          (n.computeMinDistance(o, s, i),
          n._minDistance <= n._terminateDistance)
        )
          return null;
      }
  }),
  (mM.prototype.interfaces_ = function () {
    return [];
  }),
  (mM.prototype.getClass = function () {
    return mM;
  }),
  (mM.distance = function (t, e) {
    return new mM(t, e).distance();
  }),
  (mM.isWithinDistance = function (t, e, i) {
    return new mM(t, e, i).distance() <= i;
  }),
  (mM.nearestPoints = function (t, e) {
    return new mM(t, e).nearestPoints();
  });
var yM = function () {
  (this._pt = [new qv(), new qv()]),
    (this._distance = Gv.NaN),
    (this._isNull = !0);
};
(yM.prototype.getCoordinates = function () {
  return this._pt;
}),
  (yM.prototype.getCoordinate = function (t) {
    return this._pt[t];
  }),
  (yM.prototype.setMinimum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMinimum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      if (this._isNull) return this.initialize(e, i), null;
      var n = e.distance(i);
      n < this._distance && this.initialize(e, i, n);
    }
  }),
  (yM.prototype.initialize = function () {
    if (0 === arguments.length) this._isNull = !0;
    else if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1];
      this._pt[0].setCoordinate(t),
        this._pt[1].setCoordinate(e),
        (this._distance = t.distance(e)),
        (this._isNull = !1);
    } else if (3 === arguments.length) {
      var i = arguments[0],
        n = arguments[1],
        r = arguments[2];
      this._pt[0].setCoordinate(i),
        this._pt[1].setCoordinate(n),
        (this._distance = r),
        (this._isNull = !1);
    }
  }),
  (yM.prototype.toString = function () {
    return xb.toLineString(this._pt[0], this._pt[1]);
  }),
  (yM.prototype.getDistance = function () {
    return this._distance;
  }),
  (yM.prototype.setMaximum = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      this.setMaximum(t._pt[0], t._pt[1]);
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      if (this._isNull) return this.initialize(e, i), null;
      var n = e.distance(i);
      n > this._distance && this.initialize(e, i, n);
    }
  }),
  (yM.prototype.interfaces_ = function () {
    return [];
  }),
  (yM.prototype.getClass = function () {
    return yM;
  });
var vM = function () {};
(vM.prototype.interfaces_ = function () {
  return [];
}),
  (vM.prototype.getClass = function () {
    return vM;
  }),
  (vM.computeDistance = function () {
    if (
      arguments[2] instanceof yM &&
      arguments[0] instanceof Rx &&
      arguments[1] instanceof qv
    )
      for (
        var t = arguments[0],
          e = arguments[1],
          i = arguments[2],
          n = new eS(),
          r = t.getCoordinates(),
          o = 0;
        o < r.length - 1;
        o++
      ) {
        n.setCoordinates(r[o], r[o + 1]);
        var a = n.closestPoint(e);
        i.setMinimum(a, e);
      }
    else if (
      arguments[2] instanceof yM &&
      arguments[0] instanceof kx &&
      arguments[1] instanceof qv
    ) {
      var s = arguments[0],
        l = arguments[1],
        u = arguments[2];
      vM.computeDistance(s.getExteriorRing(), l, u);
      for (var c = 0; c < s.getNumInteriorRing(); c++)
        vM.computeDistance(s.getInteriorRingN(c), l, u);
    } else if (
      arguments[2] instanceof yM &&
      arguments[0] instanceof Ib &&
      arguments[1] instanceof qv
    ) {
      var h = arguments[0],
        p = arguments[1],
        d = arguments[2];
      if (h instanceof Rx) vM.computeDistance(h, p, d);
      else if (h instanceof kx) vM.computeDistance(h, p, d);
      else if (h instanceof _x)
        for (var f = h, g = 0; g < f.getNumGeometries(); g++) {
          var m = f.getGeometryN(g);
          vM.computeDistance(m, p, d);
        }
      else d.setMinimum(h.getCoordinate(), p);
    } else if (
      arguments[2] instanceof yM &&
      arguments[0] instanceof eS &&
      arguments[1] instanceof qv
    ) {
      var y = arguments[1],
        v = arguments[2],
        b = arguments[0].closestPoint(y);
      v.setMinimum(b, y);
    }
  });
var bM = function () {
    (this._g0 = null),
      (this._g1 = null),
      (this._ptDist = new yM()),
      (this._densifyFrac = 0);
    var t = arguments[0],
      e = arguments[1];
    (this._g0 = t), (this._g1 = e);
  },
  xM = {
    MaxPointDistanceFilter: {
      configurable: !0,
    },
    MaxDensifiedByFractionDistanceFilter: {
      configurable: !0,
    },
  };
(bM.prototype.getCoordinates = function () {
  return this._ptDist.getCoordinates();
}),
  (bM.prototype.setDensifyFraction = function (t) {
    if (t > 1 || t <= 0) throw new Bv("Fraction is not in range (0.0 - 1.0]");
    this._densifyFrac = t;
  }),
  (bM.prototype.compute = function (t, e) {
    this.computeOrientedDistance(t, e, this._ptDist),
      this.computeOrientedDistance(e, t, this._ptDist);
  }),
  (bM.prototype.distance = function () {
    return this.compute(this._g0, this._g1), this._ptDist.getDistance();
  }),
  (bM.prototype.computeOrientedDistance = function (t, e, i) {
    var n = new _M(e);
    if (
      (t.apply(n), i.setMaximum(n.getMaxPointDistance()), this._densifyFrac > 0)
    ) {
      var r = new SM(e, this._densifyFrac);
      t.apply(r), i.setMaximum(r.getMaxPointDistance());
    }
  }),
  (bM.prototype.orientedDistance = function () {
    return (
      this.computeOrientedDistance(this._g0, this._g1, this._ptDist),
      this._ptDist.getDistance()
    );
  }),
  (bM.prototype.interfaces_ = function () {
    return [];
  }),
  (bM.prototype.getClass = function () {
    return bM;
  }),
  (bM.distance = function () {
    if (2 === arguments.length)
      return new bM(arguments[0], arguments[1]).distance();
    if (3 === arguments.length) {
      var t = arguments[2],
        e = new bM(arguments[0], arguments[1]);
      return e.setDensifyFraction(t), e.distance();
    }
  }),
  (xM.MaxPointDistanceFilter.get = function () {
    return _M;
  }),
  (xM.MaxDensifiedByFractionDistanceFilter.get = function () {
    return SM;
  }),
  Object.defineProperties(bM, xM);
var _M = function () {
  (this._maxPtDist = new yM()),
    (this._minPtDist = new yM()),
    (this._euclideanDist = new vM()),
    (this._geom = null);
  var t = arguments[0];
  this._geom = t;
};
(_M.prototype.filter = function (t) {
  this._minPtDist.initialize(),
    vM.computeDistance(this._geom, t, this._minPtDist),
    this._maxPtDist.setMaximum(this._minPtDist);
}),
  (_M.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }),
  (_M.prototype.interfaces_ = function () {
    return [Ob];
  }),
  (_M.prototype.getClass = function () {
    return _M;
  });
var SM = function () {
  (this._maxPtDist = new yM()),
    (this._minPtDist = new yM()),
    (this._geom = null),
    (this._numSubSegs = 0);
  var t = arguments[0],
    e = arguments[1];
  (this._geom = t), (this._numSubSegs = Math.trunc(Math.round(1 / e)));
};
(SM.prototype.filter = function (t, e) {
  var i = this;
  if (0 === e) return null;
  for (
    var n = t.getCoordinate(e - 1),
      r = t.getCoordinate(e),
      o = (r.x - n.x) / this._numSubSegs,
      a = (r.y - n.y) / this._numSubSegs,
      s = 0;
    s < this._numSubSegs;
    s++
  ) {
    var l = n.x + s * o,
      u = n.y + s * a,
      c = new qv(l, u);
    i._minPtDist.initialize(),
      vM.computeDistance(i._geom, c, i._minPtDist),
      i._maxPtDist.setMaximum(i._minPtDist);
  }
}),
  (SM.prototype.isDone = function () {
    return !1;
  }),
  (SM.prototype.isGeometryChanged = function () {
    return !1;
  }),
  (SM.prototype.getMaxPointDistance = function () {
    return this._maxPtDist;
  }),
  (SM.prototype.interfaces_ = function () {
    return [xx];
  }),
  (SM.prototype.getClass = function () {
    return SM;
  });
var MM = function (t, e, i) {
    (this._minValidDistance = null),
      (this._maxValidDistance = null),
      (this._minDistanceFound = null),
      (this._maxDistanceFound = null),
      (this._isValid = !0),
      (this._errMsg = null),
      (this._errorLocation = null),
      (this._errorIndicator = null),
      (this._input = t || null),
      (this._bufDistance = e || null),
      (this._result = i || null);
  },
  CM = {
    VERBOSE: {
      configurable: !0,
    },
    MAX_DISTANCE_DIFF_FRAC: {
      configurable: !0,
    },
  };
(MM.prototype.checkMaximumDistance = function (t, e, i) {
  var n = new bM(e, t);
  if (
    (n.setDensifyFraction(0.25),
    (this._maxDistanceFound = n.orientedDistance()),
    this._maxDistanceFound > i)
  ) {
    this._isValid = !1;
    var r = n.getCoordinates();
    (this._errorLocation = r[1]),
      (this._errorIndicator = t.getFactory().createLineString(r)),
      (this._errMsg =
        "Distance between buffer curve and input is too large (" +
        this._maxDistanceFound +
        " at " +
        xb.toLineString(r[0], r[1]) +
        ")");
  }
}),
  (MM.prototype.isValid = function () {
    var t = Math.abs(this._bufDistance),
      e = MM.MAX_DISTANCE_DIFF_FRAC * t;
    return (
      (this._minValidDistance = t - e),
      (this._maxValidDistance = t + e),
      !(!this._input.isEmpty() && !this._result.isEmpty()) ||
        (this._bufDistance > 0
          ? this.checkPositiveValid()
          : this.checkNegativeValid(),
        MM.VERBOSE &&
          pb.out.println(
            "Min Dist= " +
              this._minDistanceFound +
              "  err= " +
              (1 - this._minDistanceFound / this._bufDistance) +
              "  Max Dist= " +
              this._maxDistanceFound +
              "  err= " +
              (this._maxDistanceFound / this._bufDistance - 1)
          ),
        this._isValid)
    );
  }),
  (MM.prototype.checkNegativeValid = function () {
    if (
      !(
        this._input instanceof kx ||
        this._input instanceof Ux ||
        this._input instanceof _x
      )
    )
      return null;
    var t = this.getPolygonLines(this._input);
    if (
      (this.checkMinimumDistance(t, this._result, this._minValidDistance),
      !this._isValid)
    )
      return null;
    this.checkMaximumDistance(t, this._result, this._maxValidDistance);
  }),
  (MM.prototype.getErrorIndicator = function () {
    return this._errorIndicator;
  }),
  (MM.prototype.checkMinimumDistance = function (t, e, i) {
    var n = new mM(t, e, i);
    if (((this._minDistanceFound = n.distance()), this._minDistanceFound < i)) {
      this._isValid = !1;
      var r = n.nearestPoints();
      (this._errorLocation = n.nearestPoints()[1]),
        (this._errorIndicator = t.getFactory().createLineString(r)),
        (this._errMsg =
          "Distance between buffer curve and input is too small (" +
          this._minDistanceFound +
          " at " +
          xb.toLineString(r[0], r[1]) +
          " )");
    }
  }),
  (MM.prototype.checkPositiveValid = function () {
    var t = this._result.getBoundary();
    if (
      (this.checkMinimumDistance(this._input, t, this._minValidDistance),
      !this._isValid)
    )
      return null;
    this.checkMaximumDistance(this._input, t, this._maxValidDistance);
  }),
  (MM.prototype.getErrorLocation = function () {
    return this._errorLocation;
  }),
  (MM.prototype.getPolygonLines = function (t) {
    for (
      var e = new Yb(), i = new cM(e), n = uM.getPolygons(t).iterator();
      n.hasNext();

    ) {
      n.next().apply(i);
    }
    return t.getFactory().buildGeometry(e);
  }),
  (MM.prototype.getErrorMessage = function () {
    return this._errMsg;
  }),
  (MM.prototype.interfaces_ = function () {
    return [];
  }),
  (MM.prototype.getClass = function () {
    return MM;
  }),
  (CM.VERBOSE.get = function () {
    return !1;
  }),
  (CM.MAX_DISTANCE_DIFF_FRAC.get = function () {
    return 0.012;
  }),
  Object.defineProperties(MM, CM);
var wM = function (t, e, i) {
    (this._isValid = !0),
      (this._errorMsg = null),
      (this._errorLocation = null),
      (this._errorIndicator = null),
      (this._input = t || null),
      (this._distance = e || null),
      (this._result = i || null);
  },
  AM = {
    VERBOSE: {
      configurable: !0,
    },
    MAX_ENV_DIFF_FRAC: {
      configurable: !0,
    },
  };
(wM.prototype.isValid = function () {
  return (
    this.checkPolygonal(),
    this._isValid
      ? (this.checkExpectedEmpty(),
        this._isValid
          ? (this.checkEnvelope(),
            this._isValid
              ? (this.checkArea(),
                this._isValid
                  ? (this.checkDistance(), this._isValid)
                  : this._isValid)
              : this._isValid)
          : this._isValid)
      : this._isValid
  );
}),
  (wM.prototype.checkEnvelope = function () {
    if (this._distance < 0) return null;
    var t = this._distance * wM.MAX_ENV_DIFF_FRAC;
    0 === t && (t = 0.001);
    var e = new fb(this._input.getEnvelopeInternal());
    e.expandBy(this._distance);
    var i = new fb(this._result.getEnvelopeInternal());
    i.expandBy(t),
      i.contains(e) ||
        ((this._isValid = !1),
        (this._errorMsg = "Buffer envelope is incorrect"),
        (this._errorIndicator = this._input.getFactory().toGeometry(i))),
      this.report("Envelope");
  }),
  (wM.prototype.checkDistance = function () {
    var t = new MM(this._input, this._distance, this._result);
    t.isValid() ||
      ((this._isValid = !1),
      (this._errorMsg = t.getErrorMessage()),
      (this._errorLocation = t.getErrorLocation()),
      (this._errorIndicator = t.getErrorIndicator())),
      this.report("Distance");
  }),
  (wM.prototype.checkArea = function () {
    var t = this._input.getArea(),
      e = this._result.getArea();
    this._distance > 0 &&
      t > e &&
      ((this._isValid = !1),
      (this._errorMsg = "Area of positive buffer is smaller than input"),
      (this._errorIndicator = this._result)),
      this._distance < 0 &&
        t < e &&
        ((this._isValid = !1),
        (this._errorMsg = "Area of negative buffer is larger than input"),
        (this._errorIndicator = this._result)),
      this.report("Area");
  }),
  (wM.prototype.checkPolygonal = function () {
    this._result instanceof kx ||
      this._result instanceof Ux ||
      (this._isValid = !1),
      (this._errorMsg = "Result is not polygonal"),
      (this._errorIndicator = this._result),
      this.report("Polygonal");
  }),
  (wM.prototype.getErrorIndicator = function () {
    return this._errorIndicator;
  }),
  (wM.prototype.getErrorLocation = function () {
    return this._errorLocation;
  }),
  (wM.prototype.checkExpectedEmpty = function () {
    return this._input.getDimension() >= 2 || this._distance > 0
      ? null
      : (this._result.isEmpty() ||
          ((this._isValid = !1),
          (this._errorMsg = "Result is non-empty"),
          (this._errorIndicator = this._result)),
        void this.report("ExpectedEmpty"));
  }),
  (wM.prototype.report = function (t) {
    if (!wM.VERBOSE) return null;
    pb.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"));
  }),
  (wM.prototype.getErrorMessage = function () {
    return this._errorMsg;
  }),
  (wM.prototype.interfaces_ = function () {
    return [];
  }),
  (wM.prototype.getClass = function () {
    return wM;
  }),
  (wM.isValidMsg = function (t, e, i) {
    var n = new wM(t, e, i);
    return n.isValid() ? null : n.getErrorMessage();
  }),
  (wM.isValid = function (t, e, i) {
    return !!new wM(t, e, i).isValid();
  }),
  (AM.VERBOSE.get = function () {
    return !1;
  }),
  (AM.MAX_ENV_DIFF_FRAC.get = function () {
    return 0.012;
  }),
  Object.defineProperties(wM, AM);
var EM = function () {
  (this._pts = null), (this._data = null);
  var t = arguments[0],
    e = arguments[1];
  (this._pts = t), (this._data = e);
};
(EM.prototype.getCoordinates = function () {
  return this._pts;
}),
  (EM.prototype.size = function () {
    return this._pts.length;
  }),
  (EM.prototype.getCoordinate = function (t) {
    return this._pts[t];
  }),
  (EM.prototype.isClosed = function () {
    return this._pts[0].equals(this._pts[this._pts.length - 1]);
  }),
  (EM.prototype.getSegmentOctant = function (t) {
    return t === this._pts.length - 1
      ? -1
      : J_.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
  }),
  (EM.prototype.setData = function (t) {
    this._data = t;
  }),
  (EM.prototype.getData = function () {
    return this._data;
  }),
  (EM.prototype.toString = function () {
    return xb.toLineString(new Yx(this._pts));
  }),
  (EM.prototype.interfaces_ = function () {
    return [K_];
  }),
  (EM.prototype.getClass = function () {
    return EM;
  });
var DM = function () {
  (this._findAllIntersections = !1),
    (this._isCheckEndSegmentsOnly = !1),
    (this._li = null),
    (this._interiorIntersection = null),
    (this._intSegments = null),
    (this._intersections = new Yb()),
    (this._intersectionCount = 0),
    (this._keepIntersections = !0);
  var t = arguments[0];
  (this._li = t), (this._interiorIntersection = null);
};
(DM.prototype.getInteriorIntersection = function () {
  return this._interiorIntersection;
}),
  (DM.prototype.setCheckEndSegmentsOnly = function (t) {
    this._isCheckEndSegmentsOnly = t;
  }),
  (DM.prototype.getIntersectionSegments = function () {
    return this._intSegments;
  }),
  (DM.prototype.count = function () {
    return this._intersectionCount;
  }),
  (DM.prototype.getIntersections = function () {
    return this._intersections;
  }),
  (DM.prototype.setFindAllIntersections = function (t) {
    this._findAllIntersections = t;
  }),
  (DM.prototype.setKeepIntersections = function (t) {
    this._keepIntersections = t;
  }),
  (DM.prototype.processIntersections = function (t, e, i, n) {
    if (!this._findAllIntersections && this.hasIntersection()) return null;
    if (t === i && e === n) return null;
    if (
      this._isCheckEndSegmentsOnly &&
      !(this.isEndSegment(t, e) || this.isEndSegment(i, n))
    )
      return null;
    var r = t.getCoordinates()[e],
      o = t.getCoordinates()[e + 1],
      a = i.getCoordinates()[n],
      s = i.getCoordinates()[n + 1];
    this._li.computeIntersection(r, o, a, s),
      this._li.hasIntersection() &&
        this._li.isInteriorIntersection() &&
        ((this._intSegments = new Array(4).fill(null)),
        (this._intSegments[0] = r),
        (this._intSegments[1] = o),
        (this._intSegments[2] = a),
        (this._intSegments[3] = s),
        (this._interiorIntersection = this._li.getIntersection(0)),
        this._keepIntersections &&
          this._intersections.add(this._interiorIntersection),
        this._intersectionCount++);
  }),
  (DM.prototype.isEndSegment = function (t, e) {
    return 0 === e || e >= t.size() - 2;
  }),
  (DM.prototype.hasIntersection = function () {
    return null !== this._interiorIntersection;
  }),
  (DM.prototype.isDone = function () {
    return !this._findAllIntersections && null !== this._interiorIntersection;
  }),
  (DM.prototype.interfaces_ = function () {
    return [RS];
  }),
  (DM.prototype.getClass = function () {
    return DM;
  }),
  (DM.createAllIntersectionsFinder = function (t) {
    var e = new DM(t);
    return e.setFindAllIntersections(!0), e;
  }),
  (DM.createAnyIntersectionFinder = function (t) {
    return new DM(t);
  }),
  (DM.createIntersectionCounter = function (t) {
    var e = new DM(t);
    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
  });
var TM = function () {
  (this._li = new Ab()),
    (this._segStrings = null),
    (this._findAllIntersections = !1),
    (this._segInt = null),
    (this._isValid = !0);
  var t = arguments[0];
  this._segStrings = t;
};
(TM.prototype.execute = function () {
  if (null !== this._segInt) return null;
  this.checkInteriorIntersections();
}),
  (TM.prototype.getIntersections = function () {
    return this._segInt.getIntersections();
  }),
  (TM.prototype.isValid = function () {
    return this.execute(), this._isValid;
  }),
  (TM.prototype.setFindAllIntersections = function (t) {
    this._findAllIntersections = t;
  }),
  (TM.prototype.checkInteriorIntersections = function () {
    (this._isValid = !0),
      (this._segInt = new DM(this._li)),
      this._segInt.setFindAllIntersections(this._findAllIntersections);
    var t = new lS();
    if (
      (t.setSegmentIntersector(this._segInt),
      t.computeNodes(this._segStrings),
      this._segInt.hasIntersection())
    )
      return (this._isValid = !1), null;
  }),
  (TM.prototype.checkValid = function () {
    if ((this.execute(), !this._isValid))
      throw new g_(
        this.getErrorMessage(),
        this._segInt.getInteriorIntersection()
      );
  }),
  (TM.prototype.getErrorMessage = function () {
    if (this._isValid) return "no intersections found";
    var t = this._segInt.getIntersectionSegments();
    return (
      "found non-noded intersection between " +
      xb.toLineString(t[0], t[1]) +
      " and " +
      xb.toLineString(t[2], t[3])
    );
  }),
  (TM.prototype.interfaces_ = function () {
    return [];
  }),
  (TM.prototype.getClass = function () {
    return TM;
  }),
  (TM.computeIntersections = function (t) {
    var e = new TM(t);
    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
  });
var PM = function t() {
  this._nv = null;
  var e = arguments[0];
  this._nv = new TM(t.toSegmentStrings(e));
};
(PM.prototype.checkValid = function () {
  this._nv.checkValid();
}),
  (PM.prototype.interfaces_ = function () {
    return [];
  }),
  (PM.prototype.getClass = function () {
    return PM;
  }),
  (PM.toSegmentStrings = function (t) {
    for (var e = new Yb(), i = t.iterator(); i.hasNext(); ) {
      var n = i.next();
      e.add(new EM(n.getCoordinates(), n));
    }
    return e;
  }),
  (PM.checkValid = function (t) {
    new PM(t).checkValid();
  });
var LM = function (t) {
  this._mapOp = t;
};
(LM.prototype.map = function (t) {
  for (var e = new Yb(), i = 0; i < t.getNumGeometries(); i++) {
    var n = this._mapOp.map(t.getGeometryN(i));
    n.isEmpty() || e.add(n);
  }
  return t.getFactory().createGeometryCollection(i_.toGeometryArray(e));
}),
  (LM.prototype.interfaces_ = function () {
    return [];
  }),
  (LM.prototype.getClass = function () {
    return LM;
  }),
  (LM.map = function (t, e) {
    return new LM(e).map(t);
  });
var IM = function () {
  (this._op = null),
    (this._geometryFactory = null),
    (this._ptLocator = null),
    (this._lineEdgesList = new Yb()),
    (this._resultLineList = new Yb());
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2];
  (this._op = t), (this._geometryFactory = e), (this._ptLocator = i);
};
(IM.prototype.collectLines = function (t) {
  for (
    var e = this, i = this._op.getGraph().getEdgeEnds().iterator();
    i.hasNext();

  ) {
    var n = i.next();
    e.collectLineEdge(n, t, e._lineEdgesList),
      e.collectBoundaryTouchEdge(n, t, e._lineEdgesList);
  }
}),
  (IM.prototype.labelIsolatedLine = function (t, e) {
    var i = this._ptLocator.locate(
      t.getCoordinate(),
      this._op.getArgGeometry(e)
    );
    t.getLabel().setLocation(e, i);
  }),
  (IM.prototype.build = function (t) {
    return (
      this.findCoveredLineEdges(),
      this.collectLines(t),
      this.buildLines(t),
      this._resultLineList
    );
  }),
  (IM.prototype.collectLineEdge = function (t, e, i) {
    var n = t.getLabel(),
      r = t.getEdge();
    t.isLineEdge() &&
      (t.isVisited() ||
        !pC.isResultOfOp(n, e) ||
        r.isCovered() ||
        (i.add(r), t.setVisitedEdge(!0)));
  }),
  (IM.prototype.findCoveredLineEdges = function () {
    for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext(); ) {
      t.next().getEdges().findCoveredLineEdges();
    }
    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext(); ) {
      var i = e.next(),
        n = i.getEdge();
      if (i.isLineEdge() && !n.isCoveredSet()) {
        var r = this._op.isCoveredByA(i.getCoordinate());
        n.setCovered(r);
      }
    }
  }),
  (IM.prototype.labelIsolatedLines = function (t) {
    for (var e = t.iterator(); e.hasNext(); ) {
      var i = e.next(),
        n = i.getLabel();
      i.isIsolated() &&
        (n.isNull(0)
          ? this.labelIsolatedLine(i, 0)
          : this.labelIsolatedLine(i, 1));
    }
  }),
  (IM.prototype.buildLines = function (t) {
    for (var e = this._lineEdgesList.iterator(); e.hasNext(); ) {
      var i = e.next(),
        n = this._geometryFactory.createLineString(i.getCoordinates());
      this._resultLineList.add(n), i.setInResult(!0);
    }
  }),
  (IM.prototype.collectBoundaryTouchEdge = function (t, e, i) {
    var n = t.getLabel();
    return t.isLineEdge() ||
      t.isVisited() ||
      t.isInteriorAreaEdge() ||
      t.getEdge().isInResult()
      ? null
      : (Mb.isTrue(
          !(t.isInResult() || t.getSym().isInResult()) ||
            !t.getEdge().isInResult()
        ),
        void (
          pC.isResultOfOp(n, e) &&
          e === pC.INTERSECTION &&
          (i.add(t.getEdge()), t.setVisitedEdge(!0))
        ));
  }),
  (IM.prototype.interfaces_ = function () {
    return [];
  }),
  (IM.prototype.getClass = function () {
    return IM;
  });
var NM = function () {
  (this._op = null),
    (this._geometryFactory = null),
    (this._resultPointList = new Yb());
  var t = arguments[0],
    e = arguments[1];
  (this._op = t), (this._geometryFactory = e);
};
(NM.prototype.filterCoveredNodeToPoint = function (t) {
  var e = t.getCoordinate();
  if (!this._op.isCoveredByLA(e)) {
    var i = this._geometryFactory.createPoint(e);
    this._resultPointList.add(i);
  }
}),
  (NM.prototype.extractNonCoveredResultNodes = function (t) {
    for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext(); ) {
      var i = e.next();
      if (
        !i.isInResult() &&
        !i.isIncidentEdgeInResult() &&
        (0 === i.getEdges().getDegree() || t === pC.INTERSECTION)
      ) {
        var n = i.getLabel();
        pC.isResultOfOp(n, t) && this.filterCoveredNodeToPoint(i);
      }
    }
  }),
  (NM.prototype.build = function (t) {
    return this.extractNonCoveredResultNodes(t), this._resultPointList;
  }),
  (NM.prototype.interfaces_ = function () {
    return [];
  }),
  (NM.prototype.getClass = function () {
    return NM;
  });
var RM = function () {
  (this._inputGeom = null),
    (this._factory = null),
    (this._pruneEmptyGeometry = !0),
    (this._preserveGeometryCollectionType = !0),
    (this._preserveCollections = !1),
    (this._preserveType = !1);
};
(RM.prototype.transformPoint = function (t, e) {
  return this._factory.createPoint(
    this.transformCoordinates(t.getCoordinateSequence(), t)
  );
}),
  (RM.prototype.transformPolygon = function (t, e) {
    var i = !0,
      n = this.transformLinearRing(t.getExteriorRing(), t);
    (null !== n && n instanceof Gx && !n.isEmpty()) || (i = !1);
    for (var r = new Yb(), o = 0; o < t.getNumInteriorRing(); o++) {
      var a = this.transformLinearRing(t.getInteriorRingN(o), t);
      null === a || a.isEmpty() || (a instanceof Gx || (i = !1), r.add(a));
    }
    if (i) return this._factory.createPolygon(n, r.toArray([]));
    var s = new Yb();
    return null !== n && s.add(n), s.addAll(r), this._factory.buildGeometry(s);
  }),
  (RM.prototype.createCoordinateSequence = function (t) {
    return this._factory.getCoordinateSequenceFactory().create(t);
  }),
  (RM.prototype.getInputGeometry = function () {
    return this._inputGeom;
  }),
  (RM.prototype.transformMultiLineString = function (t, e) {
    for (var i = new Yb(), n = 0; n < t.getNumGeometries(); n++) {
      var r = this.transformLineString(t.getGeometryN(n), t);
      null !== r && (r.isEmpty() || i.add(r));
    }
    return this._factory.buildGeometry(i);
  }),
  (RM.prototype.transformCoordinates = function (t, e) {
    return this.copy(t);
  }),
  (RM.prototype.transformLineString = function (t, e) {
    return this._factory.createLineString(
      this.transformCoordinates(t.getCoordinateSequence(), t)
    );
  }),
  (RM.prototype.transformMultiPoint = function (t, e) {
    for (var i = new Yb(), n = 0; n < t.getNumGeometries(); n++) {
      var r = this.transformPoint(t.getGeometryN(n), t);
      null !== r && (r.isEmpty() || i.add(r));
    }
    return this._factory.buildGeometry(i);
  }),
  (RM.prototype.transformMultiPolygon = function (t, e) {
    for (var i = new Yb(), n = 0; n < t.getNumGeometries(); n++) {
      var r = this.transformPolygon(t.getGeometryN(n), t);
      null !== r && (r.isEmpty() || i.add(r));
    }
    return this._factory.buildGeometry(i);
  }),
  (RM.prototype.copy = function (t) {
    return t.copy();
  }),
  (RM.prototype.transformGeometryCollection = function (t, e) {
    for (var i = new Yb(), n = 0; n < t.getNumGeometries(); n++) {
      var r = this.transform(t.getGeometryN(n));
      null !== r && ((this._pruneEmptyGeometry && r.isEmpty()) || i.add(r));
    }
    return this._preserveGeometryCollectionType
      ? this._factory.createGeometryCollection(i_.toGeometryArray(i))
      : this._factory.buildGeometry(i);
  }),
  (RM.prototype.transform = function (t) {
    if (
      ((this._inputGeom = t), (this._factory = t.getFactory()), t instanceof Fx)
    )
      return this.transformPoint(t, null);
    if (t instanceof Bx) return this.transformMultiPoint(t, null);
    if (t instanceof Gx) return this.transformLinearRing(t, null);
    if (t instanceof Rx) return this.transformLineString(t, null);
    if (t instanceof Sx) return this.transformMultiLineString(t, null);
    if (t instanceof kx) return this.transformPolygon(t, null);
    if (t instanceof Ux) return this.transformMultiPolygon(t, null);
    if (t instanceof _x) return this.transformGeometryCollection(t, null);
    throw new Bv("Unknown Geometry subtype: " + t.getClass().getName());
  }),
  (RM.prototype.transformLinearRing = function (t, e) {
    var i = this.transformCoordinates(t.getCoordinateSequence(), t);
    if (null === i) return this._factory.createLinearRing(null);
    var n = i.size();
    return n > 0 && n < 4 && !this._preserveType
      ? this._factory.createLineString(i)
      : this._factory.createLinearRing(i);
  }),
  (RM.prototype.interfaces_ = function () {
    return [];
  }),
  (RM.prototype.getClass = function () {
    return RM;
  });
var OM = function t() {
  if (
    ((this._snapTolerance = 0),
    (this._srcPts = null),
    (this._seg = new eS()),
    (this._allowSnappingToSourceVertices = !1),
    (this._isClosed = !1),
    arguments[0] instanceof Rx && "number" == typeof arguments[1])
  ) {
    var e = arguments[1];
    t.call(this, arguments[0].getCoordinates(), e);
  } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
    var i = arguments[0],
      n = arguments[1];
    (this._srcPts = i),
      (this._isClosed = t.isClosed(i)),
      (this._snapTolerance = n);
  }
};
(OM.prototype.snapVertices = function (t, e) {
  for (var i = this._isClosed ? t.size() - 1 : t.size(), n = 0; n < i; n++) {
    var r = t.get(n),
      o = this.findSnapForVertex(r, e);
    null !== o &&
      (t.set(n, new qv(o)),
      0 === n && this._isClosed && t.set(t.size() - 1, new qv(o)));
  }
}),
  (OM.prototype.findSnapForVertex = function (t, e) {
    for (var i = 0; i < e.length; i++) {
      if (t.equals2D(e[i])) return null;
      if (t.distance(e[i]) < this._snapTolerance) return e[i];
    }
    return null;
  }),
  (OM.prototype.snapTo = function (t) {
    var e = new Qb(this._srcPts);
    return (
      this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
    );
  }),
  (OM.prototype.snapSegments = function (t, e) {
    if (0 === e.length) return null;
    var i = e.length;
    e[0].equals2D(e[e.length - 1]) && (i = e.length - 1);
    for (var n = 0; n < i; n++) {
      var r = e[n],
        o = this.findSegmentIndexToSnap(r, t);
      o >= 0 && t.add(o + 1, new qv(r), !1);
    }
  }),
  (OM.prototype.findSegmentIndexToSnap = function (t, e) {
    for (var i = this, n = Gv.MAX_VALUE, r = -1, o = 0; o < e.size() - 1; o++) {
      if (
        ((i._seg.p0 = e.get(o)),
        (i._seg.p1 = e.get(o + 1)),
        i._seg.p0.equals2D(t) || i._seg.p1.equals2D(t))
      ) {
        if (i._allowSnappingToSourceVertices) continue;
        return -1;
      }
      var a = i._seg.distance(t);
      a < i._snapTolerance && a < n && ((n = a), (r = o));
    }
    return r;
  }),
  (OM.prototype.setAllowSnappingToSourceVertices = function (t) {
    this._allowSnappingToSourceVertices = t;
  }),
  (OM.prototype.interfaces_ = function () {
    return [];
  }),
  (OM.prototype.getClass = function () {
    return OM;
  }),
  (OM.isClosed = function (t) {
    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);
  });
var FM = function (t) {
    this._srcGeom = t || null;
  },
  zM = {
    SNAP_PRECISION_FACTOR: {
      configurable: !0,
    },
  };
(FM.prototype.snapTo = function (t, e) {
  var i = this.extractTargetCoordinates(t);
  return new kM(e, i).transform(this._srcGeom);
}),
  (FM.prototype.snapToSelf = function (t, e) {
    var i = this.extractTargetCoordinates(this._srcGeom),
      n = new kM(t, i, !0).transform(this._srcGeom),
      r = n;
    return e && Kv(r, zx) && (r = n.buffer(0)), r;
  }),
  (FM.prototype.computeSnapTolerance = function (t) {
    return this.computeMinimumSegmentLength(t) / 10;
  }),
  (FM.prototype.extractTargetCoordinates = function (t) {
    for (var e = new fx(), i = t.getCoordinates(), n = 0; n < i.length; n++)
      e.add(i[n]);
    return e.toArray(new Array(0).fill(null));
  }),
  (FM.prototype.computeMinimumSegmentLength = function (t) {
    for (var e = Gv.MAX_VALUE, i = 0; i < t.length - 1; i++) {
      var n = t[i].distance(t[i + 1]);
      n < e && (e = n);
    }
    return e;
  }),
  (FM.prototype.interfaces_ = function () {
    return [];
  }),
  (FM.prototype.getClass = function () {
    return FM;
  }),
  (FM.snap = function (t, e, i) {
    var n = new Array(2).fill(null),
      r = new FM(t);
    n[0] = r.snapTo(e, i);
    var o = new FM(e);
    return (n[1] = o.snapTo(n[0], i)), n;
  }),
  (FM.computeOverlaySnapTolerance = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = FM.computeSizeBasedSnapTolerance(t),
        i = t.getPrecisionModel();
      if (i.getType() === Kx.FIXED) {
        var n = ((1 / i.getScale()) * 2) / 1.415;
        n > e && (e = n);
      }
      return e;
    }
    if (2 === arguments.length) {
      var r = arguments[0],
        o = arguments[1];
      return Math.min(
        FM.computeOverlaySnapTolerance(r),
        FM.computeOverlaySnapTolerance(o)
      );
    }
  }),
  (FM.computeSizeBasedSnapTolerance = function (t) {
    var e = t.getEnvelopeInternal();
    return Math.min(e.getHeight(), e.getWidth()) * FM.SNAP_PRECISION_FACTOR;
  }),
  (FM.snapToSelf = function (t, e, i) {
    return new FM(t).snapToSelf(e, i);
  }),
  (zM.SNAP_PRECISION_FACTOR.get = function () {
    return 1e-9;
  }),
  Object.defineProperties(FM, zM);
var kM = (function (t) {
    function e(e, i, n) {
      t.call(this),
        (this._snapTolerance = e || null),
        (this._snapPts = i || null),
        (this._isSelfSnap = void 0 !== n && n);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.snapLine = function (t, e) {
        var i = new OM(t, this._snapTolerance);
        return (
          i.setAllowSnappingToSourceVertices(this._isSelfSnap), i.snapTo(e)
        );
      }),
      (e.prototype.transformCoordinates = function (t, e) {
        var i = t.toCoordinateArray(),
          n = this.snapLine(i, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(n);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(RM),
  BM = function () {
    (this._isFirst = !0),
      (this._commonMantissaBitsCount = 53),
      (this._commonBits = 0),
      (this._commonSignExp = null);
  };
(BM.prototype.getCommon = function () {
  return Gv.longBitsToDouble(this._commonBits);
}),
  (BM.prototype.add = function (t) {
    var e = Gv.doubleToLongBits(t);
    return this._isFirst
      ? ((this._commonBits = e),
        (this._commonSignExp = BM.signExpBits(this._commonBits)),
        (this._isFirst = !1),
        null)
      : BM.signExpBits(e) !== this._commonSignExp
      ? ((this._commonBits = 0), null)
      : ((this._commonMantissaBitsCount = BM.numCommonMostSigMantissaBits(
          this._commonBits,
          e
        )),
        void (this._commonBits = BM.zeroLowerBits(
          this._commonBits,
          64 - (12 + this._commonMantissaBitsCount)
        )));
  }),
  (BM.prototype.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
        e = Gv.longBitsToDouble(t),
        i =
          "0000000000000000000000000000000000000000000000000000000000000000" +
          Gv.toBinaryString(t),
        n = i.substring(i.length - 64);
      return (
        n.substring(0, 1) +
        "  " +
        n.substring(1, 12) +
        "(exp) " +
        n.substring(12) +
        " [ " +
        e +
        " ]"
      );
    }
  }),
  (BM.prototype.interfaces_ = function () {
    return [];
  }),
  (BM.prototype.getClass = function () {
    return BM;
  }),
  (BM.getBit = function (t, e) {
    return t & (1 << e) ? 1 : 0;
  }),
  (BM.signExpBits = function (t) {
    return t >> 52;
  }),
  (BM.zeroLowerBits = function (t, e) {
    return t & ~((1 << e) - 1);
  }),
  (BM.numCommonMostSigMantissaBits = function (t, e) {
    for (var i = 0, n = 52; n >= 0; n--) {
      if (BM.getBit(t, n) !== BM.getBit(e, n)) return i;
      i++;
    }
    return 52;
  });
var GM = function () {
    (this._commonCoord = null), (this._ccFilter = new jM());
  },
  UM = {
    CommonCoordinateFilter: {
      configurable: !0,
    },
    Translater: {
      configurable: !0,
    },
  };
(GM.prototype.addCommonBits = function (t) {
  var e = new HM(this._commonCoord);
  t.apply(e), t.geometryChanged();
}),
  (GM.prototype.removeCommonBits = function (t) {
    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;
    var e = new qv(this._commonCoord);
    (e.x = -e.x), (e.y = -e.y);
    var i = new HM(e);
    return t.apply(i), t.geometryChanged(), t;
  }),
  (GM.prototype.getCommonCoordinate = function () {
    return this._commonCoord;
  }),
  (GM.prototype.add = function (t) {
    t.apply(this._ccFilter),
      (this._commonCoord = this._ccFilter.getCommonCoordinate());
  }),
  (GM.prototype.interfaces_ = function () {
    return [];
  }),
  (GM.prototype.getClass = function () {
    return GM;
  }),
  (UM.CommonCoordinateFilter.get = function () {
    return jM;
  }),
  (UM.Translater.get = function () {
    return HM;
  }),
  Object.defineProperties(GM, UM);
var jM = function () {
  (this._commonBitsX = new BM()), (this._commonBitsY = new BM());
};
(jM.prototype.filter = function (t) {
  this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);
}),
  (jM.prototype.getCommonCoordinate = function () {
    return new qv(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
  }),
  (jM.prototype.interfaces_ = function () {
    return [Ob];
  }),
  (jM.prototype.getClass = function () {
    return jM;
  });
var HM = function () {
  this.trans = null;
  var t = arguments[0];
  this.trans = t;
};
(HM.prototype.filter = function (t, e) {
  var i = t.getOrdinate(e, 0) + this.trans.x,
    n = t.getOrdinate(e, 1) + this.trans.y;
  t.setOrdinate(e, 0, i), t.setOrdinate(e, 1, n);
}),
  (HM.prototype.isDone = function () {
    return !1;
  }),
  (HM.prototype.isGeometryChanged = function () {
    return !0;
  }),
  (HM.prototype.interfaces_ = function () {
    return [xx];
  }),
  (HM.prototype.getClass = function () {
    return HM;
  });
var VM = function (t, e) {
  (this._geom = new Array(2).fill(null)),
    (this._snapTolerance = null),
    (this._cbr = null),
    (this._geom[0] = t),
    (this._geom[1] = e),
    this.computeSnapTolerance();
};
(VM.prototype.selfSnap = function (t) {
  return new FM(t).snapTo(t, this._snapTolerance);
}),
  (VM.prototype.removeCommonBits = function (t) {
    (this._cbr = new GM()), this._cbr.add(t[0]), this._cbr.add(t[1]);
    var e = new Array(2).fill(null);
    return (
      (e[0] = this._cbr.removeCommonBits(t[0].copy())),
      (e[1] = this._cbr.removeCommonBits(t[1].copy())),
      e
    );
  }),
  (VM.prototype.prepareResult = function (t) {
    return this._cbr.addCommonBits(t), t;
  }),
  (VM.prototype.getResultGeometry = function (t) {
    var e = this.snap(this._geom),
      i = pC.overlayOp(e[0], e[1], t);
    return this.prepareResult(i);
  }),
  (VM.prototype.checkValid = function (t) {
    t.isValid() || pb.out.println("Snapped geometry is invalid");
  }),
  (VM.prototype.computeSnapTolerance = function () {
    this._snapTolerance = FM.computeOverlaySnapTolerance(
      this._geom[0],
      this._geom[1]
    );
  }),
  (VM.prototype.snap = function (t) {
    var e = this.removeCommonBits(t);
    return FM.snap(e[0], e[1], this._snapTolerance);
  }),
  (VM.prototype.interfaces_ = function () {
    return [];
  }),
  (VM.prototype.getClass = function () {
    return VM;
  }),
  (VM.overlayOp = function (t, e, i) {
    return new VM(t, e).getResultGeometry(i);
  }),
  (VM.union = function (t, e) {
    return VM.overlayOp(t, e, pC.UNION);
  }),
  (VM.intersection = function (t, e) {
    return VM.overlayOp(t, e, pC.INTERSECTION);
  }),
  (VM.symDifference = function (t, e) {
    return VM.overlayOp(t, e, pC.SYMDIFFERENCE);
  }),
  (VM.difference = function (t, e) {
    return VM.overlayOp(t, e, pC.DIFFERENCE);
  });
var WM = function (t, e) {
  (this._geom = new Array(2).fill(null)),
    (this._geom[0] = t),
    (this._geom[1] = e);
};
(WM.prototype.getResultGeometry = function (t) {
  var e = null,
    i = !1,
    n = null;
  try {
    e = pC.overlayOp(this._geom[0], this._geom[1], t);
    i = !0;
  } catch (r) {
    if (!(r instanceof _b)) throw r;
    n = r;
  }
  if (!i)
    try {
      e = VM.overlayOp(this._geom[0], this._geom[1], t);
    } catch (r) {
      throw r instanceof _b ? n : r;
    }
  return e;
}),
  (WM.prototype.interfaces_ = function () {
    return [];
  }),
  (WM.prototype.getClass = function () {
    return WM;
  }),
  (WM.overlayOp = function (t, e, i) {
    return new WM(t, e).getResultGeometry(i);
  }),
  (WM.union = function (t, e) {
    return WM.overlayOp(t, e, pC.UNION);
  }),
  (WM.intersection = function (t, e) {
    return WM.overlayOp(t, e, pC.INTERSECTION);
  }),
  (WM.symDifference = function (t, e) {
    return WM.overlayOp(t, e, pC.SYMDIFFERENCE);
  }),
  (WM.difference = function (t, e) {
    return WM.overlayOp(t, e, pC.DIFFERENCE);
  });
var qM = function () {
  (this.mce = null), (this.chainIndex = null);
  var t = arguments[0],
    e = arguments[1];
  (this.mce = t), (this.chainIndex = e);
};
(qM.prototype.computeIntersections = function (t, e) {
  this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
}),
  (qM.prototype.interfaces_ = function () {
    return [];
  }),
  (qM.prototype.getClass = function () {
    return qM;
  });
var YM = function t() {
    if (
      ((this._label = null),
      (this._xValue = null),
      (this._eventType = null),
      (this._insertEvent = null),
      (this._deleteEventIndex = null),
      (this._obj = null),
      2 === arguments.length)
    ) {
      var e = arguments[0],
        i = arguments[1];
      (this._eventType = t.DELETE), (this._xValue = e), (this._insertEvent = i);
    } else if (3 === arguments.length) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2];
      (this._eventType = t.INSERT),
        (this._label = n),
        (this._xValue = r),
        (this._obj = o);
    }
  },
  XM = {
    INSERT: {
      configurable: !0,
    },
    DELETE: {
      configurable: !0,
    },
  };
(YM.prototype.isDelete = function () {
  return this._eventType === YM.DELETE;
}),
  (YM.prototype.setDeleteEventIndex = function (t) {
    this._deleteEventIndex = t;
  }),
  (YM.prototype.getObject = function () {
    return this._obj;
  }),
  (YM.prototype.compareTo = function (t) {
    var e = t;
    return this._xValue < e._xValue
      ? -1
      : this._xValue > e._xValue
      ? 1
      : this._eventType < e._eventType
      ? -1
      : this._eventType > e._eventType
      ? 1
      : 0;
  }),
  (YM.prototype.getInsertEvent = function () {
    return this._insertEvent;
  }),
  (YM.prototype.isInsert = function () {
    return this._eventType === YM.INSERT;
  }),
  (YM.prototype.isSameLabel = function (t) {
    return null !== this._label && this._label === t._label;
  }),
  (YM.prototype.getDeleteEventIndex = function () {
    return this._deleteEventIndex;
  }),
  (YM.prototype.interfaces_ = function () {
    return [jv];
  }),
  (YM.prototype.getClass = function () {
    return YM;
  }),
  (XM.INSERT.get = function () {
    return 1;
  }),
  (XM.DELETE.get = function () {
    return 2;
  }),
  Object.defineProperties(YM, XM);
var QM = function () {};
(QM.prototype.interfaces_ = function () {
  return [];
}),
  (QM.prototype.getClass = function () {
    return QM;
  });
var ZM = function () {
  (this._hasIntersection = !1),
    (this._hasProper = !1),
    (this._hasProperInterior = !1),
    (this._properIntersectionPoint = null),
    (this._li = null),
    (this._includeProper = null),
    (this._recordIsolated = null),
    (this._isSelfIntersection = null),
    (this._numIntersections = 0),
    (this.numTests = 0),
    (this._bdyNodes = null),
    (this._isDone = !1),
    (this._isDoneWhenProperInt = !1);
  var t = arguments[0],
    e = arguments[1],
    i = arguments[2];
  (this._li = t), (this._includeProper = e), (this._recordIsolated = i);
};
(ZM.prototype.isTrivialIntersection = function (t, e, i, n) {
  if (t === i && 1 === this._li.getIntersectionNum()) {
    if (ZM.isAdjacentSegments(e, n)) return !0;
    if (t.isClosed()) {
      var r = t.getNumPoints() - 1;
      if ((0 === e && n === r) || (0 === n && e === r)) return !0;
    }
  }
  return !1;
}),
  (ZM.prototype.getProperIntersectionPoint = function () {
    return this._properIntersectionPoint;
  }),
  (ZM.prototype.setIsDoneIfProperInt = function (t) {
    this._isDoneWhenProperInt = t;
  }),
  (ZM.prototype.hasProperInteriorIntersection = function () {
    return this._hasProperInterior;
  }),
  (ZM.prototype.isBoundaryPointInternal = function (t, e) {
    for (var i = e.iterator(); i.hasNext(); ) {
      var n = i.next().getCoordinate();
      if (t.isIntersection(n)) return !0;
    }
    return !1;
  }),
  (ZM.prototype.hasProperIntersection = function () {
    return this._hasProper;
  }),
  (ZM.prototype.hasIntersection = function () {
    return this._hasIntersection;
  }),
  (ZM.prototype.isDone = function () {
    return this._isDone;
  }),
  (ZM.prototype.isBoundaryPoint = function (t, e) {
    return (
      null !== e &&
      (!!this.isBoundaryPointInternal(t, e[0]) ||
        !!this.isBoundaryPointInternal(t, e[1]))
    );
  }),
  (ZM.prototype.setBoundaryNodes = function (t, e) {
    (this._bdyNodes = new Array(2).fill(null)),
      (this._bdyNodes[0] = t),
      (this._bdyNodes[1] = e);
  }),
  (ZM.prototype.addIntersections = function (t, e, i, n) {
    if (t === i && e === n) return null;
    this.numTests++;
    var r = t.getCoordinates()[e],
      o = t.getCoordinates()[e + 1],
      a = i.getCoordinates()[n],
      s = i.getCoordinates()[n + 1];
    this._li.computeIntersection(r, o, a, s),
      this._li.hasIntersection() &&
        (this._recordIsolated && (t.setIsolated(!1), i.setIsolated(!1)),
        this._numIntersections++,
        this.isTrivialIntersection(t, e, i, n) ||
          ((this._hasIntersection = !0),
          (!this._includeProper && this._li.isProper()) ||
            (t.addIntersections(this._li, e, 0),
            i.addIntersections(this._li, n, 1)),
          this._li.isProper() &&
            ((this._properIntersectionPoint = this._li
              .getIntersection(0)
              .copy()),
            (this._hasProper = !0),
            this._isDoneWhenProperInt && (this._isDone = !0),
            this.isBoundaryPoint(this._li, this._bdyNodes) ||
              (this._hasProperInterior = !0))));
  }),
  (ZM.prototype.interfaces_ = function () {
    return [];
  }),
  (ZM.prototype.getClass = function () {
    return ZM;
  }),
  (ZM.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  });
var JM = (function (t) {
    function e() {
      t.call(this), (this.events = new Yb()), (this.nOverlaps = null);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.prepareEvents = function () {
        G_.sort(this.events);
        for (var t = 0; t < this.events.size(); t++) {
          var e = this.events.get(t);
          e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);
        }
      }),
      (e.prototype.computeIntersections = function () {
        if (1 === arguments.length) {
          var t = arguments[0];
          (this.nOverlaps = 0), this.prepareEvents();
          for (var e = 0; e < this.events.size(); e++) {
            var i = this.events.get(e);
            if (
              (i.isInsert() &&
                this.processOverlaps(e, i.getDeleteEventIndex(), i, t),
              t.isDone())
            )
              break;
          }
        } else if (3 === arguments.length)
          if (
            arguments[2] instanceof ZM &&
            Kv(arguments[0], Wb) &&
            Kv(arguments[1], Wb)
          ) {
            var n = arguments[0],
              r = arguments[1],
              o = arguments[2];
            this.addEdges(n, n),
              this.addEdges(r, r),
              this.computeIntersections(o);
          } else if (
            "boolean" == typeof arguments[2] &&
            Kv(arguments[0], Wb) &&
            arguments[1] instanceof ZM
          ) {
            var a = arguments[0],
              s = arguments[1];
            arguments[2] ? this.addEdges(a, null) : this.addEdges(a),
              this.computeIntersections(s);
          }
      }),
      (e.prototype.addEdge = function (t, e) {
        for (
          var i = t.getMonotoneChainEdge(), n = i.getStartIndexes(), r = 0;
          r < n.length - 1;
          r++
        ) {
          var o = new qM(i, r),
            a = new YM(e, i.getMinX(r), o);
          this.events.add(a), this.events.add(new YM(i.getMaxX(r), a));
        }
      }),
      (e.prototype.processOverlaps = function (t, e, i, n) {
        for (var r = i.getObject(), o = t; o < e; o++) {
          var a = this.events.get(o);
          if (a.isInsert()) {
            var s = a.getObject();
            i.isSameLabel(a) ||
              (r.computeIntersections(s, n), this.nOverlaps++);
          }
        }
      }),
      (e.prototype.addEdges = function () {
        if (1 === arguments.length)
          for (var t = arguments[0].iterator(); t.hasNext(); ) {
            var e = t.next();
            this.addEdge(e, e);
          }
        else if (2 === arguments.length)
          for (
            var i = arguments[1], n = arguments[0].iterator();
            n.hasNext();

          ) {
            var r = n.next();
            this.addEdge(r, i);
          }
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(QM),
  KM = function () {
    (this._min = Gv.POSITIVE_INFINITY), (this._max = Gv.NEGATIVE_INFINITY);
  },
  $M = {
    NodeComparator: {
      configurable: !0,
    },
  };
(KM.prototype.getMin = function () {
  return this._min;
}),
  (KM.prototype.intersects = function (t, e) {
    return !(this._min > e || this._max < t);
  }),
  (KM.prototype.getMax = function () {
    return this._max;
  }),
  (KM.prototype.toString = function () {
    return xb.toLineString(new qv(this._min, 0), new qv(this._max, 0));
  }),
  (KM.prototype.interfaces_ = function () {
    return [];
  }),
  (KM.prototype.getClass = function () {
    return KM;
  }),
  ($M.NodeComparator.get = function () {
    return tC;
  }),
  Object.defineProperties(KM, $M);
var tC = function () {};
(tC.prototype.compare = function (t, e) {
  var i = t,
    n = e,
    r = (i._min + i._max) / 2,
    o = (n._min + n._max) / 2;
  return r < o ? -1 : r > o ? 1 : 0;
}),
  (tC.prototype.interfaces_ = function () {
    return [Vv];
  }),
  (tC.prototype.getClass = function () {
    return tC;
  });
var eC = (function (t) {
    function e() {
      t.call(this), (this._item = null);
      var e = arguments[0],
        i = arguments[1],
        n = arguments[2];
      (this._min = e), (this._max = i), (this._item = n);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.query = function (t, e, i) {
        if (!this.intersects(t, e)) return null;
        i.visitItem(this._item);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(KM),
  iC = (function (t) {
    function e() {
      t.call(this), (this._node1 = null), (this._node2 = null);
      var e = arguments[0],
        i = arguments[1];
      (this._node1 = e),
        (this._node2 = i),
        this.buildExtent(this._node1, this._node2);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.buildExtent = function (t, e) {
        (this._min = Math.min(t._min, e._min)),
          (this._max = Math.max(t._max, e._max));
      }),
      (e.prototype.query = function (t, e, i) {
        if (!this.intersects(t, e)) return null;
        null !== this._node1 && this._node1.query(t, e, i),
          null !== this._node2 && this._node2.query(t, e, i);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      e
    );
  })(KM),
  nC = function () {
    (this._leaves = new Yb()), (this._root = null), (this._level = 0);
  };
(nC.prototype.buildTree = function () {
  G_.sort(this._leaves, new KM.NodeComparator());
  for (var t = this._leaves, e = null, i = new Yb(); ; ) {
    if ((this.buildLevel(t, i), 1 === i.size())) return i.get(0);
    (e = t), (t = i), (i = e);
  }
}),
  (nC.prototype.insert = function (t, e, i) {
    if (null !== this._root)
      throw new Error("Index cannot be added to once it has been queried");
    this._leaves.add(new eC(t, e, i));
  }),
  (nC.prototype.query = function (t, e, i) {
    this.init(), this._root.query(t, e, i);
  }),
  (nC.prototype.buildRoot = function () {
    if (null !== this._root) return null;
    this._root = this.buildTree();
  }),
  (nC.prototype.printNode = function (t) {
    pb.out.println(
      xb.toLineString(new qv(t._min, this._level), new qv(t._max, this._level))
    );
  }),
  (nC.prototype.init = function () {
    if (null !== this._root) return null;
    this.buildRoot();
  }),
  (nC.prototype.buildLevel = function (t, e) {
    this._level++, e.clear();
    for (var i = 0; i < t.size(); i += 2) {
      var n = t.get(i);
      if (null === (i + 1 < t.size() ? t.get(i) : null)) e.add(n);
      else {
        var r = new iC(t.get(i), t.get(i + 1));
        e.add(r);
      }
    }
  }),
  (nC.prototype.interfaces_ = function () {
    return [];
  }),
  (nC.prototype.getClass = function () {
    return nC;
  });
var rC = function () {
  this._items = new Yb();
};
(rC.prototype.visitItem = function (t) {
  this._items.add(t);
}),
  (rC.prototype.getItems = function () {
    return this._items;
  }),
  (rC.prototype.interfaces_ = function () {
    return [F_];
  }),
  (rC.prototype.getClass = function () {
    return rC;
  });
var oC = function () {
    this._index = null;
    var t = arguments[0];
    if (!Kv(t, zx)) throw new Bv("Argument must be Polygonal");
    this._index = new lC(t);
  },
  aC = {
    SegmentVisitor: {
      configurable: !0,
    },
    IntervalIndexedGeometry: {
      configurable: !0,
    },
  };
(oC.prototype.locate = function (t) {
  var e = new Db(t),
    i = new sC(e);
  return this._index.query(t.y, t.y, i), e.getLocation();
}),
  (oC.prototype.interfaces_ = function () {
    return [AS];
  }),
  (oC.prototype.getClass = function () {
    return oC;
  }),
  (aC.SegmentVisitor.get = function () {
    return sC;
  }),
  (aC.IntervalIndexedGeometry.get = function () {
    return lC;
  }),
  Object.defineProperties(oC, aC);
var sC = function () {
  this._counter = null;
  var t = arguments[0];
  this._counter = t;
};
(sC.prototype.visitItem = function (t) {
  var e = t;
  this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
}),
  (sC.prototype.interfaces_ = function () {
    return [F_];
  }),
  (sC.prototype.getClass = function () {
    return sC;
  });
var lC = function () {
  this._index = new nC();
  var t = arguments[0];
  this.init(t);
};
(lC.prototype.init = function (t) {
  for (var e = cM.getLines(t).iterator(); e.hasNext(); ) {
    var i = e.next().getCoordinates();
    this.addLine(i);
  }
}),
  (lC.prototype.addLine = function (t) {
    for (var e = 1; e < t.length; e++) {
      var i = new eS(t[e - 1], t[e]),
        n = Math.min(i.p0.y, i.p1.y),
        r = Math.max(i.p0.y, i.p1.y);
      this._index.insert(n, r, i);
    }
  }),
  (lC.prototype.query = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1],
        i = new rC();
      return this._index.query(t, e, i), i.getItems();
    }
    if (3 === arguments.length) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2];
      this._index.query(n, r, o);
    }
  }),
  (lC.prototype.interfaces_ = function () {
    return [];
  }),
  (lC.prototype.getClass = function () {
    return lC;
  });
var uC = (function (t) {
    function e() {
      if (
        (t.call(this),
        (this._parentGeom = null),
        (this._lineEdgeMap = new Jx()),
        (this._boundaryNodeRule = null),
        (this._useBoundaryDeterminationRule = !0),
        (this._argIndex = null),
        (this._boundaryNodes = null),
        (this._hasTooFewPoints = !1),
        (this._invalidPoint = null),
        (this._areaPtLocator = null),
        (this._ptLocator = new hM()),
        2 === arguments.length)
      ) {
        var e = arguments[0],
          i = arguments[1],
          n = Fb.OGC_SFS_BOUNDARY_RULE;
        (this._argIndex = e),
          (this._parentGeom = i),
          (this._boundaryNodeRule = n),
          null !== i && this.add(i);
      } else if (3 === arguments.length) {
        var r = arguments[0],
          o = arguments[1],
          a = arguments[2];
        (this._argIndex = r),
          (this._parentGeom = o),
          (this._boundaryNodeRule = a),
          null !== o && this.add(o);
      }
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.insertBoundaryPoint = function (t, i) {
        var n = this._nodes.addNode(i).getLabel(),
          r = 1;
        n.getLocation(t, c_.ON) === Zv.BOUNDARY && r++;
        var o = e.determineBoundary(this._boundaryNodeRule, r);
        n.setLocation(t, o);
      }),
      (e.prototype.computeSelfNodes = function () {
        if (2 === arguments.length) {
          var t = arguments[0],
            e = arguments[1];
          return this.computeSelfNodes(t, e, !1);
        }
        if (3 === arguments.length) {
          var i = arguments[1],
            n = arguments[2],
            r = new ZM(arguments[0], !0, !1);
          r.setIsDoneIfProperInt(n);
          var o = this.createEdgeSetIntersector(),
            a =
              this._parentGeom instanceof Gx ||
              this._parentGeom instanceof kx ||
              this._parentGeom instanceof Ux,
            s = i || !a;
          return (
            o.computeIntersections(this._edges, r, s),
            this.addSelfIntersectionNodes(this._argIndex),
            r
          );
        }
      }),
      (e.prototype.computeSplitEdges = function (t) {
        for (var e = this._edges.iterator(); e.hasNext(); ) {
          e.next().eiList.addSplitEdges(t);
        }
      }),
      (e.prototype.computeEdgeIntersections = function (t, e, i) {
        var n = new ZM(e, i, !0);
        return (
          n.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()),
          this.createEdgeSetIntersector().computeIntersections(
            this._edges,
            t._edges,
            n
          ),
          n
        );
      }),
      (e.prototype.getGeometry = function () {
        return this._parentGeom;
      }),
      (e.prototype.getBoundaryNodeRule = function () {
        return this._boundaryNodeRule;
      }),
      (e.prototype.hasTooFewPoints = function () {
        return this._hasTooFewPoints;
      }),
      (e.prototype.addPoint = function () {
        if (arguments[0] instanceof Fx) {
          var t = arguments[0].getCoordinate();
          this.insertPoint(this._argIndex, t, Zv.INTERIOR);
        } else if (arguments[0] instanceof qv) {
          var e = arguments[0];
          this.insertPoint(this._argIndex, e, Zv.INTERIOR);
        }
      }),
      (e.prototype.addPolygon = function (t) {
        this.addPolygonRing(t.getExteriorRing(), Zv.EXTERIOR, Zv.INTERIOR);
        for (var e = 0; e < t.getNumInteriorRing(); e++) {
          var i = t.getInteriorRingN(e);
          this.addPolygonRing(i, Zv.INTERIOR, Zv.EXTERIOR);
        }
      }),
      (e.prototype.addEdge = function (t) {
        this.insertEdge(t);
        var e = t.getCoordinates();
        this.insertPoint(this._argIndex, e[0], Zv.BOUNDARY),
          this.insertPoint(this._argIndex, e[e.length - 1], Zv.BOUNDARY);
      }),
      (e.prototype.addLineString = function (t) {
        var e = Zb.removeRepeatedPoints(t.getCoordinates());
        if (e.length < 2)
          return (
            (this._hasTooFewPoints = !0), (this._invalidPoint = e[0]), null
          );
        var i = new jS(e, new b_(this._argIndex, Zv.INTERIOR));
        this._lineEdgeMap.put(t, i),
          this.insertEdge(i),
          Mb.isTrue(e.length >= 2, "found LineString with single point"),
          this.insertBoundaryPoint(this._argIndex, e[0]),
          this.insertBoundaryPoint(this._argIndex, e[e.length - 1]);
      }),
      (e.prototype.getInvalidPoint = function () {
        return this._invalidPoint;
      }),
      (e.prototype.getBoundaryPoints = function () {
        for (
          var t = this.getBoundaryNodes(),
            e = new Array(t.size()).fill(null),
            i = 0,
            n = t.iterator();
          n.hasNext();

        ) {
          var r = n.next();
          e[i++] = r.getCoordinate().copy();
        }
        return e;
      }),
      (e.prototype.getBoundaryNodes = function () {
        return (
          null === this._boundaryNodes &&
            (this._boundaryNodes = this._nodes.getBoundaryNodes(
              this._argIndex
            )),
          this._boundaryNodes
        );
      }),
      (e.prototype.addSelfIntersectionNode = function (t, e, i) {
        if (this.isBoundaryNode(t, e)) return null;
        i === Zv.BOUNDARY && this._useBoundaryDeterminationRule
          ? this.insertBoundaryPoint(t, e)
          : this.insertPoint(t, e, i);
      }),
      (e.prototype.addPolygonRing = function (t, e, i) {
        if (t.isEmpty()) return null;
        var n = Zb.removeRepeatedPoints(t.getCoordinates());
        if (n.length < 4)
          return (
            (this._hasTooFewPoints = !0), (this._invalidPoint = n[0]), null
          );
        var r = e,
          o = i;
        Tb.isCCW(n) && ((r = i), (o = e));
        var a = new jS(n, new b_(this._argIndex, Zv.BOUNDARY, r, o));
        this._lineEdgeMap.put(t, a),
          this.insertEdge(a),
          this.insertPoint(this._argIndex, n[0], Zv.BOUNDARY);
      }),
      (e.prototype.insertPoint = function (t, e, i) {
        var n = this._nodes.addNode(e),
          r = n.getLabel();
        null === r ? (n._label = new b_(t, i)) : r.setLocation(t, i);
      }),
      (e.prototype.createEdgeSetIntersector = function () {
        return new JM();
      }),
      (e.prototype.addSelfIntersectionNodes = function (t) {
        for (var e = this._edges.iterator(); e.hasNext(); )
          for (
            var i = e.next(),
              n = i.getLabel().getLocation(t),
              r = i.eiList.iterator();
            r.hasNext();

          ) {
            var o = r.next();
            this.addSelfIntersectionNode(t, o.coord, n);
          }
      }),
      (e.prototype.add = function () {
        if (1 !== arguments.length)
          return t.prototype.add.apply(this, arguments);
        var e = arguments[0];
        if (e.isEmpty()) return null;
        if (
          (e instanceof Ux && (this._useBoundaryDeterminationRule = !1),
          e instanceof kx)
        )
          this.addPolygon(e);
        else if (e instanceof Rx) this.addLineString(e);
        else if (e instanceof Fx) this.addPoint(e);
        else if (e instanceof Bx) this.addCollection(e);
        else if (e instanceof Sx) this.addCollection(e);
        else if (e instanceof Ux) this.addCollection(e);
        else {
          if (!(e instanceof _x)) throw new Error(e.getClass().getName());
          this.addCollection(e);
        }
      }),
      (e.prototype.addCollection = function (t) {
        for (var e = 0; e < t.getNumGeometries(); e++) {
          var i = t.getGeometryN(e);
          this.add(i);
        }
      }),
      (e.prototype.locate = function (t) {
        return Kv(this._parentGeom, zx) &&
          this._parentGeom.getNumGeometries() > 50
          ? (null === this._areaPtLocator &&
              (this._areaPtLocator = new oC(this._parentGeom)),
            this._areaPtLocator.locate(t))
          : this._ptLocator.locate(t, this._parentGeom);
      }),
      (e.prototype.findEdge = function () {
        if (1 === arguments.length) {
          var e = arguments[0];
          return this._lineEdgeMap.get(e);
        }
        return t.prototype.findEdge.apply(this, arguments);
      }),
      (e.prototype.interfaces_ = function () {
        return [];
      }),
      (e.prototype.getClass = function () {
        return e;
      }),
      (e.determineBoundary = function (t, e) {
        return t.isInBoundary(e) ? Zv.BOUNDARY : Zv.INTERIOR;
      }),
      e
    );
  })(L_),
  cC = function () {
    if (
      ((this._li = new Ab()),
      (this._resultPrecisionModel = null),
      (this._arg = null),
      1 === arguments.length)
    ) {
      var t = arguments[0];
      this.setComputationPrecision(t.getPrecisionModel()),
        (this._arg = new Array(1).fill(null)),
        (this._arg[0] = new uC(0, t));
    } else if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1],
        n = Fb.OGC_SFS_BOUNDARY_RULE;
      e.getPrecisionModel().compareTo(i.getPrecisionModel()) >= 0
        ? this.setComputationPrecision(e.getPrecisionModel())
        : this.setComputationPrecision(i.getPrecisionModel()),
        (this._arg = new Array(2).fill(null)),
        (this._arg[0] = new uC(0, e, n)),
        (this._arg[1] = new uC(1, i, n));
    } else if (3 === arguments.length) {
      var r = arguments[0],
        o = arguments[1],
        a = arguments[2];
      r.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0
        ? this.setComputationPrecision(r.getPrecisionModel())
        : this.setComputationPrecision(o.getPrecisionModel()),
        (this._arg = new Array(2).fill(null)),
        (this._arg[0] = new uC(0, r, a)),
        (this._arg[1] = new uC(1, o, a));
    }
  };
(cC.prototype.getArgGeometry = function (t) {
  return this._arg[t].getGeometry();
}),
  (cC.prototype.setComputationPrecision = function (t) {
    (this._resultPrecisionModel = t),
      this._li.setPrecisionModel(this._resultPrecisionModel);
  }),
  (cC.prototype.interfaces_ = function () {
    return [];
  }),
  (cC.prototype.getClass = function () {
    return cC;
  });
var hC = function () {};
(hC.prototype.interfaces_ = function () {
  return [];
}),
  (hC.prototype.getClass = function () {
    return hC;
  }),
  (hC.map = function () {
    if (arguments[0] instanceof Ib && Kv(arguments[1], hC.MapOp)) {
      for (
        var t = arguments[0], e = arguments[1], i = new Yb(), n = 0;
        n < t.getNumGeometries();
        n++
      ) {
        var r = e.map(t.getGeometryN(n));
        null !== r && i.add(r);
      }
      return t.getFactory().buildGeometry(i);
    }
    if (Kv(arguments[0], jb) && Kv(arguments[1], hC.MapOp)) {
      for (
        var o = arguments[0], a = arguments[1], s = new Yb(), l = o.iterator();
        l.hasNext();

      ) {
        var u = l.next(),
          c = a.map(u);
        null !== c && s.add(c);
      }
      return s;
    }
  }),
  (hC.MapOp = function () {});
var pC = (function (t) {
  function e() {
    var e = arguments[0],
      i = arguments[1];
    t.call(this, e, i),
      (this._ptLocator = new hM()),
      (this._geomFact = null),
      (this._resultGeom = null),
      (this._graph = null),
      (this._edgeList = new NS()),
      (this._resultPolyList = new Yb()),
      (this._resultLineList = new Yb()),
      (this._resultPointList = new Yb()),
      (this._graph = new L_(new LS())),
      (this._geomFact = e.getFactory());
  }
  return (
    t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e),
    (e.prototype.insertUniqueEdge = function (t) {
      var e = this._edgeList.findEqualEdge(t);
      if (null !== e) {
        var i = e.getLabel(),
          n = t.getLabel();
        e.isPointwiseEqual(t) || (n = new b_(t.getLabel())).flip();
        var r = e.getDepth();
        r.isNull() && r.add(i), r.add(n), i.merge(n);
      } else this._edgeList.add(t);
    }),
    (e.prototype.getGraph = function () {
      return this._graph;
    }),
    (e.prototype.cancelDuplicateResultEdges = function () {
      for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext(); ) {
        var e = t.next(),
          i = e.getSym();
        e.isInResult() &&
          i.isInResult() &&
          (e.setInResult(!1), i.setInResult(!1));
      }
    }),
    (e.prototype.isCoveredByLA = function (t) {
      return (
        !!this.isCovered(t, this._resultLineList) ||
        !!this.isCovered(t, this._resultPolyList)
      );
    }),
    (e.prototype.computeGeometry = function (t, i, n, r) {
      var o = new Yb();
      return (
        o.addAll(t),
        o.addAll(i),
        o.addAll(n),
        o.isEmpty()
          ? e.createEmptyResult(
              r,
              this._arg[0].getGeometry(),
              this._arg[1].getGeometry(),
              this._geomFact
            )
          : this._geomFact.buildGeometry(o)
      );
    }),
    (e.prototype.mergeSymLabels = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext(); ) {
        t.next().getEdges().mergeSymLabels();
      }
    }),
    (e.prototype.isCovered = function (t, e) {
      for (var i = e.iterator(); i.hasNext(); ) {
        var n = i.next();
        if (this._ptLocator.locate(t, n) !== Zv.EXTERIOR) return !0;
      }
      return !1;
    }),
    (e.prototype.replaceCollapsedEdges = function () {
      for (var t = new Yb(), e = this._edgeList.iterator(); e.hasNext(); ) {
        var i = e.next();
        i.isCollapsed() && (e.remove(), t.add(i.getCollapsedEdge()));
      }
      this._edgeList.addAll(t);
    }),
    (e.prototype.updateNodeLabelling = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext(); ) {
        var e = t.next(),
          i = e.getEdges().getLabel();
        e.getLabel().merge(i);
      }
    }),
    (e.prototype.getResultGeometry = function (t) {
      return this.computeOverlay(t), this._resultGeom;
    }),
    (e.prototype.insertUniqueEdges = function (t) {
      for (var e = t.iterator(); e.hasNext(); ) {
        var i = e.next();
        this.insertUniqueEdge(i);
      }
    }),
    (e.prototype.computeOverlay = function (t) {
      this.copyPoints(0),
        this.copyPoints(1),
        this._arg[0].computeSelfNodes(this._li, !1),
        this._arg[1].computeSelfNodes(this._li, !1),
        this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
      var e = new Yb();
      this._arg[0].computeSplitEdges(e),
        this._arg[1].computeSplitEdges(e),
        this.insertUniqueEdges(e),
        this.computeLabelsFromDepths(),
        this.replaceCollapsedEdges(),
        PM.checkValid(this._edgeList.getEdges()),
        this._graph.addEdges(this._edgeList.getEdges()),
        this.computeLabelling(),
        this.labelIncompleteNodes(),
        this.findResultAreaEdges(t),
        this.cancelDuplicateResultEdges();
      var i = new I_(this._geomFact);
      i.add(this._graph), (this._resultPolyList = i.getPolygons());
      var n = new IM(this, this._geomFact, this._ptLocator);
      this._resultLineList = n.build(t);
      var r = new NM(this, this._geomFact, this._ptLocator);
      (this._resultPointList = r.build(t)),
        (this._resultGeom = this.computeGeometry(
          this._resultPointList,
          this._resultLineList,
          this._resultPolyList,
          t
        ));
    }),
    (e.prototype.labelIncompleteNode = function (t, e) {
      var i = this._ptLocator.locate(
        t.getCoordinate(),
        this._arg[e].getGeometry()
      );
      t.getLabel().setLocation(e, i);
    }),
    (e.prototype.copyPoints = function (t) {
      for (var e = this._arg[t].getNodeIterator(); e.hasNext(); ) {
        var i = e.next();
        this._graph
          .addNode(i.getCoordinate())
          .setLabel(t, i.getLabel().getLocation(t));
      }
    }),
    (e.prototype.findResultAreaEdges = function (t) {
      for (var i = this._graph.getEdgeEnds().iterator(); i.hasNext(); ) {
        var n = i.next(),
          r = n.getLabel();
        r.isArea() &&
          !n.isInteriorAreaEdge() &&
          e.isResultOfOp(
            r.getLocation(0, c_.RIGHT),
            r.getLocation(1, c_.RIGHT),
            t
          ) &&
          n.setInResult(!0);
      }
    }),
    (e.prototype.computeLabelsFromDepths = function () {
      for (var t = this._edgeList.iterator(); t.hasNext(); ) {
        var e = t.next(),
          i = e.getLabel(),
          n = e.getDepth();
        if (!n.isNull()) {
          n.normalize();
          for (var r = 0; r < 2; r++)
            i.isNull(r) ||
              !i.isArea() ||
              n.isNull(r) ||
              (0 === n.getDelta(r)
                ? i.toLine(r)
                : (Mb.isTrue(
                    !n.isNull(r, c_.LEFT),
                    "depth of LEFT side has not been initialized"
                  ),
                  i.setLocation(r, c_.LEFT, n.getLocation(r, c_.LEFT)),
                  Mb.isTrue(
                    !n.isNull(r, c_.RIGHT),
                    "depth of RIGHT side has not been initialized"
                  ),
                  i.setLocation(r, c_.RIGHT, n.getLocation(r, c_.RIGHT))));
        }
      }
    }),
    (e.prototype.computeLabelling = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext(); ) {
        t.next().getEdges().computeLabelling(this._arg);
      }
      this.mergeSymLabels(), this.updateNodeLabelling();
    }),
    (e.prototype.labelIncompleteNodes = function () {
      for (var t = this._graph.getNodes().iterator(); t.hasNext(); ) {
        var e = t.next(),
          i = e.getLabel();
        e.isIsolated() &&
          (i.isNull(0)
            ? this.labelIncompleteNode(e, 0)
            : this.labelIncompleteNode(e, 1)),
          e.getEdges().updateLabelling(i);
      }
    }),
    (e.prototype.isCoveredByA = function (t) {
      return !!this.isCovered(t, this._resultPolyList);
    }),
    (e.prototype.interfaces_ = function () {
      return [];
    }),
    (e.prototype.getClass = function () {
      return e;
    }),
    e
  );
})(cC);
(pC.overlayOp = function (t, e, i) {
  return new pC(t, e).getResultGeometry(i);
}),
  (pC.intersection = function (t, e) {
    if (t.isEmpty() || e.isEmpty())
      return pC.createEmptyResult(pC.INTERSECTION, t, e, t.getFactory());
    if (t.isGeometryCollection()) {
      var i = e;
      return LM.map(t, {
        interfaces_: function () {
          return [hC.MapOp];
        },
        map: function (t) {
          return t.intersection(i);
        },
      });
    }
    return (
      t.checkNotGeometryCollection(t),
      t.checkNotGeometryCollection(e),
      WM.overlayOp(t, e, pC.INTERSECTION)
    );
  }),
  (pC.symDifference = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty())
        return pC.createEmptyResult(pC.SYMDIFFERENCE, t, e, t.getFactory());
      if (t.isEmpty()) return e.copy();
      if (e.isEmpty()) return t.copy();
    }
    return (
      t.checkNotGeometryCollection(t),
      t.checkNotGeometryCollection(e),
      WM.overlayOp(t, e, pC.SYMDIFFERENCE)
    );
  }),
  (pC.resultDimension = function (t, e, i) {
    var n = e.getDimension(),
      r = i.getDimension(),
      o = -1;
    switch (t) {
      case pC.INTERSECTION:
        o = Math.min(n, r);
        break;
      case pC.UNION:
        o = Math.max(n, r);
        break;
      case pC.DIFFERENCE:
        o = n;
        break;
      case pC.SYMDIFFERENCE:
        o = Math.max(n, r);
    }
    return o;
  }),
  (pC.createEmptyResult = function (t, e, i, n) {
    var r = null;
    switch (pC.resultDimension(t, e, i)) {
      case -1:
        r = n.createGeometryCollection(new Array(0).fill(null));
        break;
      case 0:
        r = n.createPoint();
        break;
      case 1:
        r = n.createLineString();
        break;
      case 2:
        r = n.createPolygon();
    }
    return r;
  }),
  (pC.difference = function (t, e) {
    return t.isEmpty()
      ? pC.createEmptyResult(pC.DIFFERENCE, t, e, t.getFactory())
      : e.isEmpty()
      ? t.copy()
      : (t.checkNotGeometryCollection(t),
        t.checkNotGeometryCollection(e),
        WM.overlayOp(t, e, pC.DIFFERENCE));
  }),
  (pC.isResultOfOp = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1],
        i = t.getLocation(0),
        n = t.getLocation(1);
      return pC.isResultOfOp(i, n, e);
    }
    if (3 === arguments.length) {
      var r = arguments[0],
        o = arguments[1];
      switch (
        (r === Zv.BOUNDARY && (r = Zv.INTERIOR),
        o === Zv.BOUNDARY && (o = Zv.INTERIOR),
        arguments[2])
      ) {
        case pC.INTERSECTION:
          return r === Zv.INTERIOR && o === Zv.INTERIOR;
        case pC.UNION:
          return r === Zv.INTERIOR || o === Zv.INTERIOR;
        case pC.DIFFERENCE:
          return r === Zv.INTERIOR && o !== Zv.INTERIOR;
        case pC.SYMDIFFERENCE:
          return (
            (r === Zv.INTERIOR && o !== Zv.INTERIOR) ||
            (r !== Zv.INTERIOR && o === Zv.INTERIOR)
          );
      }
      return !1;
    }
  }),
  (pC.INTERSECTION = 1),
  (pC.UNION = 2),
  (pC.DIFFERENCE = 3),
  (pC.SYMDIFFERENCE = 4);
var dC = function () {
  (this._g = null),
    (this._boundaryDistanceTolerance = null),
    (this._linework = null),
    (this._ptLocator = new hM()),
    (this._seg = new eS());
  var t = arguments[0],
    e = arguments[1];
  (this._g = t),
    (this._boundaryDistanceTolerance = e),
    (this._linework = this.extractLinework(t));
};
(dC.prototype.isWithinToleranceOfBoundary = function (t) {
  for (var e = this, i = 0; i < this._linework.getNumGeometries(); i++)
    for (
      var n = e._linework.getGeometryN(i).getCoordinateSequence(), r = 0;
      r < n.size() - 1;
      r++
    ) {
      if (
        (n.getCoordinate(r, e._seg.p0),
        n.getCoordinate(r + 1, e._seg.p1),
        e._seg.distance(t) <= e._boundaryDistanceTolerance)
      )
        return !0;
    }
  return !1;
}),
  (dC.prototype.getLocation = function (t) {
    return this.isWithinToleranceOfBoundary(t)
      ? Zv.BOUNDARY
      : this._ptLocator.locate(t, this._g);
  }),
  (dC.prototype.extractLinework = function (t) {
    var e = new fC();
    t.apply(e);
    var i = e.getLinework(),
      n = i_.toLineStringArray(i);
    return t.getFactory().createMultiLineString(n);
  }),
  (dC.prototype.interfaces_ = function () {
    return [];
  }),
  (dC.prototype.getClass = function () {
    return dC;
  });
var fC = function () {
  (this._linework = null), (this._linework = new Yb());
};
(fC.prototype.getLinework = function () {
  return this._linework;
}),
  (fC.prototype.filter = function (t) {
    if (t instanceof kx) {
      var e = t;
      this._linework.add(e.getExteriorRing());
      for (var i = 0; i < e.getNumInteriorRing(); i++)
        this._linework.add(e.getInteriorRingN(i));
    }
  }),
  (fC.prototype.interfaces_ = function () {
    return [bx];
  }),
  (fC.prototype.getClass = function () {
    return fC;
  });
var gC = function () {
  (this._g = null), (this._doLeft = !0), (this._doRight = !0);
  var t = arguments[0];
  this._g = t;
};
(gC.prototype.extractPoints = function (t, e, i) {
  for (var n = t.getCoordinates(), r = 0; r < n.length - 1; r++)
    this.computeOffsetPoints(n[r], n[r + 1], e, i);
}),
  (gC.prototype.setSidesToGenerate = function (t, e) {
    (this._doLeft = t), (this._doRight = e);
  }),
  (gC.prototype.getPoints = function (t) {
    for (var e = new Yb(), i = cM.getLines(this._g).iterator(); i.hasNext(); ) {
      var n = i.next();
      this.extractPoints(n, t, e);
    }
    return e;
  }),
  (gC.prototype.computeOffsetPoints = function (t, e, i, n) {
    var r = e.x - t.x,
      o = e.y - t.y,
      a = Math.sqrt(r * r + o * o),
      s = (i * r) / a,
      l = (i * o) / a,
      u = (e.x + t.x) / 2,
      c = (e.y + t.y) / 2;
    if (this._doLeft) {
      var h = new qv(u - l, c + s);
      n.add(h);
    }
    if (this._doRight) {
      var p = new qv(u + l, c - s);
      n.add(p);
    }
  }),
  (gC.prototype.interfaces_ = function () {
    return [];
  }),
  (gC.prototype.getClass = function () {
    return gC;
  });
var mC = function t() {
    (this._geom = null),
      (this._locFinder = null),
      (this._location = new Array(3).fill(null)),
      (this._invalidLocation = null),
      (this._boundaryDistanceTolerance = t.TOLERANCE),
      (this._testCoords = new Yb());
    var e = arguments[0],
      i = arguments[1],
      n = arguments[2];
    (this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(
      e,
      i
    )),
      (this._geom = [e, i, n]),
      (this._locFinder = [
        new dC(this._geom[0], this._boundaryDistanceTolerance),
        new dC(this._geom[1], this._boundaryDistanceTolerance),
        new dC(this._geom[2], this._boundaryDistanceTolerance),
      ]);
  },
  yC = {
    TOLERANCE: {
      configurable: !0,
    },
  };
(mC.prototype.reportResult = function (t, e, i) {
  pb.out.println(
    "Overlay result invalid - A:" +
      Zv.toLocationSymbol(e[0]) +
      " B:" +
      Zv.toLocationSymbol(e[1]) +
      " expected:" +
      (i ? "i" : "e") +
      " actual:" +
      Zv.toLocationSymbol(e[2])
  );
}),
  (mC.prototype.isValid = function (t) {
    return (
      this.addTestPts(this._geom[0]),
      this.addTestPts(this._geom[1]),
      this.checkValid(t)
    );
  }),
  (mC.prototype.checkValid = function () {
    var t = this;
    if (1 === arguments.length) {
      for (var e = arguments[0], i = 0; i < this._testCoords.size(); i++) {
        var n = t._testCoords.get(i);
        if (!t.checkValid(e, n)) return (t._invalidLocation = n), !1;
      }
      return !0;
    }
    if (2 === arguments.length) {
      var r = arguments[0],
        o = arguments[1];
      return (
        (this._location[0] = this._locFinder[0].getLocation(o)),
        (this._location[1] = this._locFinder[1].getLocation(o)),
        (this._location[2] = this._locFinder[2].getLocation(o)),
        !!mC.hasLocation(this._location, Zv.BOUNDARY) ||
          this.isValidResult(r, this._location)
      );
    }
  }),
  (mC.prototype.addTestPts = function (t) {
    var e = new gC(t);
    this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance));
  }),
  (mC.prototype.isValidResult = function (t, e) {
    var i = pC.isResultOfOp(e[0], e[1], t),
      n = !(i ^ (e[2] === Zv.INTERIOR));
    return n || this.reportResult(t, e, i), n;
  }),
  (mC.prototype.getInvalidLocation = function () {
    return this._invalidLocation;
  }),
  (mC.prototype.interfaces_ = function () {
    return [];
  }),
  (mC.prototype.getClass = function () {
    return mC;
  }),
  (mC.hasLocation = function (t, e) {
    for (var i = 0; i < 3; i++) if (t[i] === e) return !0;
    return !1;
  }),
  (mC.computeBoundaryDistanceTolerance = function (t, e) {
    return Math.min(
      FM.computeSizeBasedSnapTolerance(t),
      FM.computeSizeBasedSnapTolerance(e)
    );
  }),
  (mC.isValid = function (t, e, i, n) {
    return new mC(t, e, n).isValid(i);
  }),
  (yC.TOLERANCE.get = function () {
    return 1e-6;
  }),
  Object.defineProperties(mC, yC);
var vC = function t(e) {
  (this._geomFactory = null),
    (this._skipEmpty = !1),
    (this._inputGeoms = null),
    (this._geomFactory = t.extractFactory(e)),
    (this._inputGeoms = e);
};
(vC.prototype.extractElements = function (t, e) {
  if (null === t) return null;
  for (var i = 0; i < t.getNumGeometries(); i++) {
    var n = t.getGeometryN(i);
    (this._skipEmpty && n.isEmpty()) || e.add(n);
  }
}),
  (vC.prototype.combine = function () {
    for (var t = new Yb(), e = this._inputGeoms.iterator(); e.hasNext(); ) {
      var i = e.next();
      this.extractElements(i, t);
    }
    return 0 === t.size()
      ? null !== this._geomFactory
        ? this._geomFactory.createGeometryCollection(null)
        : null
      : this._geomFactory.buildGeometry(t);
  }),
  (vC.prototype.interfaces_ = function () {
    return [];
  }),
  (vC.prototype.getClass = function () {
    return vC;
  }),
  (vC.combine = function () {
    return 1 === arguments.length
      ? new vC(arguments[0]).combine()
      : 2 === arguments.length
      ? new vC(vC.createList(arguments[0], arguments[1])).combine()
      : 3 === arguments.length
      ? new vC(
          vC.createList(arguments[0], arguments[1], arguments[2])
        ).combine()
      : void 0;
  }),
  (vC.extractFactory = function (t) {
    return t.isEmpty() ? null : t.iterator().next().getFactory();
  }),
  (vC.createList = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
        e = arguments[1],
        i = new Yb();
      return i.add(t), i.add(e), i;
    }
    if (3 === arguments.length) {
      var n = arguments[0],
        r = arguments[1],
        o = arguments[2],
        a = new Yb();
      return a.add(n), a.add(r), a.add(o), a;
    }
  });
var bC = function () {
    (this._inputPolys = null), (this._geomFactory = null);
    var t = arguments[0];
    (this._inputPolys = t),
      null === this._inputPolys && (this._inputPolys = new Yb());
  },
  xC = {
    STRTREE_NODE_CAPACITY: {
      configurable: !0,
    },
  };
(bC.prototype.reduceToGeometries = function (t) {
  for (var e = new Yb(), i = t.iterator(); i.hasNext(); ) {
    var n = i.next(),
      r = null;
    Kv(n, Wb) ? (r = this.unionTree(n)) : n instanceof Ib && (r = n), e.add(r);
  }
  return e;
}),
  (bC.prototype.extractByEnvelope = function (t, e, i) {
    for (var n = new Yb(), r = 0; r < e.getNumGeometries(); r++) {
      var o = e.getGeometryN(r);
      o.getEnvelopeInternal().intersects(t) ? n.add(o) : i.add(o);
    }
    return this._geomFactory.buildGeometry(n);
  }),
  (bC.prototype.unionOptimized = function (t, e) {
    var i = t.getEnvelopeInternal(),
      n = e.getEnvelopeInternal();
    if (!i.intersects(n)) return vC.combine(t, e);
    if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1)
      return this.unionActual(t, e);
    var r = i.intersection(n);
    return this.unionUsingEnvelopeIntersection(t, e, r);
  }),
  (bC.prototype.union = function () {
    if (null === this._inputPolys)
      throw new Error("union() method cannot be called twice");
    if (this._inputPolys.isEmpty()) return null;
    this._geomFactory = this._inputPolys.iterator().next().getFactory();
    for (
      var t = new q_(bC.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator();
      e.hasNext();

    ) {
      var i = e.next();
      t.insert(i.getEnvelopeInternal(), i);
    }
    this._inputPolys = null;
    var n = t.itemsTree();
    return this.unionTree(n);
  }),
  (bC.prototype.binaryUnion = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return this.binaryUnion(t, 0, t.size());
    }
    if (3 === arguments.length) {
      var e = arguments[0],
        i = arguments[1],
        n = arguments[2];
      if (n - i <= 1) {
        var r = bC.getGeometry(e, i);
        return this.unionSafe(r, null);
      }
      if (n - i == 2)
        return this.unionSafe(bC.getGeometry(e, i), bC.getGeometry(e, i + 1));
      var o = Math.trunc((n + i) / 2),
        a = this.binaryUnion(e, i, o),
        s = this.binaryUnion(e, o, n);
      return this.unionSafe(a, s);
    }
  }),
  (bC.prototype.repeatedUnion = function (t) {
    for (var e = null, i = t.iterator(); i.hasNext(); ) {
      var n = i.next();
      e = null === e ? n.copy() : e.union(n);
    }
    return e;
  }),
  (bC.prototype.unionSafe = function (t, e) {
    return null === t && null === e
      ? null
      : null === t
      ? e.copy()
      : null === e
      ? t.copy()
      : this.unionOptimized(t, e);
  }),
  (bC.prototype.unionActual = function (t, e) {
    return bC.restrictToPolygons(t.union(e));
  }),
  (bC.prototype.unionTree = function (t) {
    var e = this.reduceToGeometries(t);
    return this.binaryUnion(e);
  }),
  (bC.prototype.unionUsingEnvelopeIntersection = function (t, e, i) {
    var n = new Yb(),
      r = this.extractByEnvelope(i, t, n),
      o = this.extractByEnvelope(i, e, n),
      a = this.unionActual(r, o);
    return n.add(a), vC.combine(n);
  }),
  (bC.prototype.bufferUnion = function () {
    if (1 === arguments.length) {
      var t = arguments[0];
      return t.get(0).getFactory().buildGeometry(t).buffer(0);
    }
    if (2 === arguments.length) {
      var e = arguments[0],
        i = arguments[1];
      return e.getFactory().createGeometryCollection([e, i]).buffer(0);
    }
  }),
  (bC.prototype.interfaces_ = function () {
    return [];
  }),
  (bC.prototype.getClass = function () {
    return bC;
  }),
  (bC.restrictToPolygons = function (t) {
    if (Kv(t, zx)) return t;
    var e = uM.getPolygons(t);
    return 1 === e.size()
      ? e.get(0)
      : t.getFactory().createMultiPolygon(i_.toPolygonArray(e));
  }),
  (bC.getGeometry = function (t, e) {
    return e >= t.size() ? null : t.get(e);
  }),
  (bC.union = function (t) {
    return new bC(t).union();
  }),
  (xC.STRTREE_NODE_CAPACITY.get = function () {
    return 4;
  }),
  Object.defineProperties(bC, xC);
var _C = function () {};
function SC() {
  return new MC();
}
function MC() {
  this.reset();
}
(_C.prototype.interfaces_ = function () {
  return [];
}),
  (_C.prototype.getClass = function () {
    return _C;
  }),
  (_C.union = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty())
        return pC.createEmptyResult(pC.UNION, t, e, t.getFactory());
      if (t.isEmpty()) return e.copy();
      if (e.isEmpty()) return t.copy();
    }
    return (
      t.checkNotGeometryCollection(t),
      t.checkNotGeometryCollection(e),
      WM.overlayOp(t, e, pC.UNION)
    );
  }),
  (MC.prototype = {
    constructor: MC,
    reset: function () {
      this.s = this.t = 0;
    },
    add: function (t) {
      wC(CC, t, this.t),
        wC(this, CC.s, this.s),
        this.s ? (this.t += CC.t) : (this.s = CC.t);
    },
    valueOf: function () {
      return this.s;
    },
  });
var CC = new MC();
function wC(t, e, i) {
  var n = (t.s = e + i),
    r = n - e,
    o = n - r;
  t.t = e - o + (i - r);
}
var AC = 1e-6,
  EC = Math.PI,
  DC = EC / 2,
  TC = EC / 4,
  PC = 2 * EC,
  LC = 180 / EC,
  IC = EC / 180,
  NC = Math.abs,
  RC = Math.atan,
  OC = Math.atan2,
  FC = Math.cos,
  zC = Math.sin,
  kC = Math.sqrt;
function BC(t) {
  return t > 1 ? 0 : t < -1 ? EC : Math.acos(t);
}
function GC(t) {
  return t > 1 ? DC : t < -1 ? -DC : Math.asin(t);
}
function UC() {}
function jC(t, e) {
  t && qC.hasOwnProperty(t.type) && qC[t.type](t, e);
}
var HC,
  VC,
  WC = {
    Feature: function (t, e) {
      jC(t.geometry, e);
    },
    FeatureCollection: function (t, e) {
      for (var i = t.features, n = -1, r = i.length; ++n < r; )
        jC(i[n].geometry, e);
    },
  },
  qC = {
    Sphere: function (t, e) {
      e.sphere();
    },
    Point: function (t, e) {
      (t = t.coordinates), e.point(t[0], t[1], t[2]);
    },
    MultiPoint: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; )
        (t = i[n]), e.point(t[0], t[1], t[2]);
    },
    LineString: function (t, e) {
      YC(t.coordinates, e, 0);
    },
    MultiLineString: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; )
        YC(i[n], e, 0);
    },
    Polygon: function (t, e) {
      XC(t.coordinates, e);
    },
    MultiPolygon: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; ) XC(i[n], e);
    },
    GeometryCollection: function (t, e) {
      for (var i = t.geometries, n = -1, r = i.length; ++n < r; ) jC(i[n], e);
    },
  };
function YC(t, e, i) {
  var n,
    r = -1,
    o = t.length - i;
  for (e.lineStart(); ++r < o; ) (n = t[r]), e.point(n[0], n[1], n[2]);
  e.lineEnd();
}
function XC(t, e) {
  var i = -1,
    n = t.length;
  for (e.polygonStart(); ++i < n; ) YC(t[i], e, 1);
  e.polygonEnd();
}
function QC(t) {
  return [OC(t[1], t[0]), GC(t[2])];
}
function ZC(t) {
  var e = t[0],
    i = t[1],
    n = FC(i);
  return [n * FC(e), n * zC(e), zC(i)];
}
function JC(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function KC(t, e) {
  return [
    t[1] * e[2] - t[2] * e[1],
    t[2] * e[0] - t[0] * e[2],
    t[0] * e[1] - t[1] * e[0],
  ];
}
function $C(t, e) {
  (t[0] += e[0]), (t[1] += e[1]), (t[2] += e[2]);
}
function tw(t, e) {
  return [t[0] * e, t[1] * e, t[2] * e];
}
function ew(t) {
  var e = kC(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  (t[0] /= e), (t[1] /= e), (t[2] /= e);
}
function iw(t, e) {
  function i(i, n) {
    return (i = t(i, n)), e(i[0], i[1]);
  }
  return (
    t.invert &&
      e.invert &&
      (i.invert = function (i, n) {
        return (i = e.invert(i, n)) && t.invert(i[0], i[1]);
      }),
    i
  );
}
function nw(t, e) {
  return [t > EC ? t - PC : t < -EC ? t + PC : t, e];
}
function rw(t) {
  return function (e, i) {
    return [(e += t) > EC ? e - PC : e < -EC ? e + PC : e, i];
  };
}
function ow(t) {
  var e = rw(t);
  return (e.invert = rw(-t)), e;
}
function aw(t, e) {
  var i = FC(t),
    n = zC(t),
    r = FC(e),
    o = zC(e);
  function a(t, e) {
    var a = FC(e),
      s = FC(t) * a,
      l = zC(t) * a,
      u = zC(e),
      c = u * i + s * n;
    return [OC(l * r - c * o, s * i - u * n), GC(c * r + l * o)];
  }
  return (
    (a.invert = function (t, e) {
      var a = FC(e),
        s = FC(t) * a,
        l = zC(t) * a,
        u = zC(e),
        c = u * r - l * o;
      return [OC(l * r + u * o, s * i + c * n), GC(c * i - s * n)];
    }),
    a
  );
}
function sw(t, e) {
  ((e = ZC(e))[0] -= t), ew(e);
  var i = BC(-e[1]);
  return ((-e[2] < 0 ? -i : i) + PC - AC) % PC;
}
function lw() {
  var t,
    e = [];
  return {
    point: function (e, i) {
      t.push([e, i]);
    },
    lineStart: function () {
      e.push((t = []));
    },
    lineEnd: UC,
    rejoin: function () {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function () {
      var i = e;
      return (e = []), (t = null), i;
    },
  };
}
function uw(t, e) {
  return NC(t[0] - e[0]) < AC && NC(t[1] - e[1]) < AC;
}
function cw(t, e, i, n) {
  (this.x = t),
    (this.z = e),
    (this.o = i),
    (this.e = n),
    (this.v = !1),
    (this.n = this.p = null);
}
function hw(t, e, i, n, r) {
  var o,
    a,
    s = [],
    l = [];
  if (
    (t.forEach(function (t) {
      if (!((e = t.length - 1) <= 0)) {
        var e,
          i,
          n = t[0],
          a = t[e];
        if (uw(n, a)) {
          for (r.lineStart(), o = 0; o < e; ++o) r.point((n = t[o])[0], n[1]);
          r.lineEnd();
        } else
          s.push((i = new cw(n, t, null, !0))),
            l.push((i.o = new cw(n, null, i, !1))),
            s.push((i = new cw(a, t, null, !1))),
            l.push((i.o = new cw(a, null, i, !0)));
      }
    }),
    s.length)
  ) {
    for (l.sort(e), pw(s), pw(l), o = 0, a = l.length; o < a; ++o)
      l[o].e = i = !i;
    for (var u, c, h = s[0]; ; ) {
      for (var p = h, d = !0; p.v; ) if ((p = p.n) === h) return;
      (u = p.z), r.lineStart();
      do {
        if (((p.v = p.o.v = !0), p.e)) {
          if (d)
            for (o = 0, a = u.length; o < a; ++o) r.point((c = u[o])[0], c[1]);
          else n(p.x, p.n.x, 1, r);
          p = p.n;
        } else {
          if (d)
            for (u = p.p.z, o = u.length - 1; o >= 0; --o)
              r.point((c = u[o])[0], c[1]);
          else n(p.x, p.p.x, -1, r);
          p = p.p;
        }
        (u = (p = p.o).z), (d = !d);
      } while (!p.v);
      r.lineEnd();
    }
  }
}
function pw(t) {
  if ((e = t.length)) {
    for (var e, i, n = 0, r = t[0]; ++n < e; )
      (r.n = i = t[n]), (i.p = r), (r = i);
    (r.n = i = t[0]), (i.p = r);
  }
}
function dw(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function fw(t) {
  for (var e, i, n, r = t.length, o = -1, a = 0; ++o < r; ) a += t[o].length;
  for (i = new Array(a); --r >= 0; )
    for (e = (n = t[r]).length; --e >= 0; ) i[--a] = n[e];
  return i;
}
SC(),
  SC(),
  SC(),
  (nw.invert = nw),
  1 === (HC = dw).length &&
    ((VC = HC),
    (HC = function (t, e) {
      return dw(VC(t), e);
    }));
var gw = 1e9,
  mw = -gw;
function yw(t, e, i, n) {
  function r(r, o) {
    return t <= r && r <= i && e <= o && o <= n;
  }
  function o(r, o, s, u) {
    var c = 0,
      h = 0;
    if (null == r || (c = a(r, s)) !== (h = a(o, s)) || (l(r, o) < 0) ^ (s > 0))
      do {
        u.point(0 === c || 3 === c ? t : i, c > 1 ? n : e);
      } while ((c = (c + s + 4) % 4) !== h);
    else u.point(o[0], o[1]);
  }
  function a(n, r) {
    return NC(n[0] - t) < AC
      ? r > 0
        ? 0
        : 3
      : NC(n[0] - i) < AC
      ? r > 0
        ? 2
        : 1
      : NC(n[1] - e) < AC
      ? r > 0
        ? 1
        : 0
      : r > 0
      ? 3
      : 2;
  }
  function s(t, e) {
    return l(t.x, e.x);
  }
  function l(t, e) {
    var i = a(t, 1),
      n = a(e, 1);
    return i !== n
      ? i - n
      : 0 === i
      ? e[1] - t[1]
      : 1 === i
      ? t[0] - e[0]
      : 2 === i
      ? t[1] - e[1]
      : e[0] - t[0];
  }
  return function (a) {
    var l,
      u,
      c,
      h,
      p,
      d,
      f,
      g,
      m,
      y,
      v,
      b = a,
      x = lw(),
      _ = {
        point: S,
        lineStart: function () {
          (_.point = M), u && u.push((c = []));
          (y = !0), (m = !1), (f = g = NaN);
        },
        lineEnd: function () {
          l && (M(h, p), d && m && x.rejoin(), l.push(x.result()));
          (_.point = S), m && b.lineEnd();
        },
        polygonStart: function () {
          (b = x), (l = []), (u = []), (v = !0);
        },
        polygonEnd: function () {
          var e = (function () {
              for (var e = 0, i = 0, r = u.length; i < r; ++i)
                for (
                  var o,
                    a,
                    s = u[i],
                    l = 1,
                    c = s.length,
                    h = s[0],
                    p = h[0],
                    d = h[1];
                  l < c;
                  ++l
                )
                  (o = p),
                    (a = d),
                    (p = (h = s[l])[0]),
                    (d = h[1]),
                    a <= n
                      ? d > n && (p - o) * (n - a) > (d - a) * (t - o) && ++e
                      : d <= n && (p - o) * (n - a) < (d - a) * (t - o) && --e;
              return e;
            })(),
            i = v && e,
            r = (l = fw(l)).length;
          (i || r) &&
            (a.polygonStart(),
            i && (a.lineStart(), o(null, null, 1, a), a.lineEnd()),
            r && hw(l, s, e, o, a),
            a.polygonEnd());
          (b = a), (l = u = c = null);
        },
      };
    function S(t, e) {
      r(t, e) && b.point(t, e);
    }
    function M(o, a) {
      var s = r(o, a);
      if ((u && c.push([o, a]), y))
        (h = o),
          (p = a),
          (d = s),
          (y = !1),
          s && (b.lineStart(), b.point(o, a));
      else if (s && m) b.point(o, a);
      else {
        var l = [
            (f = Math.max(mw, Math.min(gw, f))),
            (g = Math.max(mw, Math.min(gw, g))),
          ],
          x = [
            (o = Math.max(mw, Math.min(gw, o))),
            (a = Math.max(mw, Math.min(gw, a))),
          ];
        !(function (t, e, i, n, r, o) {
          var a,
            s = t[0],
            l = t[1],
            u = 0,
            c = 1,
            h = e[0] - s,
            p = e[1] - l;
          if (((a = i - s), h || !(a > 0))) {
            if (((a /= h), h < 0)) {
              if (a < u) return;
              a < c && (c = a);
            } else if (h > 0) {
              if (a > c) return;
              a > u && (u = a);
            }
            if (((a = r - s), h || !(a < 0))) {
              if (((a /= h), h < 0)) {
                if (a > c) return;
                a > u && (u = a);
              } else if (h > 0) {
                if (a < u) return;
                a < c && (c = a);
              }
              if (((a = n - l), p || !(a > 0))) {
                if (((a /= p), p < 0)) {
                  if (a < u) return;
                  a < c && (c = a);
                } else if (p > 0) {
                  if (a > c) return;
                  a > u && (u = a);
                }
                if (((a = o - l), p || !(a < 0))) {
                  if (((a /= p), p < 0)) {
                    if (a > c) return;
                    a > u && (u = a);
                  } else if (p > 0) {
                    if (a < u) return;
                    a < c && (c = a);
                  }
                  return (
                    u > 0 && ((t[0] = s + u * h), (t[1] = l + u * p)),
                    c < 1 && ((e[0] = s + c * h), (e[1] = l + c * p)),
                    !0
                  );
                }
              }
            }
          }
        })(l, x, t, e, i, n)
          ? s && (b.lineStart(), b.point(o, a), (v = !1))
          : (m || (b.lineStart(), b.point(l[0], l[1])),
            b.point(x[0], x[1]),
            s || b.lineEnd(),
            (v = !1));
      }
      (f = o), (g = a), (m = s);
    }
    return _;
  };
}
var vw = SC();
function bw(t) {
  return t;
}
SC(), SC(), SC();
var xw = 1 / 0,
  _w = xw,
  Sw = -xw,
  Mw = Sw,
  Cw = {
    point: function (t, e) {
      t < xw && (xw = t);
      t > Sw && (Sw = t);
      e < _w && (_w = e);
      e > Mw && (Mw = e);
    },
    lineStart: UC,
    lineEnd: UC,
    polygonStart: UC,
    polygonEnd: UC,
    result: function () {
      var t = [
        [xw, _w],
        [Sw, Mw],
      ];
      return (Sw = Mw = -(_w = xw = 1 / 0)), t;
    },
  };
function ww(t, e, i, n) {
  return function (r, o) {
    var a,
      s,
      l,
      u = e(o),
      c = r.invert(n[0], n[1]),
      h = lw(),
      p = e(h),
      d = !1,
      f = {
        point: g,
        lineStart: y,
        lineEnd: v,
        polygonStart: function () {
          (f.point = b), (f.lineStart = x), (f.lineEnd = _), (s = []), (a = []);
        },
        polygonEnd: function () {
          (f.point = g), (f.lineStart = y), (f.lineEnd = v), (s = fw(s));
          var t = (function (t, e) {
            var i = e[0],
              n = e[1],
              r = [zC(i), -FC(i), 0],
              o = 0,
              a = 0;
            vw.reset();
            for (var s = 0, l = t.length; s < l; ++s)
              if ((c = (u = t[s]).length))
                for (
                  var u,
                    c,
                    h = u[c - 1],
                    p = h[0],
                    d = h[1] / 2 + TC,
                    f = zC(d),
                    g = FC(d),
                    m = 0;
                  m < c;
                  ++m, p = v, f = x, g = _, h = y
                ) {
                  var y = u[m],
                    v = y[0],
                    b = y[1] / 2 + TC,
                    x = zC(b),
                    _ = FC(b),
                    S = v - p,
                    M = S >= 0 ? 1 : -1,
                    C = M * S,
                    w = C > EC,
                    A = f * x;
                  if (
                    (vw.add(OC(A * M * zC(C), g * _ + A * FC(C))),
                    (o += w ? S + M * PC : S),
                    w ^ (p >= i) ^ (v >= i))
                  ) {
                    var E = KC(ZC(h), ZC(y));
                    ew(E);
                    var D = KC(r, E);
                    ew(D);
                    var T = (w ^ (S >= 0) ? -1 : 1) * GC(D[2]);
                    (n > T || (n === T && (E[0] || E[1]))) &&
                      (a += w ^ (S >= 0) ? 1 : -1);
                  }
                }
            return (o < -AC || (o < AC && vw < -AC)) ^ (1 & a);
          })(a, c);
          s.length
            ? (d || (o.polygonStart(), (d = !0)), hw(s, Ew, t, i, o))
            : t &&
              (d || (o.polygonStart(), (d = !0)),
              o.lineStart(),
              i(null, null, 1, o),
              o.lineEnd()),
            d && (o.polygonEnd(), (d = !1)),
            (s = a = null);
        },
        sphere: function () {
          o.polygonStart(),
            o.lineStart(),
            i(null, null, 1, o),
            o.lineEnd(),
            o.polygonEnd();
        },
      };
    function g(e, i) {
      var n = r(e, i);
      t((e = n[0]), (i = n[1])) && o.point(e, i);
    }
    function m(t, e) {
      var i = r(t, e);
      u.point(i[0], i[1]);
    }
    function y() {
      (f.point = m), u.lineStart();
    }
    function v() {
      (f.point = g), u.lineEnd();
    }
    function b(t, e) {
      l.push([t, e]);
      var i = r(t, e);
      p.point(i[0], i[1]);
    }
    function x() {
      p.lineStart(), (l = []);
    }
    function _() {
      b(l[0][0], l[0][1]), p.lineEnd();
      var t,
        e,
        i,
        n,
        r = p.clean(),
        u = h.result(),
        c = u.length;
      if ((l.pop(), a.push(l), (l = null), c))
        if (1 & r) {
          if ((e = (i = u[0]).length - 1) > 0) {
            for (
              d || (o.polygonStart(), (d = !0)), o.lineStart(), t = 0;
              t < e;
              ++t
            )
              o.point((n = i[t])[0], n[1]);
            o.lineEnd();
          }
        } else
          c > 1 && 2 & r && u.push(u.pop().concat(u.shift())),
            s.push(u.filter(Aw));
    }
    return f;
  };
}
function Aw(t) {
  return t.length > 1;
}
function Ew(t, e) {
  return (
    ((t = t.x)[0] < 0 ? t[1] - DC - AC : DC - t[1]) -
    ((e = e.x)[0] < 0 ? e[1] - DC - AC : DC - e[1])
  );
}
SC();
var Dw = ww(
  function () {
    return !0;
  },
  function (t) {
    var e,
      i = NaN,
      n = NaN,
      r = NaN;
    return {
      lineStart: function () {
        t.lineStart(), (e = 1);
      },
      point: function (o, a) {
        var s = o > 0 ? EC : -EC,
          l = NC(o - i);
        NC(l - EC) < AC
          ? (t.point(i, (n = (n + a) / 2 > 0 ? DC : -DC)),
            t.point(r, n),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, n),
            t.point(o, n),
            (e = 0))
          : r !== s &&
            l >= EC &&
            (NC(i - r) < AC && (i -= r * AC),
            NC(o - s) < AC && (o -= s * AC),
            (n = (function (t, e, i, n) {
              var r,
                o,
                a = zC(t - i);
              return NC(a) > AC
                ? RC(
                    (zC(e) * (o = FC(n)) * zC(i) -
                      zC(n) * (r = FC(e)) * zC(t)) /
                      (r * o * a)
                  )
                : (e + n) / 2;
            })(i, n, o, a)),
            t.point(r, n),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, n),
            (e = 0)),
          t.point((i = o), (n = a)),
          (r = s);
      },
      lineEnd: function () {
        t.lineEnd(), (i = n = NaN);
      },
      clean: function () {
        return 2 - e;
      },
    };
  },
  function (t, e, i, n) {
    var r;
    if (null == t)
      (r = i * DC),
        n.point(-EC, r),
        n.point(0, r),
        n.point(EC, r),
        n.point(EC, 0),
        n.point(EC, -r),
        n.point(0, -r),
        n.point(-EC, -r),
        n.point(-EC, 0),
        n.point(-EC, r);
    else if (NC(t[0] - e[0]) > AC) {
      var o = t[0] < e[0] ? EC : -EC;
      (r = (i * o) / 2), n.point(-o, r), n.point(0, r), n.point(o, r);
    } else n.point(e[0], e[1]);
  },
  [-EC, -DC]
);
function Tw(t, e) {
  var i = FC(t),
    n = i > 0,
    r = NC(i) > AC;
  function o(t, e) {
    return FC(t) * FC(e) > i;
  }
  function a(t, e, n) {
    var r = [1, 0, 0],
      o = KC(ZC(t), ZC(e)),
      a = JC(o, o),
      s = o[0],
      l = a - s * s;
    if (!l) return !n && t;
    var u = (i * a) / l,
      c = (-i * s) / l,
      h = KC(r, o),
      p = tw(r, u);
    $C(p, tw(o, c));
    var d = h,
      f = JC(p, d),
      g = JC(d, d),
      m = f * f - g * (JC(p, p) - 1);
    if (!(m < 0)) {
      var y = kC(m),
        v = tw(d, (-f - y) / g);
      if (($C(v, p), (v = QC(v)), !n)) return v;
      var b,
        x = t[0],
        _ = e[0],
        S = t[1],
        M = e[1];
      _ < x && ((b = x), (x = _), (_ = b));
      var C = _ - x,
        w = NC(C - EC) < AC;
      if (
        (!w && M < S && ((b = S), (S = M), (M = b)),
        w || C < AC
          ? w
            ? (S + M > 0) ^ (v[1] < (NC(v[0] - x) < AC ? S : M))
            : S <= v[1] && v[1] <= M
          : (C > EC) ^ (x <= v[0] && v[0] <= _))
      ) {
        var A = tw(d, (-f + y) / g);
        return $C(A, p), [v, QC(A)];
      }
    }
  }
  function s(e, i) {
    var r = n ? t : EC - t,
      o = 0;
    return (
      e < -r ? (o |= 1) : e > r && (o |= 2),
      i < -r ? (o |= 4) : i > r && (o |= 8),
      o
    );
  }
  return ww(
    o,
    function (t) {
      var e, i, l, u, c;
      return {
        lineStart: function () {
          (u = l = !1), (c = 1);
        },
        point: function (h, p) {
          var d,
            f = [h, p],
            g = o(h, p),
            m = n ? (g ? 0 : s(h, p)) : g ? s(h + (h < 0 ? EC : -EC), p) : 0;
          if (
            (!e && (u = l = g) && t.lineStart(),
            g !== l &&
              (!(d = a(e, f)) || uw(e, d) || uw(f, d)) &&
              ((f[0] += AC), (f[1] += AC), (g = o(f[0], f[1]))),
            g !== l)
          )
            (c = 0),
              g
                ? (t.lineStart(), (d = a(f, e)), t.point(d[0], d[1]))
                : ((d = a(e, f)), t.point(d[0], d[1]), t.lineEnd()),
              (e = d);
          else if (r && e && n ^ g) {
            var y;
            m & i ||
              !(y = a(f, e, !0)) ||
              ((c = 0),
              n
                ? (t.lineStart(),
                  t.point(y[0][0], y[0][1]),
                  t.point(y[1][0], y[1][1]),
                  t.lineEnd())
                : (t.point(y[1][0], y[1][1]),
                  t.lineEnd(),
                  t.lineStart(),
                  t.point(y[0][0], y[0][1])));
          }
          !g || (e && uw(e, f)) || t.point(f[0], f[1]),
            (e = f),
            (l = g),
            (i = m);
        },
        lineEnd: function () {
          l && t.lineEnd(), (e = null);
        },
        clean: function () {
          return c | ((u && l) << 1);
        },
      };
    },
    function (i, n, r, o) {
      !(function (t, e, i, n, r, o) {
        if (i) {
          var a = FC(e),
            s = zC(e),
            l = n * i;
          null == r
            ? ((r = e + n * PC), (o = e - l / 2))
            : ((r = sw(a, r)),
              (o = sw(a, o)),
              (n > 0 ? r < o : r > o) && (r += n * PC));
          for (var u, c = r; n > 0 ? c > o : c < o; c -= l)
            (u = QC([a, -s * FC(c), -s * zC(c)])), t.point(u[0], u[1]);
        }
      })(o, t, e, r, i, n);
    },
    n ? [0, -t] : [-EC, t - EC]
  );
}
function Pw(t) {
  return function (e) {
    var i = new Lw();
    for (var n in t) i[n] = t[n];
    return (i.stream = e), i;
  };
}
function Lw() {}
function Iw(t, e, i) {
  var n = e[1][0] - e[0][0],
    r = e[1][1] - e[0][1],
    o = t.clipExtent && t.clipExtent();
  t.scale(150).translate([0, 0]),
    null != o && t.clipExtent(null),
    (function (t, e) {
      t && WC.hasOwnProperty(t.type) ? WC[t.type](t, e) : jC(t, e);
    })(i, t.stream(Cw));
  var a = Cw.result(),
    s = Math.min(n / (a[1][0] - a[0][0]), r / (a[1][1] - a[0][1])),
    l = +e[0][0] + (n - s * (a[1][0] + a[0][0])) / 2,
    u = +e[0][1] + (r - s * (a[1][1] + a[0][1])) / 2;
  return null != o && t.clipExtent(o), t.scale(150 * s).translate([l, u]);
}
Lw.prototype = {
  constructor: Lw,
  point: function (t, e) {
    this.stream.point(t, e);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  },
};
var Nw = 16,
  Rw = FC(30 * IC);
function Ow(t, e) {
  return +e
    ? (function (t, e) {
        function i(n, r, o, a, s, l, u, c, h, p, d, f, g, m) {
          var y = u - n,
            v = c - r,
            b = y * y + v * v;
          if (b > 4 * e && g--) {
            var x = a + p,
              _ = s + d,
              S = l + f,
              M = kC(x * x + _ * _ + S * S),
              C = GC((S /= M)),
              w = NC(NC(S) - 1) < AC || NC(o - h) < AC ? (o + h) / 2 : OC(_, x),
              A = t(w, C),
              E = A[0],
              D = A[1],
              T = E - n,
              P = D - r,
              L = v * T - y * P;
            ((L * L) / b > e ||
              NC((y * T + v * P) / b - 0.5) > 0.3 ||
              a * p + s * d + l * f < Rw) &&
              (i(n, r, o, a, s, l, E, D, w, (x /= M), (_ /= M), S, g, m),
              m.point(E, D),
              i(E, D, w, x, _, S, u, c, h, p, d, f, g, m));
          }
        }
        return function (e) {
          var n,
            r,
            o,
            a,
            s,
            l,
            u,
            c,
            h,
            p,
            d,
            f,
            g = {
              point: m,
              lineStart: y,
              lineEnd: b,
              polygonStart: function () {
                e.polygonStart(), (g.lineStart = x);
              },
              polygonEnd: function () {
                e.polygonEnd(), (g.lineStart = y);
              },
            };
          function m(i, n) {
            (i = t(i, n)), e.point(i[0], i[1]);
          }
          function y() {
            (c = NaN), (g.point = v), e.lineStart();
          }
          function v(n, r) {
            var o = ZC([n, r]),
              a = t(n, r);
            i(
              c,
              h,
              u,
              p,
              d,
              f,
              (c = a[0]),
              (h = a[1]),
              (u = n),
              (p = o[0]),
              (d = o[1]),
              (f = o[2]),
              Nw,
              e
            ),
              e.point(c, h);
          }
          function b() {
            (g.point = m), e.lineEnd();
          }
          function x() {
            y(), (g.point = _), (g.lineEnd = S);
          }
          function _(t, e) {
            v((n = t), e),
              (r = c),
              (o = h),
              (a = p),
              (s = d),
              (l = f),
              (g.point = v);
          }
          function S() {
            i(c, h, u, p, d, f, r, o, n, a, s, l, Nw, e), (g.lineEnd = b), b();
          }
          return g;
        };
      })(t, e)
    : (function (t) {
        return Pw({
          point: function (e, i) {
            (e = t(e, i)), this.stream.point(e[0], e[1]);
          },
        });
      })(t);
}
var Fw = Pw({
  point: function (t, e) {
    this.stream.point(t * IC, e * IC);
  },
});
function zw(t) {
  return (function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h = 150,
      p = 480,
      d = 250,
      f = 0,
      g = 0,
      m = 0,
      y = 0,
      v = 0,
      b = null,
      x = Dw,
      _ = null,
      S = bw,
      M = 0.5,
      C = Ow(E, M);
    function w(t) {
      return [(t = o(t[0] * IC, t[1] * IC))[0] * h + i, n - t[1] * h];
    }
    function A(t) {
      return (
        (t = o.invert((t[0] - i) / h, (n - t[1]) / h)) && [t[0] * LC, t[1] * LC]
      );
    }
    function E(t, r) {
      return [(t = e(t, r))[0] * h + i, n - t[1] * h];
    }
    function D() {
      o = iw(
        (r = (function (t, e, i) {
          return (t %= PC)
            ? e || i
              ? iw(ow(t), aw(e, i))
              : ow(t)
            : e || i
            ? aw(e, i)
            : nw;
        })(m, y, v)),
        e
      );
      var t = e(f, g);
      return (i = p - t[0] * h), (n = d + t[1] * h), T();
    }
    function T() {
      return (u = c = null), w;
    }
    return (
      (w.stream = function (t) {
        return u && c === t ? u : (u = Fw(x(r, C(S((c = t))))));
      }),
      (w.clipAngle = function (t) {
        return arguments.length
          ? ((x = +t ? Tw((b = t * IC), 6 * IC) : ((b = null), Dw)), T())
          : b * LC;
      }),
      (w.clipExtent = function (t) {
        return arguments.length
          ? ((S =
              null == t
                ? ((_ = a = s = l = null), bw)
                : yw(
                    (_ = +t[0][0]),
                    (a = +t[0][1]),
                    (s = +t[1][0]),
                    (l = +t[1][1])
                  )),
            T())
          : null == _
          ? null
          : [
              [_, a],
              [s, l],
            ];
      }),
      (w.scale = function (t) {
        return arguments.length ? ((h = +t), D()) : h;
      }),
      (w.translate = function (t) {
        return arguments.length ? ((p = +t[0]), (d = +t[1]), D()) : [p, d];
      }),
      (w.center = function (t) {
        return arguments.length
          ? ((f = (t[0] % 360) * IC), (g = (t[1] % 360) * IC), D())
          : [f * LC, g * LC];
      }),
      (w.rotate = function (t) {
        return arguments.length
          ? ((m = (t[0] % 360) * IC),
            (y = (t[1] % 360) * IC),
            (v = t.length > 2 ? (t[2] % 360) * IC : 0),
            D())
          : [m * LC, y * LC, v * LC];
      }),
      (w.precision = function (t) {
        return arguments.length ? ((C = Ow(E, (M = t * t))), T()) : kC(M);
      }),
      (w.fitExtent = function (t, e) {
        return Iw(w, t, e);
      }),
      (w.fitSize = function (t, e) {
        return (function (t, e, i) {
          return Iw(t, [[0, 0], e], i);
        })(w, t, e);
      }),
      function () {
        return (e = t.apply(this, arguments)), (w.invert = e.invert && A), D();
      }
    );
  })(function () {
    return t;
  })();
}
var kw,
  Bw,
  Gw =
    ((kw = function (t) {
      return (t = BC(t)) && t / zC(t);
    }),
    function (t, e) {
      var i = FC(t),
        n = FC(e),
        r = kw(i * n);
      return [r * n * zC(t), r * zC(e)];
    });
function Uw(t, e, i, n) {
  var r = t.properties || {},
    o = "Feature" === t.type ? t.geometry : t;
  if ("GeometryCollection" === o.type) {
    var a = [];
    return (
      wm(t, function (t) {
        var r = Uw(t, e, i, n);
        r && a.push(r);
      }),
      gm(a)
    );
  }
  var s = (function (t) {
      var e = zm(t).geometry.coordinates,
        i = [-e[0], -e[1]];
      return zw(Gw).scale(79.4188).clipAngle(179.999).rotate(i).scale(um);
    })(o),
    l = {
      type: o.type,
      coordinates: Hw(o.coordinates, s),
    },
    u = new l_().read(l),
    c = vm(bm(e, i), "meters"),
    h = eM.bufferOp(u, c, n);
  if (!jw((h = new u_().write(h)).coordinates))
    return hm(
      {
        type: h.type,
        coordinates: Vw(h.coordinates, s),
      },
      r
    );
}
function jw(t) {
  return Array.isArray(t[0]) ? jw(t[0]) : isNaN(t[0]);
}
function Hw(t, e) {
  return "object" != typeof t[0]
    ? e(t)
    : t.map(function (t) {
        return Hw(t, e);
      });
}
function Vw(t, e) {
  return "object" != typeof t[0]
    ? e.invert(t)
    : t.map(function (t) {
        return Vw(t, e);
      });
}
Gw.invert =
  ((Bw = function (t) {
    return t;
  }),
  function (t, e) {
    var i = kC(t * t + e * e),
      n = Bw(i),
      r = zC(n),
      o = FC(n);
    return [OC(t * r, i * o), GC(i && (e * r) / i)];
  });
const Ww = {
    bbox: Em,
    bboxClip: function (t, e) {
      var i = Pm(t),
        n = i.type,
        r = "Feature" === t.type ? t.properties : {},
        o = i.coordinates;
      switch (n) {
        case "LineString":
        case "MultiLineString":
          var a = [];
          return (
            "LineString" === n && (o = [o]),
            o.forEach(function (t) {
              !(function (t, e, i) {
                var n,
                  r,
                  o,
                  a,
                  s,
                  l = t.length,
                  u = Hy(t[0], e),
                  c = [];
                for (i || (i = []), n = 1; n < l; n++) {
                  for (a = t[n - 1], r = o = Hy((s = t[n]), e); ; ) {
                    if (!(u | r)) {
                      c.push(a),
                        r !== o
                          ? (c.push(s), n < l - 1 && (i.push(c), (c = [])))
                          : n === l - 1 && c.push(s);
                      break;
                    }
                    if (u & r) break;
                    u
                      ? (u = Hy((a = jy(a, s, u, e)), e))
                      : (r = Hy((s = jy(a, s, r, e)), e));
                  }
                  u = o;
                }
                c.length && i.push(c);
              })(t, e, a);
            }),
            1 === a.length ? fm(a[0], r) : mm(a, r)
          );
        case "Polygon":
          return dm(Vy(o, e), r);
        case "MultiPolygon":
          return ym(
            o.map(function (t) {
              return Vy(t, e);
            }),
            r
          );
        default:
          throw new Error("geometry " + n + " not supported");
      }
    },
    buffer: function (t, e, i) {
      var n = (i = i || {}).units || "kilometers",
        r = i.steps || 8;
      if (!t) throw new Error("geojson is required");
      if ("object" != typeof i) throw new Error("options must be an object");
      if ("number" != typeof r) throw new Error("steps must be an number");
      if (void 0 === e) throw new Error("radius is required");
      if (r <= 0) throw new Error("steps must be greater than 0");
      var o = [];
      switch (t.type) {
        case "GeometryCollection":
          return (
            wm(t, function (t) {
              var i = Uw(t, e, n, r);
              i && o.push(i);
            }),
            gm(o)
          );
        case "FeatureCollection":
          return (
            Cm(t, function (t) {
              var i = Uw(t, e, n, r);
              i &&
                Cm(i, function (t) {
                  t && o.push(t);
                });
            }),
            gm(o)
          );
      }
      return Uw(t, e, n, r);
    },
    difference: function (t, e) {
      var i = Pm(t),
        n = Pm(e),
        r = t.properties || {},
        o = zv.difference(i.coordinates, n.coordinates);
      return 0 === o.length ? null : 1 === o.length ? dm(o[0], r) : ym(o, r);
    },
    distance: Rm,
    intersect: function (t, e, i) {
      void 0 === i && (i = {});
      var n = Pm(t),
        r = Pm(e),
        o = zv.intersection(n.coordinates, r.coordinates);
      return 0 === o.length
        ? null
        : 1 === o.length
        ? dm(o[0], i.properties)
        : ym(o, i.properties);
    },
    pointsWithinPolygon: function (t, e) {
      var i = [];
      return (
        Cm(t, function (t) {
          var n,
            r,
            o = !1;
          if ("Point" === t.geometry.type)
            wm(e, function (e) {
              Im(t, e) && (o = !0);
            }),
              o && i.push(t);
          else {
            if ("MultiPoint" !== t.geometry.type)
              throw new Error("Input geometry must be a Point or MultiPoint");
            var a = [];
            wm(e, function (e) {
              Mm(t, function (t) {
                Im(t, e) && ((o = !0), a.push(t));
              });
            }),
              o &&
                i.push(
                  (void 0 === r && (r = {}),
                  hm(
                    {
                      type: "MultiPoint",
                      coordinates: a,
                    },
                    n,
                    r
                  ))
                );
          }
        }),
        gm(i)
      );
    },
    points: function (t, e, i) {
      return (
        void 0 === i && (i = {}),
        gm(
          t.map(function (t) {
            return pm(t, e);
          }),
          i
        )
      );
    },
    center: zm,
  },
  qw = {
    FlyLine: (t, e) => ({
      from: t[e.fromField],
      to: t[e.toField],
    }),
    Point: (t, e) => ({
      lng: t[e.lngField],
      lat: t[e.latField],
    }),
    Polygon: (t, e) => ({
      coordinates: t[e.coordinatesField],
    }),
    Line: (t, e) => ({
      coordinates: t[e.coordinatesField],
    }),
  },
  Yw = (t) => "FeatureCollection" === t.type || "Feature" === t.type,
  Xw = (t, e, i) => {
    i.type = "bytejson";
    const n = [],
      { layerType: r, coordsField: o } = e;
    return (
      t.forEach((t) => {
        let e = r;
        const i = qw[r](t, o);
        let a = [];
        if (
          ("FlyLine" === e && ((e = "FlyLine"), (a = [i.from, i.to])),
          t.lng && ((e = "Point"), (a = [i.lng, i.lat])),
          "Line" === e)
        ) {
          const t = "Line" === e ? "LineString" : "Polygon";
          (e = Array.isArray(i.coordinates[0][0]) ? `Multi${t}` : t),
            (a = i.coordinates);
        }
        const s = at(t, ["coordinates"]),
          l = ot(rt(rt({}, s), i), {
            geometry: {
              type: e,
              coordinates: a,
            },
          });
        n.push(l);
      }),
      n
    );
  };
var Qw, Zw;
((Zw = Qw || (Qw = {})).contain = "contain"),
  (Zw.intersect = "intersect"),
  (Zw.intersectClip = "intersectClip"),
  (Zw.none = "none");
const Jw = (t, e) => {
    const i = (function (t) {
        if (!t) throw new Error("geojson is required");
        var e = [];
        return (
          Am(t, function (t) {
            e.push(t);
          }),
          gm(e)
        );
      })(t),
      n = [];
    i.features.forEach((t) => {
      Cm(
        (function (t, e) {
          if (!t) throw new Error("line is required");
          if (!e) throw new Error("splitter is required");
          var i = Lm(t),
            n = Lm(e);
          if ("LineString" !== i) throw new Error("line must be LineString");
          if ("FeatureCollection" === n)
            throw new Error("splitter cannot be a FeatureCollection");
          if ("GeometryCollection" === n)
            throw new Error("splitter cannot be a GeometryCollection");
          var r = Ry(e, {
            precision: 7,
          });
          switch (n) {
            case "Point":
              return Fy(t, r);
            case "MultiPoint":
              return Oy(t, r);
            case "LineString":
            case "MultiLineString":
            case "Polygon":
            case "MultiPolygon":
              return Oy(t, Ay(t, r));
          }
        })(t, e),
        (t) => {
          Py(t, e) && n.push(t);
        }
      );
    });
    const r = ((o = gm(n)),
    (a = {
      MultiPoint: {
        coordinates: [],
        properties: [],
      },
      MultiLineString: {
        coordinates: [],
        properties: [],
      },
      MultiPolygon: {
        coordinates: [],
        properties: [],
      },
    }),
    Cm(o, function (t) {
      var e, i, n, r;
      switch (null === (r = t.geometry) || void 0 === r ? void 0 : r.type) {
        case "Point":
          a.MultiPoint.coordinates.push(t.geometry.coordinates),
            a.MultiPoint.properties.push(t.properties);
          break;
        case "MultiPoint":
          (e = a.MultiPoint.coordinates).push.apply(e, t.geometry.coordinates),
            a.MultiPoint.properties.push(t.properties);
          break;
        case "LineString":
          a.MultiLineString.coordinates.push(t.geometry.coordinates),
            a.MultiLineString.properties.push(t.properties);
          break;
        case "MultiLineString":
          (i = a.MultiLineString.coordinates).push.apply(
            i,
            t.geometry.coordinates
          ),
            a.MultiLineString.properties.push(t.properties);
          break;
        case "Polygon":
          a.MultiPolygon.coordinates.push(t.geometry.coordinates),
            a.MultiPolygon.properties.push(t.properties);
          break;
        case "MultiPolygon":
          (n = a.MultiPolygon.coordinates).push.apply(
            n,
            t.geometry.coordinates
          ),
            a.MultiPolygon.properties.push(t.properties);
      }
    }),
    gm(
      Object.keys(a)
        .filter(function (t) {
          return a[t].coordinates.length;
        })
        .sort()
        .map(function (t) {
          return hm(
            {
              type: t,
              coordinates: a[t].coordinates,
            },
            {
              collectedProperties: a[t].properties,
            }
          );
        })
    )).features[0];
    var o, a;
    return (
      r || {
        geometry: {
          coordinates: [],
        },
      }
    );
  },
  Kw = (t, e, i, n) => {
    if (!i || i === Qw.none) return !0;
    let r = t.geometry ? t : pm([t.lng, t.lat]);
    if (
      ((r = rt(
        {
          type: "Feature",
          properties: {},
        },
        r
      )),
      "Point" === r.geometry.type)
    )
      return i !== Qw.intersect || Im(r, e);
    if ("FlyLine" === n || "Line" === n)
      return (
        i !== Qw.intersect || r.geometry.coordinates.some((t) => Im(pm(t), e))
      );
    const o = r.geometry.type.startsWith("Multi")
      ? r.geometry.coordinates.every((t) =>
          Py(
            {
              type: "Feature",
              properties: {},
              geometry: {
                type: r.geometry.type.replace("Multi", ""),
                coordinates: t,
              },
            },
            e
          )
        )
      : Py(r, e);
    return o
      ? o && r
      : i === Qw.intersect
      ? ((a = e),
        (s = !1),
        Am(r, function (t) {
          Am(a, function (e) {
            if (!0 === s) return !0;
            s = !Wy(t.geometry, e.geometry);
          });
        }),
        s && r)
      : i === Qw.intersectClip
      ? Jw(r, e)
      : void 0;
    var a, s;
  },
  $w = Math.PI / 180,
  tA = 180 / Math.PI;
function eA(t) {
  return t * $w;
}
function iA(t) {
  return t * tA;
}
class nA {
  constructor(t = 0, e = 0, i = 0) {
    (this.x = t), (this.y = e), (this.z = i);
  }
  set(t, e, i) {
    return (
      void 0 === i && (i = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = i),
      this
    );
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
  }
}
function rA(t) {
  return t;
}
function oA(t, e) {
  return (
    (t = eA(t)),
    (e = eA(e)),
    [Math.sin(t) * Math.sin(e), -1 * Math.sin(t) * Math.cos(e), Math.cos(t)]
  );
}
function aA(t, e) {
  return (
    (t = eA(t)),
    (e = eA(e)),
    [-1 * Math.cos(t) * Math.sin(e), Math.cos(t) * Math.cos(e), Math.sin(t)]
  );
}
class sA {
  constructor(t) {
    (this._getEffectState = t), (this.transform = this.transform.bind(this));
  }
}
const lA = (t, e) => {
    const {
        center: i,
        zoom: n,
        pitch: r,
        rotation: o,
        enablePan: a,
        enableZoom: s,
        enableRotate: l,
        enablePitch: u,
        lock: c,
        zoomSpeed: h,
        rotateSpeed: p,
        panSpeed: d,
        maxPitch: f,
        minPitch: g,
        maxRotation: m,
        minRotation: y,
      } = t,
      v = (function (t, e = 0) {
        return Xf(t.zoom, e);
      })(t, e),
      b = new nA(),
      x = new nA(),
      _ = new nA(),
      S = Qf(i);
    return (
      (b.x = S[0]),
      (b.y = S[1]),
      x.fromArray(oA(r, o)).multiplyScalar(v).add(b),
      _.fromArray(aA(r, o)),
      {
        target: b.toArray(),
        position: x.toArray(),
        up: _.toArray(),
        fov: Kf(n),
        near: v / 10,
        far: 10 * v,
        enablePan: a,
        enableZoom: s,
        enableRotate: l,
        enablePitch: u,
        lock: c,
        zoomSpeed: h,
        rotateSpeed: p,
        panSpeed: d,
        maxPitch: f,
        minPitch: g,
        maxRotation: m,
        minRotation: y,
      }
    );
  },
  uA = (t, e) => {
    const {
        enablePan: i,
        enableZoom: n,
        enableRotate: r,
        enablePitch: o,
        lock: a,
        zoomSpeed: s,
        rotateSpeed: l,
        panSpeed: u,
        maxPitch: c,
        minPitch: h,
        maxRotation: p,
        minRotation: d,
      } = t,
      f = new nA().fromArray(t.position),
      g = new nA().fromArray(t.up),
      m = new nA().fromArray(t.target),
      y = new nA(0, 0, 0);
    y.copy(f).sub(m);
    const v = y.length(),
      b = Zf([m.x, m.y]),
      x = Nf(qf(v, e), 2),
      _ = iA(Math.acos(y.z / v));
    return {
      center: b,
      zoom: x,
      rotation: iA(0 !== _ ? -1 * Math.atan(y.x / y.y) : -1 * Math.asin(g.x)),
      pitch: _,
      enablePan: i,
      enableZoom: n,
      enableRotate: r,
      enablePitch: o,
      lock: a,
      zoomSpeed: s,
      rotateSpeed: l,
      panSpeed: u,
      maxPitch: c,
      minPitch: h,
      maxRotation: p,
      minRotation: d,
    };
  };
class cA extends sA {
  transform(t) {
    const { canvasHeight: e } = this._getEffectState();
    return uA(t, e);
  }
}
class hA extends sA {
  transform(t) {
    const { canvasHeight: e } = this._getEffectState();
    return lA(t, e);
  }
}
class pA extends sA {
  transform(t) {
    const e = this._getEffectState(),
      { centerProj: i, bboxSize: n, canvasHeight: r } = e;
    return (function (t, e, i) {
      const {
          enablePan: n,
          enableZoom: r,
          enableRotate: o,
          enablePitch: a,
          lock: s,
          zoomSpeed: l,
          rotateSpeed: u,
          panSpeed: c,
          maxPitch: h,
          minPitch: p,
          maxRotation: d,
          minRotation: f,
        } = t,
        g = new nA(0, 0, 0),
        m = new nA().fromArray(t.position),
        y = new nA().fromArray(t.target),
        v = new nA().fromArray(t.up);
      g.copy(m).sub(y);
      const b = g.length(),
        x = iA(Math.acos(g.z / b)),
        _ = iA(0 !== x ? -1 * Math.atan(g.x / g.y) : -1 * Math.asin(v.x));
      return {
        offset: [(y.x - e[0]) / i, (y.y - e[1]) / i, b / i],
        pitch: x,
        rotation: _,
        enablePan: n,
        enableZoom: r,
        enableRotate: o,
        enablePitch: a,
        lock: s,
        zoomSpeed: l,
        rotateSpeed: u,
        panSpeed: c,
        maxPitch: h,
        minPitch: p,
        maxRotation: d,
        minRotation: f,
      };
    })(lA(t, r), i, n);
  }
}
class dA extends sA {
  transform(t) {
    const {
        centerProj: e,
        bboxSize: i,
        canvasHeight: n,
      } = this._getEffectState(),
      r = (function (t, e, i) {
        const {
            offset: n,
            pitch: r,
            rotation: o,
            enablePan: a,
            enableZoom: s,
            enableRotate: l,
            enablePitch: u,
            lock: c,
            zoomSpeed: h,
            rotateSpeed: p,
            panSpeed: d,
            maxPitch: f,
            minPitch: g,
            maxRotation: m,
            minRotation: y,
          } = t,
          v = n[2] * i,
          b = new nA(),
          x = new nA(),
          _ = new nA(),
          S = [e[0] + n[0] * i, e[1] + n[1] * i, 0];
        return (
          (b.x = S[0]),
          (b.y = S[1]),
          x.fromArray(oA(r, o)).multiplyScalar(v).add(b),
          _.fromArray(aA(r, o)),
          {
            target: b.toArray(),
            position: x.toArray(),
            up: _.toArray(),
            fov: 45,
            near: v / 5,
            far: 5 * v,
            enablePan: a,
            enableZoom: s,
            enableRotate: l,
            enablePitch: u,
            lock: c,
            zoomSpeed: h,
            rotateSpeed: p,
            panSpeed: d,
            maxPitch: f,
            minPitch: g,
            maxRotation: m,
            minRotation: y,
          }
        );
      })(t, e, i);
    return uA(r, n);
  }
}
class fA {
  constructor(t) {
    (this._count = 0),
      (this._callback = {}),
      (this._afterFuncArr = []),
      (this.sourceState = t);
  }
  subscribe(t) {
    const e = this._uuid();
    return (
      (this._callback[e] = t),
      () => {
        delete this._callback[e];
      }
    );
  }
  setSourceState(t) {
    let e = Object.assign(this.sourceState, t);
    this._afterFuncArr.forEach((t) => {
      e = t(e);
    }),
      (this.sourceState = e),
      this._triggle();
  }
  getSourceState() {
    return this.sourceState;
  }
  after(t) {
    this._afterFuncArr.push(t);
  }
  _triggle() {
    Object.values(this._callback).forEach((t) => {
      t(this.sourceState);
    });
  }
  _uuid() {
    return this._count++;
  }
}
class gA {
  constructor(t) {
    (this._getFuncMap = {}),
      (this._setFuncMap = {}),
      (this._cache = {}),
      (this._listeners = {}),
      (this._count = 0),
      (this.reactiveState = new fA(t)),
      this.reactiveState.subscribe(() => {
        this._updateCache(), this._checkSubject();
      });
  }
  registerGetAndSet(t, e, i) {
    this.registerGet(t, e), this.registerSet(t, i);
  }
  registerGet(t, e) {
    (this._getFuncMap[t] = e), this._updateCache();
  }
  registerSet(t, e) {
    this._setFuncMap[t] = e;
  }
  get(t) {
    return this._cache[t];
  }
  set(t, e) {
    const i = this._setFuncMap[t],
      n = this._cache[t];
    i && this.reactiveState.setSourceState(i(Object.assign(n, e)));
  }
  getSourceState() {
    return this.reactiveState.getSourceState();
  }
  subscribe(t, e) {
    const i = this._uuid();
    return (
      (this._listeners[i] = {
        name: t,
        func: e,
      }),
      () => {
        delete this._listeners[i];
      }
    );
  }
  unsubscribe(t, e) {
    Object.keys(this._listeners).forEach((i) => {
      const { name: n, func: r } = this._listeners[i];
      n === t && r === e && delete this._listeners[i];
    });
  }
  _checkSubject() {
    Object.keys(this._listeners).forEach((t) => {
      const { name: e, func: i } = this._listeners[t];
      i(this.get(e));
    });
  }
  _uuid() {
    return this._count++;
  }
  _updateCache() {
    Object.keys(this._getFuncMap).forEach((t) => {
      this._cache[t] = this._getFuncMap[t](this.reactiveState.getSourceState());
    });
  }
  unsubjectAll() {
    this._listeners = {};
  }
}
class mA {
  constructor(t) {
    this.getOptions = t;
  }
  dolly(t, e) {
    const { zoom: i, enableZoom: n, zoomSpeed: r, lock: o } = e;
    return !o && n && ((t *= r), (e.zoom = Nf(i + t, 2))), e;
  }
  rotate(t, e, i) {
    const {
      pitch: n,
      rotation: r,
      enablePitch: o,
      enableRotate: a,
      rotateSpeed: s,
      lock: l,
    } = i;
    if (l) return i;
    const u = this.getOptions().canvasHeight;
    let c = o ? iA((-2 * Math.PI * e) / u) : 0,
      h = a ? iA((-2 * Math.PI * t) / u) : 0;
    return (c *= s), (h *= s), (i.pitch = n + c), (i.rotation = r + h), i;
  }
  pan(t, e, i, n) {
    const {
      center: r,
      pitch: o,
      enablePan: a,
      panSpeed: s,
      lock: l,
      rotation: u,
    } = i;
    if (l || !a) return i;
    const c = Qf(r);
    (e = o >= -90 && o <= 90 ? e : -1 * e), (t *= s), (e *= s);
    const h = Zf([
      c[0] - (t * Math.cos(eA(u)) + e * Math.sin(eA(u))) * n,
      c[1] - (t * Math.sin(eA(u)) - e * Math.cos(eA(u))) * n,
    ]);
    return (i.center = h), i;
  }
}
for (let p7 = 0; p7 < 256; p7++) p7.toString(16);
function yA(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
function vA(t, e, i) {
  return (1 - i) * t + i * e;
}
const bA = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  xA = {
    h: 0,
    s: 0,
    l: 0,
  },
  _A = {
    h: 0,
    s: 0,
    l: 0,
  };
function SA(t, e, i) {
  return (
    i < 0 && (i += 1),
    i > 1 && (i -= 1),
    i < 1 / 6
      ? t + 6 * (e - t) * i
      : i < 0.5
      ? e
      : i < 2 / 3
      ? t + 6 * (e - t) * (2 / 3 - i)
      : t
  );
}
function MA(t) {
  return t < 0.04045
    ? 0.0773993808 * t
    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
}
function CA(t) {
  return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
class wA {
  constructor(t, e, i) {
    return (
      (this.NAMES = bA),
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    );
  }
  set(t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : "number" == typeof t
        ? this.setHex(t)
        : "string" == typeof t && this.setStyle(t),
      this
    );
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (255 & t) / 255),
      this
    );
  }
  setRGB(t, e, i) {
    return (this.r = t), (this.g = e), (this.b = i), this;
  }
  setHSL(t, e, i) {
    var n;
    if (
      ((t = ((t % (n = 1)) + n) % n),
      (e = yA(e, 0, 1)),
      (i = yA(i, 0, 1)),
      0 === e)
    )
      this.r = this.g = this.b = i;
    else {
      const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
        r = 2 * i - n;
      (this.r = SA(r, n, t + 1 / 3)),
        (this.g = SA(r, n, t)),
        (this.b = SA(r, n, t - 1 / 3));
    }
    return this;
  }
  setStyle(t) {
    let e;
    if ((e = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
      let t;
      const i = e[1],
        n = e[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (
            (t =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
              t[4],
              this
            );
          if (
            (t =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
              t[4],
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (t =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          ) {
            const e = parseFloat(t[1]) / 360,
              i = parseInt(t[2], 10) / 100,
              n = parseInt(t[3], 10) / 100;
            return t[4], this.setHSL(e, i, n);
          }
      }
    } else if ((e = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const t = e[1],
        i = t.length;
      if (3 === i)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
          (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
          (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
          this
        );
      if (6 === i)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
          (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
          (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
          this
        );
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  }
  setColorName(t) {
    const e = bA[t.toLowerCase()];
    return void 0 !== e && this.setHex(e), this;
  }
  clone() {
    return new wA(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copyGammaToLinear(t, e = 2) {
    return (
      (this.r = Math.pow(t.r, e)),
      (this.g = Math.pow(t.g, e)),
      (this.b = Math.pow(t.b, e)),
      this
    );
  }
  copyLinearToGamma(t, e = 2) {
    const i = e > 0 ? 1 / e : 1;
    return (
      (this.r = Math.pow(t.r, i)),
      (this.g = Math.pow(t.g, i)),
      (this.b = Math.pow(t.b, i)),
      this
    );
  }
  convertGammaToLinear(t) {
    return this.copyGammaToLinear(this, t), this;
  }
  convertLinearToGamma(t) {
    return this.copyLinearToGamma(this, t), this;
  }
  copySRGBToLinear(t) {
    return (this.r = MA(t.r)), (this.g = MA(t.g)), (this.b = MA(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = CA(t.r)), (this.g = CA(t.g)), (this.b = CA(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ (255 * this.b);
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(t) {
    const e = this.r,
      i = this.g,
      n = this.b,
      r = Math.max(e, i, n),
      o = Math.min(e, i, n);
    let a, s;
    const l = (o + r) / 2;
    if (o === r) (a = 0), (s = 0);
    else {
      const t = r - o;
      switch (((s = l <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
        case e:
          a = (i - n) / t + (i < n ? 6 : 0);
          break;
        case i:
          a = (n - e) / t + 2;
          break;
        case n:
          a = (e - i) / t + 4;
      }
      a /= 6;
    }
    return (t.h = a), (t.s = s), (t.l = l), t;
  }
  getStyle() {
    return (
      "rgb(" +
      ((255 * this.r) | 0) +
      "," +
      ((255 * this.g) | 0) +
      "," +
      ((255 * this.b) | 0) +
      ")"
    );
  }
  offsetHSL(t, e, i) {
    return (
      this.getHSL(xA),
      (xA.h += t),
      (xA.s += e),
      (xA.l += i),
      this.setHSL(xA.h, xA.s, xA.l),
      this
    );
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpColors(t, e, i) {
    return (
      (this.r = t.r + (e.r - t.r) * i),
      (this.g = t.g + (e.g - t.g) * i),
      (this.b = t.b + (e.b - t.b) * i),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL(xA), t.getHSL(_A);
    const i = vA(xA.h, _A.h, e),
      n = vA(xA.s, _A.s, e),
      r = vA(xA.l, _A.l, e);
    return this.setHSL(i, n, r), this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      !0 === t.normalized &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
const AA = new Map();
function EA(t) {
  var e;
  const i = AA.get(t);
  if (i) return pd(i);
  {
    let i;
    /^(rgba|RGBA)/.test(t) &&
      (i = (function (t) {
        const e = t.replace(/(?:\(|\)|rgba|RGBA)*/g, "").split(",");
        return {
          r: Number(e[0]),
          g: Number(e[1]),
          b: Number(e[2]),
          a: Number(e[3]),
        };
      })(t));
    const n = {
      color: new wA(t),
      transparent: !(!i || 1 === i.a),
      opacity: null != (e = null == i ? void 0 : i.a) ? e : 1,
    };
    return AA.set(t, n), n;
  }
}
function DA(t, e) {
  return t.transparent ? t.opacity : e;
}
function TA(t, e) {
  const i = -t,
    n = [-1, 1];
  return i + ((e - n[0]) / (n[1] - n[0])) * (t - i);
}
class PA {
  static area(t) {
    const e = t.length;
    let i = 0;
    for (let n = e - 1, r = 0; r < e; n = r++)
      i += t[n].x * t[r].y - t[r].x * t[n].y;
    return 0.5 * i;
  }
  static isClockWise(t) {
    return PA.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const i = [],
      n = [],
      r = [];
    LA(t), IA(i, t);
    let o = t.length;
    e.forEach(LA);
    for (let s = 0; s < e.length; s++)
      n.push(o), (o += e[s].length), IA(i, e[s]);
    const a = _l.default(i, n);
    for (let s = 0; s < a.length; s += 3) r.push(a.slice(s, s + 3));
    return r;
  }
}
function LA(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function IA(t, e) {
  for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
}
class NA extends En {
  constructor(
    t = new qs([new Le(0, 0.5), new Le(-0.5, -0.5), new Le(0.5, -0.5)]),
    e = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = {
        shapes: t,
        curveSegments: e,
      });
    const i = [],
      n = [],
      r = [],
      o = [];
    let a = 0,
      s = 0;
    if (!1 === Array.isArray(t)) l(t);
    else
      for (let u = 0; u < t.length; u++)
        l(t[u]), this.addGroup(a, s, u), (a += s), (s = 0);
    function l(t) {
      const a = n.length / 3,
        l = t.extractPoints(e);
      let u = l.shape;
      const c = l.holes;
      !1 === PA.isClockWise(u) && (u = u.reverse());
      for (let e = 0, i = c.length; e < i; e++) {
        const t = c[e];
        !0 === PA.isClockWise(t) && (c[e] = t.reverse());
      }
      const h = PA.triangulateShape(u, c);
      for (let e = 0, i = c.length; e < i; e++) {
        const t = c[e];
        u = u.concat(t);
      }
      for (let e = 0, i = u.length; e < i; e++) {
        const t = u[e];
        n.push(t.x, t.y, 0), r.push(0, 0, 1), o.push(t.x, t.y);
      }
      for (let e = 0, n = h.length; e < n; e++) {
        const t = h[e],
          n = t[0] + a,
          r = t[1] + a,
          o = t[2] + a;
        i.push(n, r, o), (s += 3);
      }
    }
    this.setIndex(i),
      this.setAttribute("position", new bn(n, 3)),
      this.setAttribute("normal", new bn(r, 3)),
      this.setAttribute("uv", new bn(o, 2));
  }
  toJSON() {
    const t = super.toJSON();
    return (function (t, e) {
      if (((e.shapes = []), Array.isArray(t)))
        for (let i = 0, n = t.length; i < n; i++) {
          const n = t[i];
          e.shapes.push(n.uuid);
        }
      else e.shapes.push(t.uuid);
      return e;
    })(this.parameters.shapes, t);
  }
  static fromJSON(t, e) {
    const i = [];
    for (let n = 0, r = t.shapes.length; n < r; n++) {
      const r = e[t.shapes[n]];
      i.push(r);
    }
    return new NA(i, t.curveSegments);
  }
}
class RA extends En {
  constructor(t = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = {
        geometry: t,
      }),
      null !== t)
    ) {
      const e = [],
        i = new Set(),
        n = new Ye(),
        r = new Ye();
      if (null !== t.index) {
        const o = t.attributes.position,
          a = t.index;
        let s = t.groups;
        0 === s.length &&
          (s = [
            {
              start: 0,
              count: a.count,
              materialIndex: 0,
            },
          ]);
        for (let t = 0, l = s.length; t < l; ++t) {
          const l = s[t],
            u = l.start;
          for (let t = u, s = u + l.count; t < s; t += 3)
            for (let l = 0; l < 3; l++) {
              const s = a.getX(t + l),
                u = a.getX(t + ((l + 1) % 3));
              n.fromBufferAttribute(o, s),
                r.fromBufferAttribute(o, u),
                !0 === OA(n, r, i) &&
                  (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z));
            }
        }
      } else {
        const o = t.attributes.position;
        for (let t = 0, a = o.count / 3; t < a; t++)
          for (let s = 0; s < 3; s++) {
            const a = 3 * t + s,
              l = 3 * t + ((s + 1) % 3);
            n.fromBufferAttribute(o, a),
              r.fromBufferAttribute(o, l),
              !0 === OA(n, r, i) &&
                (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new bn(e, 3));
    }
  }
}
function OA(t, e, i) {
  const n = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
  return !0 !== i.has(n) && !0 !== i.has(r) && (i.add(n, r), !0);
}
class FA extends hn {
  constructor(t) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new ln(0)),
      (this.transparent = !0),
      this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this;
  }
}
class zA extends hn {
  constructor(t) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = {
        STANDARD: "",
      }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new ln(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ln(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new Le(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = {
        STANDARD: "",
      }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.envMapIntensity = t.envMapIntensity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
const kA = {
  arraySlice: (t, e, i) =>
    kA.isTypedArray(t)
      ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length))
      : t.slice(e, i),
  convertArray: (t, e, i) =>
    !t || (!i && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t),
  isTypedArray: (t) => ArrayBuffer.isView(t) && !(t instanceof DataView),
  getKeyframeOrder(t) {
    const e = t.length,
      i = new Array(e);
    for (let n = 0; n !== e; ++n) i[n] = n;
    return (
      i.sort(function (e, i) {
        return t[e] - t[i];
      }),
      i
    );
  },
  sortedArray(t, e, i) {
    const n = t.length,
      r = new t.constructor(n);
    for (let o = 0, a = 0; a !== n; ++o) {
      const n = i[o] * e;
      for (let i = 0; i !== e; ++i) r[a++] = t[n + i];
    }
    return r;
  },
  flattenJSON(t, e, i, n) {
    let r = 1,
      o = t[0];
    for (; void 0 !== o && void 0 === o[n]; ) o = t[r++];
    if (void 0 === o) return;
    let a = o[n];
    if (void 0 !== a)
      if (Array.isArray(a))
        do {
          (a = o[n]),
            void 0 !== a && (e.push(o.time), i.push.apply(i, a)),
            (o = t[r++]);
        } while (void 0 !== o);
      else if (void 0 !== a.toArray)
        do {
          (a = o[n]),
            void 0 !== a && (e.push(o.time), a.toArray(i, i.length)),
            (o = t[r++]);
        } while (void 0 !== o);
      else
        do {
          (a = o[n]), void 0 !== a && (e.push(o.time), i.push(a)), (o = t[r++]);
        } while (void 0 !== o);
  },
  subclip(t, e, i, n, r = 30) {
    const o = t.clone();
    o.name = e;
    const a = [];
    for (let l = 0; l < o.tracks.length; ++l) {
      const t = o.tracks[l],
        e = t.getValueSize(),
        s = [],
        u = [];
      for (let o = 0; o < t.times.length; ++o) {
        const a = t.times[o] * r;
        if (!(a < i || a >= n)) {
          s.push(t.times[o]);
          for (let i = 0; i < e; ++i) u.push(t.values[o * e + i]);
        }
      }
      0 !== s.length &&
        ((t.times = kA.convertArray(s, t.times.constructor)),
        (t.values = kA.convertArray(u, t.values.constructor)),
        a.push(t));
    }
    o.tracks = a;
    let s = 1 / 0;
    for (let l = 0; l < o.tracks.length; ++l)
      s > o.tracks[l].times[0] && (s = o.tracks[l].times[0]);
    for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * s);
    return o.resetDuration(), o;
  },
  makeClipAdditive(t, e = 0, i = t, n = 30) {
    n <= 0 && (n = 30);
    const r = i.tracks.length,
      o = e / n;
    for (let a = 0; a < r; ++a) {
      const e = i.tracks[a],
        n = e.ValueTypeName;
      if ("bool" === n || "string" === n) continue;
      const r = t.tracks.find(function (t) {
        return t.name === e.name && t.ValueTypeName === n;
      });
      if (void 0 === r) continue;
      let s = 0;
      const l = e.getValueSize();
      e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (s = l / 3);
      let u = 0;
      const c = r.getValueSize();
      r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (u = c / 3);
      const h = e.times.length - 1;
      let p;
      if (o <= e.times[0]) {
        const t = s,
          i = l - s;
        p = kA.arraySlice(e.values, t, i);
      } else if (o >= e.times[h]) {
        const t = h * l + s,
          i = t + l - s;
        p = kA.arraySlice(e.values, t, i);
      } else {
        const t = e.createInterpolant(),
          i = s,
          n = l - s;
        t.evaluate(o), (p = kA.arraySlice(t.resultBuffer, i, n));
      }
      if ("quaternion" === n) {
        new We().fromArray(p).normalize().conjugate().toArray(p);
      }
      const d = r.times.length;
      for (let t = 0; t < d; ++t) {
        const e = t * c + u;
        if ("quaternion" === n)
          We.multiplyQuaternionsFlat(r.values, e, p, 0, r.values, e);
        else {
          const t = c - 2 * u;
          for (let i = 0; i < t; ++i) r.values[e + i] -= p[i];
        }
      }
    }
    return (t.blendMode = 2501), t;
  },
};
class BA {
  constructor(t, e, i, n) {
    (this.beforeStart_ = this.copySampleValue_),
      (this.afterEnd_ = this.copySampleValue_),
      (this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
      (this.sampleValues = e),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(t) {
    const e = this.parameterPositions;
    let i = this._cachedIndex,
      n = e[i],
      r = e[i - 1];
    t: {
      e: {
        let o;
        i: {
          n: if (!(t < n)) {
            for (let o = i + 2; ; ) {
              if (void 0 === n) {
                if (t < r) break n;
                return (
                  (i = e.length),
                  (this._cachedIndex = i),
                  this.afterEnd_(i - 1, t, r)
                );
              }
              if (i === o) break;
              if (((r = n), (n = e[++i]), t < n)) break e;
            }
            o = e.length;
            break i;
          }
          if (t >= r) break t;
          {
            const a = e[1];
            t < a && ((i = 2), (r = a));
            for (let o = i - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
              if (i === o) break;
              if (((n = r), (r = e[--i - 1]), t >= r)) break e;
            }
            (o = i), (i = 0);
          }
        }
        for (; i < o; ) {
          const n = (i + o) >>> 1;
          t < e[n] ? (o = n) : (i = n + 1);
        }
        if (((n = e[i]), (r = e[i - 1]), void 0 === r))
          return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
        if (void 0 === n)
          return (
            (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, r, t)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, t, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t, e, i) {
    const n = this.resultBuffer,
      r = this.sampleValues,
      o = this.valueSize,
      a = t * o;
    for (let s = 0; s !== o; ++s) n[s] = r[a + s];
    return n;
  }
  interpolate_(t, e, i, n) {
    throw new Error("call to abstract method");
  }
  intervalChanged_(t, e, i) {}
}
class GA extends BA {
  constructor(t, e, i, n) {
    super(t, e, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: ae,
        endingEnd: ae,
      });
  }
  intervalChanged_(t, e, i) {
    const n = this.parameterPositions;
    let r = t - 2,
      o = t + 1,
      a = n[r],
      s = n[o];
    if (void 0 === a)
      switch (this.getSettings_().endingStart) {
        case se:
          (r = t), (a = 2 * e - i);
          break;
        case le:
          (r = n.length - 2), (a = e + n[r] - n[r + 1]);
          break;
        default:
          (r = t), (a = i);
      }
    if (void 0 === s)
      switch (this.getSettings_().endingEnd) {
        case se:
          (o = t), (s = 2 * i - e);
          break;
        case le:
          (o = 1), (s = i + n[1] - n[0]);
          break;
        default:
          (o = t - 1), (s = e);
      }
    const l = 0.5 * (i - e),
      u = this.valueSize;
    (this._weightPrev = l / (e - a)),
      (this._weightNext = l / (s - i)),
      (this._offsetPrev = r * u),
      (this._offsetNext = o * u);
  }
  interpolate_(t, e, i, n) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      s = t * a,
      l = s - a,
      u = this._offsetPrev,
      c = this._offsetNext,
      h = this._weightPrev,
      p = this._weightNext,
      d = (i - e) / (n - e),
      f = d * d,
      g = f * d,
      m = -h * g + 2 * h * f - h * d,
      y = (1 + h) * g + (-1.5 - 2 * h) * f + (-0.5 + h) * d + 1,
      v = (-1 - p) * g + (1.5 + p) * f + 0.5 * d,
      b = p * g - p * f;
    for (let x = 0; x !== a; ++x)
      r[x] = m * o[u + x] + y * o[l + x] + v * o[s + x] + b * o[c + x];
    return r;
  }
}
class UA extends BA {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
  interpolate_(t, e, i, n) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      s = t * a,
      l = s - a,
      u = (i - e) / (n - e),
      c = 1 - u;
    for (let h = 0; h !== a; ++h) r[h] = o[l + h] * c + o[s + h] * u;
    return r;
  }
}
class jA extends BA {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1);
  }
}
class HA {
  constructor(t, e, i, n) {
    if (
      ((this.TimeBufferType = Float32Array),
      (this.ValueBufferType = Float32Array),
      (this.DefaultInterpolation = re),
      void 0 === t)
    )
      throw new Error("@dp/gis-engine: KeyframeTrack: track name is undefined");
    if (void 0 === e || 0 === e.length)
      throw new Error(
        "@dp/gis-engine: KeyframeTrack: no keyframes in track named " + t
      );
    (this.name = t),
      (this.times = kA.convertArray(e, this.TimeBufferType)),
      (this.values = kA.convertArray(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }
  static toJSON(t) {
    const e = t.constructor;
    let i;
    if (e.toJSON !== this.toJSON) i = e.toJSON(t);
    else {
      i = {
        name: t.name,
        times: kA.convertArray(t.times, Array),
        values: kA.convertArray(t.values, Array),
      };
      const e = t.getInterpolation();
      e !== t.DefaultInterpolation && (i.interpolation = e);
    }
    return (i.type = t.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new jA(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodLinear(t) {
    return new UA(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodSmooth(t) {
    return new GA(this.times, this.values, this.getValueSize(), t);
  }
  setInterpolation(t) {
    let e;
    switch (t) {
      case ne:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case re:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case oe:
        e = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === e) {
      const e =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (void 0 === this.createInterpolant) {
        if (t === this.DefaultInterpolation) throw new Error(e);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return this;
    }
    return (this.createInterpolant = e), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ne;
      case this.InterpolantFactoryMethodLinear:
        return re;
      case this.InterpolantFactoryMethodSmooth:
        return oe;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t) {
    if (0 !== t) {
      const e = this.times;
      for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
    }
    return this;
  }
  scale(t) {
    if (1 !== t) {
      const e = this.times;
      for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
    }
    return this;
  }
  trim(t, e) {
    const i = this.times,
      n = i.length;
    let r = 0,
      o = n - 1;
    for (; r !== n && i[r] < t; ) ++r;
    for (; -1 !== o && i[o] > e; ) --o;
    if ((++o, 0 !== r || o !== n)) {
      r >= o && ((o = Math.max(o, 1)), (r = o - 1));
      const t = this.getValueSize();
      (this.times = kA.arraySlice(i, r, o)),
        (this.values = kA.arraySlice(this.values, r * t, o * t));
    }
    return this;
  }
  validate() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) != 0 &&
      (console.error(
        "@dp/gis-engine: KeyframeTrack: Invalid value size in track.",
        this
      ),
      (t = !1));
    const i = this.times,
      n = this.values,
      r = i.length;
    0 === r &&
      (console.error("@dp/gis-engine: KeyframeTrack: Track is empty.", this),
      (t = !1));
    let o = null;
    for (let a = 0; a !== r; a++) {
      const e = i[a];
      if ("number" == typeof e && isNaN(e)) {
        console.error(
          "@dp/gis-engine: KeyframeTrack: Time is not a valid number.",
          this,
          a,
          e
        ),
          (t = !1);
        break;
      }
      if (null !== o && o > e) {
        console.error(
          "@dp/gis-engine: KeyframeTrack: Out of order keys.",
          this,
          a,
          e,
          o
        ),
          (t = !1);
        break;
      }
      o = e;
    }
    if (void 0 !== n && kA.isTypedArray(n))
      for (let a = 0, s = n.length; a !== s; ++a) {
        const e = n[a];
        if (isNaN(e)) {
          console.error(
            "@dp/gis-engine: KeyframeTrack: Value is not a valid number.",
            this,
            a,
            e
          ),
            (t = !1);
          break;
        }
      }
    return t;
  }
  optimize() {
    const t = kA.arraySlice(this.times),
      e = kA.arraySlice(this.values),
      i = this.getValueSize(),
      n = this.getInterpolation() === oe,
      r = t.length - 1;
    let o = 1;
    for (let a = 1; a < r; ++a) {
      let r = !1;
      const s = t[a];
      if (s !== t[a + 1] && (1 !== a || s !== t[0]))
        if (n) r = !0;
        else {
          const t = a * i,
            n = t - i,
            o = t + i;
          for (let a = 0; a !== i; ++a) {
            const i = e[t + a];
            if (i !== e[n + a] || i !== e[o + a]) {
              r = !0;
              break;
            }
          }
        }
      if (r) {
        if (a !== o) {
          t[o] = t[a];
          const n = a * i,
            r = o * i;
          for (let t = 0; t !== i; ++t) e[r + t] = e[n + t];
        }
        ++o;
      }
    }
    if (r > 0) {
      t[o] = t[r];
      for (let t = r * i, n = o * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
      ++o;
    }
    return (
      o !== t.length
        ? ((this.times = kA.arraySlice(t, 0, o)),
          (this.values = kA.arraySlice(e, 0, o * i)))
        : ((this.times = t), (this.values = e)),
      this
    );
  }
  clone() {
    const t = kA.arraySlice(this.times, 0),
      e = kA.arraySlice(this.values, 0),
      i = new (0, this.constructor)(this.name, t, e);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
class VA extends HA {
  constructor(t, e, i) {
    super(t, e, i, ne),
      (this.ValueTypeName = "bool"),
      (this.ValueBufferType = Float32Array),
      (this.DefaultInterpolation = ne);
  }
}
class WA extends HA {
  constructor() {
    super(...arguments), (this.ValueTypeName = "color");
  }
}
class qA extends HA {
  constructor(t, e, i, n) {
    super(t, e, i, n), (this.ValueTypeName = "number");
  }
}
class YA extends BA {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
  interpolate_(t, e, i, n) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      s = (i - e) / (n - e);
    let l = t * a;
    for (let u = l + a; l !== u; l += 4) We.slerpFlat(r, 0, o, l - a, o, l, s);
    return r;
  }
}
class XA extends HA {
  constructor() {
    super(...arguments),
      (this.ValueTypeName = "quaternion"),
      (this.DefaultInterpolation = re);
  }
  InterpolantFactoryMethodLinear(t) {
    return new YA(this.times, this.values, this.getValueSize(), t);
  }
}
class QA extends HA {
  constructor() {
    super(...arguments),
      (this.ValueTypeName = "string"),
      (this.ValueBufferType = Array),
      (this.DefaultInterpolation = ne);
  }
}
class ZA extends HA {
  constructor(t, e, i, n) {
    super(t, e, i, n), (this.ValueTypeName = "vector");
  }
}
class JA {
  constructor(t, e = -1, i, n = 2500) {
    (this.name = t),
      (this.tracks = i),
      (this.duration = e),
      (this.blendMode = n),
      (this.uuid = we()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(t) {
    const e = [],
      i = t.tracks,
      n = 1 / (t.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) e.push(KA(i[o]).scale(n));
    const r = new this(t.name, t.duration, e, t.blendMode);
    return (r.uuid = t.uuid), r;
  }
  static toJSON(t) {
    const e = [],
      i = t.tracks,
      n = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode,
      };
    for (let r = 0, o = i.length; r !== o; ++r) e.push(HA.toJSON(i[r]));
    return n;
  }
  static CreateFromMorphTargetSequence(t, e, i, n) {
    const r = e.length,
      o = [];
    for (let a = 0; a < r; a++) {
      let t = [],
        s = [];
      t.push((a + r - 1) % r, a, (a + 1) % r), s.push(0, 1, 0);
      const l = kA.getKeyframeOrder(t);
      (t = kA.sortedArray(t, 1, l)),
        (s = kA.sortedArray(s, 1, l)),
        n || 0 !== t[0] || (t.push(r), s.push(s[0])),
        o.push(
          new qA(".morphTargetInfluences[" + e[a].name + "]", t, s).scale(1 / i)
        );
    }
    return new this(t, -1, o);
  }
  static findByName(t, e) {
    let i = t;
    if (!Array.isArray(t)) {
      const e = t;
      i = (e.geometry && e.geometry.animations) || e.animations;
    }
    for (let n = 0; n < i.length; n++) if (i[n].name === e) return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t, e, i) {
    const n = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, s = t.length; a < s; a++) {
      const e = t[a],
        i = e.name.match(r);
      if (i && i.length > 1) {
        const t = i[1];
        let r = n[t];
        r || (n[t] = r = []), r.push(e);
      }
    }
    const o = [];
    for (const a in n)
      o.push(this.CreateFromMorphTargetSequence(a, n[a], e, i));
    return o;
  }
  static parseAnimation(t, e) {
    if (!t)
      return (
        console.error(
          "@dp/gis-engine: AnimationClip: No animation in JSONLoader data."
        ),
        null
      );
    const i = function (t, e, i, n, r) {
        if (0 !== i.length) {
          const o = [],
            a = [];
          kA.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a));
        }
      },
      n = [],
      r = t.name || "default",
      o = t.fps || 30,
      a = t.blendMode;
    let s = t.length || -1;
    const l = t.hierarchy || [];
    for (let u = 0; u < l.length; u++) {
      const t = l[u].keys;
      if (t && 0 !== t.length)
        if (t[0].morphTargets) {
          const e = [];
          let i;
          for (i = 0; i < t.length; i++)
            if (t[i].morphTargets)
              for (let n = 0; n < t[i].morphTargets.length; n++)
                e[t[i].morphTargets[n]] = -1;
          for (const r in e) {
            const e = [],
              o = [];
            for (let n = 0; n !== t[i].morphTargets.length; ++n) {
              const n = t[i];
              e.push(n.time), o.push(n.morphTarget === r ? 1 : 0);
            }
            n.push(new qA(".morphTargetInfluence[" + r + "]", e, o));
          }
          s = e.length * (o || 1);
        } else {
          const r = ".bones[" + e[u].name + "]";
          i(ZA, r + ".position", t, "pos", n),
            i(XA, r + ".quaternion", t, "rot", n),
            i(ZA, r + ".scale", t, "scl", n);
        }
    }
    if (0 === n.length) return null;
    return new this(r, s, n, a);
  }
  resetDuration() {
    let t = 0;
    for (let e = 0, i = this.tracks.length; e !== i; ++e) {
      const i = this.tracks[e];
      t = Math.max(t, i.times[i.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  }
  validate() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
    return this;
  }
  clone() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
    return new JA(this.name, this.duration, t, this.blendMode);
  }
  toJSON() {
    return JA.toJSON(this);
  }
}
function KA(t) {
  if (void 0 === t.type)
    throw new Error(
      "@dp/gis-engine: KeyframeTrack: track type undefined, can not parse"
    );
  const e = (function (t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return qA;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ZA;
      case "color":
        return WA;
      case "quaternion":
        return XA;
      case "bool":
      case "boolean":
        return VA;
      case "string":
        return QA;
    }
    throw new Error(
      "@dp/gis-engine: KeyframeTrack: Unsupported typeName: " + t
    );
  })(t.type);
  if (void 0 === t.times) {
    const e = [],
      i = [];
    kA.flattenJSON(t.keys, e, i, "value"), (t.times = e), (t.values = i);
  }
  return void 0 !== e.parse
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
const $A = {
  enabled: !1,
  files: {},
  add(t, e) {
    !1 !== this.enabled && (this.files[t] = e);
  },
  get(t) {
    if (!1 !== this.enabled) return this.files[t];
  },
  remove(t) {
    delete this.files[t];
  },
  clear() {
    this.files = {};
  },
};
const tE = new (class {
  constructor(t, e, i) {
    (this.isLoading = !1),
      (this.itemsLoaded = 0),
      (this.itemsTotal = 0),
      (this.handlers = []),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = i);
  }
  itemStart(t) {
    this.itemsTotal++,
      !1 === this.isLoading &&
        void 0 !== this.onStart &&
        this.onStart(t, this.itemsLoaded, this.itemsTotal),
      (this.isLoading = !0);
  }
  itemEnd(t) {
    this.itemsLoaded++,
      void 0 !== this.onProgress &&
        this.onProgress(t, this.itemsLoaded, this.itemsTotal),
      this.itemsLoaded === this.itemsTotal &&
        ((this.isLoading = !1), void 0 !== this.onLoad && this.onLoad());
  }
  itemError(t) {
    void 0 !== this.onError && this.onError(t);
  }
  resolveURL(t) {
    return this.urlModifier ? this.urlModifier(t) : t;
  }
  setURLModifier(t) {
    return (this.urlModifier = t), this;
  }
  addHandler(t, e) {
    return this.handlers.push(t, e), this;
  }
  removeHandler(t) {
    const e = this.handlers.indexOf(t);
    return -1 !== e && this.handlers.splice(e, 2), this;
  }
  getHandler(t) {
    for (let e = 0, i = this.handlers.length; e < i; e += 2) {
      const i = this.handlers[e],
        n = this.handlers[e + 1];
      if ((i.global && (i.lastIndex = 0), i.test(t))) return n;
    }
    return null;
  }
})();
class eE {
  constructor(t) {
    (this.manager = void 0 !== t ? t : tE),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load(t, e, i, n) {}
  loadAsync(t, e) {
    return new Promise((i, n) => {
      this.load(t, i, e, n);
    });
  }
  parse(t, e) {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this;
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this;
  }
  setPath(t) {
    return (this.path = t), this;
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this;
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this;
  }
}
const iE = {};
class nE extends eE {
  constructor(t) {
    super(t);
  }
  load(t, e, i, n) {
    if (t instanceof HTMLImageElement) return t;
    if (t instanceof File)
      return this.createImage(URL.createObjectURL(t), e, n);
    {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const i = $A.get(t);
      return void 0 !== i
        ? (this.manager.itemStart(t),
          setTimeout(function () {
            e && e(i), this.manager.itemEnd(t);
          }, 0),
          i)
        : this.createImage(t, e, n);
    }
  }
  createImage(t, e, i) {
    const n = Re("img"),
      r = () => {
        a(), $A.add(t, n), e && e(n), this.manager.itemEnd(t);
      },
      o = (e) => {
        a(), i && i(e), this.manager.itemError(t), this.manager.itemEnd(t);
      },
      a = () => {
        n.removeEventListener("load", r, !1),
          n.removeEventListener("error", o, !1);
      };
    return (
      n.addEventListener("load", r, !1),
      n.addEventListener("error", o, !1),
      "data:" !== t.substr(0, 5) &&
        void 0 !== this.crossOrigin &&
        (n.crossOrigin = this.crossOrigin),
      this.manager.itemStart(t),
      (n.src = t),
      n
    );
  }
}
class rE extends eE {
  constructor(t) {
    super(t);
  }
  load(t, e, i, n) {
    const r = new Ge(),
      o = new nE(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      (this.image = o.load(
        t,
        (t) => {
          (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
        },
        i,
        n
      )),
      r
    );
  }
  abort() {
    this.image &&
      "function" == typeof this.image.hasAttribute &&
      (this.image.src = "");
  }
}
class oE extends Hi {
  constructor(t, e = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new ln(t)),
      (this.intensity = e);
  }
  dispose() {}
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      void 0 !== this.groundColor &&
        (e.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (e.object.distance = this.distance),
      void 0 !== this.angle && (e.object.angle = this.angle),
      void 0 !== this.decay && (e.object.decay = this.decay),
      void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
      e
    );
  }
}
const aE = new Mi(),
  sE = new Ye(),
  lE = new Ye();
class uE {
  constructor(t) {
    (this.camera = t),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Le(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Mi()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new hr()),
      (this._frameExtents = new Le(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new je(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera,
      i = this.matrix;
    sE.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(sE),
      lE.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(lE),
      e.updateMatrixWorld(),
      aE.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(aE),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(e.projectionMatrix),
      i.multiply(e.matrixWorldInverse);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return (
      0 !== this.bias && (t.bias = this.bias),
      0 !== this.normalBias && (t.normalBias = this.normalBias),
      1 !== this.radius && (t.radius = this.radius),
      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    );
  }
}
class cE extends uE {
  constructor() {
    super(new Mr(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class hE extends oE {
  constructor(t, e = 1) {
    super(t, e),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Hi.DefaultUp),
      this.updateMatrix(),
      (this.target = new Hi()),
      (this.shadow = new cE());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
class pE extends oE {
  constructor(t, e) {
    super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class dE extends En {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    );
  }
}
class fE {
  constructor(t = !0) {
    (this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = gE()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = gE();
      (t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t);
    }
    return t;
  }
}
function gE() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
class mE {
  constructor(t, e, i = null, n = e.blendMode) {
    (this._mixer = t),
      (this._clip = e),
      (this._localRoot = i),
      (this.blendMode = n);
    const r = e.tracks,
      o = r.length,
      a = new Array(o),
      s = {
        endingStart: ae,
        endingEnd: ae,
      };
    for (let l = 0; l !== o; ++l) {
      const t = r[l].createInterpolant(null);
      (a[l] = t), (t.settings = s);
    }
    (this._interpolantSettings = s),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      0 !== this.timeScale &&
      null === this._startTime &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t) {
    return (this._startTime = t), this;
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this;
  }
  setEffectiveWeight(t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1);
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0);
  }
  crossFadeFrom(t, e, i) {
    if ((t.fadeOut(e), this.fadeIn(e), i)) {
      const i = this._clip.duration,
        n = t._clip.duration,
        r = n / i,
        o = i / n;
      t.warp(1, r, e), this.warp(o, 1, e);
    }
    return this;
  }
  crossFadeTo(t, e, i) {
    return t.crossFadeFrom(this, e, i);
  }
  stopFading() {
    const t = this._weightInterpolant;
    return (
      null !== t &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping();
  }
  syncWith(t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    );
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  }
  warp(t, e, i) {
    const n = this._mixer,
      r = n.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    null === a &&
      ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const s = a.parameterPositions,
      l = a.sampleValues;
    return (s[0] = r), (s[1] = r + i), (l[0] = t / o), (l[1] = e / o), this;
  }
  stopWarping() {
    const t = this._timeScaleInterpolant;
    return (
      null !== t &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t, e, i, n) {
    if (!this.enabled) return void this._updateWeight(t);
    const r = this._startTime;
    if (null !== r) {
      const n = (t - r) * i;
      if (n < 0 || 0 === i) return;
      (this._startTime = null), (e = i * n);
    }
    e *= this._updateTimeScale(t);
    const o = this._updateTime(e),
      a = this._updateWeight(t);
    if (a > 0) {
      const t = this._interpolants,
        e = this._propertyBindings;
      if (2501 === this.blendMode)
        for (let i = 0, n = t.length; i !== n; ++i)
          t[i].evaluate(o), e[i].accumulateAdditive(a);
      else
        for (let i = 0, r = t.length; i !== r; ++i)
          t[i].evaluate(o), e[i].accumulate(n, a);
    }
  }
  _updateWeight(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const i = this._weightInterpolant;
      if (null !== i) {
        const n = i.evaluate(t)[0];
        (e *= n),
          t > i.parameterPositions[1] &&
            (this.stopFading(), 0 === n && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = e), e;
  }
  _updateTimeScale(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (null !== i) {
        (e *= i.evaluate(t)[0]),
          t > i.parameterPositions[1] &&
            (this.stopWarping(),
            0 === e ? (this.paused = !0) : (this.timeScale = e));
      }
    }
    return (this._effectiveTimeScale = e), e;
  }
  _updateTime(t) {
    const e = this._clip.duration,
      i = this.loop;
    let n = this.time + t,
      r = this._loopCount;
    const o = 2202 === i;
    if (0 === t) return -1 === r || !o || 1 & ~r ? n : e - n;
    if (2200 === i) {
      -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      t: {
        if (n >= e) n = e;
        else {
          if (!(n < 0)) {
            this.time = n;
            break t;
          }
          n = 0;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = n),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (-1 === r &&
          (t >= 0
            ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
            : this._setEndings(0 === this.repetitions, !0, o)),
        n >= e || n < 0)
      ) {
        const i = Math.floor(n / e);
        (n -= e * i), (r += Math.abs(i));
        const a = this.repetitions - r;
        if (a <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (n = t > 0 ? e : 0),
            (this.time = n),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1,
            });
        else {
          if (1 === a) {
            const e = t < 0;
            this._setEndings(e, !e, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = r),
            (this.time = n),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: i,
            });
        }
      } else this.time = n;
      if (o && !(1 & ~r)) return e - n;
    }
    return n;
  }
  _setEndings(t, e, i) {
    const n = this._interpolantSettings;
    i
      ? ((n.endingStart = se), (n.endingEnd = se))
      : ((n.endingStart = t ? (this.zeroSlopeAtStart ? se : ae) : le),
        (n.endingEnd = e ? (this.zeroSlopeAtEnd ? se : ae) : le));
  }
  _scheduleFading(t, e, i) {
    const n = this._mixer,
      r = n.time;
    let o = this._weightInterpolant;
    null === o &&
      ((o = n._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      s = o.sampleValues;
    return (a[0] = r), (s[0] = e), (a[1] = r + t), (s[1] = i), this;
  }
}
class yE {
  constructor(t, e, i) {
    let n, r, o;
    switch (((this.binding = t), (this.valueSize = i), e)) {
      case "quaternion":
        (n = this._slerp),
          (r = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(6 * i)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (n = this._select),
          (r = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(5 * i));
        break;
      default:
        (n = this._lerp),
          (r = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(5 * i));
    }
    (this._mixBufferRegion = n),
      (this._mixBufferRegionAdditive = r),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(t, e) {
    const i = this.buffer,
      n = this.valueSize,
      r = t * n + n;
    let o = this.cumulativeWeight;
    if (0 === o) {
      for (let t = 0; t !== n; ++t) i[r + t] = i[t];
      o = e;
    } else {
      o += e;
      const t = e / o;
      this._mixBufferRegion(i, r, 0, t, n);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(t) {
    const e = this.buffer,
      i = this.valueSize,
      n = i * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(),
      this._mixBufferRegionAdditive(e, n, 0, t, i),
      (this.cumulativeWeightAdditive += t);
  }
  apply(t) {
    const e = this.valueSize,
      i = this.buffer,
      n = t * e + e,
      r = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const t = e * this._origIndex;
      this._mixBufferRegion(i, n, t, 1 - r, e);
    }
    o > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
    for (let s = e, l = e + e; s !== l; ++s)
      if (i[s] !== i[s + e]) {
        a.setValue(i, n);
        break;
      }
  }
  saveOriginalState() {
    const t = this.binding,
      e = this.buffer,
      i = this.valueSize,
      n = i * this._origIndex;
    t.getValue(e, n);
    for (let r = i, o = n; r !== o; ++r) e[r] = e[n + (r % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const t = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t);
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize;
    for (let i = t; i < e; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[e + i] = this.buffer[t + i];
  }
  _select(t, e, i, n, r) {
    if (n >= 0.5) for (let o = 0; o !== r; ++o) t[e + o] = t[i + o];
  }
  _slerp(t, e, i, n) {
    We.slerpFlat(t, e, t, e, t, i, n);
  }
  _slerpAdditive(t, e, i, n, r) {
    const o = this._workIndex * r;
    We.multiplyQuaternionsFlat(t, o, t, e, t, i),
      We.slerpFlat(t, e, t, e, t, o, n);
  }
  _lerp(t, e, i, n, r) {
    const o = 1 - n;
    for (let a = 0; a !== r; ++a) {
      const r = e + a;
      t[r] = t[r] * o + t[i + a] * n;
    }
  }
  _lerpAdditive(t, e, i, n, r) {
    for (let o = 0; o !== r; ++o) {
      const r = e + o;
      t[r] = t[r] + t[i + o] * n;
    }
  }
}
const vE = "\\[\\]\\.:\\/",
  bE = new RegExp("[" + vE + "]", "g"),
  xE = "[^" + vE + "]",
  _E = "[^" + vE.replace("\\.", "") + "]",
  SE = /((?:WC+[\/:])*)/.source.replace("WC", xE),
  ME = /(WCOD+)?/.source.replace("WCOD", _E),
  CE = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", xE),
  wE = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", xE),
  AE = new RegExp("^" + SE + ME + CE + wE + "$"),
  EE = ["material", "materials", "bones"];
class DE {
  constructor(t, e, i) {
    (this.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
      (this.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (this.GetterByBindingType = [
        this._getValue_direct,
        this._getValue_array,
        this._getValue_arrayElement,
        this._getValue_toArray,
      ]),
      (this.SetterByBindingTypeAndVersioning = [
        [
          this._setValue_direct,
          this._setValue_direct_setNeedsUpdate,
          this._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          this._setValue_array,
          this._setValue_array_setNeedsUpdate,
          this._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          this._setValue_arrayElement,
          this._setValue_arrayElement_setNeedsUpdate,
          this._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          this._setValue_fromArray,
          this._setValue_fromArray_setNeedsUpdate,
          this._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]),
      (this.path = e),
      (this.parsedPath = i || DE.parseTrackName(e)),
      (this.node = DE.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(t, e, i) {
    return t && t.isAnimationObjectGroup
      ? new DE.Composite(t, e, i)
      : new DE(t, e, i);
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(bE, "");
  }
  static parseTrackName(t) {
    const e = AE.exec(t);
    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const i = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6],
      },
      n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (void 0 !== n && -1 !== n) {
      const t = i.nodeName.substring(n + 1);
      -1 !== EE.indexOf(t) &&
        ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = t));
    }
    if (null === i.propertyName || 0 === i.propertyName.length)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + t
      );
    return i;
  }
  static findNode(t, e) {
    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const i = t.skeleton.getBoneByName(e);
      if (void 0 !== i) return i;
    }
    if (t.children) {
      const i = function (t) {
          for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (r.name === e || r.uuid === e) return r;
            const o = i(r.children);
            if (o) return o;
          }
          return null;
        },
        n = i(t.children);
      if (n) return n;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(t, e) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  bind() {
    let t = this.node;
    const e = this.parsedPath,
      i = e.objectName,
      n = e.propertyName;
    let r = e.propertyIndex;
    if (
      (t ||
        ((t = DE.findNode(this.rootNode, e.nodeName) || this.rootNode),
        (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    )
      return void console.error(
        "@dp/gis-engine: PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
    if (i) {
      let n = e.objectIndex;
      switch (i) {
        case "materials":
          if (!t.material)
            return void console.error(
              "@dp/gis-engine: PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
          if (!t.material.materials)
            return void console.error(
              "@dp/gis-engine: PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton)
            return void console.error(
              "@dp/gis-engine: PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
          t = t.skeleton.bones;
          for (let e = 0; e < t.length; e++)
            if (t[e].name === n) {
              n = e;
              break;
            }
          break;
        default:
          if (void 0 === t[i])
            return void console.error(
              "@dp/gis-engine: PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
          t = t[i];
      }
      if (void 0 !== n) {
        if (void 0 === t[n])
          return void console.error(
            "@dp/gis-engine: PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            t
          );
        t = t[n];
      }
    }
    const o = t[n];
    if (void 0 === o) {
      const i = e.nodeName;
      return void console.error(
        "@dp/gis-engine: PropertyBinding: Trying to update property for track: " +
          i +
          "." +
          n +
          " but it wasn't found.",
        t
      );
    }
    let a = this.Versioning.None;
    (this.targetObject = t),
      void 0 !== t.needsUpdate
        ? (a = this.Versioning.NeedsUpdate)
        : void 0 !== t.matrixWorldNeedsUpdate &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let s = this.BindingType.Direct;
    if (void 0 !== r) {
      if ("morphTargetInfluences" === n) {
        if (!t.geometry)
          return void console.error(
            "@dp/gis-engine: PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
        if (!t.geometry.isBufferGeometry)
          return void console.error(
            "@dp/gis-engine: PropertyBinding: Can not bind to morphTargetInfluences on Geometry. Use BufferGeometry instead.",
            this
          );
        if (!t.geometry.morphAttributes)
          return void console.error(
            "@dp/gis-engine: PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
        void 0 !== t.morphTargetDictionary[r] &&
          (r = t.morphTargetDictionary[r]);
      }
      (s = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = r);
    } else
      void 0 !== o.fromArray && void 0 !== o.toArray
        ? ((s = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((s = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = n);
    (this.getValue = this.GetterByBindingType[s]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[s][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
DE.Composite = class {
  constructor(t, e, i) {
    const n = i || DE.parseTrackName(e);
    (this._targetGroup = t), (this._bindings = t.subscribe_(e, n));
  }
  getValue(t, e) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      n = this._bindings[i];
    void 0 !== n && n.getValue(t, e);
  }
  setValue(t, e) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(t, e);
  }
  bind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
      t[e].bind();
  }
  unbind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
      t[e].unbind();
  }
};
class TE {
  constructor(...t) {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = we()),
      (this._objects = Array.prototype.slice.call(t)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, r = t.length; n !== r; ++n) e[t[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const i = this;
    this.stats = {
      objects: {
        get total() {
          return i._objects.length;
        },
        get inUse() {
          return this.total - i.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return i._bindings.length;
      },
    };
  }
  add(...t) {
    const e = this._objects,
      i = this._indicesByUUID,
      n = this._paths,
      r = this._parsedPaths,
      o = this._bindings,
      a = o.length;
    let s,
      l = e.length,
      u = this.nCachedObjects_;
    for (let c = 0, h = t.length; c !== h; ++c) {
      const h = t[c],
        p = h.uuid;
      let d = i[p];
      if (void 0 === d) {
        (d = l++), (i[p] = d), e.push(h);
        for (let t = 0, e = a; t !== e; ++t) o[t].push(new DE(h, n[t], r[t]));
      } else if (d < u) {
        s = e[d];
        const t = --u,
          l = e[t];
        (i[l.uuid] = d), (e[d] = l), (i[p] = t), (e[t] = h);
        for (let e = 0, i = a; e !== i; ++e) {
          const i = o[e],
            a = i[t];
          let s = i[d];
          (i[d] = a), void 0 === s && (s = new DE(h, n[e], r[e])), (i[t] = s);
        }
      } else
        e[d] !== s &&
          console.error(
            "@dp/gis-engine: AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove(...t) {
    const e = this._objects,
      i = this._indicesByUUID,
      n = this._bindings,
      r = n.length;
    let o = this.nCachedObjects_;
    for (let a = 0, s = t.length; a !== s; ++a) {
      const s = t[a],
        l = s.uuid,
        u = i[l];
      if (void 0 !== u && u >= o) {
        const t = o++,
          a = e[t];
        (i[a.uuid] = u), (e[u] = a), (i[l] = t), (e[t] = s);
        for (let e = 0, i = r; e !== i; ++e) {
          const i = n[e],
            r = i[t],
            o = i[u];
          (i[u] = r), (i[t] = o);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache(...t) {
    const e = this._objects,
      i = this._indicesByUUID,
      n = this._bindings,
      r = n.length;
    let o = this.nCachedObjects_,
      a = e.length;
    for (let s = 0, l = t.length; s !== l; ++s) {
      const l = t[s].uuid,
        u = i[l];
      if (void 0 !== u)
        if ((delete i[l], u < o)) {
          const t = --o,
            s = e[t],
            l = --a,
            c = e[l];
          (i[s.uuid] = u), (e[u] = s), (i[c.uuid] = t), (e[t] = c), e.pop();
          for (let e = 0, i = r; e !== i; ++e) {
            const i = n[e],
              r = i[t],
              o = i[l];
            (i[u] = r), (i[t] = o), i.pop();
          }
        } else {
          const t = --a,
            o = e[t];
          t > 0 && (i[o.uuid] = u), (e[u] = o), e.pop();
          for (let e = 0, i = r; e !== i; ++e) {
            const i = n[e];
            (i[u] = i[t]), i.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(t, e) {
    const i = this._bindingsIndicesByPath;
    let n = i[t];
    const r = this._bindings;
    if (void 0 !== n) return r[n];
    const o = this._paths,
      a = this._parsedPaths,
      s = this._objects,
      l = s.length,
      u = this.nCachedObjects_,
      c = new Array(l);
    (n = r.length), (i[t] = n), o.push(t), a.push(e), r.push(c);
    for (let h = u, p = s.length; h !== p; ++h) {
      const i = s[h];
      c[h] = new DE(i, t, e);
    }
    return c;
  }
  unsubscribe_(t) {
    const e = this._bindingsIndicesByPath,
      i = e[t];
    if (void 0 !== i) {
      const n = this._paths,
        r = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        s = o[a];
      (e[t[a]] = i),
        (o[i] = s),
        o.pop(),
        (r[i] = r[a]),
        r.pop(),
        (n[i] = n[a]),
        n.pop();
    }
  }
}
class PE extends vt {
  constructor(t) {
    super(),
      (this._controlInterpolantsResultBuffer = new Float32Array(1)),
      (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(t, e) {
    const i = t._localRoot || this._root,
      n = t._clip.tracks,
      r = n.length,
      o = t._propertyBindings,
      a = t._interpolants,
      s = i.uuid,
      l = this._bindingsByRootAndName;
    let u = l[s];
    void 0 === u && ((u = {}), (l[s] = u));
    for (let c = 0; c !== r; ++c) {
      const t = n[c],
        r = t.name;
      let l = u[r];
      if (void 0 !== l) o[c] = l;
      else {
        if (((l = o[c]), void 0 !== l)) {
          null === l._cacheIndex &&
            (++l.referenceCount, this._addInactiveBinding(l, s, r));
          continue;
        }
        const n = e && e._propertyBindings[c].binding.parsedPath;
        (l = new yE(DE.create(i, r, n), t.ValueTypeName, t.getValueSize())),
          ++l.referenceCount,
          this._addInactiveBinding(l, s, r),
          (o[c] = l);
      }
      a[c].resultBuffer = l.buffer;
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (null === t._cacheIndex) {
        const e = (t._localRoot || this._root).uuid,
          i = t._clip.uuid,
          n = this._actionsByClip[i];
        this._bindAction(t, n && n.knownActions[0]),
          this._addInactiveAction(t, i, e);
      }
      const e = t._propertyBindings;
      for (let t = 0, i = e.length; t !== i; ++t) {
        const i = e[t];
        0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
      }
      this._lendAction(t);
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let t = 0, i = e.length; t !== i; ++t) {
        const i = e[t];
        0 == --i.useCount &&
          (i.restoreOriginalState(), this._takeBackBinding(i));
      }
      this._takeBackAction(t);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(t) {
    const e = t._cacheIndex;
    return null !== e && e < this._nActiveActions;
  }
  _addInactiveAction(t, e, i) {
    const n = this._actions,
      r = this._actionsByClip;
    let o = r[e];
    if (void 0 === o)
      (o = {
        knownActions: [t],
        actionByRoot: {},
      }),
        (t._byClipCacheIndex = 0),
        (r[e] = o);
    else {
      const e = o.knownActions;
      (t._byClipCacheIndex = e.length), e.push(t);
    }
    (t._cacheIndex = n.length), n.push(t), (o.actionByRoot[i] = t);
  }
  _removeInactiveAction(t) {
    const e = this._actions,
      i = e[e.length - 1],
      n = t._cacheIndex;
    (i._cacheIndex = n), (e[n] = i), e.pop(), (t._cacheIndex = null);
    const r = t._clip.uuid,
      o = this._actionsByClip,
      a = o[r],
      s = a.knownActions,
      l = s[s.length - 1],
      u = t._byClipCacheIndex;
    (l._byClipCacheIndex = u),
      (s[u] = l),
      s.pop(),
      (t._byClipCacheIndex = null);
    delete a.actionByRoot[(t._localRoot || this._root).uuid],
      0 === s.length && delete o[r],
      this._removeInactiveBindingsForAction(t);
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const t = e[i];
      0 == --t.referenceCount && this._removeInactiveBinding(t);
    }
  }
  _lendAction(t) {
    const e = this._actions,
      i = t._cacheIndex,
      n = this._nActiveActions++,
      r = e[n];
    (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
  }
  _takeBackAction(t) {
    const e = this._actions,
      i = t._cacheIndex,
      n = --this._nActiveActions,
      r = e[n];
    (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
  }
  _addInactiveBinding(t, e, i) {
    const n = this._bindingsByRootAndName,
      r = this._bindings;
    let o = n[e];
    void 0 === o && ((o = {}), (n[e] = o)),
      (o[i] = t),
      (t._cacheIndex = r.length),
      r.push(t);
  }
  _removeInactiveBinding(t) {
    const e = this._bindings,
      i = t.binding,
      n = i.rootNode.uuid,
      r = i.path,
      o = this._bindingsByRootAndName,
      a = o[n],
      s = e[e.length - 1],
      l = t._cacheIndex;
    (s._cacheIndex = l),
      (e[l] = s),
      e.pop(),
      delete a[r],
      0 === Object.keys(a).length && delete o[n];
  }
  _lendBinding(t) {
    const e = this._bindings,
      i = t._cacheIndex,
      n = this._nActiveBindings++,
      r = e[n];
    (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
  }
  _takeBackBinding(t) {
    const e = this._bindings,
      i = t._cacheIndex,
      n = --this._nActiveBindings,
      r = e[n];
    (t._cacheIndex = n), (e[n] = t), (r._cacheIndex = i), (e[i] = r);
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++;
    let i = t[e];
    return (
      "undefined" === i &&
        ((i = new UA(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (i.__cacheIndex = e),
        (t[e] = i)),
      i
    );
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants,
      i = t.__cacheIndex,
      n = --this._nActiveControlInterpolants,
      r = e[n];
    (t.__cacheIndex = n), (e[n] = t), (r.__cacheIndex = i), (e[i] = r);
  }
  clipAction(t, e, i) {
    const n = e || this._root,
      r = n.uuid;
    let o = "string" == typeof t ? JA.findByName(n, t) : t;
    const a = null !== o ? o.uuid : t,
      s = this._actionsByClip[a];
    let l = null;
    if ((void 0 === i && (i = null !== o ? o.blendMode : ue), void 0 !== s)) {
      const t = s.actionByRoot[r];
      if (void 0 !== t && t.blendMode === i) return t;
      (l = s.knownActions[0]), null === o && (o = l._clip);
    }
    if (null === o) return null;
    const u = new mE(this, o, e, i);
    return this._bindAction(u, l), this._addInactiveAction(u, a, r), u;
  }
  existingAction(t, e) {
    const i = e || this._root,
      n = i.uuid,
      r = "string" == typeof t ? JA.findByName(i, t) : t,
      o = r ? r.uuid : t,
      a = this._actionsByClip[o];
    return (void 0 !== a && a.actionByRoot[n]) || null;
  }
  stopAllAction() {
    const t = this._actions;
    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
    return this;
  }
  update(t) {
    t *= this.timeScale;
    const e = this._actions,
      i = this._nActiveActions,
      n = (this.time += t),
      r = Math.sign(t),
      o = (this._accuIndex ^= 1);
    for (let l = 0; l !== i; ++l) {
      e[l]._update(n, t, r, o);
    }
    const a = this._bindings,
      s = this._nActiveBindings;
    for (let l = 0; l !== s; ++l) a[l].apply(o);
    return this;
  }
  setTime(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
    return this.update(t);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t) {
    const e = this._actions,
      i = t.uuid,
      n = this._actionsByClip,
      r = n[i];
    if (void 0 !== r) {
      const t = r.knownActions;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const n = t[i];
        this._deactivateAction(n);
        const r = n._cacheIndex,
          o = e[e.length - 1];
        (n._cacheIndex = null),
          (n._byClipCacheIndex = null),
          (o._cacheIndex = r),
          (e[r] = o),
          e.pop(),
          this._removeInactiveBindingsForAction(n);
      }
      delete n[i];
    }
  }
  uncacheRoot(t) {
    const e = t.uuid,
      i = this._actionsByClip;
    for (const r in i) {
      const t = i[r].actionByRoot[e];
      void 0 !== t &&
        (this._deactivateAction(t), this._removeInactiveAction(t));
    }
    const n = this._bindingsByRootAndName[e];
    if (void 0 !== n)
      for (const r in n) {
        const t = n[r];
        t.restoreOriginalState(), this._removeInactiveBinding(t);
      }
  }
  uncacheAction(t, e) {
    const i = this.existingAction(t, e);
    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class LE extends $a {
  constructor(t, e, i = 1) {
    super(t, e),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  clone(t) {
    const e = super.clone(t);
    return (e.meshPerAttribute = this.meshPerAttribute), e;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    );
  }
}
class IE {
  constructor(t, e, i = 0, n = 1 / 0) {
    (this.ray = new Si(t, e)),
      (this.near = i),
      (this.far = n),
      (this.camera = null),
      (this.layers = new Di()),
      (this.params = {
        Mesh: {},
        Line: {
          threshold: 1,
        },
        LOD: {},
        Points: {
          threshold: 1,
        },
        Sprite: {},
      });
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e && e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e && e.isOrthographicCamera
      ? (this.ray.origin
          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
        (this.camera = e))
      : console.error(
          "@dp/gis-engine: Raycaster: Unsupported camera type: " + e.type
        );
  }
  intersectObject(t, e = !0, i = []) {
    return RE(t, this, i, e), i.sort(NE), i;
  }
  intersectObjects(t, e = !0, i = []) {
    for (let n = 0, r = t.length; n < r; n++) RE(t[n], this, i, e);
    return i.sort(NE), i;
  }
}
function NE(t, e) {
  return t.distance - e.distance;
}
function RE(t, e, i, n) {
  if ((t.layers.test(e.layers) && t.raycast(e, i), !0 === n)) {
    const n = t.children;
    for (let t = 0, r = n.length; t < r; t++) RE(n[t], e, i, !0);
  }
}
class OE {
  constructor(t = 1, e = 0, i = 0) {
    return (this.radius = t), (this.phi = e), (this.theta = i), this;
  }
  set(t, e, i) {
    return (this.radius = t), (this.phi = e), (this.theta = i), this;
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    );
  }
  makeSafe() {
    const t = 1e-6;
    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, i) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + i * i)),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, i)),
          (this.phi = Math.acos(Ae(e / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new OE().copy(this);
  }
}
const FE = new Ye(),
  zE = new Ye();
class kE {
  constructor(t = new Ye(), e = new Ye()) {
    (this.start = t), (this.end = e);
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(t) {
    return t.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(t, e) {
    FE.subVectors(t, this.start), zE.subVectors(this.end, this.start);
    const i = zE.dot(zE);
    let n = zE.dot(FE) / i;
    return e && (n = Ae(n, 0, 1)), n;
  }
  closestPointToPoint(t, e, i) {
    const n = this.closestPointToPointParameter(t, e);
    return this.delta(i).multiplyScalar(n).add(this.start);
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
  clone() {
    return new kE().copy(this);
  }
}
const BE = new Ye();
class GE extends Hi {
  constructor(t, e) {
    super(),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e);
    const i = new En(),
      n = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, s = 32; o < s; o++, a++) {
      const t = (o / s) * Math.PI * 2,
        e = (a / s) * Math.PI * 2;
      n.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1);
    }
    i.setAttribute("position", new bn(n, 3));
    const r = new us({
      fog: !1,
      toneMapped: !1,
    });
    (this.cone = new vs(i, r)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const t = this.light.distance ? this.light.distance : 1e3,
      e = t * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, t),
      BE.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(BE),
      void 0 !== this.color
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
class UE extends vs {
  constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
    const r = new ln(i),
      o = new ln(n),
      a = e / 2,
      s = t / e,
      l = t / 2,
      u = [],
      c = [];
    for (let p = 0, d = 0, f = -l; p <= e; p++, f += s) {
      u.push(-l, 0, f, l, 0, f), u.push(f, 0, -l, f, 0, l);
      const t = p === a ? r : o;
      t.toArray(c, d),
        (d += 3),
        t.toArray(c, d),
        (d += 3),
        t.toArray(c, d),
        (d += 3),
        t.toArray(c, d),
        (d += 3);
    }
    const h = new En();
    h.setAttribute("position", new bn(u, 3)),
      h.setAttribute("color", new bn(c, 3));
    super(
      h,
      new us({
        vertexColors: !0,
        toneMapped: !1,
      })
    ),
      (this.type = "GridHelper");
  }
}
class jE extends vs {
  constructor(t = 10, e = 16, i = 8, n = 64, r = 4473924, o = 8947848) {
    const a = new ln(r),
      s = new ln(o),
      l = [],
      u = [];
    for (let h = 0; h <= e; h++) {
      const i = (h / e) * (2 * Math.PI),
        n = Math.sin(i) * t,
        r = Math.cos(i) * t;
      l.push(0, 0, 0), l.push(n, 0, r);
      const o = 1 & h ? a : s;
      u.push(o.r, o.g, o.b), u.push(o.r, o.g, o.b);
    }
    for (let h = 0; h <= i; h++) {
      const e = 1 & h ? a : s,
        r = t - (t / i) * h;
      for (let t = 0; t < n; t++) {
        let i = (t / n) * (2 * Math.PI),
          o = Math.sin(i) * r,
          a = Math.cos(i) * r;
        l.push(o, 0, a),
          u.push(e.r, e.g, e.b),
          (i = ((t + 1) / n) * (2 * Math.PI)),
          (o = Math.sin(i) * r),
          (a = Math.cos(i) * r),
          l.push(o, 0, a),
          u.push(e.r, e.g, e.b);
      }
    }
    const c = new En();
    c.setAttribute("position", new bn(l, 3)),
      c.setAttribute("color", new bn(u, 3));
    super(
      c,
      new us({
        vertexColors: !0,
        toneMapped: !1,
      })
    ),
      (this.type = "PolarGridHelper");
  }
}
const HE = new Ye(),
  VE = new Ye(),
  WE = new Ye();
class qE extends Hi {
  constructor(t, e, i) {
    super(),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      void 0 === e && (e = 1);
    let n = new En();
    n.setAttribute(
      "position",
      new bn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    );
    const r = new us({
      fog: !1,
      toneMapped: !1,
    });
    (this.lightPlane = new gs(n, r)),
      this.add(this.lightPlane),
      (n = new En()),
      n.setAttribute("position", new bn([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new gs(n, r)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    HE.setFromMatrixPosition(this.light.matrixWorld),
      VE.setFromMatrixPosition(this.light.target.matrixWorld),
      WE.subVectors(VE, HE),
      this.lightPlane.lookAt(VE),
      void 0 !== this.color
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(VE),
      (this.targetLine.scale.z = WE.length());
  }
}
const YE = new Ye(),
  XE = new Kn();
class QE extends vs {
  constructor(t) {
    const e = new En(),
      i = new us({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1,
      }),
      n = [],
      r = [],
      o = {},
      a = new ln(16755200),
      s = new ln(16711680),
      l = new ln(43775),
      u = new ln(16777215),
      c = new ln(3355443);
    function h(t, e, i) {
      p(t, i), p(e, i);
    }
    function p(t, e) {
      n.push(0, 0, 0),
        r.push(e.r, e.g, e.b),
        void 0 === o[t] && (o[t] = []),
        o[t].push(n.length / 3 - 1);
    }
    h("n1", "n2", a),
      h("n2", "n4", a),
      h("n4", "n3", a),
      h("n3", "n1", a),
      h("f1", "f2", a),
      h("f2", "f4", a),
      h("f4", "f3", a),
      h("f3", "f1", a),
      h("n1", "f1", a),
      h("n2", "f2", a),
      h("n3", "f3", a),
      h("n4", "f4", a),
      h("p", "n1", s),
      h("p", "n2", s),
      h("p", "n3", s),
      h("p", "n4", s),
      h("u1", "u2", l),
      h("u2", "u3", l),
      h("u3", "u1", l),
      h("c", "t", u),
      h("p", "c", c),
      h("cn1", "cn2", c),
      h("cn3", "cn4", c),
      h("cf1", "cf2", c),
      h("cf3", "cf4", c),
      e.setAttribute("position", new bn(n, 3)),
      e.setAttribute("color", new bn(r, 3)),
      super(e, i),
      (this.type = "CameraHelper"),
      (this.camera = t),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
  }
  update() {
    const t = this.geometry,
      e = this.pointMap;
    XE.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      ZE("c", e, t, XE, 0, 0, -1),
      ZE("t", e, t, XE, 0, 0, 1),
      ZE("n1", e, t, XE, -1, -1, -1),
      ZE("n2", e, t, XE, 1, -1, -1),
      ZE("n3", e, t, XE, -1, 1, -1),
      ZE("n4", e, t, XE, 1, 1, -1),
      ZE("f1", e, t, XE, -1, -1, 1),
      ZE("f2", e, t, XE, 1, -1, 1),
      ZE("f3", e, t, XE, -1, 1, 1),
      ZE("f4", e, t, XE, 1, 1, 1),
      ZE("u1", e, t, XE, 0.7, 1.1, -1),
      ZE("u2", e, t, XE, -0.7, 1.1, -1),
      ZE("u3", e, t, XE, 0, 2, -1),
      ZE("cf1", e, t, XE, -1, 0, 1),
      ZE("cf2", e, t, XE, 1, 0, 1),
      ZE("cf3", e, t, XE, 0, -1, 1),
      ZE("cf4", e, t, XE, 0, 1, 1),
      ZE("cn1", e, t, XE, -1, 0, -1),
      ZE("cn2", e, t, XE, 1, 0, -1),
      ZE("cn3", e, t, XE, 0, -1, -1),
      ZE("cn4", e, t, XE, 0, 1, -1),
      (t.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ZE(t, e, i, n, r, o, a) {
  YE.set(r, o, a).unproject(n);
  const s = e[t];
  if (void 0 !== s) {
    const t = i.getAttribute("position");
    for (let e = 0, i = s.length; e < i; e++) t.setXYZ(s[e], YE.x, YE.y, YE.z);
  }
}
class JE extends vs {
  constructor(t, e = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      n = new En();
    n.setIndex(new gn(i, 1)),
      n.setAttribute(
        "position",
        new bn(
          [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1,
          ],
          3
        )
      ),
      super(
        n,
        new us({
          color: e,
          toneMapped: !1,
        })
      ),
      (this.box = t),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(t) {
    const e = this.box;
    e.isEmpty() ||
      (e.getCenter(this.position),
      e.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(t));
  }
}
class KE extends vs {
  constructor(t = 1) {
    const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      i = new En();
    i.setAttribute("position", new bn(e, 3)),
      i.setAttribute(
        "color",
        new bn([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
      );
    super(
      i,
      new us({
        vertexColors: !0,
        toneMapped: !1,
      })
    ),
      (this.type = "AxesHelper");
  }
  setColors(t, e, i) {
    const n = new ln(),
      r = this.geometry.attributes.color.array;
    return (
      n.set(t),
      n.toArray(r, 0),
      n.toArray(r, 3),
      n.set(e),
      n.toArray(r, 6),
      n.toArray(r, 9),
      n.set(i),
      n.toArray(r, 12),
      n.toArray(r, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const $E = new Float32Array(1);
new Int32Array($E.buffer);
class tD {
  constructor(t, e, i) {
    (this.gl = t),
      (this.extensions = e),
      (this.capabilities = i),
      (this.isWebGL2 = i.isWebGL2);
  }
  convert(t) {
    let e;
    if (t === Yt) return this.gl.UNSIGNED_BYTE;
    if (1017 === t) return this.gl.UNSIGNED_SHORT_4_4_4_4;
    if (1018 === t) return this.gl.UNSIGNED_SHORT_5_5_5_1;
    if (1019 === t) return this.gl.UNSIGNED_SHORT_5_6_5;
    if (1010 === t) return this.gl.BYTE;
    if (1011 === t) return this.gl.SHORT;
    if (t === Xt) return this.gl.UNSIGNED_SHORT;
    if (1013 === t) return this.gl.INT;
    if (t === Qt) return this.gl.UNSIGNED_INT;
    if (t === Zt) return this.gl.FLOAT;
    if (t === Jt)
      return this.isWebGL2
        ? this.gl.HALF_FLOAT
        : ((e = this.extensions.get("OES_texture_half_float")),
          null !== e ? e.HALF_FLOAT_OES : null);
    if (1021 === t) return this.gl.ALPHA;
    if (t === $t) return this.gl.RGB;
    if (t === te) return this.gl.RGBA;
    if (1024 === t) return this.gl.LUMINANCE;
    if (1025 === t) return this.gl.LUMINANCE_ALPHA;
    if (t === ee) return this.gl.DEPTH_COMPONENT;
    if (t === ie) return this.gl.DEPTH_STENCIL;
    if (1028 === t) return this.gl.RED;
    if (1029 === t) return this.gl.RED_INTEGER;
    if (1030 === t) return this.gl.RG;
    if (1031 === t) return this.gl.RG_INTEGER;
    if (1032 === t) return this.gl.RGB_INTEGER;
    if (1033 === t) return this.gl.RGBA_INTEGER;
    if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
      if (
        ((e = this.extensions.get("WEBGL_compressed_texture_s3tc")), null === e)
      )
        return null;
      if (33776 === t) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (33777 === t) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (33778 === t) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (33779 === t) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
      if (
        ((e = this.extensions.get("WEBGL_compressed_texture_pvrtc")),
        null === e)
      )
        return null;
      if (35840 === t) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (35841 === t) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (35842 === t) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (35843 === t) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (36196 === t)
      return (
        (e = this.extensions.get("WEBGL_compressed_texture_etc1")),
        null !== e ? e.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (
      (37492 === t || 37496 === t) &&
      ((e = this.extensions.get("WEBGL_compressed_texture_etc")), null !== e)
    ) {
      if (37492 === t) return e.COMPRESSED_RGB8_ETC2;
      if (37496 === t) return e.COMPRESSED_RGBA8_ETC2_EAC;
    }
    return 37808 === t ||
      37809 === t ||
      37810 === t ||
      37811 === t ||
      37812 === t ||
      37813 === t ||
      37814 === t ||
      37815 === t ||
      37816 === t ||
      37817 === t ||
      37818 === t ||
      37819 === t ||
      37820 === t ||
      37821 === t ||
      37840 === t ||
      37841 === t ||
      37842 === t ||
      37843 === t ||
      37844 === t ||
      37845 === t ||
      37846 === t ||
      37847 === t ||
      37848 === t ||
      37849 === t ||
      37850 === t ||
      37851 === t ||
      37852 === t ||
      37853 === t
      ? ((e = this.extensions.get("WEBGL_compressed_texture_astc")),
        null !== e ? t : null)
      : 36492 === t
      ? ((e = this.extensions.get("EXT_texture_compression_bptc")),
        null !== e ? t : null)
      : t === Kt
      ? this.isWebGL2
        ? this.gl.UNSIGNED_INT_24_8
        : ((e = this.extensions.get("WEBGL_depth_texture")),
          null !== e ? e.UNSIGNED_INT_24_8_WEBGL : null)
      : void 0;
  }
}
const eD = {
    type: "start",
  },
  iD = {
    type: "end",
  },
  nD = {
    type: "change",
  },
  rD = {
    type: "pan",
  },
  oD = {
    type: "panStart",
  },
  aD = {
    type: "panEnd",
  },
  sD = {
    type: "rotate",
  },
  lD = {
    type: "rotateStart",
  },
  uD = {
    type: "rotateEnd",
  },
  cD = {
    type: "pitch",
  },
  hD = {
    type: "pitchStart",
  },
  pD = {
    type: "pitchEnd",
  },
  dD = {
    type: "zoom",
  },
  fD = {
    type: "zoomStart",
  },
  gD = {
    type: "zoomEnd",
  };
class mD extends vt {
  constructor(t, e) {
    super(),
      (this.dollyTrigger = new yD(
        () => {
          this.dispatchEvent(fD);
        },
        () => {
          this.dispatchEvent(dD);
        },
        () => {
          this.dispatchEvent(gD);
        }
      )),
      (this.panTrigger = new yD(
        () => {
          this.dispatchEvent(oD);
        },
        () => {
          this.dispatchEvent(rD);
        },
        () => {
          this.dispatchEvent(aD);
        }
      )),
      (this.rotateTrigger = new yD(
        () => {
          this.dispatchEvent(lD);
        },
        () => {
          this.dispatchEvent(sD);
        },
        () => {
          this.dispatchEvent(uD);
        }
      )),
      (this.pitchTrigger = new yD(
        () => {
          this.dispatchEvent(hD);
        },
        () => {
          this.dispatchEvent(cD);
        },
        () => {
          this.dispatchEvent(pD);
        }
      )),
      (this.onPointerDown = (t) => {
        if (!1 === this.enabled) return;
        const e = t.target;
        0 === this.pointers.length &&
          e &&
          (e.setPointerCapture(t.pointerId),
          e.addEventListener("pointermove", this.onPointerMove),
          e.addEventListener("pointerup", this.onPointerUp)),
          this.addPointer(t),
          "touch" === t.pointerType
            ? this.onTouchStart(t)
            : this.onMouseDown(t);
      }),
      (this.onPointerMove = (t) => {
        !1 !== this.enabled &&
          ("touch" === t.pointerType
            ? this.onTouchMove(t)
            : this.onMouseMove(t));
      }),
      (this.onPointerUp = (t) => {
        this.removePointer(t);
        const e = t.target;
        0 === this.pointers.length &&
          e &&
          (e.releasePointerCapture(t.pointerId),
          e.removeEventListener("pointermove", this.onPointerMove),
          e.removeEventListener("pointerup", this.onPointerUp)),
          this.dispatchEvent(iD),
          (this.state = this.STATE.NONE);
      }),
      (this.onPointerCancel = (t) => {
        this.removePointer(t);
      }),
      (this.onMouseWheel = (t) => {
        !1 !== this.enabled &&
          !1 !== this.enableZoom &&
          this.state === this.STATE.NONE &&
          (t.preventDefault(),
          this.dispatchEvent(eD),
          this.handleMouseWheel(t),
          this.dispatchEvent(iD));
      }),
      (this.onContextMenu = (t) => {
        !1 !== this.enabled && t.preventDefault();
      }),
      (this.props = e),
      t === document &&
        console.error(
          '@dp/gis-engine: OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.domElement = t),
      (t.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new Ye()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ft.ROTATE,
        MIDDLE: ft.DOLLY,
        RIGHT: ft.PAN,
      }),
      (this.touches = {
        ONE: mt.ROTATE,
        TWO: mt.DOLLY_PAN,
      }),
      (this.target0 = this.target.clone()),
      (this.STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      }),
      (this.state = this.STATE.NONE),
      (this.EPS = 1e-6),
      (this.spherical = new OE()),
      (this.sphericalDelta = new OE()),
      (this.scale = 1),
      (this.panOffset = new Ye()),
      (this.zoomChanged = !1),
      (this.rotateStart = new Le()),
      (this.rotateEnd = new Le()),
      (this.rotateDelta = new Le()),
      (this.panStart = new Le()),
      (this.panEnd = new Le()),
      (this.panDelta = new Le()),
      (this.dollyStart = new Le()),
      (this.dollyEnd = new Le()),
      (this.dollyDelta = new Le()),
      (this.pointers = []),
      (this.pointerPositions = {}),
      t.addEventListener("contextmenu", this.onContextMenu),
      t.addEventListener("pointerdown", this.onPointerDown),
      t.addEventListener("pointercancel", this.onPointerCancel),
      t.addEventListener("wheel", this.onMouseWheel, {
        passive: !1,
      });
  }
  getAutoRotationAngle() {
    return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;
  }
  getZoomScale() {
    return Math.pow(0.95, this.zoomSpeed);
  }
  rotateLeft(t) {
    this.sphericalDelta.theta -= t;
  }
  rotateUp(t) {
    this.sphericalDelta.phi -= t;
  }
  panLeft(t, e) {
    const i = new Ye();
    i.setFromMatrixColumn(e, 0), i.multiplyScalar(-t), this.panOffset.add(i);
  }
  panUp(t, e) {
    const i = new Ye();
    !0 === this.screenSpacePanning
      ? i.setFromMatrixColumn(e, 1)
      : (i.setFromMatrixColumn(e, 0), i.crossVectors(this.object.up, i)),
      i.multiplyScalar(t),
      this.panOffset.add(i);
  }
  pan(t, e) {
    const i = new Ye(),
      n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const r = this.object.position;
      i.copy(r).sub(this.target);
      let o = i.length();
      (o *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
        this.panLeft((2 * t * o) / n.clientHeight, this.object.matrix),
        this.panUp((2 * e * o) / n.clientHeight, this.object.matrix);
    } else
      this.object.isOrthographicCamera
        ? (this.panLeft(
            (t * (this.object.right - this.object.left)) /
              this.object.zoom /
              n.clientWidth,
            this.object.matrix
          ),
          this.panUp(
            (e * (this.object.top - this.object.bottom)) /
              this.object.zoom /
              n.clientHeight,
            this.object.matrix
          ))
        : (this.enablePan = !1);
  }
  dollyOut(t) {
    this.object.isPerspectiveCamera
      ? (this.scale /= t)
      : this.object.isOrthographicCamera
      ? ((this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom * t)
        )),
        this.object.updateProjectionMatrix(),
        (this.zoomChanged = !0))
      : (this.enableZoom = !1);
  }
  dollyIn(t) {
    this.object.isPerspectiveCamera
      ? (this.scale *= t)
      : this.object.isOrthographicCamera
      ? ((this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / t)
        )),
        this.object.updateProjectionMatrix(),
        (this.zoomChanged = !0))
      : (this.enableZoom = !1);
  }
  handleMouseDownRotate(t) {
    this.rotateStart.set(t.clientX, t.clientY);
  }
  handleMouseDownDolly(t) {
    this.dollyStart.set(t.clientX, t.clientY);
  }
  handleMouseDownPan(t) {
    this.panStart.set(t.clientX, t.clientY);
  }
  handleMouseMoveRotate(t) {
    this.rotateEnd.set(t.clientX, t.clientY),
      this.rotateDelta
        .subVectors(this.rotateEnd, this.rotateStart)
        .multiplyScalar(this.rotateSpeed),
      this.domElement,
      this.props.rotate(this.rotateDelta.x, this.rotateDelta.y),
      0 !== this.rotateDelta.y && this.pitchTrigger.triggle(),
      0 !== this.rotateDelta.x && this.rotateTrigger.triggle(),
      (0 === this.rotateDelta.y && 0 === this.rotateDelta.x) ||
        this.dispatchEvent(nD),
      this.rotateStart.copy(this.rotateEnd);
  }
  handleMouseMoveDolly(t) {
    this.dollyEnd.set(t.clientX, t.clientY),
      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart),
      this.dollyDelta.y > 0
        ? this.props.dolly(-0.1)
        : this.dollyDelta.y < 0 && this.props.dolly(0.1),
      this.dollyStart.copy(this.dollyEnd),
      this.dollyTrigger.triggle(),
      this.dispatchEvent(nD);
  }
  handleMouseMovePan(t) {
    this.panEnd.set(t.clientX, t.clientY),
      this.panDelta
        .subVectors(this.panEnd, this.panStart)
        .multiplyScalar(this.panSpeed),
      this.props.pan(this.panDelta.x, this.panDelta.y),
      this.panStart.copy(this.panEnd),
      this.panTrigger.triggle(),
      this.dispatchEvent(nD);
  }
  handleMouseWheel(t) {
    t.deltaY < 0
      ? this.props.dolly(0.1)
      : t.deltaY > 0 && this.props.dolly(-0.1),
      (this.state = this.STATE.NONE),
      this.dollyTrigger.triggle(),
      this.dispatchEvent(nD);
  }
  handleKeyDown(t) {}
  onTouchStart(t) {
    switch ((this.trackPointer(t), this.pointers.length)) {
      case 1:
        switch (this.touches.ONE) {
          case mt.ROTATE:
            if (!1 === this.enableRotate) return;
            this.handleTouchStartRotate(),
              (this.state = this.STATE.TOUCH_ROTATE);
            break;
          case mt.PAN:
            if (!1 === this.enablePan) return;
            this.handleTouchStartPan(), (this.state = this.STATE.TOUCH_PAN);
            break;
          default:
            this.state = this.STATE.NONE;
        }
        break;
      case 2:
        switch (this.touches.TWO) {
          case mt.DOLLY_PAN:
            if (!1 === this.enableZoom && !1 === this.enablePan) return;
            this.handleTouchStartDollyPan(),
              (this.state = this.STATE.TOUCH_DOLLY_PAN);
            break;
          case mt.DOLLY_ROTATE:
            if (!1 === this.enableZoom && !1 === this.enableRotate) return;
            this.handleTouchStartDollyRotate(),
              (this.state = this.STATE.TOUCH_DOLLY_ROTATE);
            break;
          default:
            this.state = this.STATE.NONE;
        }
        break;
      default:
        this.state = this.STATE.NONE;
    }
    this.state !== this.STATE.NONE && this.dispatchEvent(eD);
  }
  onTouchMove(t) {
    switch ((this.trackPointer(t), this.state)) {
      case this.STATE.TOUCH_ROTATE:
        if (!1 === this.enableRotate) return;
        this.handleTouchMoveRotate(t);
        break;
      case this.STATE.TOUCH_PAN:
        if (!1 === this.enablePan) return;
        this.handleTouchMovePan(t);
        break;
      case this.STATE.TOUCH_DOLLY_PAN:
        if (!1 === this.enableZoom && !1 === this.enablePan) return;
        this.handleTouchMoveDollyPan(t);
        break;
      case this.STATE.TOUCH_DOLLY_ROTATE:
        if (!1 === this.enableZoom && !1 === this.enableRotate) return;
        this.handleTouchMoveDollyRotate(t);
        break;
      default:
        this.state = this.STATE.NONE;
    }
  }
  handleTouchStartRotate() {
    if (1 === this.pointers.length)
      this.rotateStart.set(this.pointers[0].pageX, this.pointers[0].pageY);
    else {
      const t = 0.5 * (this.pointers[0].pageX + this.pointers[1].pageX),
        e = 0.5 * (this.pointers[0].pageY + this.pointers[1].pageY);
      this.rotateStart.set(t, e);
    }
  }
  handleTouchStartPan() {
    if (1 === this.pointers.length)
      this.panStart.set(this.pointers[0].pageX, this.pointers[0].pageY);
    else {
      const t = 0.5 * (this.pointers[0].pageX + this.pointers[1].pageX),
        e = 0.5 * (this.pointers[0].pageY + this.pointers[1].pageY);
      this.panStart.set(t, e);
    }
  }
  handleTouchStartDolly() {
    const t = this.pointers[0].pageX - this.pointers[1].pageX,
      e = this.pointers[0].pageY - this.pointers[1].pageY,
      i = Math.sqrt(t * t + e * e);
    this.dollyStart.set(0, i);
  }
  handleTouchStartDollyPan() {
    this.enableZoom && this.handleTouchStartDolly(),
      this.enablePan && this.handleTouchStartPan();
  }
  handleTouchStartDollyRotate() {
    this.enableZoom && this.handleTouchStartDolly(),
      this.enableRotate && this.handleTouchStartRotate();
  }
  handleTouchMoveRotate(t) {
    if (1 == this.pointers.length) this.rotateEnd.set(t.pageX, t.pageY);
    else {
      const e = this.getSecondPointerPosition(t),
        i = 0.5 * (t.pageX + e.x),
        n = 0.5 * (t.pageY + e.y);
      this.rotateEnd.set(i, n);
    }
    this.rotateDelta
      .subVectors(this.rotateEnd, this.rotateStart)
      .multiplyScalar(this.rotateSpeed),
      this.props.rotate(this.rotateDelta.x, this.rotateDelta.y),
      0 !== this.rotateDelta.y && this.pitchTrigger.triggle(),
      0 !== this.rotateDelta.x && this.rotateTrigger.triggle(),
      (0 === this.rotateDelta.y && 0 === this.rotateDelta.x) ||
        this.dispatchEvent(nD),
      this.rotateStart.copy(this.rotateEnd);
  }
  handleTouchMovePan(t) {
    if (1 === this.pointers.length) this.panEnd.set(t.pageX, t.pageY);
    else {
      const e = this.getSecondPointerPosition(t),
        i = 0.5 * (t.pageX + e.x),
        n = 0.5 * (t.pageY + e.y);
      this.panEnd.set(i, n);
    }
    this.panDelta
      .subVectors(this.panEnd, this.panStart)
      .multiplyScalar(this.panSpeed),
      this.props.pan(this.panDelta.x, this.panDelta.y),
      this.panStart.copy(this.panEnd),
      this.panTrigger.triggle(),
      this.dispatchEvent(nD);
  }
  handleTouchMoveDolly(t) {
    const e = this.getSecondPointerPosition(t),
      i = t.pageX - e.x,
      n = t.pageY - e.y;
    this.dollyStart.y;
    const r = Math.sqrt(i * i + n * n);
    this.dollyEnd.set(0, r),
      this.dollyDelta.set(
        0,
        Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed)
      );
    const o = Math.log2(this.dollyDelta.y);
    this.props.dolly(o),
      this.dollyStart.copy(this.dollyEnd),
      this.dollyTrigger.triggle(),
      this.dispatchEvent(nD);
  }
  handleTouchMoveDollyPan(t) {
    this.enableZoom && this.handleTouchMoveDolly(t),
      this.enablePan && this.handleTouchMovePan(t);
  }
  handleTouchMoveDollyRotate(t) {
    this.enableZoom && this.handleTouchMoveDolly(t),
      this.enableRotate && this.handleTouchMoveRotate(t);
  }
  onMouseDown(t) {
    let e;
    switch (t.button) {
      case 0:
        e = this.mouseButtons.LEFT;
        break;
      case 1:
        e = this.mouseButtons.MIDDLE;
        break;
      case 2:
        e = this.mouseButtons.RIGHT;
        break;
      default:
        e = -1;
    }
    switch (e) {
      case ft.DOLLY:
        if (!1 === this.enableZoom) return;
        this.handleMouseDownDolly(t), (this.state = this.STATE.DOLLY);
        break;
      case ft.ROTATE:
        if (t.ctrlKey || t.metaKey || t.shiftKey) {
          if (!1 === this.enablePan) return;
          this.handleMouseDownPan(t), (this.state = this.STATE.PAN);
        } else {
          if (!1 === this.enableRotate) return;
          this.handleMouseDownRotate(t), (this.state = this.STATE.ROTATE);
        }
        break;
      case ft.PAN:
        if (t.ctrlKey || t.metaKey || t.shiftKey) {
          if (!1 === this.enableRotate) return;
          this.handleMouseDownRotate(t), (this.state = this.STATE.ROTATE);
        } else {
          if (!1 === this.enablePan) return;
          this.handleMouseDownPan(t), (this.state = this.STATE.PAN);
        }
        break;
      default:
        this.state = this.STATE.NONE;
    }
    this.state !== this.STATE.NONE && this.dispatchEvent(eD);
  }
  onMouseMove(t) {
    if (!1 !== this.enabled)
      switch (this.state) {
        case this.STATE.ROTATE:
          if (!1 === this.enableRotate) return;
          this.handleMouseMoveRotate(t);
          break;
        case this.STATE.DOLLY:
          if (!1 === this.enableZoom) return;
          this.handleMouseMoveDolly(t);
          break;
        case this.STATE.PAN:
          if (!1 === this.enablePan) return;
          this.handleMouseMovePan(t);
      }
  }
  addPointer(t) {
    this.pointers.push(t);
  }
  removePointer(t) {
    delete this.pointerPositions[t.pointerId];
    for (let e = 0; e < this.pointers.length; e++)
      if (this.pointers[e].pointerId == t.pointerId)
        return void this.pointers.splice(e, 1);
  }
  trackPointer(t) {
    let e = this.pointerPositions[t.pointerId];
    void 0 === e && ((e = new Le()), (this.pointerPositions[t.pointerId] = e)),
      e.set(t.pageX, t.pageY);
  }
  getSecondPointerPosition(t) {
    const e =
      t.pointerId === this.pointers[0].pointerId
        ? this.pointers[1]
        : this.pointers[0];
    return this.pointerPositions[e.pointerId];
  }
  getPolarAngle() {
    return this.spherical.phi;
  }
  getAzimuthalAngle() {
    return this.spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  saveState() {
    this.target0.copy(this.target),
      this.position0.copy(this.object.position),
      (this.zoom0 = this.object.zoom);
  }
  reset() {
    this.target.copy(this.target0),
      this.object.position.copy(this.position0),
      (this.object.zoom = this.zoom0),
      this.object.updateProjectionMatrix(),
      this.dispatchEvent(nD),
      (this.state = this.STATE.NONE);
  }
  dispose() {
    this.domElement.removeEventListener("contextmenu", this.onContextMenu),
      this.domElement.removeEventListener("pointerdown", this.onPointerDown),
      this.domElement.removeEventListener(
        "pointercancel",
        this.onPointerCancel
      ),
      this.domElement.removeEventListener("wheel", this.onMouseWheel),
      this.domElement.removeEventListener("pointermove", this.onPointerMove),
      this.domElement.removeEventListener("pointerup", this.onPointerUp);
  }
}
class yD {
  constructor(t, e, i) {
    (this.start = t),
      (this.change = e),
      (this.end = i),
      (this.flag = !1),
      (this.handleEnd = ((t, e) => {
        let i;
        return (...n) => {
          const r = globalThis;
          i ||
            (i = window.setTimeout(() => {
              t.apply(r, n), (i = null);
            }, e));
        };
      })(() => {
        (this.flag = !1), this.end();
      }, 250));
  }
  triggle() {
    this.flag || ((this.flag = !0), this.start()),
      this.change(),
      this.handleEnd();
  }
}
const vD = new Ye(),
  bD = new Mi(),
  xD = new Mi();
new Ye(), new Ye();
const _D = new Ye(),
  SD = new We(),
  MD = new Ye();
const CD = new Mi(),
  wD = new Mi();
new Mr(-1, 1, 1, -1, 0, 1);
const AD = new En();
AD.setAttribute("position", new bn([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
  AD.setAttribute("uv", new bn([0, 2, 0, 0, 2, 0], 2)),
  new Mr(-1, 1, 1, -1, 0, 1);
const ED = new En();
ED.setAttribute("position", new bn([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
  ED.setAttribute("uv", new bn([0, 2, 0, 0, 2, 0], 2)),
  new Le(0.001953125, 0),
  new Le(0.001953125, 0),
  new Le(0, 0.001953125),
  new Le(1, 0),
  new Le(0, 1);
const DD = class extends Wn {
  constructor() {
    const t = DD.SkyShader,
      e = new Jn({
        name: "SkyShader",
        fragmentShader: t.fragmentShader,
        vertexShader: t.vertexShader,
        uniforms: Zn.clone(t.uniforms),
        side: bt,
        depthWrite: !1,
      });
    super(new Yn(1, 1, 1), e), (this.isSky = !0);
  }
};
(DD.SkyShader = {
  uniforms: {
    turbidity: {
      value: 2,
    },
    rayleigh: {
      value: 1,
    },
    mieCoefficient: {
      value: 0.005,
    },
    mieDirectionalG: {
      value: 0.8,
    },
    sunPosition: {
      value: new Ye(),
    },
    up: {
      value: new Ye(0, 1, 0),
    },
  },
  vertexShader:
    "\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",
  fragmentShader:
    "\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}",
}),
  (fr.line = {
    worldUnits: {
      value: 1,
    },
    linewidth: {
      value: 1,
    },
    resolution: {
      value: new Le(1, 1),
    },
    dashOffset: {
      value: 0,
    },
    dashScale: {
      value: 1,
    },
    dashSize: {
      value: 1,
    },
    gapSize: {
      value: 1,
    },
  }),
  (mr.line = {
    uniforms: Zn.merge([fr.common, fr.fog, fr.line]),
    vertexShader:
      "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
    fragmentShader:
      "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t",
  });
class TD extends Jn {
  constructor(t) {
    super({
      type: "LineMaterial",
      uniforms: Zn.clone(mr.line.uniforms),
      vertexShader: mr.line.vertexShader,
      fragmentShader: mr.line.fragmentShader,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get() {
            return this.uniforms.diffuse.value;
          },
          set(t) {
            this.uniforms.diffuse.value = t;
          },
        },
        worldUnits: {
          enumerable: !0,
          get() {
            return "WORLD_UNITS" in this.defines;
          },
          set(t) {
            !0 === t
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS;
          },
        },
        linewidth: {
          enumerable: !0,
          get() {
            return this.uniforms.linewidth.value;
          },
          set(t) {
            this.uniforms.linewidth.value = t;
          },
        },
        dashed: {
          enumerable: !0,
          get() {
            return Boolean("USE_DASH" in this.defines);
          },
          set(t) {
            Boolean(t) !== Boolean("USE_DASH" in this.defines) &&
              (this.needsUpdate = !0),
              !0 === t
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH;
          },
        },
        dashScale: {
          enumerable: !0,
          get() {
            return this.uniforms.dashScale.value;
          },
          set(t) {
            this.uniforms.dashScale.value = t;
          },
        },
        dashSize: {
          enumerable: !0,
          get() {
            return this.uniforms.dashSize.value;
          },
          set(t) {
            this.uniforms.dashSize.value = t;
          },
        },
        dashOffset: {
          enumerable: !0,
          get() {
            return this.uniforms.dashOffset.value;
          },
          set(t) {
            this.uniforms.dashOffset.value = t;
          },
        },
        gapSize: {
          enumerable: !0,
          get() {
            return this.uniforms.gapSize.value;
          },
          set(t) {
            this.uniforms.gapSize.value = t;
          },
        },
        opacity: {
          enumerable: !0,
          get() {
            return this.uniforms.opacity.value;
          },
          set(t) {
            this.uniforms.opacity.value = t;
          },
        },
        resolution: {
          enumerable: !0,
          get() {
            return this.uniforms.resolution.value;
          },
          set(t) {
            this.uniforms.resolution.value.copy(t);
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get() {
            return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
          },
          set(t) {
            Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) &&
              (this.needsUpdate = !0),
              !0 === t
                ? ((this.defines.USE_ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1));
          },
        },
      }),
      this.setValues(t);
  }
}
const PD = new li(),
  LD = new Ye();
class ID extends dE {
  constructor() {
    super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = "LineSegmentsGeometry");
    this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]),
      this.setAttribute(
        "position",
        new bn(
          [
            -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0,
            1, -1, 0,
          ],
          3
        )
      ),
      this.setAttribute(
        "uv",
        new bn([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2)
      );
  }
  applyMatrix4(t) {
    const e = this.attributes.instanceStart,
      i = this.attributes.instanceEnd;
    return (
      void 0 !== e &&
        (e.applyMatrix4(t), i.applyMatrix4(t), (e.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  setPositions(t) {
    let e;
    t instanceof Float32Array
      ? (e = t)
      : Array.isArray(t) && (e = new Float32Array(t));
    const i = new LE(e, 6, 1);
    return (
      this.setAttribute("instanceStart", new es(i, 3, 0)),
      this.setAttribute("instanceEnd", new es(i, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    );
  }
  setColors(t) {
    let e;
    t instanceof Float32Array
      ? (e = t)
      : Array.isArray(t) && (e = new Float32Array(t));
    const i = new LE(e, 6, 1);
    return (
      this.setAttribute("instanceColorStart", new es(i, 3, 0)),
      this.setAttribute("instanceColorEnd", new es(i, 3, 3)),
      this
    );
  }
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromMesh(t) {
    return this.fromWireframeGeometry(new RA(t.geometry)), this;
  }
  fromLineSegments(t) {
    const e = t.geometry;
    if (!e.isGeometry)
      return (
        e.isBufferGeometry && this.setPositions(e.attributes.position.array),
        this
      );
    console.error(
      "@dp/gis-engine: LineSegmentsGeometry no longer supports Geometry. Use BufferGeometry instead."
    );
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new li());
    const t = this.attributes.instanceStart,
      e = this.attributes.instanceEnd;
    void 0 !== t &&
      void 0 !== e &&
      (this.boundingBox.setFromBufferAttribute(t),
      PD.setFromBufferAttribute(e),
      this.boundingBox.union(PD));
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new fi()),
      null === this.boundingBox && this.computeBoundingBox();
    const t = this.attributes.instanceStart,
      e = this.attributes.instanceEnd;
    if (void 0 !== t && void 0 !== e) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let n = 0;
      for (let r = 0, o = t.count; r < o; r++)
        LD.fromBufferAttribute(t, r),
          (n = Math.max(n, i.distanceToSquared(LD))),
          LD.fromBufferAttribute(e, r),
          (n = Math.max(n, i.distanceToSquared(LD)));
      (this.boundingSphere.radius = Math.sqrt(n)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "@dp/gis-engine: LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this
          );
    }
  }
  toJSON() {}
  applyMatrix(t) {
    return this.applyMatrix4(t);
  }
}
const ND = new Ye(),
  RD = new Ye(),
  OD = new je(),
  FD = new je(),
  zD = new je(),
  kD = new Ye(),
  BD = new Mi(),
  GD = new kE(),
  UD = new Ye(),
  jD = new li(),
  HD = new fi(),
  VD = new je();
function WD(t, e, i, n) {
  return (
    VD.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix),
    VD.multiplyScalar(1 / VD.w),
    (VD.x = i / n.width),
    (VD.y = i / n.height),
    VD.applyMatrix4(t.projectionMatrixInverse),
    VD.multiplyScalar(1 / VD.w),
    Math.abs(Math.max(VD.x, VD.y))
  );
}
class qD extends Wn {
  constructor(
    t = new ID(),
    e = new TD({
      color: 16777215 * Math.random(),
    })
  ) {
    super(t, e), (this.type = "LineSegments2");
  }
  computeLineDistances() {
    const t = this.geometry,
      e = t.attributes.instanceStart,
      i = t.attributes.instanceEnd,
      n = new Float32Array(2 * e.count);
    for (let o = 0, a = 0, s = e.count; o < s; o++, a += 2)
      ND.fromBufferAttribute(e, o),
        RD.fromBufferAttribute(i, o),
        (n[a] = 0 === a ? 0 : n[a - 1]),
        (n[a + 1] = n[a] + ND.distanceTo(RD));
    const r = new LE(n, 2, 1);
    return (
      t.setAttribute("instanceDistanceStart", new es(r, 1, 0)),
      t.setAttribute("instanceDistanceEnd", new es(r, 1, 1)),
      this
    );
  }
  raycast(t, e) {
    null === t.camera &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.'
      );
    const i = (void 0 !== t.params.Line2 && t.params.Line2.threshold) || 0,
      n = t.ray,
      r = t.camera,
      o = r.projectionMatrix,
      a = this.matrixWorld,
      s = this.geometry,
      l = this.material,
      u = l.resolution,
      c = l.linewidth + i,
      h = s.attributes.instanceStart,
      p = s.attributes.instanceEnd,
      d = -r.near;
    null === s.boundingSphere && s.computeBoundingSphere(),
      HD.copy(s.boundingSphere).applyMatrix4(a);
    const f = WD(r, Math.max(r.near, HD.distanceToPoint(n.origin)), c, u);
    if (((HD.radius += f), !1 === t.ray.intersectsSphere(HD))) return;
    null === s.boundingBox && s.computeBoundingBox(),
      jD.copy(s.boundingBox).applyMatrix4(a);
    const g = WD(r, Math.max(r.near, jD.distanceToPoint(n.origin)), c, u);
    if (
      ((jD.max.x += g),
      (jD.max.y += g),
      (jD.max.z += g),
      (jD.min.x -= g),
      (jD.min.y -= g),
      (jD.min.z -= g),
      !1 !== t.ray.intersectsBox(jD))
    ) {
      n.at(1, zD),
        (zD.w = 1),
        zD.applyMatrix4(r.matrixWorldInverse),
        zD.applyMatrix4(o),
        zD.multiplyScalar(1 / zD.w),
        (zD.x *= u.x / 2),
        (zD.y *= u.y / 2),
        (zD.z = 0),
        kD.copy(zD),
        BD.multiplyMatrices(r.matrixWorldInverse, a);
      for (let t = 0, i = h.count; t < i; t++) {
        OD.fromBufferAttribute(h, t),
          FD.fromBufferAttribute(p, t),
          (OD.w = 1),
          (FD.w = 1),
          OD.applyMatrix4(BD),
          FD.applyMatrix4(BD);
        if (OD.z > d && FD.z > d) continue;
        if (OD.z > d) {
          const t = OD.z - FD.z,
            e = (OD.z - d) / t;
          OD.lerp(FD, e);
        } else if (FD.z > d) {
          const t = FD.z - OD.z,
            e = (FD.z - d) / t;
          FD.lerp(OD, e);
        }
        OD.applyMatrix4(o),
          FD.applyMatrix4(o),
          OD.multiplyScalar(1 / OD.w),
          FD.multiplyScalar(1 / FD.w),
          (OD.x *= u.x / 2),
          (OD.y *= u.y / 2),
          (FD.x *= u.x / 2),
          (FD.y *= u.y / 2),
          GD.start.copy(OD),
          (GD.start.z = 0),
          GD.end.copy(FD),
          (GD.end.z = 0);
        const i = GD.closestPointToPointParameter(kD, !0);
        GD.at(i, UD);
        const r = Ee(OD.z, FD.z, i),
          s = r >= -1 && r <= 1,
          l = kD.distanceTo(UD) < 0.5 * c;
        if (s && l) {
          GD.start.fromBufferAttribute(h, t),
            GD.end.fromBufferAttribute(p, t),
            GD.start.applyMatrix4(a),
            GD.end.applyMatrix4(a);
          const i = new Ye(),
            r = new Ye();
          n.distanceSqToSegment(GD.start, GD.end, r, i),
            e.push({
              point: r,
              pointOnLine: i,
              distance: n.origin.distanceTo(r),
              object: this,
              face: null,
              faceIndex: t,
              uv: null,
              uv2: null,
            });
        }
      }
    }
  }
}
class YD extends ID {
  constructor() {
    super(), (this.isLineGeometry = !0), (this.type = "LineGeometry");
  }
  setPositions(t) {
    const e = t.length - 3,
      i = new Float32Array(2 * e);
    for (let n = 0; n < e; n += 3)
      (i[2 * n] = t[n]),
        (i[2 * n + 1] = t[n + 1]),
        (i[2 * n + 2] = t[n + 2]),
        (i[2 * n + 3] = t[n + 3]),
        (i[2 * n + 4] = t[n + 4]),
        (i[2 * n + 5] = t[n + 5]);
    return super.setPositions(i), this;
  }
  setColors(t) {
    const e = t.length - 3,
      i = new Float32Array(2 * e);
    for (let n = 0; n < e; n += 3)
      (i[2 * n] = t[n]),
        (i[2 * n + 1] = t[n + 1]),
        (i[2 * n + 2] = t[n + 2]),
        (i[2 * n + 3] = t[n + 3]),
        (i[2 * n + 4] = t[n + 4]),
        (i[2 * n + 5] = t[n + 5]);
    return super.setColors(i), this;
  }
  fromLine(t) {
    const e = t.geometry;
    if (!e.isGeometry)
      return (
        e.isBufferGeometry && this.setPositions(e.attributes.position.array),
        this
      );
    console.error(
      "@dp/gis-engine: LineGeometry no longer supports Geometry. Use BufferGeometry instead."
    );
  }
}
class XD extends qD {
  constructor(
    t = new YD(),
    e = new TD({
      color: 16777215 * Math.random(),
    })
  ) {
    super(t, e), (this.isLine2 = !0), (this.type = "Line2");
  }
}
new ln(0), new Le(1, 0), new Le(0, 1);
class QD {
  static isWebGLAvailable() {
    try {
      const t = document.createElement("canvas");
      if (window.WebGLRenderingContext) {
        const e = t.getContext("webgl") || t.getContext("experimental-webgl");
        return !!e && (e.getExtension("WEBGL_lose_context").loseContext(), !0);
      }
      return !1;
    } catch (t) {
      return !1;
    }
  }
  static isWebGL2Available() {
    try {
      const t = document.createElement("canvas");
      if (window.WebGLRenderingContext) {
        const e = t.getContext("webgl2");
        return !!e && (e.getExtension("WEBGL_lose_context").loseContext(), !0);
      }
      return !1;
    } catch (t) {
      return !1;
    }
  }
  static isGPUAcceleratorEnabled() {
    const t = document.createElement("canvas").getContext("webgl");
    let e = !0;
    if (t) {
      const i = t.getExtension("WEBGL_debug_renderer_info");
      if (i) {
        const n = t.getParameter(i.UNMASKED_RENDERER_WEBGL);
        (e = !/SwiftShader/gi.test(n)),
          t.getExtension("WEBGL_lose_context").loseContext();
      }
    }
    return e;
  }
  static getWebGLErrorMessage() {
    return this.getErrorMessage(1);
  }
  static getWebGL2ErrorMessage() {
    return this.getErrorMessage(2);
  }
  static getErrorMessage(t) {
    const e = {
      1: window.WebGLRenderingContext,
      2: window.WebGL2RenderingContext,
    };
    let i =
      'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';
    const n = document.createElement("div");
    return (
      (n.id = "webglmessage"),
      (n.style.fontFamily = "monospace"),
      (n.style.fontSize = "13px"),
      (n.style.fontWeight = "normal"),
      (n.style.textAlign = "center"),
      (n.style.background = "#fff"),
      (n.style.color = "#000"),
      (n.style.padding = "1.5em"),
      (n.style.width = "400px"),
      (n.style.margin = "5em auto 0"),
      (i = e[t]
        ? i.replace("$0", "graphics card")
        : i.replace("$0", "browser")),
      (i = i.replace(
        "$1",
        {
          1: "WebGL",
          2: "WebGL 2",
        }[t]
      )),
      (n.innerHTML = i),
      n
    );
  }
}
function ZD(t, e, i) {
  t.normalized
    ? t.setXYZW(e, 255 * i[0], 255 * i[1], 255 * i[2], 255 * i[3])
    : t.setXYZW(e, i[0], i[1], i[2], i[3]),
    (t.needsUpdate = !0);
}
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new Ye(),
  new tn();
var JD = Object.defineProperty,
  KD = Object.defineProperties,
  $D = Object.getOwnPropertyDescriptors,
  tT = Object.getOwnPropertySymbols,
  eT = Object.prototype.hasOwnProperty,
  iT = Object.prototype.propertyIsEnumerable,
  nT = (t, e, i) =>
    e in t
      ? JD(t, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: i,
        })
      : (t[e] = i),
  rT = (t, e) => {
    for (var i in e || (e = {})) eT.call(e, i) && nT(t, i, e[i]);
    if (tT) for (var i of tT(e)) iT.call(e, i) && nT(t, i, e[i]);
    return t;
  },
  oT = (t, e) => KD(t, $D(e));
for (let p7 = 0; p7 < 256; p7++) p7.toString(16);
const aT = (t, e) => {
  const { callback: i } = e;
  return i && (t = t.filter(i)), t;
};
class sT {
  constructor() {
    (this._partials = new Float64Array(32)), (this._n = 0);
  }
  add(t) {
    const e = this._partials;
    let i = 0;
    for (let n = 0; n < this._n && n < 32; n++) {
      const r = e[n],
        o = t + r,
        a = Math.abs(t) < Math.abs(r) ? t - (o - r) : r - (o - t);
      a && (e[i++] = a), (t = o);
    }
    return (e[i] = t), (this._n = i + 1), this;
  }
  valueOf() {
    const t = this._partials;
    let e,
      i,
      n,
      r = this._n,
      o = 0;
    if (r > 0) {
      for (
        o = t[--r];
        r > 0 && ((e = o), (i = t[--r]), (o = e + i), (n = i - (o - e)), !n);

      );
      r > 0 &&
        ((n < 0 && t[r - 1] < 0) || (n > 0 && t[r - 1] > 0)) &&
        ((i = 2 * n), (e = o + i), i == e - o && (o = e));
    }
    return o;
  }
}
function lT(t) {
  return Array.from(
    (function* (t) {
      for (const e of t) yield* e;
    })(t)
  );
}
var uT = 1e-6,
  cT = 1e-12,
  hT = Math.PI,
  pT = hT / 2,
  dT = hT / 4,
  fT = 2 * hT,
  gT = 180 / hT,
  mT = hT / 180,
  yT = Math.abs,
  vT = Math.atan,
  bT = Math.atan2,
  xT = Math.cos,
  _T = Math.exp,
  ST = Math.log,
  MT = Math.sin,
  CT =
    Math.sign ||
    function (t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    },
  wT = Math.sqrt,
  AT = Math.tan;
function ET(t) {
  return t > 1 ? pT : t < -1 ? -pT : Math.asin(t);
}
function DT() {}
function TT(t, e) {
  t && LT.hasOwnProperty(t.type) && LT[t.type](t, e);
}
var PT = {
    Feature: function (t, e) {
      TT(t.geometry, e);
    },
    FeatureCollection: function (t, e) {
      for (var i = t.features, n = -1, r = i.length; ++n < r; )
        TT(i[n].geometry, e);
    },
  },
  LT = {
    Sphere: function (t, e) {
      e.sphere();
    },
    Point: function (t, e) {
      (t = t.coordinates), e.point(t[0], t[1], t[2]);
    },
    MultiPoint: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; )
        (t = i[n]), e.point(t[0], t[1], t[2]);
    },
    LineString: function (t, e) {
      IT(t.coordinates, e, 0);
    },
    MultiLineString: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; )
        IT(i[n], e, 0);
    },
    Polygon: function (t, e) {
      NT(t.coordinates, e);
    },
    MultiPolygon: function (t, e) {
      for (var i = t.coordinates, n = -1, r = i.length; ++n < r; ) NT(i[n], e);
    },
    GeometryCollection: function (t, e) {
      for (var i = t.geometries, n = -1, r = i.length; ++n < r; ) TT(i[n], e);
    },
  };
function IT(t, e, i) {
  var n,
    r = -1,
    o = t.length - i;
  for (e.lineStart(); ++r < o; ) (n = t[r]), e.point(n[0], n[1], n[2]);
  e.lineEnd();
}
function NT(t, e) {
  var i = -1,
    n = t.length;
  for (e.polygonStart(); ++i < n; ) IT(t[i], e, 1);
  e.polygonEnd();
}
function RT(t, e) {
  t && PT.hasOwnProperty(t.type) ? PT[t.type](t, e) : TT(t, e);
}
function OT(t) {
  return [bT(t[1], t[0]), ET(t[2])];
}
function FT(t) {
  var e = t[0],
    i = t[1],
    n = xT(i);
  return [n * xT(e), n * MT(e), MT(i)];
}
function zT(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function kT(t, e) {
  return [
    t[1] * e[2] - t[2] * e[1],
    t[2] * e[0] - t[0] * e[2],
    t[0] * e[1] - t[1] * e[0],
  ];
}
function BT(t, e) {
  (t[0] += e[0]), (t[1] += e[1]), (t[2] += e[2]);
}
function GT(t, e) {
  return [t[0] * e, t[1] * e, t[2] * e];
}
function UT(t) {
  var e = wT(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  (t[0] /= e), (t[1] /= e), (t[2] /= e);
}
function jT(t, e) {
  function i(i, n) {
    return (i = t(i, n)), e(i[0], i[1]);
  }
  return (
    t.invert &&
      e.invert &&
      (i.invert = function (i, n) {
        return (i = e.invert(i, n)) && t.invert(i[0], i[1]);
      }),
    i
  );
}
function HT(t, e) {
  return [yT(t) > hT ? t + Math.round(-t / fT) * fT : t, e];
}
function VT(t, e, i) {
  return (t %= fT)
    ? e || i
      ? jT(qT(t), YT(e, i))
      : qT(t)
    : e || i
    ? YT(e, i)
    : HT;
}
function WT(t) {
  return function (e, i) {
    return [(e += t) > hT ? e - fT : e < -hT ? e + fT : e, i];
  };
}
function qT(t) {
  var e = WT(t);
  return (e.invert = WT(-t)), e;
}
function YT(t, e) {
  var i = xT(t),
    n = MT(t),
    r = xT(e),
    o = MT(e);
  function a(t, e) {
    var a = xT(e),
      s = xT(t) * a,
      l = MT(t) * a,
      u = MT(e),
      c = u * i + s * n;
    return [bT(l * r - c * o, s * i - u * n), ET(c * r + l * o)];
  }
  return (
    (a.invert = function (t, e) {
      var a = xT(e),
        s = xT(t) * a,
        l = MT(t) * a,
        u = MT(e),
        c = u * r - l * o;
      return [bT(l * r + u * o, s * i + c * n), ET(c * i - s * n)];
    }),
    a
  );
}
function XT(t, e) {
  ((e = FT(e))[0] -= t), UT(e);
  var i,
    n = (i = -e[1]) > 1 ? 0 : i < -1 ? hT : Math.acos(i);
  return ((-e[2] < 0 ? -n : n) + fT - uT) % fT;
}
function QT() {
  var t,
    e = [];
  return {
    point: function (e, i, n) {
      t.push([e, i, n]);
    },
    lineStart: function () {
      e.push((t = []));
    },
    lineEnd: DT,
    rejoin: function () {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function () {
      var i = e;
      return (e = []), (t = null), i;
    },
  };
}
function ZT(t, e) {
  return yT(t[0] - e[0]) < uT && yT(t[1] - e[1]) < uT;
}
function JT(t, e, i, n) {
  (this.x = t),
    (this.z = e),
    (this.o = i),
    (this.e = n),
    (this.v = !1),
    (this.n = this.p = null);
}
function KT(t, e, i, n, r) {
  var o,
    a,
    s = [],
    l = [];
  if (
    (t.forEach(function (t) {
      if (!((e = t.length - 1) <= 0)) {
        var e,
          i,
          n = t[0],
          a = t[e];
        if (ZT(n, a)) {
          if (!n[2] && !a[2]) {
            for (r.lineStart(), o = 0; o < e; ++o) r.point((n = t[o])[0], n[1]);
            return void r.lineEnd();
          }
          a[0] += 2 * uT;
        }
        s.push((i = new JT(n, t, null, !0))),
          l.push((i.o = new JT(n, null, i, !1))),
          s.push((i = new JT(a, t, null, !1))),
          l.push((i.o = new JT(a, null, i, !0)));
      }
    }),
    s.length)
  ) {
    for (l.sort(e), $T(s), $T(l), o = 0, a = l.length; o < a; ++o)
      l[o].e = i = !i;
    for (var u, c, h = s[0]; ; ) {
      for (var p = h, d = !0; p.v; ) if ((p = p.n) === h) return;
      (u = p.z), r.lineStart();
      do {
        if (((p.v = p.o.v = !0), p.e)) {
          if (d)
            for (o = 0, a = u.length; o < a; ++o) r.point((c = u[o])[0], c[1]);
          else n(p.x, p.n.x, 1, r);
          p = p.n;
        } else {
          if (d)
            for (u = p.p.z, o = u.length - 1; o >= 0; --o)
              r.point((c = u[o])[0], c[1]);
          else n(p.x, p.p.x, -1, r);
          p = p.p;
        }
        (u = (p = p.o).z), (d = !d);
      } while (!p.v);
      r.lineEnd();
    }
  }
}
function $T(t) {
  if ((e = t.length)) {
    for (var e, i, n = 0, r = t[0]; ++n < e; )
      (r.n = i = t[n]), (i.p = r), (r = i);
    (r.n = i = t[0]), (i.p = r);
  }
}
function tP(t) {
  return yT(t[0]) <= hT ? t[0] : CT(t[0]) * (((yT(t[0]) + hT) % fT) - hT);
}
function eP(t, e, i, n) {
  return function (r) {
    var o,
      a,
      s,
      l = e(r),
      u = QT(),
      c = e(u),
      h = !1,
      p = {
        point: d,
        lineStart: g,
        lineEnd: m,
        polygonStart: function () {
          (p.point = y), (p.lineStart = v), (p.lineEnd = b), (a = []), (o = []);
        },
        polygonEnd: function () {
          (p.point = d), (p.lineStart = g), (p.lineEnd = m), (a = lT(a));
          var t = (function (t, e) {
            var i = tP(e),
              n = e[1],
              r = MT(n),
              o = [MT(i), -xT(i), 0],
              a = 0,
              s = 0,
              l = new sT();
            1 === r ? (n = pT + uT) : -1 === r && (n = -pT - uT);
            for (var u = 0, c = t.length; u < c; ++u)
              if ((p = (h = t[u]).length))
                for (
                  var h,
                    p,
                    d = h[p - 1],
                    f = tP(d),
                    g = d[1] / 2 + dT,
                    m = MT(g),
                    y = xT(g),
                    v = 0;
                  v < p;
                  ++v, f = x, m = S, y = M, d = b
                ) {
                  var b = h[v],
                    x = tP(b),
                    _ = b[1] / 2 + dT,
                    S = MT(_),
                    M = xT(_),
                    C = x - f,
                    w = C >= 0 ? 1 : -1,
                    A = w * C,
                    E = A > hT,
                    D = m * S;
                  if (
                    (l.add(bT(D * w * MT(A), y * M + D * xT(A))),
                    (a += E ? C + w * fT : C),
                    E ^ (f >= i) ^ (x >= i))
                  ) {
                    var T = kT(FT(d), FT(b));
                    UT(T);
                    var P = kT(o, T);
                    UT(P);
                    var L = (E ^ (C >= 0) ? -1 : 1) * ET(P[2]);
                    (n > L || (n === L && (T[0] || T[1]))) &&
                      (s += E ^ (C >= 0) ? 1 : -1);
                  }
                }
            return (a < -uT || (a < uT && l < -cT)) ^ (1 & s);
          })(o, n);
          a.length
            ? (h || (r.polygonStart(), (h = !0)), KT(a, nP, t, i, r))
            : t &&
              (h || (r.polygonStart(), (h = !0)),
              r.lineStart(),
              i(null, null, 1, r),
              r.lineEnd()),
            h && (r.polygonEnd(), (h = !1)),
            (a = o = null);
        },
        sphere: function () {
          r.polygonStart(),
            r.lineStart(),
            i(null, null, 1, r),
            r.lineEnd(),
            r.polygonEnd();
        },
      };
    function d(e, i) {
      t(e, i) && r.point(e, i);
    }
    function f(t, e) {
      l.point(t, e);
    }
    function g() {
      (p.point = f), l.lineStart();
    }
    function m() {
      (p.point = d), l.lineEnd();
    }
    function y(t, e) {
      s.push([t, e]), c.point(t, e);
    }
    function v() {
      c.lineStart(), (s = []);
    }
    function b() {
      y(s[0][0], s[0][1]), c.lineEnd();
      var t,
        e,
        i,
        n,
        l = c.clean(),
        p = u.result(),
        d = p.length;
      if ((s.pop(), o.push(s), (s = null), d))
        if (1 & l) {
          if ((e = (i = p[0]).length - 1) > 0) {
            for (
              h || (r.polygonStart(), (h = !0)), r.lineStart(), t = 0;
              t < e;
              ++t
            )
              r.point((n = i[t])[0], n[1]);
            r.lineEnd();
          }
        } else
          d > 1 && 2 & l && p.push(p.pop().concat(p.shift())),
            a.push(p.filter(iP));
    }
    return p;
  };
}
function iP(t) {
  return t.length > 1;
}
function nP(t, e) {
  return (
    ((t = t.x)[0] < 0 ? t[1] - pT - uT : pT - t[1]) -
    ((e = e.x)[0] < 0 ? e[1] - pT - uT : pT - e[1])
  );
}
HT.invert = HT;
var rP = eP(
  function () {
    return !0;
  },
  function (t) {
    var e,
      i = NaN,
      n = NaN,
      r = NaN;
    return {
      lineStart: function () {
        t.lineStart(), (e = 1);
      },
      point: function (o, a) {
        var s = o > 0 ? hT : -hT,
          l = yT(o - i);
        yT(l - hT) < uT
          ? (t.point(i, (n = (n + a) / 2 > 0 ? pT : -pT)),
            t.point(r, n),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, n),
            t.point(o, n),
            (e = 0))
          : r !== s &&
            l >= hT &&
            (yT(i - r) < uT && (i -= r * uT),
            yT(o - s) < uT && (o -= s * uT),
            (n = (function (t, e, i, n) {
              var r,
                o,
                a = MT(t - i);
              return yT(a) > uT
                ? vT(
                    (MT(e) * (o = xT(n)) * MT(i) -
                      MT(n) * (r = xT(e)) * MT(t)) /
                      (r * o * a)
                  )
                : (e + n) / 2;
            })(i, n, o, a)),
            t.point(r, n),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, n),
            (e = 0)),
          t.point((i = o), (n = a)),
          (r = s);
      },
      lineEnd: function () {
        t.lineEnd(), (i = n = NaN);
      },
      clean: function () {
        return 2 - e;
      },
    };
  },
  function (t, e, i, n) {
    var r;
    if (null == t)
      (r = i * pT),
        n.point(-hT, r),
        n.point(0, r),
        n.point(hT, r),
        n.point(hT, 0),
        n.point(hT, -r),
        n.point(0, -r),
        n.point(-hT, -r),
        n.point(-hT, 0),
        n.point(-hT, r);
    else if (yT(t[0] - e[0]) > uT) {
      var o = t[0] < e[0] ? hT : -hT;
      (r = (i * o) / 2), n.point(-o, r), n.point(0, r), n.point(o, r);
    } else n.point(e[0], e[1]);
  },
  [-hT, -pT]
);
function oP(t) {
  var e = xT(t),
    i = 6 * mT,
    n = e > 0,
    r = yT(e) > uT;
  function o(t, i) {
    return xT(t) * xT(i) > e;
  }
  function a(t, i, n) {
    var r = [1, 0, 0],
      o = kT(FT(t), FT(i)),
      a = zT(o, o),
      s = o[0],
      l = a - s * s;
    if (!l) return !n && t;
    var u = (e * a) / l,
      c = (-e * s) / l,
      h = kT(r, o),
      p = GT(r, u);
    BT(p, GT(o, c));
    var d = h,
      f = zT(p, d),
      g = zT(d, d),
      m = f * f - g * (zT(p, p) - 1);
    if (!(m < 0)) {
      var y = wT(m),
        v = GT(d, (-f - y) / g);
      if ((BT(v, p), (v = OT(v)), !n)) return v;
      var b,
        x = t[0],
        _ = i[0],
        S = t[1],
        M = i[1];
      _ < x && ((b = x), (x = _), (_ = b));
      var C = _ - x,
        w = yT(C - hT) < uT;
      if (
        (!w && M < S && ((b = S), (S = M), (M = b)),
        w || C < uT
          ? w
            ? (S + M > 0) ^ (v[1] < (yT(v[0] - x) < uT ? S : M))
            : S <= v[1] && v[1] <= M
          : (C > hT) ^ (x <= v[0] && v[0] <= _))
      ) {
        var A = GT(d, (-f + y) / g);
        return BT(A, p), [v, OT(A)];
      }
    }
  }
  function s(e, i) {
    var r = n ? t : hT - t,
      o = 0;
    return (
      e < -r ? (o |= 1) : e > r && (o |= 2),
      i < -r ? (o |= 4) : i > r && (o |= 8),
      o
    );
  }
  return eP(
    o,
    function (t) {
      var e, i, l, u, c;
      return {
        lineStart: function () {
          (u = l = !1), (c = 1);
        },
        point: function (h, p) {
          var d,
            f = [h, p],
            g = o(h, p),
            m = n ? (g ? 0 : s(h, p)) : g ? s(h + (h < 0 ? hT : -hT), p) : 0;
          if (
            (!e && (u = l = g) && t.lineStart(),
            g !== l && (!(d = a(e, f)) || ZT(e, d) || ZT(f, d)) && (f[2] = 1),
            g !== l)
          )
            (c = 0),
              g
                ? (t.lineStart(), (d = a(f, e)), t.point(d[0], d[1]))
                : ((d = a(e, f)), t.point(d[0], d[1], 2), t.lineEnd()),
              (e = d);
          else if (r && e && n ^ g) {
            var y;
            m & i ||
              !(y = a(f, e, !0)) ||
              ((c = 0),
              n
                ? (t.lineStart(),
                  t.point(y[0][0], y[0][1]),
                  t.point(y[1][0], y[1][1]),
                  t.lineEnd())
                : (t.point(y[1][0], y[1][1]),
                  t.lineEnd(),
                  t.lineStart(),
                  t.point(y[0][0], y[0][1], 3)));
          }
          !g || (e && ZT(e, f)) || t.point(f[0], f[1]),
            (e = f),
            (l = g),
            (i = m);
        },
        lineEnd: function () {
          l && t.lineEnd(), (e = null);
        },
        clean: function () {
          return c | ((u && l) << 1);
        },
      };
    },
    function (e, n, r, o) {
      !(function (t, e, i, n, r, o) {
        if (i) {
          var a = xT(e),
            s = MT(e),
            l = n * i;
          null == r
            ? ((r = e + n * fT), (o = e - l / 2))
            : ((r = XT(a, r)),
              (o = XT(a, o)),
              (n > 0 ? r < o : r > o) && (r += n * fT));
          for (var u, c = r; n > 0 ? c > o : c < o; c -= l)
            (u = OT([a, -s * xT(c), -s * MT(c)])), t.point(u[0], u[1]);
        }
      })(o, t, i, r, e, n);
    },
    n ? [0, -t] : [-hT, t - hT]
  );
}
var aP = 1e9,
  sP = -aP;
function lP(t, e, i, n) {
  function r(r, o) {
    return t <= r && r <= i && e <= o && o <= n;
  }
  function o(r, o, s, u) {
    var c = 0,
      h = 0;
    if (null == r || (c = a(r, s)) !== (h = a(o, s)) || (l(r, o) < 0) ^ (s > 0))
      do {
        u.point(0 === c || 3 === c ? t : i, c > 1 ? n : e);
      } while ((c = (c + s + 4) % 4) !== h);
    else u.point(o[0], o[1]);
  }
  function a(n, r) {
    return yT(n[0] - t) < uT
      ? r > 0
        ? 0
        : 3
      : yT(n[0] - i) < uT
      ? r > 0
        ? 2
        : 1
      : yT(n[1] - e) < uT
      ? r > 0
        ? 1
        : 0
      : r > 0
      ? 3
      : 2;
  }
  function s(t, e) {
    return l(t.x, e.x);
  }
  function l(t, e) {
    var i = a(t, 1),
      n = a(e, 1);
    return i !== n
      ? i - n
      : 0 === i
      ? e[1] - t[1]
      : 1 === i
      ? t[0] - e[0]
      : 2 === i
      ? t[1] - e[1]
      : e[0] - t[0];
  }
  return function (a) {
    var l,
      u,
      c,
      h,
      p,
      d,
      f,
      g,
      m,
      y,
      v,
      b = a,
      x = QT(),
      _ = {
        point: S,
        lineStart: function () {
          (_.point = M), u && u.push((c = []));
          (y = !0), (m = !1), (f = g = NaN);
        },
        lineEnd: function () {
          l && (M(h, p), d && m && x.rejoin(), l.push(x.result()));
          (_.point = S), m && b.lineEnd();
        },
        polygonStart: function () {
          (b = x), (l = []), (u = []), (v = !0);
        },
        polygonEnd: function () {
          var e = (function () {
              for (var e = 0, i = 0, r = u.length; i < r; ++i)
                for (
                  var o,
                    a,
                    s = u[i],
                    l = 1,
                    c = s.length,
                    h = s[0],
                    p = h[0],
                    d = h[1];
                  l < c;
                  ++l
                )
                  (o = p),
                    (a = d),
                    (p = (h = s[l])[0]),
                    (d = h[1]),
                    a <= n
                      ? d > n && (p - o) * (n - a) > (d - a) * (t - o) && ++e
                      : d <= n && (p - o) * (n - a) < (d - a) * (t - o) && --e;
              return e;
            })(),
            i = v && e,
            r = (l = lT(l)).length;
          (i || r) &&
            (a.polygonStart(),
            i && (a.lineStart(), o(null, null, 1, a), a.lineEnd()),
            r && KT(l, s, e, o, a),
            a.polygonEnd());
          (b = a), (l = u = c = null);
        },
      };
    function S(t, e) {
      r(t, e) && b.point(t, e);
    }
    function M(o, a) {
      var s = r(o, a);
      if ((u && c.push([o, a]), y))
        (h = o),
          (p = a),
          (d = s),
          (y = !1),
          s && (b.lineStart(), b.point(o, a));
      else if (s && m) b.point(o, a);
      else {
        var l = [
            (f = Math.max(sP, Math.min(aP, f))),
            (g = Math.max(sP, Math.min(aP, g))),
          ],
          x = [
            (o = Math.max(sP, Math.min(aP, o))),
            (a = Math.max(sP, Math.min(aP, a))),
          ];
        !(function (t, e, i, n, r, o) {
          var a,
            s = t[0],
            l = t[1],
            u = 0,
            c = 1,
            h = e[0] - s,
            p = e[1] - l;
          if (((a = i - s), h || !(a > 0))) {
            if (((a /= h), h < 0)) {
              if (a < u) return;
              a < c && (c = a);
            } else if (h > 0) {
              if (a > c) return;
              a > u && (u = a);
            }
            if (((a = r - s), h || !(a < 0))) {
              if (((a /= h), h < 0)) {
                if (a > c) return;
                a > u && (u = a);
              } else if (h > 0) {
                if (a < u) return;
                a < c && (c = a);
              }
              if (((a = n - l), p || !(a > 0))) {
                if (((a /= p), p < 0)) {
                  if (a < u) return;
                  a < c && (c = a);
                } else if (p > 0) {
                  if (a > c) return;
                  a > u && (u = a);
                }
                if (((a = o - l), p || !(a < 0))) {
                  if (((a /= p), p < 0)) {
                    if (a > c) return;
                    a > u && (u = a);
                  } else if (p > 0) {
                    if (a < u) return;
                    a < c && (c = a);
                  }
                  return (
                    u > 0 && ((t[0] = s + u * h), (t[1] = l + u * p)),
                    c < 1 && ((e[0] = s + c * h), (e[1] = l + c * p)),
                    !0
                  );
                }
              }
            }
          }
        })(l, x, t, e, i, n)
          ? s && (b.lineStart(), b.point(o, a), (v = !1))
          : (m || (b.lineStart(), b.point(l[0], l[1])),
            b.point(x[0], x[1]),
            s || b.lineEnd(),
            (v = !1));
      }
      (f = o), (g = a), (m = s);
    }
    return _;
  };
}
var uP,
  cP,
  hP,
  pP,
  dP = (t) => t,
  fP = new sT(),
  gP = new sT(),
  mP = {
    point: DT,
    lineStart: DT,
    lineEnd: DT,
    polygonStart: function () {
      (mP.lineStart = yP), (mP.lineEnd = xP);
    },
    polygonEnd: function () {
      (mP.lineStart = mP.lineEnd = mP.point = DT),
        fP.add(yT(gP)),
        (gP = new sT());
    },
    result: function () {
      var t = fP / 2;
      return (fP = new sT()), t;
    },
  };
function yP() {
  mP.point = vP;
}
function vP(t, e) {
  (mP.point = bP), (uP = hP = t), (cP = pP = e);
}
function bP(t, e) {
  gP.add(pP * t - hP * e), (hP = t), (pP = e);
}
function xP() {
  bP(uP, cP);
}
var _P = mP,
  SP = 1 / 0,
  MP = SP,
  CP = -SP,
  wP = CP;
var AP,
  EP,
  DP,
  TP,
  PP = {
    point: function (t, e) {
      t < SP && (SP = t);
      t > CP && (CP = t);
      e < MP && (MP = e);
      e > wP && (wP = e);
    },
    lineStart: DT,
    lineEnd: DT,
    polygonStart: DT,
    polygonEnd: DT,
    result: function () {
      var t = [
        [SP, MP],
        [CP, wP],
      ];
      return (CP = wP = -(MP = SP = 1 / 0)), t;
    },
  },
  LP = 0,
  IP = 0,
  NP = 0,
  RP = 0,
  OP = 0,
  FP = 0,
  zP = 0,
  kP = 0,
  BP = 0,
  GP = {
    point: UP,
    lineStart: jP,
    lineEnd: WP,
    polygonStart: function () {
      (GP.lineStart = qP), (GP.lineEnd = YP);
    },
    polygonEnd: function () {
      (GP.point = UP), (GP.lineStart = jP), (GP.lineEnd = WP);
    },
    result: function () {
      var t = BP
        ? [zP / BP, kP / BP]
        : FP
        ? [RP / FP, OP / FP]
        : NP
        ? [LP / NP, IP / NP]
        : [NaN, NaN];
      return (LP = IP = NP = RP = OP = FP = zP = kP = BP = 0), t;
    },
  };
function UP(t, e) {
  (LP += t), (IP += e), ++NP;
}
function jP() {
  GP.point = HP;
}
function HP(t, e) {
  (GP.point = VP), UP((DP = t), (TP = e));
}
function VP(t, e) {
  var i = t - DP,
    n = e - TP,
    r = wT(i * i + n * n);
  (RP += (r * (DP + t)) / 2),
    (OP += (r * (TP + e)) / 2),
    (FP += r),
    UP((DP = t), (TP = e));
}
function WP() {
  GP.point = UP;
}
function qP() {
  GP.point = XP;
}
function YP() {
  QP(AP, EP);
}
function XP(t, e) {
  (GP.point = QP), UP((AP = DP = t), (EP = TP = e));
}
function QP(t, e) {
  var i = t - DP,
    n = e - TP,
    r = wT(i * i + n * n);
  (RP += (r * (DP + t)) / 2),
    (OP += (r * (TP + e)) / 2),
    (FP += r),
    (zP += (r = TP * t - DP * e) * (DP + t)),
    (kP += r * (TP + e)),
    (BP += 3 * r),
    UP((DP = t), (TP = e));
}
var ZP = GP;
function JP(t) {
  this._context = t;
}
JP.prototype = {
  _radius: 4.5,
  pointRadius: function (t) {
    return (this._radius = t), this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    0 === this._line && this._context.closePath(), (this._point = NaN);
  },
  point: function (t, e) {
    switch (this._point) {
      case 0:
        this._context.moveTo(t, e), (this._point = 1);
        break;
      case 1:
        this._context.lineTo(t, e);
        break;
      default:
        this._context.moveTo(t + this._radius, e),
          this._context.arc(t, e, this._radius, 0, fT);
    }
  },
  result: DT,
};
var KP,
  $P,
  tL,
  eL,
  iL,
  nL = new sT(),
  rL = {
    point: DT,
    lineStart: function () {
      rL.point = oL;
    },
    lineEnd: function () {
      KP && aL($P, tL), (rL.point = DT);
    },
    polygonStart: function () {
      KP = !0;
    },
    polygonEnd: function () {
      KP = null;
    },
    result: function () {
      var t = +nL;
      return (nL = new sT()), t;
    },
  };
function oL(t, e) {
  (rL.point = aL), ($P = eL = t), (tL = iL = e);
}
function aL(t, e) {
  (eL -= t), (iL -= e), nL.add(wT(eL * eL + iL * iL)), (eL = t), (iL = e);
}
var sL = rL;
function lL() {
  this._string = [];
}
function uL(t) {
  return (
    "m0," +
    t +
    "a" +
    t +
    "," +
    t +
    " 0 1,1 0," +
    -2 * t +
    "a" +
    t +
    "," +
    t +
    " 0 1,1 0," +
    2 * t +
    "z"
  );
}
function cL(t) {
  return function (e) {
    var i = new hL();
    for (var n in t) i[n] = t[n];
    return (i.stream = e), i;
  };
}
function hL() {}
function pL(t, e, i) {
  var n = t.clipExtent && t.clipExtent();
  return (
    t.scale(150).translate([0, 0]),
    null != n && t.clipExtent(null),
    RT(i, t.stream(PP)),
    e(PP.result()),
    null != n && t.clipExtent(n),
    t
  );
}
function dL(t, e, i) {
  return pL(
    t,
    function (i) {
      var n = e[1][0] - e[0][0],
        r = e[1][1] - e[0][1],
        o = Math.min(n / (i[1][0] - i[0][0]), r / (i[1][1] - i[0][1])),
        a = +e[0][0] + (n - o * (i[1][0] + i[0][0])) / 2,
        s = +e[0][1] + (r - o * (i[1][1] + i[0][1])) / 2;
      t.scale(150 * o).translate([a, s]);
    },
    i
  );
}
(lL.prototype = {
  _radius: 4.5,
  _circle: uL(4.5),
  pointRadius: function (t) {
    return (
      (t = +t) !== this._radius && ((this._radius = t), (this._circle = null)),
      this
    );
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    0 === this._line && this._string.push("Z"), (this._point = NaN);
  },
  point: function (t, e) {
    switch (this._point) {
      case 0:
        this._string.push("M", t, ",", e), (this._point = 1);
        break;
      case 1:
        this._string.push("L", t, ",", e);
        break;
      default:
        null == this._circle && (this._circle = uL(this._radius)),
          this._string.push("M", t, ",", e, this._circle);
    }
  },
  result: function () {
    if (this._string.length) {
      var t = this._string.join("");
      return (this._string = []), t;
    }
    return null;
  },
}),
  (hL.prototype = {
    constructor: hL,
    point: function (t, e) {
      this.stream.point(t, e);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    },
  });
var fL = 16,
  gL = xT(30 * mT);
function mL(t, e) {
  return +e
    ? (function (t, e) {
        function i(n, r, o, a, s, l, u, c, h, p, d, f, g, m) {
          var y = u - n,
            v = c - r,
            b = y * y + v * v;
          if (b > 4 * e && g--) {
            var x = a + p,
              _ = s + d,
              S = l + f,
              M = wT(x * x + _ * _ + S * S),
              C = ET((S /= M)),
              w = yT(yT(S) - 1) < uT || yT(o - h) < uT ? (o + h) / 2 : bT(_, x),
              A = t(w, C),
              E = A[0],
              D = A[1],
              T = E - n,
              P = D - r,
              L = v * T - y * P;
            ((L * L) / b > e ||
              yT((y * T + v * P) / b - 0.5) > 0.3 ||
              a * p + s * d + l * f < gL) &&
              (i(n, r, o, a, s, l, E, D, w, (x /= M), (_ /= M), S, g, m),
              m.point(E, D),
              i(E, D, w, x, _, S, u, c, h, p, d, f, g, m));
          }
        }
        return function (e) {
          var n,
            r,
            o,
            a,
            s,
            l,
            u,
            c,
            h,
            p,
            d,
            f,
            g = {
              point: m,
              lineStart: y,
              lineEnd: b,
              polygonStart: function () {
                e.polygonStart(), (g.lineStart = x);
              },
              polygonEnd: function () {
                e.polygonEnd(), (g.lineStart = y);
              },
            };
          function m(i, n) {
            (i = t(i, n)), e.point(i[0], i[1]);
          }
          function y() {
            (c = NaN), (g.point = v), e.lineStart();
          }
          function v(n, r) {
            var o = FT([n, r]),
              a = t(n, r);
            i(
              c,
              h,
              u,
              p,
              d,
              f,
              (c = a[0]),
              (h = a[1]),
              (u = n),
              (p = o[0]),
              (d = o[1]),
              (f = o[2]),
              fL,
              e
            ),
              e.point(c, h);
          }
          function b() {
            (g.point = m), e.lineEnd();
          }
          function x() {
            y(), (g.point = _), (g.lineEnd = S);
          }
          function _(t, e) {
            v((n = t), e),
              (r = c),
              (o = h),
              (a = p),
              (s = d),
              (l = f),
              (g.point = v);
          }
          function S() {
            i(c, h, u, p, d, f, r, o, n, a, s, l, fL, e), (g.lineEnd = b), b();
          }
          return g;
        };
      })(t, e)
    : (function (t) {
        return cL({
          point: function (e, i) {
            (e = t(e, i)), this.stream.point(e[0], e[1]);
          },
        });
      })(t);
}
var yL = cL({
  point: function (t, e) {
    this.stream.point(t * mT, e * mT);
  },
});
function vL(t, e, i, n, r, o) {
  if (!o)
    return (function (t, e, i, n, r) {
      function o(o, a) {
        return [e + t * (o *= n), i - t * (a *= r)];
      }
      return (
        (o.invert = function (o, a) {
          return [((o - e) / t) * n, ((i - a) / t) * r];
        }),
        o
      );
    })(t, e, i, n, r);
  var a = xT(o),
    s = MT(o),
    l = a * t,
    u = s * t,
    c = a / t,
    h = s / t,
    p = (s * i - a * e) / t,
    d = (s * e + a * i) / t;
  function f(t, o) {
    return [l * (t *= n) - u * (o *= r) + e, i - u * t - l * o];
  }
  return (
    (f.invert = function (t, e) {
      return [n * (c * t - h * e + p), r * (d - h * t - c * e)];
    }),
    f
  );
}
function bL(t) {
  return (function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h = 150,
      p = 480,
      d = 250,
      f = 0,
      g = 0,
      m = 0,
      y = 0,
      v = 0,
      b = 0,
      x = 1,
      _ = 1,
      S = null,
      M = rP,
      C = null,
      w = dP,
      A = 0.5;
    function E(t) {
      return l(t[0] * mT, t[1] * mT);
    }
    function D(t) {
      return (t = l.invert(t[0], t[1])) && [t[0] * gT, t[1] * gT];
    }
    function T() {
      var t = vL(h, 0, 0, x, _, b).apply(null, e(f, g)),
        n = vL(h, p - t[0], d - t[1], x, _, b);
      return (
        (i = VT(m, y, v)), (s = jT(e, n)), (l = jT(i, s)), (a = mL(s, A)), P()
      );
    }
    function P() {
      return (u = c = null), E;
    }
    return (
      (E.stream = function (t) {
        return u && c === t
          ? u
          : (u = yL(
              (function (t) {
                return cL({
                  point: function (e, i) {
                    var n = t(e, i);
                    return this.stream.point(n[0], n[1]);
                  },
                });
              })(i)(M(a(w((c = t)))))
            ));
      }),
      (E.preclip = function (t) {
        return arguments.length ? ((M = t), (S = void 0), P()) : M;
      }),
      (E.postclip = function (t) {
        return arguments.length ? ((w = t), (C = n = r = o = null), P()) : w;
      }),
      (E.clipAngle = function (t) {
        return arguments.length
          ? ((M = +t ? oP((S = t * mT)) : ((S = null), rP)), P())
          : S * gT;
      }),
      (E.clipExtent = function (t) {
        return arguments.length
          ? ((w =
              null == t
                ? ((C = n = r = o = null), dP)
                : lP(
                    (C = +t[0][0]),
                    (n = +t[0][1]),
                    (r = +t[1][0]),
                    (o = +t[1][1])
                  )),
            P())
          : null == C
          ? null
          : [
              [C, n],
              [r, o],
            ];
      }),
      (E.scale = function (t) {
        return arguments.length ? ((h = +t), T()) : h;
      }),
      (E.translate = function (t) {
        return arguments.length ? ((p = +t[0]), (d = +t[1]), T()) : [p, d];
      }),
      (E.center = function (t) {
        return arguments.length
          ? ((f = (t[0] % 360) * mT), (g = (t[1] % 360) * mT), T())
          : [f * gT, g * gT];
      }),
      (E.rotate = function (t) {
        return arguments.length
          ? ((m = (t[0] % 360) * mT),
            (y = (t[1] % 360) * mT),
            (v = t.length > 2 ? (t[2] % 360) * mT : 0),
            T())
          : [m * gT, y * gT, v * gT];
      }),
      (E.angle = function (t) {
        return arguments.length ? ((b = (t % 360) * mT), T()) : b * gT;
      }),
      (E.reflectX = function (t) {
        return arguments.length ? ((x = t ? -1 : 1), T()) : x < 0;
      }),
      (E.reflectY = function (t) {
        return arguments.length ? ((_ = t ? -1 : 1), T()) : _ < 0;
      }),
      (E.precision = function (t) {
        return arguments.length ? ((a = mL(s, (A = t * t))), P()) : wT(A);
      }),
      (E.fitExtent = function (t, e) {
        return dL(E, t, e);
      }),
      (E.fitSize = function (t, e) {
        return (function (t, e, i) {
          return dL(t, [[0, 0], e], i);
        })(E, t, e);
      }),
      (E.fitWidth = function (t, e) {
        return (function (t, e, i) {
          return pL(
            t,
            function (i) {
              var n = +e,
                r = n / (i[1][0] - i[0][0]),
                o = (n - r * (i[1][0] + i[0][0])) / 2,
                a = -r * i[0][1];
              t.scale(150 * r).translate([o, a]);
            },
            i
          );
        })(E, t, e);
      }),
      (E.fitHeight = function (t, e) {
        return (function (t, e, i) {
          return pL(
            t,
            function (i) {
              var n = +e,
                r = n / (i[1][1] - i[0][1]),
                o = -r * i[0][0],
                a = (n - r * (i[1][1] + i[0][1])) / 2;
              t.scale(150 * r).translate([o, a]);
            },
            i
          );
        })(E, t, e);
      }),
      function () {
        return (e = t.apply(this, arguments)), (E.invert = e.invert && D), T();
      }
    );
  })(function () {
    return t;
  })();
}
function xL(t, e) {
  return [t, ST(AT((pT + e) / 2))];
}
xL.invert = function (t, e) {
  return [t, 2 * vT(_T(e)) - pT];
};
const _L = (function (t) {
  var e,
    i,
    n,
    r = bL(t),
    o = r.center,
    a = r.scale,
    s = r.translate,
    l = r.clipExtent,
    u = null;
  function c() {
    var o = hT * a(),
      s = r(
        (function (t) {
          function e(e) {
            return ((e = t(e[0] * mT, e[1] * mT))[0] *= gT), (e[1] *= gT), e;
          }
          return (
            (t = VT(t[0] * mT, t[1] * mT, t.length > 2 ? t[2] * mT : 0)),
            (e.invert = function (e) {
              return (
                ((e = t.invert(e[0] * mT, e[1] * mT))[0] *= gT), (e[1] *= gT), e
              );
            }),
            e
          );
        })(r.rotate()).invert([0, 0])
      );
    return l(
      null == u
        ? [
            [s[0] - o, s[1] - o],
            [s[0] + o, s[1] + o],
          ]
        : t === xL
        ? [
            [Math.max(s[0] - o, u), e],
            [Math.min(s[0] + o, i), n],
          ]
        : [
            [u, Math.max(s[1] - o, e)],
            [i, Math.min(s[1] + o, n)],
          ]
    );
  }
  return (
    (r.scale = function (t) {
      return arguments.length ? (a(t), c()) : a();
    }),
    (r.translate = function (t) {
      return arguments.length ? (s(t), c()) : s();
    }),
    (r.center = function (t) {
      return arguments.length ? (o(t), c()) : o();
    }),
    (r.clipExtent = function (t) {
      return arguments.length
        ? (null == t
            ? (u = e = i = n = null)
            : ((u = +t[0][0]), (e = +t[0][1]), (i = +t[1][0]), (n = +t[1][1])),
          c())
        : null == u
        ? null
        : [
            [u, e],
            [i, n],
          ];
    }),
    c()
  );
})(xL)
  .scale(961 / fT)
  .translate([0, 0])
  .center([0, 0])
  .scale(63781);
const SL = {
    webmercator: function (t) {
      const e = _L;
      if (void 0 === t[2]) {
        const i = e(t);
        return (i[1] *= -1), i;
      }
      {
        const i = e(t);
        return (i[1] *= -1), i.push(t[2]), i;
      }
    },
  },
  ML = (t, e) => {
    if (!t || 0 == t.length) return t;
    const { projection: i, as: n } = e,
      r = SL[i];
    if (t[0].lng) {
      return t.map((t) =>
        oT(rT({}, t), {
          [n]: r([t.lng, t.lat]),
        })
      );
    }
    return t.map((t) => {
      const { coordinates: e } = t.geometry || {};
      if (!Array.isArray(e[0])) {
        const i = r(e);
        return oT(rT({}, t), {
          [n]: i,
        });
      }
      const i = e.map((t) => (Array.isArray(t[0]) ? t.map((t) => r(t)) : r(t)));
      return oT(rT({}, t), {
        [n]: i,
        geometry: oT(rT({}, t.geometry), {
          [n]: i,
        }),
      });
    });
  };
function CL(t) {
  if (t.__esModule) return t;
  var e = Object.defineProperty({}, "__esModule", {
    value: !0,
  });
  return (
    Object.keys(t).forEach(function (i) {
      var n = Object.getOwnPropertyDescriptor(t, i);
      Object.defineProperty(
        e,
        i,
        n.get
          ? n
          : {
              enumerable: !0,
              get: function () {
                return t[i];
              },
            }
      );
    }),
    e
  );
}
var wL = Object.prototype.hasOwnProperty;
function AL(t, e, i, n, r, o) {
  3 === arguments.length && ((n = o = Array), (r = null));
  for (
    var a = new n((t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))),
      s = new o(t),
      l = t - 1,
      u = 0;
    u < t;
    ++u
  )
    a[u] = r;
  return {
    set: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return (s[u] = o);
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    maybeSet: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    get: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) break;
        c = a[(u = (u + 1) & l)];
      }
      return o;
    },
    keys: function () {
      for (var t = [], e = 0, i = a.length; e < i; ++e) {
        var n = a[e];
        n != r && t.push(n);
      }
      return t;
    },
  };
}
function EL(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
var DL = new ArrayBuffer(16),
  TL = new Float64Array(DL),
  PL = new Uint32Array(DL);
function LL(t) {
  (TL[0] = t[0]), (TL[1] = t[1]);
  var e = PL[0] ^ PL[1];
  return 2147483647 & (e = (e << 5) ^ (e >> 7) ^ PL[2] ^ PL[3]);
}
function IL(t) {
  var e,
    i,
    n,
    r,
    o = t.coordinates,
    a = t.lines,
    s = t.rings,
    l = (function () {
      for (
        var t = AL(1.4 * o.length, _, S, Int32Array, -1, Int32Array),
          e = new Int32Array(o.length),
          i = 0,
          n = o.length;
        i < n;
        ++i
      )
        e[i] = t.maybeSet(i, i);
      return e;
    })(),
    u = new Int32Array(o.length),
    c = new Int32Array(o.length),
    h = new Int32Array(o.length),
    p = new Int8Array(o.length),
    d = 0;
  for (e = 0, i = o.length; e < i; ++e) u[e] = c[e] = h[e] = -1;
  for (e = 0, i = a.length; e < i; ++e) {
    var f = a[e],
      g = f[0],
      m = f[1];
    for (n = l[g], r = l[++g], ++d, p[n] = 1; ++g <= m; )
      x(e, n, (n = r), (r = l[g]));
    ++d, (p[r] = 1);
  }
  for (e = 0, i = o.length; e < i; ++e) u[e] = -1;
  for (e = 0, i = s.length; e < i; ++e) {
    var y = s[e],
      v = y[0] + 1,
      b = y[1];
    for (x(e, l[b - 1], (n = l[v - 1]), (r = l[v])); ++v <= b; )
      x(e, n, (n = r), (r = l[v]));
  }
  function x(t, e, i, n) {
    if (u[i] !== t) {
      u[i] = t;
      var r = c[i];
      if (r >= 0) {
        var o = h[i];
        (r === e && o === n) || (r === n && o === e) || (++d, (p[i] = 1));
      } else (c[i] = e), (h[i] = n);
    }
  }
  function _(t) {
    return LL(o[t]);
  }
  function S(t, e) {
    return EL(o[t], o[e]);
  }
  u = c = h = null;
  var M,
    C = (function (t, e, i, n, r) {
      3 === arguments.length && ((n = Array), (r = null));
      for (
        var o = new n(
            (t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))
          ),
          a = t - 1,
          s = 0;
        s < t;
        ++s
      )
        o[s] = r;
      return {
        add: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) throw new Error("full hashset");
            l = o[(s = (s + 1) & a)];
          }
          return (o[s] = n), !0;
        },
        has: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) break;
            l = o[(s = (s + 1) & a)];
          }
          return !1;
        },
        values: function () {
          for (var t = [], e = 0, i = o.length; e < i; ++e) {
            var n = o[e];
            n != r && t.push(n);
          }
          return t;
        },
      };
    })(1.4 * d, LL, EL);
  for (e = 0, i = o.length; e < i; ++e) p[(M = l[e])] && C.add(o[M]);
  return C;
}
function NL(t, e, i, n) {
  RL(t, e, i), RL(t, e, e + n), RL(t, e + n, i);
}
function RL(t, e, i) {
  for (var n, r = e + ((i-- - e) >> 1); e < r; ++e, --i)
    (n = t[e]), (t[e] = t[i]), (t[i] = n);
}
function OL(t) {
  var e,
    i,
    n = {};
  for (e in t)
    n[e] =
      null == (i = t[e])
        ? {
            type: null,
          }
        : ("FeatureCollection" === i.type
            ? FL
            : "Feature" === i.type
            ? zL
            : kL)(i);
  return n;
}
function FL(t) {
  var e = {
    type: "GeometryCollection",
    geometries: t.features.map(zL),
  };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function zL(t) {
  var e,
    i = kL(t.geometry);
  for (e in (null != t.id && (i.id = t.id),
  null != t.bbox && (i.bbox = t.bbox),
  t.properties)) {
    i.properties = t.properties;
    break;
  }
  return i;
}
function kL(t) {
  if (null == t)
    return {
      type: null,
    };
  var e =
    "GeometryCollection" === t.type
      ? {
          type: "GeometryCollection",
          geometries: t.geometries.map(kL),
        }
      : "Point" === t.type || "MultiPoint" === t.type
      ? {
          type: t.type,
          coordinates: t.coordinates,
        }
      : {
          type: t.type,
          arcs: t.coordinates,
        };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function BL(t) {
  var e,
    i = t[0],
    n = t[1];
  return n < i && ((e = i), (i = n), (n = e)), i + 31 * n;
}
function GL(t, e) {
  var i,
    n = t[0],
    r = t[1],
    o = e[0],
    a = e[1];
  return (
    r < n && ((i = n), (n = r), (r = i)),
    a < o && ((i = o), (o = a), (a = i)),
    n === o && r === a
  );
}
var UL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        topology: function (t, e) {
          var i = (function (t) {
              var e = 1 / 0,
                i = 1 / 0,
                n = -1 / 0,
                r = -1 / 0;
              function o(t) {
                null != t && wL.call(a, t.type) && a[t.type](t);
              }
              var a = {
                GeometryCollection: function (t) {
                  t.geometries.forEach(o);
                },
                Point: function (t) {
                  s(t.coordinates);
                },
                MultiPoint: function (t) {
                  t.coordinates.forEach(s);
                },
                LineString: function (t) {
                  l(t.arcs);
                },
                MultiLineString: function (t) {
                  t.arcs.forEach(l);
                },
                Polygon: function (t) {
                  t.arcs.forEach(l);
                },
                MultiPolygon: function (t) {
                  t.arcs.forEach(u);
                },
              };
              function s(t) {
                var o = t[0],
                  a = t[1];
                o < e && (e = o),
                  o > n && (n = o),
                  a < i && (i = a),
                  a > r && (r = a);
              }
              function l(t) {
                t.forEach(s);
              }
              function u(t) {
                t.forEach(l);
              }
              for (var c in t) o(t[c]);
              return n >= e && r >= i ? [e, i, n, r] : void 0;
            })((t = OL(t))),
            n =
              e > 0 &&
              i &&
              (function (t, e, i) {
                var n = e[0],
                  r = e[1],
                  o = e[2],
                  a = e[3],
                  s = o - n ? (i - 1) / (o - n) : 1,
                  l = a - r ? (i - 1) / (a - r) : 1;
                function u(t) {
                  return [
                    Math.round((t[0] - n) * s),
                    Math.round((t[1] - r) * l),
                  ];
                }
                function c(t, e) {
                  for (
                    var i,
                      o,
                      a,
                      u,
                      c,
                      h = -1,
                      p = 0,
                      d = t.length,
                      f = new Array(d);
                    ++h < d;

                  )
                    (i = t[h]),
                      (u = Math.round((i[0] - n) * s)),
                      (c = Math.round((i[1] - r) * l)),
                      (u === o && c === a) || (f[p++] = [(o = u), (a = c)]);
                  for (f.length = p; p < e; ) p = f.push([f[0][0], f[0][1]]);
                  return f;
                }
                function h(t) {
                  return c(t, 2);
                }
                function p(t) {
                  return c(t, 4);
                }
                function d(t) {
                  return t.map(p);
                }
                function f(t) {
                  null != t && wL.call(g, t.type) && g[t.type](t);
                }
                var g = {
                  GeometryCollection: function (t) {
                    t.geometries.forEach(f);
                  },
                  Point: function (t) {
                    t.coordinates = u(t.coordinates);
                  },
                  MultiPoint: function (t) {
                    t.coordinates = t.coordinates.map(u);
                  },
                  LineString: function (t) {
                    t.arcs = h(t.arcs);
                  },
                  MultiLineString: function (t) {
                    t.arcs = t.arcs.map(h);
                  },
                  Polygon: function (t) {
                    t.arcs = d(t.arcs);
                  },
                  MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(d);
                  },
                };
                for (var m in t) f(t[m]);
                return {
                  scale: [1 / s, 1 / l],
                  translate: [n, r],
                };
              })(t, i, e),
            r = (function (t) {
              var e,
                i,
                n,
                r,
                o = t.coordinates,
                a = t.lines,
                s = t.rings,
                l = a.length + s.length;
              for (
                delete t.lines, delete t.rings, n = 0, r = a.length;
                n < r;
                ++n
              )
                for (e = a[n]; (e = e.next); ) ++l;
              for (n = 0, r = s.length; n < r; ++n)
                for (i = s[n]; (i = i.next); ) ++l;
              var u = AL(2 * l * 1.4, LL, EL),
                c = (t.arcs = []);
              for (n = 0, r = a.length; n < r; ++n) {
                e = a[n];
                do {
                  h(e);
                } while ((e = e.next));
              }
              for (n = 0, r = s.length; n < r; ++n)
                if ((i = s[n]).next)
                  do {
                    h(i);
                  } while ((i = i.next));
                else p(i);
              function h(t) {
                var e, i, n, r, a, s, l, h;
                if ((n = u.get((e = o[t[0]]))))
                  for (l = 0, h = n.length; l < h; ++l)
                    if (d((r = n[l]), t))
                      return (t[0] = r[0]), void (t[1] = r[1]);
                if ((a = u.get((i = o[t[1]]))))
                  for (l = 0, h = a.length; l < h; ++l)
                    if (f((s = a[l]), t))
                      return (t[1] = s[0]), void (t[0] = s[1]);
                n ? n.push(t) : u.set(e, [t]),
                  a ? a.push(t) : u.set(i, [t]),
                  c.push(t);
              }
              function p(t) {
                var e, i, n, r, a;
                if ((i = u.get(o[t[0]])))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                if ((i = u.get((e = o[t[0] + y(t)]))))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                i ? i.push(t) : u.set(e, [t]), c.push(t);
              }
              function d(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1];
                if (i - r != n - e[1]) return !1;
                for (; i <= r; ++i, ++n) if (!EL(o[i], o[n])) return !1;
                return !0;
              }
              function f(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1];
                if (i - r != n - a) return !1;
                for (; i <= r; ++i, --a) if (!EL(o[i], o[a])) return !1;
                return !0;
              }
              function g(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1] - i;
                if (r !== e[1] - n) return !1;
                for (var a = y(t), s = y(e), l = 0; l < r; ++l)
                  if (!EL(o[i + ((l + a) % r)], o[n + ((l + s) % r)]))
                    return !1;
                return !0;
              }
              function m(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1],
                  s = r - i;
                if (s !== a - n) return !1;
                for (var l = y(t), u = s - y(e), c = 0; c < s; ++c)
                  if (!EL(o[i + ((c + l) % s)], o[a - ((c + u) % s)]))
                    return !1;
                return !0;
              }
              function y(t) {
                for (
                  var e = t[0], i = t[1], n = e, r = n, a = o[n];
                  ++n < i;

                ) {
                  var s = o[n];
                  (s[0] < a[0] || (s[0] === a[0] && s[1] < a[1])) &&
                    ((r = n), (a = s));
                }
                return r - e;
              }
              return t;
            })(
              (function (t) {
                var e,
                  i,
                  n,
                  r = IL(t),
                  o = t.coordinates,
                  a = t.lines,
                  s = t.rings;
                for (i = 0, n = a.length; i < n; ++i)
                  for (var l = a[i], u = l[0], c = l[1]; ++u < c; )
                    r.has(o[u]) &&
                      ((e = {
                        0: u,
                        1: l[1],
                      }),
                      (l[1] = u),
                      (l = l.next = e));
                for (i = 0, n = s.length; i < n; ++i)
                  for (
                    var h = s[i], p = h[0], d = p, f = h[1], g = r.has(o[p]);
                    ++d < f;

                  )
                    r.has(o[d]) &&
                      (g
                        ? ((e = {
                            0: d,
                            1: h[1],
                          }),
                          (h[1] = d),
                          (h = h.next = e))
                        : (NL(o, p, f, f - d),
                          (o[f] = o[p]),
                          (g = !0),
                          (d = p)));
                return t;
              })(
                (function (t) {
                  var e = -1,
                    i = [],
                    n = [],
                    r = [];
                  function o(t) {
                    t && wL.call(a, t.type) && a[t.type](t);
                  }
                  var a = {
                    GeometryCollection: function (t) {
                      t.geometries.forEach(o);
                    },
                    LineString: function (t) {
                      t.arcs = s(t.arcs);
                    },
                    MultiLineString: function (t) {
                      t.arcs = t.arcs.map(s);
                    },
                    Polygon: function (t) {
                      t.arcs = t.arcs.map(l);
                    },
                    MultiPolygon: function (t) {
                      t.arcs = t.arcs.map(u);
                    },
                  };
                  function s(t) {
                    for (var n = 0, o = t.length; n < o; ++n) r[++e] = t[n];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return i.push(a), a;
                  }
                  function l(t) {
                    for (var i = 0, o = t.length; i < o; ++i) r[++e] = t[i];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return n.push(a), a;
                  }
                  function u(t) {
                    return t.map(l);
                  }
                  for (var c in t) o(t[c]);
                  return {
                    type: "Topology",
                    coordinates: r,
                    lines: i,
                    rings: n,
                    objects: t,
                  };
                })(t)
              )
            ),
            o = r.coordinates,
            a = AL(1.4 * r.arcs.length, BL, GL);
          function s(t) {
            t && wL.call(l, t.type) && l[t.type](t);
          }
          (t = r.objects),
            (r.bbox = i),
            (r.arcs = r.arcs.map(function (t, e) {
              return a.set(t, e), o.slice(t[0], t[1] + 1);
            })),
            delete r.coordinates,
            (o = null);
          var l = {
            GeometryCollection: function (t) {
              t.geometries.forEach(s);
            },
            LineString: function (t) {
              t.arcs = u(t.arcs);
            },
            MultiLineString: function (t) {
              t.arcs = t.arcs.map(u);
            },
            Polygon: function (t) {
              t.arcs = t.arcs.map(u);
            },
            MultiPolygon: function (t) {
              t.arcs = t.arcs.map(c);
            },
          };
          function u(t) {
            var e = [];
            do {
              var i = a.get(t);
              e.push(t[0] < t[1] ? i : ~i);
            } while ((t = t.next));
            return e;
          }
          function c(t) {
            return t.map(u);
          }
          for (var h in t) s(t[h]);
          return (
            n &&
              ((r.transform = n),
              (r.arcs = (function (t) {
                for (var e = -1, i = t.length; ++e < i; ) {
                  for (
                    var n,
                      r,
                      o = t[e],
                      a = 0,
                      s = 1,
                      l = o.length,
                      u = o[0],
                      c = u[0],
                      h = u[1];
                    ++a < l;

                  )
                    (n = (u = o[a])[0]),
                      (r = u[1]),
                      (n === c && r === h) ||
                        ((o[s++] = [n - c, r - h]), (c = n), (h = r));
                  1 === s && (o[s++] = [0, 0]), (o.length = s);
                }
                return t;
              })(r.arcs))),
            r
          );
        },
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  jL = CL(UL);
function HL(t) {
  return t;
}
function VL(t) {
  if (null == t) return HL;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u);
    for (c[0] = (e += t[0]) * n + o, c[1] = (i += t[1]) * r + a; l < u; )
      (c[l] = t[l]), ++l;
    return c;
  };
}
function WL(t) {
  var e,
    i = VL(t.transform),
    n = 1 / 0,
    r = n,
    o = -n,
    a = -n;
  function s(t) {
    (t = i(t))[0] < n && (n = t[0]),
      t[0] > o && (o = t[0]),
      t[1] < r && (r = t[1]),
      t[1] > a && (a = t[1]);
  }
  function l(t) {
    switch (t.type) {
      case "GeometryCollection":
        t.geometries.forEach(l);
        break;
      case "Point":
        s(t.coordinates);
        break;
      case "MultiPoint":
        t.coordinates.forEach(s);
    }
  }
  for (e in (t.arcs.forEach(function (t) {
    for (var e, s = -1, l = t.length; ++s < l; )
      (e = i(t[s], s))[0] < n && (n = e[0]),
        e[0] > o && (o = e[0]),
        e[1] < r && (r = e[1]),
        e[1] > a && (a = e[1]);
  }),
  t.objects))
    l(t.objects[e]);
  return [n, r, o, a];
}
function qL(t, e) {
  var i = e.id,
    n = e.bbox,
    r = null == e.properties ? {} : e.properties,
    o = YL(t, e);
  return null == i && null == n
    ? {
        type: "Feature",
        properties: r,
        geometry: o,
      }
    : null == n
    ? {
        type: "Feature",
        id: i,
        properties: r,
        geometry: o,
      }
    : {
        type: "Feature",
        id: i,
        bbox: n,
        properties: r,
        geometry: o,
      };
}
function YL(t, e) {
  var i = VL(t.transform),
    n = t.arcs;
  function r(t, e) {
    e.length && e.pop();
    for (var r = n[t < 0 ? ~t : t], o = 0, a = r.length; o < a; ++o)
      e.push(i(r[o], o));
    t < 0 &&
      (function (t, e) {
        for (var i, n = t.length, r = n - e; r < --n; )
          (i = t[r]), (t[r++] = t[n]), (t[n] = i);
      })(e, a);
  }
  function o(t) {
    return i(t);
  }
  function a(t) {
    for (var e = [], i = 0, n = t.length; i < n; ++i) r(t[i], e);
    return e.length < 2 && e.push(e[0]), e;
  }
  function s(t) {
    for (var e = a(t); e.length < 4; ) e.push(e[0]);
    return e;
  }
  function l(t) {
    return t.map(s);
  }
  return (function t(e) {
    var i,
      n = e.type;
    switch (n) {
      case "GeometryCollection":
        return {
          type: n,
          geometries: e.geometries.map(t),
        };
      case "Point":
        i = o(e.coordinates);
        break;
      case "MultiPoint":
        i = e.coordinates.map(o);
        break;
      case "LineString":
        i = a(e.arcs);
        break;
      case "MultiLineString":
        i = e.arcs.map(a);
        break;
      case "Polygon":
        i = l(e.arcs);
        break;
      case "MultiPolygon":
        i = e.arcs.map(l);
        break;
      default:
        return null;
    }
    return {
      type: n,
      coordinates: i,
    };
  })(e);
}
function XL(t, e) {
  var i = {},
    n = {},
    r = {},
    o = [],
    a = -1;
  function s(t, e) {
    for (var n in t) {
      var r = t[n];
      delete e[r.start],
        delete r.start,
        delete r.end,
        r.forEach(function (t) {
          i[t < 0 ? ~t : t] = 1;
        }),
        o.push(r);
    }
  }
  return (
    e.forEach(function (i, n) {
      var r,
        o = t.arcs[i < 0 ? ~i : i];
      o.length < 3 &&
        !o[1][0] &&
        !o[1][1] &&
        ((r = e[++a]), (e[a] = i), (e[n] = r));
    }),
    e.forEach(function (e) {
      var i,
        o,
        a = (function (e) {
          var i,
            n = t.arcs[e < 0 ? ~e : e],
            r = n[0];
          t.transform
            ? ((i = [0, 0]),
              n.forEach(function (t) {
                (i[0] += t[0]), (i[1] += t[1]);
              }))
            : (i = n[n.length - 1]);
          return e < 0 ? [i, r] : [r, i];
        })(e),
        s = a[0],
        l = a[1];
      if ((i = r[s]))
        if ((delete r[i.end], i.push(e), (i.end = l), (o = n[l]))) {
          delete n[o.start];
          var u = o === i ? i : i.concat(o);
          n[(u.start = i.start)] = r[(u.end = o.end)] = u;
        } else n[i.start] = r[i.end] = i;
      else if ((i = n[l]))
        if ((delete n[i.start], i.unshift(e), (i.start = s), (o = r[s]))) {
          delete r[o.end];
          var c = o === i ? i : o.concat(i);
          n[(c.start = o.start)] = r[(c.end = i.end)] = c;
        } else n[i.start] = r[i.end] = i;
      else n[((i = [e]).start = s)] = r[(i.end = l)] = i;
    }),
    s(r, n),
    s(n, r),
    e.forEach(function (t) {
      i[t < 0 ? ~t : t] || o.push([t]);
    }),
    o
  );
}
function QL(t, e, i) {
  var n, r, o;
  if (arguments.length > 1)
    n = (function (t, e, i) {
      var n,
        r = [],
        o = [];
      function a(t) {
        var e = t < 0 ? ~t : t;
        (o[e] || (o[e] = [])).push({
          i: t,
          g: n,
        });
      }
      function s(t) {
        t.forEach(a);
      }
      function l(t) {
        t.forEach(s);
      }
      function u(t) {
        t.forEach(l);
      }
      function c(t) {
        switch (((n = t), t.type)) {
          case "GeometryCollection":
            t.geometries.forEach(c);
            break;
          case "LineString":
            s(t.arcs);
            break;
          case "MultiLineString":
          case "Polygon":
            l(t.arcs);
            break;
          case "MultiPolygon":
            u(t.arcs);
        }
      }
      return (
        c(e),
        o.forEach(
          null == i
            ? function (t) {
                r.push(t[0].i);
              }
            : function (t) {
                i(t[0].g, t[t.length - 1].g) && r.push(t[0].i);
              }
        ),
        r
      );
    })(0, e, i);
  else for (r = 0, n = new Array((o = t.arcs.length)); r < o; ++r) n[r] = r;
  return {
    type: "MultiLineString",
    arcs: XL(t, n),
  };
}
function ZL(t, e) {
  var i = {},
    n = [],
    r = [];
  function o(t) {
    t.forEach(function (e) {
      e.forEach(function (e) {
        (i[(e = e < 0 ? ~e : e)] || (i[e] = [])).push(t);
      });
    }),
      n.push(t);
  }
  function a(e) {
    return (function (t) {
      for (var e, i = -1, n = t.length, r = t[n - 1], o = 0; ++i < n; )
        (e = r), (r = t[i]), (o += e[0] * r[1] - e[1] * r[0]);
      return Math.abs(o);
    })(
      YL(t, {
        type: "Polygon",
        arcs: [e],
      }).coordinates[0]
    );
  }
  return (
    e.forEach(function t(e) {
      switch (e.type) {
        case "GeometryCollection":
          e.geometries.forEach(t);
          break;
        case "Polygon":
          o(e.arcs);
          break;
        case "MultiPolygon":
          e.arcs.forEach(o);
      }
    }),
    n.forEach(function (t) {
      if (!t._) {
        var e = [],
          n = [t];
        for (t._ = 1, r.push(e); (t = n.pop()); )
          e.push(t),
            t.forEach(function (t) {
              t.forEach(function (t) {
                i[t < 0 ? ~t : t].forEach(function (t) {
                  t._ || ((t._ = 1), n.push(t));
                });
              });
            });
      }
    }),
    n.forEach(function (t) {
      delete t._;
    }),
    {
      type: "MultiPolygon",
      arcs: r
        .map(function (e) {
          var n,
            r = [];
          if (
            (e.forEach(function (t) {
              t.forEach(function (t) {
                t.forEach(function (t) {
                  i[t < 0 ? ~t : t].length < 2 && r.push(t);
                });
              });
            }),
            (n = (r = XL(t, r)).length) > 1)
          )
            for (var o, s, l = 1, u = a(r[0]); l < n; ++l)
              (o = a(r[l])) > u &&
                ((s = r[0]), (r[0] = r[l]), (r[l] = s), (u = o));
          return r;
        })
        .filter(function (t) {
          return t.length > 0;
        }),
    }
  );
}
function JL(t, e) {
  for (var i = 0, n = t.length; i < n; ) {
    var r = (i + n) >>> 1;
    t[r] < e ? (i = r + 1) : (n = r);
  }
  return i;
}
function KL(t) {
  if (null == t) return HL;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u),
      h = Math.round((t[0] - o) / n),
      p = Math.round((t[1] - a) / r);
    for (c[0] = h - e, e = h, c[1] = p - i, i = p; l < u; ) (c[l] = t[l]), ++l;
    return c;
  };
}
var $L = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bbox: WL,
        feature: function (t, e) {
          return (
            "string" == typeof e && (e = t.objects[e]),
            "GeometryCollection" === e.type
              ? {
                  type: "FeatureCollection",
                  features: e.geometries.map(function (e) {
                    return qL(t, e);
                  }),
                }
              : qL(t, e)
          );
        },
        mesh: function (t) {
          return YL(t, QL.apply(this, arguments));
        },
        meshArcs: QL,
        merge: function (t) {
          return YL(t, ZL.apply(this, arguments));
        },
        mergeArcs: ZL,
        neighbors: function (t) {
          var e = {},
            i = t.map(function () {
              return [];
            });
          function n(t, i) {
            t.forEach(function (t) {
              t < 0 && (t = ~t);
              var n = e[t];
              n ? n.push(i) : (e[t] = [i]);
            });
          }
          function r(t, e) {
            t.forEach(function (t) {
              n(t, e);
            });
          }
          var o = {
            LineString: n,
            MultiLineString: r,
            Polygon: r,
            MultiPolygon: function (t, e) {
              t.forEach(function (t) {
                r(t, e);
              });
            },
          };
          for (var a in (t.forEach(function t(e, i) {
            "GeometryCollection" === e.type
              ? e.geometries.forEach(function (e) {
                  t(e, i);
                })
              : e.type in o && o[e.type](e.arcs, i);
          }),
          e))
            for (var s = e[a], l = s.length, u = 0; u < l; ++u)
              for (var c = u + 1; c < l; ++c) {
                var h,
                  p = s[u],
                  d = s[c];
                (h = i[p])[(a = JL(h, d))] !== d && h.splice(a, 0, d),
                  (h = i[d])[(a = JL(h, p))] !== p && h.splice(a, 0, p);
              }
          return i;
        },
        quantize: function (t, e) {
          if (t.transform) throw new Error("already quantized");
          if (e && e.scale) s = t.bbox;
          else {
            if (!((i = Math.floor(e)) >= 2)) throw new Error("n must be ≥2");
            var i,
              n = (s = t.bbox || WL(t))[0],
              r = s[1],
              o = s[2],
              a = s[3];
            e = {
              scale: [
                o - n ? (o - n) / (i - 1) : 1,
                a - r ? (a - r) / (i - 1) : 1,
              ],
              translate: [n, r],
            };
          }
          var s,
            l,
            u = KL(e),
            c = t.objects,
            h = {};
          function p(t) {
            return u(t);
          }
          function d(t) {
            var e;
            switch (t.type) {
              case "GeometryCollection":
                e = {
                  type: "GeometryCollection",
                  geometries: t.geometries.map(d),
                };
                break;
              case "Point":
                e = {
                  type: "Point",
                  coordinates: p(t.coordinates),
                };
                break;
              case "MultiPoint":
                e = {
                  type: "MultiPoint",
                  coordinates: t.coordinates.map(p),
                };
                break;
              default:
                return t;
            }
            return (
              null != t.id && (e.id = t.id),
              null != t.bbox && (e.bbox = t.bbox),
              null != t.properties && (e.properties = t.properties),
              e
            );
          }
          for (l in c) h[l] = d(c[l]);
          return {
            type: "Topology",
            bbox: s,
            transform: e,
            objects: h,
            arcs: t.arcs.map(function (t) {
              var e,
                i = 0,
                n = 1,
                r = t.length,
                o = new Array(r);
              for (o[0] = u(t[0], 0); ++i < r; )
                ((e = u(t[i], i))[0] || e[1]) && (o[n++] = e);
              return 1 === n && (o[n++] = [0, 0]), (o.length = n), o;
            }),
          };
        },
        transform: VL,
        untransform: KL,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  tI = CL($L),
  eI = function (t) {
    var e = t.slice(),
      i = [];
    for (; e.length > 0; ) {
      var n = e.shift();
      (e = e.reduce(function (t, e) {
        var i = nI(n, e);
        return i ? (n = i) : t.push(e), t;
      }, [])),
        i.push(n);
    }
    i =
      1 === i.length
        ? i[0]
        : {
            type: "MultiLineString",
            coordinates: i.map(function (t) {
              return t.coordinates;
            }),
          };
    return i;
  };
function iI(t) {
  return t[0].toString() + "," + t[1].toString();
}
function nI(t, e) {
  var i,
    n = iI(t.coordinates[0]),
    r = iI(t.coordinates[t.coordinates.length - 1]),
    o = iI(e.coordinates[0]),
    a = iI(e.coordinates[e.coordinates.length - 1]);
  if (n === a) i = e.coordinates.concat(t.coordinates.slice(1));
  else if (o === r) i = t.coordinates.concat(e.coordinates.slice(1));
  else if (n === o) i = t.coordinates.slice(1).reverse().concat(e.coordinates);
  else {
    if (r !== a) return null;
    i = t.coordinates.concat(e.coordinates.reverse().slice(1));
  }
  return {
    type: "LineString",
    coordinates: i,
  };
}
var rI = {};
function oI(t, e, i) {
  var n,
    r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p,
    d = 0,
    f = 0,
    g = "FeatureCollection" === t.type,
    m = "Feature" === t.type,
    y = g ? t.features.length : 1;
  for (n = 0; n < y; n++)
    for (
      u = (p =
        "GeometryCollection" ===
        (h = g ? t.features[n].geometry : m ? t.geometry : t).type)
        ? h.geometries.length
        : 1,
        a = 0;
      a < u;
      a++
    )
      if (
        ((c = (l = p ? h.geometries[a] : h).coordinates),
        (d = !i || ("Polygon" !== l.type && "MultiPolygon" !== l.type) ? 0 : 1),
        "Point" === l.type)
      )
        e(c, f), f++;
      else if ("LineString" === l.type || "MultiPoint" === l.type)
        for (r = 0; r < c.length; r++) e(c[r], f), f++;
      else if ("Polygon" === l.type || "MultiLineString" === l.type)
        for (r = 0; r < c.length; r++)
          for (o = 0; o < c[r].length - d; o++) e(c[r][o], f), f++;
      else if ("MultiPolygon" === l.type)
        for (r = 0; r < c.length; r++)
          for (o = 0; o < c[r].length; o++)
            for (s = 0; s < c[r][o].length - d; s++) e(c[r][o][s], f), f++;
      else {
        if ("GeometryCollection" !== l.type)
          throw new Error("Unknown Geometry Type");
        for (r = 0; r < l.geometries.length; r++) oI(l.geometries[r], e, i);
      }
}
function aI(t, e) {
  var i;
  switch (t.type) {
    case "FeatureCollection":
      for (i = 0; i < t.features.length; i++) e(t.features[i].properties, i);
      break;
    case "Feature":
      e(t.properties, 0);
  }
}
function sI(t, e) {
  if ("Feature" === t.type) e(t, 0);
  else if ("FeatureCollection" === t.type)
    for (var i = 0; i < t.features.length; i++) e(t.features[i], i);
}
function lI(t, e) {
  var i,
    n,
    r,
    o,
    a,
    s,
    l,
    u = 0,
    c = "FeatureCollection" === t.type,
    h = "Feature" === t.type,
    p = c ? t.features.length : 1;
  for (i = 0; i < p; i++)
    for (
      a = (l =
        "GeometryCollection" ===
        (s = c ? t.features[i].geometry : h ? t.geometry : t).type)
        ? s.geometries.length
        : 1,
        r = 0;
      r < a;
      r++
    )
      if (
        "Point" === (o = l ? s.geometries[r] : s).type ||
        "LineString" === o.type ||
        "MultiPoint" === o.type ||
        "Polygon" === o.type ||
        "MultiLineString" === o.type ||
        "MultiPolygon" === o.type
      )
        e(o, u), u++;
      else {
        if ("GeometryCollection" !== o.type)
          throw new Error("Unknown Geometry Type");
        for (n = 0; n < o.geometries.length; n++) e(o.geometries[n], u), u++;
      }
}
(rI.coordEach = oI),
  (rI.coordReduce = function (t, e, i, n) {
    var r = i;
    return (
      oI(
        t,
        function (t, n) {
          r = 0 === n && void 0 === i ? t : e(r, t, n);
        },
        n
      ),
      r
    );
  }),
  (rI.propEach = aI),
  (rI.propReduce = function (t, e, i) {
    var n = i;
    return (
      aI(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (rI.featureEach = sI),
  (rI.featureReduce = function (t, e, i) {
    var n = i;
    return (
      sI(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  }),
  (rI.coordAll = function (t) {
    var e = [];
    return (
      oI(t, function (t) {
        e.push(t);
      }),
      e
    );
  }),
  (rI.geomEach = lI),
  (rI.geomReduce = function (t, e, i) {
    var n = i;
    return (
      lI(t, function (t, r) {
        n = 0 === r && void 0 === i ? t : e(n, t, r);
      }),
      n
    );
  });
var uI = jL.topology,
  cI = tI.merge,
  hI = eI,
  pI = rI.geomEach,
  dI = function t(e) {
    switch ((e && e.type) || null) {
      case "FeatureCollection":
        return (
          (e.features = e.features.reduce(function (e, i) {
            return e.concat(t(i));
          }, [])),
          e
        );
      case "Feature":
        return e.geometry
          ? t(e.geometry).map(function (t) {
              var i = {
                type: "Feature",
                properties: JSON.parse(JSON.stringify(e.properties)),
                geometry: t,
              };
              return void 0 !== e.id && (i.id = e.id), i;
            })
          : e;
      case "MultiPoint":
        return e.coordinates.map(function (t) {
          return {
            type: "Point",
            coordinates: t,
          };
        });
      case "MultiPolygon":
        return e.coordinates.map(function (t) {
          return {
            type: "Polygon",
            coordinates: t,
          };
        });
      case "MultiLineString":
        return e.coordinates.map(function (t) {
          return {
            type: "LineString",
            coordinates: t,
          };
        });
      case "GeometryCollection":
        return e.geometries.map(t).reduce(function (t, e) {
          return t.concat(e);
        }, []);
      case "Point":
      case "Polygon":
      case "LineString":
        return [e];
    }
  },
  fI = function () {
    var t = ((i = arguments),
      i.length
        ? Array.isArray(i[0])
          ? i[0]
          : Array.prototype.slice.call(i)
        : []).reduce(function (t, e) {
        var i = dI(e);
        Array.isArray(i) || (i = [i]);
        for (var n = 0; n < i.length; n++)
          pI(i[n], function (e) {
            t.push(e);
          });
        return t;
      }, []),
      e = (function (t) {
        for (var e = null, i = 0; i < t.length; i++)
          if (e) {
            if (e !== t[i].type) return null;
          } else e = t[i].type;
        return e;
      })(t);
    var i;
    if (!e) throw new Error("List does not contain only homoegenous GeoJSON");
    switch (e) {
      case "LineString":
        return hI(t);
      case "Polygon":
        return (function (t) {
          var e = {
              geoms: {
                type: "GeometryCollection",
                geometries: JSON.parse(JSON.stringify(t)),
              },
            },
            i = uI(e);
          return cI(i, i.objects.geoms.geometries);
        })(t);
      default:
        return t;
    }
  };
const gI = (t, e) => fI(t);
var mI = {
    exports: {},
  },
  yI = function (t, e) {
    (this.p1 = t), (this.p2 = e);
  };
(yI.prototype.rise = function () {
  return this.p2[1] - this.p1[1];
}),
  (yI.prototype.run = function () {
    return this.p2[0] - this.p1[0];
  }),
  (yI.prototype.slope = function () {
    return this.rise() / this.run();
  }),
  (yI.prototype.yIntercept = function () {
    return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
  }),
  (yI.prototype.isVertical = function () {
    return !isFinite(this.slope());
  }),
  (yI.prototype.isHorizontal = function () {
    return this.p1[1] == this.p2[1];
  }),
  (yI.prototype._perpendicularDistanceHorizontal = function (t) {
    return Math.abs(this.p1[1] - t[1]);
  }),
  (yI.prototype._perpendicularDistanceVertical = function (t) {
    return Math.abs(this.p1[0] - t[0]);
  }),
  (yI.prototype._perpendicularDistanceHasSlope = function (t) {
    var e = this.slope(),
      i = this.yIntercept();
    return Math.abs(e * t[0] - t[1] + i) / Math.sqrt(Math.pow(e, 2) + 1);
  }),
  (yI.prototype.perpendicularDistance = function (t) {
    return this.isVertical()
      ? this._perpendicularDistanceVertical(t)
      : this.isHorizontal()
      ? this._perpendicularDistanceHorizontal(t)
      : this._perpendicularDistanceHasSlope(t);
  });
var vI = yI,
  bI = function (t, e) {
    for (var i = 0, n = 0, r = 1; r <= t.length - 2; r++) {
      var o = new vI(t[0], t[t.length - 1]).perpendicularDistance(t[r]);
      o > i && ((n = r), (i = o));
    }
    if (i > e)
      var a = bI(t.slice(0, n), e),
        s = bI(t.slice(n, t.length), e),
        l = a.concat(s);
    else l = t.length > 1 ? [t[0], t[t.length - 1]] : [t[0]];
    return l;
  },
  xI = bI;
function _I(t, e) {
  return t === e || (t != t && e != e);
}
function SI(t, e) {
  for (var i = t.length; i--; ) if (_I(t[i][0], e)) return i;
  return -1;
}
!(function (t) {
  var e = xI;
  function i(e, i) {
    var n = e.geometry,
      r = n.type;
    if ("LineString" === r)
      n.coordinates = t.exports.simplify(n.coordinates, i);
    else if ("Polygon" === r || "MultiLineString" === r)
      for (var o = 0; o < n.coordinates.length; o++)
        n.coordinates[o] = t.exports.simplify(n.coordinates[o], i);
    else if ("MultiPolygon" === r)
      for (var a = 0; a < n.coordinates.length; a++)
        for (var s = 0; s < n.coordinates[a].length; s++)
          n.coordinates[a][s] = t.exports.simplify(n.coordinates[a][s], i);
    return e;
  }
  (t.exports = function (t, e, n) {
    return (
      n || (t = JSON.parse(JSON.stringify(t))),
      t.features
        ? (function (t, e) {
            for (var n = 0; n < t.features.length; n++)
              t.features[n] = i(t.features[n], e);
            return t;
          })(t, e)
        : t.type && "Feature" === t.type
        ? i(t, e)
        : new Error("FeatureCollection or individual Feature required")
    );
  }),
    (t.exports.simplify = function (t, i) {
      return e(t, i);
    });
})(mI);
var MI = Array.prototype.splice;
function CI(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
(CI.prototype.clear = function () {
  (this.__data__ = []), (this.size = 0);
}),
  (CI.prototype.delete = function (t) {
    var e = this.__data__,
      i = SI(e, t);
    return (
      !(i < 0) &&
      (i == e.length - 1 ? e.pop() : MI.call(e, i, 1), --this.size, !0)
    );
  }),
  (CI.prototype.get = function (t) {
    var e = this.__data__,
      i = SI(e, t);
    return i < 0 ? void 0 : e[i][1];
  }),
  (CI.prototype.has = function (t) {
    return SI(this.__data__, t) > -1;
  }),
  (CI.prototype.set = function (t, e) {
    var i = this.__data__,
      n = SI(i, t);
    return n < 0 ? (++this.size, i.push([t, e])) : (i[n][1] = e), this;
  });
var wI =
    "object" == typeof global && global && global.Object === Object && global,
  AI = "object" == typeof self && self && self.Object === Object && self,
  EI = wI || AI || Function("return this")(),
  DI = EI.Symbol,
  TI = Object.prototype,
  PI = TI.hasOwnProperty,
  LI = TI.toString,
  II = DI ? DI.toStringTag : void 0;
var NI = Object.prototype.toString;
var RI = "[object Null]",
  OI = "[object Undefined]",
  FI = DI ? DI.toStringTag : void 0;
function zI(t) {
  return null == t
    ? void 0 === t
      ? OI
      : RI
    : FI && FI in Object(t)
    ? (function (t) {
        var e = PI.call(t, II),
          i = t[II];
        try {
          t[II] = void 0;
          var n = !0;
        } catch (o) {}
        var r = LI.call(t);
        return n && (e ? (t[II] = i) : delete t[II]), r;
      })(t)
    : (function (t) {
        return NI.call(t);
      })(t);
}
function kI(t) {
  var e = typeof t;
  return null != t && ("object" == e || "function" == e);
}
var BI = "[object AsyncFunction]",
  GI = "[object Function]",
  UI = "[object GeneratorFunction]",
  jI = "[object Proxy]";
function HI(t) {
  if (!kI(t)) return !1;
  var e = zI(t);
  return e == GI || e == UI || e == BI || e == jI;
}
var VI = EI["__core-js_shared__"],
  WI = (function () {
    var t = /[^.]+$/.exec((VI && VI.keys && VI.keys.IE_PROTO) || "");
    return t ? "Symbol(src)_1." + t : "";
  })();
var qI = Function.prototype.toString;
function YI(t) {
  if (null != t) {
    try {
      return qI.call(t);
    } catch (e) {}
    try {
      return t + "";
    } catch (e) {}
  }
  return "";
}
var XI = /^\[object .+?Constructor\]$/,
  QI = Function.prototype,
  ZI = Object.prototype,
  JI = QI.toString,
  KI = ZI.hasOwnProperty,
  $I = RegExp(
    "^" +
      JI.call(KI)
        .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function tN(t) {
  return !(!kI(t) || ((e = t), WI && WI in e)) && (HI(t) ? $I : XI).test(YI(t));
  var e;
}
function eN(t, e) {
  var i = (function (t, e) {
    return null == t ? void 0 : t[e];
  })(t, e);
  return tN(i) ? i : void 0;
}
var iN = eN(EI, "Map"),
  nN = eN(Object, "create");
var rN = Object.prototype.hasOwnProperty;
var oN = Object.prototype.hasOwnProperty;
function aN(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
function sN(t, e) {
  var i,
    n,
    r = t.__data__;
  return (
    "string" == (n = typeof (i = e)) ||
    "number" == n ||
    "symbol" == n ||
    "boolean" == n
      ? "__proto__" !== i
      : null === i
  )
    ? r["string" == typeof e ? "string" : "hash"]
    : r.map;
}
function lN(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
(aN.prototype.clear = function () {
  (this.__data__ = nN ? nN(null) : {}), (this.size = 0);
}),
  (aN.prototype.delete = function (t) {
    var e = this.has(t) && delete this.__data__[t];
    return (this.size -= e ? 1 : 0), e;
  }),
  (aN.prototype.get = function (t) {
    var e = this.__data__;
    if (nN) {
      var i = e[t];
      return "__lodash_hash_undefined__" === i ? void 0 : i;
    }
    return rN.call(e, t) ? e[t] : void 0;
  }),
  (aN.prototype.has = function (t) {
    var e = this.__data__;
    return nN ? void 0 !== e[t] : oN.call(e, t);
  }),
  (aN.prototype.set = function (t, e) {
    var i = this.__data__;
    return (
      (this.size += this.has(t) ? 0 : 1),
      (i[t] = nN && void 0 === e ? "__lodash_hash_undefined__" : e),
      this
    );
  }),
  (lN.prototype.clear = function () {
    (this.size = 0),
      (this.__data__ = {
        hash: new aN(),
        map: new (iN || CI)(),
        string: new aN(),
      });
  }),
  (lN.prototype.delete = function (t) {
    var e = sN(this, t).delete(t);
    return (this.size -= e ? 1 : 0), e;
  }),
  (lN.prototype.get = function (t) {
    return sN(this, t).get(t);
  }),
  (lN.prototype.has = function (t) {
    return sN(this, t).has(t);
  }),
  (lN.prototype.set = function (t, e) {
    var i = sN(this, t),
      n = i.size;
    return i.set(t, e), (this.size += i.size == n ? 0 : 1), this;
  });
function uN(t) {
  var e = (this.__data__ = new CI(t));
  this.size = e.size;
}
(uN.prototype.clear = function () {
  (this.__data__ = new CI()), (this.size = 0);
}),
  (uN.prototype.delete = function (t) {
    var e = this.__data__,
      i = e.delete(t);
    return (this.size = e.size), i;
  }),
  (uN.prototype.get = function (t) {
    return this.__data__.get(t);
  }),
  (uN.prototype.has = function (t) {
    return this.__data__.has(t);
  }),
  (uN.prototype.set = function (t, e) {
    var i = this.__data__;
    if (i instanceof CI) {
      var n = i.__data__;
      if (!iN || n.length < 199)
        return n.push([t, e]), (this.size = ++i.size), this;
      i = this.__data__ = new lN(n);
    }
    return i.set(t, e), (this.size = i.size), this;
  });
var cN = (function () {
    try {
      var t = eN(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch (e) {}
  })(),
  hN = cN;
function pN(t, e, i) {
  "__proto__" == e && hN
    ? hN(t, e, {
        configurable: !0,
        enumerable: !0,
        value: i,
        writable: !0,
      })
    : (t[e] = i);
}
var dN = Object.prototype.hasOwnProperty;
function fN(t, e, i) {
  var n = t[e];
  (dN.call(t, e) && _I(n, i) && (void 0 !== i || e in t)) || pN(t, e, i);
}
function gN(t, e, i, n) {
  var r = !i;
  i || (i = {});
  for (var o = -1, a = e.length; ++o < a; ) {
    var s = e[o],
      l = n ? n(i[s], t[s], s, i, t) : void 0;
    void 0 === l && (l = t[s]), r ? pN(i, s, l) : fN(i, s, l);
  }
  return i;
}
function mN(t) {
  return null != t && "object" == typeof t;
}
function yN(t) {
  return mN(t) && "[object Arguments]" == zI(t);
}
var vN = Object.prototype,
  bN = vN.hasOwnProperty,
  xN = vN.propertyIsEnumerable,
  _N = yN(
    (function () {
      return arguments;
    })()
  )
    ? yN
    : function (t) {
        return mN(t) && bN.call(t, "callee") && !xN.call(t, "callee");
      },
  SN = Array.isArray;
var MN = "object" == typeof exports && exports && !exports.nodeType && exports,
  CN = MN && "object" == typeof module && module && !module.nodeType && module,
  wN = CN && CN.exports === MN ? EI.Buffer : void 0,
  AN =
    (wN ? wN.isBuffer : void 0) ||
    function () {
      return !1;
    },
  EN = 9007199254740991,
  DN = /^(?:0|[1-9]\d*)$/;
function TN(t, e) {
  var i = typeof t;
  return (
    !!(e = null == e ? EN : e) &&
    ("number" == i || ("symbol" != i && DN.test(t))) &&
    t > -1 &&
    t % 1 == 0 &&
    t < e
  );
}
var PN = 9007199254740991;
function LN(t) {
  return "number" == typeof t && t > -1 && t % 1 == 0 && t <= PN;
}
var IN = {};
function NN(t) {
  return function (e) {
    return t(e);
  };
}
(IN["[object Float32Array]"] =
  IN["[object Float64Array]"] =
  IN["[object Int8Array]"] =
  IN["[object Int16Array]"] =
  IN["[object Int32Array]"] =
  IN["[object Uint8Array]"] =
  IN["[object Uint8ClampedArray]"] =
  IN["[object Uint16Array]"] =
  IN["[object Uint32Array]"] =
    !0),
  (IN["[object Arguments]"] =
    IN["[object Array]"] =
    IN["[object ArrayBuffer]"] =
    IN["[object Boolean]"] =
    IN["[object DataView]"] =
    IN["[object Date]"] =
    IN["[object Error]"] =
    IN["[object Function]"] =
    IN["[object Map]"] =
    IN["[object Number]"] =
    IN["[object Object]"] =
    IN["[object RegExp]"] =
    IN["[object Set]"] =
    IN["[object String]"] =
    IN["[object WeakMap]"] =
      !1);
var RN = "object" == typeof exports && exports && !exports.nodeType && exports,
  ON = RN && "object" == typeof module && module && !module.nodeType && module,
  FN = ON && ON.exports === RN && wI.process,
  zN = (function () {
    try {
      var t = ON && ON.require && ON.require("util").types;
      return t || (FN && FN.binding && FN.binding("util"));
    } catch (e) {}
  })(),
  kN = zN && zN.isTypedArray,
  BN = kN
    ? NN(kN)
    : function (t) {
        return mN(t) && LN(t.length) && !!IN[zI(t)];
      },
  GN = Object.prototype.hasOwnProperty;
function UN(t, e) {
  var i = SN(t),
    n = !i && _N(t),
    r = !i && !n && AN(t),
    o = !i && !n && !r && BN(t),
    a = i || n || r || o,
    s = a
      ? (function (t, e) {
          for (var i = -1, n = Array(t); ++i < t; ) n[i] = e(i);
          return n;
        })(t.length, String)
      : [],
    l = s.length;
  for (var u in t)
    (!e && !GN.call(t, u)) ||
      (a &&
        ("length" == u ||
          (r && ("offset" == u || "parent" == u)) ||
          (o && ("buffer" == u || "byteLength" == u || "byteOffset" == u)) ||
          TN(u, l))) ||
      s.push(u);
  return s;
}
var jN = Object.prototype;
function HN(t) {
  var e = t && t.constructor;
  return t === (("function" == typeof e && e.prototype) || jN);
}
function VN(t, e) {
  return function (i) {
    return t(e(i));
  };
}
var WN = VN(Object.keys, Object),
  qN = Object.prototype.hasOwnProperty;
function YN(t) {
  return null != t && LN(t.length) && !HI(t);
}
function XN(t) {
  return YN(t)
    ? UN(t)
    : (function (t) {
        if (!HN(t)) return WN(t);
        var e = [];
        for (var i in Object(t))
          qN.call(t, i) && "constructor" != i && e.push(i);
        return e;
      })(t);
}
var QN = Object.prototype.hasOwnProperty;
function ZN(t) {
  if (!kI(t))
    return (function (t) {
      var e = [];
      if (null != t) for (var i in Object(t)) e.push(i);
      return e;
    })(t);
  var e = HN(t),
    i = [];
  for (var n in t) ("constructor" != n || (!e && QN.call(t, n))) && i.push(n);
  return i;
}
function JN(t) {
  return YN(t) ? UN(t, !0) : ZN(t);
}
var KN = "object" == typeof exports && exports && !exports.nodeType && exports,
  $N = KN && "object" == typeof module && module && !module.nodeType && module,
  tR = $N && $N.exports === KN ? EI.Buffer : void 0,
  eR = tR ? tR.allocUnsafe : void 0;
function iR(t, e) {
  if (e) return t.slice();
  var i = t.length,
    n = eR ? eR(i) : new t.constructor(i);
  return t.copy(n), n;
}
function nR(t, e) {
  var i = -1,
    n = t.length;
  for (e || (e = Array(n)); ++i < n; ) e[i] = t[i];
  return e;
}
function rR() {
  return [];
}
var oR = Object.prototype.propertyIsEnumerable,
  aR = Object.getOwnPropertySymbols,
  sR = aR
    ? function (t) {
        return null == t
          ? []
          : ((t = Object(t)),
            (function (t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length, r = 0, o = [];
                ++i < n;

              ) {
                var a = t[i];
                e(a, i, t) && (o[r++] = a);
              }
              return o;
            })(aR(t), function (e) {
              return oR.call(t, e);
            }));
      }
    : rR,
  lR = sR;
function uR(t, e) {
  for (var i = -1, n = e.length, r = t.length; ++i < n; ) t[r + i] = e[i];
  return t;
}
var cR = VN(Object.getPrototypeOf, Object),
  hR = Object.getOwnPropertySymbols
    ? function (t) {
        for (var e = []; t; ) uR(e, lR(t)), (t = cR(t));
        return e;
      }
    : rR,
  pR = hR;
function dR(t, e, i) {
  var n = e(t);
  return SN(t) ? n : uR(n, i(t));
}
function fR(t) {
  return dR(t, XN, lR);
}
function gR(t) {
  return dR(t, JN, pR);
}
var mR = eN(EI, "DataView"),
  yR = eN(EI, "Promise"),
  vR = eN(EI, "Set"),
  bR = eN(EI, "WeakMap"),
  xR = "[object Map]",
  _R = "[object Promise]",
  SR = "[object Set]",
  MR = "[object WeakMap]",
  CR = "[object DataView]",
  wR = YI(mR),
  AR = YI(iN),
  ER = YI(yR),
  DR = YI(vR),
  TR = YI(bR),
  PR = zI;
((mR && PR(new mR(new ArrayBuffer(1))) != CR) ||
  (iN && PR(new iN()) != xR) ||
  (yR && PR(yR.resolve()) != _R) ||
  (vR && PR(new vR()) != SR) ||
  (bR && PR(new bR()) != MR)) &&
  (PR = function (t) {
    var e = zI(t),
      i = "[object Object]" == e ? t.constructor : void 0,
      n = i ? YI(i) : "";
    if (n)
      switch (n) {
        case wR:
          return CR;
        case AR:
          return xR;
        case ER:
          return _R;
        case DR:
          return SR;
        case TR:
          return MR;
      }
    return e;
  });
var LR = PR,
  IR = Object.prototype.hasOwnProperty;
var NR = EI.Uint8Array;
function RR(t) {
  var e = new t.constructor(t.byteLength);
  return new NR(e).set(new NR(t)), e;
}
var OR = /\w*$/;
var FR = DI ? DI.prototype : void 0,
  zR = FR ? FR.valueOf : void 0;
function kR(t, e) {
  var i = e ? RR(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.length);
}
var BR = "[object Boolean]",
  GR = "[object Date]",
  UR = "[object Map]",
  jR = "[object Number]",
  HR = "[object RegExp]",
  VR = "[object Set]",
  WR = "[object String]",
  qR = "[object Symbol]",
  YR = "[object ArrayBuffer]",
  XR = "[object DataView]",
  QR = "[object Float32Array]",
  ZR = "[object Float64Array]",
  JR = "[object Int8Array]",
  KR = "[object Int16Array]",
  $R = "[object Int32Array]",
  tO = "[object Uint8Array]",
  eO = "[object Uint8ClampedArray]",
  iO = "[object Uint16Array]",
  nO = "[object Uint32Array]";
function rO(t, e, i) {
  var n,
    r,
    o,
    a = t.constructor;
  switch (e) {
    case YR:
      return RR(t);
    case BR:
    case GR:
      return new a(+t);
    case XR:
      return (function (t, e) {
        var i = e ? RR(t.buffer) : t.buffer;
        return new t.constructor(i, t.byteOffset, t.byteLength);
      })(t, i);
    case QR:
    case ZR:
    case JR:
    case KR:
    case $R:
    case tO:
    case eO:
    case iO:
    case nO:
      return kR(t, i);
    case UR:
      return new a();
    case jR:
    case WR:
      return new a(t);
    case HR:
      return (
        ((o = new (r = t).constructor(r.source, OR.exec(r))).lastIndex =
          r.lastIndex),
        o
      );
    case VR:
      return new a();
    case qR:
      return (n = t), zR ? Object(zR.call(n)) : {};
  }
}
var oO = Object.create,
  aO = (function () {
    function t() {}
    return function (e) {
      if (!kI(e)) return {};
      if (oO) return oO(e);
      t.prototype = e;
      var i = new t();
      return (t.prototype = void 0), i;
    };
  })(),
  sO = aO;
function lO(t) {
  return "function" != typeof t.constructor || HN(t) ? {} : sO(cR(t));
}
var uO = zN && zN.isMap,
  cO = uO
    ? NN(uO)
    : function (t) {
        return mN(t) && "[object Map]" == LR(t);
      };
var hO = zN && zN.isSet,
  pO = hO
    ? NN(hO)
    : function (t) {
        return mN(t) && "[object Set]" == LR(t);
      },
  dO = 1,
  fO = 2,
  gO = 4,
  mO = "[object Arguments]",
  yO = "[object Function]",
  vO = "[object GeneratorFunction]",
  bO = "[object Object]",
  xO = {};
function _O(t, e, i, n, r, o) {
  var a,
    s = e & dO,
    l = e & fO,
    u = e & gO;
  if ((i && (a = r ? i(t, n, r, o) : i(t)), void 0 !== a)) return a;
  if (!kI(t)) return t;
  var c = SN(t);
  if (c) {
    if (
      ((a = (function (t) {
        var e = t.length,
          i = new t.constructor(e);
        return (
          e &&
            "string" == typeof t[0] &&
            IR.call(t, "index") &&
            ((i.index = t.index), (i.input = t.input)),
          i
        );
      })(t)),
      !s)
    )
      return nR(t, a);
  } else {
    var h = LR(t),
      p = h == yO || h == vO;
    if (AN(t)) return iR(t, s);
    if (h == bO || h == mO || (p && !r)) {
      if (((a = l || p ? {} : lO(t)), !s))
        return l
          ? (function (t, e) {
              return gN(t, pR(t), e);
            })(
              t,
              (function (t, e) {
                return t && gN(e, JN(e), t);
              })(a, t)
            )
          : (function (t, e) {
              return gN(t, lR(t), e);
            })(
              t,
              (function (t, e) {
                return t && gN(e, XN(e), t);
              })(a, t)
            );
    } else {
      if (!xO[h]) return r ? t : {};
      a = rO(t, h, s);
    }
  }
  o || (o = new uN());
  var d = o.get(t);
  if (d) return d;
  o.set(t, a),
    pO(t)
      ? t.forEach(function (n) {
          a.add(_O(n, e, i, n, t, o));
        })
      : cO(t) &&
        t.forEach(function (n, r) {
          a.set(r, _O(n, e, i, r, t, o));
        });
  var f = c ? void 0 : (u ? (l ? gR : fR) : l ? JN : XN)(t);
  return (
    (function (t, e) {
      for (
        var i = -1, n = null == t ? 0 : t.length;
        ++i < n && !1 !== e(t[i], i, t);

      );
    })(f || t, function (n, r) {
      f && (n = t[(r = n)]), fN(a, r, _O(n, e, i, r, t, o));
    }),
    a
  );
}
(xO[mO] =
  xO["[object Array]"] =
  xO["[object ArrayBuffer]"] =
  xO["[object DataView]"] =
  xO["[object Boolean]"] =
  xO["[object Date]"] =
  xO["[object Float32Array]"] =
  xO["[object Float64Array]"] =
  xO["[object Int8Array]"] =
  xO["[object Int16Array]"] =
  xO["[object Int32Array]"] =
  xO["[object Map]"] =
  xO["[object Number]"] =
  xO[bO] =
  xO["[object RegExp]"] =
  xO["[object Set]"] =
  xO["[object String]"] =
  xO["[object Symbol]"] =
  xO["[object Uint8Array]"] =
  xO["[object Uint8ClampedArray]"] =
  xO["[object Uint16Array]"] =
  xO["[object Uint32Array]"] =
    !0),
  (xO["[object Error]"] = xO[yO] = xO["[object WeakMap]"] = !1);
function SO(t) {
  return _O(t, 5);
}
function MO(t, e, i) {
  ((void 0 !== i && !_I(t[e], i)) || (void 0 === i && !(e in t))) &&
    pN(t, e, i);
}
var CO = (function (t) {
    return function (e, i, n) {
      for (var r = -1, o = Object(e), a = n(e), s = a.length; s--; ) {
        var l = a[t ? s : ++r];
        if (!1 === i(o[l], l, o)) break;
      }
      return e;
    };
  })(),
  wO = CO;
var AO = "[object Object]",
  EO = Function.prototype,
  DO = Object.prototype,
  TO = EO.toString,
  PO = DO.hasOwnProperty,
  LO = TO.call(Object);
function IO(t, e) {
  if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e)
    return t[e];
}
function NO(t, e, i, n, r, o, a) {
  var s = IO(t, i),
    l = IO(e, i),
    u = a.get(l);
  if (u) MO(t, i, u);
  else {
    var c,
      h = o ? o(s, l, i + "", t, e, a) : void 0,
      p = void 0 === h;
    if (p) {
      var d = SN(l),
        f = !d && AN(l),
        g = !d && !f && BN(l);
      (h = l),
        d || f || g
          ? SN(s)
            ? (h = s)
            : mN((c = s)) && YN(c)
            ? (h = nR(s))
            : f
            ? ((p = !1), (h = iR(l, !0)))
            : g
            ? ((p = !1), (h = kR(l, !0)))
            : (h = [])
          : (function (t) {
              if (!mN(t) || zI(t) != AO) return !1;
              var e = cR(t);
              if (null === e) return !0;
              var i = PO.call(e, "constructor") && e.constructor;
              return (
                "function" == typeof i && i instanceof i && TO.call(i) == LO
              );
            })(l) || _N(l)
          ? ((h = s),
            _N(s)
              ? (h = (function (t) {
                  return gN(t, JN(t));
                })(s))
              : (kI(s) && !HI(s)) || (h = lO(l)))
          : (p = !1);
    }
    p && (a.set(l, h), r(h, l, n, o, a), a.delete(l)), MO(t, i, h);
  }
}
function RO(t, e, i, n, r) {
  t !== e &&
    wO(
      e,
      function (o, a) {
        if ((r || (r = new uN()), kI(o))) NO(t, e, a, i, RO, n, r);
        else {
          var s = n ? n(IO(t, a), o, a + "", t, e, r) : void 0;
          void 0 === s && (s = o), MO(t, a, s);
        }
      },
      JN
    );
}
function OO(t) {
  return t;
}
var FO = Math.max;
var zO = hN
    ? function (t, e) {
        return hN(t, "toString", {
          configurable: !0,
          enumerable: !1,
          value:
            ((i = e),
            function () {
              return i;
            }),
          writable: !0,
        });
        var i;
      }
    : OO,
  kO = zO,
  BO = Date.now;
var GO,
  UO,
  jO,
  HO =
    ((GO = kO),
    (UO = 0),
    (jO = 0),
    function () {
      var t = BO(),
        e = 16 - (t - jO);
      if (((jO = t), e > 0)) {
        if (++UO >= 800) return arguments[0];
      } else UO = 0;
      return GO.apply(void 0, arguments);
    });
function VO(t, e) {
  return HO(
    (function (t, e, i) {
      return (
        (e = FO(void 0 === e ? t.length - 1 : e, 0)),
        function () {
          for (
            var n = arguments, r = -1, o = FO(n.length - e, 0), a = Array(o);
            ++r < o;

          )
            a[r] = n[e + r];
          r = -1;
          for (var s = Array(e + 1); ++r < e; ) s[r] = n[r];
          return (
            (s[e] = i(a)),
            (function (t, e, i) {
              switch (i.length) {
                case 0:
                  return t.call(e);
                case 1:
                  return t.call(e, i[0]);
                case 2:
                  return t.call(e, i[0], i[1]);
                case 3:
                  return t.call(e, i[0], i[1], i[2]);
              }
              return t.apply(e, i);
            })(t, this, s)
          );
        }
      );
    })(t, e, OO),
    t + ""
  );
}
var WO,
  qO =
    ((WO = function (t, e, i, n) {
      RO(t, e, i, n);
    }),
    VO(function (t, e) {
      var i = -1,
        n = e.length,
        r = n > 1 ? e[n - 1] : void 0,
        o = n > 2 ? e[2] : void 0;
      for (
        r = WO.length > 3 && "function" == typeof r ? (n--, r) : void 0,
          o &&
            (function (t, e, i) {
              if (!kI(i)) return !1;
              var n = typeof e;
              return (
                !!("number" == n
                  ? YN(i) && TN(e, i.length)
                  : "string" == n && (e in i)) && _I(i[e], t)
              );
            })(e[0], e[1], o) &&
            ((r = n < 3 ? void 0 : r), (n = 1)),
          t = Object(t);
        ++i < n;

      ) {
        var a = e[i];
        a && WO(t, a, i, r);
      }
      return t;
    })),
  YO = qO;
const XO = function (t, ...e) {
  return YO(SO(t), ...e, (t, e) => (SN(e) ? e : void 0 === e ? null : void 0));
};
var QO = function () {
  (this.totalCount = 0), (this.data = {});
};
(QO.prototype.train = function (t, e) {
  for (var i in (this.data[e] || (this.data[e] = {}), t)) {
    var n = t[i];
    void 0 === this.data[e][i] && (this.data[e][i] = {}),
      void 0 === this.data[e][i][n] && (this.data[e][i][n] = 0),
      this.data[e][i][n]++;
  }
  this.totalCount++;
}),
  (QO.prototype.score = function (t) {
    var e,
      i = {};
    for (var n in t) {
      var r = t[n];
      for (e in this.data)
        (i[e] = {}),
          this.data[e][n]
            ? (i[e][n + "_" + r] = (this.data[e][n][r] || 0) / this.totalCount)
            : (i[e][n + "_" + r] = 0);
    }
    var o = {};
    for (e in i) for (var a in ((o[e] = 0), i[e])) o[e] += i[e][a];
    return o;
  });
var ZO = function () {
  (this.weights = []), (this.bias = 0);
};
(ZO.prototype.predict = function (t) {
  if (t.length !== this.weights.length) return null;
  for (var e = 0, i = 0; i < this.weights.length; i++)
    e += this.weights[i] * t[i];
  return (e += this.bias) > 0 ? 1 : 0;
}),
  (ZO.prototype.train = function (t, e) {
    if (0 !== e && 1 !== e) return null;
    t.length !== this.weights.length && ((this.weights = t), (this.bias = 1));
    var i = this.predict(t);
    if ("number" == typeof i && i !== e) {
      for (var n = e - i, r = 0; r < this.weights.length; r++)
        this.weights[r] += n * t[r];
      this.bias += n;
    }
    return this;
  });
var JO = Math.sqrt(2 * Math.PI);
function KO(t) {
  for (var e = t, i = t, n = 1; n < 15; n++) e += i *= (t * t) / (2 * n + 1);
  return Math.round(1e4 * (0.5 + (e / JO) * Math.exp((-t * t) / 2))) / 1e4;
}
for (var $O = [], tF = 0; tF <= 3.09; tF += 0.01) $O.push(KO(tF));
var eF, iF, nF;
vR &&
  ((eF = new vR([, -0])),
  (iF = -1),
  (nF = Array(eF.size)),
  eF.forEach(function (t) {
    nF[++iF] = t;
  }),
  nF)[1],
  DI && DI.isConcatSpreadable;
var rF = DI ? DI.prototype : void 0;
rF && rF.valueOf;
var oF = "[object Symbol]";
var aF = "Expected a function";
function sF(t, e) {
  if ("function" != typeof t || (null != e && "function" != typeof e))
    throw new TypeError(aF);
  var i = function () {
    var n = arguments,
      r = e ? e.apply(this, n) : n[0],
      o = i.cache;
    if (o.has(r)) return o.get(r);
    var a = t.apply(this, n);
    return (i.cache = o.set(r, a) || o), a;
  };
  return (i.cache = new (sF.Cache || lN)()), i;
}
sF.Cache = lN;
var lF =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  uF = /\\(\\)?/g;
!(function (t) {
  var e = sF(t, function (t) {
      return 500 === i.size && i.clear(), t;
    }),
    i = e.cache;
})(function (t) {
  var e = [];
  return (
    46 === t.charCodeAt(0) && e.push(""),
    t.replace(lF, function (t, i, n, r) {
      e.push(n ? r.replace(uF, "$1") : i || t);
    }),
    e
  );
});
var cF,
  hF,
  pF = 1 / 0,
  dF = DI ? DI.prototype : void 0,
  fF = dF ? dF.toString : void 0;
function gF(t) {
  if ("string" == typeof t) return t;
  if (SN(t))
    return (
      (function (t, e) {
        for (var i = -1, n = null == t ? 0 : t.length, r = Array(n); ++i < n; )
          r[i] = e(t[i], i, t);
        return r;
      })(t, gF) + ""
    );
  if (
    (function (t) {
      return "symbol" == typeof t || (mN(t) && zI(t) == oF);
    })(t)
  )
    return fF ? fF.call(t) : "";
  var e = t + "";
  return "0" == e && 1 / t == -pF ? "-0" : e;
}
((hF = cF || (cF = {})).DSV = "dsv"),
  (hF.TREE = "tree"),
  (hF.GEO = "geo"),
  (hF.BYTE = "bytejson"),
  (hF.HEX = "hex"),
  (hF.GRAPH = "graph"),
  (hF.TABLE = "table"),
  (hF.GEO_GRATICULE = "geo-graticule");
const mF = (t, e) => {
  const { callback: i } = e;
  return i && (t = t.map(i)), t;
};
var yF = {},
  vF = {};
function bF(t) {
  return new Function(
    "d",
    "return {" +
      t
        .map(function (t, e) {
          return JSON.stringify(t) + ": d[" + e + '] || ""';
        })
        .join(",") +
      "}"
  );
}
function xF(t) {
  var e = Object.create(null),
    i = [];
  return (
    t.forEach(function (t) {
      for (var n in t) n in e || i.push((e[n] = n));
    }),
    i
  );
}
function _F(t, e) {
  var i = t + "",
    n = i.length;
  return n < e ? new Array(e - n + 1).join(0) + i : i;
}
function SF(t) {
  var e,
    i = t.getUTCHours(),
    n = t.getUTCMinutes(),
    r = t.getUTCSeconds(),
    o = t.getUTCMilliseconds();
  return isNaN(t)
    ? "Invalid Date"
    : ((e = t.getUTCFullYear()) < 0
        ? "-" + _F(-e, 6)
        : e > 9999
        ? "+" + _F(e, 6)
        : _F(e, 4)) +
        "-" +
        _F(t.getUTCMonth() + 1, 2) +
        "-" +
        _F(t.getUTCDate(), 2) +
        (o
          ? "T" +
            _F(i, 2) +
            ":" +
            _F(n, 2) +
            ":" +
            _F(r, 2) +
            "." +
            _F(o, 3) +
            "Z"
          : r
          ? "T" + _F(i, 2) + ":" + _F(n, 2) + ":" + _F(r, 2) + "Z"
          : n || i
          ? "T" + _F(i, 2) + ":" + _F(n, 2) + "Z"
          : "");
}
function MF(t) {
  var e = new RegExp('["' + t + "\n\r]"),
    i = t.charCodeAt(0);
  function n(t, e) {
    var n,
      r = [],
      o = t.length,
      a = 0,
      s = 0,
      l = o <= 0,
      u = !1;
    function c() {
      if (l) return vF;
      if (u) return (u = !1), yF;
      var e,
        n,
        r = a;
      if (34 === t.charCodeAt(r)) {
        for (
          ;
          (a++ < o && 34 !== t.charCodeAt(a)) || 34 === t.charCodeAt(++a);

        );
        return (
          (e = a) >= o
            ? (l = !0)
            : 10 === (n = t.charCodeAt(a++))
            ? (u = !0)
            : 13 === n && ((u = !0), 10 === t.charCodeAt(a) && ++a),
          t.slice(r + 1, e - 1).replace(/""/g, '"')
        );
      }
      for (; a < o; ) {
        if (10 === (n = t.charCodeAt((e = a++)))) u = !0;
        else if (13 === n) (u = !0), 10 === t.charCodeAt(a) && ++a;
        else if (n !== i) continue;
        return t.slice(r, e);
      }
      return (l = !0), t.slice(r, o);
    }
    for (
      10 === t.charCodeAt(o - 1) && --o, 13 === t.charCodeAt(o - 1) && --o;
      (n = c()) !== vF;

    ) {
      for (var h = []; n !== yF && n !== vF; ) h.push(n), (n = c());
      (e && null == (h = e(h, s++))) || r.push(h);
    }
    return r;
  }
  function r(e, i) {
    return e.map(function (e) {
      return i
        .map(function (t) {
          return a(e[t]);
        })
        .join(t);
    });
  }
  function o(e) {
    return e.map(a).join(t);
  }
  function a(t) {
    return null == t
      ? ""
      : t instanceof Date
      ? SF(t)
      : e.test((t += ""))
      ? '"' + t.replace(/"/g, '""') + '"'
      : t;
  }
  return {
    parse: function (t, e) {
      var i,
        r,
        o = n(t, function (t, n) {
          if (i) return i(t, n - 1);
          (r = t),
            (i = e
              ? (function (t, e) {
                  var i = bF(t);
                  return function (n, r) {
                    return e(i(n), r, t);
                  };
                })(t, e)
              : bF(t));
        });
      return (o.columns = r || []), o;
    },
    parseRows: n,
    format: function (e, i) {
      return (
        null == i && (i = xF(e)), [i.map(a).join(t)].concat(r(e, i)).join("\n")
      );
    },
    formatBody: function (t, e) {
      return null == e && (e = xF(t)), r(t, e).join("\n");
    },
    formatRows: function (t) {
      return t.map(o).join("\n");
    },
    formatRow: o,
    formatValue: a,
  };
}
MF(","), MF("\t");
var CF,
  wF,
  AF,
  EF,
  DF,
  TF = {},
  PF = function (t, e) {
    (CF = {}),
      (AF = []),
      (wF = 0),
      (EF = 0),
      (DF = 1),
      NF(t),
      (DF = Math.min(DF, LF));
    for (var i = Math.ceil(Math.log(DF) / Math.LN10), n = 0; n < AF.length; n++)
      e.writeStringField(1, AF[n]);
    2 !== EF && e.writeVarintField(2, EF);
    6 !== i && e.writeVarintField(3, i);
    "FeatureCollection" === t.type
      ? e.writeMessage(4, kF, t)
      : "Feature" === t.type
      ? e.writeMessage(5, BF, t)
      : e.writeMessage(6, GF, t);
    return (CF = null), e.finish();
  },
  LF = 1e6,
  IF = {
    Point: 0,
    MultiPoint: 1,
    LineString: 2,
    MultiLineString: 3,
    Polygon: 4,
    MultiPolygon: 5,
    GeometryCollection: 6,
  };
function NF(t) {
  var e, i;
  if ("FeatureCollection" === t.type)
    for (e = 0; e < t.features.length; e++) NF(t.features[e]);
  else if ("Feature" === t.type)
    for (i in (null !== t.geometry && NF(t.geometry), t.properties)) zF(i);
  else if ("Point" === t.type) FF(t.coordinates);
  else if ("MultiPoint" === t.type) OF(t.coordinates);
  else if ("GeometryCollection" === t.type)
    for (e = 0; e < t.geometries.length; e++) NF(t.geometries[e]);
  else if ("LineString" === t.type) OF(t.coordinates);
  else if ("Polygon" === t.type || "MultiLineString" === t.type)
    RF(t.coordinates);
  else if ("MultiPolygon" === t.type)
    for (e = 0; e < t.coordinates.length; e++) RF(t.coordinates[e]);
  for (i in t) qF(i, t.type) || zF(i);
}
function RF(t) {
  for (var e = 0; e < t.length; e++) OF(t[e]);
}
function OF(t) {
  for (var e = 0; e < t.length; e++) FF(t[e]);
}
function FF(t) {
  EF = Math.max(EF, t.length);
  for (var e = 0; e < t.length; e++)
    for (; Math.round(t[e] * DF) / DF !== t[e] && DF < LF; ) DF *= 10;
}
function zF(t) {
  void 0 === CF[t] && (AF.push(t), (CF[t] = wF++));
}
function kF(t, e) {
  for (var i = 0; i < t.features.length; i++)
    e.writeMessage(1, BF, t.features[i]);
  UF(t, e, !0);
}
function BF(t, e) {
  null !== t.geometry && e.writeMessage(1, GF, t.geometry),
    void 0 !== t.id &&
      ("number" == typeof t.id && t.id % 1 == 0
        ? e.writeSVarintField(12, t.id)
        : e.writeStringField(11, t.id)),
    t.properties && UF(t.properties, e),
    UF(t, e, !0);
}
function GF(t, e) {
  e.writeVarintField(1, IF[t.type]);
  var i = t.coordinates;
  if ("Point" === t.type)
    !(function (t, e) {
      for (var i = [], n = 0; n < EF; n++) i.push(Math.round(t[n] * DF));
      e.writePackedSVarint(3, i);
    })(i, e);
  else if ("MultiPoint" === t.type) HF(i, e);
  else if ("LineString" === t.type) HF(i, e);
  else if ("MultiLineString" === t.type) VF(i, e);
  else if ("Polygon" === t.type) VF(i, e, !0);
  else if ("MultiPolygon" === t.type)
    !(function (t, e) {
      var i,
        n,
        r = t.length;
      if (1 !== r || 1 !== t[0].length) {
        var o = [r];
        for (i = 0; i < r; i++)
          for (o.push(t[i].length), n = 0; n < t[i].length; n++)
            o.push(t[i][n].length - 1);
        e.writePackedVarint(2, o);
      }
      var a = [];
      for (i = 0; i < r; i++)
        for (n = 0; n < t[i].length; n++) WF(a, t[i][n], !0);
      e.writePackedSVarint(3, a);
    })(i, e);
  else if ("GeometryCollection" === t.type)
    for (var n = 0; n < t.geometries.length; n++)
      e.writeMessage(4, GF, t.geometries[n]);
  UF(t, e, !0);
}
function UF(t, e, i) {
  var n = [],
    r = 0;
  for (var o in t)
    (i && qF(o, t.type)) ||
      (e.writeMessage(13, jF, t[o]), n.push(CF[o]), n.push(r++));
  e.writePackedVarint(i ? 15 : 14, n);
}
function jF(t, e) {
  if (null !== t) {
    var i = typeof t;
    "string" === i
      ? e.writeStringField(1, t)
      : "boolean" === i
      ? e.writeBooleanField(5, t)
      : "object" === i
      ? e.writeStringField(6, JSON.stringify(t))
      : "number" === i &&
        (t % 1 != 0
          ? e.writeDoubleField(2, t)
          : t >= 0
          ? e.writeVarintField(3, t)
          : e.writeVarintField(4, -t));
  }
}
function HF(t, e) {
  var i = [];
  WF(i, t), e.writePackedSVarint(3, i);
}
function VF(t, e, i) {
  var n,
    r = t.length;
  if (1 !== r) {
    var o = [];
    for (n = 0; n < r; n++) o.push(t[n].length - (i ? 1 : 0));
    e.writePackedVarint(2, o);
  }
  var a = [];
  for (n = 0; n < r; n++) WF(a, t[n], i);
  e.writePackedSVarint(3, a);
}
function WF(t, e, i) {
  var n,
    r,
    o = e.length - (i ? 1 : 0),
    a = new Array(EF);
  for (r = 0; r < EF; r++) a[r] = 0;
  for (n = 0; n < o; n++)
    for (r = 0; r < EF; r++) {
      var s = Math.round(e[n][r] * DF) - a[r];
      t.push(s), (a[r] += s);
    }
}
function qF(t, e) {
  if ("type" === t) return !0;
  if ("FeatureCollection" === e) {
    if ("features" === t) return !0;
  } else if ("Feature" === e) {
    if ("id" === t || "properties" === t || "geometry" === t) return !0;
  } else if ("GeometryCollection" === e) {
    if ("geometries" === t) return !0;
  } else if ("coordinates" === t) return !0;
  return !1;
}
var YF,
  XF,
  QF,
  ZF,
  JF,
  KF = function (t) {
    (ZF = 2), (JF = Math.pow(10, 6)), (QF = null), (YF = []), (XF = []);
    var e = t.readFields(tz, {});
    return (YF = null), e;
  },
  $F = [
    "Point",
    "MultiPoint",
    "LineString",
    "MultiLineString",
    "Polygon",
    "MultiPolygon",
    "GeometryCollection",
  ];
function tz(t, e, i) {
  1 === t
    ? YF.push(i.readString())
    : 2 === t
    ? (ZF = i.readVarint())
    : 3 === t
    ? (JF = Math.pow(10, i.readVarint()))
    : 4 === t
    ? (function (t, e) {
        (e.type = "FeatureCollection"), (e.features = []), t.readMessage(nz, e);
      })(i, e)
    : 5 === t
    ? ez(i, e)
    : 6 === t && iz(i, e);
}
function ez(t, e) {
  e.type = "Feature";
  var i = t.readMessage(rz, e);
  return "geometry" in i || (i.geometry = null), i;
}
function iz(t, e) {
  return (e.type = "Point"), t.readMessage(oz, e);
}
function nz(t, e, i) {
  1 === t
    ? e.features.push(ez(i, {}))
    : 13 === t
    ? XF.push(az(i))
    : 15 === t && sz(i, e);
}
function rz(t, e, i) {
  1 === t
    ? (e.geometry = iz(i, {}))
    : 11 === t
    ? (e.id = i.readString())
    : 12 === t
    ? (e.id = i.readSVarint())
    : 13 === t
    ? XF.push(az(i))
    : 14 === t
    ? (e.properties = sz(i, {}))
    : 15 === t && sz(i, e);
}
function oz(t, e, i) {
  1 === t
    ? (e.type = $F[i.readVarint()])
    : 2 === t
    ? (QF = i.readPackedVarint())
    : 3 === t
    ? (function (t, e, i) {
        "Point" === i
          ? (t.coordinates = (function (t) {
              var e = t.readVarint() + t.pos,
                i = [];
              for (; t.pos < e; ) i.push(t.readSVarint() / JF);
              return i;
            })(e))
          : "MultiPoint" === i || "LineString" === i
          ? (t.coordinates = uz(e))
          : "MultiLineString" === i
          ? (t.coordinates = cz(e))
          : "Polygon" === i
          ? (t.coordinates = cz(e, !0))
          : "MultiPolygon" === i &&
            (t.coordinates = (function (t) {
              var e = t.readVarint() + t.pos;
              if (!QF) return [[lz(t, e, null, !0)]];
              for (var i = [], n = 1, r = 0; r < QF[0]; r++) {
                for (var o = [], a = 0; a < QF[n]; a++)
                  o.push(lz(t, e, QF[n + 1 + a], !0));
                (n += QF[n] + 1), i.push(o);
              }
              return (QF = null), i;
            })(e));
      })(e, i, e.type)
    : 4 === t
    ? ((e.geometries = e.geometries || []), e.geometries.push(iz(i, {})))
    : 13 === t
    ? XF.push(az(i))
    : 15 === t && sz(i, e);
}
function az(t) {
  for (var e = t.readVarint() + t.pos, i = null; t.pos < e; ) {
    var n = t.readVarint() >> 3;
    1 === n
      ? (i = t.readString())
      : 2 === n
      ? (i = t.readDouble())
      : 3 === n
      ? (i = t.readVarint())
      : 4 === n
      ? (i = -t.readVarint())
      : 5 === n
      ? (i = t.readBoolean())
      : 6 === n && (i = JSON.parse(t.readString()));
  }
  return i;
}
function sz(t, e) {
  for (var i = t.readVarint() + t.pos; t.pos < i; )
    e[YF[t.readVarint()]] = XF[t.readVarint()];
  return (XF = []), e;
}
function lz(t, e, i, n) {
  var r,
    o,
    a = 0,
    s = [],
    l = [];
  for (o = 0; o < ZF; o++) l[o] = 0;
  for (; i ? a < i : t.pos < e; ) {
    for (r = [], o = 0; o < ZF; o++)
      (l[o] += t.readSVarint()), (r[o] = l[o] / JF);
    s.push(r), a++;
  }
  return n && s.push(s[0]), s;
}
function uz(t) {
  return lz(t, t.readVarint() + t.pos);
}
function cz(t, e) {
  var i = t.readVarint() + t.pos;
  if (!QF) return [lz(t, i, null, e)];
  for (var n = [], r = 0; r < QF.length; r++) n.push(lz(t, i, QF[r], e));
  return (QF = null), n;
}
(TF.encode = PF), (TF.decode = KF);
var hz = {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    read: function (t, e, i, n, r) {
      var o,
        a,
        s = 8 * r - n - 1,
        l = (1 << s) - 1,
        u = l >> 1,
        c = -7,
        h = i ? r - 1 : 0,
        p = i ? -1 : 1,
        d = t[e + h];
      for (
        h += p, o = d & ((1 << -c) - 1), d >>= -c, c += s;
        c > 0;
        o = 256 * o + t[e + h], h += p, c -= 8
      );
      for (
        a = o & ((1 << -c) - 1), o >>= -c, c += n;
        c > 0;
        a = 256 * a + t[e + h], h += p, c -= 8
      );
      if (0 === o) o = 1 - u;
      else {
        if (o === l) return a ? NaN : (1 / 0) * (d ? -1 : 1);
        (a += Math.pow(2, n)), (o -= u);
      }
      return (d ? -1 : 1) * a * Math.pow(2, o - n);
    },
    write: function (t, e, i, n, r, o) {
      var a,
        s,
        l,
        u = 8 * o - r - 1,
        c = (1 << u) - 1,
        h = c >> 1,
        p = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        d = n ? 0 : o - 1,
        f = n ? 1 : -1,
        g = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
      for (
        e = Math.abs(e),
          isNaN(e) || e === 1 / 0
            ? ((s = isNaN(e) ? 1 : 0), (a = c))
            : ((a = Math.floor(Math.log(e) / Math.LN2)),
              e * (l = Math.pow(2, -a)) < 1 && (a--, (l *= 2)),
              (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 &&
                (a++, (l /= 2)),
              a + h >= c
                ? ((s = 0), (a = c))
                : a + h >= 1
                ? ((s = (e * l - 1) * Math.pow(2, r)), (a += h))
                : ((s = e * Math.pow(2, h - 1) * Math.pow(2, r)), (a = 0)));
        r >= 8;
        t[i + d] = 255 & s, d += f, s /= 256, r -= 8
      );
      for (
        a = (a << r) | s, u += r;
        u > 0;
        t[i + d] = 255 & a, d += f, a /= 256, u -= 8
      );
      t[i + d - f] |= 128 * g;
    },
  },
  pz = fz,
  dz = hz;
function fz(t) {
  (this.buf =
    ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0)),
    (this.pos = 0),
    (this.type = 0),
    (this.length = this.buf.length);
}
(fz.Varint = 0), (fz.Fixed64 = 1), (fz.Bytes = 2), (fz.Fixed32 = 5);
var gz = 4294967296,
  mz = 1 / gz,
  yz = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
function vz(t) {
  return t.type === fz.Bytes ? t.readVarint() + t.pos : t.pos + 1;
}
function bz(t, e, i) {
  return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
}
function xz(t, e, i) {
  var n =
    e <= 16383
      ? 1
      : e <= 2097151
      ? 2
      : e <= 268435455
      ? 3
      : Math.floor(Math.log(e) / (7 * Math.LN2));
  i.realloc(n);
  for (var r = i.pos - 1; r >= t; r--) i.buf[r + n] = i.buf[r];
}
function _z(t, e) {
  for (var i = 0; i < t.length; i++) e.writeVarint(t[i]);
}
function Sz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeSVarint(t[i]);
}
function Mz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeFloat(t[i]);
}
function Cz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeDouble(t[i]);
}
function wz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeBoolean(t[i]);
}
function Az(t, e) {
  for (var i = 0; i < t.length; i++) e.writeFixed32(t[i]);
}
function Ez(t, e) {
  for (var i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
}
function Dz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeFixed64(t[i]);
}
function Tz(t, e) {
  for (var i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
}
function Pz(t, e) {
  return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + 16777216 * t[e + 3];
}
function Lz(t, e, i) {
  (t[i] = e),
    (t[i + 1] = e >>> 8),
    (t[i + 2] = e >>> 16),
    (t[i + 3] = e >>> 24);
}
function Iz(t, e) {
  return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + (t[e + 3] << 24);
}
function Nz(t) {
  if (!t) throw new Error("geojson is required");
  switch (t.type) {
    case "Feature":
      return Rz(t);
    case "FeatureCollection":
      return (function (t) {
        var e = {
          type: "FeatureCollection",
        };
        return (
          Object.keys(t).forEach(function (i) {
            switch (i) {
              case "type":
              case "features":
                return;
              default:
                e[i] = t[i];
            }
          }),
          (e.features = t.features.map(function (t) {
            return Rz(t);
          })),
          e
        );
      })(t);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return Fz(t);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Rz(t) {
  var e = {
    type: "Feature",
  };
  return (
    Object.keys(t).forEach(function (i) {
      switch (i) {
        case "type":
        case "properties":
        case "geometry":
          return;
        default:
          e[i] = t[i];
      }
    }),
    (e.properties = Oz(t.properties)),
    (e.geometry = Fz(t.geometry)),
    e
  );
}
function Oz(t) {
  var e = {};
  return t
    ? (Object.keys(t).forEach(function (i) {
        var n = t[i];
        "object" == typeof n
          ? null === n
            ? (e[i] = null)
            : Array.isArray(n)
            ? (e[i] = n.map(function (t) {
                return t;
              }))
            : (e[i] = Oz(n))
          : (e[i] = n);
      }),
      e)
    : e;
}
function Fz(t) {
  var e = {
    type: t.type,
  };
  return (
    t.bbox && (e.bbox = t.bbox),
    "GeometryCollection" === t.type
      ? ((e.geometries = t.geometries.map(function (t) {
          return Fz(t);
        })),
        e)
      : ((e.coordinates = zz(t.coordinates)), e)
  );
}
function zz(t) {
  var e = t;
  return "object" != typeof e[0]
    ? e.slice()
    : e.map(function (t) {
        return zz(t);
      });
}
function kz(t, e, i) {
  void 0 === i && (i = {});
  var n = {
    type: "Feature",
  };
  return (
    (0 === i.id || i.id) && (n.id = i.id),
    i.bbox && (n.bbox = i.bbox),
    (n.properties = e || {}),
    (n.geometry = t),
    n
  );
}
function Bz(t, e) {
  void 0 === e && (e = {});
  var i = {
    type: "FeatureCollection",
  };
  return (
    e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), (i.features = t), i
  );
}
function Gz(t) {
  if (Array.isArray(t)) return t;
  if ("Feature" === t.type) {
    if (null !== t.geometry) return t.geometry.coordinates;
  } else if (t.coordinates) return t.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function Uz(t) {
  for (var e, i, n = Gz(t), r = 0, o = 1; o < n.length; )
    (e = i || n[0]), (r += ((i = n[o])[0] - e[0]) * (i[1] + e[1])), o++;
  return r > 0;
}
function jz(t, e) {
  if ("Feature" === t.type) e(t, 0);
  else if ("FeatureCollection" === t.type)
    for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);
}
function Hz(t, e) {
  var i,
    n,
    r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p = 0,
    d = "FeatureCollection" === t.type,
    f = "Feature" === t.type,
    g = d ? t.features.length : 1;
  for (i = 0; i < g; i++) {
    for (
      s = d ? t.features[i].geometry : f ? t.geometry : t,
        u = d ? t.features[i].properties : f ? t.properties : {},
        c = d ? t.features[i].bbox : f ? t.bbox : void 0,
        h = d ? t.features[i].id : f ? t.id : void 0,
        a = (l = !!s && "GeometryCollection" === s.type)
          ? s.geometries.length
          : 1,
        r = 0;
      r < a;
      r++
    )
      if (null !== (o = l ? s.geometries[r] : s))
        switch (o.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            if (!1 === e(o, p, u, c, h)) return !1;
            break;
          case "GeometryCollection":
            for (n = 0; n < o.geometries.length; n++)
              if (!1 === e(o.geometries[n], p, u, c, h)) return !1;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      else if (!1 === e(null, p, u, c, h)) return !1;
    p++;
  }
}
function Vz(t, e) {
  if (!(i = e = e || {}) || i.constructor !== Object)
    throw new Error("options is invalid");
  var i,
    n = e.reverse || !1,
    r = e.mutate || !1;
  if (!t) throw new Error("<geojson> is required");
  if ("boolean" != typeof n) throw new Error("<reverse> must be a boolean");
  if ("boolean" != typeof r) throw new Error("<mutate> must be a boolean");
  !1 === r && (t = Nz(t));
  var o = [];
  switch (t.type) {
    case "GeometryCollection":
      return (
        Hz(t, function (t) {
          Wz(t, n);
        }),
        t
      );
    case "FeatureCollection":
      return (
        jz(t, function (t) {
          jz(Wz(t, n), function (t) {
            o.push(t);
          });
        }),
        Bz(o)
      );
  }
  return Wz(t, n);
}
function Wz(t, e) {
  switch ("Feature" === t.type ? t.geometry.type : t.type) {
    case "GeometryCollection":
      return (
        Hz(t, function (t) {
          Wz(t, e);
        }),
        t
      );
    case "LineString":
      return qz(Gz(t), e), t;
    case "Polygon":
      return Yz(Gz(t), e), t;
    case "MultiLineString":
      return (
        Gz(t).forEach(function (t) {
          qz(t, e);
        }),
        t
      );
    case "MultiPolygon":
      return (
        Gz(t).forEach(function (t) {
          Yz(t, e);
        }),
        t
      );
    case "Point":
    case "MultiPoint":
      return t;
  }
}
function qz(t, e) {
  Uz(t) === e && t.reverse();
}
function Yz(t, e) {
  Uz(t[0]) !== e && t[0].reverse();
  for (var i = 1; i < t.length; i++) Uz(t[i]) === e && t[i].reverse();
}
function Xz(t) {
  if (!t) throw new Error("geojson is required");
  var e = [];
  return (
    (function (t, e) {
      Hz(t, function (t, i, n, r, o) {
        var a,
          s = null === t ? null : t.type;
        switch (s) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return (
              !1 !==
                e(
                  kz(t, n, {
                    bbox: r,
                    id: o,
                  }),
                  i,
                  0
                ) && void 0
            );
        }
        switch (s) {
          case "MultiPoint":
            a = "Point";
            break;
          case "MultiLineString":
            a = "LineString";
            break;
          case "MultiPolygon":
            a = "Polygon";
        }
        for (var l = 0; l < t.coordinates.length; l++) {
          var u = t.coordinates[l];
          if (
            !1 ===
            e(
              kz(
                {
                  type: a,
                  coordinates: u,
                },
                n
              ),
              i,
              l
            )
          )
            return !1;
        }
      });
    })(t, function (t) {
      e.push(t);
    }),
    Bz(e)
  );
}
fz.prototype = {
  destroy: function () {
    this.buf = null;
  },
  readFields: function (t, e, i) {
    for (i = i || this.length; this.pos < i; ) {
      var n = this.readVarint(),
        r = n >> 3,
        o = this.pos;
      (this.type = 7 & n), t(r, e, this), this.pos === o && this.skip(n);
    }
    return e;
  },
  readMessage: function (t, e) {
    return this.readFields(t, e, this.readVarint() + this.pos);
  },
  readFixed32: function () {
    var t = Pz(this.buf, this.pos);
    return (this.pos += 4), t;
  },
  readSFixed32: function () {
    var t = Iz(this.buf, this.pos);
    return (this.pos += 4), t;
  },
  readFixed64: function () {
    var t = Pz(this.buf, this.pos) + Pz(this.buf, this.pos + 4) * gz;
    return (this.pos += 8), t;
  },
  readSFixed64: function () {
    var t = Pz(this.buf, this.pos) + Iz(this.buf, this.pos + 4) * gz;
    return (this.pos += 8), t;
  },
  readFloat: function () {
    var t = dz.read(this.buf, this.pos, !0, 23, 4);
    return (this.pos += 4), t;
  },
  readDouble: function () {
    var t = dz.read(this.buf, this.pos, !0, 52, 8);
    return (this.pos += 8), t;
  },
  readVarint: function (t) {
    var e,
      i,
      n = this.buf;
    return (
      (e = 127 & (i = n[this.pos++])),
      i < 128
        ? e
        : ((e |= (127 & (i = n[this.pos++])) << 7),
          i < 128
            ? e
            : ((e |= (127 & (i = n[this.pos++])) << 14),
              i < 128
                ? e
                : ((e |= (127 & (i = n[this.pos++])) << 21),
                  i < 128
                    ? e
                    : (function (t, e, i) {
                        var n,
                          r,
                          o = i.buf;
                        if (((r = o[i.pos++]), (n = (112 & r) >> 4), r < 128))
                          return bz(t, n, e);
                        if (((r = o[i.pos++]), (n |= (127 & r) << 3), r < 128))
                          return bz(t, n, e);
                        if (((r = o[i.pos++]), (n |= (127 & r) << 10), r < 128))
                          return bz(t, n, e);
                        if (((r = o[i.pos++]), (n |= (127 & r) << 17), r < 128))
                          return bz(t, n, e);
                        if (((r = o[i.pos++]), (n |= (127 & r) << 24), r < 128))
                          return bz(t, n, e);
                        if (((r = o[i.pos++]), (n |= (1 & r) << 31), r < 128))
                          return bz(t, n, e);
                        throw new Error(
                          "Expected varint not more than 10 bytes"
                        );
                      })((e |= (15 & (i = n[this.pos])) << 28), t, this))))
    );
  },
  readVarint64: function () {
    return this.readVarint(!0);
  },
  readSVarint: function () {
    var t = this.readVarint();
    return t % 2 == 1 ? (t + 1) / -2 : t / 2;
  },
  readBoolean: function () {
    return Boolean(this.readVarint());
  },
  readString: function () {
    var t = this.readVarint() + this.pos,
      e = this.pos;
    return (
      (this.pos = t),
      t - e >= 12 && yz
        ? (function (t, e, i) {
            return yz.decode(t.subarray(e, i));
          })(this.buf, e, t)
        : (function (t, e, i) {
            var n = "",
              r = e;
            for (; r < i; ) {
              var o,
                a,
                s,
                l = t[r],
                u = null,
                c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
              if (r + c > i) break;
              1 === c
                ? l < 128 && (u = l)
                : 2 === c
                ? 128 == (192 & (o = t[r + 1])) &&
                  (u = ((31 & l) << 6) | (63 & o)) <= 127 &&
                  (u = null)
                : 3 === c
                ? ((o = t[r + 1]),
                  (a = t[r + 2]),
                  128 == (192 & o) &&
                    128 == (192 & a) &&
                    ((u = ((15 & l) << 12) | ((63 & o) << 6) | (63 & a)) <=
                      2047 ||
                      (u >= 55296 && u <= 57343)) &&
                    (u = null))
                : 4 === c &&
                  ((o = t[r + 1]),
                  (a = t[r + 2]),
                  (s = t[r + 3]),
                  128 == (192 & o) &&
                    128 == (192 & a) &&
                    128 == (192 & s) &&
                    ((u =
                      ((15 & l) << 18) |
                      ((63 & o) << 12) |
                      ((63 & a) << 6) |
                      (63 & s)) <= 65535 ||
                      u >= 1114112) &&
                    (u = null)),
                null === u
                  ? ((u = 65533), (c = 1))
                  : u > 65535 &&
                    ((u -= 65536),
                    (n += String.fromCharCode(((u >>> 10) & 1023) | 55296)),
                    (u = 56320 | (1023 & u))),
                (n += String.fromCharCode(u)),
                (r += c);
            }
            return n;
          })(this.buf, e, t)
    );
  },
  readBytes: function () {
    var t = this.readVarint() + this.pos,
      e = this.buf.subarray(this.pos, t);
    return (this.pos = t), e;
  },
  readPackedVarint: function (t, e) {
    if (this.type !== fz.Bytes) return t.push(this.readVarint(e));
    var i = vz(this);
    for (t = t || []; this.pos < i; ) t.push(this.readVarint(e));
    return t;
  },
  readPackedSVarint: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readSVarint());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readSVarint());
    return t;
  },
  readPackedBoolean: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readBoolean());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readBoolean());
    return t;
  },
  readPackedFloat: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readFloat());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readFloat());
    return t;
  },
  readPackedDouble: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readDouble());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readDouble());
    return t;
  },
  readPackedFixed32: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readFixed32());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readFixed32());
    return t;
  },
  readPackedSFixed32: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readSFixed32());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readSFixed32());
    return t;
  },
  readPackedFixed64: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readFixed64());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readFixed64());
    return t;
  },
  readPackedSFixed64: function (t) {
    if (this.type !== fz.Bytes) return t.push(this.readSFixed64());
    var e = vz(this);
    for (t = t || []; this.pos < e; ) t.push(this.readSFixed64());
    return t;
  },
  skip: function (t) {
    var e = 7 & t;
    if (e === fz.Varint) for (; this.buf[this.pos++] > 127; );
    else if (e === fz.Bytes) this.pos = this.readVarint() + this.pos;
    else if (e === fz.Fixed32) this.pos += 4;
    else {
      if (e !== fz.Fixed64) throw new Error("Unimplemented type: " + e);
      this.pos += 8;
    }
  },
  writeTag: function (t, e) {
    this.writeVarint((t << 3) | e);
  },
  realloc: function (t) {
    for (var e = this.length || 16; e < this.pos + t; ) e *= 2;
    if (e !== this.length) {
      var i = new Uint8Array(e);
      i.set(this.buf), (this.buf = i), (this.length = e);
    }
  },
  finish: function () {
    return (
      (this.length = this.pos),
      (this.pos = 0),
      this.buf.subarray(0, this.length)
    );
  },
  writeFixed32: function (t) {
    this.realloc(4), Lz(this.buf, t, this.pos), (this.pos += 4);
  },
  writeSFixed32: function (t) {
    this.realloc(4), Lz(this.buf, t, this.pos), (this.pos += 4);
  },
  writeFixed64: function (t) {
    this.realloc(8),
      Lz(this.buf, -1 & t, this.pos),
      Lz(this.buf, Math.floor(t * mz), this.pos + 4),
      (this.pos += 8);
  },
  writeSFixed64: function (t) {
    this.realloc(8),
      Lz(this.buf, -1 & t, this.pos),
      Lz(this.buf, Math.floor(t * mz), this.pos + 4),
      (this.pos += 8);
  },
  writeVarint: function (t) {
    (t = +t || 0) > 268435455 || t < 0
      ? (function (t, e) {
          var i, n;
          t >= 0
            ? ((i = t % 4294967296 | 0), (n = (t / 4294967296) | 0))
            : ((n = ~(-t / 4294967296)),
              4294967295 ^ (i = ~(-t % 4294967296))
                ? (i = (i + 1) | 0)
                : ((i = 0), (n = (n + 1) | 0)));
          if (t >= 0x10000000000000000 || t < -0x10000000000000000)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e.realloc(10),
            (function (t, e, i) {
              (i.buf[i.pos++] = (127 & t) | 128),
                (t >>>= 7),
                (i.buf[i.pos++] = (127 & t) | 128),
                (t >>>= 7),
                (i.buf[i.pos++] = (127 & t) | 128),
                (t >>>= 7),
                (i.buf[i.pos++] = (127 & t) | 128),
                (t >>>= 7),
                (i.buf[i.pos] = 127 & t);
            })(i, 0, e),
            (function (t, e) {
              var i = (7 & t) << 4;
              if (((e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0)), !t)) return;
              if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                return;
              if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                return;
              if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                return;
              if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                return;
              e.buf[e.pos++] = 127 & t;
            })(n, e);
        })(t, this)
      : (this.realloc(4),
        (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
        t <= 127 ||
          ((this.buf[this.pos++] = (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
          t <= 127 ||
            ((this.buf[this.pos++] = (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
            t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
  },
  writeSVarint: function (t) {
    this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
  },
  writeBoolean: function (t) {
    this.writeVarint(Boolean(t));
  },
  writeString: function (t) {
    (t = String(t)), this.realloc(4 * t.length), this.pos++;
    var e = this.pos;
    this.pos = (function (t, e, i) {
      for (var n, r, o = 0; o < e.length; o++) {
        if ((n = e.charCodeAt(o)) > 55295 && n < 57344) {
          if (!r) {
            n > 56319 || o + 1 === e.length
              ? ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189))
              : (r = n);
            continue;
          }
          if (n < 56320) {
            (t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (r = n);
            continue;
          }
          (n = ((r - 55296) << 10) | (n - 56320) | 65536), (r = null);
        } else
          r && ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (r = null));
        n < 128
          ? (t[i++] = n)
          : (n < 2048
              ? (t[i++] = (n >> 6) | 192)
              : (n < 65536
                  ? (t[i++] = (n >> 12) | 224)
                  : ((t[i++] = (n >> 18) | 240),
                    (t[i++] = ((n >> 12) & 63) | 128)),
                (t[i++] = ((n >> 6) & 63) | 128)),
            (t[i++] = (63 & n) | 128));
      }
      return i;
    })(this.buf, t, this.pos);
    var i = this.pos - e;
    i >= 128 && xz(e, i, this),
      (this.pos = e - 1),
      this.writeVarint(i),
      (this.pos += i);
  },
  writeFloat: function (t) {
    this.realloc(4),
      dz.write(this.buf, t, this.pos, !0, 23, 4),
      (this.pos += 4);
  },
  writeDouble: function (t) {
    this.realloc(8),
      dz.write(this.buf, t, this.pos, !0, 52, 8),
      (this.pos += 8);
  },
  writeBytes: function (t) {
    var e = t.length;
    this.writeVarint(e), this.realloc(e);
    for (var i = 0; i < e; i++) this.buf[this.pos++] = t[i];
  },
  writeRawMessage: function (t, e) {
    this.pos++;
    var i = this.pos;
    t(e, this);
    var n = this.pos - i;
    n >= 128 && xz(i, n, this),
      (this.pos = i - 1),
      this.writeVarint(n),
      (this.pos += n);
  },
  writeMessage: function (t, e, i) {
    this.writeTag(t, fz.Bytes), this.writeRawMessage(e, i);
  },
  writePackedVarint: function (t, e) {
    e.length && this.writeMessage(t, _z, e);
  },
  writePackedSVarint: function (t, e) {
    e.length && this.writeMessage(t, Sz, e);
  },
  writePackedBoolean: function (t, e) {
    e.length && this.writeMessage(t, wz, e);
  },
  writePackedFloat: function (t, e) {
    e.length && this.writeMessage(t, Mz, e);
  },
  writePackedDouble: function (t, e) {
    e.length && this.writeMessage(t, Cz, e);
  },
  writePackedFixed32: function (t, e) {
    e.length && this.writeMessage(t, Az, e);
  },
  writePackedSFixed32: function (t, e) {
    e.length && this.writeMessage(t, Ez, e);
  },
  writePackedFixed64: function (t, e) {
    e.length && this.writeMessage(t, Dz, e);
  },
  writePackedSFixed64: function (t, e) {
    e.length && this.writeMessage(t, Tz, e);
  },
  writeBytesField: function (t, e) {
    this.writeTag(t, fz.Bytes), this.writeBytes(e);
  },
  writeFixed32Field: function (t, e) {
    this.writeTag(t, fz.Fixed32), this.writeFixed32(e);
  },
  writeSFixed32Field: function (t, e) {
    this.writeTag(t, fz.Fixed32), this.writeSFixed32(e);
  },
  writeFixed64Field: function (t, e) {
    this.writeTag(t, fz.Fixed64), this.writeFixed64(e);
  },
  writeSFixed64Field: function (t, e) {
    this.writeTag(t, fz.Fixed64), this.writeSFixed64(e);
  },
  writeVarintField: function (t, e) {
    this.writeTag(t, fz.Varint), this.writeVarint(e);
  },
  writeSVarintField: function (t, e) {
    this.writeTag(t, fz.Varint), this.writeSVarint(e);
  },
  writeStringField: function (t, e) {
    this.writeTag(t, fz.Bytes), this.writeString(e);
  },
  writeFloatField: function (t, e) {
    this.writeTag(t, fz.Fixed32), this.writeFloat(e);
  },
  writeDoubleField: function (t, e) {
    this.writeTag(t, fz.Fixed64), this.writeDouble(e);
  },
  writeBooleanField: function (t, e) {
    this.writeVarintField(t, Boolean(e));
  },
};
const Qz = (function (t, e) {
    var i,
      n,
      r = 4.5;
    function o(t) {
      return (
        t &&
          ("function" == typeof r && n.pointRadius(+r.apply(this, arguments)),
          RT(t, i(n))),
        n.result()
      );
    }
    return (
      (o.area = function (t) {
        return RT(t, i(_P)), _P.result();
      }),
      (o.measure = function (t) {
        return RT(t, i(sL)), sL.result();
      }),
      (o.bounds = function (t) {
        return RT(t, i(PP)), PP.result();
      }),
      (o.centroid = function (t) {
        return RT(t, i(ZP)), ZP.result();
      }),
      (o.projection = function (e) {
        return arguments.length
          ? ((i = null == e ? ((t = null), dP) : (t = e).stream), o)
          : t;
      }),
      (o.context = function (t) {
        return arguments.length
          ? ((n = null == t ? ((e = null), new lL()) : new JP((e = t))),
            "function" != typeof r && n.pointRadius(r),
            o)
          : e;
      }),
      (o.pointRadius = function (t) {
        return arguments.length
          ? ((r = "function" == typeof t ? t : (n.pointRadius(+t), +t)), o)
          : r;
      }),
      o.projection(t).context(e)
    );
  })(),
  Zz = {
    centroid: !1,
    name: !1,
    bbox: !1,
    rewind: !1,
  },
  Jz = (t) => {
    if (t.geometry.type.startsWith("Multi")) {
      const e = Xz(t).features[0];
      return rT(rT({}, e), e.properties);
    }
    return rT(rT({}, t), t.properties);
  },
  Kz = (t, e = {}, i) => {
    i.type = cF.GEO;
    const n = XO(Zz, e),
      { centroid: r, name: o, bbox: a, rewind: s } = n;
    if (Array.isArray(t))
      return ((t) => {
        const e = [];
        return (
          t.forEach((t) => {
            "FeatureCollection" === t.type
              ? t.features.forEach((t) => {
                  e.push(Jz(t));
                })
              : e.push(Jz(t));
          }),
          e
        );
      })(t);
    let l = t.features;
    return (
      s && (l = Vz(t).features),
      l.forEach((t) => {
        if (r) {
          const e = Qz.centroid(t);
          (t.centroidX = e[0]), (t.centroidY = e[1]);
        }
        if ((o && (t.name = t.properties.name), a)) {
          const e = Qz.bounds(t);
          t.bbox = e;
        }
      }),
      (t.features = l),
      t
    );
  },
  $z = {};
var tk = {
  exports: {},
};
!(function (t) {
  var e = Object.prototype.hasOwnProperty,
    i = "~";
  function n() {}
  function r(t, e, i) {
    (this.fn = t), (this.context = e), (this.once = i || !1);
  }
  function o(t, e, n, o, a) {
    if ("function" != typeof n)
      throw new TypeError("The listener must be a function");
    var s = new r(n, o || t, a),
      l = i ? i + e : e;
    return (
      t._events[l]
        ? t._events[l].fn
          ? (t._events[l] = [t._events[l], s])
          : t._events[l].push(s)
        : ((t._events[l] = s), t._eventsCount++),
      t
    );
  }
  function a(t, e) {
    0 == --t._eventsCount ? (t._events = new n()) : delete t._events[e];
  }
  function s() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (i = !1)),
    (s.prototype.eventNames = function () {
      var t,
        n,
        r = [];
      if (0 === this._eventsCount) return r;
      for (n in (t = this._events)) e.call(t, n) && r.push(i ? n.slice(1) : n);
      return Object.getOwnPropertySymbols
        ? r.concat(Object.getOwnPropertySymbols(t))
        : r;
    }),
    (s.prototype.listeners = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      if (!n) return [];
      if (n.fn) return [n.fn];
      for (var r = 0, o = n.length, a = new Array(o); r < o; r++)
        a[r] = n[r].fn;
      return a;
    }),
    (s.prototype.listenerCount = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      return n ? (n.fn ? 1 : n.length) : 0;
    }),
    (s.prototype.emit = function (t, e, n, r, o, a) {
      var s = i ? i + t : t;
      if (!this._events[s]) return !1;
      var l,
        u,
        c = this._events[s],
        h = arguments.length;
      if (c.fn) {
        switch ((c.once && this.removeListener(t, c.fn, void 0, !0), h)) {
          case 1:
            return c.fn.call(c.context), !0;
          case 2:
            return c.fn.call(c.context, e), !0;
          case 3:
            return c.fn.call(c.context, e, n), !0;
          case 4:
            return c.fn.call(c.context, e, n, r), !0;
          case 5:
            return c.fn.call(c.context, e, n, r, o), !0;
          case 6:
            return c.fn.call(c.context, e, n, r, o, a), !0;
        }
        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
        c.fn.apply(c.context, l);
      } else {
        var p,
          d = c.length;
        for (u = 0; u < d; u++)
          switch (
            (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), h)
          ) {
            case 1:
              c[u].fn.call(c[u].context);
              break;
            case 2:
              c[u].fn.call(c[u].context, e);
              break;
            case 3:
              c[u].fn.call(c[u].context, e, n);
              break;
            case 4:
              c[u].fn.call(c[u].context, e, n, r);
              break;
            default:
              if (!l)
                for (p = 1, l = new Array(h - 1); p < h; p++)
                  l[p - 1] = arguments[p];
              c[u].fn.apply(c[u].context, l);
          }
      }
      return !0;
    }),
    (s.prototype.on = function (t, e, i) {
      return o(this, t, e, i, !1);
    }),
    (s.prototype.once = function (t, e, i) {
      return o(this, t, e, i, !0);
    }),
    (s.prototype.removeListener = function (t, e, n, r) {
      var o = i ? i + t : t;
      if (!this._events[o]) return this;
      if (!e) return a(this, o), this;
      var s = this._events[o];
      if (s.fn)
        s.fn !== e || (r && !s.once) || (n && s.context !== n) || a(this, o);
      else {
        for (var l = 0, u = [], c = s.length; l < c; l++)
          (s[l].fn !== e || (r && !s[l].once) || (n && s[l].context !== n)) &&
            u.push(s[l]);
        u.length ? (this._events[o] = 1 === u.length ? u[0] : u) : a(this, o);
      }
      return this;
    }),
    (s.prototype.removeAllListeners = function (t) {
      var e;
      return (
        t
          ? ((e = i ? i + t : t), this._events[e] && a(this, e))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prefixed = i),
    (s.EventEmitter = s),
    (t.exports = s);
})(tk);
var ek = tk.exports,
  ik = 0;
function nk(t) {
  var e,
    i = ++ik;
  return (null == (e = t) ? "" : gF(e)) + i;
}
function rk(t = "dataset") {
  return nk(t + "_");
}
class ok {
  constructor(t) {
    let e;
    (this.options = t),
      (this.isDataSet = !0),
      (this.transformMap = {}),
      (this.parserMap = {}),
      (this.dataViewMap = {}),
      (this.target = new ek()),
      (e = (null == t ? void 0 : t.name) ? t.name : rk("dataset")),
      (this.name = e);
  }
  getDataView(t) {
    return this.dataViewMap[t];
  }
  setDataView(t, e) {
    if (this.dataViewMap[t])
      throw new Error(`Error: dataView ${t} 之前已存在，请重新命名`);
    this.dataViewMap[t] = e;
  }
  removeDataView(t) {
    this.dataViewMap &&
      ((this.dataViewMap[t] = null), delete this.dataViewMap[t]);
  }
  registerParser(t, e) {
    this.parserMap[t], (this.parserMap[t] = e);
  }
  removeParser(t) {
    this.parserMap && ((this.parserMap[t] = null), delete this.parserMap[t]);
  }
  getParser(t) {
    return this.parserMap[t] || this.parserMap.default;
  }
  registerTransform(t, e) {
    this.transformMap[t], (this.transformMap[t] = e);
  }
  removeTransform(t) {
    this.transformMap &&
      ((this.transformMap[t] = null), delete this.transformMap[t]);
  }
  getTransform(t) {
    return this.transformMap[t];
  }
  destroy() {
    (this.transformMap = null),
      (this.parserMap = null),
      (this.dataViewMap = null),
      this.target.removeAllListeners();
  }
}
class ak {
  constructor(t, e) {
    let i;
    (this.dataSet = t),
      (this.options = e),
      (this.isDataView = !0),
      (this.target = new ek()),
      (this.transformsArr = []),
      (this.rawData = {}),
      (this.history = !1),
      (this.historyData = []),
      (this.parserData = {}),
      (this.latestData = {}),
      (this.reRunAllTransform = (
        t = {
          pushHistory: !0,
          emitMessage: !0,
        }
      ) => (
        this.resetTransformData(),
        this.transformsArr.forEach((e) => {
          this.executeTransform(
            e,
            oT(rT({}, t), {
              emitMessage: !1,
            })
          );
        }),
        !1 !== (null == t ? void 0 : t.emitMessage) &&
          this.target.emit("change", []),
        this
      )),
      (i = (null == e ? void 0 : e.name) ? e.name : rk("dataview")),
      (this.name = i),
      (null == e ? void 0 : e.history) && (this.history = e.history),
      this.dataSet.setDataView(i, this);
  }
  parse(t, e) {
    let i = !0;
    (t instanceof ak || !1 === (null == e ? void 0 : e.clone)) && (i = !1);
    const n = i ? t : SO(t);
    if (e) {
      e = SO(e);
      const t = this.dataSet.getParser(e.type || "bytejson")(
        n,
        e.options,
        this
      );
      (this.rawData = n),
        (this.parserData = t),
        this.history && this.historyData.push(n, t),
        (this.latestData = t);
    } else
      (this.parserData = n),
        (this.rawData = n),
        this.history && this.historyData.push(n),
        (this.latestData = n);
    return this.target.emit("change", []), this;
  }
  transform(t, e = !0) {
    return (
      t &&
        t.type &&
        (this.transformsArr.push(t),
        e && ((t = SO(t)), this.executeTransform(t))),
      this
    );
  }
  sortTransform() {
    this.transformsArr.sort((t, e) => {
      var i, n;
      return null != (n = null != (i = t.level) ? i : 0 - e.level) ? n : 0;
    });
  }
  executeTransform(
    t,
    e = {
      pushHistory: !0,
      emitMessage: !0,
    }
  ) {
    const { pushHistory: i, emitMessage: n } = e,
      r = this.dataSet.getTransform(t.type)(this.latestData, t.options);
    this.history && !1 !== i && this.historyData.push(r),
      (this.latestData = r),
      !1 !== n && this.target.emit("change", []);
  }
  resetTransformData() {
    (this.latestData = this.parserData),
      this.history &&
        ((this.historyData.length = 0),
        this.historyData.push(this.rawData, this.parserData));
  }
  destroy() {
    this.dataSet.removeDataView(this.name);
  }
}
const sk = !0,
  lk = !0,
  uk = {
    mode: "webgis",
    zoom: 3.75,
    center: [104.299, 33.518],
    rotation: 4,
    pitch: 40,
    enableZoom: !0,
    enablePitch: !0,
    enableRotate: !0,
    enablePan: !0,
    lock: !1,
    zoomSpeed: 1,
    rotateSpeed: 1,
    panSpeed: 1,
    maxPitch: 80,
    minPitch: 0,
    maxRotation: 360,
    minRotation: -360,
    maxZoom: 20,
    minZoom: 2,
    drillSave: !0,
  },
  ck = {
    ambient: {
      enabled: !0,
      color: "#FFFFFF",
      intensity: 35,
    },
    directional: {
      enabled: !0,
      color: "#FFFFFF",
      intensity: 35,
      x: 0.3,
      y: -0.5,
      z: 0.5,
      shadow: {
        enabled: !0,
        color: "#000000",
        opacity: 0.3,
        size: 1024,
        bias: 1e-4,
      },
    },
  },
  hk = {
    offsetX: 0,
    offsetY: 0,
    dpr: window.devicePixelRatio ? window.devicePixelRatio : 1,
    background: {
      color: "rgba(12,9,41,1)",
      map: null,
      transparent: !1,
    },
  },
  pk = 12,
  dk = 400,
  fk = "rgba(215,242,255,0.6)",
  gk = "SourceHanSansCN-Normal",
  mk = {
    fontFamily:
      "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
    fontSize: pk,
    fontWeight: dk,
    color: fk,
    strokeWidth: 0,
    strokeColor: "rgba(0,0,0,1)",
    offsetX: 0,
    offsetY: 0,
  },
  yk = {
    color: null,
    opacity: 1,
    padding: {
      top: 5,
      left: 5,
      right: 5,
      bottom: 5,
    },
    shadow: {
      color: "rgb(255, 255, 255)",
      blur: 0,
      offsetX: 0,
      offsetY: 0,
    },
    borderRadius: null,
  },
  vk = "1.2",
  bk = "1.4";
var xk, _k;
((_k = xk || (xk = {})).GEOJSON = "geojson"),
  (_k.GEOBUF = "geobuf"),
  (_k.GEOJSON_URL = "geojson_url"),
  (_k.GEOBUF_URL = "geobuf_url");
const Sk = {
    visible: !0,
    offset: [0, 0, 0],
    opacity: 1,
    zIndex: 0,
    zoomRange: [0, 24],
  },
  Mk = "100000";
var Ck, wk, Ak, Ek, Dk, Tk;
((wk = Ck || (Ck = {}))[(wk.wgs84 = 0)] = "wgs84"),
  (wk[(wk.gcj = 1)] = "gcj"),
  ((Ek = Ak || (Ak = {}))[(Ek.pbf = 0)] = "pbf"),
  (Ek[(Ek.geojson = 1)] = "geojson"),
  ((Tk = Dk || (Dk = {}))[(Tk.downloadfile = 0)] = "downloadfile"),
  (Tk[(Tk.browse = 1)] = "browse");
const Pk = {
    enabled: !0,
    data: {
      0: {
        type: xk.GEOBUF_URL,
        data: `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/data/districtaggregate_province_kld_gc.pbf`,
        simplify: {
          enabled: !0,
          tolerance: 0.025,
        },
      },
      1: {
        type: xk.GEOBUF_URL,
        data: `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/data/districtaggregate_city_kld_gc.pbf`,
        simplify: {
          enabled: !0,
          tolerance: 0.005,
        },
      },
      2: {
        type: xk.GEOBUF_URL,
        data: `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/data/districtaggregate_county_kld_gc.pbf`,
        simplify: {
          enabled: !1,
        },
      },
      region: {},
    },
    level: {
      range: [0, 2],
      adcode: Mk,
    },
    granularity: {
      0: 1,
      1: 2,
      2: 3,
      3: 3,
      region: 1,
    },
    duration: 500,
    preventMouse: !1,
    drillDownEvent: "dblclick",
    drillUpEvent: "undblclick",
  },
  Lk = ["110000", "310000", "120000", "500000", "810000", "820000", "710000"],
  Ik = `https://lf-digitaltwin-cim.${atob(
    "Ynl0ZXRvcy5jb20="
  )}/obj/bytedcimplus/gaode/t2/{z}/{x}/{y}.jpg`,
  Nk = `https://lf-digitaltwin-cim.${atob(
    "Ynl0ZXRvcy5jb20="
  )}/obj/bytedcimplus/nextzen/{z}/{x}/{y}.png`,
  Rk = {
    common: Sk,
    enabled: !0,
    data: {
      district: {
        type: xk.GEOBUF_URL,
        data: `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/data/countryborder_208_gc.pbf`,
      },
      subDistrict: {
        type: xk.GEOBUF_URL,
        data: `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/data/district_100000_1_gc.pbf`,
      },
    },
    fields: {
      majorPOIField: "name",
      minorPOIField: "value",
    },
    poi: {
      enabled: !0,
      hideOnMove: !1,
      alignment: "middle",
      offsetX: 0,
      offsetY: 0,
      coverEnable: !1,
      orient: "vertical",
      major: {
        enabled: !0,
        fontFamily: gk,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        nameMap: {},
        offsetX: 0,
        offsetY: 0,
      },
    },
    districtStyle: {
      enabled: !0,
      heightScale: 1,
      fill: {
        color: "rgba(4,28,34,1)",
        map: "",
        normalMap: "",
        normalScale: 30,
        metalness: 0,
        roughness: 1,
        opacity: 1,
      },
      innerShadow: {
        enabled: !0,
        shadowColor: "rgba(0,90,117,1)",
        shadowBlurScale: 0.1,
      },
      boundaryStreamer: {
        enabled: !0,
        lineLength: 60,
        lineWidth: 8,
        lineHeadColor: "rgba(26,255,255,1)",
        lineColor: "rgba(55,114,255,0)",
        lineHeadRatio: 0.1,
        speed: -10,
      },
      sideConfig: {
        map: null,
        colorConfig: {
          type: "linear",
          range: ["rgba(60,177,209,1)", "rgba(6,33,38,0.5)"],
        },
      },
      stroke: {
        color: "rgba(46,176,200,1)",
        opacity: 1,
        width: 2,
      },
      bottomStroke: {
        color: "#69dcbe",
        opacity: 1,
        width: 1,
      },
    },
    extrudeBackgroundStyle: {
      enabled: !1,
      heightScale: 1,
      fill: {
        map: Ik || ff("images", "china.webp"),
        normalMap: Nk,
        normalScale: 30,
        metalness: 0,
        roughness: 1,
        opacity: 1,
      },
      sideConfig: {
        map: null,
        colorConfig: {
          type: "linear",
          range: ["rgba(56,85,91,0.9)", "rgba(100,208,208,1)"],
        },
      },
    },
    subDistrictStyle: {
      stroke: {
        color: "rgba(30,89,99,1)",
        opacity: 1,
        width: 1,
      },
    },
    drill: Pk,
    interaction: {
      hover: {
        enabled: !1,
        trigger: "mousemove",
        effect: {
          color: vk,
          poi: !1,
        },
      },
      select: {
        enabled: !1,
        trigger: "click",
        multi: !1,
        effect: {
          color: bk,
          poi: !1,
        },
      },
    },
    viewClip: null,
  },
  Ok = {
    cameraChange: !0,
    cameraTween: !0,
  };
function Fk(t) {
  return !![
    "loaded",
    "destroy",
    "resize",
    "viewportChange",
    "pan",
    "panStart",
    "panEnd",
    "zoom",
    "zoomStart",
    "zoomEnd",
    "rotate",
    "rotateStart",
    "rotateEnd",
    "pitch",
    "pitchStart",
    "pitchEnd",
    "hover",
    "select",
    "drill",
    "drillUp",
    "drillUpEnd",
    "drillDown",
    "drillDownEnd",
    "drillEnd",
  ].includes(t);
}
var zk = "named",
  kk = "name",
  Bk = "unmanaged",
  Gk = "inject",
  Uk = "multi_inject",
  jk = "inversify:paramtypes",
  Hk = "post_construct",
  Vk = "Request",
  Wk = "Singleton",
  qk = "Transient",
  Yk = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider",
  },
  Xk = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable",
  },
  Qk = 0;
function Zk() {
  return Qk++;
}
var Jk = (function () {
    function t(t, e) {
      (this.id = Zk()),
        (this.activated = !1),
        (this.serviceIdentifier = t),
        (this.scope = e),
        (this.type = Yk.Invalid),
        (this.constraint = function (t) {
          return !0;
        }),
        (this.implementationType = null),
        (this.cache = null),
        (this.factory = null),
        (this.provider = null),
        (this.onActivation = null),
        (this.dynamicValue = null);
    }
    return (
      (t.prototype.clone = function () {
        var e = new t(this.serviceIdentifier, this.scope);
        return (
          (e.activated = !1),
          (e.implementationType = this.implementationType),
          (e.dynamicValue = this.dynamicValue),
          (e.scope = this.scope),
          (e.type = this.type),
          (e.factory = this.factory),
          (e.provider = this.provider),
          (e.constraint = this.constraint),
          (e.onActivation = this.onActivation),
          (e.cache = this.cache),
          e
        );
      }),
      t
    );
  })(),
  Kk = "NULL argument",
  $k = "Key Not Found",
  tB = "Ambiguous match found for serviceIdentifier:",
  eB = "No matching bindings found for serviceIdentifier:",
  iB = "Missing required @injectable annotation in:",
  nB = "Missing required @inject or @multiInject annotation in:",
  rB = "Circular dependency found:",
  oB = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return (
      "The number of constructor arguments in the derived class " +
      t[0] +
      " must be >= than the number of constructor arguments of its base class."
    );
  },
  aB = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return "@postConstruct error in class " + t[0] + ": " + t[1];
  },
  sB = "Maximum call stack size exceeded",
  lB = (function () {
    function t() {}
    return (
      (t.prototype.getConstructorMetadata = function (t) {
        return {
          compilerGeneratedMetadata: Reflect.getMetadata(jk, t),
          userGeneratedMetadata:
            Reflect.getMetadata("inversify:tagged", t) || {},
        };
      }),
      (t.prototype.getPropertiesMetadata = function (t) {
        return Reflect.getMetadata("inversify:tagged_props", t) || [];
      }),
      t
    );
  })(),
  uB = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1,
  };
function cB(t) {
  return t instanceof RangeError || t.message === sB;
}
function hB(t) {
  return "function" == typeof t
    ? t.name
    : "symbol" == typeof t
    ? t.toString()
    : t;
}
function pB(t, e, i) {
  var n = "",
    r = i(t, e);
  return (
    0 !== r.length &&
      ((n = "\nRegistered bindings:"),
      r.forEach(function (t) {
        var e = "Object";
        null !== t.implementationType && (e = gB(t.implementationType)),
          (n = n + "\n " + e),
          t.constraint.metaData && (n = n + " - " + t.constraint.metaData);
      })),
    n
  );
}
function dB(t, e) {
  return (
    null !== t.parentRequest &&
    (t.parentRequest.serviceIdentifier === e || dB(t.parentRequest, e))
  );
}
function fB(t) {
  t.childRequests.forEach(function (t) {
    if (dB(t, t.serviceIdentifier)) {
      var e = (function (t) {
        var e = (function t(e, i) {
          void 0 === i && (i = []);
          var n = hB(e.serviceIdentifier);
          return (
            i.push(n), null !== e.parentRequest ? t(e.parentRequest, i) : i
          );
        })(t);
        return e.reverse().join(" --\x3e ");
      })(t);
      throw new Error(rB + " " + e);
    }
    fB(t);
  });
}
function gB(t) {
  if (t.name) return t.name;
  var e = t.toString(),
    i = e.match(/^function\s*([^\s(]+)/);
  return i ? i[1] : "Anonymous function: " + e;
}
var mB = (function () {
    function t(t) {
      (this.id = Zk()), (this.container = t);
    }
    return (
      (t.prototype.addPlan = function (t) {
        this.plan = t;
      }),
      (t.prototype.setCurrentRequest = function (t) {
        this.currentRequest = t;
      }),
      t
    );
  })(),
  yB = (function () {
    function t(t, e) {
      (this.key = t), (this.value = e);
    }
    return (
      (t.prototype.toString = function () {
        return this.key === zk
          ? "named: " + this.value.toString() + " "
          : "tagged: { key:" +
              this.key.toString() +
              ", value: " +
              this.value +
              " }";
      }),
      t
    );
  })(),
  vB = function (t, e) {
    (this.parentContext = t), (this.rootRequest = e);
  },
  bB = (function () {
    function t(t) {
      this._cb = t;
    }
    return (
      (t.prototype.unwrap = function () {
        return this._cb();
      }),
      t
    );
  })(),
  xB = (function () {
    function t(t) {
      this.str = t;
    }
    return (
      (t.prototype.startsWith = function (t) {
        return 0 === this.str.indexOf(t);
      }),
      (t.prototype.endsWith = function (t) {
        var e,
          i = t.split("").reverse().join("");
        return (
          (e = this.str.split("").reverse().join("")),
          this.startsWith.call(
            {
              str: e,
            },
            i
          )
        );
      }),
      (t.prototype.contains = function (t) {
        return -1 !== this.str.indexOf(t);
      }),
      (t.prototype.equals = function (t) {
        return this.str === t;
      }),
      (t.prototype.value = function () {
        return this.str;
      }),
      t
    );
  })(),
  _B = (function () {
    function t(t, e, i, n) {
      (this.id = Zk()),
        (this.type = t),
        (this.serviceIdentifier = i),
        (this.name = new xB(e || "")),
        (this.metadata = new Array());
      var r = null;
      "string" == typeof n ? (r = new yB(zk, n)) : n instanceof yB && (r = n),
        null !== r && this.metadata.push(r);
    }
    return (
      (t.prototype.hasTag = function (t) {
        for (var e = 0, i = this.metadata; e < i.length; e++) {
          if (i[e].key === t) return !0;
        }
        return !1;
      }),
      (t.prototype.isArray = function () {
        return this.hasTag(Uk);
      }),
      (t.prototype.matchesArray = function (t) {
        return this.matchesTag(Uk)(t);
      }),
      (t.prototype.isNamed = function () {
        return this.hasTag(zk);
      }),
      (t.prototype.isTagged = function () {
        return this.metadata.some(function (t) {
          return (
            t.key !== Gk &&
            t.key !== Uk &&
            t.key !== kk &&
            t.key !== Bk &&
            t.key !== zk
          );
        });
      }),
      (t.prototype.isOptional = function () {
        return this.matchesTag("optional")(!0);
      }),
      (t.prototype.getNamedTag = function () {
        return this.isNamed()
          ? this.metadata.filter(function (t) {
              return t.key === zk;
            })[0]
          : null;
      }),
      (t.prototype.getCustomTags = function () {
        return this.isTagged()
          ? this.metadata.filter(function (t) {
              return (
                t.key !== Gk &&
                t.key !== Uk &&
                t.key !== kk &&
                t.key !== Bk &&
                t.key !== zk
              );
            })
          : null;
      }),
      (t.prototype.matchesNamedTag = function (t) {
        return this.matchesTag(zk)(t);
      }),
      (t.prototype.matchesTag = function (t) {
        var e = this;
        return function (i) {
          for (var n = 0, r = e.metadata; n < r.length; n++) {
            var o = r[n];
            if (o.key === t && o.value === i) return !0;
          }
          return !1;
        };
      }),
      t
    );
  })();
function SB(t, e, i, n) {
  var r = t.getConstructorMetadata(i),
    o = r.compilerGeneratedMetadata;
  if (void 0 === o) throw new Error(iB + " " + e + ".");
  var a = r.userGeneratedMetadata,
    s = Object.keys(a),
    l = (function (t, e, i, n, r) {
      for (var o = [], a = 0; a < r; a++) {
        var s = MB(a, t, e, i, n);
        null !== s && o.push(s);
      }
      return o;
    })(n, e, o, a, 0 === i.length && s.length > 0 ? s.length : i.length),
    u = CB(t, i);
  return l.concat(u);
}
function MB(t, e, i, n, r) {
  var o = r[t.toString()] || [],
    a = AB(o),
    s = !0 !== a.unmanaged,
    l = n[t],
    u = a.inject || a.multiInject;
  if (((l = u || l) instanceof bB && (l = l.unwrap()), s)) {
    if (!e && (l === Object || l === Function || void 0 === l))
      throw new Error(nB + " argument " + t + " in class " + i + ".");
    var c = new _B(Xk.ConstructorArgument, a.targetName, l);
    return (c.metadata = o), c;
  }
  return null;
}
function CB(t, e) {
  for (
    var i = t.getPropertiesMetadata(e), n = [], r = 0, o = Object.keys(i);
    r < o.length;
    r++
  ) {
    var a = o[r],
      s = i[a],
      l = AB(i[a]),
      u = l.targetName || a,
      c = l.inject || l.multiInject,
      h = new _B(Xk.ClassProperty, u, c);
    (h.metadata = s), n.push(h);
  }
  var p = Object.getPrototypeOf(e.prototype).constructor;
  if (p !== Object) {
    var d = CB(t, p);
    n = n.concat(d);
  }
  return n;
}
function wB(t, e) {
  var i = Object.getPrototypeOf(e.prototype).constructor;
  if (i !== Object) {
    var n = SB(t, gB(i), i, !0),
      r = n.map(function (t) {
        return t.metadata.filter(function (t) {
          return t.key === Bk;
        });
      }),
      o = [].concat.apply([], r).length,
      a = n.length - o;
    return a > 0 ? a : wB(t, i);
  }
  return 0;
}
function AB(t) {
  var e = {};
  return (
    t.forEach(function (t) {
      e[t.key.toString()] = t.value;
    }),
    {
      inject: e[Gk],
      multiInject: e[Uk],
      targetName: e[kk],
      unmanaged: e[Bk],
    }
  );
}
var EB = (function () {
  function t(t, e, i, n, r) {
    (this.id = Zk()),
      (this.serviceIdentifier = t),
      (this.parentContext = e),
      (this.parentRequest = i),
      (this.target = r),
      (this.childRequests = []),
      (this.bindings = Array.isArray(n) ? n : [n]),
      (this.requestScope = null === i ? new Map() : null);
  }
  return (
    (t.prototype.addChildRequest = function (e, i, n) {
      var r = new t(e, this.parentContext, this, i, n);
      return this.childRequests.push(r), r;
    }),
    t
  );
})();
function DB(t) {
  return t._bindingDictionary;
}
function TB(t, e, i, n, r) {
  var o = LB(i.container, r.serviceIdentifier),
    a = [];
  return (
    o.length === uB.NoBindingsAvailable &&
      i.container.options.autoBindInjectable &&
      "function" == typeof r.serviceIdentifier &&
      t.getConstructorMetadata(r.serviceIdentifier).compilerGeneratedMetadata &&
      (i.container.bind(r.serviceIdentifier).toSelf(),
      (o = LB(i.container, r.serviceIdentifier))),
    (a = e
      ? o
      : o.filter(function (t) {
          var e = new EB(t.serviceIdentifier, i, n, t, r);
          return t.constraint(e);
        })),
    (function (t, e, i, n) {
      switch (e.length) {
        case uB.NoBindingsAvailable:
          if (i.isOptional()) return e;
          var r = hB(t),
            o = eB;
          throw (
            ((o += (function (t, e) {
              if (e.isTagged() || e.isNamed()) {
                var i = "",
                  n = e.getNamedTag(),
                  r = e.getCustomTags();
                return (
                  null !== n && (i += n.toString() + "\n"),
                  null !== r &&
                    r.forEach(function (t) {
                      i += t.toString() + "\n";
                    }),
                  " " + t + "\n " + t + " - " + i
                );
              }
              return " " + t;
            })(r, i)),
            (o += pB(n, r, LB)),
            new Error(o))
          );
        case uB.OnlyOneBindingAvailable:
          if (!i.isArray()) return e;
        case uB.MultipleBindingsAvailable:
        default:
          if (i.isArray()) return e;
          (r = hB(t)), (o = tB + " " + r);
          throw ((o += pB(n, r, LB)), new Error(o));
      }
    })(r.serviceIdentifier, a, r, i.container),
    a
  );
}
function PB(t, e, i, n, r, o) {
  var a, s;
  if (null === r) {
    (a = TB(t, e, n, null, o)), (s = new EB(i, n, null, a, o));
    var l = new vB(n, s);
    n.addPlan(l);
  } else
    (a = TB(t, e, n, r, o)), (s = r.addChildRequest(o.serviceIdentifier, a, o));
  a.forEach(function (e) {
    var i = null;
    if (o.isArray()) i = s.addChildRequest(e.serviceIdentifier, e, o);
    else {
      if (e.cache) return;
      i = s;
    }
    if (e.type === Yk.Instance && null !== e.implementationType) {
      var r = (function (t, e) {
        return SB(t, gB(e), e, !1);
      })(t, e.implementationType);
      if (!n.container.options.skipBaseClassChecks) {
        var a = wB(t, e.implementationType);
        if (r.length < a) {
          var l = oB(gB(e.implementationType));
          throw new Error(l);
        }
      }
      r.forEach(function (e) {
        PB(t, !1, e.serviceIdentifier, n, i, e);
      });
    }
  });
}
function LB(t, e) {
  var i = [],
    n = DB(t);
  return (
    n.hasKey(e) ? (i = n.get(e)) : null !== t.parent && (i = LB(t.parent, e)), i
  );
}
function IB(t, e, i, n, r, o, a, s) {
  void 0 === s && (s = !1);
  var l = new mB(e),
    u = (function (t, e, i, n, r, o) {
      var a = new yB(t ? Uk : Gk, i),
        s = new _B(e, n, i, a);
      if (void 0 !== r) {
        var l = new yB(r, o);
        s.metadata.push(l);
      }
      return s;
    })(i, n, r, "", o, a);
  try {
    return PB(t, s, r, l, null, u), l;
  } catch (c) {
    throw (cB(c) && l.plan && fB(l.plan.rootRequest), c);
  }
}
function NB(t, e, i) {
  var n,
    r,
    o = null;
  if (e.length > 0) {
    var a = e
      .filter(function (t) {
        return null !== t.target && t.target.type === Xk.ConstructorArgument;
      })
      .map(i);
    (r = a),
      (o = (function (t, e, i) {
        var n = e.filter(function (t) {
            return null !== t.target && t.target.type === Xk.ClassProperty;
          }),
          r = n.map(i);
        return (
          n.forEach(function (e, i) {
            var n;
            n = e.target.name.value();
            var o = r[i];
            t[n] = o;
          }),
          t
        );
      })((o = new ((n = t).bind.apply(n, [void 0].concat(r)))()), e, i));
  } else o = new t();
  return (
    (function (t, e) {
      if (Reflect.hasMetadata(Hk, t)) {
        var i = Reflect.getMetadata(Hk, t);
        try {
          e[i.value]();
        } catch (n) {
          throw new Error(aB(t.name, n.message));
        }
      }
    })(t, o),
    o
  );
}
var RB = function (t, e, i) {
    try {
      return i();
    } catch (n) {
      throw cB(n)
        ? new Error(
            (function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              return (
                "It looks like there is a circular dependency in one of the '" +
                t[0] +
                "' bindings. Please investigate bindings withservice identifier '" +
                t[1] +
                "'."
              );
            })(t, e.toString())
          )
        : n;
    }
  },
  OB = function (t) {
    return function (e) {
      e.parentContext.setCurrentRequest(e);
      var i = e.bindings,
        n = e.childRequests,
        r = e.target && e.target.isArray(),
        o = !(
          e.parentRequest &&
          e.parentRequest.target &&
          e.target &&
          e.parentRequest.target.matchesArray(e.target.serviceIdentifier)
        );
      if (r && o)
        return n.map(function (e) {
          return OB(t)(e);
        });
      var a = null;
      if (!e.target.isOptional() || 0 !== i.length) {
        var s = i[0],
          l = s.scope === Wk,
          u = s.scope === Vk;
        if (l && s.activated) return s.cache;
        if (u && null !== t && t.has(s.id)) return t.get(s.id);
        if (s.type === Yk.ConstantValue) a = s.cache;
        else if (s.type === Yk.Function) a = s.cache;
        else if (s.type === Yk.Constructor) a = s.implementationType;
        else if (s.type === Yk.DynamicValue && null !== s.dynamicValue)
          a = RB("toDynamicValue", s.serviceIdentifier, function () {
            return s.dynamicValue(e.parentContext);
          });
        else if (s.type === Yk.Factory && null !== s.factory)
          a = RB("toFactory", s.serviceIdentifier, function () {
            return s.factory(e.parentContext);
          });
        else if (s.type === Yk.Provider && null !== s.provider)
          a = RB("toProvider", s.serviceIdentifier, function () {
            return s.provider(e.parentContext);
          });
        else {
          if (s.type !== Yk.Instance || null === s.implementationType) {
            var c = hB(e.serviceIdentifier);
            throw new Error("Invalid binding type: " + c);
          }
          a = NB(s.implementationType, n, OB(t));
        }
        return (
          "function" == typeof s.onActivation &&
            (a = s.onActivation(e.parentContext, a)),
          l && ((s.cache = a), (s.activated = !0)),
          u && null !== t && !t.has(s.id) && t.set(s.id, a),
          a
        );
      }
    };
  };
var FB = function (t, e) {
    var i = t.parentRequest;
    return null !== i && (!!e(i) || FB(i, e));
  },
  zB = function (t) {
    return function (e) {
      var i = function (i) {
        return null !== i && null !== i.target && i.target.matchesTag(t)(e);
      };
      return (i.metaData = new yB(t, e)), i;
    };
  },
  kB = zB(zk),
  BB = function (t) {
    return function (e) {
      var i = null;
      if (null !== e) {
        if (((i = e.bindings[0]), "string" == typeof t))
          return i.serviceIdentifier === t;
        var n = e.bindings[0].implementationType;
        return t === n;
      }
      return !1;
    };
  },
  GB = (function () {
    function t(t) {
      this._binding = t;
    }
    return (
      (t.prototype.when = function (t) {
        return (this._binding.constraint = t), new UB(this._binding);
      }),
      (t.prototype.whenTargetNamed = function (t) {
        return (this._binding.constraint = kB(t)), new UB(this._binding);
      }),
      (t.prototype.whenTargetIsDefault = function () {
        return (
          (this._binding.constraint = function (t) {
            return (
              null !== t.target && !t.target.isNamed() && !t.target.isTagged()
            );
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenTargetTagged = function (t, e) {
        return (this._binding.constraint = zB(t)(e)), new UB(this._binding);
      }),
      (t.prototype.whenInjectedInto = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return BB(t)(e.parentRequest);
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenParentNamed = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return kB(t)(e.parentRequest);
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenParentTagged = function (t, e) {
        return (
          (this._binding.constraint = function (i) {
            return zB(t)(e)(i.parentRequest);
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenAnyAncestorIs = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return FB(e, BB(t));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenNoAncestorIs = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return !FB(e, BB(t));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenAnyAncestorNamed = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return FB(e, kB(t));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenNoAncestorNamed = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return !FB(e, kB(t));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenAnyAncestorTagged = function (t, e) {
        return (
          (this._binding.constraint = function (i) {
            return FB(i, zB(t)(e));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenNoAncestorTagged = function (t, e) {
        return (
          (this._binding.constraint = function (i) {
            return !FB(i, zB(t)(e));
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenAnyAncestorMatches = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return FB(e, t);
          }),
          new UB(this._binding)
        );
      }),
      (t.prototype.whenNoAncestorMatches = function (t) {
        return (
          (this._binding.constraint = function (e) {
            return !FB(e, t);
          }),
          new UB(this._binding)
        );
      }),
      t
    );
  })(),
  UB = (function () {
    function t(t) {
      this._binding = t;
    }
    return (
      (t.prototype.onActivation = function (t) {
        return (this._binding.onActivation = t), new GB(this._binding);
      }),
      t
    );
  })(),
  jB = (function () {
    function t(t) {
      (this._binding = t),
        (this._bindingWhenSyntax = new GB(this._binding)),
        (this._bindingOnSyntax = new UB(this._binding));
    }
    return (
      (t.prototype.when = function (t) {
        return this._bindingWhenSyntax.when(t);
      }),
      (t.prototype.whenTargetNamed = function (t) {
        return this._bindingWhenSyntax.whenTargetNamed(t);
      }),
      (t.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      }),
      (t.prototype.whenTargetTagged = function (t, e) {
        return this._bindingWhenSyntax.whenTargetTagged(t, e);
      }),
      (t.prototype.whenInjectedInto = function (t) {
        return this._bindingWhenSyntax.whenInjectedInto(t);
      }),
      (t.prototype.whenParentNamed = function (t) {
        return this._bindingWhenSyntax.whenParentNamed(t);
      }),
      (t.prototype.whenParentTagged = function (t, e) {
        return this._bindingWhenSyntax.whenParentTagged(t, e);
      }),
      (t.prototype.whenAnyAncestorIs = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(t);
      }),
      (t.prototype.whenNoAncestorIs = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorIs(t);
      }),
      (t.prototype.whenAnyAncestorNamed = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(t);
      }),
      (t.prototype.whenAnyAncestorTagged = function (t, e) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e);
      }),
      (t.prototype.whenNoAncestorNamed = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(t);
      }),
      (t.prototype.whenNoAncestorTagged = function (t, e) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(t, e);
      }),
      (t.prototype.whenAnyAncestorMatches = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(t);
      }),
      (t.prototype.whenNoAncestorMatches = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(t);
      }),
      (t.prototype.onActivation = function (t) {
        return this._bindingOnSyntax.onActivation(t);
      }),
      t
    );
  })(),
  HB = (function () {
    function t(t) {
      this._binding = t;
    }
    return (
      (t.prototype.inRequestScope = function () {
        return (this._binding.scope = Vk), new jB(this._binding);
      }),
      (t.prototype.inSingletonScope = function () {
        return (this._binding.scope = Wk), new jB(this._binding);
      }),
      (t.prototype.inTransientScope = function () {
        return (this._binding.scope = qk), new jB(this._binding);
      }),
      t
    );
  })(),
  VB = (function () {
    function t(t) {
      (this._binding = t),
        (this._bindingWhenSyntax = new GB(this._binding)),
        (this._bindingOnSyntax = new UB(this._binding)),
        (this._bindingInSyntax = new HB(t));
    }
    return (
      (t.prototype.inRequestScope = function () {
        return this._bindingInSyntax.inRequestScope();
      }),
      (t.prototype.inSingletonScope = function () {
        return this._bindingInSyntax.inSingletonScope();
      }),
      (t.prototype.inTransientScope = function () {
        return this._bindingInSyntax.inTransientScope();
      }),
      (t.prototype.when = function (t) {
        return this._bindingWhenSyntax.when(t);
      }),
      (t.prototype.whenTargetNamed = function (t) {
        return this._bindingWhenSyntax.whenTargetNamed(t);
      }),
      (t.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      }),
      (t.prototype.whenTargetTagged = function (t, e) {
        return this._bindingWhenSyntax.whenTargetTagged(t, e);
      }),
      (t.prototype.whenInjectedInto = function (t) {
        return this._bindingWhenSyntax.whenInjectedInto(t);
      }),
      (t.prototype.whenParentNamed = function (t) {
        return this._bindingWhenSyntax.whenParentNamed(t);
      }),
      (t.prototype.whenParentTagged = function (t, e) {
        return this._bindingWhenSyntax.whenParentTagged(t, e);
      }),
      (t.prototype.whenAnyAncestorIs = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(t);
      }),
      (t.prototype.whenNoAncestorIs = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorIs(t);
      }),
      (t.prototype.whenAnyAncestorNamed = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(t);
      }),
      (t.prototype.whenAnyAncestorTagged = function (t, e) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(t, e);
      }),
      (t.prototype.whenNoAncestorNamed = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(t);
      }),
      (t.prototype.whenNoAncestorTagged = function (t, e) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(t, e);
      }),
      (t.prototype.whenAnyAncestorMatches = function (t) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(t);
      }),
      (t.prototype.whenNoAncestorMatches = function (t) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(t);
      }),
      (t.prototype.onActivation = function (t) {
        return this._bindingOnSyntax.onActivation(t);
      }),
      t
    );
  })(),
  WB = (function () {
    function t(t) {
      this._binding = t;
    }
    return (
      (t.prototype.to = function (t) {
        return (
          (this._binding.type = Yk.Instance),
          (this._binding.implementationType = t),
          new VB(this._binding)
        );
      }),
      (t.prototype.toSelf = function () {
        if ("function" != typeof this._binding.serviceIdentifier)
          throw new Error(
            "The toSelf function can only be applied when a constructor is used as service identifier"
          );
        var t = this._binding.serviceIdentifier;
        return this.to(t);
      }),
      (t.prototype.toConstantValue = function (t) {
        return (
          (this._binding.type = Yk.ConstantValue),
          (this._binding.cache = t),
          (this._binding.dynamicValue = null),
          (this._binding.implementationType = null),
          new jB(this._binding)
        );
      }),
      (t.prototype.toDynamicValue = function (t) {
        return (
          (this._binding.type = Yk.DynamicValue),
          (this._binding.cache = null),
          (this._binding.dynamicValue = t),
          (this._binding.implementationType = null),
          new VB(this._binding)
        );
      }),
      (t.prototype.toConstructor = function (t) {
        return (
          (this._binding.type = Yk.Constructor),
          (this._binding.implementationType = t),
          new jB(this._binding)
        );
      }),
      (t.prototype.toFactory = function (t) {
        return (
          (this._binding.type = Yk.Factory),
          (this._binding.factory = t),
          new jB(this._binding)
        );
      }),
      (t.prototype.toFunction = function (t) {
        if ("function" != typeof t)
          throw new Error(
            "Value provided to function binding must be a function!"
          );
        var e = this.toConstantValue(t);
        return (this._binding.type = Yk.Function), e;
      }),
      (t.prototype.toAutoFactory = function (t) {
        return (
          (this._binding.type = Yk.Factory),
          (this._binding.factory = function (e) {
            return function () {
              return e.container.get(t);
            };
          }),
          new jB(this._binding)
        );
      }),
      (t.prototype.toProvider = function (t) {
        return (
          (this._binding.type = Yk.Provider),
          (this._binding.provider = t),
          new jB(this._binding)
        );
      }),
      (t.prototype.toService = function (t) {
        this.toDynamicValue(function (e) {
          return e.container.get(t);
        });
      }),
      t
    );
  })(),
  qB = (function () {
    function t() {}
    return (
      (t.of = function (e, i) {
        var n = new t();
        return (n.bindings = e), (n.middleware = i), n;
      }),
      t
    );
  })(),
  YB = (function () {
    function t() {
      this._map = new Map();
    }
    return (
      (t.prototype.getMap = function () {
        return this._map;
      }),
      (t.prototype.add = function (t, e) {
        if (null == t) throw new Error(Kk);
        if (null == e) throw new Error(Kk);
        var i = this._map.get(t);
        void 0 !== i ? (i.push(e), this._map.set(t, i)) : this._map.set(t, [e]);
      }),
      (t.prototype.get = function (t) {
        if (null == t) throw new Error(Kk);
        var e = this._map.get(t);
        if (void 0 !== e) return e;
        throw new Error($k);
      }),
      (t.prototype.remove = function (t) {
        if (null == t) throw new Error(Kk);
        if (!this._map.delete(t)) throw new Error($k);
      }),
      (t.prototype.removeByCondition = function (t) {
        var e = this;
        this._map.forEach(function (i, n) {
          var r = i.filter(function (e) {
            return !t(e);
          });
          r.length > 0 ? e._map.set(n, r) : e._map.delete(n);
        });
      }),
      (t.prototype.hasKey = function (t) {
        if (null == t) throw new Error(Kk);
        return this._map.has(t);
      }),
      (t.prototype.clone = function () {
        var e = new t();
        return (
          this._map.forEach(function (t, i) {
            t.forEach(function (t) {
              return e.add(i, t.clone());
            });
          }),
          e
        );
      }),
      (t.prototype.traverse = function (t) {
        this._map.forEach(function (e, i) {
          t(i, e);
        });
      }),
      t
    );
  })(),
  XB =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, i, n) {
      return new (i || (i = Promise))(function (r, o) {
        function a(t) {
          try {
            l(n.next(t));
          } catch (e) {
            o(e);
          }
        }
        function s(t) {
          try {
            l(n.throw(t));
          } catch (e) {
            o(e);
          }
        }
        function l(t) {
          t.done
            ? r(t.value)
            : new i(function (e) {
                e(t.value);
              }).then(a, s);
        }
        l((n = n.apply(t, e || [])).next());
      });
    },
  QB =
    (globalThis && globalThis.__generator) ||
    function (t, e) {
      var i,
        n,
        r,
        o,
        a = {
          label: 0,
          sent: function () {
            if (1 & r[0]) throw r[1];
            return r[1];
          },
          trys: [],
          ops: [],
        };
      return (
        (o = {
          next: s(0),
          throw: s(1),
          return: s(2),
        }),
        "function" == typeof Symbol &&
          (o[Symbol.iterator] = function () {
            return this;
          }),
        o
      );
      function s(o) {
        return function (s) {
          return (function (o) {
            if (i) throw new TypeError("Generator is already executing.");
            for (; a; )
              try {
                if (
                  ((i = 1),
                  n &&
                    (r = n[2 & o[0] ? "return" : o[0] ? "throw" : "next"]) &&
                    !(r = r.call(n, o[1])).done)
                )
                  return r;
                switch (((n = 0), r && (o = [0, r.value]), o[0])) {
                  case 0:
                  case 1:
                    r = o;
                    break;
                  case 4:
                    return (
                      a.label++,
                      {
                        value: o[1],
                        done: !1,
                      }
                    );
                  case 5:
                    a.label++, (n = o[1]), (o = [0]);
                    continue;
                  case 7:
                    (o = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (
                      !((r = a.trys),
                      (r = r.length > 0 && r[r.length - 1]) ||
                        (6 !== o[0] && 2 !== o[0]))
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === o[0] && (!r || (o[1] > r[0] && o[1] < r[3]))) {
                      a.label = o[1];
                      break;
                    }
                    if (6 === o[0] && a.label < r[1]) {
                      (a.label = r[1]), (r = o);
                      break;
                    }
                    if (r && a.label < r[2]) {
                      (a.label = r[2]), a.ops.push(o);
                      break;
                    }
                    r[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                o = e.call(t, a);
              } catch (s) {
                (o = [6, s]), (n = 0);
              } finally {
                i = r = 0;
              }
            if (5 & o[0]) throw o[1];
            return {
              value: o[0] ? o[1] : void 0,
              done: !0,
            };
          })([o, s]);
        };
      }
    },
  ZB = (function () {
    function t(t) {
      var e = t || {};
      if ("object" != typeof e)
        throw new Error(
          "Invalid Container constructor argument. Container options must be an object."
        );
      if (void 0 === e.defaultScope) e.defaultScope = qk;
      else if (
        e.defaultScope !== Wk &&
        e.defaultScope !== qk &&
        e.defaultScope !== Vk
      )
        throw new Error(
          "Invalid Container option. Default scope must be a string ('singleton' or 'transient')."
        );
      if (void 0 === e.autoBindInjectable) e.autoBindInjectable = !1;
      else if ("boolean" != typeof e.autoBindInjectable)
        throw new Error(
          "Invalid Container option. Auto bind injectable must be a boolean"
        );
      if (void 0 === e.skipBaseClassChecks) e.skipBaseClassChecks = !1;
      else if ("boolean" != typeof e.skipBaseClassChecks)
        throw new Error(
          "Invalid Container option. Skip base check must be a boolean"
        );
      (this.options = {
        autoBindInjectable: e.autoBindInjectable,
        defaultScope: e.defaultScope,
        skipBaseClassChecks: e.skipBaseClassChecks,
      }),
        (this.id = Zk()),
        (this._bindingDictionary = new YB()),
        (this._snapshots = []),
        (this._middleware = null),
        (this.parent = null),
        (this._metadataReader = new lB());
    }
    return (
      (t.merge = function (e, i) {
        var n = new t(),
          r = DB(n),
          o = DB(e),
          a = DB(i);
        function s(t, e) {
          t.traverse(function (t, i) {
            i.forEach(function (t) {
              e.add(t.serviceIdentifier, t.clone());
            });
          });
        }
        return s(o, r), s(a, r), n;
      }),
      (t.prototype.load = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        for (
          var i = this._getContainerModuleHelpersFactory(), n = 0, r = t;
          n < r.length;
          n++
        ) {
          var o = r[n],
            a = i(o.id);
          o.registry(
            a.bindFunction,
            a.unbindFunction,
            a.isboundFunction,
            a.rebindFunction
          );
        }
      }),
      (t.prototype.loadAsync = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return XB(this, void 0, void 0, function () {
          var e, i, n, r, o;
          return QB(this, function (a) {
            switch (a.label) {
              case 0:
                (e = this._getContainerModuleHelpersFactory()),
                  (i = 0),
                  (n = t),
                  (a.label = 1);
              case 1:
                return i < n.length
                  ? ((r = n[i]),
                    (o = e(r.id)),
                    [
                      4,
                      r.registry(
                        o.bindFunction,
                        o.unbindFunction,
                        o.isboundFunction,
                        o.rebindFunction
                      ),
                    ])
                  : [3, 4];
              case 2:
                a.sent(), (a.label = 3);
              case 3:
                return i++, [3, 1];
              case 4:
                return [2];
            }
          });
        });
      }),
      (t.prototype.unload = function () {
        for (var t = this, e = [], i = 0; i < arguments.length; i++)
          e[i] = arguments[i];
        e.forEach(function (e) {
          var i,
            n =
              ((i = e.id),
              function (t) {
                return t.moduleId === i;
              });
          t._bindingDictionary.removeByCondition(n);
        });
      }),
      (t.prototype.bind = function (t) {
        var e = this.options.defaultScope || qk,
          i = new Jk(t, e);
        return this._bindingDictionary.add(t, i), new WB(i);
      }),
      (t.prototype.rebind = function (t) {
        return this.unbind(t), this.bind(t);
      }),
      (t.prototype.unbind = function (t) {
        try {
          this._bindingDictionary.remove(t);
        } catch (e) {
          throw new Error("Could not unbind serviceIdentifier: " + hB(t));
        }
      }),
      (t.prototype.unbindAll = function () {
        this._bindingDictionary = new YB();
      }),
      (t.prototype.isBound = function (t) {
        var e = this._bindingDictionary.hasKey(t);
        return !e && this.parent && (e = this.parent.isBound(t)), e;
      }),
      (t.prototype.isBoundNamed = function (t, e) {
        return this.isBoundTagged(t, zk, e);
      }),
      (t.prototype.isBoundTagged = function (t, e, i) {
        var n = !1;
        if (this._bindingDictionary.hasKey(t)) {
          var r = this._bindingDictionary.get(t),
            o = (function (t, e, i, n) {
              var r = new _B(Xk.Variable, "", e, new yB(i, n)),
                o = new mB(t);
              return new EB(e, o, null, [], r);
            })(this, t, e, i);
          n = r.some(function (t) {
            return t.constraint(o);
          });
        }
        return !n && this.parent && (n = this.parent.isBoundTagged(t, e, i)), n;
      }),
      (t.prototype.snapshot = function () {
        this._snapshots.push(
          qB.of(this._bindingDictionary.clone(), this._middleware)
        );
      }),
      (t.prototype.restore = function () {
        var t = this._snapshots.pop();
        if (void 0 === t) throw new Error("No snapshot available to restore.");
        (this._bindingDictionary = t.bindings),
          (this._middleware = t.middleware);
      }),
      (t.prototype.createChild = function (e) {
        var i = new t(e || this.options);
        return (i.parent = this), i;
      }),
      (t.prototype.applyMiddleware = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        var i = this._middleware ? this._middleware : this._planAndResolve();
        this._middleware = t.reduce(function (t, e) {
          return e(t);
        }, i);
      }),
      (t.prototype.applyCustomMetadataReader = function (t) {
        this._metadataReader = t;
      }),
      (t.prototype.get = function (t) {
        return this._get(!1, !1, Xk.Variable, t);
      }),
      (t.prototype.getTagged = function (t, e, i) {
        return this._get(!1, !1, Xk.Variable, t, e, i);
      }),
      (t.prototype.getNamed = function (t, e) {
        return this.getTagged(t, zk, e);
      }),
      (t.prototype.getAll = function (t) {
        return this._get(!0, !0, Xk.Variable, t);
      }),
      (t.prototype.getAllTagged = function (t, e, i) {
        return this._get(!1, !0, Xk.Variable, t, e, i);
      }),
      (t.prototype.getAllNamed = function (t, e) {
        return this.getAllTagged(t, zk, e);
      }),
      (t.prototype.resolve = function (t) {
        var e = this.createChild();
        return e.bind(t).toSelf(), e.get(t);
      }),
      (t.prototype._getContainerModuleHelpersFactory = function () {
        var t = this,
          e = function (t, e) {
            t._binding.moduleId = e;
          },
          i = function (i) {
            return function (n) {
              var r = t.rebind.bind(t)(n);
              return e(r, i), r;
            };
          };
        return function (n) {
          return {
            bindFunction:
              ((r = n),
              function (i) {
                var n = t.bind.bind(t)(i);
                return e(n, r), n;
              }),
            isboundFunction: function (e) {
              return t.isBound.bind(t)(e);
            },
            rebindFunction: i(n),
            unbindFunction: function (e) {
              t.unbind.bind(t)(e);
            },
          };
          var r;
        };
      }),
      (t.prototype._get = function (t, e, i, n, r, o) {
        var a = null,
          s = {
            avoidConstraints: t,
            contextInterceptor: function (t) {
              return t;
            },
            isMultiInject: e,
            key: r,
            serviceIdentifier: n,
            targetType: i,
            value: o,
          };
        if (this._middleware) {
          if (null == (a = this._middleware(s)))
            throw new Error(
              "Invalid return type in middleware. Middleware must return!"
            );
        } else a = this._planAndResolve()(s);
        return a;
      }),
      (t.prototype._planAndResolve = function () {
        var t = this;
        return function (e) {
          var i = IB(
            t._metadataReader,
            t,
            e.isMultiInject,
            e.targetType,
            e.serviceIdentifier,
            e.key,
            e.value,
            e.avoidConstraints
          );
          return (function (t) {
            return OB(t.plan.rootRequest.requestScope)(t.plan.rootRequest);
          })((i = e.contextInterceptor(i)));
        };
      }),
      t
    );
  })();
function JB() {
  return function (t) {
    if (Reflect.hasOwnMetadata(jk, t))
      throw new Error("Cannot apply @injectable decorator multiple times.");
    var e = Reflect.getMetadata("design:paramtypes", t) || [];
    return Reflect.defineMetadata(jk, e, t), t;
  };
}
const KB = {
  ITextService: Symbol.for("ITextService"),
  ILogService: Symbol.for("ILogService"),
  IEventEmitter: Symbol.for("IEventEmitter"),
  SceneID: Symbol.for("SceneID"),
  IEventService: Symbol.for("IEventService"),
  ITextureService: Symbol.for("ITextureService"),
  IShaderService: Symbol.for("IShaderService"),
};
const $B = 32 * window.devicePixelRatio,
  tG = 32 * $B,
  eG = 32 * $B;
const iG = new (class {
  constructor(t, e) {
    (this.width = t), (this.height = e);
    const i = document.createElement("canvas");
    (i.height = e), (i.width = t), (this.ctx = i.getContext("2d"));
  }
  async createTextImage(t, e) {
    const { textSeries: i, background: n, orient: r, alignment: o } = e;
    this.ctx.clearRect(0, 0, this.width, this.height),
      (this.ctx.textBaseline = "top");
    let a = 0,
      s = 0;
    const l = $B / i[0].props.fontSize,
      u = 0 + (n.shadow.blur * l) / 2,
      c = 0 + (n.shadow.blur * l) / 2;
    i.forEach((t) => {
      const {
        text: e,
        props: {
          fontWeight: n,
          fontFamily: o,
          fontSize: u,
          offsetX: c,
          offsetY: h,
        },
      } = t;
      let p = $B * (u / i[0].props.fontSize);
      this.ctx.font = `${n} ${p}px ${o} `;
      const d = this.ctx.measureText(String(e)).width + c * l;
      p += h * l;
      const f = {
        x: 0,
        y: 0,
      };
      switch (r) {
        case "vertical":
          (f.x = c * l), (f.y = s + h * l), (a = a > d ? a : d), (s += p);
          break;
        case "horizontal":
          (f.y = h * l), (f.x = a + c * l), (a += d), (s = s > p ? s : p);
          break;
        default:
          console.error("[xGis]", `传入 poi orient ${r} 无法解析`);
      }
      t.origin = f;
    });
    const h = s + n.padding.top * l + n.padding.bottom * l,
      p = a + n.padding.left * l + n.padding.right * l;
    if (
      (n.shadow &&
        ((this.ctx.shadowBlur = n.shadow.blur * l),
        (this.ctx.shadowOffsetX = n.shadow.offsetX * l),
        (this.ctx.shadowOffsetY = -n.shadow.offsetY * l),
        (this.ctx.shadowColor = n.shadow.color)),
      n.map)
    ) {
      const e = t.getImage(n.map);
      this.ctx.save(),
        (this.ctx.globalAlpha = n.opacity),
        e
          ? Mf(
              this.ctx,
              e,
              u,
              c,
              p,
              h,
              n.borderRadius ? n.borderRadius.map((t) => t * l) : null
            )
          : await t.addImageAsync(n.map, n.map, (t) => {
              Mf(
                this.ctx,
                t,
                u,
                c,
                p,
                h,
                n.borderRadius ? n.borderRadius.map((t) => t * l) : null
              );
            }),
        this.ctx.restore();
    } else
      n.color &&
        (this.ctx.save(),
        (d = this.ctx),
        (f = n.color),
        (g = u),
        (m = c),
        (y = p),
        (v = h),
        (b = n.borderRadius ? n.borderRadius.map((t) => t * l) : null),
        (d.fillStyle = f),
        b ? (Cf(d, g, m, y, v, b), d.fill()) : d.fillRect(g, m, y, v),
        this.ctx.restore());
    var d, f, g, m, y, v, b;
    i.forEach((t) => {
      const {
          text: e,
          props: {
            fontWeight: h,
            fontFamily: p,
            fontSize: d,
            color: f,
            offsetX: g,
            offsetY: m,
            strokeWidth: y,
            strokeColor: v,
          },
        } = t,
        b = $B * (d / i[0].props.fontSize);
      this.ctx.font = `${h} ${b}px ${p} `;
      const x = this.ctx.measureText(String(e));
      switch (r) {
        case "vertical":
          switch (o) {
            case "top":
              t.origin.x += 0;
              break;
            case "bottom":
              t.origin.x += a - (x.width + g * l);
              break;
            case "middle":
              t.origin.x += (a - (x.width + g * l)) / 2;
              break;
            default:
              console.error("[xGis]", `传入 poi alignment ${o} 无法解析`);
          }
          break;
        case "horizontal":
          switch (o) {
            case "top":
              t.origin.y += 0;
              break;
            case "bottom":
              t.origin.y += s - (b + m * l);
              break;
            case "middle":
              t.origin.y += (s - (b + m * l)) / 2;
              break;
            default:
              console.error("[xGis]", `传入 poi alignment ${o} 无法解析`);
          }
          break;
        default:
          console.error("[xGis]", `传入 poi orient ${r} 无法解析`);
      }
      (this.ctx.globalAlpha = 1), (this.ctx.fillStyle = f);
      const _ = x.actualBoundingBoxAscent || 0,
        S = t.origin.x + u + n.padding.left * l,
        M = t.origin.y + c - _ + n.padding.top * l;
      y &&
        ((this.ctx.strokeStyle = v),
        (this.ctx.lineWidth = y * l),
        this.ctx.strokeText(String(e), S, M)),
        this.ctx.fillText(String(e), S, M);
    });
    const x = p + n.shadow.blur * l,
      _ = h + n.shadow.blur * l;
    return this.ctx.getImageData(0, 0, x, _);
  }
})(tG, eG);
class nG extends Cr {
  constructor(t) {
    super({
      transparent: !0,
      fragmentShader:
        "precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uMap;\nvoid main() {\n  vec4 tex = texture2D(uMap, vUv);\n  gl_FragColor = tex;\n}",
      vertexShader:
        "precision highp float;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      uniforms: {
        uMap: {
          value: null,
        },
      },
    }),
      (this.props = t),
      (this.textureService = bG.get(KB.ITextureService));
  }
  async init() {
    const t = await iG.createTextImage(this.textureService, this.props),
      e = new is(t, t.width, t.height);
    (e.flipY = !0),
      (e.minFilter = Vt),
      (e.magFilter = Vt),
      (this.uniforms.uMap.value = e),
      (this.imageWidth = t.width),
      (this.imageHeight = t.height),
      (this.needsUpdate = !0);
  }
}
var rG = Object.defineProperty,
  oG = Object.getOwnPropertyDescriptor;
let aG = class {
  constructor() {}
  async createText(t) {
    return await this.create2DText(t);
  }
  async create2DText(t) {
    const {
        position: e,
        textSeries: i,
        background: n,
        orient: r,
        zIndex: o,
        alignment: a,
        offsetX: s,
        offsetY: l,
      } = t,
      u = {
        position: e,
        alignment: a,
        orient: r,
        zIndex: o,
        offsetX: s,
        offsetY: l,
        textSeries: i.map((t) =>
          af(t, {
            props: af(mk, t.props),
          })
        ),
        background: af(yk, n),
      },
      c = new dr(1, 1, 1, 1),
      h = new nG(u);
    await h.init();
    const p = (h.imageWidth / $B) * i[0].props.fontSize,
      d = (h.imageHeight / $B) * i[0].props.fontSize;
    c.translate(0, 0, 0), c.scale(p, d, 1);
    const f = new Wn(c, h);
    return f.setRenderIndex(o), f.position.set(e.x + s, e.y + l, e.z), f;
  }
};
aG = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? oG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && rG(e, i, o), o;
})([JB()], aG);
var sG = Symbol.for("INJECTION");
function lG(t, e, i, n) {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return (
        n &&
          !Reflect.hasMetadata(sG, this, e) &&
          Reflect.defineMetadata(sG, i(), this, e),
        Reflect.hasMetadata(sG, this, e)
          ? Reflect.getMetadata(sG, this, e)
          : i()
      );
    },
    set: function (t) {
      Reflect.defineMetadata(sG, t, this, e);
    },
  });
}
var uG = Object.defineProperty,
  cG = Object.getOwnPropertyDescriptor;
const hG = "[xGis]";
let pG = class {
  constructor() {
    this.__init();
  }
  __init() {
    this.logService = {
      log: console.log,
      warn: console.warn,
      error: console.error,
    };
  }
  error(...t) {
    this.logService.error(hG, ...t);
  }
  warn(...t) {
    this.logService.warn(hG, ...t);
  }
  log(...t) {
    this.logService.log(hG, ...t);
  }
  probe(...t) {}
  deprecated(t, e) {}
  time(t) {}
  timeEnd(t) {}
};
pG = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? cG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && uG(e, i, o), o;
})([JB()], pG);
var dG = Object.defineProperty,
  fG = Object.getOwnPropertyDescriptor;
let gG = class {
  constructor() {
    (this.textureManagerMap = {}),
      (this.imageMap = {}),
      (this.getTextureManager = (t, e) => (
        this.textureManagerMap[t]
          ? this.textureManagerMap[t][e] ||
            (this.textureManagerMap[t][e] = {
              loader: new rE(),
              abort: () => {},
              setTexture: Yd(this._setTexture)(t, e),
            })
          : (this.textureManagerMap[t] = {
              [e]: {
                loader: new rE(),
                abort: () => {},
                setTexture: Yd(this._setTexture)(t, e),
              },
            }),
        this.textureManagerMap[t][e]
      )),
      (this.removeTextureManager = (t) => {
        (this.textureManagerMap[t] = null), delete this.textureManagerMap[t];
      }),
      (this._setTexture = (t, e, i, n) => {
        this.textureManagerMap[t][e].abort(),
          new Promise((n, r) => {
            (this.textureManagerMap[t][e].abort = r), i(n);
          })
            .then((t) => {
              n(t);
            })
            .catch(() => {});
      }),
      (this.logService = bG.get(KB.ILogService));
  }
  addImage(t, e, i) {
    if (this.getImage(t)) return;
    new rE().load(e, (e) => {
      (this.imageMap[t] = e.image), i && i(e.image);
    });
  }
  async addImageAsync(t, e, i) {
    if (this.getImage(t)) return;
    const n = new rE(),
      r = await n.loadAsync(e);
    (this.imageMap[t] = r.image), i && i(r.image);
  }
  getImage(t) {
    const e = this.imageMap[t];
    return e || null;
  }
  getImageMap() {
    return this.imageMap;
  }
  getTextureManagerMap() {
    return this.textureManagerMap;
  }
};
gG = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? fG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && dG(e, i, o), o;
})([JB()], gG);
var mG = Object.defineProperty,
  yG = Object.getOwnPropertyDescriptor;
let vG = class {
  constructor() {
    this.moduleList = {};
  }
  registerBasicModule() {
    this.destroy(),
      this.registerModule("common", {
        vertexShader:
          "vec4 caclPosition(vec3 position) {\n  vec4 result = vec4(0.0);\n  result = vec4(position, 1.0);\n  return result;\n}",
        fragmentShader: "",
      });
  }
  registerModule(t, e) {
    if (this.moduleList[t]) return this.moduleList[t];
    const { basicMaterial: i = {}, uniforms: n, defines: r } = e,
      o = i,
      { vertexShader: a, fragmentShader: s, uniforms: l } = o,
      u = at(o, ["vertexShader", "fragmentShader", "uniforms"]);
    let c = this.loadChunk("vs", e.vertexShader, this.moduleList),
      h = this.loadChunk("fs", e.fragmentShader, this.moduleList);
    a && (c = this.patchShader(this.parseShader(a), c)),
      s && (h = this.patchShader(this.parseShader(s), h)),
      (this.moduleList[t] = ot(
        rt(
          ot(rt({}, i), {
            vertexShader: c,
            fragmentShader: h,
            uniforms: rt(rt({}, l), n),
          }),
          u
        ),
        {
          defines: r,
        }
      ));
  }
  getShaderModule(t) {
    return this.moduleList[t];
  }
  patchShader(t, e) {
    let i = e;
    return (
      (i = i.replace(
        "void main() {",
        `\n          ${t.header}\n          void main() {\n            ${t.main}\n          `
      )),
      (i = t.defines + i),
      i
    );
  }
  parseShader(t) {
    const e = {
        defines: "",
        header: "",
        main: "",
      },
      i = t.match(/void\s*main\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}/g);
    if (null == i ? void 0 : i.length) {
      const n = i[0].match(/\{((.|\n)*?)\}/g);
      (null == n ? void 0 : n.length) &&
        (e.main = n[0].substring(1, n[0].length - 1));
      const r = t.replace(i[0], ""),
        o = r.match(/#(.*?;)/g) || [],
        a = o.reduce((t, e) => t.replace(e, ""), r);
      (e.header = a), (e.defines = o.join("\n"));
    }
    return e;
  }
  loadChunk(t, e, i) {
    let n = e;
    return (
      /#pragma(\s+([^\s<>]+))/.test(e) &&
        (n = e.replace(/#pragma (.*);?/gi, (e, n) =>
          "vs" === t ? i[n].vertexShader : i[n].fragmentShader
        )),
      n
    );
  }
  destroy() {
    this.moduleList = {};
  }
};
vG = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? yG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && mG(e, i, o), o;
})([JB()], vG);
const bG = new ZB();
bG.bind(KB.ILogService).to(pG).inSingletonScope(),
  bG.bind(KB.ITextureService).to(gG).inSingletonScope(),
  bG.bind(KB.IShaderService).to(vG).inSingletonScope(),
  bG.bind(KB.ITextService).toConstantValue(new aG()),
  bG.bind(KB.IEventEmitter).to(dt);
const xG = (function (t, e) {
    void 0 === e && (e = !0);
    var i = (function (t, e) {
        return function (i) {
          return function (n, r) {
            lG(
              n,
              r,
              function () {
                return t.get(i);
              },
              e
            );
          };
        };
      })(t, e),
      n = (function (t, e) {
        return function (i, n) {
          return function (r, o) {
            lG(
              r,
              o,
              function () {
                return t.getNamed(i, n);
              },
              e
            );
          };
        };
      })(t, e),
      r = (function (t, e) {
        return function (i, n, r) {
          return function (o, a) {
            lG(
              o,
              a,
              function () {
                return t.getTagged(i, n, r);
              },
              e
            );
          };
        };
      })(t, e),
      o = (function (t, e) {
        return function (i) {
          return function (n, r) {
            lG(
              n,
              r,
              function () {
                return t.getAll(i);
              },
              e
            );
          };
        };
      })(t, e);
    return {
      lazyInject: i,
      lazyInjectNamed: n,
      lazyInjectTagged: r,
      lazyMultiInject: o,
    };
  })(bG, !1),
  _G = (t) => {
    const e = xG.lazyInject(t);
    return function (t, i, n) {
      e.call(this, t, i), n && (n.initializer = () => t[i]);
    };
  };
var SG = Object.defineProperty,
  MG = Object.getOwnPropertyDescriptor;
let CG = class {
  constructor() {
    (this.eventsPool = new Map()),
      (this.ee = new dt()),
      (this.bindEvent = (t, e) => {
        switch (e) {
          case "mousemove":
            this.__addEventToPool("mousemove", t);
            break;
          case "click":
          case "unclick":
            this.__addEventToPool("click", t);
            break;
          case "dblclick":
          case "undblclick":
            this.__addEventToPool("dblclick", t);
            break;
          case "swipe":
            this.__addEventToPool("touchmove", t);
            break;
          case "tap":
          case "untap":
          case "dbltap":
          case "undbltap":
            this.__addEventToPool("touchstart", t);
            break;
          default:
            this.__addEventToPool(e, t);
        }
      }),
      (this.__addEventToPool = (t, e) => {
        let i = this.eventsPool.get(t);
        i ||
          (this.eventsPool.set(t, new Set()),
          this.ee.emit("bindLayerEvent", t)),
          (i = this.eventsPool.get(t)),
          i.add(e);
      }),
      (this.removeMapEvent = (t, e) => {
        switch (e) {
          case "mousemove":
            this.__removeEventFromPool("mousemove", t);
            break;
          case "click":
          case "unclick":
            this.__removeEventFromPool("click", t);
            break;
          case "dblclick":
          case "undblclick":
            this.__removeEventFromPool("dblclick", t);
            break;
          case "swipe":
            this.__removeEventFromPool("touchmove", t);
            break;
          case "tap":
          case "untap":
          case "dbltap":
          case "undbltap":
            this.__removeEventFromPool("touchstart", t);
            break;
          default:
            this.__removeEventFromPool(e, t);
        }
      }),
      (this.__removeEventFromPool = (t, e) => {
        const i = this.eventsPool.get(t);
        i &&
          (i.delete(e),
          0 === i.size &&
            (this.eventsPool.delete(t), this.ee.emit("removeMapEvent", t)));
      }),
      (this.__resetState = () => {
        (this.ee = new dt()), (this.eventsPool = new Map());
      }),
      (this._destroy = () => {
        this.ee.removeAllListeners(), this.__resetState();
      }),
      (this.logService = bG.get(KB.ILogService));
  }
};
CG = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? MG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && SG(e, i, o), o;
})([JB()], CG);
class wG {
  constructor(t) {
    (this.props = t),
      (this.__resolution = 1),
      (this.state = this.props.config),
      this.__init();
  }
  __init() {
    this.initCoreCamera(), this.initHudCamera();
  }
  initCoreCamera() {
    const { width: t, height: e } = this.props;
    this.coreCamera = new $n(45, t / e, 10 * Vf, Vf / 100);
  }
  initHudCamera() {
    const { width: t, height: e } = this.props;
    (this.hudCamera = new Mr(-t / 2, t / 2, e / 2, -e / 2, 0.1, 10)),
      this.hudCamera.position.set(0, 0, 1),
      this.hudCamera.updateProjectionMatrix(),
      this.hudCamera.lookAt(0, 0, 0);
  }
  update(t, e) {
    (this.props.width = t),
      (this.props.height = e),
      this.coreCamera.type,
      this.coreCamera.update(t, e),
      this.hudCamera.update(t, e);
  }
  getResolution() {
    return this.__resolution;
  }
  destroy() {
    (this.coreCamera = null), (this.hudCamera = null);
  }
}
var AG, EG;
((EG = AG || (AG = {})).WebGis = "webGis"),
  (EG.XGis = "xGis"),
  (EG.Engine = "engine");
class DG {
  constructor(t) {
    (this.props = t),
      (this.__controlChangeHandler = () => {
        const { layerManager: t } = this.props;
        t.updatePOI();
      }),
      (this.__controlEndHandler = () => {
        const { sceneSystem: t, layerManager: e } = this.props;
        null !== t.hudScene && e.updatePOI(!0);
      }),
      this.__initControl();
  }
  __initControl() {
    const t = new gA({
      zoom: this.props.config.zoom,
      center: this.props.config.center,
      pitch: this.props.config.pitch,
      rotation: this.props.config.rotation,
      enablePan: this.props.config.enablePan,
      enablePitch: this.props.config.enablePitch,
      enableRotate: this.props.config.enableRotate,
      enableZoom: this.props.config.enableZoom,
      lock: this.props.config.lock,
      zoomSpeed: this.props.config.zoomSpeed,
      rotateSpeed: this.props.config.rotateSpeed,
      panSpeed: this.props.config.panSpeed,
      maxPitch: this.props.config.maxPitch,
      minPitch: this.props.config.minPitch,
      maxRotation: this.props.config.maxRotation,
      minRotation: this.props.config.minRotation,
      maxZoom: this.props.config.maxZoom,
      minZoom: this.props.config.minZoom,
      drillSave: this.props.config.drillSave,
    });
    t.reactiveState.after((t) => {
      let { pitch: e, rotation: i } = t;
      const {
        maxPitch: n,
        minPitch: r,
        maxRotation: o,
        minRotation: a,
        minZoom: s,
        maxZoom: l,
      } = t;
      for (e += 180; e < 0; ) e += 360;
      return (
        (i = Ae(i % 360, a, o)),
        (t.pitch = Ae((e % 360) - 180, r, n)),
        (t.rotation = i % 360),
        (t.zoom = Ae(t.zoom, s, l)),
        t
      );
    });
    const e = () => ({
      canvasHeight: this.props.renderSystem.getSize().y,
      bboxSize: this.props.gis.globalOpts
        ? this.props.gis.globalOpts.viewBBoxOption.size.bboxSize
        : 100,
      centerProj: this.props.gis.globalOpts
        ? this.props.gis.globalOpts.viewBBoxOption.centerProj
        : [0, 0],
    });
    t.registerGetAndSet(AG.WebGis, rA, rA),
      t.registerGetAndSet(AG.XGis, new pA(e).transform, new dA(e).transform),
      t.registerGetAndSet(AG.Engine, new hA(e).transform, new cA(e).transform);
    const i = new mA(e);
    (this.controls = new mD(this.props.gis.state.containerDom, {
      dolly: (e) => {
        t.reactiveState.setSourceState(i.dolly(e, t.get(AG.WebGis)));
      },
      pan: (e, n) => {
        t.reactiveState.setSourceState(
          i.pan(e, n, t.get(AG.WebGis), this.getCameraResolution())
        );
      },
      rotate: (e, n) => {
        t.reactiveState.setSourceState(i.rotate(e, n, t.get(AG.WebGis)));
      },
    })),
      this.controls.addEventListener("change", this.__controlChangeHandler),
      this.controls.addEventListener("end", this.__controlEndHandler),
      t.subscribe(AG.Engine, (t) => {
        this.props.cameraSystem.coreCamera.position.fromArray(t.position),
          this.props.cameraSystem.coreCamera.up.fromArray(t.up),
          (this.props.cameraSystem.coreCamera.near = t.near),
          (this.props.cameraSystem.coreCamera.far = t.far),
          (this.props.cameraSystem.coreCamera.fov = t.fov),
          this.props.cameraSystem.coreCamera.updateProjectionMatrix(),
          this.controls.target.fromArray(t.target),
          this.props.cameraSystem.coreCamera.lookAt(this.controls.target);
      }),
      (this.gisStateApi = t);
  }
  getCameraResolution() {
    const { zoom: t, center: e } = this.gisStateApi.getSourceState();
    return this.props.layerManager.geo.getResolution(t) * Math.cos(De(e[1]));
  }
  getBounds() {
    const { pitch: t } = this.gisStateApi.reactiveState.sourceState,
      e = De(t),
      i = 1 / Math.tan(e / 2) / Math.tan(Math.max(0.1, e)),
      n = Math.max(0, 1 - 0.9 * i),
      r = this.__point2mercator(-1, -1),
      o = this.__point2mercator(1, -1),
      a = this.__point2mercator(1, 1 - n),
      s = this.__point2mercator(-1, 1 - n);
    return [
      Math.min(r[0], o[0], s[0], a[0]),
      Math.min(r[1], o[1], s[1], a[1]),
      Math.max(r[0], o[0], s[0], a[0]),
      Math.max(r[1], o[1], s[1], a[1]),
    ];
  }
  __point2mercator(t, e) {
    const i = new Ye(t, e, -1).unproject(this.props.cameraSystem.coreCamera),
      n = new Ye(t, e, 1).unproject(this.props.cameraSystem.coreCamera),
      r = i.z === n.z ? 0 : (0 - i.z) / (n.z - i.z);
    return [i.x * (1 - r) + n.x * r, i.y * (1 - r) + n.y * r];
  }
  lock() {
    this.controls.enabled = !1;
  }
  unlock() {
    this.controls.enabled = !0;
  }
  reset() {
    this.controls.reset();
  }
  destroy() {
    this.controls.removeEventListener("change", this.__controlChangeHandler),
      this.controls.removeEventListener("end", this.__controlEndHandler),
      this.controls.dispose(),
      this.gisStateApi.unsubjectAll();
  }
}
var TG = Object.defineProperty,
  PG = Object.getOwnPropertyDescriptor;
class LG {
  constructor(t) {
    (this.props = t),
      (this.onWindowResize = (t) => {
        t.preventDefault();
      }),
      (this.onWindowOnline = (t) => {
        t.preventDefault();
      }),
      this.__init();
  }
  __init() {
    window.addEventListener("orientationchange", this.onWindowResize, !1),
      window.addEventListener("online", this.onWindowOnline, !1);
  }
  destroy() {
    window.removeEventListener("orientationchange", this.onWindowResize, !1),
      window.removeEventListener("online", this.onWindowOnline, !1);
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? PG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && TG(e, i, o);
})([_G(KB.ILogService)], LG.prototype, "logService", 2);
var IG = Object.defineProperty,
  NG = Object.getOwnPropertyDescriptor;
class RG {
  constructor(t) {
    (this.props = t),
      (this.bindEventListeners = (t) => {
        const { containerDom: e } = this.props;
        e.addEventListener(t, this.handleEvent, !1);
      }),
      (this.mouse = new Le());
  }
  removeEventListener(t) {
    const { containerDom: e } = this.props;
    e.removeEventListener(t, this.handleEvent);
  }
  handleHoverCursor() {
    const { containerDom: t } = this.props;
    this.isHover && "pointer" !== t.style.cursor
      ? (t.style.cursor = "pointer")
      : this.isHover ||
        "pointer" !== t.style.cursor ||
        (t.style.cursor = "default");
  }
  processEvent(t) {
    const { containerDom: e } = this.props;
    let i, n;
    if (
      (t.preventDefault(),
      (this.orginalEvent = t),
      (this.isHover = !1),
      (this.eventType = t.type),
      t instanceof MouseEvent)
    )
      (i = t.offsetX), (n = t.offsetY);
    else if (t instanceof TouchEvent) {
      const { top: r, left: o } = (function (t) {
        let e = t,
          i = 0,
          n = 0;
        for (; null !== e; )
          (i += e.offsetTop), (n += e.offsetLeft), (e = e.offsetParent);
        return {
          top: i,
          left: n,
        };
      })(e);
      (i = t.targetTouches[0].pageX - o), (n = t.targetTouches[0].pageY - r);
    } else this.logService.error(`传入event ${this.eventType} 无法解析位置`);
    (this.offsetX = i), (this.offsetY = n);
  }
  layerDispatch(t, e) {
    const { layerManager: i } = this.props,
      { object: n, instanceId: r } = t || {};
    if (n) {
      const t = cf(r) ? n.getUserDataAt(r) : n.ext,
        o = {
          x: this.offsetX,
          y: this.offsetY,
          code: 200,
          properties: ot(rt({}, t), {
            _id_: n.id,
            _instanceId_: r,
          }),
          orginalEvent: this.orginalEvent,
        };
      if (
        (e.ee.emit(this.eventType, o),
        e.ee.emit("un" + this.eventType, null),
        e.interaction.hover.enabled &&
          e.interaction.hover.trigger === this.eventType &&
          (e.interaction.hover.effect.color &&
            e.active({
              type: "hover",
              object: n,
              id: n.id,
              name: n.ext.name,
              instanceId: r,
              color: e.interaction.hover.effect.color,
            }),
          e.interaction.hover.effect.poi &&
            e.poiGroup.active({
              id: n.id,
              instanceId: r,
            }),
          e.ee.emit("hover", o),
          (this.isHover = !0)),
        e.interaction.select.enabled &&
          e.interaction.select.trigger === this.eventType &&
          (e.comboTimer ||
            (e.comboTimer = setTimeout(() => {
              (e.comboTimer = null),
                e.interaction.select.effect.color &&
                  e.active({
                    type: "select",
                    object: n,
                    id: n.id,
                    name: n.ext.name,
                    instanceId: r,
                    color: e.interaction.select.effect.color,
                    multi: e.interaction.select.multi,
                  }),
                e.interaction.select.effect.poi &&
                  e.poiGroup.active({
                    id: n.id,
                    instanceId: r,
                  }),
                e.ee.emit("select", o);
            }, e.comboTimeout))),
        (this.eventType === i.baseMapLayer.state.drill.drillDownEvent ||
          "un" + this.eventType === i.baseMapLayer.state.drill.drillUpEvent) &&
          i.baseMapLayer.state.drill.enabled &&
          !i.baseMapLayer.state.drill.preventMouse)
      ) {
        const t = i.baseMapLayer.state.data.region;
        if (
          t &&
          0 === i.baseMapLayer.currentLevel &&
          !i.baseMapLayer.currentRegion
        ) {
          const e = Object.values(t).find((t) => t.child.includes(n.ext.id));
          if (e) return void i.baseMapLayer.drillRegion(e.adcode);
        }
        const e = n.ext.acroutes,
          r = i.baseMapLayer.currentLevel;
        if (e) {
          const t = e.split(",");
          t.length > r + 1
            ? i.baseMapLayer.drillDown(t[r + 1])
            : i.baseMapLayer.drillDown(n.ext.adcode);
        } else i.baseMapLayer.drillDown(n.ext.adcode);
      }
    } else
      e.ee.emit(this.eventType, null),
        e.ee.emit("un" + this.eventType, {}),
        e.interaction.hover.enabled &&
          e.interaction.hover.trigger === this.eventType &&
          (e.interaction.hover.effect.color &&
            e.unActive({
              type: "hover",
            }),
          e.interaction.hover.effect.poi && e.poiGroup.active(null),
          e.ee.emit("hover", null)),
        e.interaction.select.enabled &&
          e.interaction.select.trigger === this.eventType &&
          (e.interaction.select.effect.color &&
            e.unActive({
              type: "select",
            }),
          e.interaction.select.effect.poi && e.poiGroup.active(null),
          e.ee.emit("select", null)),
        (this.eventType !== i.baseMapLayer.state.drill.drillDownEvent &&
          "un" + this.eventType !== i.baseMapLayer.state.drill.drillUpEvent) ||
          (i.baseMapLayer.state.drill.enabled &&
            !i.baseMapLayer.state.drill.preventMouse &&
            i.baseMapLayer.drillUp());
  }
  destroy() {
    const { containerDom: t } = this.props;
    this.props.eventManager.eventsPool.forEach((e, i) => {
      null == t || t.removeEventListener(i, this.handleEvent);
    });
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? NG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && IG(e, i, o);
})([_G(KB.ILogService)], RG.prototype, "logService", 2);
var OG = Object.defineProperty,
  FG = Object.getOwnPropertyDescriptor;
class zG extends RG {
  constructor(t) {
    super(t),
      (this.props = t),
      (this.handleEvent = (t) => {
        const {
            cameraSystem: e,
            containerDom: i,
            layerManager: n,
            renderSystem: r,
          } = this.props,
          o = Sf(i) || r.coreRenderer.domElement;
        if (t.target !== o) return;
        const a = this.props.eventManager.eventsPool.get(t.type);
        a &&
          (super.processEvent(t),
          this.mouse.set(
            (this.offsetX / i.clientWidth) * 2 - 1,
            (-this.offsetY / i.clientHeight) * 2 + 1
          ),
          this.raycaster.setFromCamera(this.mouse, e.coreCamera),
          a.forEach((t) => {
            const e = n.get({
              layerID: t,
            });
            if (e && e.state.common.visible) {
              const t = e.listenerObj.children,
                i =
                  1 === t.length && t[0].isInstancedMesh
                    ? this.raycaster.intersectObject(t[0], e.recursive)
                    : this.raycaster.intersectObjects(t, e.recursive),
                n = i.length > 0 ? i[0] : null;
              super.layerDispatch(n, e);
            }
          }),
          super.handleHoverCursor());
      }),
      this.__init();
  }
  __init() {
    this.__initRayPick();
  }
  __initRayPick() {
    this.raycaster || (this.raycaster = new IE());
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? FG(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && OG(e, i, o);
})([_G(KB.ILogService)], zG.prototype, "logService", 2);
class kG extends RG {
  constructor(t) {
    super(t),
      (this.props = t),
      (this.handleEvent = (t) => {
        const {
            cameraSystem: e,
            renderSystem: i,
            layerManager: n,
            containerDom: r,
          } = this.props,
          o = Sf(r) || i.coreRenderer.domElement;
        if (t.target !== o) return;
        super.processEvent(t),
          this.mouse.set(this.offsetX, this.offsetY),
          e.coreCamera.setViewOffset(
            i.coreRenderer.domElement.width,
            i.coreRenderer.domElement.height,
            (this.mouse.x * window.devicePixelRatio) | 0,
            (this.mouse.y * window.devicePixelRatio) | 0,
            1,
            1
          ),
          i.coreRenderer.setRenderTarget(this.pickingTexture),
          i.coreRenderer.clear(),
          i.coreRenderer.render(this.pickingScene, e.coreCamera),
          e.coreCamera.clearViewOffset();
        const a = new Uint8Array(4);
        if (
          (i.coreRenderer.readRenderTargetPixels(
            this.pickingTexture,
            0,
            0,
            1,
            1,
            a
          ),
          i.coreRenderer.setRenderTarget(null),
          (function (t) {
            return 0 === t[0] && 0 === t[1] && 0 === t[2] && 0 === t[3];
          })(a))
        )
          this.pickingLayers.forEach((t) => {
            super.layerDispatch(null, t);
          });
        else {
          const t = (a[0] << 16) | (a[1] << 8) | a[2],
            e = this.pickingObjMap.get(t),
            i = n.get({
              layerID: e.ext.realLayerID,
            });
          super.layerDispatch(e, i);
        }
        super.handleHoverCursor(), i.coreRenderer.setRenderTarget(null);
      }),
      this.__init();
  }
  __init() {
    this.__initGPUPick();
  }
  __initGPUPick() {
    if (this.pickingScene) return;
    (this.pickingScene = new Ka()),
      (this.pickingTexture = new He(1, 1)),
      (this.pickingTexture.texture.minFilter = Vt);
    const t = new Jn({
      vertexShader:
        "attribute vec3 idcolor;\nattribute vec3 position;\n\nvarying vec3 vidcolor;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  vidcolor = idcolor;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
      fragmentShader:
        "precision highp float;\nvarying vec3 vidcolor;\nvoid main(void) {\n  gl_FragColor = vec4(vidcolor, 1.0);\n}",
      transparent: !1,
      side: xt,
    });
    (this.pickingObjMap = new Map()),
      (this.pickingLayers = []),
      this.props.layerManager.ee.on("loaded", (e) => {
        this.pickingLayers.push(e);
        const i = this.pickingScene.getObjectByFn(
          (t) => t.ext.realLayerID === e.id
        );
        i && i.destroy(!1);
        const n = null != i ? i : new As();
        n.ext.realLayerID = e.id;
        for (let r = 0; r < e.listenerObj.children.length; r++) {
          const i = e.listenerObj.children[r];
          if (i instanceof Wn && i.isMesh) {
            const r = new ln(),
              o = i.geometry.clone();
            this.applyVertexColors(o, r.setHex(i.id));
            const a = new Wn(o, t);
            (i.ext.realLayerID = e.id),
              n.add(a),
              this.pickingObjMap.set(i.id, i);
          }
        }
        i || this.pickingScene.add(n);
      });
  }
  applyVertexColors(t, e) {
    const i = t.attributes.position,
      n = [];
    for (let r = 0; r < i.count; r++) n.push(e.r, e.g, e.b);
    t.setAttribute("idcolor", new bn(n, 3));
  }
}
var BG = (function () {
    if ("undefined" != typeof Map) return Map;
    function t(t, e) {
      var i = -1;
      return (
        t.some(function (t, n) {
          return t[0] === e && ((i = n), !0);
        }),
        i
      );
    }
    return (function () {
      function e() {
        this.__entries__ = [];
      }
      return (
        Object.defineProperty(e.prototype, "size", {
          get: function () {
            return this.__entries__.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.get = function (e) {
          var i = t(this.__entries__, e),
            n = this.__entries__[i];
          return n && n[1];
        }),
        (e.prototype.set = function (e, i) {
          var n = t(this.__entries__, e);
          ~n ? (this.__entries__[n][1] = i) : this.__entries__.push([e, i]);
        }),
        (e.prototype.delete = function (e) {
          var i = this.__entries__,
            n = t(i, e);
          ~n && i.splice(n, 1);
        }),
        (e.prototype.has = function (e) {
          return !!~t(this.__entries__, e);
        }),
        (e.prototype.clear = function () {
          this.__entries__.splice(0);
        }),
        (e.prototype.forEach = function (t, e) {
          void 0 === e && (e = null);
          for (var i = 0, n = this.__entries__; i < n.length; i++) {
            var r = n[i];
            t.call(e, r[1], r[0]);
          }
        }),
        e
      );
    })();
  })(),
  GG =
    "undefined" != typeof window &&
    "undefined" != typeof document &&
    window.document === document,
  UG =
    "undefined" != typeof global && global.Math === Math
      ? global
      : "undefined" != typeof self && self.Math === Math
      ? self
      : "undefined" != typeof window && window.Math === Math
      ? window
      : Function("return this")(),
  jG =
    "function" == typeof requestAnimationFrame
      ? requestAnimationFrame.bind(UG)
      : function (t) {
          return setTimeout(function () {
            return t(Date.now());
          }, 1e3 / 60);
        };
var HG = [
    "top",
    "right",
    "bottom",
    "left",
    "width",
    "height",
    "size",
    "weight",
  ],
  VG = "undefined" != typeof MutationObserver,
  WG = (function () {
    function t() {
      (this.connected_ = !1),
        (this.mutationEventsAdded_ = !1),
        (this.mutationsObserver_ = null),
        (this.observers_ = []),
        (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
        (this.refresh = (function (t, e) {
          var i = !1,
            n = !1,
            r = 0;
          function o() {
            i && ((i = !1), t()), n && s();
          }
          function a() {
            jG(o);
          }
          function s() {
            var t = Date.now();
            if (i) {
              if (t - r < 2) return;
              n = !0;
            } else (i = !0), (n = !1), setTimeout(a, e);
            r = t;
          }
          return s;
        })(this.refresh.bind(this), 20));
    }
    return (
      (t.prototype.addObserver = function (t) {
        ~this.observers_.indexOf(t) || this.observers_.push(t),
          this.connected_ || this.connect_();
      }),
      (t.prototype.removeObserver = function (t) {
        var e = this.observers_,
          i = e.indexOf(t);
        ~i && e.splice(i, 1),
          !e.length && this.connected_ && this.disconnect_();
      }),
      (t.prototype.refresh = function () {
        this.updateObservers_() && this.refresh();
      }),
      (t.prototype.updateObservers_ = function () {
        var t = this.observers_.filter(function (t) {
          return t.gatherActive(), t.hasActive();
        });
        return (
          t.forEach(function (t) {
            return t.broadcastActive();
          }),
          t.length > 0
        );
      }),
      (t.prototype.connect_ = function () {
        GG &&
          !this.connected_ &&
          (document.addEventListener("transitionend", this.onTransitionEnd_),
          window.addEventListener("resize", this.refresh),
          VG
            ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
              this.mutationsObserver_.observe(document, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0,
              }))
            : (document.addEventListener("DOMSubtreeModified", this.refresh),
              (this.mutationEventsAdded_ = !0)),
          (this.connected_ = !0));
      }),
      (t.prototype.disconnect_ = function () {
        GG &&
          this.connected_ &&
          (document.removeEventListener("transitionend", this.onTransitionEnd_),
          window.removeEventListener("resize", this.refresh),
          this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
          this.mutationEventsAdded_ &&
            document.removeEventListener("DOMSubtreeModified", this.refresh),
          (this.mutationsObserver_ = null),
          (this.mutationEventsAdded_ = !1),
          (this.connected_ = !1));
      }),
      (t.prototype.onTransitionEnd_ = function (t) {
        var e = t.propertyName,
          i = void 0 === e ? "" : e;
        HG.some(function (t) {
          return !!~i.indexOf(t);
        }) && this.refresh();
      }),
      (t.getInstance = function () {
        return this.instance_ || (this.instance_ = new t()), this.instance_;
      }),
      (t.instance_ = null),
      t
    );
  })(),
  qG = function (t, e) {
    for (var i = 0, n = Object.keys(e); i < n.length; i++) {
      var r = n[i];
      Object.defineProperty(t, r, {
        value: e[r],
        enumerable: !1,
        writable: !1,
        configurable: !0,
      });
    }
    return t;
  },
  YG = function (t) {
    return (t && t.ownerDocument && t.ownerDocument.defaultView) || UG;
  },
  XG = tU(0, 0, 0, 0);
function QG(t) {
  return parseFloat(t) || 0;
}
function ZG(t) {
  for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
  return e.reduce(function (e, i) {
    return e + QG(t["border-" + i + "-width"]);
  }, 0);
}
function JG(t) {
  var e = t.clientWidth,
    i = t.clientHeight;
  if (!e && !i) return XG;
  var n = YG(t).getComputedStyle(t),
    r = (function (t) {
      for (
        var e = {}, i = 0, n = ["top", "right", "bottom", "left"];
        i < n.length;
        i++
      ) {
        var r = n[i],
          o = t["padding-" + r];
        e[r] = QG(o);
      }
      return e;
    })(n),
    o = r.left + r.right,
    a = r.top + r.bottom,
    s = QG(n.width),
    l = QG(n.height);
  if (
    ("border-box" === n.boxSizing &&
      (Math.round(s + o) !== e && (s -= ZG(n, "left", "right") + o),
      Math.round(l + a) !== i && (l -= ZG(n, "top", "bottom") + a)),
    !(function (t) {
      return t === YG(t).document.documentElement;
    })(t))
  ) {
    var u = Math.round(s + o) - e,
      c = Math.round(l + a) - i;
    1 !== Math.abs(u) && (s -= u), 1 !== Math.abs(c) && (l -= c);
  }
  return tU(r.left, r.top, s, l);
}
var KG =
  "undefined" != typeof SVGGraphicsElement
    ? function (t) {
        return t instanceof YG(t).SVGGraphicsElement;
      }
    : function (t) {
        return t instanceof YG(t).SVGElement && "function" == typeof t.getBBox;
      };
function $G(t) {
  return GG
    ? KG(t)
      ? (function (t) {
          var e = t.getBBox();
          return tU(0, 0, e.width, e.height);
        })(t)
      : JG(t)
    : XG;
}
function tU(t, e, i, n) {
  return {
    x: t,
    y: e,
    width: i,
    height: n,
  };
}
var eU = (function () {
    function t(t) {
      (this.broadcastWidth = 0),
        (this.broadcastHeight = 0),
        (this.contentRect_ = tU(0, 0, 0, 0)),
        (this.target = t);
    }
    return (
      (t.prototype.isActive = function () {
        var t = $G(this.target);
        return (
          (this.contentRect_ = t),
          t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
        );
      }),
      (t.prototype.broadcastRect = function () {
        var t = this.contentRect_;
        return (
          (this.broadcastWidth = t.width), (this.broadcastHeight = t.height), t
        );
      }),
      t
    );
  })(),
  iU = function (t, e) {
    var i,
      n,
      r,
      o,
      a,
      s,
      l,
      u =
        ((n = (i = e).x),
        (r = i.y),
        (o = i.width),
        (a = i.height),
        (s = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object),
        (l = Object.create(s.prototype)),
        qG(l, {
          x: n,
          y: r,
          width: o,
          height: a,
          top: r,
          right: n + o,
          bottom: a + r,
          left: n,
        }),
        l);
    qG(this, {
      target: t,
      contentRect: u,
    });
  },
  nU = (function () {
    function t(t, e, i) {
      if (
        ((this.activeObservations_ = []),
        (this.observations_ = new BG()),
        "function" != typeof t)
      )
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      (this.callback_ = t), (this.controller_ = e), (this.callbackCtx_ = i);
    }
    return (
      (t.prototype.observe = function (t) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if ("undefined" != typeof Element && Element instanceof Object) {
          if (!(t instanceof YG(t).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var e = this.observations_;
          e.has(t) ||
            (e.set(t, new eU(t)),
            this.controller_.addObserver(this),
            this.controller_.refresh());
        }
      }),
      (t.prototype.unobserve = function (t) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if ("undefined" != typeof Element && Element instanceof Object) {
          if (!(t instanceof YG(t).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var e = this.observations_;
          e.has(t) &&
            (e.delete(t), e.size || this.controller_.removeObserver(this));
        }
      }),
      (t.prototype.disconnect = function () {
        this.clearActive(),
          this.observations_.clear(),
          this.controller_.removeObserver(this);
      }),
      (t.prototype.gatherActive = function () {
        var t = this;
        this.clearActive(),
          this.observations_.forEach(function (e) {
            e.isActive() && t.activeObservations_.push(e);
          });
      }),
      (t.prototype.broadcastActive = function () {
        if (this.hasActive()) {
          var t = this.callbackCtx_,
            e = this.activeObservations_.map(function (t) {
              return new iU(t.target, t.broadcastRect());
            });
          this.callback_.call(t, e, t), this.clearActive();
        }
      }),
      (t.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      }),
      (t.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      }),
      t
    );
  })(),
  rU = "undefined" != typeof WeakMap ? new WeakMap() : new BG(),
  oU = function t(e) {
    if (!(this instanceof t))
      throw new TypeError("Cannot call a class as a function.");
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    var i = WG.getInstance(),
      n = new nU(e, i, this);
    rU.set(this, n);
  };
["observe", "unobserve", "disconnect"].forEach(function (t) {
  oU.prototype[t] = function () {
    var e;
    return (e = rU.get(this))[t].apply(e, arguments);
  };
});
var aU = void 0 !== UG.ResizeObserver ? UG.ResizeObserver : oU;
class sU {
  constructor(t) {
    (this.props = t),
      (this.__containerDomResizeHandler = () => {
        const {
            containerDom: t,
            viewportSystem: e,
            renderSystem: i,
            layerManager: n,
            ee: r,
          } = this.props,
          o = t.clientWidth,
          a = t.clientHeight;
        i.setSize(o, a),
          e.setSize(o, a),
          r.emit("resize", {
            width: o,
            height: a,
          }),
          n.updatePOI(!0);
      }),
      (this.bindEventListeners = (t) => {
        const { containerDom: e } = this.props;
        e.addEventListener(t, this.handleEvent, !1);
      }),
      (this.handleEvent = (t) => {
        const { ee: e } = this.props;
        t.preventDefault();
        const i = t.type,
          n = {
            orginalEvent: t,
          };
        e.emit(i, n);
      }),
      this.__initContainerDomResizeHandle();
  }
  __initContainerDomResizeHandle() {
    const { autoSize: t, containerDom: e } = this.props;
    t &&
      ((this.containerDomResizeObserver = new aU(() => {
        this.__containerDomResizeHandler();
      })),
      this.containerDomResizeObserver.observe(e));
  }
  destroy() {
    var t;
    null == (t = this.containerDomResizeObserver) || t.disconnect();
  }
}
var lU,
  uU,
  cU,
  hU,
  pU = Object.defineProperty,
  dU = Object.getOwnPropertyDescriptor;
class fU {
  constructor(t) {
    (this.props = t),
      (this._contextLost = (t) => {
        t.preventDefault();
      }),
      (this._contextRestored = (t) => {}),
      this.__init();
  }
  __init() {
    const { renderSystem: t } = this.props,
      e = t.coreRenderer.domElement;
    e.addEventListener("webglcontextlost", this._contextLost, !1),
      e.addEventListener("webglcontextrestored", this._contextRestored, !1);
  }
  destroy() {
    var t;
    const { renderSystem: e } = this.props,
      i = null == (t = e.coreRenderer) ? void 0 : t.domElement;
    null == i ||
      i.removeEventListener("webglcontextlost", this._contextLost, !1),
      null == i ||
        i.removeEventListener(
          "webglcontextrestored",
          this._contextRestored,
          !1
        );
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? dU(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && pU(e, i, o);
})([_G(KB.ILogService)], fU.prototype, "logService", 2);
class gU {
  constructor(t) {
    (this.props = t),
      this.initLayerEvent(),
      this.initMapContextEvent(),
      this.initMapContainerEvent(),
      this.initWindowEvent();
  }
  initLayerEvent() {
    this.__initEngine(), this.bindLayerListeners();
  }
  __initEngine() {
    const { engine: t } = this.props;
    switch (t) {
      case "cpu":
        this.pickingEngine = new zG(this.props);
        break;
      case "gpu":
        this.pickingEngine = new kG(this.props);
    }
  }
  bindLayerListeners() {
    this.props.eventManager.ee.on("bindLayerEvent", (t) => {
      this.pickingEngine.bindEventListeners(t);
    }),
      this.props.eventManager.ee.on("removeMapEvent", (t) => {
        this.pickingEngine.removeEventListener(t);
      });
  }
  initMapContextEvent() {
    this.mapContextEvent = new fU(this.props);
  }
  initWindowEvent() {
    this.windowEvent = new LG(this.props);
  }
  initMapContainerEvent() {
    this.mapContainerEvent = new sU(this.props);
  }
  destroy() {
    this.pickingEngine.destroy(),
      this.mapContainerEvent.destroy(),
      this.mapContextEvent.destroy(),
      this.windowEvent.destroy(),
      this.props.eventManager._destroy();
  }
}
((uU = lU || (lU = {}))[(uU.PLANE_LAYER = 0)] = "PLANE_LAYER"),
  (uU[(uU.SHADOW_PLANE = 1)] = "SHADOW_PLANE"),
  (uU[(uU.BASE_MAP_LAYER_BOTTOM_STROKE = 2)] = "BASE_MAP_LAYER_BOTTOM_STROKE"),
  (uU[(uU.BASE_MAP_LAYER_EXTRUDE_MESH = 3)] = "BASE_MAP_LAYER_EXTRUDE_MESH"),
  (uU[(uU.BASE_MAP_LAYER_PROVINCE_MESH = 4)] = "BASE_MAP_LAYER_PROVINCE_MESH"),
  (uU[(uU.DISTRICT_LAYER_PROVINCE_MESH = 5)] = "DISTRICT_LAYER_PROVINCE_MESH"),
  (uU[(uU.BASE_MAP_LAYER_PROVINCE_STROKE = 6)] =
    "BASE_MAP_LAYER_PROVINCE_STROKE"),
  (uU[(uU.BASE_MAP_LAYER_COUNTRY_STROKE = 7)] =
    "BASE_MAP_LAYER_COUNTRY_STROKE"),
  (uU[(uU.BASE_MAP_LAYER_INNERSHADOW_MESH = 8)] =
    "BASE_MAP_LAYER_INNERSHADOW_MESH"),
  (uU[(uU.BOUNDARY_STREAMER_MESH = 9)] = "BOUNDARY_STREAMER_MESH"),
  (uU[(uU.POLYGON_MESH = 10)] = "POLYGON_MESH"),
  (uU[(uU.POLYGON_STROKE = 11)] = "POLYGON_STROKE"),
  (uU[(uU.PATH_LAYER = 12)] = "PATH_LAYER"),
  (uU[(uU.PATH_LAYER_DIR = 13)] = "PATH_LAYER_DIR"),
  (uU[(uU.BREATH_POINT_LAYER_OUTER_MESH = 14)] =
    "BREATH_POINT_LAYER_OUTER_MESH"),
  (uU[(uU.BREATH_POINT_LAYER_INNER_MESH = 15)] =
    "BREATH_POINT_LAYER_INNER_MESH"),
  (uU[(uU.BUBBLE_LAYER_MESH = 16)] = "BUBBLE_LAYER_MESH"),
  (uU[(uU.POINT_HEATMAP3D_LAYER = 17)] = "POINT_HEATMAP3D_LAYER"),
  (uU[(uU.HEXAGON_HEATMAP = 18)] = "HEXAGON_HEATMAP"),
  (uU[(uU.LIGHT_BAR_LAYER = 19)] = "LIGHT_BAR_LAYER"),
  (uU[(uU.BAR_LAYER = 20)] = "BAR_LAYER"),
  (uU[(uU.FLY_LINE_LAYER = 21)] = "FLY_LINE_LAYER"),
  (uU[(uU.STREAM_LAYER = 22)] = "STREAM_LAYER"),
  (uU[(uU.PARTICLE_LAYER = 23)] = "PARTICLE_LAYER"),
  ((hU = cU || (cU = {}))[(hU.POI = 0)] = "POI"),
  (hU[(hU.ATTACH_LAYER_BACKGROUND_MESH = 1)] = "ATTACH_LAYER_BACKGROUND_MESH"),
  (hU[(hU.ATTACH_LAYER_FILL_MESH = 2)] = "ATTACH_LAYER_FILL_MESH"),
  (hU[(hU.ATTACH_LAYER_STROKE_MESH = 3)] = "ATTACH_LAYER_STROKE_MESH"),
  (hU[(hU.ATTACH_LAYER_BORDER_MESH = 4)] = "ATTACH_LAYER_BORDER_MESH"),
  (hU[(hU.ATTACH_LAYER_POI = 5)] = "ATTACH_LAYER_POI");
class mU {
  constructor(t) {
    (this.props = t), (this.type = "ambient"), this.__init();
  }
  __init() {
    this.state = this.props;
    const { color: t, intensity: e } = this.props;
    this.light = new pE(t, this.intensityScale(e));
  }
  set(t) {
    this.state = af(this.state, t);
    const { color: e, intensity: i } = this.state;
    (this.light.color = new ln(e)),
      (this.light.intensity = this.intensityScale(i));
  }
  intensityScale(t) {
    const e = [0, 100];
    return 0 + ((t - 0) / (e[1] - e[0])) * 2;
  }
  destroy() {
    this.light.destroy();
  }
}
class yU {
  constructor(t, e) {
    (this.gis = t),
      (this.props = e),
      (this.type = "directional"),
      this.__init();
  }
  __init() {
    this.state = this.props;
    const { color: t, intensity: e } = this.props;
    this.light = new hE(t, this.intensityScale(e));
  }
  set(t) {
    this.state = af(this.state, t);
    const { color: e, intensity: i, x: n, y: r, z: o } = this.state;
    (this.light.color = new ln(e)),
      (this.light.intensity = this.intensityScale(i)),
      this.light.position.set(this.xScale(n), this.yScale(r), this.zScale(o));
  }
  updateArea() {
    const { x: t, y: e, z: i } = this.props,
      {
        bboxOption: {
          size: { width: n, height: r },
        },
        cameraStatus: { far: o, target: a },
      } = this.gis.globalOpts;
    if (
      ((this.light.shadow.camera.near = 0),
      (this.light.shadow.camera.far = o),
      (this.light.shadow.camera.left = -n / 2),
      (this.light.shadow.camera.right = n / 2),
      (this.light.shadow.camera.top = r / 2),
      (this.light.shadow.camera.bottom = -r / 2),
      this.light.position.set(this.xScale(t), this.yScale(e), this.zScale(i)),
      !this.light.target.parent)
    ) {
      const t = new Hi();
      (this.light.target = t), this.gis.sceneSystem.coreScene.add(t);
    }
    this.light.target.position.set(a[0], a[1], 0);
  }
  xScale(t) {
    const {
        bboxOption: {
          bboxProj: e,
          size: { width: i },
        },
      } = this.gis.globalOpts,
      n = e[0] - i,
      r = e[2] + i,
      o = [-1, 1];
    return n + ((t - o[0]) / (o[1] - o[0])) * (r - n);
  }
  yScale(t) {
    const {
        bboxOption: {
          bboxProj: e,
          size: { height: i },
        },
      } = this.gis.globalOpts,
      n = e[1] - i,
      r = e[3] + i,
      o = [-1, 1];
    return n + ((t - o[0]) / (o[1] - o[0])) * (r - n);
  }
  zScale(t) {
    const {
        bboxOption: {
          size: { bboxSize: e },
          baseHeight: i,
        },
      } = this.gis.globalOpts,
      n = [0, 1];
    return i + ((t - n[0]) / (n[1] - n[0])) * (e - i);
  }
  intensityScale(t) {
    const e = [0, 100];
    return 0 + ((t - e[0]) / (e[1] - e[0])) * 2;
  }
  destroy() {
    this.light.destroy();
  }
}
var vU = Object.defineProperty,
  bU = Object.getOwnPropertyDescriptor;
class xU {
  constructor(t) {
    (this.props = t), (this.lights = []), this.__init();
  }
  __init() {
    (this.state = this.props.config),
      this.initAmbient(),
      this.initDirectionsal(),
      this.initShadow(),
      (this._propsWatch = kf.createPropsWatch()),
      this._initPropsWatchRule(),
      (this.ee = new dt()),
      this.ee.on("updateArea", () => {
        this.updateArea();
      });
  }
  updateArea() {
    var t;
    if ((null == (t = this.directional) || t.updateArea(), this.shadowPlane)) {
      const { gis: t } = this.props,
        { globalOpts: e } = t,
        {
          centerProj: i,
          size: { width: n, height: r },
        } = e.bboxOption;
      this.shadowPlane.scale.set(3 * n, 3 * r, 1),
        this.shadowPlane.position.setX(i[0]),
        this.shadowPlane.position.setY(i[1]);
    }
  }
  initAmbient() {
    const { ambient: t } = this.state;
    t.enabled && ((this.ambient = new mU(t)), this.add(this.ambient));
  }
  initDirectionsal() {
    const { gis: t } = this.props,
      { directional: e } = this.state;
    e.enabled &&
      ((this.directional = new yU(t, e)), this.add(this.directional));
  }
  initShadow() {
    this.__initShadowPlane(), this.updateShadow();
  }
  get() {
    return af(this.state, {
      light: this.lights,
    });
  }
  set(t) {
    return this._propsWatch.compare(this.state, t), this;
  }
  add(t) {
    const { sceneSystem: e } = this.props;
    return this.lights.push(t), e.coreScene.add(t.light), this;
  }
  remove(t) {
    return this;
  }
  __initShadowPlane() {
    const { sceneSystem: t } = this.props,
      {
        directional: {
          shadow: { color: e, opacity: i },
        },
      } = this.state,
      n = new dr(1, 1),
      r = new FA({
        color: e,
        opacity: i,
        transparent: !0,
      });
    (this.shadowPlane = new Wn(n, r)),
      this.shadowPlane.setRenderIndex(lU.SHADOW_PLANE),
      (this.shadowPlane.receiveShadow = !0),
      (this.shadowPlane.name = "shadow-plane"),
      t.coreScene.add(this.shadowPlane);
  }
  updateShadow() {
    if (!this.directional)
      return void this.logService.error("平行光不存在，无法配置阴影");
    const {
      enabled: t,
      color: e,
      opacity: i,
      size: n,
      bias: r,
    } = this.state.directional.shadow;
    t
      ? ((this.shadowPlane.visible = !0),
        (this.directional.light.castShadow = !0),
        (this.directional.light.shadow.bias = r),
        (this.directional.light.shadow.mapSize.width = n),
        (this.directional.light.shadow.mapSize.height = n))
      : ((this.shadowPlane.visible = !1),
        (this.directional.light.castShadow = !1));
    const o = this.shadowPlane.material;
    (o.color = new ln(e)), (o.opacity = i), (o.needsUpdate = !0);
  }
  _initPropsWatchRule() {
    this._propsWatch.addWatch([
      this._propsWatch.defaultRule("", "always", (t) => {
        this.state = af(this.state, t);
      }),
      this._propsWatch.defaultRule(["ambient"], "diffDeep", (t) => {
        var e;
        null == (e = this.ambient) || e.set(t.ambient);
      }),
      this._propsWatch.defaultRule(
        ["directional", "shadow"],
        "diffDeep",
        (t) => {
          this.updateShadow();
        }
      ),
      this._propsWatch.defaultRule(
        [
          ["directional", "color"],
          ["directional", "x"],
          ["directional", "y"],
          ["directional", "z"],
          ["directional", "intensity"],
        ],
        "diffAnyoneDeep",
        (t) => {
          var e;
          null == (e = this.directional) || e.set(t.directional);
        }
      ),
    ]);
  }
  destroy() {
    var t, e;
    this.shadowPlane.destroy(),
      null == (t = this.ambient) || t.destroy(),
      null == (e = this.directional) || e.destroy(),
      this.ee.removeAllListeners(),
      (this._propsWatch = null);
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? bU(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && vU(e, i, o);
})([_G(KB.ILogService)], xU.prototype, "logService", 2);
var _U = Object.defineProperty,
  SU = Object.getOwnPropertyDescriptor;
class MU {
  constructor(t) {
    (this.props = t),
      (this.size = new Le(1, 1)),
      (this.rtManager = new rr()),
      (this.renderCb = []);
    const { width: e, height: i, sceneSystem: n, cameraSystem: r } = this.props;
    this.initRender(),
      this.setSize(e, i),
      this.register((t) => {
        t.setRenderTarget(null),
          t.render(n.coreScene, r.coreCamera),
          t.render(n.hudScene, r.hudCamera),
          this.markerRenderer && this.markerRenderer.rerender();
      });
  }
  initRender() {
    const { containerDom: t, sceneSystem: e } = this.props;
    (this.coreRenderer = new Ja({
      alpha: !0,
      antialias: !0,
      precision: "highp",
    })),
      (this.coreRenderer.sortObjects = !0),
      (this.coreRenderer.autoClear = !1),
      this.coreRenderer.clear();
    this.createRendererContainer(t).appendChild(this.coreRenderer.domElement),
      this.coreRenderer.setPixelRatio(e.state.dpr),
      (this.coreRenderer.shadowMap.enabled = !0),
      (this.coreRenderer.shadowMap.type = 2),
      (this.coreRenderer.debug.checkShaderErrors = !1);
  }
  getContainerSize() {
    const { containerDom: t } = this.props;
    return [t.clientWidth, t.clientHeight];
  }
  createRendererContainer(t) {
    let e = t;
    if (("string" == typeof t && (e = document.getElementById(t)), e)) {
      const t = document.createElement("div");
      return (
        (t.style.cssText +=
          "\n      position: absolute;\n      z-index:2;\n      height: 100%;\n      width: 100%;\n      // pointer-events: none; // 事件释放，交互放到 gis-maps层\n      // pointer-events: none; // 事件拦截，交互放到 gis-core层\n    "),
        (t.id = "gis-scene"),
        t.classList.add("gis-scene"),
        e.appendChild(t),
        t
      );
    }
    return this.logService.error(`传入 containerDom ${t} 不合法`), null;
  }
  setSize(t, e) {
    this.coreRenderer.setSize(t, e),
      this.size.set(this.coreRenderer._width, this.coreRenderer._height),
      this.markerRenderer && this.markerRenderer.setSize(t, e),
      this.rtManager.updateSize(t, e);
  }
  getSize() {
    return this.size;
  }
  newRT() {
    return this.rtManager.get(this.size.x, this.size.y);
  }
  removeRT(t) {
    this.rtManager.remove(t);
  }
  register(t) {
    this.renderCb.unshift(t);
  }
  unregister(t) {
    this.renderCb.splice(this.renderCb.indexOf(t), 1);
  }
  renderAll() {
    this.renderCb.forEach((t) => t(this.coreRenderer));
  }
  toDataURL(t = "image/jpeg", e = 0.92) {
    this.renderAll();
    return this.coreRenderer.domElement.toDataURL(t, e);
  }
  destroy() {
    (this.renderCb = []),
      this.coreRenderer.renderLists.dispose(),
      this.coreRenderer.dispose(),
      this.coreRenderer.forceContextLoss(),
      (this.coreRenderer = null),
      this.rtManager.destroy();
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? SU(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && _U(e, i, o);
})([_G(KB.ILogService)], MU.prototype, "logService", 2);
const CU = new ln(16777215),
  wU = !1;
new ln("grey");
const AU = {
  axis: "z",
  speed: 0.01,
};
var EU, DU;
((DU = EU || (EU = {})).RUNNING = "running"), (DU.PAUSED = "paused");
class TU {
  constructor() {
    (this.status = EU.PAUSED), (this.state = AU);
  }
  set(t) {
    this.state = af(this.state, t);
  }
  start() {
    this.status = EU.RUNNING;
  }
  pause() {
    this.status = EU.PAUSED;
  }
}
var PU = Object.defineProperty,
  LU = Object.getOwnPropertyDescriptor;
class IU {
  constructor(t) {
    (this.props = t),
      (this.id = we()),
      (this.textureManager = Yd(this.textureService.getTextureManager)(
        this.id
      )),
      (this.state = t.config),
      this.__init(),
      (this.animation = new TU());
  }
  set(t) {
    return (this.state = af(this.state, t)), this.__updateScene(t), this;
  }
  get() {
    return this.state;
  }
  __init() {
    (this.coreScene = new Ka()),
      (this.hudScene = new Ka()),
      this.__updateScene(this.state);
  }
  __updateScene(t) {
    const { offsetX: e, offsetY: i, background: n } = t;
    if (null == n ? void 0 : n.transparent) this.coreScene.background = null;
    else {
      if (this.state.background.transparent) return;
      if (sf(n, "map"))
        if (lf(n.map)) {
          this.coreScene.background = null;
          const t = this.state.background.color;
          t && (this.coreScene.background = new ln(t));
        } else
          this.textureManager("map").setTexture(
            (t) => {
              this.textureManager("map").loader.load(n.map, (e) => {
                t(e);
              });
            },
            (t) => {
              (t.wrapS = Gt), (t.wrapT = Gt), (this.coreScene.background = t);
            }
          );
      else if (sf(n, "color")) {
        if (this.state.background.map)
          return void (this.state.background.color = n.color);
        lf(n.color)
          ? (this.coreScene.background = CU)
          : (this.textureManager("map").abort(),
            (this.coreScene.background = null),
            (this.coreScene.background = new ln(n.color)));
      }
    }
    cf(e) && this.coreScene.position.setX(e),
      cf(i) && this.coreScene.position.setY(i);
  }
  destroy() {
    this.coreScene.destroy(!1),
      (this.coreScene = null),
      this.textureService.removeTextureManager(this.id),
      this.hudScene.destroy(!1),
      (this.hudScene = null);
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? LU(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && PU(e, i, o);
})([_G(KB.ITextureService)], IU.prototype, "textureService", 2);
var NU = Object.defineProperty,
  RU = Object.getOwnPropertyDescriptor;
let OU = class {
  constructor() {
    (this.geo = {
      project: Qf,
      unproject: Zf,
      getResolution: Yf,
      zoomToDistance: Xf,
      distanceToZoom: qf,
    }),
      (this.__layers = new Map()),
      (this.BASE_MAP_Z = 0),
      (this.logService = bG.get(KB.ILogService)),
      (this.ee = new dt()),
      this.ee.on("updateArea", (t) => {
        for (const e of this.layers.values())
          for (const i of e.values()) i.updateArea(t);
      });
  }
  get layers() {
    return this.__layers;
  }
  get baseMapLayer() {
    var t;
    return null == (t = this.layers.get("base"))
      ? void 0
      : t.values().next().value;
  }
  add(t) {
    const { layerType: e, layer: i } = t,
      n = this.__layers.get(e);
    return (
      n ? n.set(i.id, i) : this.__layers.set(e, new Map([[i.id, i]])),
      i.ee.on("loaded", (t) => {
        this.ee.emit("loaded", t);
      }),
      i
    );
  }
  set(t) {
    const { layerID: e, layerType: i, props: n } = t;
    if (e || !i) {
      if (e)
        for (const [, r] of this.__layers.entries())
          for (const [t, i] of r.entries()) t === e && i.set(n);
    } else {
      const t = this.__layers.get(i);
      t
        ? t.forEach((t) => {
            t.set(n);
          })
        : this.logService.error(`传入${i} 无对应图层`);
    }
  }
  remove(t) {
    const { layerID: e, layerType: i } = t;
    if (e || !i) {
      if (e)
        for (const [n, r] of this.__layers.entries())
          for (const [t, i] of r.entries())
            if (t === e) return i.remove(), void this.__layers.get(n).delete(t);
    } else {
      const t = this.__layers.get(i);
      t
        ? (t.forEach((t) => {
            t.remove();
          }),
          this.__layers.delete(i))
        : this.logService.error(`传入${i} 无对应图层`);
    }
  }
  __removePure(t) {
    const { layerID: e, layerType: i } = t;
    if (i) {
      this.__layers.get(i)
        ? this.__layers.delete(i)
        : this.logService.error(`传入${i} 无对应图层`);
    } else
      for (const [n, r] of this.__layers.entries())
        for (const [t] of r.entries())
          if (t === e) return void this.__layers.get(n).delete(t);
  }
  get(t) {
    const { layerID: e, layerType: i } = t;
    if (!e && i) {
      const t = this.__layers.get(i);
      return t
        ? Array.from(t.values())
        : void this.logService.error(`传入${i} 无对应图层`);
    }
    if (e)
      for (const n of this.__layers.values())
        for (const [t, i] of n.entries()) if (t === e) return i;
  }
  updatePOI(t) {
    for (const e of this.layers.values())
      for (const i of e.values()) i._updatePOI(t);
  }
  destroy() {
    for (const t of this.__layers.values())
      for (const e of t.values()) e.remove();
    this.__layers.clear(), (this.BASE_MAP_Z = 0);
  }
  unproject(t) {
    return this.geo.project(t);
  }
  projectionLngLatRelative2Absolute(t) {
    return this.geo.unproject(t);
  }
};
OU = ((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? RU(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  return n && o && NU(e, i, o), o;
})([JB()], OU);
var FU,
  zU = {
    Linear: {
      None: function (t) {
        return t;
      },
    },
    Quadratic: {
      In: function (t) {
        return t * t;
      },
      Out: function (t) {
        return t * (2 - t);
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
      },
    },
    Cubic: {
      In: function (t) {
        return t * t * t;
      },
      Out: function (t) {
        return --t * t * t + 1;
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
      },
    },
    Quartic: {
      In: function (t) {
        return t * t * t * t;
      },
      Out: function (t) {
        return 1 - --t * t * t * t;
      },
      InOut: function (t) {
        return (t *= 2) < 1
          ? 0.5 * t * t * t * t
          : -0.5 * ((t -= 2) * t * t * t - 2);
      },
    },
    Quintic: {
      In: function (t) {
        return t * t * t * t * t;
      },
      Out: function (t) {
        return --t * t * t * t * t + 1;
      },
      InOut: function (t) {
        return (t *= 2) < 1
          ? 0.5 * t * t * t * t * t
          : 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
    },
    Sinusoidal: {
      In: function (t) {
        return 1 - Math.cos((t * Math.PI) / 2);
      },
      Out: function (t) {
        return Math.sin((t * Math.PI) / 2);
      },
      InOut: function (t) {
        return 0.5 * (1 - Math.cos(Math.PI * t));
      },
    },
    Exponential: {
      In: function (t) {
        return 0 === t ? 0 : Math.pow(1024, t - 1);
      },
      Out: function (t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
      },
      InOut: function (t) {
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (t *= 2) < 1
          ? 0.5 * Math.pow(1024, t - 1)
          : 0.5 * (2 - Math.pow(2, -10 * (t - 1)));
      },
    },
    Circular: {
      In: function (t) {
        return 1 - Math.sqrt(1 - t * t);
      },
      Out: function (t) {
        return Math.sqrt(1 - --t * t);
      },
      InOut: function (t) {
        return (t *= 2) < 1
          ? -0.5 * (Math.sqrt(1 - t * t) - 1)
          : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
    },
    Elastic: {
      In: function (t) {
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI);
      },
      Out: function (t) {
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : Math.pow(2, -10 * t) * Math.sin(5 * (t - 0.1) * Math.PI) + 1;
      },
      InOut: function (t) {
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (t *= 2) < 1
          ? -0.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
          : 0.5 *
              Math.pow(2, -10 * (t - 1)) *
              Math.sin(5 * (t - 1.1) * Math.PI) +
            1;
      },
    },
    Back: {
      In: function (t) {
        var e = 1.70158;
        return t * t * ((e + 1) * t - e);
      },
      Out: function (t) {
        var e = 1.70158;
        return --t * t * ((e + 1) * t + e) + 1;
      },
      InOut: function (t) {
        var e = 2.5949095;
        return (t *= 2) < 1
          ? t * t * ((e + 1) * t - e) * 0.5
          : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
      },
    },
    Bounce: {
      In: function (t) {
        return 1 - zU.Bounce.Out(1 - t);
      },
      Out: function (t) {
        return t < 1 / 2.75
          ? 7.5625 * t * t
          : t < 2 / 2.75
          ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
          : t < 2.5 / 2.75
          ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
          : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      InOut: function (t) {
        return t < 0.5
          ? 0.5 * zU.Bounce.In(2 * t)
          : 0.5 * zU.Bounce.Out(2 * t - 1) + 0.5;
      },
    },
  },
  kU =
    "undefined" == typeof self &&
    "undefined" != typeof process &&
    process.hrtime
      ? function () {
          var t = process.hrtime();
          return 1e3 * t[0] + t[1] / 1e6;
        }
      : "undefined" != typeof self &&
        void 0 !== self.performance &&
        void 0 !== self.performance.now
      ? self.performance.now.bind(self.performance)
      : void 0 !== Date.now
      ? Date.now
      : function () {
          return new Date().getTime();
        },
  BU = (function () {
    function t() {
      (this._tweens = {}), (this._tweensAddedDuringUpdate = {});
    }
    return (
      (t.prototype.getAll = function () {
        var t = this;
        return Object.keys(this._tweens).map(function (e) {
          return t._tweens[e];
        });
      }),
      (t.prototype.removeAll = function () {
        this._tweens = {};
      }),
      (t.prototype.add = function (t) {
        (this._tweens[t.getId()] = t),
          (this._tweensAddedDuringUpdate[t.getId()] = t);
      }),
      (t.prototype.remove = function (t) {
        delete this._tweens[t.getId()],
          delete this._tweensAddedDuringUpdate[t.getId()];
      }),
      (t.prototype.update = function (t, e) {
        void 0 === t && (t = kU()), void 0 === e && (e = !1);
        var i = Object.keys(this._tweens);
        if (0 === i.length) return !1;
        for (; i.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var n = 0; n < i.length; n++) {
            var r = this._tweens[i[n]],
              o = !e;
            r && !1 === r.update(t, o) && !e && delete this._tweens[i[n]];
          }
          i = Object.keys(this._tweensAddedDuringUpdate);
        }
        return !0;
      }),
      t
    );
  })(),
  GU = {
    Linear: function (t, e) {
      var i = t.length - 1,
        n = i * e,
        r = Math.floor(n),
        o = GU.Utils.Linear;
      return e < 0
        ? o(t[0], t[1], n)
        : e > 1
        ? o(t[i], t[i - 1], i - n)
        : o(t[r], t[r + 1 > i ? i : r + 1], n - r);
    },
    Bezier: function (t, e) {
      for (
        var i = 0,
          n = t.length - 1,
          r = Math.pow,
          o = GU.Utils.Bernstein,
          a = 0;
        a <= n;
        a++
      )
        i += r(1 - e, n - a) * r(e, a) * t[a] * o(n, a);
      return i;
    },
    CatmullRom: function (t, e) {
      var i = t.length - 1,
        n = i * e,
        r = Math.floor(n),
        o = GU.Utils.CatmullRom;
      return t[0] === t[i]
        ? (e < 0 && (r = Math.floor((n = i * (1 + e)))),
          o(t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i], n - r))
        : e < 0
        ? t[0] - (o(t[0], t[0], t[1], t[1], -n) - t[0])
        : e > 1
        ? t[i] - (o(t[i], t[i], t[i - 1], t[i - 1], n - i) - t[i])
        : o(
            t[r ? r - 1 : 0],
            t[r],
            t[i < r + 1 ? i : r + 1],
            t[i < r + 2 ? i : r + 2],
            n - r
          );
    },
    Utils: {
      Linear: function (t, e, i) {
        return (e - t) * i + t;
      },
      Bernstein: function (t, e) {
        var i = GU.Utils.Factorial;
        return i(t) / i(e) / i(t - e);
      },
      Factorial:
        ((FU = [1]),
        function (t) {
          var e = 1;
          if (FU[t]) return FU[t];
          for (var i = t; i > 1; i--) e *= i;
          return (FU[t] = e), e;
        }),
      CatmullRom: function (t, e, i, n, r) {
        var o = 0.5 * (i - t),
          a = 0.5 * (n - e),
          s = r * r;
        return (
          (2 * e - 2 * i + o + a) * (r * s) +
          (-3 * e + 3 * i - 2 * o - a) * s +
          o * r +
          e
        );
      },
    },
  },
  UU = (function () {
    function t() {}
    return (
      (t.nextId = function () {
        return t._nextId++;
      }),
      (t._nextId = 0),
      t
    );
  })(),
  jU = new BU(),
  HU = (function () {
    function t(t, e) {
      void 0 === e && (e = jU),
        (this._object = t),
        (this._group = e),
        (this._isPaused = !1),
        (this._pauseStart = 0),
        (this._valuesStart = {}),
        (this._valuesEnd = {}),
        (this._valuesStartRepeat = {}),
        (this._duration = 1e3),
        (this._initialRepeat = 0),
        (this._repeat = 0),
        (this._yoyo = !1),
        (this._isPlaying = !1),
        (this._reversed = !1),
        (this._delayTime = 0),
        (this._startTime = 0),
        (this._easingFunction = zU.Linear.None),
        (this._interpolationFunction = GU.Linear),
        (this._chainedTweens = []),
        (this._onStartCallbackFired = !1),
        (this._id = UU.nextId()),
        (this._isChainStopped = !1),
        (this._goToEnd = !1);
    }
    return (
      (t.prototype.getId = function () {
        return this._id;
      }),
      (t.prototype.isPlaying = function () {
        return this._isPlaying;
      }),
      (t.prototype.isPaused = function () {
        return this._isPaused;
      }),
      (t.prototype.to = function (t, e) {
        return (
          (this._valuesEnd = Object.create(t)),
          void 0 !== e && (this._duration = e),
          this
        );
      }),
      (t.prototype.duration = function (t) {
        return (this._duration = t), this;
      }),
      (t.prototype.start = function (t) {
        if (this._isPlaying) return this;
        if (
          (this._group && this._group.add(this),
          (this._repeat = this._initialRepeat),
          this._reversed)
        )
          for (var e in ((this._reversed = !1), this._valuesStartRepeat))
            this._swapEndStartRepeatValues(e),
              (this._valuesStart[e] = this._valuesStartRepeat[e]);
        return (
          (this._isPlaying = !0),
          (this._isPaused = !1),
          (this._onStartCallbackFired = !1),
          (this._isChainStopped = !1),
          (this._startTime =
            void 0 !== t
              ? "string" == typeof t
                ? kU() + parseFloat(t)
                : t
              : kU()),
          (this._startTime += this._delayTime),
          this._setupProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            this._valuesStartRepeat
          ),
          this
        );
      }),
      (t.prototype._setupProperties = function (t, e, i, n) {
        for (var r in i) {
          var o = t[r],
            a = Array.isArray(o),
            s = a ? "array" : typeof o,
            l = !a && Array.isArray(i[r]);
          if ("undefined" !== s && "function" !== s) {
            if (l) {
              var u = i[r];
              if (0 === u.length) continue;
              (u = u.map(this._handleRelativeValue.bind(this, o))),
                (i[r] = [o].concat(u));
            }
            if (("object" !== s && !a) || !o || l)
              void 0 === e[r] && (e[r] = o),
                a || (e[r] *= 1),
                (n[r] = l ? i[r].slice().reverse() : e[r] || 0);
            else {
              for (var c in ((e[r] = a ? [] : {}), o)) e[r][c] = o[c];
              (n[r] = a ? [] : {}), this._setupProperties(o, e[r], i[r], n[r]);
            }
          }
        }
      }),
      (t.prototype.stop = function () {
        return (
          this._isChainStopped ||
            ((this._isChainStopped = !0), this.stopChainedTweens()),
          this._isPlaying
            ? (this._group && this._group.remove(this),
              (this._isPlaying = !1),
              (this._isPaused = !1),
              this._onStopCallback && this._onStopCallback(this._object),
              this)
            : this
        );
      }),
      (t.prototype.end = function () {
        return (this._goToEnd = !0), this.update(1 / 0), this;
      }),
      (t.prototype.pause = function (t) {
        return (
          void 0 === t && (t = kU()),
          this._isPaused ||
            !this._isPlaying ||
            ((this._isPaused = !0),
            (this._pauseStart = t),
            this._group && this._group.remove(this)),
          this
        );
      }),
      (t.prototype.resume = function (t) {
        return (
          void 0 === t && (t = kU()),
          this._isPaused && this._isPlaying
            ? ((this._isPaused = !1),
              (this._startTime += t - this._pauseStart),
              (this._pauseStart = 0),
              this._group && this._group.add(this),
              this)
            : this
        );
      }),
      (t.prototype.stopChainedTweens = function () {
        for (var t = 0, e = this._chainedTweens.length; t < e; t++)
          this._chainedTweens[t].stop();
        return this;
      }),
      (t.prototype.group = function (t) {
        return (this._group = t), this;
      }),
      (t.prototype.delay = function (t) {
        return (this._delayTime = t), this;
      }),
      (t.prototype.repeat = function (t) {
        return (this._initialRepeat = t), (this._repeat = t), this;
      }),
      (t.prototype.repeatDelay = function (t) {
        return (this._repeatDelayTime = t), this;
      }),
      (t.prototype.yoyo = function (t) {
        return (this._yoyo = t), this;
      }),
      (t.prototype.easing = function (t) {
        return (this._easingFunction = t), this;
      }),
      (t.prototype.interpolation = function (t) {
        return (this._interpolationFunction = t), this;
      }),
      (t.prototype.chain = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return (this._chainedTweens = t), this;
      }),
      (t.prototype.onStart = function (t) {
        return (this._onStartCallback = t), this;
      }),
      (t.prototype.onUpdate = function (t) {
        return (this._onUpdateCallback = t), this;
      }),
      (t.prototype.onRepeat = function (t) {
        return (this._onRepeatCallback = t), this;
      }),
      (t.prototype.onComplete = function (t) {
        return (this._onCompleteCallback = t), this;
      }),
      (t.prototype.onStop = function (t) {
        return (this._onStopCallback = t), this;
      }),
      (t.prototype.update = function (t, e) {
        if (
          (void 0 === t && (t = kU()), void 0 === e && (e = !0), this._isPaused)
        )
          return !0;
        var i,
          n,
          r = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
          if (t > r) return !1;
          e && this.start(t);
        }
        if (((this._goToEnd = !1), t < this._startTime)) return !0;
        !1 === this._onStartCallbackFired &&
          (this._onStartCallback && this._onStartCallback(this._object),
          (this._onStartCallbackFired = !0)),
          (n = (t - this._startTime) / this._duration),
          (n = 0 === this._duration || n > 1 ? 1 : n);
        var o = this._easingFunction(n);
        if (
          (this._updateProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            o
          ),
          this._onUpdateCallback && this._onUpdateCallback(this._object, n),
          1 === n)
        ) {
          if (this._repeat > 0) {
            for (i in (isFinite(this._repeat) && this._repeat--,
            this._valuesStartRepeat))
              this._yoyo ||
                "string" != typeof this._valuesEnd[i] ||
                (this._valuesStartRepeat[i] =
                  this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])),
                this._yoyo && this._swapEndStartRepeatValues(i),
                (this._valuesStart[i] = this._valuesStartRepeat[i]);
            return (
              this._yoyo && (this._reversed = !this._reversed),
              void 0 !== this._repeatDelayTime
                ? (this._startTime = t + this._repeatDelayTime)
                : (this._startTime = t + this._delayTime),
              this._onRepeatCallback && this._onRepeatCallback(this._object),
              !0
            );
          }
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var a = 0, s = this._chainedTweens.length; a < s; a++)
            this._chainedTweens[a].start(this._startTime + this._duration);
          return (this._isPlaying = !1), !1;
        }
        return !0;
      }),
      (t.prototype._updateProperties = function (t, e, i, n) {
        for (var r in i)
          if (void 0 !== e[r]) {
            var o = e[r] || 0,
              a = i[r],
              s = Array.isArray(t[r]),
              l = Array.isArray(a);
            !s && l
              ? (t[r] = this._interpolationFunction(a, n))
              : "object" == typeof a && a
              ? this._updateProperties(t[r], o, a, n)
              : "number" == typeof (a = this._handleRelativeValue(o, a)) &&
                (t[r] = o + (a - o) * n);
          }
      }),
      (t.prototype._handleRelativeValue = function (t, e) {
        return "string" != typeof e
          ? e
          : "+" === e.charAt(0) || "-" === e.charAt(0)
          ? t + parseFloat(e)
          : parseFloat(e);
      }),
      (t.prototype._swapEndStartRepeatValues = function (t) {
        var e = this._valuesStartRepeat[t],
          i = this._valuesEnd[t];
        (this._valuesStartRepeat[t] =
          "string" == typeof i
            ? this._valuesStartRepeat[t] + parseFloat(i)
            : this._valuesEnd[t]),
          (this._valuesEnd[t] = e);
      }),
      t
    );
  })(),
  VU = jU,
  WU = VU.getAll.bind(VU),
  qU = VU.removeAll.bind(VU);
VU.add.bind(VU);
var YU,
  XU,
  QU = VU.remove.bind(VU),
  ZU = VU.update.bind(VU);
((XU = YU || (YU = {})).RUNNING = "running"), (XU.PAUSED = "paused");
class JU {
  constructor(t) {
    (this.props = t),
      (this.clock = new fE()),
      (this.tickTimes = 0),
      (this.__onVisibilityChange = () => {
        if (document[this.hiddenProperty]);
        else {
          const { layerManager: t } = this.props;
          t.updatePOI(!0);
        }
      }),
      this.hackRAFPause();
  }
  start() {
    this.status !== YU.RUNNING &&
      ((this.status = YU.RUNNING), this._autoTick());
  }
  pause() {
    this.tickID &&
      (window.cancelAnimationFrame(this.tickID), (this.tickID = null)),
      (this.status = YU.PAUSED);
  }
  _autoTick() {
    this.tick(),
      (this.tickID = window.requestAnimationFrame(() => {
        this._autoTick();
      }));
  }
  tick() {
    const { renderSystem: t, layerManager: e } = this.props;
    this.deltaTime = this.clock.getDelta();
    for (const i of e.layers.values())
      for (const t of i.values())
        t.animation.status === EU.RUNNING &&
          t.handleAnimation({
            tickTimes: this.tickTimes,
            deltaTime: this.deltaTime,
          });
    WU().length > 0 && ZU(), t.renderAll(), this.tickTimes++;
  }
  hackRAFPause() {
    (this.hiddenProperty =
      "hidden" in window.document
        ? "hidden"
        : "webkitHidden" in window.document
        ? "webkitHidden"
        : "mozHidden" in window.document
        ? "mozHidden"
        : null),
      (this.visibilityChangeEvent = this.hiddenProperty.replace(
        /hidden/i,
        "visibilitychange"
      )),
      document.addEventListener(
        this.visibilityChangeEvent,
        this.__onVisibilityChange,
        !1
      );
  }
  destroy() {
    this.pause(),
      this.clock.stop(),
      qU(),
      document.removeEventListener(
        this.visibilityChangeEvent,
        this.__onVisibilityChange,
        !1
      );
  }
}
class KU {
  constructor(t) {
    (this.props = t), this.__initAexs();
  }
  __initAexs() {
    const { length: t, sceneSystem: e } = this.props;
    (this.axisHelper = new KE(t)), e.coreScene.add(this.axisHelper);
  }
}
var $U,
  tj,
  ej = Object.defineProperty,
  ij = Object.getOwnPropertyDescriptor;
class nj {
  constructor(t) {
    (this.props = t), this.__initGrid();
  }
  __initGrid() {
    const { type: t, sceneSystem: e, config: i } = this.props;
    let n;
    switch (t) {
      case "polar":
        const r = 10,
          o = 16,
          a = 8;
        return (
          (n = 64),
          (this.gridHelper = new jE(r, o, a, n, 4473924, 8947848)),
          void e.coreScene.add(this.gridHelper)
        );
      case "cartesian":
        const { size: s } = i;
        n = i.divisions;
        const l = s * n,
          u = 12632256,
          c = 12632256;
        return (
          (this.gridHelper = new UE(l, n, u, c)),
          void e.coreScene.add(this.gridHelper)
        );
      default:
        return void this.logService.error(`输入 GridHelper ${t}无法解析`);
    }
  }
}
function rj(t, e) {
  return null == t || null == e
    ? NaN
    : t < e
    ? -1
    : t > e
    ? 1
    : t >= e
    ? 0
    : NaN;
}
function oj(t, e) {
  return null == t || null == e
    ? NaN
    : e < t
    ? -1
    : e > t
    ? 1
    : e >= t
    ? 0
    : NaN;
}
function aj(t) {
  let e, i, n;
  function r(t, n, r = 0, o = t.length) {
    if (r < o) {
      if (0 !== e(n, n)) return o;
      do {
        const e = (r + o) >>> 1;
        i(t[e], n) < 0 ? (r = e + 1) : (o = e);
      } while (r < o);
    }
    return r;
  }
  return (
    2 !== t.length
      ? ((e = rj), (i = (e, i) => rj(t(e), i)), (n = (e, i) => t(e) - i))
      : ((e = t === rj || t === oj ? t : sj), (i = t), (n = t)),
    {
      left: r,
      center: function (t, e, i = 0, o = t.length) {
        const a = r(t, e, i, o - 1);
        return a > i && n(t[a - 1], e) > -n(t[a], e) ? a - 1 : a;
      },
      right: function (t, n, r = 0, o = t.length) {
        if (r < o) {
          if (0 !== e(n, n)) return o;
          do {
            const e = (r + o) >>> 1;
            i(t[e], n) <= 0 ? (r = e + 1) : (o = e);
          } while (r < o);
        }
        return r;
      },
    }
  );
}
function sj() {
  return 0;
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? ij(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && ej(e, i, o);
})([_G(KB.ILogService)], nj.prototype, "logService", 2),
  ((tj = $U || ($U = {})).CONSTANT = "constant"),
  (tj.LINEAR = "linear"),
  (tj.THRESHOLD = "threshold"),
  (tj.ORDINAL = "ordinal"),
  (tj.CUSTOM = "custom"),
  (tj.CONDITIONAL = "conditional");
const lj = aj(rj).right;
aj(function (t) {
  return null === t ? NaN : +t;
}).center;
var uj = lj;
class cj extends Map {
  constructor(t, e = pj) {
    if (
      (super(),
      Object.defineProperties(this, {
        _intern: {
          value: new Map(),
        },
        _key: {
          value: e,
        },
      }),
      null != t)
    )
      for (const [i, n] of t) this.set(i, n);
  }
  get(t) {
    return super.get(hj(this, t));
  }
  has(t) {
    return super.has(hj(this, t));
  }
  set(t, e) {
    return super.set(
      (function ({ _intern: t, _key: e }, i) {
        const n = e(i);
        return t.has(n) ? t.get(n) : (t.set(n, i), i);
      })(this, t),
      e
    );
  }
  delete(t) {
    return super.delete(
      (function ({ _intern: t, _key: e }, i) {
        const n = e(i);
        t.has(n) && ((i = t.get(n)), t.delete(n));
        return i;
      })(this, t)
    );
  }
}
function hj({ _intern: t, _key: e }, i) {
  const n = e(i);
  return t.has(n) ? t.get(n) : i;
}
function pj(t) {
  return null !== t && "object" == typeof t ? t.valueOf() : t;
}
var dj = Math.sqrt(50),
  fj = Math.sqrt(10),
  gj = Math.sqrt(2);
function mj(t, e, i) {
  var n = (e - t) / Math.max(0, i),
    r = Math.floor(Math.log(n) / Math.LN10),
    o = n / Math.pow(10, r);
  return r >= 0
    ? (o >= dj ? 10 : o >= fj ? 5 : o >= gj ? 2 : 1) * Math.pow(10, r)
    : -Math.pow(10, -r) / (o >= dj ? 10 : o >= fj ? 5 : o >= gj ? 2 : 1);
}
function yj(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
  }
  return this;
}
const vj = Symbol("implicit");
function bj(t, e, i) {
  (t.prototype = e.prototype = i), (i.constructor = t);
}
function xj(t, e) {
  var i = Object.create(t.prototype);
  for (var n in e) i[n] = e[n];
  return i;
}
function _j() {}
var Sj = 0.7,
  Mj = 1 / Sj,
  Cj = "\\s*([+-]?\\d+)\\s*",
  wj = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  Aj = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  Ej = /^#([0-9a-f]{3,8})$/,
  Dj = new RegExp(`^rgb\\(${Cj},${Cj},${Cj}\\)$`),
  Tj = new RegExp(`^rgb\\(${Aj},${Aj},${Aj}\\)$`),
  Pj = new RegExp(`^rgba\\(${Cj},${Cj},${Cj},${wj}\\)$`),
  Lj = new RegExp(`^rgba\\(${Aj},${Aj},${Aj},${wj}\\)$`),
  Ij = new RegExp(`^hsl\\(${wj},${Aj},${Aj}\\)$`),
  Nj = new RegExp(`^hsla\\(${wj},${Aj},${Aj},${wj}\\)$`),
  Rj = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  };
function Oj() {
  return this.rgb().formatHex();
}
function Fj() {
  return this.rgb().formatRgb();
}
function zj(t) {
  var e, i;
  return (
    (t = (t + "").trim().toLowerCase()),
    (e = Ej.exec(t))
      ? ((i = e[1].length),
        (e = parseInt(e[1], 16)),
        6 === i
          ? kj(e)
          : 3 === i
          ? new Uj(
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (240 & e),
              ((15 & e) << 4) | (15 & e),
              1
            )
          : 8 === i
          ? Bj(
              (e >> 24) & 255,
              (e >> 16) & 255,
              (e >> 8) & 255,
              (255 & e) / 255
            )
          : 4 === i
          ? Bj(
              ((e >> 12) & 15) | ((e >> 8) & 240),
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (240 & e),
              (((15 & e) << 4) | (15 & e)) / 255
            )
          : null)
      : (e = Dj.exec(t))
      ? new Uj(e[1], e[2], e[3], 1)
      : (e = Tj.exec(t))
      ? new Uj((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, 1)
      : (e = Pj.exec(t))
      ? Bj(e[1], e[2], e[3], e[4])
      : (e = Lj.exec(t))
      ? Bj((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, e[4])
      : (e = Ij.exec(t))
      ? Yj(e[1], e[2] / 100, e[3] / 100, 1)
      : (e = Nj.exec(t))
      ? Yj(e[1], e[2] / 100, e[3] / 100, e[4])
      : Rj.hasOwnProperty(t)
      ? kj(Rj[t])
      : "transparent" === t
      ? new Uj(NaN, NaN, NaN, 0)
      : null
  );
}
function kj(t) {
  return new Uj((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
}
function Bj(t, e, i, n) {
  return n <= 0 && (t = e = i = NaN), new Uj(t, e, i, n);
}
function Gj(t, e, i, n) {
  return 1 === arguments.length
    ? ((r = t) instanceof _j || (r = zj(r)),
      r ? new Uj((r = r.rgb()).r, r.g, r.b, r.opacity) : new Uj())
    : new Uj(t, e, i, null == n ? 1 : n);
  var r;
}
function Uj(t, e, i, n) {
  (this.r = +t), (this.g = +e), (this.b = +i), (this.opacity = +n);
}
function jj() {
  return `#${qj(this.r)}${qj(this.g)}${qj(this.b)}`;
}
function Hj() {
  const t = Vj(this.opacity);
  return `${1 === t ? "rgb(" : "rgba("}${Wj(this.r)}, ${Wj(this.g)}, ${Wj(
    this.b
  )}${1 === t ? ")" : `, ${t})`}`;
}
function Vj(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function Wj(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function qj(t) {
  return ((t = Wj(t)) < 16 ? "0" : "") + t.toString(16);
}
function Yj(t, e, i, n) {
  return (
    n <= 0
      ? (t = e = i = NaN)
      : i <= 0 || i >= 1
      ? (t = e = NaN)
      : e <= 0 && (t = NaN),
    new Qj(t, e, i, n)
  );
}
function Xj(t) {
  if (t instanceof Qj) return new Qj(t.h, t.s, t.l, t.opacity);
  if ((t instanceof _j || (t = zj(t)), !t)) return new Qj();
  if (t instanceof Qj) return t;
  var e = (t = t.rgb()).r / 255,
    i = t.g / 255,
    n = t.b / 255,
    r = Math.min(e, i, n),
    o = Math.max(e, i, n),
    a = NaN,
    s = o - r,
    l = (o + r) / 2;
  return (
    s
      ? ((a =
          e === o
            ? (i - n) / s + 6 * (i < n)
            : i === o
            ? (n - e) / s + 2
            : (e - i) / s + 4),
        (s /= l < 0.5 ? o + r : 2 - o - r),
        (a *= 60))
      : (s = l > 0 && l < 1 ? 0 : a),
    new Qj(a, s, l, t.opacity)
  );
}
function Qj(t, e, i, n) {
  (this.h = +t), (this.s = +e), (this.l = +i), (this.opacity = +n);
}
function Zj(t) {
  return (t = (t || 0) % 360) < 0 ? t + 360 : t;
}
function Jj(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function Kj(t, e, i) {
  return (
    255 *
    (t < 60
      ? e + ((i - e) * t) / 60
      : t < 180
      ? i
      : t < 240
      ? e + ((i - e) * (240 - t)) / 60
      : e)
  );
}
bj(_j, zj, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Oj,
  formatHex: Oj,
  formatHex8: function () {
    return this.rgb().formatHex8();
  },
  formatHsl: function () {
    return Xj(this).formatHsl();
  },
  formatRgb: Fj,
  toString: Fj,
}),
  bj(
    Uj,
    Gj,
    xj(_j, {
      brighter(t) {
        return (
          (t = null == t ? Mj : Math.pow(Mj, t)),
          new Uj(this.r * t, this.g * t, this.b * t, this.opacity)
        );
      },
      darker(t) {
        return (
          (t = null == t ? Sj : Math.pow(Sj, t)),
          new Uj(this.r * t, this.g * t, this.b * t, this.opacity)
        );
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Uj(Wj(this.r), Wj(this.g), Wj(this.b), Vj(this.opacity));
      },
      displayable() {
        return (
          -0.5 <= this.r &&
          this.r < 255.5 &&
          -0.5 <= this.g &&
          this.g < 255.5 &&
          -0.5 <= this.b &&
          this.b < 255.5 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      hex: jj,
      formatHex: jj,
      formatHex8: function () {
        return `#${qj(this.r)}${qj(this.g)}${qj(this.b)}${qj(
          255 * (isNaN(this.opacity) ? 1 : this.opacity)
        )}`;
      },
      formatRgb: Hj,
      toString: Hj,
    })
  ),
  bj(
    Qj,
    function (t, e, i, n) {
      return 1 === arguments.length
        ? Xj(t)
        : new Qj(t, e, i, null == n ? 1 : n);
    },
    xj(_j, {
      brighter(t) {
        return (
          (t = null == t ? Mj : Math.pow(Mj, t)),
          new Qj(this.h, this.s, this.l * t, this.opacity)
        );
      },
      darker(t) {
        return (
          (t = null == t ? Sj : Math.pow(Sj, t)),
          new Qj(this.h, this.s, this.l * t, this.opacity)
        );
      },
      rgb() {
        var t = (this.h % 360) + 360 * (this.h < 0),
          e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
          i = this.l,
          n = i + (i < 0.5 ? i : 1 - i) * e,
          r = 2 * i - n;
        return new Uj(
          Kj(t >= 240 ? t - 240 : t + 120, r, n),
          Kj(t, r, n),
          Kj(t < 120 ? t + 240 : t - 120, r, n),
          this.opacity
        );
      },
      clamp() {
        return new Qj(Zj(this.h), Jj(this.s), Jj(this.l), Vj(this.opacity));
      },
      displayable() {
        return (
          ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
          0 <= this.l &&
          this.l <= 1 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      formatHsl() {
        const t = Vj(this.opacity);
        return `${1 === t ? "hsl(" : "hsla("}${Zj(this.h)}, ${
          100 * Jj(this.s)
        }%, ${100 * Jj(this.l)}%${1 === t ? ")" : `, ${t})`}`;
      },
    })
  );
var $j = (t) => () => t;
function tH(t) {
  return 1 == (t = +t)
    ? eH
    : function (e, i) {
        return i - e
          ? (function (t, e, i) {
              return (
                (t = Math.pow(t, i)),
                (e = Math.pow(e, i) - t),
                (i = 1 / i),
                function (n) {
                  return Math.pow(t + n * e, i);
                }
              );
            })(e, i, t)
          : $j(isNaN(e) ? i : e);
      };
}
function eH(t, e) {
  var i = e - t;
  return i
    ? (function (t, e) {
        return function (i) {
          return t + i * e;
        };
      })(t, i)
    : $j(isNaN(t) ? e : t);
}
var iH = (function t(e) {
  var i = tH(e);
  function n(t, e) {
    var n = i((t = Gj(t)).r, (e = Gj(e)).r),
      r = i(t.g, e.g),
      o = i(t.b, e.b),
      a = eH(t.opacity, e.opacity);
    return function (e) {
      return (
        (t.r = n(e)), (t.g = r(e)), (t.b = o(e)), (t.opacity = a(e)), t + ""
      );
    };
  }
  return (n.gamma = t), n;
})(1);
function nH(t, e) {
  e || (e = []);
  var i,
    n = t ? Math.min(e.length, t.length) : 0,
    r = e.slice();
  return function (o) {
    for (i = 0; i < n; ++i) r[i] = t[i] * (1 - o) + e[i] * o;
    return r;
  };
}
function rH(t, e) {
  var i,
    n = e ? e.length : 0,
    r = t ? Math.min(n, t.length) : 0,
    o = new Array(r),
    a = new Array(n);
  for (i = 0; i < r; ++i) o[i] = hH(t[i], e[i]);
  for (; i < n; ++i) a[i] = e[i];
  return function (t) {
    for (i = 0; i < r; ++i) a[i] = o[i](t);
    return a;
  };
}
function oH(t, e) {
  var i = new Date();
  return (
    (t = +t),
    (e = +e),
    function (n) {
      return i.setTime(t * (1 - n) + e * n), i;
    }
  );
}
function aH(t, e) {
  return (
    (t = +t),
    (e = +e),
    function (i) {
      return t * (1 - i) + e * i;
    }
  );
}
function sH(t, e) {
  var i,
    n = {},
    r = {};
  for (i in ((null !== t && "object" == typeof t) || (t = {}),
  (null !== e && "object" == typeof e) || (e = {}),
  e))
    i in t ? (n[i] = hH(t[i], e[i])) : (r[i] = e[i]);
  return function (t) {
    for (i in n) r[i] = n[i](t);
    return r;
  };
}
var lH = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  uH = new RegExp(lH.source, "g");
function cH(t, e) {
  var i,
    n,
    r,
    o = (lH.lastIndex = uH.lastIndex = 0),
    a = -1,
    s = [],
    l = [];
  for (t += "", e += ""; (i = lH.exec(t)) && (n = uH.exec(e)); )
    (r = n.index) > o &&
      ((r = e.slice(o, r)), s[a] ? (s[a] += r) : (s[++a] = r)),
      (i = i[0]) === (n = n[0])
        ? s[a]
          ? (s[a] += n)
          : (s[++a] = n)
        : ((s[++a] = null),
          l.push({
            i: a,
            x: aH(i, n),
          })),
      (o = uH.lastIndex);
  return (
    o < e.length && ((r = e.slice(o)), s[a] ? (s[a] += r) : (s[++a] = r)),
    s.length < 2
      ? l[0]
        ? (function (t) {
            return function (e) {
              return t(e) + "";
            };
          })(l[0].x)
        : (function (t) {
            return function () {
              return t;
            };
          })(e)
      : ((e = l.length),
        function (t) {
          for (var i, n = 0; n < e; ++n) s[(i = l[n]).i] = i.x(t);
          return s.join("");
        })
  );
}
function hH(t, e) {
  var i,
    n,
    r = typeof e;
  return null == e || "boolean" === r
    ? $j(e)
    : ("number" === r
        ? aH
        : "string" === r
        ? (i = zj(e))
          ? ((e = i), iH)
          : cH
        : e instanceof zj
        ? iH
        : e instanceof Date
        ? oH
        : ((n = e),
          !ArrayBuffer.isView(n) || n instanceof DataView
            ? Array.isArray(e)
              ? rH
              : ("function" != typeof e.valueOf &&
                  "function" != typeof e.toString) ||
                isNaN(e)
              ? sH
              : aH
            : nH))(t, e);
}
function pH(t, e) {
  return (
    (t = +t),
    (e = +e),
    function (i) {
      return Math.round(t * (1 - i) + e * i);
    }
  );
}
function dH(t) {
  return +t;
}
var fH = [0, 1];
function gH(t) {
  return t;
}
function mH(t, e) {
  return (e -= t = +t)
    ? function (i) {
        return (i - t) / e;
      }
    : ((i = isNaN(e) ? NaN : 0.5),
      function () {
        return i;
      });
  var i;
}
function yH(t, e, i) {
  var n = t[0],
    r = t[1],
    o = e[0],
    a = e[1];
  return (
    r < n ? ((n = mH(r, n)), (o = i(a, o))) : ((n = mH(n, r)), (o = i(o, a))),
    function (t) {
      return o(n(t));
    }
  );
}
function vH(t, e, i) {
  var n = Math.min(t.length, e.length) - 1,
    r = new Array(n),
    o = new Array(n),
    a = -1;
  for (
    t[n] < t[0] && ((t = t.slice().reverse()), (e = e.slice().reverse()));
    ++a < n;

  )
    (r[a] = mH(t[a], t[a + 1])), (o[a] = i(e[a], e[a + 1]));
  return function (e) {
    var i = uj(t, e, 1, n) - 1;
    return o[i](r[i](e));
  };
}
function bH() {
  var t,
    e,
    i,
    n,
    r,
    o,
    a = fH,
    s = fH,
    l = hH,
    u = gH;
  function c() {
    var t = Math.min(a.length, s.length);
    return (
      u !== gH &&
        (u = (function (t, e) {
          var i;
          return (
            t > e && ((i = t), (t = e), (e = i)),
            function (i) {
              return Math.max(t, Math.min(e, i));
            }
          );
        })(a[0], a[t - 1])),
      (n = t > 2 ? vH : yH),
      (r = o = null),
      h
    );
  }
  function h(e) {
    return null == e || isNaN((e = +e))
      ? i
      : (r || (r = n(a.map(t), s, l)))(t(u(e)));
  }
  return (
    (h.invert = function (i) {
      return u(e((o || (o = n(s, a.map(t), aH)))(i)));
    }),
    (h.domain = function (t) {
      return arguments.length ? ((a = Array.from(t, dH)), c()) : a.slice();
    }),
    (h.range = function (t) {
      return arguments.length ? ((s = Array.from(t)), c()) : s.slice();
    }),
    (h.rangeRound = function (t) {
      return (s = Array.from(t)), (l = pH), c();
    }),
    (h.clamp = function (t) {
      return arguments.length ? ((u = !!t || gH), c()) : u !== gH;
    }),
    (h.interpolate = function (t) {
      return arguments.length ? ((l = t), c()) : l;
    }),
    (h.unknown = function (t) {
      return arguments.length ? ((i = t), h) : i;
    }),
    function (i, n) {
      return (t = i), (e = n), c();
    }
  );
}
function xH(t, e) {
  if (
    (i = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0
  )
    return null;
  var i,
    n = t.slice(0, i);
  return [n.length > 1 ? n[0] + n.slice(2) : n, +t.slice(i + 1)];
}
function _H(t) {
  return (t = xH(Math.abs(t))) ? t[1] : NaN;
}
var SH,
  MH =
    /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function CH(t) {
  if (!(e = MH.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new wH({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10],
  });
}
function wH(t) {
  (this.fill = void 0 === t.fill ? " " : t.fill + ""),
    (this.align = void 0 === t.align ? ">" : t.align + ""),
    (this.sign = void 0 === t.sign ? "-" : t.sign + ""),
    (this.symbol = void 0 === t.symbol ? "" : t.symbol + ""),
    (this.zero = !!t.zero),
    (this.width = void 0 === t.width ? void 0 : +t.width),
    (this.comma = !!t.comma),
    (this.precision = void 0 === t.precision ? void 0 : +t.precision),
    (this.trim = !!t.trim),
    (this.type = void 0 === t.type ? "" : t.type + "");
}
function AH(t, e) {
  var i = xH(t, e);
  if (!i) return t + "";
  var n = i[0],
    r = i[1];
  return r < 0
    ? "0." + new Array(-r).join("0") + n
    : n.length > r + 1
    ? n.slice(0, r + 1) + "." + n.slice(r + 1)
    : n + new Array(r - n.length + 2).join("0");
}
(CH.prototype = wH.prototype),
  (wH.prototype.toString = function () {
    return (
      this.fill +
      this.align +
      this.sign +
      this.symbol +
      (this.zero ? "0" : "") +
      (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) +
      (this.comma ? "," : "") +
      (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) +
      (this.trim ? "~" : "") +
      this.type
    );
  });
var EH = {
  "%": (t, e) => (100 * t).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: function (t) {
    return Math.abs((t = Math.round(t))) >= 1e21
      ? t.toLocaleString("en").replace(/,/g, "")
      : t.toString(10);
  },
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => AH(100 * t, e),
  r: AH,
  s: function (t, e) {
    var i = xH(t, e);
    if (!i) return t + "";
    var n = i[0],
      r = i[1],
      o = r - (SH = 3 * Math.max(-8, Math.min(8, Math.floor(r / 3)))) + 1,
      a = n.length;
    return o === a
      ? n
      : o > a
      ? n + new Array(o - a + 1).join("0")
      : o > 0
      ? n.slice(0, o) + "." + n.slice(o)
      : "0." + new Array(1 - o).join("0") + xH(t, Math.max(0, e + o - 1))[0];
  },
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16),
};
function DH(t) {
  return t;
}
var TH,
  PH,
  LH,
  IH,
  NH,
  RH,
  OH,
  FH = Array.prototype.map,
  zH = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "µ",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y",
  ];
function kH(t) {
  var e,
    i,
    n =
      void 0 === t.grouping || void 0 === t.thousands
        ? DH
        : ((e = FH.call(t.grouping, Number)),
          (i = t.thousands + ""),
          function (t, n) {
            for (
              var r = t.length, o = [], a = 0, s = e[0], l = 0;
              r > 0 &&
              s > 0 &&
              (l + s + 1 > n && (s = Math.max(1, n - l)),
              o.push(t.substring((r -= s), r + s)),
              !((l += s + 1) > n));

            )
              s = e[(a = (a + 1) % e.length)];
            return o.reverse().join(i);
          }),
    r = void 0 === t.currency ? "" : t.currency[0] + "",
    o = void 0 === t.currency ? "" : t.currency[1] + "",
    a = void 0 === t.decimal ? "." : t.decimal + "",
    s =
      void 0 === t.numerals
        ? DH
        : (function (t) {
            return function (e) {
              return e.replace(/[0-9]/g, function (e) {
                return t[+e];
              });
            };
          })(FH.call(t.numerals, String)),
    l = void 0 === t.percent ? "%" : t.percent + "",
    u = void 0 === t.minus ? "−" : t.minus + "",
    c = void 0 === t.nan ? "NaN" : t.nan + "";
  function h(t) {
    var e = (t = CH(t)).fill,
      i = t.align,
      h = t.sign,
      p = t.symbol,
      d = t.zero,
      f = t.width,
      g = t.comma,
      m = t.precision,
      y = t.trim,
      v = t.type;
    "n" === v
      ? ((g = !0), (v = "g"))
      : EH[v] || (void 0 === m && (m = 12), (y = !0), (v = "g")),
      (d || ("0" === e && "=" === i)) && ((d = !0), (e = "0"), (i = "="));
    var b =
        "$" === p
          ? r
          : "#" === p && /[boxX]/.test(v)
          ? "0" + v.toLowerCase()
          : "",
      x = "$" === p ? o : /[%p]/.test(v) ? l : "",
      _ = EH[v],
      S = /[defgprs%]/.test(v);
    function M(t) {
      var r,
        o,
        l,
        p = b,
        M = x;
      if ("c" === v) (M = _(t) + M), (t = "");
      else {
        var C = (t = +t) < 0 || 1 / t < 0;
        if (
          ((t = isNaN(t) ? c : _(Math.abs(t), m)),
          y &&
            (t = (function (t) {
              t: for (var e, i = t.length, n = 1, r = -1; n < i; ++n)
                switch (t[n]) {
                  case ".":
                    r = e = n;
                    break;
                  case "0":
                    0 === r && (r = n), (e = n);
                    break;
                  default:
                    if (!+t[n]) break t;
                    r > 0 && (r = 0);
                }
              return r > 0 ? t.slice(0, r) + t.slice(e + 1) : t;
            })(t)),
          C && 0 == +t && "+" !== h && (C = !1),
          (p = (C ? ("(" === h ? h : u) : "-" === h || "(" === h ? "" : h) + p),
          (M =
            ("s" === v ? zH[8 + SH / 3] : "") +
            M +
            (C && "(" === h ? ")" : "")),
          S)
        )
          for (r = -1, o = t.length; ++r < o; )
            if (48 > (l = t.charCodeAt(r)) || l > 57) {
              (M = (46 === l ? a + t.slice(r + 1) : t.slice(r)) + M),
                (t = t.slice(0, r));
              break;
            }
      }
      g && !d && (t = n(t, 1 / 0));
      var w = p.length + t.length + M.length,
        A = w < f ? new Array(f - w + 1).join(e) : "";
      switch (
        (g && d && ((t = n(A + t, A.length ? f - M.length : 1 / 0)), (A = "")),
        i)
      ) {
        case "<":
          t = p + t + M + A;
          break;
        case "=":
          t = p + A + t + M;
          break;
        case "^":
          t = A.slice(0, (w = A.length >> 1)) + p + t + M + A.slice(w);
          break;
        default:
          t = A + p + t + M;
      }
      return s(t);
    }
    return (
      (m =
        void 0 === m
          ? 6
          : /[gprs]/.test(v)
          ? Math.max(1, Math.min(21, m))
          : Math.max(0, Math.min(20, m))),
      (M.toString = function () {
        return t + "";
      }),
      M
    );
  }
  return {
    format: h,
    formatPrefix: function (t, e) {
      var i = h((((t = CH(t)).type = "f"), t)),
        n = 3 * Math.max(-8, Math.min(8, Math.floor(_H(e) / 3))),
        r = Math.pow(10, -n),
        o = zH[8 + n / 3];
      return function (t) {
        return i(r * t) + o;
      };
    },
  };
}
function BH(t, e, i, n) {
  var r,
    o = (function (t, e, i) {
      var n = Math.abs(e - t) / Math.max(0, i),
        r = Math.pow(10, Math.floor(Math.log(n) / Math.LN10)),
        o = n / r;
      return (
        o >= dj ? (r *= 10) : o >= fj ? (r *= 5) : o >= gj && (r *= 2),
        e < t ? -r : r
      );
    })(t, e, i);
  switch ((n = CH(null == n ? ",f" : n)).type) {
    case "s":
      var a = Math.max(Math.abs(t), Math.abs(e));
      return (
        null != n.precision ||
          isNaN(
            (r = (function (t, e) {
              return Math.max(
                0,
                3 * Math.max(-8, Math.min(8, Math.floor(_H(e) / 3))) -
                  _H(Math.abs(t))
              );
            })(o, a))
          ) ||
          (n.precision = r),
        LH(n, a)
      );
    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      null != n.precision ||
        isNaN(
          (r = (function (t, e) {
            return (
              (t = Math.abs(t)),
              (e = Math.abs(e) - t),
              Math.max(0, _H(e) - _H(t)) + 1
            );
          })(o, Math.max(Math.abs(t), Math.abs(e))))
        ) ||
        (n.precision = r - ("e" === n.type));
      break;
    case "f":
    case "%":
      null != n.precision ||
        isNaN(
          (r = (function (t) {
            return Math.max(0, -_H(Math.abs(t)));
          })(o))
        ) ||
        (n.precision = r - 2 * ("%" === n.type));
  }
  return PH(n);
}
function GH(t) {
  var e = t.domain;
  return (
    (t.ticks = function (t) {
      var i = e();
      return (function (t, e, i) {
        var n,
          r,
          o,
          a,
          s = -1;
        if (((i = +i), (t = +t) == (e = +e) && i > 0)) return [t];
        if (
          ((n = e < t) && ((r = t), (t = e), (e = r)),
          0 === (a = mj(t, e, i)) || !isFinite(a))
        )
          return [];
        if (a > 0) {
          let i = Math.round(t / a),
            n = Math.round(e / a);
          for (
            i * a < t && ++i, n * a > e && --n, o = new Array((r = n - i + 1));
            ++s < r;

          )
            o[s] = (i + s) * a;
        } else {
          a = -a;
          let i = Math.round(t * a),
            n = Math.round(e * a);
          for (
            i / a < t && ++i, n / a > e && --n, o = new Array((r = n - i + 1));
            ++s < r;

          )
            o[s] = (i + s) / a;
        }
        return n && o.reverse(), o;
      })(i[0], i[i.length - 1], null == t ? 10 : t);
    }),
    (t.tickFormat = function (t, i) {
      var n = e();
      return BH(n[0], n[n.length - 1], null == t ? 10 : t, i);
    }),
    (t.nice = function (i) {
      null == i && (i = 10);
      var n,
        r,
        o = e(),
        a = 0,
        s = o.length - 1,
        l = o[a],
        u = o[s],
        c = 10;
      for (
        u < l && ((r = l), (l = u), (u = r), (r = a), (a = s), (s = r));
        c-- > 0;

      ) {
        if ((r = mj(l, u, i)) === n) return (o[a] = l), (o[s] = u), e(o);
        if (r > 0) (l = Math.floor(l / r) * r), (u = Math.ceil(u / r) * r);
        else {
          if (!(r < 0)) break;
          (l = Math.ceil(l * r) / r), (u = Math.floor(u * r) / r);
        }
        n = r;
      }
      return t;
    }),
    t
  );
}
(TH = kH({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
})),
  (PH = TH.format),
  (LH = TH.formatPrefix),
  ((NH = IH || (IH = {})).Greater = ">"),
  (NH.Less = "<"),
  (NH.GreaterEqual = ">="),
  (NH.LessEqual = "<="),
  (NH.Equal = "=="),
  (NH.NotEqual = "!="),
  (NH.Contain = "Contain"),
  (NH.NotContain = "NotContain"),
  (NH.StartWith = "StartWith"),
  (NH.EndWith = "EndWith"),
  ((OH = RH || (RH = {})).Value = "value"),
  (OH.Field = "field");
const UH = (t, e, i) => {
  var n, r, o, a;
  for (const s of e) {
    const e = s.type === RH.Field ? (null == i ? void 0 : i[s.value]) : s.value;
    if (!s.op || void 0 === e) return !0;
    switch (s.op) {
      case IH.Equal:
        if (t != e) return !1;
        break;
      case IH.Greater:
        if (!(t > e)) return !1;
        break;
      case IH.GreaterEqual:
        if (!(t >= e)) return !1;
        break;
      case IH.Less:
        if (!(t < e)) return !1;
        break;
      case IH.LessEqual:
        if (!(t <= e)) return !1;
        break;
      case IH.NotEqual:
        if (t == e) return !1;
        break;
      case IH.Contain:
        if (
          !(null == (n = null == t ? void 0 : t.includes)
            ? void 0
            : n.call(t, e))
        )
          return !1;
        break;
      case IH.NotContain:
        if (
          null == (r = null == t ? void 0 : t.includes) ? void 0 : r.call(t, e)
        )
          return !1;
        break;
      case IH.StartWith:
        if (
          !(null == (o = null == t ? void 0 : t.startsWith)
            ? void 0
            : o.call(t, e))
        )
          return !1;
        break;
      case IH.EndWith:
        if (
          !(null == (a = null == t ? void 0 : t.endsWith)
            ? void 0
            : a.call(t, e))
        )
          return !1;
        break;
      default:
        return !1;
    }
  }
  return !0;
};
const jH = class {
  static apply(t, e) {
    const i = [];
    return hf(e)
      ? []
      : (t.forEach((t) => {
          const { visual: n, scaleField: r } = t;
          let o;
          if (n) {
            const { type: t } = n,
              i = n[t];
            let a = [];
            switch (t) {
              case $U.CONSTANT:
                o = () => i;
                break;
              case $U.LINEAR:
                if (hf(i.domain)) {
                  const t = jH.preProcessData(e, r),
                    [n, o] = [t[0][r], t[t.length - 1][r]];
                  a.push(n);
                  const s = i.range.length - 1;
                  for (let e = 1; e < s; e++)
                    a.push(t[Math.floor(t.length / s) * e][r]);
                  a.push(o);
                } else a = i.domain;
                o = jH._getScale(t).domain(a).range(i.range).clamp(i.clamp);
                break;
              case $U.THRESHOLD:
                if (hf(i.domain)) {
                  const t = jH.preProcessData(e, r),
                    n = i.range.length;
                  for (let e = 1; e < n; e++)
                    a.push(t[Math.floor(t.length / n) * e][r]);
                } else a = i.domain;
                o = jH._getScale(t).domain(a).range(i.range);
                break;
              case $U.ORDINAL:
                (o = jH._getScale(t).domain(i.domain).range(i.range)),
                  i.unknown &&
                    ("undefined" === i.unknown
                      ? (o = o.unknown(void 0))
                      : "implicit" === i.unknown ||
                        console.error(
                          "@dp/gis-scale",
                          `视觉通道传入unknown ${i.unknown}无法解析`
                        ));
                break;
              default:
                const n = jH._getScale(t);
                o
                  ? (o = n.domain(i.domain).range(i.range))
                  : console.error(
                      "@dp/gis-scale",
                      `视觉通道传入type ${t}无法解析`
                    );
            }
          } else o = null;
          i.push(o);
        }),
        e.forEach((e) => {
          t.forEach((t, n) => {
            const { scaleField: r, dataField: o, visual: a } = t;
            if (a) {
              const t = (0, i[n])(e[r]);
              if (uf(t)) e[o] = a.default;
              else {
                const i = a[$U.CONDITIONAL];
                if (null == i ? void 0 : i.length) {
                  const t = (function (t, e, i) {
                    for (const n of e) if (UH(t, n.exps, i)) return n.target;
                  })(e[r], i, e);
                  if (t) return void (e[o] = t);
                }
                e[o] = t;
              }
            } else e[o] = e[r];
          });
        }),
        e);
  }
  static _getScale(t) {
    const e = jH.scaleMap[t]();
    return (
      e || console.error("@dp/gis-scale", `视觉通道传入type ${t}无法解析`), e
    );
  }
  static registerScale(t, e) {
    jH._getScale(t) || (jH.scaleMap[t] = e);
  }
  static preProcessData(t, e) {
    const i = t.filter((t) => cf(t[e]));
    return (
      i.sort((t, i) => t[e] - i[e]),
      0 === i.length
        ? (console.error("@dp/gis-scale", `视觉通道数据源中没有${e}字段`),
          [
            {
              [e]: 0,
            },
          ])
        : i
    );
  }
};
let HH = jH;
HH.scaleMap = {
  [$U.LINEAR]: function t() {
    var e = bH()(gH, gH);
    return (
      (e.copy = function () {
        return (
          (i = e),
          t()
            .domain(i.domain())
            .range(i.range())
            .interpolate(i.interpolate())
            .clamp(i.clamp())
            .unknown(i.unknown())
        );
        var i;
      }),
      yj.apply(e, arguments),
      GH(e)
    );
  },
  [$U.THRESHOLD]: function t() {
    var e,
      i = [0.5],
      n = [0, 1],
      r = 1;
    function o(t) {
      return null != t && t <= t ? n[uj(i, t, 0, r)] : e;
    }
    return (
      (o.domain = function (t) {
        return arguments.length
          ? ((i = Array.from(t)), (r = Math.min(i.length, n.length - 1)), o)
          : i.slice();
      }),
      (o.range = function (t) {
        return arguments.length
          ? ((n = Array.from(t)), (r = Math.min(i.length, n.length - 1)), o)
          : n.slice();
      }),
      (o.invertExtent = function (t) {
        var e = n.indexOf(t);
        return [i[e - 1], i[e]];
      }),
      (o.unknown = function (t) {
        return arguments.length ? ((e = t), o) : e;
      }),
      (o.copy = function () {
        return t().domain(i).range(n).unknown(e);
      }),
      yj.apply(o, arguments)
    );
  },
  [$U.ORDINAL]: function t() {
    var e = new cj(),
      i = [],
      n = [],
      r = vj;
    function o(t) {
      let o = e.get(t);
      if (void 0 === o) {
        if (r !== vj) return r;
        e.set(t, (o = i.push(t) - 1));
      }
      return n[o % n.length];
    }
    return (
      (o.domain = function (t) {
        if (!arguments.length) return i.slice();
        (i = []), (e = new cj());
        for (const n of t) e.has(n) || e.set(n, i.push(n) - 1);
        return o;
      }),
      (o.range = function (t) {
        return arguments.length ? ((n = Array.from(t)), o) : n.slice();
      }),
      (o.unknown = function (t) {
        return arguments.length ? ((r = t), o) : r;
      }),
      (o.copy = function () {
        return t(i, n).unknown(r);
      }),
      yj.apply(o, arguments),
      o
    );
  },
};
const VH = (t, e) => t.map((t) => t[e]),
  WH = (t, e) =>
    VH(t, e).reduce((t, e) => Lf(null != t ? t : 0, null != e ? e : 0)),
  qH = {
    min: (t, e) => (t.sort((t, i) => t[e] - i[e]), t[0][e]),
    max: (t, e) => (t.sort((t, i) => t[e] - i[e]), t[t.length - 1][e]),
    mode: (t, e) => {
      const i = VH(t, e);
      let n = null,
        r = 0;
      for (const o of i) 0 == r && (n = o), o != n ? r-- : r++;
      return n;
    },
    mean: (t, e) => If(WH(t, e), t.length),
    sum: WH,
    count: (t) => t.length,
  },
  YH = (t, e, i) => {
    const { color: n, height: r } = e,
      o = (function (t) {
        const e = [];
        return (
          null == t ||
            t.forEach((t) => {
              var i;
              null == (i = t.exps) ||
                i.forEach((t) => {
                  t.type !== RH.Field || e.includes(t.value) || e.push(t.value);
                });
            }),
          e
        );
      })(i),
      a = [];
    return (
      t.forEach((t, e) => {
        const i = t.points,
          s = qH[n.calcMethod](i, n.field),
          l = Object.fromEntries(o.map((t) => [t, qH[n.calcMethod](i, t)]));
        let u = r ? s : null;
        !r ||
          (r.calcMethod === n.calcMethod && r.field === n.field) ||
          (u = qH[r.calcMethod](i, r.field)),
          a.push(
            ot(
              rt(
                {
                  _id: e,
                  coordinates: [t.x, t.y],
                  rawData: i,
                  count: i.length,
                  colorField: s,
                  heightField: u,
                },
                l
              ),
              {
                majorPOIField: i[0].majorPOIField,
                minorPOIField: s,
              }
            )
          );
      }),
      a
    );
  };
function XH(t) {
  const e = new Ye(),
    i = (function (t, e) {
      let i;
      if (t instanceof Wn) {
        const e = t.geometry;
        return e.computeBoundingBox(), (i = e.boundingBox), i;
      }
      if (t instanceof As) {
        if (((i = new li().setFromObject(t)), e)) {
          const { color: t, group: n } = e,
            r = new JE(i, new ln(t));
          n.add(r);
        }
        return i;
      }
      return console.error("[xGis]", "传入 obj 计算包围盒 不支持"), null;
    })(t),
    n = new Ye().copy(i.max),
    r = new Ye().copy(i.min);
  i.getCenter(e), t.localToWorld(e), t.localToWorld(n), t.localToWorld(r);
  const o = new Ye(e.getComponent(0), n.getComponent(1), e.getComponent(2)),
    a = new Ye(e.getComponent(0), r.getComponent(1), e.getComponent(2));
  return {
    max: n,
    min: r,
    center: e,
    top: o,
    bottom: a,
  };
}
function QH(t, e, i) {
  var n, r;
  const o =
      null != (n = null == i ? void 0 : i.clientWidth) ? n : window.innerWidth,
    a =
      null != (r = null == i ? void 0 : i.clientHeight)
        ? r
        : window.innerHeight;
  t.project(e);
  return {
    screenX: (0.5 + t.x / 2) * o,
    screenY: (0.5 - t.y / 2) * a,
  };
}
function ZH(t, e) {
  const i = new li();
  i.setFromObject(t);
  const n = new li();
  return n.setFromObject(e), !!i.intersectsBox(n);
}
function JH(t, e, i) {
  return (
    (cf(i) && t.id === i) || (cf(e) && (t.ext.name === e || t.ext.alias === e))
  );
}
new (class extends eE {
  constructor(t) {
    super(t);
  }
  load(t, e, i, n) {
    void 0 === t && (t = ""),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = $A.get(t);
    if (void 0 !== r)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          e && e(r), this.manager.itemEnd(t);
        }, 0),
        r
      );
    if (void 0 !== iE[t])
      return void iE[t].push({
        onLoad: e,
        onProgress: i,
        onError: n,
      });
    (iE[t] = []),
      iE[t].push({
        onLoad: e,
        onProgress: i,
        onError: n,
      });
    const o = new Request(t, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin",
    });
    fetch(o)
      .then((e) => {
        if (200 === e.status || 0 === e.status) {
          e.status;
          const i = iE[t],
            n = e.body.getReader(),
            r = e.headers.get("Content-Length"),
            o = r ? parseInt(r) : 0,
            a = 0 !== o;
          let s = 0;
          return new ReadableStream({
            start(t) {
              !(function e() {
                n.read().then(({ done: n, value: r }) => {
                  if (n) t.close();
                  else {
                    s += r.byteLength;
                    const n = new ProgressEvent("progress", {
                      lengthComputable: a,
                      loaded: s,
                      total: o,
                    });
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t];
                      e.onProgress && e.onProgress(n);
                    }
                    t.enqueue(r), e();
                  }
                });
              })();
            },
          });
        }
        throw Error(
          `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
        );
      })
      .then((t) => {
        const e = new Response(t);
        switch (this.responseType) {
          case "arraybuffer":
            return e.arrayBuffer();
          case "blob":
            return e.blob();
          case "document":
            return e
              .text()
              .then((t) => new DOMParser().parseFromString(t, this.mimeType));
          case "json":
            return e.json();
          default:
            return e.text();
        }
      })
      .then((e) => {
        $A.add(t, e);
        const i = iE[t];
        delete iE[t];
        for (let t = 0, n = i.length; t < n; t++) {
          const n = i[t];
          n.onLoad && n.onLoad(e);
        }
        this.manager.itemEnd(t);
      })
      .catch((e) => {
        const i = iE[t];
        delete iE[t];
        for (let t = 0, n = i.length; t < n; t++) {
          const n = i[t];
          n.onError && n.onError(e);
        }
        this.manager.itemError(t), this.manager.itemEnd(t);
      }),
      this.manager.itemStart(t);
  }
  setResponseType(t) {
    return (this.responseType = t), this;
  }
  setMimeType(t) {
    return (this.mimeType = t), this;
  }
})();
var KH = Object.defineProperty,
  $H = Object.getOwnPropertyDescriptor,
  tV = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? $H(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && KH(e, i, o), o;
  };
class eV extends As {
  constructor(t = cU.POI) {
    super(),
      (this.zIndex = t),
      (this.__asyncTaskPool = []),
      (this.__prevVisible = !1),
      (this.__moving = !1);
  }
  set moving(t) {
    this.__moving !== t &&
      (t
        ? ((this.__prevVisible = this.visible),
          (this.__moving = !0),
          (this.visible = !1))
        : ((this.__moving = !1), (this.visible = this.__prevVisible)));
  }
  async addText(t, e, i, n, r, o, a, s, l) {
    const u = [];
    r &&
      u.push({
        text: r.content,
        props: r.props,
      }),
      o &&
        u.push({
          text: o.content,
          props: o.props,
        });
    const c = (function (t) {
      let e;
      return {
        promise: new Promise((i, n) => {
          (e = n), t && t(i, n);
        }),
        abort: () => {
          e("async promise is aborted");
        },
      };
    })(async (r, o) => {
      r(
        await this.textService.createText({
          position: t,
          textSeries: u,
          alignment: i,
          background: n,
          orient: e,
          zIndex: this.zIndex,
          offsetX: a,
          offsetY: s,
        })
      );
    });
    this.__asyncTaskPool.push(c);
    try {
      const t = await c.promise;
      (t.ext = l), this.add(t);
    } catch (h) {
      this.logService.warn(h);
    }
  }
  collision() {
    const t = [];
    this.children.forEach((e) => {
      let i = !0;
      for (let n = 0; n < t.length; n++) {
        if (ZH(e, t[n])) {
          i = !1;
          break;
        }
        i = !0;
      }
      i ? ((e.visible = !0), t.push(e)) : (e.visible = !1);
    });
  }
  updateTextPosition(t, e) {
    this.children.forEach((i) => {
      const n = new Ye(...i.ext.position);
      n.applyMatrix4(t);
      const r = n.project(e.coreCamera).unproject(e.hudCamera);
      i.position.set(r.x + i.ext.offsetX, r.y + i.ext.offsetY, 0);
    });
  }
  updateBaseHeight(t) {
    this.children.forEach((e) => {
      e.ext.position[2] = t;
    });
  }
  active(t) {
    if (!t)
      return void this.hide({
        each: !0,
      });
    const { id: e, instanceId: i } = t;
    cf(i)
      ? this.children.forEach((t) => {
          t.ext.relatedInstanceId === i ? (t.visible = !0) : (t.visible = !1);
        })
      : this.children.forEach((t) => {
          var i;
          (null == (i = t.ext.relatedMeshIds) ? void 0 : i.includes(e))
            ? (t.visible = !0)
            : (t.visible = !1);
        });
  }
  abort() {
    this.__asyncTaskPool.forEach((t) => t.abort()), (this.__asyncTaskPool = []);
  }
  hide(t) {
    if (!t) return void (this.visible = !1);
    const { each: e } = t;
    e &&
      this.children.forEach((t) => {
        t.visible = !1;
      });
  }
  show(t) {
    if (!t) return void (this.visible = !0);
    const { each: e } = t;
    e &&
      this.children.forEach((t) => {
        t.visible = !0;
      });
  }
}
tV([_G(KB.ITextService)], eV.prototype, "textService", 2),
  tV([_G(KB.ILogService)], eV.prototype, "logService", 2);
var iV = Object.defineProperty,
  nV = Object.getOwnPropertyDescriptor,
  rV = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? nV(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && iV(e, i, o), o;
  };
let oV = class {
  constructor(t, e) {
    (this.gis = t),
      (this.props = e),
      (this.animation = new TU()),
      (this.ee = new dt()),
      (this.scaleService = HH),
      (this.listenerObj = new As()),
      (this.comboTimeout = 200),
      (this.activeArr = []),
      (this.handleDblclick = (t) => {
        clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = null;
          }, this.comboTimeout));
      }),
      this._baseLayerinit();
    const { containerDom: i } = this.gis.props;
    i.addEventListener("dblclick", this.handleDblclick, !1);
  }
  _baseLayerinit() {
    (this.group = new As()),
      (this.group.userData.isRootLayer = !0),
      (this.group.userData.invertedRelection = !1),
      (this.id = this.group.uuid),
      (this.dataView = new ak(this.gis.dataSet, {})),
      (this.textureManager = Yd(this.textureService.getTextureManager)(
        this.id
      )),
      (this._propsWatch = kf.createPropsWatch()),
      this._initPropsWatchRule();
  }
  _initialState(t) {
    this.state = af(t, this.props);
  }
  _initLayerGroup(t) {
    const {
        layerName: e,
        layerType: i,
        coreGroup: n,
        label: r = {},
        isHudScene: o = !1,
      } = t,
      { enabled: a = !1, markerType: s = "css2d" } = r,
      { sceneSystem: l, layerManager: u } = this.gis;
    (this.layerType = i),
      o ? l.hudScene.add(this.group) : l.coreScene.add(this.group),
      (this.group.name = e),
      (this.coreGroup = null != n ? n : new As()),
      (this.coreGroup.name = `core-${e}`),
      this.group.add(this.coreGroup),
      (this.poiGroup = new eV()),
      (this.poiGroup.name = `${e}-poi-layer`),
      l.hudScene.add(this.poiGroup),
      u.add({
        layerType: i,
        layer: this,
      }),
      a &&
        this.gis.eventManager.ee.emit("markerEnabled", {
          markerType: s,
        }),
      this.updateBaseHeight();
  }
  _getParseData(t) {
    const { rawData: e, layerType: i, coordsField: n } = t,
      { clipMode: r } = this.state,
      { globalOpts: o } = this.gis,
      { boundary: a } = o,
      s = Yw(e[0]) ? "geojson" : "bytejson",
      l = !(!r || r === Qw.none),
      u = this.dataView
        .parse(e, {
          type: s,
          options: {
            layerType: i,
            coordsField: n,
          },
        })
        .transform({
          type: "filter",
          options: {
            callback: l && ((t) => Kw(t, a.features[0], r, i)),
          },
        })
        .transform({
          type: "webgis",
          options: {
            as: "coordinates",
          },
        }).latestData;
    return this.state.parseData.push(...u), this;
  }
  _getScaleData(t) {
    const { parseData: e } = this.state;
    return (this.state.scaleData = this.scaleService.apply(t, e)), this;
  }
  _getRenderData(t) {}
  add(t) {
    return this;
  }
  remove() {
    this._destroy();
  }
  set(t) {
    return this._propsWatch.compare(this.state, t), this;
  }
  get() {
    return this.state;
  }
  updateArea(t) {
    this.updateBaseHeight(), this._updateOffset(this.state.common.offset);
  }
  updateBaseHeight() {
    const { globalOpts: t } = this.gis;
    if (t) {
      const e = t.bboxOption.baseHeight;
      this.coreGroup.position.setZ(e),
        this.poiGroup.updateBaseHeight(e),
        this._updatePOI(!0);
    }
  }
  setContainer(t) {
    this.container = t;
  }
  getContainer() {
    return this.container;
  }
  clear() {
    this.clearCoreGroup(),
      this.clearPoiGroup(),
      this.clearInteractionGroup(),
      this._clearData();
  }
  clearCoreGroup() {
    this.coreGroup.destroy(!1);
  }
  clearPoiGroup() {
    this.poiGroup.abort(), this.poiGroup.destroy(!1);
  }
  clearInteractionGroup() {
    this.unActive();
  }
  _clearData() {
    (this.dataView.latestData = null),
      (this.state.data = []),
      (this.state.parseData = []),
      (this.state.scaleData = []),
      (this.state.renderData = []);
  }
  _destroy() {
    var t;
    const { sceneSystem: e, layerManager: i } = this.gis,
      { containerDom: n } = this.gis.props;
    n.removeEventListener("dblclick", this.handleDblclick),
      this.clear(),
      i.__removePure({
        layerID: this.id,
      }),
      this.dataView.destroy(),
      this.textureService.removeTextureManager(this.id),
      null == (t = e.coreScene) || t.remove(this.group),
      this.ee.removeAllListeners(),
      (this._propsWatch = null);
  }
  on(t, e, i) {
    Fk(t) || this.gis.eventManager.bindEvent(this.id, t), this.ee.on(t, e, i);
  }
  off(t, e) {
    Fk(t) || this.gis.eventManager.removeMapEvent(this.id, t),
      this.ee.removeListener(t),
      e && e();
  }
  rotate(t, e) {
    switch (t) {
      case "x":
        this.group.rotateX(De(e));
        break;
      case "y":
        this.group.rotateY(De(e));
        break;
      case "z":
        this.group.rotateZ(De(e));
    }
  }
  handleAnimation(t) {}
  emitPropsWatch(t = {}) {
    this._propsWatch.compare(t, this.state);
  }
  _initPropsWatchRule() {
    this._propsWatch.addWatch([
      this._propsWatch.defaultRule("", "always", (t) => {
        this.state = af(this.state, t);
      }),
      this._propsWatch.defaultRule(["common", "offset"], "diff", (t) => {
        cf(t.common.offset) && this._updateOffset(t.common.offset);
      }),
      this._propsWatch.defaultRule(["common", "visible"], "diff", (t) => {
        sf(t.common, "visible") && this._updateVisible(t.common.visible);
      }),
      this._propsWatch.defaultRule(["common", "zIndex"], "diff", (t) => {
        sf(t.common, "zIndex") && this._updateZIndex(t.common.zIndex);
      }),
      this._propsWatch.defaultRule(["common", "zoomRange"], "diff", (t) => {
        sf(t.common, "zoomRange") && this._updateZoomRange(t.common.zoomRange);
      }),
      this._propsWatch.defaultRule("interaction", "diffDeep", () => {
        this._updateInteraction(this.state.interaction);
      }),
    ]);
  }
  _updateOffset(t) {
    const [e, i, n] = t,
      { globalOpts: r } = this.gis,
      { size: o } = r.bboxOption,
      a = TA(o.bboxSize, e),
      s = TA(o.bboxSize, i),
      l = TA(o.bboxSize, n);
    this.extensions &&
      Object.values(this.extensions).forEach((t) => {
        t.group.position.setX(a),
          t.group.position.setY(s),
          t.group.position.setZ(l),
          t._updatePOI(!0);
      }),
      this.group.position.setX(a),
      this.group.position.setY(s),
      this.group.position.setZ(l),
      this._updatePOI(!0);
  }
  _updateVisible(t) {
    this.extensions &&
      Object.values(this.extensions).forEach((e) => {
        e.group.visible = !!t && e.state.common.visible;
      }),
      "marker-layer" === this.group.name &&
        requestAnimationFrame(() => {
          const e = `data-layerid="${this.id}"`;
          document.querySelectorAll(`[${e}]`).forEach((e) => {
            e.firstChild.style.display = t ? "block" : "none";
          });
        }),
      (this.group.visible = t),
      (this.poiGroup.visible = t);
  }
  _updateZoomRange(t) {
    this.extensions &&
      Object.values(this.extensions).forEach((e) => {
        (e.group.ext.zoomRange = t), (e.poiGroup.ext.zoomRange = t);
      }),
      (this.group.ext.zoomRange = t),
      (this.poiGroup.ext.zoomRange = t);
  }
  _updateZIndex(t) {
    this.extensions &&
      Object.values(this.extensions).forEach((e) => {
        e.group.zIndex = null != t ? t : e.group.zIndex;
      }),
      "marker-layer" === this.group.name &&
        requestAnimationFrame(() => {
          const e = `data-layerid="${this.id}"`;
          document.querySelectorAll(`[${e}]`).forEach((e) => {
            e.style.zIndex = t + "";
          });
        }),
      (this.group.zIndex = null != t ? t : this.group.zIndex);
  }
  _updateInteraction(t) {
    if (((this.interaction = t), !this.interaction)) return;
    const { hover: e, select: i } = this.interaction;
    [e, i].forEach((t) => {
      t.enabled
        ? this.gis.eventManager.bindEvent(this.id, t.trigger)
        : this.gis.eventManager.removeMapEvent(this.id, t.trigger);
    });
  }
  registerInteraction(t = this.state.interaction, e = this.coreGroup, i = !1) {
    (this.interaction = t), (this.listenerObj = e), (this.recursive = i);
  }
  active(t) {
    const {
      type: e,
      object: i,
      id: n,
      instanceId: r,
      name: o,
      color: a,
      multi: s,
    } = t;
    return cf(n) || cf(o)
      ? (o
          ? o instanceof Array
            ? o.forEach((t) => {
                this._activeAtomic({
                  name: t,
                  object: i,
                  color: a,
                  type: e,
                  multi: s,
                });
              })
            : this._activeAtomic({
                name: o,
                object: i,
                color: a,
                type: e,
                multi: s,
              })
          : n instanceof Array
          ? n.forEach((t) => {
              this._activeAtomic({
                id: t,
                object: i,
                color: a,
                type: e,
                instanceId: r,
                multi: s,
              });
            })
          : this._activeAtomic({
              id: n,
              object: i,
              color: a,
              type: e,
              instanceId: r,
              multi: s,
            }),
        this)
      : (this.logService.error("active 需要 传入 id 或 name"), this);
  }
  _activeAtomic(t) {
    const { object: e } = t;
    e && e.isInstancedMesh
      ? this._activeInstanceAtomic(t)
      : this._activeMeshAtomic(t);
  }
  _activeInstanceAtomic(t) {
    const {
      color: e,
      type: i,
      object: n,
      instanceId: r,
      id: o,
      name: a,
      multi: s,
    } = t;
    n.ext.activeArr || (n.ext.activeArr = []);
    const l = n.ext.activeArr.findIndex(
      (t) => t.isActive && t.instanceId === r
    );
    if (-1 != l) {
      const t = n.ext.activeArr[l];
      if ("select" === t.type && "hover" === i) return;
      if ("select" === t.type && "select" === i) {
        const { instanceId: e, rawColor: i } = t;
        return (
          ZD(n.geometry.attributes.color, e, i),
          (n.ext.activeArr[l].type = ""),
          (n.ext.activeArr[l].activeColor = ""),
          void (n.ext.activeArr[l].isActive = !1)
        );
      }
    }
    "hover" === i &&
      this.unActive({
        type: "hover",
      }),
      "select" === i &&
        !0 !== s &&
        this.unActive({
          type: "select",
        });
    const u = n.ext.activeArr.findIndex((t) => t.instanceId === r);
    let c;
    if (-1 === u) {
      const { color: t } = n.geometry.attributes,
        { array: o, itemSize: a } = t;
      (c = Array.from(o).slice(r * a, r * a + a)),
        t.normalized && (c = c.map((t) => t / 255)),
        n.ext.activeArr.push({
          rawColor: c,
          activeColor: e,
          instanceId: r,
          isActive: !0,
          type: i,
        });
    } else (n.ext.activeArr[u].type = i), (n.ext.activeArr[u].isActive = !0);
    if (isNaN(Number(e))) {
      const t = EA(e);
      ZD(n.geometry.attributes.color, r, [
        t.color.r,
        t.color.g,
        t.color.b,
        t.opacity,
      ]);
    } else {
      const t = Number(e),
        i = n.ext.activeArr[u];
      ZD(n.geometry.attributes.color, r, [
        (null != c ? c : i.rawColor)[0] * t,
        (null != c ? c : i.rawColor)[1] * t,
        (null != c ? c : i.rawColor)[2] * t,
        (null != c ? c : i.rawColor)[3],
      ]);
    }
    const h = {
      name: a,
      id: o,
      instanceId: r,
      object: n,
      type: i,
      meshs: [],
    };
    this.activeArr.push(h);
  }
  _activeMeshAtomic(t) {
    const { name: e, color: i, type: n, id: r, multi: o } = t,
      a = this.activeArr.findIndex((t) =>
        t.meshs.find((t) => JH(t, e, r) && t.ext.isActive)
      );
    if (-1 != a) {
      const t = this.activeArr[a];
      let i = !1;
      if (
        (t.meshs.forEach((o) => {
          "select" === o.ext.type && "hover" === n
            ? (i = !0)
            : "select" === o.ext.type &&
              "select" === n &&
              (this._unactiveAtomic({
                id: r,
                name: e,
                meshs: t.meshs,
              }),
              this.activeArr.splice(a, 1),
              (i = !0));
        }),
        i)
      )
        return;
    }
    "hover" === n &&
      this.unActive({
        type: "hover",
      }),
      "select" === n &&
        !0 !== o &&
        this.unActive({
          type: "select",
        });
    const s = this.listenerObj.getObjectsByFn((t) => JH(t, e, r));
    if (0 === s.length) return void this.logService.error("active mesh 不存在");
    const l = {
      name: e,
      id: r,
      meshs: [],
      type: n,
    };
    s.forEach((t) => {
      const e = t,
        r = e.material;
      (e.ext.type = n),
        (e.ext.isActive = !0),
        (e.ext.activeColor = i),
        e.ext.rawColor ||
          ((e.ext.rawColor = r.color.clone()),
          (e.ext.rawTransparent = r.transparent),
          (e.ext.rawOpacity = r.opacity));
      if (isNaN(Number(i))) {
        const t = EA(i);
        (r.color = t.color),
          (r.transparent = t.transparent),
          (r.opacity = t.opacity);
      } else {
        const t = Number(i),
          n = e.ext.rawColor.clone();
        r.color = n.multiplyScalar(t);
      }
      (r.needsUpdate = !0), l.meshs.push(t);
    }),
      this.activeArr.push(l);
  }
  unActive(t) {
    for (let e = this.activeArr.length - 1; e >= 0; e--) {
      const i = this.activeArr[e],
        n = i.object,
        r = i.type,
        o = i.meshs;
      if (cf(null == t ? void 0 : t.id)) {
        const { id: i } = t;
        i instanceof Array
          ? i.forEach((t) => {
              t === n.id &&
                (this._unactiveAtomic({
                  id: t,
                  object: n,
                  meshs: o,
                }),
                this.activeArr.splice(e, 1));
            })
          : i === n.id &&
            (this._unactiveAtomic({
              id: i,
              object: n,
              meshs: o,
            }),
            this.activeArr.splice(e, 1));
      } else if (null == t ? void 0 : t.name) {
        const { name: i } = t;
        i instanceof Array
          ? i.forEach((t) => {
              t === n.name &&
                (this._unactiveAtomic({
                  name: t,
                  object: n,
                  meshs: o,
                }),
                this.activeArr.splice(e, 1));
            })
          : i === n.name &&
            (this._unactiveAtomic({
              name: i,
              object: n,
              meshs: o,
            }),
            this.activeArr.splice(e, 1));
      } else
        cf(null == t ? void 0 : t.type)
          ? t.type === r &&
            (this._unactiveAtomic({
              type: t.type,
              object: n,
              meshs: o,
            }),
            this.activeArr.splice(e, 1))
          : (this._unactiveAtomic({
              type: r,
              object: n,
              meshs: o,
            }),
            this.activeArr.splice(e, 1));
    }
    return this;
  }
  _unactiveAtomic(t) {
    const { object: e } = t;
    e && e.isInstancedMesh
      ? this._unactiveInstanceAtomic(t)
      : this._unactiveMeshAtomic(t);
  }
  _unactiveInstanceAtomic(t) {
    const { type: e, object: i } = t;
    for (let n = i.ext.activeArr.length - 1; n >= 0; n--) {
      const t = i.ext.activeArr[n],
        { instanceId: r, isActive: o, rawColor: a } = t;
      o &&
        e === t.type &&
        (ZD(i.geometry.attributes.color, r, a),
        (t.type = ""),
        (t.activeColor = ""),
        (t.isActive = !1));
    }
  }
  _unactiveMeshAtomic(t) {
    const { id: e, type: i, name: n, meshs: r } = t;
    r.forEach((t) => {
      if ((JH(t, n, e) || (!!i && t.ext.type === i)) && t.ext.isActive) {
        const e = t.material;
        (e.color = t.ext.rawColor),
          (e.transparent = t.ext.rawTransparent),
          (e.opacity = t.ext.rawOpacity),
          (e.needsUpdate = !0),
          (t.ext.isActive = !1),
          (t.ext.activeColor = ""),
          (t.ext.type = "");
      }
    });
  }
  _updatePOI(t = !1) {
    const { poi: e, interaction: i } = this.state;
    if (!e || !e.enabled) return;
    const { cameraSystem: n } = this.gis,
      { coverEnable: r, hideOnMove: o } = e;
    if (o && !t) return void (this.poiGroup.moving = !0);
    t && (this.poiGroup.moving = !1),
      this.group.updateWorldMatrix(!0, !1),
      n.coreCamera.updateWorldMatrix(!0, !1),
      this.poiGroup.updateTextPosition(this.group.matrixWorld, n);
    (i.hover.enabled && i.hover.effect.poi) ||
    (i.select.enabled && i.select.effect.poi)
      ? this.poiGroup.hide({
          each: !0,
        })
      : r || this.poiGroup.collision();
  }
  _mapSize(t, e) {
    const { globalOpts: i } = this.gis;
    let n = 100;
    switch (e) {
      case "straightline":
        n = (t / 100) * i.layerFitValue.straightLineWidth;
        break;
      case "flyline":
        n = (t / 100) * i.layerFitValue.flylineWidth;
        break;
      case "z":
        n = (t / 100) * i.layerFitValue.z;
        break;
      default:
        n = (t / 100) * i.layerFitValue.xy;
    }
    return n;
  }
};
function aV(t) {
  return function (e, i) {
    e.__layerEvent__ || (e.__layerEvent__ = []), e.__layerEvent__.push([t, i]);
  };
}
rV([_G(KB.ILogService)], oV.prototype, "logService", 2),
  rV([_G(KB.ITextService)], oV.prototype, "textService", 2),
  rV([_G(KB.ITextureService)], oV.prototype, "textureService", 2),
  (oV = rV(
    [
      function (t) {
        return class extends t {
          constructor(t, e) {
            super(t, e),
              this.__layerEvent__ &&
                this.__layerEvent__.forEach(([t, e]) => {
                  this.gis.ee.on(t, this[e]);
                });
          }
          remove() {
            super.remove(),
              this.__layerEvent__ &&
                this.__layerEvent__.forEach(([t, e]) => {
                  this.gis.ee.off(t, this[e]);
                });
          }
        };
      },
    ],
    oV
  ));
const sV = 4800;
function lV(t) {
  let e = af(t);
  return (
    am.flatten(e),
    (e = (function (t) {
      const e = {
        type: "FeatureCollection",
        features: [],
      };
      let i, n;
      for (i = 0; i < t.features.length; i++) {
        const r = t.features[i],
          o = r.geometry;
        if (!o || !o.coordinates || 0 === o.coordinates.length) continue;
        if ("Polygon" != o.type) continue;
        const a = o.coordinates,
          s = [];
        for (n = 0; n < a.length; n++) {
          const t = a[n][0],
            e = a[n][a[n].length - 1];
          t[0] == e[0] && t[1] == e[1]
            ? s.push(a[n])
            : a[n].length > 10 && (a[n].push(t), s.push(a[n]));
        }
        (r.geometry.coordinates = s), e.features.push(r);
      }
      return e;
    })(e)),
    e
  );
}
async function uV(t, e = "all") {
  if (!t.districtData) return;
  const i =
      "bottomStroke" === e
        ? null
        : (function (t) {
            const { districtStyle: e } = t.state;
            if (e.stroke && e.stroke.width) {
              const i = new TD({
                transparent: !0,
                color: new ln(e.stroke.color).getHex(),
                linewidth: e.stroke.width,
                opacity: e.stroke.opacity,
              });
              return (
                i.resolution.set(
                  t.gis.props.containerDom.clientWidth,
                  t.gis.props.containerDom.clientHeight
                ),
                i
              );
            }
            return null;
          })(t),
    n =
      "stroke" === e
        ? null
        : (function (t) {
            const { districtStyle: e } = t.state;
            if (e.bottomStroke && e.stroke.width) {
              const i = new TD({
                transparent: !0,
                color: new ln(e.bottomStroke.color).getHex(),
                linewidth: e.bottomStroke.width,
                opacity: e.bottomStroke.opacity,
                dashed: !1,
              });
              return (
                i.resolution.set(
                  t.gis.props.containerDom.clientWidth,
                  t.gis.props.containerDom.clientHeight
                ),
                i
              );
            }
            return null;
          })(t);
  t.districtData.forEach((e) => {
    e.geometry.coordinates.forEach((e) => {
      ((e) => {
        let r;
        const o = [];
        for (let t = 0; t < e.length; t++) {
          const [i, n] = e[t];
          o.push(i, n, 0);
        }
        if (((i || n) && ((r = new YD()), r.setPositions(o)), i)) {
          const e = new XD(r, i);
          e.setRenderIndex(lU.BASE_MAP_LAYER_COUNTRY_STROKE),
            t.districtStrokeGroup.add(e);
        }
        if (n) {
          const e = new XD(r, n);
          e.setRenderIndex(lU.BASE_MAP_LAYER_BOTTOM_STROKE),
            t.districtBottomStrokeGroup.add(e);
        }
      })(e);
    });
  });
}
function cV(t, e) {
  if (sf(t, "stroke")) {
    const i = EA(t.stroke.color);
    0 === e.districtStrokeGroup.children.length
      ? uV(e, "stroke")
      : e.districtStrokeGroup.children.forEach((e) => {
          const n = e.material;
          n &&
            ((n.color = i.color),
            (n.opacity = DA(i, t.stroke.opacity)),
            (n.linewidth = t.stroke.width));
        });
  }
}
function hV(t, e) {
  if (sf(t, "bottomStroke")) {
    const i = EA(t.bottomStroke.color);
    0 === e.districtBottomStrokeGroup.children.length
      ? uV(e, "bottomStroke")
      : e.districtBottomStrokeGroup.children.forEach((e) => {
          const n = e.material;
          (n.color = i.color),
            (n.opacity = DA(i, t.bottomStroke.opacity)),
            (n.linewidth = t.bottomStroke.width);
        });
  }
}
function pV(t) {
  const e = t[0],
    i = t[1],
    n = t[2];
  return Math.sqrt(e * e + i * i + n * n);
}
function dV(t, e, i) {
  return (t[0] = e[0] - i[0]), (t[1] = e[1] - i[1]), (t[2] = e[2] - i[2]), t;
}
function fV(t, e) {
  const i = e[0],
    n = e[1],
    r = e[2];
  let o = i * i + n * n + r * r;
  return (
    o > 0 &&
      ((o = 1 / Math.sqrt(o)),
      (t[0] = e[0] * o),
      (t[1] = e[1] * o),
      (t[2] = e[2] * o)),
    t
  );
}
function gV(t, e, i, n = [], r = !0) {
  const o = [],
    a = [];
  return (
    dV(o, i, e),
    dV(a, t, e),
    (function (t, e, i) {
      const n = e[0],
        r = e[1],
        o = e[2],
        a = i[0],
        s = i[1],
        l = i[2];
      (t[0] = r * l - o * s), (t[1] = o * a - n * l), (t[2] = n * s - r * a);
    })(n, o, a),
    r && fV(n, n),
    n
  );
}
function mV(t, e, i, n) {
  let r = 0;
  for (let o = e, a = i - n; o < i; o += n)
    (r += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
  return r > 0;
}
function yV(t, e) {
  const { coordinates: i, bbox: n, height: r } = e,
    { vertices: o, holes: a, dimensions: s } = _l.flatten(i),
    l = _l.default(o, a, s),
    { index: u, position: c, normal: h, uv: p } = t,
    d = n[2] - n[0],
    f = n[3] - n[1],
    g = c.length / 3;
  let m;
  const y = [];
  for (m = 0; m < o.length; m += s)
    (y[0] = +Math.round(o[m])),
      (y[1] = +Math.round(o[m + 1])),
      (y[2] = +Math.round(r)),
      c.push(...y),
      p.push((+y[0] - n[0]) / d, (+y[1] - n[1]) / f),
      h.push(0, 0, 0);
  let v, b, x;
  const _ = [],
    S = [],
    M = [],
    C = [];
  for (m = 2; m < l.length; m += 3)
    (v = l[m - 2] + g),
      (b = l[m - 1] + g),
      (x = l[m] + g),
      u.push(v, b, x),
      (v *= 3),
      (_[0] = c[v]),
      (_[1] = c[v + 1]),
      (_[2] = c[v + 2]),
      (b *= 3),
      (S[0] = c[b]),
      (S[1] = c[b + 1]),
      (S[2] = c[b + 2]),
      (x *= 3),
      (M[0] = c[x]),
      (M[1] = c[x + 1]),
      (M[2] = c[x + 2]),
      gV(_, S, M, C, !1),
      (h[v] += C[0]),
      (h[v + 1] += C[1]),
      (h[v + 2] += C[2]),
      (h[b] += C[0]),
      (h[b + 1] += C[1]),
      (h[b + 2] += C[2]),
      (h[x] += C[0]),
      (h[x + 1] += C[1]),
      (h[x + 2] += C[2]);
  for (m = 3 * g; m < h.length; m += 3)
    (C[0] = h[m]),
      (C[1] = h[m + 1]),
      (C[2] = h[m + 2]),
      fV(C, C),
      ([h[m], h[m + 1], h[m + 2]] = C);
}
function vV(t, e) {
  const { coordinates: i, height: n } = e,
    { vertices: r, holes: o, dimensions: a } = _l.flatten(i),
    { index: s, position: l, normal: u, uv: c } = t,
    h = [],
    p = [],
    d = [],
    f = [],
    g = [],
    m = [],
    y = [],
    v = [],
    b = [],
    x = l.length / 3;
  let _, S;
  for (_ = 0; _ < r.length; _ += a)
    (y[0] = +Math.round(r[_])),
      (y[1] = +Math.round(r[_ + 1])),
      (y[2] = +Math.round(n)),
      l.push(...y),
      u.push(0, 0, 0),
      (y[2] = 0),
      l.push(...y),
      u.push(0, 0, 0);
  const M = o && o.length > 0 ? o[0] : r.length / a;
  let C, w;
  b.push([0, M]);
  const A = o.length;
  for (_ = 0; _ < A; _++)
    (C = o[_]), (w = _ < A - 1 ? o[_ + 1] : r.length / a), b.push([C, w]);
  let E, D, T;
  for (_ = 0; _ < b.length; _++) {
    ([C, w] = b[_]), (D = 0 === _), (E = 0);
    if (D === mV(r, C * a, w * a, a))
      for (S = C + 1; S < w; S++)
        (T = 2 * (S - 1) + x),
          (T *= 3),
          (h[0] = l[T]),
          (h[1] = l[T + 1]),
          (h[2] = l[T + 2]),
          (p[0] = l[T + 3]),
          (p[1] = l[T + 4]),
          (p[2] = l[T + 5]),
          (T = 2 * S + x),
          (T *= 3),
          (d[0] = l[T]),
          (d[1] = l[T + 1]),
          (d[2] = l[T + 2]),
          (f[0] = l[T + 3]),
          (f[1] = l[T + 4]),
          (f[2] = l[T + 5]),
          (T = 2 * (S - 1) + x),
          (T *= 2),
          (c[T] = E),
          (c[T + 1] = 1),
          (c[T + 2] = E),
          (c[T + 3] = 0),
          (E += pV(dV(v, f, p))),
          (T = 2 * S + x),
          (T *= 2),
          (c[T] = E),
          (c[T + 1] = 1),
          (c[T + 2] = E),
          (c[T + 3] = 0),
          gV(p, f, h, g, !1),
          gV(f, d, h, m, !1),
          (T = 2 * (S - 1) + x),
          (T *= 3),
          (u[T] += g[0] + m[0]),
          (u[T + 1] += g[1] + m[1]),
          (u[T + 2] += g[2] + m[2]),
          (u[T + 3] += g[0]),
          (u[T + 4] += g[1]),
          (u[T + 5] += g[2]),
          (T = 2 * S + x),
          (T *= 3),
          (u[T] += m[0]),
          (u[T + 1] += m[1]),
          (u[T + 2] += m[2]),
          (u[T + 3] += g[0] + m[0]),
          (u[T + 4] += g[1] + m[1]),
          (u[T + 5] += g[2] + m[2]),
          (T = 2 * (S - 1) + x),
          s.push(T + 1, T + 3, T),
          s.push(T + 3, T + 2, T);
    else
      for (S = w - 2; S >= C; S--)
        (T = 2 * (S + 1) + x),
          (T *= 3),
          (h[0] = l[T]),
          (h[1] = l[T + 1]),
          (h[2] = l[T + 2]),
          (p[0] = l[T + 3]),
          (p[1] = l[T + 4]),
          (p[2] = l[T + 5]),
          (T = 2 * S + x),
          (T *= 3),
          (d[0] = l[T]),
          (d[1] = l[T + 1]),
          (d[2] = l[T + 2]),
          (f[0] = l[T + 3]),
          (f[1] = l[T + 4]),
          (f[2] = l[T + 5]),
          (T = 2 * (S + 1) + x),
          (T *= 2),
          (c[T] = E),
          (c[T + 1] = 1),
          (c[T + 2] = E),
          (c[T + 3] = 0),
          (E += pV(dV(v, f, p))),
          (T = 2 * S + x),
          (T *= 2),
          (c[T] = E),
          (c[T + 1] = 1),
          (c[T + 2] = E),
          (c[T + 3] = 0),
          gV(p, f, h, g, !1),
          gV(f, d, h, m, !1),
          (T = 2 * (S + 1) + x),
          (T *= 3),
          (u[T] += g[0] + m[0]),
          (u[T + 1] += g[1] + m[1]),
          (u[T + 2] += g[2] + m[2]),
          (u[T + 3] += g[0]),
          (u[T + 4] += g[1]),
          (u[T + 5] += g[2]),
          (T = 2 * S + x),
          (T *= 3),
          (u[T] += m[0]),
          (u[T + 1] += m[1]),
          (u[T + 2] += m[2]),
          (u[T + 3] += g[0] + m[0]),
          (u[T + 4] += g[1] + m[1]),
          (u[T + 5] += g[2] + m[2]),
          (T = 2 * (S + 1) + x),
          s.push(T + 1, T - 1, T),
          s.push(T - 1, T - 2, T);
  }
  for (_ = 3 * x; _ < u.length; _ += 3)
    (g[0] = u[_]),
      (g[1] = u[_ + 1]),
      (g[2] = u[_ + 2]),
      fV(g, g),
      ([u[_], u[_ + 1], u[_ + 2]] = g);
}
function bV(t, e) {
  const i = {
      index: [],
      position: [],
      normal: [],
      uv: [],
    },
    n = {
      index: [],
      position: [],
      normal: [],
      uv: [],
    };
  let r, o, a;
  for (r = 0; r < t.features.length; r++) {
    (o = t.features[r]), (a = o.geometry.coordinates);
    yV(i, {
      coordinates: a,
      bbox: e,
      height: 1,
    });
    vV(n, {
      coordinates: a,
      bbox: e,
      height: 1,
    });
  }
  const s = {
    index: [],
    position: [],
    normal: [],
    uv: [],
    group: [],
  };
  return xV(0, s, i), xV(1, s, n), s;
}
function xV(t, e, i) {
  _V(e, i, "index"),
    _V(e, i, "position"),
    _V(e, i, "normal"),
    _V(e, i, "uv"),
    e.group.push(t, i.index.length, i.position.length / 3);
}
function _V(t, e, i) {
  for (let n = 0; n < e[i].length; n++) t[i].push(e[i][n]);
}
class SV {
  constructor(t, e) {
    (this.levelMax = t), (this.levelMin = e);
  }
  _getMapSize(t) {
    return Math.pow(2, t);
  }
  getResolution(t, e) {
    return (12756274 * Math.PI * Math.cos(t)) / 256 / this._getMapSize(e);
  }
  _lngToTileX(t, e) {
    const i = (t + 180) / 360;
    let n = Math.floor(i * this._getMapSize(e));
    return (n = Math.min(n, Math.pow(2, e) - 1)), n;
  }
  _latToTileY(t, e) {
    const i = (t * Math.PI) / 180,
      n = (1 - Math.log(Math.tan(i) + 1 / Math.cos(i)) / Math.PI) / 2;
    return Math.floor(n * this._getMapSize(e));
  }
  lnglatToTile(t, e, i) {
    return {
      tileX: this._lngToTileX(t, i),
      tileY: this._latToTileY(e, i),
    };
  }
  _lngToPixelX(t, e) {
    const i = (t + 180) / 360;
    return Math.floor((i * this._getMapSize(e) * 256) % 256);
  }
  _latToPixelY(t, e) {
    const i = Math.sin((t * Math.PI) / 180),
      n = 0.5 - Math.log((1 + i) / (1 - i)) / (4 * Math.PI);
    return Math.floor((n * this._getMapSize(e) * 256) % 256);
  }
  lnglatToPixel(t, e, i) {
    return {
      pixelX: this._lngToPixelX(t, i),
      pixelY: this._latToPixelY(e, i),
    };
  }
  _pixelXTolng(t, e, i) {
    return ((e + t / 256) / this._getMapSize(i)) * 360 - 180;
  }
  _pixelYToLat(t, e, i) {
    const n = t / 256;
    var r;
    return (
      (180 *
        Math.atan(
          ((r = Math.PI * (1 - (2 * (e + n)) / this._getMapSize(i))),
          (Math.exp(r) - Math.exp(-r)) / 2)
        )) /
      Math.PI
    );
  }
  pixelToLnglat(t, e, i, n, r) {
    return {
      lng: this._pixelXTolng(t, i, r),
      lat: this._pixelYToLat(e, n, r),
    };
  }
}
function MV(t) {
  const {
      tileUrl: e,
      maxZoom: i,
      worldBboxSize: n,
      bboxOption: r,
      isExtrudeBackground: o,
    } = t,
    { bbox: a, size: s } = r,
    l = (function (t) {
      const {
        bboxSize: e,
        maxZoom: i,
        worldBboxSize: n,
        isExtrudeBackground: r,
      } = t;
      let o = ~~(n / e);
      for (let s = 0; s < 21; s++)
        if (o >= Math.pow(2, s) && o < Math.pow(2, s + 1)) {
          o = s + 3;
          break;
        }
      r && o > 4 && o <= i && (o -= 1);
      const a = i || 12;
      return o > a && (o = a), o;
    })({
      bboxSize: s.bboxSize,
      maxZoom: i,
      worldBboxSize: n,
      isExtrudeBackground: o,
    }),
    u = new SV(0, 20),
    c = u._lngToTileX(a[0], l),
    h = u._lngToTileX(a[2], l),
    p = u._latToTileY(a[3], l),
    d = u._latToTileY(a[1], l),
    f = {
      leftTop: u.pixelToLnglat(0, 0, c, p, l),
      rightBottom: u.pixelToLnglat(256, 256, h, d, l),
    },
    g = {
      leftTop: Qf([f.leftTop.lng, f.leftTop.lat, 0]),
      rightBottom: Qf([f.rightBottom.lng, f.rightBottom.lat, 0]),
      width: 0,
      height: 0,
    };
  (g.width = Math.abs(g.rightBottom[0] - g.leftTop[0])),
    (g.height = Math.abs(g.rightBottom[1] - g.leftTop[1]));
  const m = [];
  for (let y = c; y <= h; y++)
    for (let t = p; t <= d; t++)
      y >= 0 &&
        t >= 0 &&
        y < Math.pow(2, l) &&
        t < Math.pow(2, l) &&
        m.push({
          url: e.replace("{x}", y).replace("{y}", t).replace("{z}", l),
          col: y,
          row: t,
          zoom: l,
        });
  return {
    minCol: c,
    maxCol: h,
    minRow: p,
    maxRow: d,
    tilesInfo: m,
    tileBboxProj: g,
    zoom: l,
  };
}
function CV(t) {
  return Math.pow(2, t);
}
function wV(t, e, i) {
  const n = (function (t, e) {
      const i = (t + 180) / 360;
      return Math.floor(i * CV(e) * 256);
    })(t, i),
    r = (function (t, e) {
      const i = Math.sin((t * Math.PI) / 180),
        n = 0.5 - Math.log((1 + i) / (1 - i)) / (4 * Math.PI);
      return Math.floor(n * CV(e) * 256);
    })(e, i);
  return [n, r];
}
function AV(t) {
  const { feature: e, zoom: i, style: n, width: r, height: o, offset: a } = t,
    s = document.createElement("canvas"),
    l = s.getContext("2d");
  (s.width = r),
    (s.height = o),
    (s.style.width = r + "px"),
    (s.style.height = o + "px");
  const u = e.geometry.coordinates,
    c = [];
  let h, p, d;
  c.push([]);
  for (let f = 0; f < u[0].length; f++) {
    const t = u[0][f];
    (d = wV(t[0], t[1], i)), c[0].push([d[0] - a[0], d[1] - a[1]]);
  }
  console.log('c', c)
  for (
    l.globalCompositeOperation = "source-out", l.beginPath(), h = 0;
    h < c.length;
    h++
  ) {
    for (p = 0; p < c[h].length; p++) {
      const t = c[h][p];
      l[p ? "lineTo" : "moveTo"](t[0], t[1]);
    }
    l.closePath();
  }
  return (
    (l.shadowBlur = n.shadowBlur),
    (l.shadowColor = n.shadowColor),
    (l.fillStyle = n.fillColor),
    l.fill(),
    s
  );
}
function EV(t, e, i, n, r) {
  let o;
  if (
    ((t = t.subarray || t.slice ? t : t.buffer),
    (i = i.subarray || i.slice ? i : i.buffer),
    (t = e
      ? t.subarray
        ? t.subarray(e, r && e + r)
        : t.slice(e, r && e + r)
      : t),
    i.set)
  )
    i.set(t, n);
  else for (o = 0; o < t.length; o++) i[o + n] = t[o];
  return i;
}
function DV(t, e, i) {
  return (
    (e *= 6),
    i[(t *= 6)] === i[e] && i[1 + t] === i[1 + e] && i[2 + t] === i[2 + e]
  );
}
function TV(t, e) {
  return [e[(t *= 6)], e[1 + t], e[2 + t]];
}
class PV extends En {
  constructor() {
    super(),
      (this.isMeshLine = !0),
      (this.type = "MeshLine"),
      (this.positions = []),
      (this.previous = []),
      (this.next = []),
      (this.side = []),
      (this.width = []),
      (this.indices = []),
      (this.uvs = []),
      (this.counters = []),
      (this.lens = []),
      (this.lineLengths = []),
      (this.lineConfig = []),
      (this.symbolConfig = []),
      (this.geometry = new En()),
      (this._points = []),
      (this._geom = null),
      (this.matrixWorld = new Mi()),
      (this.raycast = this.MeshLineRaycast),
      Object.defineProperties(this, {
        geom: {
          enumerable: !0,
          get() {
            return this._geom;
          },
          set(t) {
            this.setGeometry(t);
          },
        },
        points: {
          enumerable: !0,
          get() {
            return this._points;
          },
          set(t) {
            this.setPoints(t);
          },
        },
      });
  }
  setMatrixWorld(t) {
    this.matrixWorld = t;
  }
  setGeometry(t, e) {
    this.process(t, e);
  }
  compareV3(t, e) {
    const i = 6 * t,
      n = 6 * e;
    return (
      this.positions[i] === this.positions[n] &&
      this.positions[i + 1] === this.positions[n + 1] &&
      this.positions[i + 2] === this.positions[n + 2]
    );
  }
  copyV3(t) {
    const e = 6 * t;
    return [this.positions[e], this.positions[e + 1], this.positions[e + 2]];
  }
  process(t, e) {
    const i = e.curveLen,
      n = e.lineConfig,
      r = e.symbolConfig;
    this._processIndex(t),
      this._processSide(t),
      this._processUV(t, i),
      this._processPosition(t);
    const o = t.length / 6;
    for (let a = 0; a < o; a++)
      this.lens.push(i),
        this.lens.push(i),
        this.lineConfig.push(n.lineType),
        this.lineConfig.push(n.blurRatio),
        this.lineConfig.push(n.lineHeadRatio),
        this.lineConfig.push(n.lineTextureNum),
        this.lineConfig.push(n.lineType),
        this.lineConfig.push(n.blurRatio),
        this.lineConfig.push(n.lineHeadRatio),
        this.lineConfig.push(n.lineTextureNum),
        this.symbolConfig.push(r.symbolType),
        this.symbolConfig.push(r.symbolNum),
        this.symbolConfig.push(r.symbolAspect),
        this.symbolConfig.push(r.symbolType),
        this.symbolConfig.push(r.symbolNum),
        this.symbolConfig.push(r.symbolAspect);
  }
  _processIndex(t) {
    for (
      let e = this.positions.length / 3, i = t.length / 6, n = 0;
      n < i - 1;
      n++
    ) {
      const t = 2 * n + e;
      this.indices.push(t, 1 + t, 2 + t),
        this.indices.push(2 + t, 1 + t, 3 + t);
    }
  }
  _processPosition(t) {
    const e = t.length / 6;
    let i, n;
    for (n = 0; n < e; n++)
      this.counters.push((i = n / (e - 1))), this.counters.push(i);
    this.positions.push.apply(this.positions, t);
    const r = t.length / 6;
    let o = DV(0, r - 1, t) ? TV(r - 2, t) : TV(0, t);
    this.previous.push(o[0], o[1], o[2]), this.previous.push(o[0], o[1], o[2]);
    for (let a = 0; a < r - 1; a++)
      (o = TV(a, t)),
        this.previous.push(o[0], o[1], o[2]),
        this.previous.push(o[0], o[1], o[2]);
    for (let a = 1; a < r; a++)
      (o = TV(a, t)),
        this.next.push(o[0], o[1], o[2]),
        this.next.push(o[0], o[1], o[2]),
        (o = DV(r - 1, 0, t) ? TV(1, t) : TV(r - 1, t)),
        this.next.push(o[0], o[1], o[2]),
        this.next.push(o[0], o[1], o[2]);
  }
  _processUV(t, e) {
    let i;
    if (2 < arguments.length && void 0 !== arguments[2] && arguments[2]) {
      let n, r;
      this.uvs.push(0, 0), this.uvs.push(0, 1), (i = t.length);
      for (let o = 0, a = 6; a < i; a += 6)
        (n = [t[a - 6], t[a - 6 + 1], t[a - 6 + 2]]),
          (r = [t[a], t[a + 1], t[a + 2]]),
          (o += Math.sqrt(
            Math.pow(r[0] - n[0], 2) +
              Math.pow(r[1] - n[1], 2) +
              Math.pow(r[2] - n[2], 2)
          )),
          this.uvs.push((r = o / e), 0),
          this.uvs.push(r, 1);
    } else {
      i = t.length / 6;
      for (let t = 0; t < i; t++)
        this.uvs.push(t / (i - 1), 0), this.uvs.push(t / (i - 1), 1);
    }
  }
  _processSide(t) {
    const e = t.length / 6;
    let i;
    for (i = 0; i < e; i++) this.side.push(1), this.side.push(-1);
  }
  createGeometry() {
    const t = new gn(new Float32Array(this.positions), 3),
      e = new gn(new Float32Array(this.previous), 3),
      i = new gn(new Float32Array(this.next), 3),
      n = new gn(new Float32Array(this.side), 1),
      r = new gn(new Float32Array(this.uvs), 2),
      o = new gn(new Uint32Array(this.indices), 1),
      a = new gn(new Float32Array(this.counters), 1),
      s = new gn(new Float32Array(this.lens), 1),
      l = new gn(new Float32Array(this.lineLengths), 1),
      u = new gn(new Float32Array(this.lineConfig), 4),
      c = new gn(new Float32Array(this.symbolConfig), 3);
    this.geometry.setAttribute("position", t),
      this.geometry.setAttribute("previous", e),
      this.geometry.setAttribute("next", i),
      this.geometry.setAttribute("side", n),
      this.geometry.setAttribute("uv", r),
      this.geometry.setAttribute("counters", a),
      this.geometry.setAttribute("len", s),
      this.geometry.setAttribute("lineLength", l),
      this.geometry.setAttribute("lineConfig", u),
      this.geometry.setAttribute("symbolConfig", c),
      this.geometry.setIndex(o);
  }
  advance(t) {
    const e = this._attributes.position.array,
      i = this._attributes.previous.array,
      n = this._attributes.next.array,
      r = e.length;
    EV(e, 0, i, 0, r),
      EV(e, 6, e, 0, r - 6),
      (e[r - 6] = t.x),
      (e[r - 5] = t.y),
      (e[r - 4] = t.z),
      (e[r - 3] = t.x),
      (e[r - 2] = t.y),
      (e[r - 1] = t.z),
      EV(e, 6, n, 0, r - 6),
      (n[r - 6] = t.x),
      (n[r - 5] = t.y),
      (n[r - 4] = t.z),
      (n[r - 3] = t.x),
      (n[r - 2] = t.y),
      (n[r - 1] = t.z),
      (this._attributes.position.needsUpdate = !0),
      (this._attributes.previous.needsUpdate = !0),
      (this._attributes.next.needsUpdate = !0);
  }
  clear() {
    (this.positions.length = 0),
      (this.previous.length = 0),
      (this.next.length = 0),
      (this.side.length = 0),
      (this.width.length = 0),
      (this.indices.length = 0),
      (this.uvs.length = 0),
      (this.counters.length = 0),
      (this.lens.length = 0),
      (this.lineLengths.length = 0),
      (this.lineConfig.length = 0),
      (this.symbolConfig.length = 0);
  }
  MeshLineRaycast(t, e) {
    const i = new Mi(),
      n = new Si(),
      r = new fi(),
      o = new Ye(),
      a = this.geometry;
    if (
      (a.boundingSphere || a.computeBoundingSphere(),
      r.copy(a.boundingSphere),
      r.applyMatrix4(this.matrixWorld),
      !1 === t.ray.intersectSphere(r, o))
    )
      return;
    i.copy(this.matrixWorld).invert(), n.copy(t.ray).applyMatrix4(i);
    const s = new Ye(),
      l = new Ye(),
      u = new Ye(),
      c = this instanceof vs ? 2 : 1,
      h = a.index,
      p = a.attributes;
    if (null !== h) {
      const i = h.array,
        r = p.position.array,
        a = p.width.array;
      for (let h = 0, p = i.length - 1; h < p; h += c) {
        const c = i[h],
          d = i[h + 1];
        s.fromArray(r, 3 * c), l.fromArray(r, 3 * d);
        const f = void 0 !== a[Math.floor(h / 3)] ? a[Math.floor(h / 3)] : 1,
          g = t.params.Line.threshold + (this.material.lineWidth * f) / 2,
          m = g * g;
        if (n.distanceSqToSegment(s, l, o, u) > m) continue;
        o.applyMatrix4(this.matrixWorld);
        const y = t.ray.origin.distanceTo(o);
        y < t.near ||
          y > t.far ||
          (e.push({
            distance: y,
            point: u.clone().applyMatrix4(this.matrixWorld),
            index: h,
            face: null,
            faceIndex: null,
            object: this,
          }),
          (h = p));
      }
    }
  }
}
class LV extends Jn {
  constructor(t) {
    super({
      uniforms: Object.assign({}, fr.fog, {
        bboxScale: {
          value: 1,
        },
        opacity: {
          value: 1,
        },
        lineLengthMax: {
          value: 105,
        },
        lineLength: {
          value: 30,
        },
        lineWidth: {
          value: 10,
        },
        lineColor: {
          value: new je(1, 1, 0, 0.85),
        },
        lineHeadColor: {
          value: new je(1, 0, 0, 1),
        },
        lineHeadRatio: {
          value: 0,
        },
        symbolColor: {
          value: new je(1, 1, 0, 1),
        },
        map: {
          value: null,
        },
        map1: {
          value: null,
        },
        alphaMap: {
          value: null,
        },
        resolution: {
          value: new Le(1, 1),
        },
        sizeAttenuation: {
          value: 1,
        },
        near: {
          value: 1,
        },
        far: {
          value: 1e9,
        },
        visibility: {
          value: 1,
        },
        dashOffset: {
          value: 0,
        },
        useDash: {
          value: 0,
        },
        alphaTest: {
          value: 0,
        },
        repeat: {
          value: new Le(1, 1),
        },
        uvScale: {
          value: new Le(1, 1),
        },
      }),
      vertexShader:
        "#define GLSLIFY 1\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float len;\nattribute vec4 lineConfig;\nattribute vec3 symbolConfig;\n\nuniform float lineLengthMax;\nuniform float lineLength;\nuniform float lineWidth;\nuniform vec4 lineColor;\nuniform vec4 lineHeadColor;\nuniform float lineHeadRatio;\nuniform vec4 symbolColor;\nuniform vec2 resolution;\nuniform float near;\nuniform float far;\nuniform uint sizeAttenuation;\nuniform float dashOffset;\nuniform float bboxScale;\n\nvarying vec4 vLineColor;\nvarying vec2 vNormal;\nvarying float vLineType;\nvarying float vBlurRatio;\nvarying vec4 vLineHeadColor;\nvarying float vLineHeadRatio;\nvarying float vLineSeg;\nvarying vec4 vSymbolColor;\nvarying vec3 vSymbolConfig;\nout vec2 vUv;\nflat out float lineAspect;\n\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <fog_pars_vertex>\n\nvoid main() {\n  vLineColor = lineColor;\n  vLineHeadColor = lineHeadColor;\n  vSymbolColor = symbolColor;\n\n  vLineType = lineConfig.x * 100.0;\n  vBlurRatio = lineConfig.y;\n  vLineHeadRatio = lineHeadRatio;\n\n  vSymbolConfig = symbolConfig;\n  float len_step = (lineLengthMax - lineLength) / 100.0;\n  vLineSeg = len * len_step / bboxScale * 0.0000001;\n\n  vUv = uv;\n  float aspect = resolution.x / resolution.y;\n  float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);\n  vec2 aspectVec = vec2(aspect, 1.0);\n\n  lineAspect = len / lineWidth / aspect;\n\n  mat4 mvp = projectionMatrix * modelViewMatrix;\n  vec4 projected = mvp * vec4(position, 1.0);\n  vec4 preProjected = mvp * vec4(previous, 1.);\n  vec4 nextProjected = mvp * vec4(next, 1.);\n\n  vec2 screen = projected.xy / projected.w * aspectVec;\n  vec2 preScreen = preProjected.xy / preProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n  float pixelWidth = sizeAttenuation == 1u ? 1.0 : projected.w * pixelWidthRatio;\n\n  float width = lineWidth;\n\n#ifdef USE_MAP\n\n#else\n  float dist = 1.0;\n  float segLen = mod(uv.x - dashOffset, 1.0 / vLineSeg);\n  float segRatio = segLen * vLineSeg;\n\n  float blurRange = 0.1;\n  float ratio = vLineHeadRatio + blurRange;\n  if(segRatio > ratio) {\n    dist = (segRatio - ratio) / (1.0 - ratio);\n  } else if(segRatio > ratio - blurRange) {\n    dist = pow((ratio - segRatio) / blurRange, 3.0);\n  }\n  width = mix(lineWidth, lineWidth, saturate(dist));\n#endif\n\n  width *= 1.8 * pixelWidth;\n\n  vec2 dir = vec2(0.0);\n  if(nextScreen == screen) \n    dir = normalize(screen - preScreen);\n  else if(preScreen == screen) \n    dir = normalize(nextScreen - screen);\n  else {\n    vec2 dir1 = normalize(screen - preScreen);\n    vec2 dir2 = normalize(nextScreen - screen);\n    dir = normalize(dir1 + dir2);\n  }\n\n  vNormal = normalize(vec2(-dir.y / aspect, dir.x) * side); \n\n  vec4 normalVec4 = vec4(-dir.y, dir.x, 0., 1.);\n  normalVec4.xy *= .5 * width;\n  normalVec4 *= projectionMatrix;\n  vec2 normal = normalVec4.xy;\n\n  vec4 offset = vec4(normal * side, 0., 0.);\n  gl_Position = projected + offset;\n\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  #include <fog_vertex>\n}",
      fragmentShader:
        "#define GLSLIFY 1\nuniform vec3 color;\nuniform float opacity;\n\n#ifdef USE_MAP\nuniform sampler2D map;\nuniform sampler2D map1;\n#endif\n\n#ifdef USE_ALPHA_MAP\nuniform sampler2D alphaMap;\n#endif\n\nuniform float visibility;\nuniform uint useDash;\nuniform float dashOffset;\nuniform float alphaTest;\nuniform vec2 uvScale;\n\nvarying vec2 vNormal;\nvarying vec4 vLineColor;\nvarying float vBlurRatio;\nvarying float vLineType;\nvarying vec4 vLineHeadColor;\nvarying float vLineHeadRatio;\nvarying float vLineSeg;\nvarying vec4 vSymbolColor;\nvarying vec3 vSymbolConfig;\n\nin vec2 vUv;\nflat in float lineAspect;\n\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <fog_pars_fragment>\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  #include <logdepthbuf_fragment>\n  vec4 c = vLineColor;\n\n  vec2 uv0 = vUv * uvScale;\n  uv0.x *= vLineSeg;\n  uv0.x -= dashOffset;\n  uv0.y = (vLineType - 1.0 + vUv.y) * 0.2;\n\n  float blur = 1.0;\n  float lineLen = length(vNormal) - (1.0 - vBlurRatio);\n  if(lineLen > 0.0) {\n    blur = 1.0 - lineLen / vBlurRatio;\n  }\n  blur *= blur;\n\n  vec4 texture1 = vec4(0.0);\n  float symbolLen = 1.0;\n\n#ifdef USE_MAP\n  vec4 texture0 = texture2D(map, uv0);\n\n  float segU = mod(uv0.x + dashOffset, 1.0);\n  symbolLen = vSymbolConfig.z * 100.0 / lineAspect * vLineSeg;\n\n  if(segU < symbolLen) {\n    segU = segU / symbolLen;\n\n    vec2 uv1 = vec2(segU, vUv.y);\n    uv1.y = (vSymbolConfig.x * 100.0 - 1.0 + vUv.y) / (vSymbolConfig.y * 100.0);\n\n    float endBlurLen = 0.08;\n    float endBlurFactor = 1.0;\n    if(segU < endBlurLen) {\n      endBlurFactor = pow((segU / endBlurLen), 3.0);\n    } else if(segU > 1.0 - endBlurLen) {\n      endBlurFactor = pow((1.0 - segU) / endBlurLen, 3.0);\n    }\n    texture1 = vSymbolColor * texture2D(map1, uv1) * endBlurFactor;\n  }\n\n  texture0 *= blur; \n  texture0 = mix(vec4(.0), texture0, texture0.a);\n  texture1 = mix(texture1, vec4(1.0), texture1);\n\n  c = c * texture0;\n  if(vSymbolColor.w > 0.0) {\n    c += texture1;\n  }\n#endif\n\n#ifdef USE_ALPHA_MAP\n  c.a *= texture2D(alphaMap, uv0).a;\n\n  texture1.a *= texture2D(alphaMap, uv0).a;\n#endif\n\n#include <alphatest_fragment>\n  if(c.a < alphaTest)\n    discard;\n\n  float dist = 1.0;\n  float blurRange = 0.1;\n\n  float ratio = vLineHeadRatio + blurRange;\n  float segLen = mod(uv0.x + vLineHeadRatio, 1.0);\n  float segRatio = segLen;\n\n  if(vLineHeadRatio == 0.0) {\n    dist = 0.0;\n    gl_FragColor = c;\n  } else {\n    if(segRatio > ratio) {\n      dist = pow((segRatio - ratio) / (1.0 - ratio), 4.0);\n    } else if(segRatio > vLineHeadRatio) {\n      dist = pow((segRatio - vLineHeadRatio) * blurRange, 4.0);\n    }\n  }\n  dist = saturate(dist);\n\n  if(vLineHeadColor.w > 0.0) {\n    gl_FragColor = mix(c, vLineHeadColor, dist);\n  } else {\n    gl_FragColor = c;\n  }\n\n  gl_FragColor.a *= blur;\n\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n}",
    }),
      (this.isMeshLineMaterial = !0),
      (this.type = "MeshLineMaterial"),
      this.setValues(t);
  }
  get bboxScale() {
    return this.uniforms.bboxScale.value;
  }
  set bboxScale(t) {
    this.uniforms.bboxScale.value = t;
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  get sizeAttenuation() {
    return this.uniforms.sizeAttenuation.value;
  }
  set sizeAttenuation(t) {
    this.uniforms.sizeAttenuation.value = t;
  }
  get color() {
    return this.uniforms.color.value;
  }
  set color(t) {
    this.uniforms.color.value = t;
  }
  get lineOpacity() {
    return this.uniforms.opacity.value;
  }
  set lineOpacity(t) {
    this.uniforms.opacity.value = t;
  }
  get lineWidth() {
    return this.uniforms.lineWidth.value;
  }
  set lineWidth(t) {
    this.uniforms.lineWidth.value = t;
  }
  get lineLengthMax() {
    return this.uniforms.lineLengthMax.value;
  }
  set lineLengthMax(t) {
    this.uniforms.lineLengthMax.value = t;
  }
  get lineLength() {
    return this.uniforms.lineLength.value;
  }
  set lineLength(t) {
    this.uniforms.lineLength.value = t;
  }
  get lineColor() {
    return this.uniforms.lineColor.value;
  }
  set lineColor(t) {
    this.uniforms.lineColor.value = t;
  }
  get lineHeadColor() {
    return this.uniforms.lineHeadColor.value;
  }
  set lineHeadColor(t) {
    this.uniforms.lineHeadColor.value = t;
  }
  get lineHeadRatio() {
    return this.uniforms.lineHeadRatio.value;
  }
  set lineHeadRatio(t) {
    this.uniforms.lineHeadRatio.value = t;
  }
  get lineAlphaTest() {
    return this.uniforms.alphaTest.value;
  }
  set lineAlphaTest(t) {
    this.uniforms.alphaTest.value = t;
  }
  get symbolColor() {
    return this.uniforms.symbolColor.value;
  }
  set symbolColor(t) {
    this.uniforms.symbolColor.value = t;
  }
  get map() {
    return this.uniforms.map.value;
  }
  set map(t) {
    this.uniforms.map.value = t;
  }
  get map1() {
    return this.uniforms.map1.value;
  }
  set map1(t) {
    this.uniforms.map1.value = t;
  }
  get useMap() {
    return this.uniforms.useMap.value;
  }
  set useMap(t) {
    this.uniforms.useMap.value = t;
  }
  get alphaMap() {
    return this.uniforms.alphaMap.value;
  }
  set alphaMap(t) {
    this.uniforms.alphaMap.value = t;
  }
  get useAlphaMap() {
    return this.uniforms.useAlphaMap.value;
  }
  set useAlphaMap(t) {
    this.uniforms.useAlphaMap.value = t;
  }
  get dashArray() {
    return this.uniforms.dashArray.value;
  }
  set dashArray(t) {
    (this.uniforms.dashArray.value = t), (this.useDash = 0 !== t ? 1 : 0);
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  get dashRatio() {
    return this.uniforms.dashRatio.value;
  }
  set dashRatio(t) {
    this.uniforms.dashRatio.value = t;
  }
  get useDash() {
    return this.uniforms.useDash.value;
  }
  set useDash(t) {
    this.uniforms.useDash.value = t;
  }
  get visibility() {
    return this.uniforms.visibility.value;
  }
  set visibility(t) {
    this.uniforms.visibility.value = t;
  }
  get repeat() {
    return this.uniforms.repeat.value;
  }
  set repeat(t) {
    this.uniforms.repeat.value.copy(t);
  }
  get near() {
    return this.uniforms.near.value;
  }
  set near(t) {
    this.uniforms.near.value = t;
  }
  get far() {
    return this.uniforms.far.value;
  }
  set far(t) {
    this.uniforms.far.value = t;
  }
  get uvScale() {
    return this.uniforms.uvScale.value;
  }
  set uvScale(t) {
    this.uniforms.uvScale.value = t;
  }
}
const IV = {
  lineType1: [
    {
      percent: 0,
      opacity: 1,
    },
    {
      percent: 1,
      opacity: 1,
    },
  ],
  lineType2: [
    {
      percent: 0,
      opacity: 0,
    },
    {
      percent: 1,
      opacity: 1,
    },
  ],
  lineType3: [
    {
      percent: 0,
      opacity: 0.1,
    },
    {
      percent: 0.25,
      opacity: 1,
    },
    {
      percent: 0.5,
      opacity: 1,
    },
    {
      percent: 1,
      opacity: 0,
    },
  ],
  lineType4: [
    {
      percent: 0,
      opacity: 0.25,
    },
    {
      percent: 0.1,
      opacity: 1,
    },
    {
      percent: 0.2,
      opacity: 0.25,
    },
    {
      percent: 0.3,
      opacity: 1,
    },
    {
      percent: 0.4,
      opacity: 0.25,
    },
    {
      percent: 0.5,
      opacity: 1,
    },
    {
      percent: 0.6,
      opacity: 0.25,
    },
    {
      percent: 0.7,
      opacity: 1,
    },
    {
      percent: 0.8,
      opacity: 0.25,
    },
    {
      percent: 0.9,
      opacity: 1,
    },
    {
      percent: 1,
      opacity: 0.25,
    },
  ],
  lineType5: [
    {
      percent: 0,
      opacity: 1,
    },
    {
      percent: 0.05,
      opacity: 1,
    },
    {
      percent: 0.05,
      opacity: 0,
    },
    {
      percent: 0.1,
      opacity: 0,
    },
    {
      percent: 0.1,
      opacity: 1,
    },
    {
      percent: 0.15,
      opacity: 1,
    },
    {
      percent: 0.15,
      opacity: 0,
    },
    {
      percent: 0.2,
      opacity: 0,
    },
    {
      percent: 0.2,
      opacity: 1,
    },
    {
      percent: 0.25,
      opacity: 1,
    },
    {
      percent: 0.25,
      opacity: 0,
    },
    {
      percent: 0.3,
      opacity: 0,
    },
    {
      percent: 0.3,
      opacity: 1,
    },
    {
      percent: 0.35,
      opacity: 1,
    },
    {
      percent: 0.35,
      opacity: 0,
    },
    {
      percent: 0.4,
      opacity: 0,
    },
    {
      percent: 0.4,
      opacity: 1,
    },
    {
      percent: 0.45,
      opacity: 1,
    },
    {
      percent: 0.45,
      opacity: 0,
    },
    {
      percent: 0.5,
      opacity: 0,
    },
    {
      percent: 0.5,
      opacity: 1,
    },
    {
      percent: 0.55,
      opacity: 1,
    },
    {
      percent: 0.55,
      opacity: 0,
    },
    {
      percent: 0.6,
      opacity: 0,
    },
    {
      percent: 0.6,
      opacity: 1,
    },
    {
      percent: 0.65,
      opacity: 1,
    },
    {
      percent: 0.65,
      opacity: 0,
    },
    {
      percent: 0.7,
      opacity: 0,
    },
    {
      percent: 0.7,
      opacity: 1,
    },
    {
      percent: 0.75,
      opacity: 1,
    },
    {
      percent: 0.75,
      opacity: 0,
    },
    {
      percent: 0.8,
      opacity: 0,
    },
    {
      percent: 0.8,
      opacity: 1,
    },
    {
      percent: 0.85,
      opacity: 1,
    },
    {
      percent: 0.85,
      opacity: 0,
    },
    {
      percent: 0.9,
      opacity: 0,
    },
    {
      percent: 0.9,
      opacity: 1,
    },
    {
      percent: 0.95,
      opacity: 1,
    },
    {
      percent: 0.95,
      opacity: 0,
    },
    {
      percent: 1,
      opacity: 0,
    },
  ],
};
class NV {
  constructor() {
    (this.state = null),
      (this.group = new As()),
      (this.handleAnimation = this.handleAnimation.bind(this));
  }
  set(t) {
    this.state = af(this.state, t);
    const { bboxOption: e, geojson: i, boundaryStreamer: n } = this.state,
      {
        lineLength: r,
        lineWidth: o,
        lineColor: a,
        lineHeadColor: s,
        lineHeadRatio: l,
      } = n,
      u = sm(
        lV({
          type: "FeatureCollection",
          features: am.flatten(Object.assign({}, i)).features,
        }),
        Qf
      ).features,
      c = EA(a),
      h = EA(s),
      p = (function () {
        const t = document.createElement("canvas");
        (t.width = 100),
          (t.height = 100),
          (t.style.width = "100px"),
          (t.style.height = "100px");
        const e = t.getContext("2d", {
            preserveDrawingBuffer: !0,
          }),
          i = e.createLinearGradient(0, 0, 100, 0);
        let n = 20;
        for (const o in IV) {
          const t = IV[o],
            r = {
              r: 255,
              g: 255,
              b: 255,
              a: 1,
            };
          for (let e = 0; e < t.length; e++) {
            const n = t[e],
              o = n.percent,
              a = n.opacity,
              s = ~~((r.r - r.r) * o + r.r),
              l = ~~((r.g - r.g) * o + r.g),
              u = ~~((r.b - r.b) * o + r.b),
              c = a * r.a;
            i.addColorStop(
              n.percent,
              "rgba(" + s + "," + l + "," + u + "," + c + ")"
            );
          }
          (e.fillStyle = i), e.fillRect(0, 100 - n, 100, 20), (n += 20);
        }
        const r = new Es(t);
        return (r.wrapS = r.wrapT = kt), r;
      })();
    (this.material = new LV({
      resolution: new Le(1920, 1080),
      sizeAttenuation: !1,
      side: xt,
      blending: 2,
      lineLength: r,
      lineWidth: o,
      lineColor: new je(c.color.r, c.color.g, c.color.b, c.opacity),
      lineHeadColor: new je(h.color.r, h.color.g, h.color.b, h.opacity),
      lineHeadRatio: l,
      visibility: 1,
      dashOffset: 0,
      map: p,
      map1: null,
      uvScale: new Le(1, 1),
      depthWrite: !1,
      depthTest: !0,
      depthFunc: 1,
      transparent: !0,
    })),
      (this.material.uniforms.bboxScale.value = 0.02 * e.bboxScale),
      (this.material.needsUpdate = !0);
    const d = new PV();
    for (let g = 0; g < u.length; g++) {
      const t = [],
        e = u[g].geometry.coordinates;
      for (let o = 0; o < e[0].length; o++) {
        const i = e[0][o],
          n = i[0],
          r = i[1];
        t.push(n, r, 0, n, r, 0);
      }
      let i,
        n,
        r = 0;
      for (let o = 0; o < t.length - 6; o += 6)
        (i = [t[o], t[o + 1]]),
          (n = [t[o + 6], t[o + 6 + 1]]),
          (r += Math.sqrt(Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2)));
      d.setGeometry(t, {
        curveLen: r,
        isGeoUv: !1,
        lineConfig: {
          lineType: 0.02,
          blurRatio: 0,
          lineTextureNum: 0.05,
        },
        symbolConfig: {
          symbolType: 0.01,
          symbolNum: 0.01,
          symbolAspect: 0.01,
        },
      });
    }
    d.createGeometry();
    const f = new Wn(d.geometry, this.material);
    f.setRenderIndex(lU.BOUNDARY_STREAMER_MESH),
      (f.frustumCulled = !1),
      this.group.traverse(function (t) {
        "Mesh" === t.type && (t.geometry.dispose(), t.material.dispose());
      }),
      this.group.add(f);
  }
  handleAnimation() {
    if (this.material) {
      const { boundaryStreamer: t } = this.state;
      this.material.uniforms.dashOffset.value -= 5e-4 * t.speed;
    }
  }
}
function RV(t) {
  const e = new En();
  return (
    e.setIndex(new gn(new Uint32Array(t.index), 1)),
    e.setAttribute("position", new gn(new Float32Array(t.position), 3)),
    e.setAttribute("normal", new gn(new Float32Array(t.normal), 3)),
    e.setAttribute("uv", new gn(new Float32Array(t.uv), 2)),
    e.computeBoundingSphere(),
    e.computeBoundingBox(),
    e
  );
}
const OV = (t, e, i, n) => {
  let r, o, a;
  switch (n) {
    case "extrude":
      (r = t.extrudeTopMaterial), (o = t.gis.globalOpts.bboxOption), (a = !1);
      break;
    case "extrude-background":
      (r = t.extrudeBackgroundTopMaterial),
        (o = t.gis.globalOpts.backgroundBboxOption),
        (a = !0);
  }
  !(function (t) {
    return (
      t.indexOf("{x}") > -1 && t.indexOf("{y}") > -1 && t.indexOf("{z}") > -1
    );
  })(e)
    ? t.textureManager(`${n}-${i}`).setTexture(
        (r) => {
          t.textureManager(`${n}-${i}`).loader.load(e, (t) => {
            r(t);
          });
        },
        (t) => {
          switch (i) {
            case "map":
              (r.map = t), (r.color = CU);
              break;
            case "normalMap":
              r.normalMap = t;
              break;
            case "emissiveMap":
              (r.emissiveMap = t), (r.emissiveIntensity = 1);
          }
          r.needsUpdate = !0;
        }
      )
    : t.textureManager(`${n}-${i}`).setTexture(
        (t) => {
          !(function (t) {
            const {
                tileUrl: e,
                bboxOption: i,
                maxZoom: n,
                cb: r,
                isExtrudeBackground: o,
              } = t,
              { bbox: a, bboxProj: s, size: l } = i,
              u = MV({
                tileUrl: e,
                bbox: a,
                maxZoom: n,
                worldBboxSize: Vf,
                bboxOption: i,
                isExtrudeBackground: o,
              }),
              {
                minCol: c,
                maxCol: h,
                minRow: p,
                maxRow: d,
                tilesInfo: f,
                tileBboxProj: g,
              } = u,
              m = [];
            for (let y = 0; y < f.length; y++) {
              const t = f[y],
                e = new Promise((e, i) => {
                  fetch(t.url).then((i) => {
                    i.blob().then((i) => {
                      createImageBitmap(i).then((i) => {
                        (t.imageBitmap = i), e(t);
                      });
                    });
                  });
                });
              m.push(e);
            }
            Promise.all(m)
              .then((t) => {
                const e = document.createElement("canvas");
                (e.width = (256 * (h - c + 1) * l.width) / g.width),
                  (e.height = (256 * (d - p + 1) * l.height) / g.height),
                  (e.style.width =
                    (256 * (h - c + 1) * l.width) / g.width + "px"),
                  (e.style.height =
                    (256 * (d - p + 1) * l.height) / g.height + "px");
                const i = e.getContext("2d");
                for (let r = 0; r < t.length; r++) {
                  const e = t[r],
                    n =
                      256 * (e.col - c) -
                      (Math.abs(s[0] - g.leftTop[0]) * (h - c + 1) * 256) /
                        g.width,
                    o =
                      256 * (e.row - p) -
                      (Math.abs(s[3] - g.leftTop[1]) * (d - p + 1) * 256) /
                        g.height;
                  i.drawImage(e.imageBitmap, n, o, 256, 256);
                }
                const n = new Es(e);
                (n.wrapS = n.wrapT = kt), n.repeat.set(1, 1), r(n);
              })
              .catch((t) => {});
          })({
            tileUrl: e,
            bboxOption: o,
            maxZoom: 12,
            imageType: i,
            isExtrudeBackground: a,
            cb: t,
          });
        },
        (t) => {
          switch (i) {
            case "map":
              (r.map = t), (r.color = CU);
              break;
            case "normalMap":
              r.normalMap = t;
              break;
            case "emissiveMap":
              (r.emissiveMap = t), (r.emissiveIntensity = 1);
          }
          r.needsUpdate = !0;
        }
      );
};
function FV(t, e) {
  let i, n, r, o, a;
  switch (e) {
    case "extrude":
      (a = t.extrudeTopMaterial),
        (i = t.state.districtStyle.fill.map),
        (n = t.state.districtStyle.fill.color),
        (r = t.state.districtStyle.fill.normalMap),
        (o = t.state.districtStyle.fill.normalScale),
        (a.metalness = t.state.districtStyle.fill.metalness),
        (a.roughness = t.state.districtStyle.fill.roughness);
      break;
    case "extrude-background":
      (a = t.extrudeBackgroundTopMaterial),
        (i = t.state.extrudeBackgroundStyle.fill.map),
        (n = t.state.extrudeBackgroundStyle.fill.color),
        (r = t.state.extrudeBackgroundStyle.fill.normalMap),
        (o = t.state.extrudeBackgroundStyle.fill.normalScale),
        (a.metalness = t.state.extrudeBackgroundStyle.fill.metalness),
        (a.roughness = t.state.extrudeBackgroundStyle.fill.roughness);
  }
  if (i) OV(t, i, "map", e);
  else {
    a.map = null;
    const i = n
      ? EA(n)
      : {
          color: CU,
          transparent: wU,
          opacity: 1,
        };
    n && t.textureManager(`${e}-map`).abort(),
      (a.color = i.color),
      (a.opacity = i.opacity),
      (a.transparent = i.transparent),
      (a.needsUpdate = !0);
  }
  r
    ? (OV(t, r, "normalMap", e), (a.normalScale = new Le(o, o)))
    : ((a.normalMap = null), (a.needsUpdate = !0));
}
function zV(t) {
  const {
    districtStyle: { innerShadow: e },
  } = t.state;
  if (e && e.enabled && e.shadowColor && e.shadowBlurScale) {
    const { bboxOption: i, boundary: n } = t.gis.globalOpts,
      r = (function (t) {
        const {
            geojson: e,
            bboxOption: i,
            maxZoom: n,
            shadowColor: r,
            shadowBlurScale: o,
          } = t,
          { bbox: a } = i,
          s = MV({
            tileUrl: "",
            bbox: a,
            maxZoom: n,
            worldBboxSize: Vf,
            bboxOption: i,
            isExtrudeBackground: !1,
          }),
          { zoom: l } = s,
          u = wV(a[0], a[1], l),
          c = wV(a[2], a[3], l),
          h = Math.abs(u[0] - c[0]),
          p = Math.abs(u[1] - c[1]),
          d = document.createElement("canvas");

        console.log('o',r, o);
        (d.width = h),
          (d.height = p),
          (d.style.width = h + "px"),
          (d.style.height = p + "px");
        const f = d.getContext("2d"),
          g = {
            fill: !0,
            fillColor: r,
            shadowColor: r,
            shadowBlur: 100,
          },
          m = am.flatten(Object.assign({}, e));
        let y, v;
        console.log('m.features', m.features);

        for (y = 0; y < m.features.length; y++) {
          v = m.features[y];
          const t = am.bbox(v),
            e = wV(t[0], t[1], l),
            i = wV(t[2], t[3], l),
            n = Math.abs(e[0] - i[0]),
            r = Math.abs(e[1] - i[1]);
          if (n > 0 && r > 0) {
            g.shadowBlur = Math.min(n, r) * o;
            const t = AV({
              feature: v,
              zoom: l,
              style: g,
              width: n,
              height: r,
              offset: [e[0], i[1]],
            });
            console.log({
              feature: v,
              zoom: l,
              style: g,
              width: n,
              height: r,
              offset: [e[0], i[1]],
            },  t,
              Math.abs(e[0] - u[0]),
              Math.abs(i[1] - c[1]),
              t.width,
              t.height)
            f.drawImage(
              t,
              Math.abs(e[0] - u[0]),
              Math.abs(i[1] - c[1]),
              t.width,
              t.height
            );
          }
        }
        // // 生成图片数据URL（PNG格式，默认质量0.9）
        // const dataUrl = d.toDataURL('image/png', 0.9);

        // // 创建隐藏的下载链接
        // const link = document.createElement('a');
        // link.href = dataUrl;
        // link.download = `myImage-${y}.png`; // 自定义文件名
        // // 触发下载
        // document.body.appendChild(link);
        // link.click();
        // document.body.removeChild(link);

        return d;
      })({
        geojson: n,
        bboxOption: i,
        maxZoom: 12,
        shadowColor: e.shadowColor,
        shadowBlurScale: e.shadowBlurScale,
      });
    (t.extrudeInnerShadowMaterial.map = new Es(r)),
      (t.extrudeInnerShadowMaterial.opacity = 1),
      (t.extrudeInnerShadowMaterial.needsUpdate = !0);
  } else
    (t.extrudeInnerShadowMaterial.map = null),
      (t.extrudeInnerShadowMaterial.opacity = 0),
      (t.extrudeInnerShadowMaterial.needsUpdate = !0);
}
function kV(t) {
  var e;
  const {
    districtStyle: { boundaryStreamer: i },
  } = t.state;
  if (
    (null == (e = t.boundaryStreamerLayer) || e.group.destroy(), i && i.enabled)
  ) {
    const { bboxOption: e, boundary: n, layerFitValue: r } = t.gis.globalOpts,
      o = {
        geojson: n,
        bboxOption: e,
        layerFitValue: r,
        boundaryStreamer: i,
        viewportWidth: t.gis.props.containerDom.clientWidth,
        viewportHeight: t.gis.props.containerDom.clientHeight,
      },
      a = new NV();
    (t.boundaryStreamerLayer = a), a.set(o), t.districtStrokeGroup.add(a.group);
  }
}
function BV(t, e) {
  const { colorConfig: i } = e.sideConfig,
    { bottomColor: n, topColor: r, bottomOpacity: o, topOpacity: a } = GV(i);
  (t.uniforms.topColor.value = {
    color: r,
    opacity: a,
  }),
    (t.uniforms.bottomColor.value = {
      color: n,
      opacity: o,
    });
}
function GV(t) {
  let e, i, n, r;
  switch (t.range.length) {
    case 0:
      return console.error("[xGis]", "extrude range 不合法"), null;
    case 1:
      const o = EA(t.range[0]);
      (e = o.color), (i = o.color), (n = o.opacity), (r = o.opacity);
      break;
    case 2:
      const a = EA(t.range[0]);
      (e = a.color), (n = a.opacity);
      const s = EA(t.range[1]);
      (i = s.color), (r = s.opacity);
  }
  return {
    bottomColor: e,
    topColor: i,
    bottomOpacity: n,
    topOpacity: r,
  };
}
function UV(t, e) {
  const i = t.bboxProj,
    n = 1.4 * t.size.bboxSize,
    r = [i[0] - n, i[1] - n, i[2] + n, i[3] + n];
  (r[0] = Math.max(-Vf / 2, r[0])),
    (r[1] = Math.max(-Vf / 2, r[1])),
    (r[2] = Math.min(Vf / 2, r[2])),
    (r[3] = Math.min(Vf / 2, r[3]));
  const o = Zf([r[0], r[1]]),
    a = Zf([r[2], r[3]]),
    s = [o[0], o[1], a[0], a[1]],
    l = [-180, -85.05, 180, 85.05];
  (l[0] = Math.max(-180, s[0])),
    (l[1] = Math.max(-85.05, s[1])),
    (l[2] = Math.min(180, s[2])),
    (l[3] = Math.min(85.05, s[3]));
  const u = [(l[0] + l[2]) / 2, (l[1] + l[3]) / 2, 0],
    c = Qf([l[0], l[1], 0]),
    h = Qf([l[2], l[3], 0]),
    p = [c[0], c[1], h[0], h[1]],
    d = [(p[0] + p[2]) / 2, (p[1] + p[3]) / 2, 0],
    f = Math.abs(p[0] - p[2]),
    g = Math.abs(p[1] - p[3]),
    m = Math.min(f, g),
    y = Math.max(f, g),
    v = ~~(0.382 * m + 0.618 * y),
    b = {
      bbox: l,
      bboxProj: p,
      bbox2: s,
      center: u,
      centerProj: d,
      size: {
        width: f,
        height: g,
        minSize: m,
        maxSize: y,
        bboxSize: v,
      },
      bboxScale: v / Vf,
      baseHeight: 0.05 * t.size.bboxSize * 0.2,
    };
  return (e.gis.globalOpts.backgroundBboxOption = b), b;
}
function jV(t, e) {
  const i = e.extrudeBackgroundFillGroup.children.find(
    (t) => "Mesh" === t.type && "side" === t.userData.faceType
  );
  i && ((i.scale.z = t || 1), (i.position.z = 0));
  const n = e.extrudeBackgroundFillGroup.children.find(
    (t) => "Mesh" === t.type && "top" === t.userData.faceType
  );
  n && ((n.scale.z = t || 1), (n.position.z = 0));
}
async function HV(t, e = "all") {
  var i;
  if (!t.subDistrictData) return;
  const { layerManager: n } = t.gis,
    {
      poi: { major: r },
    } = t.state;
  t.subDistrictInfoArr = [];
  const o = null != (i = r.aliasMap) ? i : r.nameMap ? pf(r.nameMap) : null,
    a = (function (t) {
      const { subDistrictStyle: e } = t.state;
      if (e.stroke && e.stroke.width) {
        const i = new TD({
          color: new ln(e.stroke.color).getHex(),
          transparent: !0,
          opacity: e.stroke.opacity,
          linewidth: e.stroke.width,
        });
        return (
          i.resolution.set(
            t.gis.props.containerDom.clientWidth,
            t.gis.props.containerDom.clientHeight
          ),
          i
        );
      }
      return null;
    })(t),
    s = new pn({
      transparent: !0,
      color: CU,
      opacity: 0,
    });
  t.subDistrictData.forEach((i) => {
    var r;
    const l = i.properties.name,
      u = null != (r = o[l]) ? r : l,
      c = n.geo.project([i.properties.centroidx, i.properties.centroidy]),
      h = {
        adcode: i.properties.id,
        name: l,
        alias: u,
        lng: i.properties.centroidx,
        lat: i.properties.centroidy,
        centroid: c,
      };
    i.geometry.coordinates.forEach((n, r) => {
      u &&
        ((i, n, r, o) => {
          if (i.length > 2) {
            let l;
            const u = [],
              c = new qs();
            for (let t = 0; t < i.length; t++) {
              const [e, n] = i[t];
              0 === t && c.moveTo(e, n), c.lineTo(e, n), u.push(e, n, 0);
            }
            if (a) {
              (l = new YD()),
                l.setPositions(u),
                a.resolution.set(
                  t.gis.props.containerDom.clientWidth,
                  t.gis.props.containerDom.clientHeight
                );
              const e = new XD(l, a);
              e.setRenderIndex(lU.BASE_MAP_LAYER_PROVINCE_STROKE),
                t.subDistrictStrokeGroup.add(e);
            }
            if ("stroke" !== e) {
              const e = new NA(c),
                i = s.clone(),
                a = new Wn(e, i);
              a.setRenderIndex(lU.BASE_MAP_LAYER_PROVINCE_MESH),
                (a.name = `sub-district-${o.alias}-${n}`),
                (a.ext = af(r.properties, o)),
                t.subDistrictFillGroup.add(a);
            }
          }
        })(n, r, i, h);
    }),
      u &&
        !t.subDistrictInfoArr.find((t) => t.adcode == h.adcode) &&
        t.subDistrictInfoArr.push(h);
  });
}
function VV(t, e) {
  if (sf(t, "stroke")) {
    const i = EA(t.stroke.color);
    0 === e.subDistrictStrokeGroup.children.length
      ? HV(e, "stroke")
      : e.subDistrictStrokeGroup.children.forEach((e) => {
          const n = e.material;
          n &&
            ((n.color = i.color),
            (n.opacity = DA(i, t.stroke.opacity)),
            (n.linewidth = t.stroke.width));
        });
  }
}
function WV(t) {
  var e, i;
  t.clearPoiGroup(), t.clearInteractionGroup(), (t.coreGroup.visible = !1);
  const n = null == (e = t.drillCache[t.currentCode]) ? void 0 : e.group;
  n
    ? ((t.coreGroup = n),
      (t.coreGroup.visible = !0),
      (t.subDistrictInfoArr =
        null == (i = t.drillCache[t.currentCode])
          ? void 0
          : i.subDistrictInfoArr),
      (t.subDistrictFillGroup = t.coreGroup.children.find(
        (t) => "sub-district-fill" === t.name
      )),
      (t.listenerObj = t.subDistrictFillGroup),
      (t.subDistrictStrokeGroup = t.coreGroup.children.find(
        (t) => "sub-district-stroke" === t.name
      )),
      (t.districtFillGroup = t.coreGroup.children.find(
        (t) => "district-fill" === t.name
      )),
      (t.districtStrokeGroup = t.coreGroup.children.find(
        (t) => "district-stroke" === t.name
      )),
      (t.districtBottomStrokeGroup = t.coreGroup.children.find(
        (t) => "district-bottom-stroke" === t.name
      )),
      (t.extrudeBackgroundFillGroup = t.coreGroup.children.find(
        (t) => "extrude-background-fill" === t.name
      )))
    : ((t.coreGroup = new As()),
      (t.coreGroup.name = `base-map-layer-core-${t.currentCode}`),
      t.group.add(t.coreGroup),
      t.__releaseLayerGroup(),
      uV(t),
      HV(t)),
    t.scaleAdaptation(),
    UV(t.gis.globalOpts.bboxOption, t),
    n
      ? (!(function (t, e) {
          cV(t, e), hV(t, e);
        })(t.state.districtStyle, t),
        VV(t.state.subDistrictStyle, t),
        t.updateExtrudeStyle(),
        t.updateBaseHeight())
      : (t.initExtrude(), t.updateExtrudeStyle()),
    t.initPOI();
}
function qV(t, e) {
  if (!t) return -1;
  return t.default.findIndex((t) => !!t.get(e));
}
const YV = class {
  static async getGeoBuf2GeoJsonByUrl(t, e) {
    try {
      const i = await fetch(t),
        n = await i.arrayBuffer(),
        r = new ak(YV.dataSet),
        o = r.parse(n, {
          type: "geobuf",
          options: e,
        }).latestData;
      return r.destroy(), o;
    } catch (i) {
      return console.error("[xGis]", `${i}`), null;
    }
  }
  static async getGeoJsonByUrl(t, e) {
    try {
      const i = await fetch(t),
        n = await i.json(),
        r = new ak(YV.dataSet),
        o = r.parse(n, {
          type: "geojson",
          options: e,
        }).latestData;
      return r.destroy(), o;
    } catch (i) {
      return console.error("[xGis]", `${i}`), null;
    }
  }
  static getParentInfoByAdCode(t, e) {
    if (!e.layerManager.baseMapLayer)
      return void console.error(
        "[xGis]",
        "gis.layerManager.baseMapLayer 尚不存在，无法使用相关供工具函数，请确定初始化 gis 实例后再调用"
      );
    let i, n;
    const {
        drillData: r,
        state: {
          data: { region: o },
        },
      } = e.layerManager.baseMapLayer,
      a = qV(r, t);
    if (0 === a) {
      const e = !!o && Object.values(o).find((e) => e.adcode === t);
      (i = e ? Mk : null), (n = e ? 0 : -1);
    } else if (1 === a) {
      const e = !!o && Object.values(o).find((e) => e.child.includes(t));
      (i = e ? e.adcode : Mk), (n = 0);
    } else if (2 === a)
      try {
        (i = e.layerManager.baseMapLayer.drillData.default[a]
          .get(t)[0]
          .properties.acroutes.split(",")[1]),
          (n = 1);
      } catch (s) {
        return void console.error(
          "[xGis]",
          `无法匹配到对应数据, level ${a} 或 adcode ${t} 不合法`
        );
      }
    else if (3 === a)
      try {
        const r =
            e.layerManager.baseMapLayer.drillData.default[a].get(t)[0]
              .properties.acroutes,
          o = r.split(",")[1];
        Lk.includes(o) ? ((i = o), (n = 1)) : ((i = r.split(",")[2]), (n = 2));
      } catch (s) {
        return void console.error(
          "[xGis]",
          `无法匹配到对应数据, level ${a} 或 adcode ${t} 不合法`
        );
      }
    else n = -1;
    return {
      level: n,
      adcode: i,
    };
  }
  static getGeoCoordByAlias(t, e) {
    var i, n;
    if (!e.layerManager.baseMapLayer)
      return void console.error(
        "[xGis]",
        "gis.layerManager.baseMapLayer 尚不存在，无法使用相关供工具函数，请确定初始化 gis 实例后再调用"
      );
    const r =
        null !=
        (n = (
          null != (i = e.layerManager.baseMapLayer.state.data.nameMap)
            ? i
            : e.layerManager.baseMapLayer.state.poi.major.nameMap
        )[t])
          ? n
          : t,
      o = e.layerManager.baseMapLayer.subDistrictInfoArr.find(
        (t) => t.name === r
      );
    return o
      ? {
          lng: o.lng,
          lat: o.lat,
        }
      : void 0;
  }
  static getGeoCoord(t) {
    if (t.layerManager.baseMapLayer)
      return t.layerManager.baseMapLayer.subDistrictInfoArr.map((t) =>
        ot(rt({}, t), {
          lng: t.lng,
          lat: t.lat,
        })
      );
    console.error(
      "[xGis]",
      "gis.layerManager.baseMapLayer 尚不存在，无法使用相关供工具函数，请确定初始化 gis 实例后再调用"
    );
  }
  static getObjectCoordByID(t, e) {
    const i = e.sceneSystem.coreScene.getObjectById(t);
    if (!i)
      return console.error("[xGis]", `传入id ${t} 无法解析到对应Object`), null;
    const n = XH(i),
      r = QH(n.center, e.cameraSystem.coreCamera, e.state.containerDom),
      o = QH(n.top, e.cameraSystem.coreCamera, e.state.containerDom);
    return {
      screen: {
        top: {
          x: o.screenX,
          y: o.screenY,
        },
        center: {
          x: r.screenX,
          y: r.screenY,
        },
      },
    };
  }
  static getDistrictDataByAlias(t, e) {
    var i;
    if (!e.layerManager.baseMapLayer)
      return (
        console.error(
          "[xGis]",
          "gis.layerManager.baseMapLayer 尚不存在，无法使用相关供工具函数，请确定初始化 gis 实例后再调用"
        ),
        null
      );
    const n = e.layerManager.baseMapLayer.subDistrictFillGroup,
      r =
        null != (i = e.layerManager.baseMapLayer.state.poi.major.nameMap[t])
          ? i
          : t,
      o = n.children.find((t) => t.ext.name === r);
    if (!o)
      return (
        console.error("[xGis]", `传入name ${t} 无法解析到对应Object`), null
      );
    const a = QH(XH(o).center, e.cameraSystem.coreCamera, e.props.containerDom);
    return {
      x: a.screenX,
      y: a.screenY,
      properties: o.ext,
    };
  }
  static exportImage(t, e = "gis") {
    const { renderSystem: i } = t;
    try {
      const t = "image/jpeg",
        n = i.toDataURL(t),
        r = "image/octet-stream";
      !(function (t, e) {
        const i = document.createElement("a");
        "string" == typeof i.download
          ? (document.body.appendChild(i),
            (i.download = e),
            (i.href = t),
            i.click(),
            document.body.removeChild(i))
          : location.replace(t);
      })(n.replace(t, r), `${e}.jpg`);
    } catch (n) {
      console.error(n);
    }
  }
};
let XV = YV;
(XV.dataSet = new ok()),
  XV.dataSet.registerParser("geobuf", (t, e = {}, i) => {
    i.type = cF.GEO;
    const n = XO(Zz, $z, e),
      r = TF.decode(new pz(t));
    return Kz(r, n, i);
  }),
  XV.dataSet.registerParser("geojson", Kz);
const QV = {
  useProcess: !0,
  useProject: !0,
};
async function ZV(t, e) {
  if (!(null == t ? void 0 : t.data)) return null;
  const { type: i, data: n, simplify: r } = t,
    { useProject: o, useProcess: a } = af(QV, e);
  let s, l;
  switch (i) {
    case xk.GEOJSON:
      s = n;
      break;
    case xk.GEOJSON_URL:
      (l = t.data), (s = await XV.getGeoJsonByUrl(l));
      break;
    case xk.GEOBUF_URL:
      (l = t.data), (s = await XV.getGeoBuf2GeoJsonByUrl(l));
      break;
    case xk.GEOBUF:
    default:
      console.error("[xGis]", `地图数据 url ${l} 格式无法解析`);
  }
  return (
    (t.__raw_geojson__ = s),
    (t.__geojson__ = s),
    (null == r ? void 0 : r.enabled) &&
      (t.__geojson__ = am.simplify(t.__geojson__, r.tolerance)),
    a && (t.__geojson_process__ = lV(t.__geojson__)),
    o &&
      (t.__geojson_process_proj__ = sm(
        a ? t.__geojson_process__ : t.__geojson__,
        Qf
      )),
    t
  );
}
const JV = {
  bboxSize: 68016,
  height: 50503.97002946732,
  maxSize: 68565.51601500002,
  minSize: 50503.97002946732,
  width: 68565.51601500002,
};
function KV(t) {
  const {
      geojson: e,
      geojsonProj: i,
      geojsonUtil: n,
      worldBboxSize: r,
      heightScale: o,
      pitch: a,
      rotation: s,
      offset: l,
      viewClip: u,
    } = t,
    c = n.bbox(i);
  let h = c;
  u &&
    (h = (function (t, e, i) {
      const n = [0, 0, 0, 0];
      switch (i) {
        case "bottom-right":
          (n[0] = t[0]),
            (n[1] = Math.max(t[1], e[3])),
            (n[2] = Math.min(t[2], e[0])),
            (n[3] = t[3]);
          break;
        case "bottom":
          (n[0] = t[0]),
            (n[1] = Math.max(t[1], e[3])),
            (n[2] = t[2]),
            (n[3] = t[3]);
          break;
        case "top":
          (n[0] = t[0]),
            (n[1] = t[1]),
            (n[2] = t[2]),
            (n[3] = Math.min(t[3], e[1]));
          break;
        case "left":
          (n[0] = Math.max(t[0], e[2])),
            (n[1] = t[1]),
            (n[2] = t[2]),
            (n[3] = t[3]);
          break;
        case "right":
          (n[0] = t[0]),
            (n[1] = t[1]),
            (n[2] = Math.min(t[2], e[0])),
            (n[3] = t[3]);
      }
      return n;
    })(
      c,
      [...Qf([u.bbox[0], u.bbox[1]]), ...Qf([u.bbox[2], u.bbox[3]])],
      u.direction
    ));
  const p = (function (t, e, i) {
      const n = [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2, 0],
        r = [t[0], t[1]],
        o = [t[2], t[3]],
        a = [...Zf(r), ...Zf(o)],
        s = [(a[0] + a[2]) / 2, (a[1] + a[3]) / 2, 0],
        l = Math.abs(t[0] - t[2]),
        u = Math.abs(t[1] - t[3]),
        c = Math.min(l, u),
        h = Math.max(l, u),
        p = JV.width,
        d = JV.height,
        f = JV.bboxSize,
        g = ef([l / p, u / d]) * f,
        m = g / e,
        y = g * i * 0.05;
      return {
        bbox: a,
        bboxProj: t,
        center: s,
        centerProj: n,
        size: {
          width: l,
          height: u,
          minSize: c,
          maxSize: h,
          bboxSize: g,
        },
        bboxScale: m,
        baseHeight: y,
      };
    })(h, r, o),
    d = [(h[0] + h[2]) / 2, (h[1] + h[3]) / 2, 0],
    f = p.size.bboxSize * l[2],
    g = oA(a, s).map((t) => t * f);
  (g[0] += d[0]), (g[1] += d[1]), (g[2] += d[2]);
  const m = aA(a, s);
  return {
    boundary: e,
    boundaryProj: i,
    bboxOption: p,
    viewBBoxOption: p,
    cameraStatus: {
      near: Math.max(p.size.bboxSize, 0.001),
      far: 10 * p.size.bboxSize,
      target: [d[0] + l[0] * p.size.bboxSize, d[1] + l[1] * p.size.bboxSize, 0],
      position: [
        g[0] + l[0] * p.size.bboxSize,
        g[1] + l[1] * p.size.bboxSize,
        g[2],
      ],
      up: m,
    },
    layerFitValue: {
      xy: p.size.bboxSize >> 4,
      z: p.size.bboxSize >> 3,
      flylineWidth: p.size.bboxSize >> 12,
      straightLineWidth: p.size.bboxSize >> 6,
    },
  };
}
async function $V(t) {
  try {
    const { drill: e, data: i } = t.state;
    e.enabled && e.data
      ? await (async function (t) {
          const { drill: e } = t.state;
          (t.drillData = await (async function (t, e, i) {
            const n = [];
            for (let r = e[0]; r <= e[1]; r++) {
              const e = t[String(r)];
              if (e) {
                const { data: t, type: i } = e;
                let r = t;
                switch (i) {
                  case xk.GEOJSON:
                    n.push(
                      new Promise((e) => {
                        e(t);
                      })
                    );
                    break;
                  case xk.GEOBUF_URL:
                    (r = t), n.push(XV.getGeoBuf2GeoJsonByUrl(r));
                    break;
                  case xk.GEOJSON_URL:
                    (r = t), n.push(XV.getGeoJsonByUrl(r));
                    break;
                  case xk.GEOBUF:
                  default:
                    console.error("[xGis]", `地图数据 url ${r} 格式无法解析`);
                }
              } else
                3 === r ||
                  console.error(
                    "[xGis]",
                    `钻取地图 level ${r} 无法匹配对应数据`
                  );
            }
            return Promise.all(n)
              .then((t) => {
                const n = (function (t, e, i) {
                  const n = {
                    default: [],
                    process: [],
                  };
                  if (
                    (t.forEach((e, r) => {
                      const o = new Map();
                      let a = new Map();
                      const s = i[String(r)];
                      if (s <= r)
                        console.error(
                          "[xGis]",
                          `配置 granularity ${s} 必须大于 level ${r} `
                        );
                      else {
                        let i;
                        switch (r) {
                          case 0:
                            switch ((o.set(Mk, t[0].features), s)) {
                              case 1:
                                (i = t[0]), a.set(Mk, i.features);
                                break;
                              case 2:
                                const e = [];
                                (i = t[1]),
                                  i.features.forEach((i) => {
                                    const n = i.properties.parent;
                                    if (Lk.includes(n)) {
                                      const i = t[0].features.find(
                                        (t) => t.properties.id === n
                                      );
                                      e.find(
                                        (t) =>
                                          t.properties.id === i.properties.id
                                      ) || e.push(i);
                                    } else e.push(i);
                                  }),
                                  a.set(Mk, e);
                                break;
                              default:
                                (i = t[2]), a.set(Mk, i.features);
                            }
                            break;
                          case 1:
                            if (
                              ((i = t[s - 1]),
                              e.features.forEach((t) => {
                                const e = t.properties.parent,
                                  i = o.get(e);
                                Array.isArray(i) ? i.push(t) : o.set(e, [t]);
                              }),
                              2 === s)
                            )
                              a = o;
                            else
                              i &&
                                e.features.forEach((t) => {
                                  const e = t.properties.parent;
                                  let n = a.get(e);
                                  Array.isArray(n) || a.set(e, []),
                                    (n = a.get(e)),
                                    Lk.includes(e)
                                      ? n.push(t)
                                      : i.features.forEach((t) => {
                                          const i = t.properties.acroutes;
                                          if (i) {
                                            i.split(",")[1] === e && n.push(t);
                                          }
                                        });
                                });
                            break;
                          case 2:
                            e.features.forEach((t) => {
                              const e = t.properties.parent,
                                i = o.get(e);
                              Array.isArray(i) ? i.push(t) : o.set(e, [t]);
                            }),
                              (a = o);
                            break;
                          default:
                            console.error(
                              "[xGis]",
                              "钻取地图 数据 data 超出三级结构"
                            );
                        }
                      }
                      n.default.push(o), n.process.push(a);
                    }),
                    t[1] && t[2] && 3 === e[e.length - 1])
                  ) {
                    const e = new Map();
                    let i = new Map();
                    t[1].features.forEach((t) => {
                      if (Lk.includes(t.properties.parent)) {
                        const i = t.properties.id,
                          n = e.get(i);
                        Array.isArray(n)
                          ? n.push(t)
                          : e.set(t.properties.id, [t]);
                      }
                    }),
                      t[2].features.forEach((t) => {
                        const i = t.properties.id,
                          n = e.get(i);
                        Array.isArray(n) ? n.push(t) : e.set(i, [t]);
                      }),
                      (i = e),
                      n.default.push(e),
                      n.process.push(i);
                  }
                  return n;
                })(t, e, i);
                return n;
              })
              .catch(
                (t) => (
                  console.error("[xGis]", t),
                  {
                    default: [],
                    process: [],
                  }
                )
              );
          })(e.data, e.level.range, e.granularity)),
            (t.currentCode = e.level.adcode),
            (t.currentLevel = qV(t.drillData, t.currentCode));
          const i = XV.getParentInfoByAdCode(t.currentCode, t.gis);
          (t.currentParentLevel = i.level), (t.currentParentCode = i.adcode);
        })(t)
      : await ZV(null == i ? void 0 : i.subDistrict),
      i.district ||
        (i.district = {
          type: xk.GEOJSON,
          data: {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                properties: {},
                geometry: am.dissolve(i.subDistrict.__raw_geojson__),
              },
            ],
          },
        }),
      await ZV(null == i ? void 0 : i.district),
      (async function (t) {
        const {
            data: { region: e, subDistrict: i },
            drill: { data: n, granularity: r, enabled: o },
          } = t.state,
          a = o && n;
        e &&
          Object.values(e).forEach((e) => {
            let n, o, s, l, u;
            if (a) {
              if (
                ((u = t.drillData.default[0]
                  .get(Mk)
                  .filter((t) => e.child.includes(t.properties.id))),
                u.length > 0)
              ) {
                let i;
                switch (r.region) {
                  case 1:
                    i = u;
                    break;
                  case 2:
                    const n = [];
                    for (const [i, o] of t.drillData.default[1].entries())
                      e.child.includes(i) &&
                        (Lk.includes(i)
                          ? n.push(
                              t.drillData.default[0]
                                .get(Mk)
                                .find((t) => t.properties.id === i)
                            )
                          : n.push(...o));
                    i = n;
                    break;
                  case 3:
                    const r = [];
                    for (const [i, o] of t.drillData.default[2].entries()) {
                      const t = o[0].properties.acroutes;
                      if (t) {
                        const i = t.split(",")[1];
                        e.child.includes(i) && r.push(...o);
                      }
                    }
                    i = r;
                }
                t.drillData.default[0].set(e.adcode, u),
                  t.drillData.process[0].set(e.adcode, i);
                const a = t.drillData.process[0].get(e.adcode);
                (n = [
                  {
                    type: "Feature",
                    properties: {},
                    geometry: am.dissolve(a),
                  },
                ]),
                  (o = sm(
                    lV({
                      type: "FeatureCollection",
                      features: n,
                    }),
                    Qf
                  ).features),
                  (s = t.drillData.process[0].get(e.adcode)),
                  (l = sm(
                    lV({
                      type: "FeatureCollection",
                      features: s,
                    }),
                    Qf
                  ).features);
              }
            } else if (
              ((u = i.__geojson__.features.filter((t) =>
                e.child.includes(t.properties.id)
              )),
              u.length > 0)
            ) {
              const i = u;
              t.drillData.default[0].set(e.adcode, u),
                t.drillData.process[0].set(e.adcode, i),
                (n = [
                  {
                    type: "Feature",
                    properties: {},
                    geometry: am.dissolve(i),
                  },
                ]),
                (o = sm(
                  lV({
                    type: "FeatureCollection",
                    features: n,
                  }),
                  Qf
                ).features),
                (s = i),
                (l = sm(
                  lV({
                    type: "FeatureCollection",
                    features: s,
                  }),
                  Qf
                ).features);
            }
            u.length > 0 &&
              (t.state = af(t.state, {
                data: {
                  [e.adcode]: {
                    districtData: o,
                    rawDistrictData: n,
                    subDistrictData: l,
                    rawSubDistrictData: s,
                  },
                },
              }));
          });
      })(t);
  } catch (e) {
    throw new Error("地图数据加载失败");
  }
}
function tW(t) {
  var e, i, n;
  try {
    const { drill: r, data: o } = t.state,
      a = r.enabled && r.data;
    if (a)
      if (0 === t.currentLevel) {
        const e =
          !!o.region &&
          Object.values(o.region).find((e) => e.adcode === t.currentCode);
        e
          ? ((t.rawDistrictData = o[e.adcode].rawDistrictData),
            (t.districtData = o[e.adcode].districtData),
            (t.currentRegion = e.adcode))
          : ((t.rawDistrictData = o.district.__geojson__.features),
            (t.districtData = o.district.__geojson_process_proj__.features));
      } else
        (t.rawDistrictData = [
          t.drillData.default[t.currentParentLevel]
            .get(t.currentParentCode)
            .find((e) => e.properties.id === t.currentCode),
        ]),
          (t.districtData = sm(
            lV({
              type: "FeatureCollection",
              features: t.rawDistrictData,
            }),
            Qf
          ).features);
    else
      (null == (e = o.district) ? void 0 : e.data) &&
        ((t.districtData = o.district.__geojson_process_proj__.features),
        (t.rawDistrictData = o.district.__geojson__.features));
    if (a) {
      t.rawSubDistrictData = t.drillData.default[t.currentLevel].get(
        t.currentCode
      );
      let e = {
        type: "FeatureCollection",
        features: t.rawSubDistrictData,
      };
      const n =
        null == (i = t.state.drill.data[t.currentLevel]) ? void 0 : i.simplify;
      (null == n ? void 0 : n.enabled) && (e = am.simplify(e, n.tolerance)),
        (t.subDistrictData = sm(lV(e), Qf).features);
    } else
      (null == (n = o.subDistrict) ? void 0 : n.data) &&
        ((t.subDistrictData = o.subDistrict.__geojson_process_proj__.features),
        (t.rawSubDistrictData = o.subDistrict.__geojson__.features));
  } catch (r) {
    throw ((t.isDrilling = !1), new Error("地图数据生成失败"));
  }
}
class eW extends oV {
  constructor(t, e, i) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.cb = i),
      (this.isDrilling = !1),
      (this.drillData = {
        default: [new Map()],
        process: [new Map()],
      }),
      (this.currentCode = Mk),
      (this.currentLevel = 0),
      (this.currentParentCode = null),
      (this.currentParentLevel = -1),
      (this.drillCache = {}),
      (this.subDistrictInfoArr = []),
      (this.currentRegion = null);
  }
  async init() {
    this._initialState(),
      this._initLayerGroup(),
      await this.__initMap(),
      this.gis.__destroyed ||
        (this.__initEvent(),
        this.animation.start(),
        super.registerInteraction(
          this.state.interaction,
          this.subDistrictFillGroup,
          !1
        ),
        super.emitPropsWatch(),
        this.registerHeightScale(),
        this.ee.emit("loaded", this),
        this.cb());
  }
  _initialState() {
    super._initialState({});
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "base-map-layer",
      layerType: "base",
    }),
      this.__releaseLayerGroup();
  }
  __initEvent() {
    const { drill: t } = this.state;
    t.enabled &&
      (t.preventMouse ||
        (this.gis.eventManager.bindEvent(this.id, t.drillUpEvent),
        this.gis.eventManager.bindEvent(this.id, t.drillDownEvent)));
  }
  __releaseLayerGroup() {
    (this.districtStrokeGroup = new As()),
      (this.districtStrokeGroup.name = "district-stroke"),
      (this.districtBottomStrokeGroup = new As()),
      (this.districtBottomStrokeGroup.name = "district-bottom-stroke"),
      (this.districtFillGroup = new As()),
      (this.districtFillGroup.name = "district-fill"),
      (this.extrudeBackgroundFillGroup = new As()),
      (this.extrudeBackgroundFillGroup.name = "extrude-background-fill"),
      (this.subDistrictStrokeGroup = new As()),
      (this.subDistrictStrokeGroup.name = "sub-district-stroke"),
      (this.subDistrictFillGroup = new As()),
      (this.subDistrictFillGroup.name = "sub-district-fill"),
      (this.listenerObj = this.subDistrictFillGroup),
      this.coreGroup.add(
        this.districtStrokeGroup,
        this.districtBottomStrokeGroup,
        this.districtFillGroup,
        this.extrudeBackgroundFillGroup,
        this.subDistrictFillGroup,
        this.subDistrictStrokeGroup
      ),
      (this.coreGroup.userData.invertedRelection = !0),
      (this.districtStrokeGroup.userData.invertedRelection = !1),
      (this.districtBottomStrokeGroup.userData.invertedRelection = !1),
      (this.districtFillGroup.userData.invertedRelection = !0),
      (this.extrudeBackgroundFillGroup.userData.invertedRelection = !0),
      (this.subDistrictFillGroup.userData.invertedRelection = !1),
      (this.subDistrictStrokeGroup.userData.invertedRelection = !1);
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  add() {
    return this;
  }
  remove() {
    super.remove();
  }
  updateArea(t) {
    const { cameraStatus: e } = this.gis.globalOpts,
      {
        drill: { duration: i },
      } = this.state,
      { cameraChange: n, cameraTween: r } = af(Ok, t);
    n &&
      this.gis.viewportSystem.setCameraState(
        e,
        r
          ? {
              duration: i,
              type: "straight",
            }
          : void 0
      ),
      this.updateBaseHeight(),
      this._updatePOI(!0);
  }
  async initExtrude() {
    const { bboxOption: t, boundary: e, boundaryProj: i } = this.gis.globalOpts,
      { districtStyle: n, extrudeBackgroundStyle: r } = this.state;
    if (
      (n &&
        n.enabled &&
        (function (t, e) {
          const { geojson: i, bboxOption: n } = t,
            r = bV(i, n.bboxProj);
          let o = 0,
            a = 0,
            s = 0,
            l = 0;
          const u = n.baseHeight ? n.baseHeight : 1;
          for (let c = 0; c < r.group.length; c += 3)
            switch (
              ((o += s),
              (a += l),
              (s = r.group[c + 1]),
              (l = r.group[c + 2]),
              r.group[c])
            ) {
              case 0:
                const t = RV({
                    index: r.index.slice(o, 1 * (o + s)),
                    position: r.position.slice(3 * a, 3 * (a + l)),
                    normal: r.normal.slice(3 * a, 3 * (a + l)),
                    uv: r.uv.slice(2 * a, 2 * (a + l)),
                  }),
                  i = new Wn(t, e.extrudeTopMaterial);
                i.setRenderIndex(lU.BASE_MAP_LAYER_EXTRUDE_MESH),
                  (i.scale.z = u),
                  (i.position.z = 0),
                  (i.userData.faceType = "top"),
                  (i.name = "map-top"),
                  (i.frustumCulled = !1),
                  e.districtFillGroup.add(i);
                const n = new Wn(t, e.extrudeInnerShadowMaterial);
                n.setRenderIndex(lU.BASE_MAP_LAYER_INNERSHADOW_MESH),
                  (n.scale.z = 1.01 * u),
                  (n.position.z = 0),
                  (n.userData.faceType = "map-innerShadow"),
                  (n.name = "map-innerShadow"),
                  (n.frustumCulled = !1),
                  e.districtFillGroup.add(n);
                break;
              case 1:
                const c = RV({
                    index: r.index.slice(o, 1 * (o + s)),
                    position: r.position.slice(3 * a, 3 * (a + l)),
                    normal: r.normal.slice(3 * a, 3 * (a + l)),
                    uv: r.uv.slice(2 * a, 2 * (a + l)),
                  }),
                  h = new Wn(c, e.extrudeSideMaterial);
                h.setRenderIndex(lU.BASE_MAP_LAYER_EXTRUDE_MESH),
                  (h.scale.z = u),
                  (h.position.z = 0),
                  (h.name = "map-side"),
                  (h.userData.faceType = "side"),
                  (h.userData.invertedRelection = !0),
                  (h.castShadow = !0),
                  (h.frustumCulled = !1),
                  e.districtFillGroup.add(h);
            }
        })(
          {
            geojson: i,
            bboxOption: t,
          },
          this
        ),
      r && r.enabled)
    ) {
      if (!this.bgGeoData) {
        const t = {
          type: xk.GEOBUF_URL,
          data: `https://lf3-dpfe.${atob(
            "Ynl0ZXRvcy5jb20="
          )}/obj/gis/data/worldborderworldborder_gc.pbf`,
        };
        this.bgGeoData = await ZV(t, {
          useProcess: !1,
          useProject: !1,
        });
      }
      const i = UV(t, this),
        n = (function (t, e, i) {
          const { bbox2: n } = t,
            r = Ww.intersect(
              {
                type: "Feature",
                properties: {},
                geometry: {
                  type: "Polygon",
                  coordinates: [
                    [
                      [n[0], n[1]],
                      [n[2], n[1]],
                      [n[2], n[3]],
                      [n[0], n[3]],
                      [n[0], n[1]],
                    ],
                  ],
                },
              },
              e.__geojson__.features[0]
            );
          let o = {
            type: "FeatureCollection",
            features: [r],
          };
          o = am.rewind(o);
          const a = Ww.distance(
              {
                type: "Feature",
                properties: {},
                geometry: {
                  type: "Point",
                  coordinates: [t.bbox[0], t.bbox[1]],
                },
              },
              {
                type: "Feature",
                properties: {},
                geometry: {
                  type: "Point",
                  coordinates: [t.bbox[2], t.bbox[3]],
                },
              },
              {
                units: "meters",
              }
            ),
            s = Ww.buffer(i.features[0], ~~(0.001 * a), {
              units: "meters",
              steps: 1,
            });
          return (
            (o = {
              type: "FeatureCollection",
              features: [Ww.difference(r, s)],
            }),
            sm(lV(o), Qf)
          );
        })(i, this.bgGeoData, e);
      !(function (t, e) {
        const { geojson: i, bboxOption: n } = t,
          r = bV(i, n.bboxProj);
        let o = 0,
          a = 0,
          s = 0,
          l = 0;
        for (let u = 0; u < r.group.length; u += 3)
          switch (
            ((o += s),
            (a += l),
            (s = r.group[u + 1]),
            (l = r.group[u + 2]),
            r.group[u])
          ) {
            case 0:
              const t = RV({
                  index: r.index.slice(o, 1 * (o + s)),
                  position: r.position.slice(3 * a, 3 * (a + l)),
                  normal: r.normal.slice(3 * a, 3 * (a + l)),
                  uv: r.uv.slice(2 * a, 2 * (a + l)),
                }),
                i = new Wn(t, e.extrudeBackgroundTopMaterial);
              i.setRenderIndex(lU.BASE_MAP_LAYER_EXTRUDE_MESH),
                (i.scale.z = n.baseHeight ? n.baseHeight : 1),
                (i.position.z = 0),
                (i.userData.faceType = "top"),
                (i.name = "map-top"),
                (i.receiveShadow = !0),
                (i.frustumCulled = !1),
                e.extrudeBackgroundFillGroup.add(i);
              break;
            case 1:
              const u = RV({
                  index: r.index.slice(o, 1 * (o + s)),
                  position: r.position.slice(3 * a, 3 * (a + l)),
                  normal: r.normal.slice(3 * a, 3 * (a + l)),
                  uv: r.uv.slice(2 * a, 2 * (a + l)),
                }),
                c = new Wn(u, e.extrudeBackgroundSideMaterial);
              c.setRenderIndex(lU.BASE_MAP_LAYER_EXTRUDE_MESH),
                (c.scale.z = n.baseHeight ? n.baseHeight : 1),
                (c.position.z = 0),
                (c.name = "map-side"),
                (c.userData.faceType = "side"),
                (c.userData.invertedRelection = !0),
                (c.castShadow = !0),
                (c.frustumCulled = !1),
                e.extrudeBackgroundFillGroup.add(c);
          }
      })(
        {
          geojson: n,
          bboxOption: i,
        },
        this
      );
    }
  }
  async updateExtrudeStyle() {
    const { districtStyle: t, extrudeBackgroundStyle: e } = this.state;
    t && t.enabled && (FV(this, "extrude"), zV(this), kV(this)),
      e && e.enabled && FV(this, "extrude-background");
  }
  updateBaseHeight() {
    const { globalOpts: t } = this.gis;
    if (t) {
      const {
        bboxOption: { baseHeight: e },
      } = t;
      this.districtStrokeGroup.position.setZ(e),
        this.subDistrictStrokeGroup.position.setZ(e),
        this.subDistrictFillGroup.position.setZ(e),
        this.poiGroup.updateBaseHeight(e),
        (function (t, e) {
          e.districtFillGroup.children.forEach((e) => {
            "map-innerShadow" === e.userData.faceType
              ? (e.scale.z = 1.01 * (t || 1))
              : (e.scale.z = t || 1),
              (e.position.z = 0);
          });
        })(e, this),
        jV(e, this);
    }
  }
  async __initMap(t) {
    const { districtStyle: e, extrudeBackgroundStyle: i } = this.state,
      { sceneSystem: n } = this.gis;
    await $V(this),
      this.gis.__destroyed ||
        (tW(this),
        uV(this),
        HV(this),
        this.scaleAdaptation(!1),
        t
          ? this.gis.viewportSystem.init("xgis")
          : this.gis.viewportSystem.init(),
        this.scaleAdaptation(!1),
        (function (t, e, i) {
          const n = EA(e.state.background.color);
          (i.extrudeTopMaterial = new zA({
            color: n.color,
            transparent: !0,
            depthTest: !0,
            depthWrite: !0,
          })),
            (i.extrudeInnerShadowMaterial = new zA({
              transparent: !0,
              depthTest: !0,
              depthWrite: !0,
            }));
          const { colorConfig: r } = t.sideConfig,
            {
              bottomColor: o,
              topColor: a,
              bottomOpacity: s,
              topOpacity: l,
            } = GV(r);
          i.extrudeSideMaterial = new Jn({
            uniforms: {
              type: {
                type: "int",
                value: ((t) => {
                  switch (t) {
                    case "linear":
                      return 1;
                    case "ordinal":
                      return 2;
                  }
                })(r.type),
              },
              bottomColor: {
                type: "vec3",
                value: {
                  color: o,
                  opacity: s,
                },
              },
              topColor: {
                type: "vec3",
                value: {
                  color: a,
                  opacity: l,
                },
              },
            },
            transparent: !0,
            vertexShader:
              "varying vec2 vUv;\n\n#include <common>  \n#include <uv_pars_vertex>  \n#include <uv2_pars_vertex>  \n#include <logdepthbuf_pars_vertex>  \n#include <clipping_planes_pars_vertex>   \n\nvoid main() {\n\n  #include <uv_vertex>    \n  #include <uv2_vertex>\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  #include <begin_vertex>    \n  \n  #include <skinning_vertex>    \n  #include <displacementmap_vertex>    \n  #include <project_vertex>    \n  #include <logdepthbuf_vertex>    \n  #include <clipping_planes_vertex>      \n  \n  #include <worldpos_vertex>    \n  \n  \n}",
            fragmentShader:
              "#ifdef GL_ES\nprecision highp float;\n#endif\n\nstruct colorObj {\n  vec3 color;\n  float opacity;\n};\n\nuniform colorObj topColor;\nuniform colorObj bottomColor;\nuniform int type;\n\nvarying vec2 vUv;\n\n#include <common>  \n#include <packing>\n#include <uv_pars_fragment>\n\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n\n    gl_FragColor = vec4(mix(topColor.color, bottomColor.color, vUv.y), mix(topColor.opacity, bottomColor.opacity, vUv.y));\n\n    #include <premultiplied_alpha_fragment>  \n    #include <dithering_fragment>\n}",
          });
        })(e, n, this),
        (function (t, e, i) {
          const n = EA(e.state.background.color);
          i.extrudeBackgroundTopMaterial = new zA({
            color: n.color,
            transparent: !0,
            depthTest: !0,
            depthWrite: !0,
          });
          const { colorConfig: r } = t.sideConfig,
            {
              bottomColor: o,
              topColor: a,
              bottomOpacity: s,
              topOpacity: l,
            } = GV(r);
          i.extrudeBackgroundSideMaterial = new Jn({
            uniforms: {
              type: {
                type: "int",
                value: ((t) => {
                  switch (t) {
                    case "linear":
                      return 1;
                    case "ordinal":
                      return 2;
                  }
                })(r.type),
              },
              bottomColor: {
                type: "vec3",
                value: {
                  color: o,
                  opacity: s,
                },
              },
              topColor: {
                type: "vec3",
                value: {
                  color: a,
                  opacity: l,
                },
              },
            },
            transparent: !1,
            vertexShader:
              "varying vec2 vUv;\n\n#include <common>  \n#include <uv_pars_vertex>  \n#include <uv2_pars_vertex>  \n#include <logdepthbuf_pars_vertex>  \n#include <clipping_planes_pars_vertex>   \n\nvoid main() {\n\n  #include <uv_vertex>    \n  #include <uv2_vertex>\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  #include <begin_vertex>    \n  \n  #include <skinning_vertex>    \n  #include <displacementmap_vertex>    \n  #include <project_vertex>    \n  #include <logdepthbuf_vertex>    \n  #include <clipping_planes_vertex>      \n  \n  #include <worldpos_vertex>    \n  \n  \n}",
            fragmentShader:
              "#ifdef GL_ES\nprecision highp float;\n#endif\n\nstruct colorObj {\n    vec3 color;\n    float opacity;\n};\n\nuniform colorObj topColor;\nuniform colorObj bottomColor;\nuniform int type;\n\nvarying vec2 vUv;\n\n#include <common>  \n#include <packing>\n#include <uv_pars_fragment>\n\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n\n    gl_FragColor = vec4(mix(topColor.color, bottomColor.color, vUv.y), mix(topColor.opacity, bottomColor.opacity, vUv.y));\n\n    #include <premultiplied_alpha_fragment>  \n    #include <dithering_fragment>\n}",
            depthTest: !0,
            depthWrite: !0,
          });
        })(i, n, this),
        await this.initExtrude());
  }
  async drillDown(t, e) {
    const { viewportSystem: i } = this.gis,
      {
        drill: {
          enabled: n,
          duration: r,
          level: { range: o },
        },
      } = this.state;
    if (!n) return this.logService.warn("当前未开启钻取功能"), this;
    if (this.isDrilling) return this.logService.warn("当前钻取未结束"), this;
    const a = qV(this.drillData, t);
    if (-1 === a)
      return this.logService.warn(`钻取层级 ${a}不合法，下钻无效`), this;
    if (a > o[1] || a < o[0])
      return this.logService.warn(`钻取层级 ${a}超过最大限制，下钻无效`), this;
    this.isDrilling = !0;
    const s = {
      adcode: this.currentCode,
      viewPortInfo: i.get(),
      group: this.coreGroup,
      subDistrictInfoArr: this.subDistrictInfoArr,
    };
    (this.drillCache[s.adcode] = s),
      (this.currentLevel = a),
      (this.currentCode = t);
    const l = XV.getParentInfoByAdCode(this.currentCode, this.gis);
    (this.currentParentLevel = l.level),
      (this.currentParentCode = l.adcode),
      (this.currentRegion = null),
      tW(this);
    const u = {
      type: "drillDown",
      code: 200,
      properties: {
        currentCode: this.currentCode,
        currentLevel: this.currentLevel,
      },
    };
    return (
      this.ee.emit("drill", u),
      this.ee.emit("drillDown", u),
      WV(this),
      await new Promise((t) =>
        setTimeout(() => {
          e && e(),
            (() => {
              this.ee.emit("drillDownEnd", u),
                this.ee.emit("drillEnd", u),
                (this.isDrilling = !1);
            })(),
            t(this);
        }, r)
      )
    );
  }
  async drillUp(t, e) {
    const { viewportSystem: i } = this.gis,
      {
        drill: {
          enabled: n,
          duration: r,
          level: { range: o },
        },
      } = this.state;
    if (!n) return this.logService.warn("当前未开启钻取功能"), this;
    if (this.isDrilling) return this.logService.warn("当前钻取未结束"), this;
    let a = this.currentParentLevel;
    if ((t && (a = qV(this.drillData, t)), -1 === a))
      return this.logService.warn(`钻取层级 ${a}不合法，上钻无效`), this;
    if (a > o[1] || a < o[0])
      return this.logService.warn(`钻取层级 ${a}超过最大限制，上钻无效`), this;
    this.isDrilling = !0;
    const s = {
      adcode: this.currentCode,
      viewPortInfo: i.get(),
      group: this.coreGroup,
      subDistrictInfoArr: this.subDistrictInfoArr,
    };
    (this.drillCache[s.adcode] = s), (this.currentLevel = a);
    const l = XV.getParentInfoByAdCode(this.currentCode, this.gis);
    this.currentCode = null != t ? t : l.adcode;
    const u = XV.getParentInfoByAdCode(this.currentCode, this.gis);
    (this.currentParentCode = u.adcode),
      (this.currentParentLevel = u.level),
      (this.currentRegion = null),
      tW(this);
    const c = {
      type: "drillUp",
      code: 200,
      properties: {
        currentCode: this.currentCode,
        currentLevel: this.currentLevel,
      },
    };
    return (
      this.ee.emit("drill", c),
      this.ee.emit("drillUp", c),
      WV(this),
      await new Promise((t) =>
        setTimeout(() => {
          e && e(),
            (() => {
              this.ee.emit("drillUpEnd", c),
                this.ee.emit("drillEnd", c),
                (this.isDrilling = !1);
            })(),
            t(this);
        }, r)
      )
    );
  }
  async drillRegion(t, e) {
    const { viewportSystem: i } = this.gis,
      {
        drill: { enabled: n, duration: r },
      } = this.state;
    if (!n) return this.logService.warn("当前未开启钻取功能"), this;
    if (this.isDrilling) return this.logService.warn("当前钻取未结束"), this;
    (this.isDrilling = !0), (this.currentRegion = t);
    const o = {
      adcode: this.currentCode,
      viewPortInfo: i.get(),
      group: this.coreGroup,
      subDistrictInfoArr: this.subDistrictInfoArr,
    };
    (this.drillCache[o.adcode] = o),
      (this.currentLevel = 0),
      (this.currentCode = t);
    const a = XV.getParentInfoByAdCode(this.currentCode, this.gis);
    (this.currentParentCode = a.adcode),
      (this.currentParentLevel = a.level),
      (async function (t) {
        const e = t.state.data[t.currentRegion];
        (t.rawSubDistrictData = e.rawSubDistrictData),
          (t.subDistrictData = e.subDistrictData),
          (t.rawDistrictData = e.rawDistrictData),
          (t.districtData = e.districtData);
      })(this);
    const s = {
      type: "drillRegion",
      code: 200,
      properties: {
        currentCode: this.currentCode,
        currentLevel: this.currentLevel,
      },
    };
    return (
      this.ee.emit("drill", s),
      this.ee.emit("drillRegion", s),
      WV(this),
      await new Promise((t) =>
        setTimeout(() => {
          e && e(),
            (() => {
              this.ee.emit("drillEnd", s),
                this.ee.emit("drillRegionEnd", s),
                (this.isDrilling = !1);
            })(),
            t(this);
        }, r)
      )
    );
  }
  async initPOI() {
    const { poi: t } = this.state,
      {
        enabled: e,
        background: i,
        orient: n,
        alignment: r,
        offsetX: o,
        offsetY: a,
        major: s,
      } = t;
    if (!e || !s.enabled) return void this.clearPoiGroup();
    this.clearPoiGroup();
    const { baseHeight: l } = this.gis.globalOpts.bboxOption;
    for (let u = 0; u < this.subDistrictInfoArr.length; u++) {
      const t = this.subDistrictInfoArr[u],
        { centroid: e, alias: c } = t;
      if (!e) continue;
      const h = new Ye(0, 0, 0);
      await this.poiGroup.addText(
        h,
        n,
        r,
        i,
        {
          content: `${s.format ? s.format(c) : c}`,
          props: s,
        },
        null,
        o,
        a,
        {
          position: [e[0], e[1], l],
          offsetX: o,
          offsetY: a,
        }
      );
    }
    this._updatePOI(!0);
  }
  scaleAdaptation(t = !0) {
    const { project: e } = this.gis.layerManager.geo,
      {
        districtStyle: { heightScale: i },
        viewClip: n,
      } = this.state,
      { drillSave: r } = this.gis.viewportSystem.get(),
      o = this.drillCache[this.currentCode];
    let a;
    a = o && r ? o.viewPortInfo : this.gis.viewportSystem.get();
    const { pitch: s, rotation: l, offset: u } = a,
      c = Vf,
      h = null == n ? void 0 : n[this.currentCode],
      p = KV({
        geojson: {
          type: "FeatureCollection",
          features: this.rawDistrictData,
        },
        geojsonProj: {
          type: "FeatureCollection",
          features: this.districtData,
        },
        project: e,
        geojsonUtil: am,
        worldBboxSize: c,
        heightScale: i,
        pitch: s,
        rotation: l,
        offset: u,
        viewClip: h,
      });
    (this.gis.globalOpts = p),
      this.gis.layerManager.ee.emit("updateArea", {
        cameraTween: t,
      }),
      this.gis.lightSystem.ee.emit("updateArea");
  }
  registerHeightScale() {
    this._propsWatch.addWatch([
      this._propsWatch.defaultRule(
        ["districtStyle", "heightScale"],
        "diffDeep",
        () => {
          const { bboxOption: t } = this.gis.globalOpts;
          (t.baseHeight =
            t.size.bboxSize * this.state.districtStyle.heightScale * 0.05),
            this.gis.layerManager.ee.emit("updateArea", {
              cameraChange: !1,
              cameraTween: !1,
            }),
            this.gis.lightSystem.ee.emit("updateArea");
        }
      ),
    ]);
  }
  debugBbox() {
    const {
        bboxOption: {
          size: { width: t, height: e },
          centerProj: i,
          baseHeight: n,
        },
      } = this.gis.globalOpts,
      r = new dr(t, e),
      o = new pn({
        color: 16711680,
        opacity: 0.1,
        transparent: !0,
        side: xt,
      }),
      a = new Wn(r, o);
    a.position.set(i[0], i[1], n + 1),
      a.setRenderIndex(lU.PARTICLE_LAYER),
      this.coreGroup.add(a);
  }
  handleAnimation() {
    this.boundaryStreamerLayer && this.boundaryStreamerLayer.handleAnimation();
  }
  clear() {
    this.clearCoreGroup(),
      this.clearPoiGroup(),
      this.clearInteractionGroup(),
      (this.isDrilling = !1),
      (this.drillData = {
        default: [new Map()],
        process: [new Map()],
      }),
      (this.currentCode = Mk),
      (this.currentLevel = 0),
      (this.currentParentCode = null),
      (this.currentParentLevel = -1),
      (this.drillCache = {}),
      (this.subDistrictStrokeGroup = null),
      (this.subDistrictFillGroup = null),
      (this.districtStrokeGroup = null),
      (this.districtBottomStrokeGroup = null),
      (this.districtFillGroup = null),
      (this.extrudeBackgroundFillGroup = null),
      (this.subDistrictInfoArr = []),
      (this.districtData = null),
      (this.subDistrictData = null),
      (this.rawDistrictData = null),
      (this.rawSubDistrictData = null),
      (this.extrudeTopMaterial = null),
      (this.extrudeSideMaterial = null),
      (this.extrudeInnerShadowMaterial = null),
      (this.extrudeBackgroundTopMaterial = null),
      (this.extrudeBackgroundSideMaterial = null),
      (this.currentRegion = null),
      (this.bgGeoData = null),
      (this.boundaryStreamerLayer = null),
      (this.gis.globalOpts = null);
  }
  async release() {
    if (
      (this.clear(),
      this._initLayerGroup(),
      await this.__initMap(!0),
      this.gis.__destroyed)
    )
      return;
    this.__initEvent(),
      this.animation.start(),
      super.registerInteraction(
        this.state.interaction,
        this.subDistrictFillGroup,
        !1
      ),
      super.emitPropsWatch(),
      this.registerHeightScale(),
      FV(this, "extrude"),
      BV(this.extrudeSideMaterial, this.state.districtStyle),
      zV(this),
      kV(this),
      cV(this.state.districtStyle, this),
      hV(this.state.districtStyle, this),
      VV(this.state.subDistrictStyle, this),
      FV(this, "extrude-background"),
      BV(this.extrudeBackgroundSideMaterial, this.state.extrudeBackgroundStyle);
    const { backgroundBboxOption: t } = this.gis.globalOpts;
    t &&
      ((t.baseHeight =
        t.size.bboxSize *
        this.state.extrudeBackgroundStyle.heightScale *
        0.05 *
        0.2),
      jV(t.baseHeight, this)),
      await this.initPOI();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(["viewClip"], "diffDeep", () => {
          (this.drillCache = {}), this.scaleAdaptation(!1);
        }),
        this._propsWatch.defaultRule(
          ["districtStyle", "fill"],
          "diffDeep",
          () => {
            FV(this, "extrude");
          }
        ),
        this._propsWatch.defaultRule(
          ["districtStyle", "sideConfig"],
          "diffDeep",
          () => {
            BV(this.extrudeSideMaterial, this.state.districtStyle);
          }
        ),
        this._propsWatch.defaultRule(
          ["districtStyle", "innerShadow"],
          "diffDeep",
          () => {
            zV(this);
          }
        ),
        this._propsWatch.defaultRule(
          ["districtStyle", "boundaryStreamer"],
          "diffDeep",
          () => {
            kV(this);
          }
        ),
        this._propsWatch.defaultRule(
          ["districtStyle", "stroke"],
          "diffDeep",
          () => {
            cV(this.state.districtStyle, this);
          }
        ),
        this._propsWatch.defaultRule(
          ["districtStyle", "bottomStroke"],
          "diffDeep",
          () => {
            hV(this.state.districtStyle, this);
          }
        ),
        this._propsWatch.defaultRule(
          ["subDistrictStyle", "stroke"],
          "diffDeep",
          () => {
            VV(this.state.subDistrictStyle, this);
          }
        ),
        this._propsWatch.defaultRule(
          ["extrudeBackgroundStyle", "fill"],
          "diffDeep",
          () => {
            FV(this, "extrude-background");
          }
        ),
        this._propsWatch.defaultRule(
          ["extrudeBackgroundStyle", "sideConfig"],
          "diffDeep",
          () => {
            BV(
              this.extrudeBackgroundSideMaterial,
              this.state.extrudeBackgroundStyle
            );
          }
        ),
        this._propsWatch.defaultRule(
          ["extrudeBackgroundStyle", "heightScale"],
          "diffDeep",
          () => {
            const { backgroundBboxOption: t } = this.gis.globalOpts;
            t &&
              ((t.baseHeight =
                t.size.bboxSize *
                this.state.extrudeBackgroundStyle.heightScale *
                0.05 *
                0.2),
              jV(t.baseHeight, this));
          }
        ),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          this.initPOI();
        }),
      ]);
  }
}
const iW = {
    css2d: class {
      constructor(t = {}) {
        (this.cache = {
          objects: new WeakMap(),
        }),
          (this.domElement =
            void 0 !== t.element ? t.element : document.createElement("div")),
          (this.domElement.style.overflow = "hidden");
      }
      renderObject(t, e, i) {
        if (t.isCSS2DObject) {
          t.onBeforeRender(this, e, i),
            vD.setFromMatrixPosition(t.matrixWorld),
            vD.applyMatrix4(xD);
          const n = t.element;
          /apple/i.test(navigator.vendor)
            ? (n.style.transform =
                "translate(-50%,-50%) translate(" +
                Math.round(vD.x * this._widthHalf + this._widthHalf) +
                "px," +
                Math.round(-vD.y * this._heightHalf + this._heightHalf) +
                "px)")
            : (n.style.transform =
                "translate(-50%,-50%) translate(" +
                (vD.x * this._widthHalf + this._widthHalf) +
                "px," +
                (-vD.y * this._heightHalf + this._heightHalf) +
                "px)"),
            (n.style.display =
              t.visible && vD.z >= -1 && vD.z <= 1 ? "" : "none"),
            n.parentNode !== this.domElement && this.domElement.appendChild(n),
            t.onAfterRender(this, e, i);
        }
        for (let n = 0, r = t.children.length; n < r; n++)
          this.renderObject(t.children[n], e, i);
      }
      getSize() {
        return {
          width: this._width,
          height: this._height,
        };
      }
      render(t, e) {
        !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          bD.copy(e.matrixWorldInverse),
          xD.multiplyMatrices(e.projectionMatrix, bD),
          this.renderObject(t, t, e);
      }
      setSize(t, e) {
        (this._width = t),
          (this._height = e),
          (this._widthHalf = this._width / 2),
          (this._heightHalf = this._height / 2),
          (this.domElement.style.width = t + "px"),
          (this.domElement.style.height = e + "px");
      }
    },
    css3d: class {
      constructor(t = {}) {
        this.cache = {
          camera: {
            fov: 0,
            style: "",
          },
          objects: new WeakMap(),
        };
        const e =
          void 0 !== t.element ? t.element : document.createElement("div");
        (e.style.overflow = "hidden"),
          (this.domElement = e),
          (this.cameraElement = document.createElement("div")),
          (this.cameraElement.style.transformStyle = "preserve-3d"),
          (this.cameraElement.style.pointerEvents = "none"),
          e.appendChild(this.cameraElement);
      }
      getSize() {
        return {
          width: this._width,
          height: this._height,
        };
      }
      render(t, e) {
        const i = e.projectionMatrix.elements[5] * this._heightHalf;
        let n, r;
        this.cache.camera.fov !== i &&
          ((this.domElement.style.perspective = e.isPerspectiveCamera
            ? i + "px"
            : ""),
          (this.cache.camera.fov = i)),
          !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          e.isOrthographicCamera &&
            ((n = -(e.right + e.left) / 2), (r = (e.top + e.bottom) / 2));
        const o = e.isOrthographicCamera
            ? "scale(" +
              i +
              ")translate(" +
              this.epsilon(n) +
              "px," +
              this.epsilon(r) +
              "px)" +
              this.getCameraCSSMatrix(e.matrixWorldInverse)
            : "translateZ(" +
              i +
              "px)" +
              this.getCameraCSSMatrix(e.matrixWorldInverse),
          a =
            o +
            "translate(" +
            this._widthHalf +
            "px," +
            this._heightHalf +
            "px)";
        this.cache.camera.style !== a &&
          ((this.cameraElement.style.transform = a),
          (this.cache.camera.style = a)),
          this.renderObject(t, t, e, o);
      }
      setSize(t, e) {
        (this._width = t),
          (this._height = e),
          (this._widthHalf = this._width / 2),
          (this._heightHalf = this._height / 2),
          (this.domElement.style.width = t + "px"),
          (this.domElement.style.height = e + "px"),
          (this.cameraElement.style.width = t + "px"),
          (this.cameraElement.style.height = e + "px");
      }
      epsilon(t) {
        return Math.abs(t) < 1e-10 ? 0 : t;
      }
      getCameraCSSMatrix(t) {
        const e = t.elements;
        return (
          "matrix3d(" +
          this.epsilon(e[0]) +
          "," +
          this.epsilon(-e[1]) +
          "," +
          this.epsilon(e[2]) +
          "," +
          this.epsilon(e[3]) +
          "," +
          this.epsilon(e[4]) +
          "," +
          this.epsilon(-e[5]) +
          "," +
          this.epsilon(e[6]) +
          "," +
          this.epsilon(e[7]) +
          "," +
          this.epsilon(e[8]) +
          "," +
          this.epsilon(-e[9]) +
          "," +
          this.epsilon(e[10]) +
          "," +
          this.epsilon(e[11]) +
          "," +
          this.epsilon(e[12]) +
          "," +
          this.epsilon(-e[13]) +
          "," +
          this.epsilon(e[14]) +
          "," +
          this.epsilon(e[15]) +
          ")"
        );
      }
      getObjectCSSMatrix(t) {
        const e = t.elements;
        return (
          "translate(-50%,-50%)" +
          ("matrix3d(" +
            this.epsilon(e[0]) +
            "," +
            this.epsilon(e[1]) +
            "," +
            this.epsilon(e[2]) +
            "," +
            this.epsilon(e[3]) +
            "," +
            this.epsilon(-e[4]) +
            "," +
            this.epsilon(-e[5]) +
            "," +
            this.epsilon(-e[6]) +
            "," +
            this.epsilon(-e[7]) +
            "," +
            this.epsilon(e[8]) +
            "," +
            this.epsilon(e[9]) +
            "," +
            this.epsilon(e[10]) +
            "," +
            this.epsilon(e[11]) +
            "," +
            this.epsilon(e[12]) +
            "," +
            this.epsilon(e[13]) +
            "," +
            this.epsilon(e[14]) +
            "," +
            this.epsilon(e[15]) +
            ")")
        );
      }
      renderObject(t, e, i, n) {
        if (t.isCSS3DObject) {
          let n;
          t.onBeforeRender(this, e, i),
            t.isCSS3DSprite
              ? (CD.copy(i.matrixWorldInverse),
                CD.transpose(),
                0 !== t.rotation2D &&
                  CD.multiply(wD.makeRotationZ(t.rotation2D)),
                t.matrixWorld.decompose(_D, SD, MD),
                CD.setPosition(_D),
                CD.scale(MD),
                (CD.elements[3] = 0),
                (CD.elements[7] = 0),
                (CD.elements[11] = 0),
                (CD.elements[15] = 1),
                (n = this.getObjectCSSMatrix(CD)))
              : (n = this.getObjectCSSMatrix(t.matrixWorld));
          const r = t.element,
            o = this.cache.objects.get(t);
          if (void 0 === o || o.style !== n) {
            r.style.transform = n;
            const e = {
              style: n,
            };
            this.cache.objects.set(t, e);
          }
          (r.style.display = t.visible ? "" : "none"),
            r.parentNode !== this.cameraElement &&
              this.cameraElement.appendChild(r),
            t.onAfterRender(this, e, i);
        }
        for (let r = 0, o = t.children.length; r < o; r++)
          this.renderObject(t.children[r], e, i, n);
      }
    },
  },
  nW = {
    css2d: class extends Hi {
      constructor(t = document.createElement("div")) {
        super(),
          (this.isCSS2DObject = !0),
          (this.element = t),
          (this.element.style.position = "absolute"),
          (this.element.style.userSelect = "none"),
          this.element.setAttribute("draggable", !1),
          this.addEventListener("removed", () => {
            this.traverse((t) => {
              t.element instanceof Element &&
                null !== t.element.parentNode &&
                t.element.parentNode.removeChild(t.element);
            });
          });
      }
      copy(t, e) {
        return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this;
      }
    },
    css3d: class extends Hi {
      constructor(t = document.createElement("div")) {
        super(),
          (this.isCSS3DObject = !0),
          (this.element = t),
          (this.element.style.position = "absolute"),
          (this.element.style.pointerEvents = "auto"),
          (this.element.style.userSelect = "none"),
          this.element.setAttribute("draggable", !1),
          this.addEventListener("removed", () => {
            this.traverse((t) => {
              t.element instanceof Element &&
                null !== t.element.parentNode &&
                t.element.parentNode.removeChild(t.element);
            });
          });
      }
      copy(t, e) {
        return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this;
      }
    },
  };
class rW {
  constructor(t) {
    (this.props = t),
      (this.rerender = () => {
        const { sceneSystem: t, cameraSystem: e } = this.props;
        t.coreScene &&
          e.coreCamera &&
          this.markerRenderer.render(t.coreScene, e.coreCamera);
      }),
      this.props,
      this.__initMarkerRenderer();
  }
  __initMarkerRenderer() {
    const { markerType: t, containerDom: e } = this.props;
    this.markerRenderer = new iW[t](this);
    const i = e.clientWidth,
      n = e.clientHeight;
    this.setSize(i, n),
      (this.markerRenderer.domElement.className = "marker-container"),
      (this.markerRenderer.domElement.style.position = "absolute"),
      (this.markerRenderer.domElement.style.top = "0px"),
      e.firstChild.appendChild(this.markerRenderer.domElement);
  }
  render(t, e) {
    this.markerRenderer.render(t, e);
  }
  setSize(t, e) {
    this.markerRenderer.setSize(t, e);
  }
  destroy() {
    var t, e;
    null == (t = this.domResize) || t.disconnect(),
      null == (e = this.controls) ||
        e.removeEventListener("change", this.rerender),
      (this.markerRenderer = null);
  }
}
var oW, aW;
((aW = oW || (oW = {})).CPU = "cpu"), (aW.GPU = "gpu");
const sW = oW.CPU,
  lW = (t, e) => {
    if (!t || 0 == t.length) return t;
    const { as: i } = e;
    if (t[0].lng) {
      return t.map((t) =>
        ot(rt({}, t), {
          [i]: Qf([t.lng, t.lat]),
        })
      );
    }
    return t.map((t) => {
      const { coordinates: e } = t.geometry || {};
      if (!Array.isArray(e[0])) {
        const n = Qf(e);
        return ot(rt({}, t), {
          [i]: n,
        });
      }
      const n = e.map((t) =>
        Array.isArray(t[0]) ? t.map((t) => Qf(t)) : Qf(t)
      );
      return ot(rt({}, t), {
        [i]: n,
        geometry: ot(rt({}, t.geometry), {
          [i]: n,
        }),
      });
    });
  },
  uW = ot(
    rt(
      {},
      {
        duration: 1e3,
        loop: 0,
        yoyo: !1,
      }
    ),
    {
      type: "straight",
    }
  );
class cW {
  constructor() {
    this.tweenGroup = new BU();
  }
  run(t) {
    const e = [];
    t.animation.forEach((t, i) => {
      const n = this.__createCameraTween(
        t.from,
        t.to,
        t.duration,
        t.delay,
        t.ease,
        t.subEase
      );
      e.push(n);
    }),
      (this.tween = e.reduce((t, e) => t.chain(e))),
      this.tween.repeat(t.loop),
      this.tween.yoyo(t.yoyo),
      this.tween.start();
    if (this.tween._chainedTweens.length > 0) {
      this.tween.onStart(() => {
        this._startHandle(t.onStart);
      });
      [this.tween, ...this.tween._chainedTweens].forEach((e) => {
        e.onUpdate((e) => {
          this._updateHandle(t.onUpdate, e);
        });
      }),
        this.tween._chainedTweens.lastItem.onComplete((e) => {
          this._endHandle(t.onComplete);
        });
    } else
      this.tween.onStart(() => {
        this._startHandle(t.onStart);
      }),
        this.tween.onUpdate((e) => {
          this._updateHandle(t.onUpdate, e);
        }),
        this.tween.onComplete((e) => {
          this._endHandle(t.onComplete);
        });
  }
  __createCameraTween(t, e, i, n = 0, r, o) {
    return new HU(t).to(e, i).delay(n).easing(this.__getEasingFunction(r, o));
  }
  __getEasingFunction(t = "Linear", e = "In") {
    return "Linear" === t ? zU.Linear.None : zU[t][e];
  }
  _startHandle(t) {
    t && t();
  }
  _updateHandle(t, e) {
    t && t(e);
  }
  _endHandle(t) {
    t && t(), QU(this.tween);
  }
  pause() {
    this.tween.pause();
  }
  start() {
    this.tween.start();
  }
  stop() {
    this.tween.stop();
  }
}
var hW = Object.defineProperty,
  pW = Object.getOwnPropertyDescriptor;
class dW {
  constructor(t) {
    (this.props = t),
      (this.ee = new dt()),
      (this.__isRenderHeightZero = () =>
        0 === this.props.renderSystem.getSize().y),
      (this.state = this.props.config);
    const { gisStateApi: e, controls: i } = this.props.controlsSystem;
    e.subscribe(AG.WebGis, (t) => {
      this.props.gis.ee.emit("viewportChange", this.get());
    }),
      [
        ["pan", "pan"],
        ["panStart", "panStart"],
        ["panEnd", "panEnd"],
        ["zoom", "zoom"],
        ["zoomStart", "zoomStart"],
        ["zoomEnd", "zoomEnd"],
        ["rotate", "rotate"],
        ["rotateStart", "rotateStart"],
        ["rotateEnd", "rotateEnd"],
        ["pitch", "pitch"],
        ["pitchStart", "pitchStart"],
        ["pitchEnd", "pitchEnd"],
      ].forEach(([t, e]) => {
        i.addEventListener(t, () => {
          this.props.gis.ee.emit(e, this.get());
        });
      });
  }
  init(t = this.state.mode) {
    switch (t) {
      case "xgis":
        this.set(this.state);
        break;
      case "webgis":
        this.setWebGisCameraState(this.state);
        break;
      case "engine":
        this.setCameraState(this.state);
        break;
      default:
        this.logService.error("视角初始化参数不合理");
    }
  }
  get() {
    const { gisStateApi: t } = this.props.controlsSystem;
    return {
      zoom: t.getSourceState().zoom,
      center: t.getSourceState().center,
      pitch: t.getSourceState().pitch,
      rotation: t.getSourceState().rotation,
      enableZoom: t.getSourceState().enableZoom,
      enablePitch: t.getSourceState().enablePitch,
      enableRotate: t.getSourceState().enableRotate,
      enablePan: t.getSourceState().enablePan,
      lock: t.getSourceState().lock,
      zoomSpeed: t.getSourceState().zoomSpeed,
      rotateSpeed: t.getSourceState().rotateSpeed,
      panSpeed: t.getSourceState().panSpeed,
      maxPitch: t.getSourceState().maxPitch,
      minPitch: t.getSourceState().minPitch,
      maxRotation: t.getSourceState().maxRotation,
      minRotation: t.getSourceState().minRotation,
      minZoom: t.getSourceState().minZoom,
      maxZoom: t.getSourceState().maxZoom,
      drillSave: t.getSourceState().drillSave,
      offset: t.get(AG.XGis).offset,
    };
  }
  set(t, e) {
    if (((this.state = af(this.state, t)), this.__isRenderHeightZero()))
      return this.logService.warn("画布的高度为0", "跳过 set"), this;
    const { gisStateApi: i } = this.props.controlsSystem,
      n = rt(
        {
          offset: uf(t.offset) ? i.get(AG.XGis).offset : t.offset,
          pitch: uf(t.pitch) ? i.getSourceState().pitch : t.pitch,
          rotation: uf(t.rotation) ? i.getSourceState().rotation : t.rotation,
        },
        this.getBaseCameraState(t)
      );
    if (e) {
      const t = af(uW, e),
        { type: r, loop: o, yoyo: a, duration: s, delay: l } = t,
        u = new cW();
      let c;
      switch (r) {
        case "orbit":
          i.set(AG.XGis, n),
            (c = {
              name: "相机环绕轨道动画",
              loop: o,
              yoyo: a,
              onStart: () => {
                this.props.controlsSystem.lock();
              },
              onComplete: () => {
                this.props.controlsSystem.unlock(),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "end",
                  });
              },
              onUpdate: (t) => {
                i.set(AG.WebGis, t),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "change",
                  });
              },
              animation: [
                {
                  from: {
                    rotation: i.getSourceState().minRotation,
                  },
                  to: {
                    rotation: i.getSourceState().maxRotation,
                  },
                  duration: s,
                  delay: l,
                },
              ],
            });
          break;
        case "straight":
          c = {
            name: "相机两点直线动画",
            loop: o,
            yoyo: a,
            onStart: () => {
              this.props.controlsSystem.lock();
            },
            onComplete: () => {
              this.props.controlsSystem.unlock(),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "end",
                });
            },
            onUpdate: (t) => {
              i.set(AG.XGis, t),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "change",
                });
            },
            animation: [
              {
                from: {
                  offset: i.get(AG.XGis).offset,
                  pitch: i.getSourceState().pitch,
                  rotation: i.getSourceState().rotation,
                },
                to: n,
                duration: s,
                delay: l,
              },
            ],
          };
      }
      u.run(c);
    } else
      i.set(AG.XGis, n),
        this.props.controlsSystem.controls.dispatchEvent({
          type: "end",
        });
    return this;
  }
  getCameraState() {
    return {
      position: this.props.cameraSystem.coreCamera.position.toArray(),
      target: this.props.controlsSystem.controls.target.toArray(),
      up: this.props.cameraSystem.coreCamera.up.toArray(),
    };
  }
  setCameraState(t, e) {
    this.state = af(this.state, t);
    const { gisStateApi: i } = this.props.controlsSystem;
    if (this.__isRenderHeightZero())
      return this.logService.warn("画布的高度为0", "跳过 setCameraState"), this;
    if (e) {
      const n = af(uW, e),
        { type: r, loop: o, yoyo: a, duration: s, delay: l } = n,
        u = new cW();
      let c;
      switch (r) {
        case "orbit":
          i.set(AG.Engine, t),
            (c = {
              name: "相机环绕轨道动画",
              loop: o,
              yoyo: a,
              onStart: () => {
                this.props.controlsSystem.lock();
              },
              onComplete: () => {
                this.props.controlsSystem.unlock(),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "end",
                  });
              },
              onUpdate: (t) => {
                i.set(AG.WebGis, t),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "change",
                  });
              },
              animation: [
                {
                  from: {
                    rotation: i.getSourceState().rotation,
                  },
                  to: {
                    rotation: 360 + i.getSourceState().rotation,
                  },
                  duration: s,
                  delay: l,
                },
              ],
            });
          break;
        case "straight":
          c = {
            name: "相机两点直线动画",
            loop: o,
            yoyo: a,
            onStart: () => {
              this.props.controlsSystem.lock();
            },
            onComplete: () => {
              this.props.controlsSystem.unlock(),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "end",
                });
            },
            onUpdate: (t) => {
              i.set(AG.Engine, t),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "change",
                });
            },
            animation: [
              {
                from: {
                  position:
                    this.props.cameraSystem.coreCamera.position.toArray(),
                  target: this.props.controlsSystem.controls.target.toArray(),
                  up: this.props.cameraSystem.coreCamera.up.toArray(),
                },
                to: t,
                duration: s,
                delay: l,
              },
            ],
          };
      }
      u.run(c);
    } else
      i.set(AG.Engine, t),
        this.props.controlsSystem.controls.dispatchEvent({
          type: "end",
        });
    return this;
  }
  getWebGisCameraState() {
    const { gisStateApi: t } = this.props.controlsSystem;
    return t.get(AG.WebGis);
  }
  setWebGisCameraState(t, e) {
    if (((this.state = af(this.state, t)), this.__isRenderHeightZero()))
      return (
        this.logService.warn("画布的高度为0", "跳过 setWebGisCameraState"), this
      );
    const { gisStateApi: i } = this.props.controlsSystem,
      n = rt(
        {
          zoom: uf(t.zoom) ? i.getSourceState().zoom : t.zoom,
          center: uf(t.center) ? i.getSourceState().center : t.center,
          pitch: uf(t.pitch) ? i.getSourceState().pitch : t.pitch,
          rotation: uf(t.rotation) ? i.getSourceState().rotation : t.rotation,
        },
        this.getBaseCameraState(t)
      );
    if (e) {
      const t = af(uW, e),
        { type: r, loop: o, yoyo: a, duration: s, delay: l } = t,
        u = new cW();
      let c;
      switch (r) {
        case "orbit":
          i.set(AG.WebGis, n),
            (c = {
              name: "相机环绕轨道动画",
              loop: o,
              yoyo: a,
              onStart: () => {
                this.props.controlsSystem.lock();
              },
              onComplete: () => {
                this.props.controlsSystem.unlock(),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "end",
                  });
              },
              onUpdate: (t) => {
                i.set(AG.WebGis, t),
                  this.props.controlsSystem.controls.dispatchEvent({
                    type: "change",
                  });
              },
              animation: [
                {
                  from: {
                    rotation: i.getSourceState().minRotation,
                  },
                  to: {
                    rotation: i.getSourceState().maxRotation,
                  },
                  duration: s,
                  delay: l,
                },
              ],
            });
          break;
        case "straight":
          c = {
            name: "相机两点直线动画",
            loop: o,
            yoyo: a,
            onStart: () => {
              this.props.controlsSystem.lock();
            },
            onComplete: () => {
              this.props.controlsSystem.unlock(),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "end",
                });
            },
            onUpdate: (t) => {
              i.set(AG.WebGis, t),
                this.props.controlsSystem.controls.dispatchEvent({
                  type: "change",
                });
            },
            animation: [
              {
                from: {
                  zoom: i.getSourceState().zoom,
                  center: i.getSourceState().center,
                  pitch: i.getSourceState().pitch,
                  rotation: i.getSourceState().rotation,
                },
                to: n,
                duration: s,
                delay: l,
              },
            ],
          };
      }
      u.run(c);
    } else
      i.set(AG.WebGis, n),
        this.props.controlsSystem.controls.dispatchEvent({
          type: "end",
        });
    return this;
  }
  getBaseCameraState(t) {
    const { gisStateApi: e } = this.props.controlsSystem;
    return {
      enablePan: uf(t.enablePan) ? e.getSourceState().enablePan : t.enablePan,
      enablePitch: uf(t.enablePitch)
        ? e.getSourceState().enablePitch
        : t.enablePitch,
      enableRotate: uf(t.enableRotate)
        ? e.getSourceState().enableRotate
        : t.enableRotate,
      enableZoom: uf(t.enableZoom)
        ? e.getSourceState().enableZoom
        : t.enableZoom,
      lock: uf(t.lock) ? e.getSourceState().lock : t.lock,
      zoomSpeed: uf(t.zoomSpeed) ? e.getSourceState().zoomSpeed : t.zoomSpeed,
      rotateSpeed: uf(t.rotateSpeed)
        ? e.getSourceState().rotateSpeed
        : t.rotateSpeed,
      panSpeed: uf(t.panSpeed) ? e.getSourceState().panSpeed : t.panSpeed,
      maxPitch: uf(t.maxPitch) ? e.getSourceState().maxPitch : t.maxPitch,
      minPitch: uf(t.minPitch) ? e.getSourceState().minPitch : t.minPitch,
      maxRotation: uf(t.maxRotation)
        ? e.getSourceState().maxRotation
        : t.maxRotation,
      minRotation: uf(t.minRotation)
        ? e.getSourceState().minRotation
        : t.minRotation,
      maxZoom: uf(t.maxZoom) ? e.getSourceState().maxZoom : t.maxZoom,
      minZoom: uf(t.minZoom) ? e.getSourceState().minZoom : t.minZoom,
      drillSave: uf(t.drillSave) ? e.getSourceState().drillSave : t.drillSave,
    };
  }
  setSize(t, e) {
    this.props.cameraSystem.update(t, e);
  }
  destroy() {
    this.ee.removeAllListeners();
  }
}
function fW(t) {
  let e;
  return (
    (e = (null == t ? void 0 : t.mode)
      ? t.mode
      : (null == t ? void 0 : t.offset)
      ? "xgis"
      : ((null == t ? void 0 : t.zoom) && (null == t || t.center), "webgis")),
    e
  );
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? pW(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && hW(e, i, o);
})([_G(KB.ILogService)], dW.prototype, "logService", 2);
var gW = Math.PI / 3,
  mW = [0, gW, 2 * gW, 3 * gW, 4 * gW, 5 * gW];
function yW(t) {
  return t[0];
}
function vW(t) {
  return t[1];
}
const bW = (t, e) => {
    const { size: i = 10, boundary: n, tessellate: r } = e;
    if (0 === t.length) return t;
    const o = sm(n, Qf);
    let a = am.bbox(o);
    a = [
      [a[0], a[1]],
      [a[2], a[3]],
    ];
    const s = (function () {
        var t,
          e,
          i,
          n = 0,
          r = 0,
          o = 1,
          a = 1,
          s = yW,
          l = vW;
        function u(t) {
          var n,
            r = {},
            o = [],
            a = t.length;
          for (n = 0; n < a; ++n)
            if (
              !isNaN((c = +s.call(null, (u = t[n]), n, t))) &&
              !isNaN((h = +l.call(null, u, n, t)))
            ) {
              var u,
                c,
                h,
                p = Math.round((h /= i)),
                d = Math.round((c = c / e - (1 & p) / 2)),
                f = h - p;
              if (3 * Math.abs(f) > 1) {
                var g = c - d,
                  m = d + (c < d ? -1 : 1) / 2,
                  y = p + (h < p ? -1 : 1),
                  v = c - m,
                  b = h - y;
                g * g + f * f > v * v + b * b &&
                  ((d = m + (1 & p ? 1 : -1) / 2), (p = y));
              }
              var x = d + "-" + p,
                _ = r[x];
              _
                ? _.push(u)
                : (o.push((_ = r[x] = [u])),
                  (_.x = (d + (1 & p) / 2) * e),
                  (_.y = p * i));
            }
          return o;
        }
        function c(t) {
          var e = 0,
            i = 0;
          return mW.map(function (n) {
            var r = Math.sin(n) * t,
              o = -Math.cos(n) * t,
              a = r - e,
              s = o - i;
            return (e = r), (i = o), [a, s];
          });
        }
        return (
          (u.hexagon = function (e) {
            return "m" + c(null == e ? t : +e).join("l") + "z";
          }),
          (u.centers = function () {
            for (
              var s = [],
                l = Math.round(r / i),
                u = Math.round(n / e),
                c = l * i;
              c < a + t;
              c += i, ++l
            )
              for (var h = u * e + ((1 & l) * e) / 2; h < o + e / 2; h += e)
                s.push([h, c]);
            return s;
          }),
          (u.mesh = function () {
            var e = c(t).slice(0, 4).join("l");
            return u
              .centers()
              .map(function (t) {
                return "M" + t + "m" + e;
              })
              .join("");
          }),
          (u.x = function (t) {
            return arguments.length ? ((s = t), u) : s;
          }),
          (u.y = function (t) {
            return arguments.length ? ((l = t), u) : l;
          }),
          (u.radius = function (n) {
            return arguments.length
              ? ((e = 2 * (t = +n) * Math.sin(gW)), (i = 1.5 * t), u)
              : t;
          }),
          (u.size = function (t) {
            return arguments.length
              ? ((n = r = 0), (o = +t[0]), (a = +t[1]), u)
              : [o - n, a - r];
          }),
          (u.extent = function (t) {
            return arguments.length
              ? ((n = +t[0][0]),
                (r = +t[0][1]),
                (o = +t[1][0]),
                (a = +t[1][1]),
                u)
              : [
                  [n, r],
                  [o, a],
                ];
          }),
          u.radius(1)
        );
      })()
        .extent(a)
        .radius(i)
        .x((t) => t.coordinates[0])
        .y((t) => t.coordinates[1]),
      l = [],
      u = {};
    Object.keys(t[0]).forEach((t) => {
      u[t] = null;
    }),
      r &&
        n &&
        s.centers().forEach((t) => {
          Kw(
            {
              lng: t[0],
              lat: t[1],
            },
            o,
            Qw.intersect
          ) &&
            l.push(
              ot(rt({}, u), {
                coordinates: t,
              })
            );
        });
    return s(l.concat(t)).map((t) => ({
      points: t,
      x: t.x,
      y: t.y,
    }));
  },
  xW = () => {
    let t = {},
      e = [];
    const i = [],
      n = [];
    let r = 0.1,
      o = 0.1;
    let a = 2,
      s = 6,
      l = 70,
      u = 0.6666667,
      c = 0.6;
    const h = (e) => ({
        x: t[e.target].x - t[e.source].x,
        y: t[e.target].y - t[e.source].y,
      }),
      p = (e) =>
        Math.sqrt(
          Math.pow(t[e.source].x - t[e.target].x, 2) +
            Math.pow(t[e.source].y - t[e.target].y, 2)
        ),
      d = (t, e) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)),
      f = (t) => {
        let e = 0;
        for (let i = 1; i < n[t].length; i++) {
          e += d(n[t][i], n[t][i - 1]);
        }
        return e;
      },
      g = (t, e) => {
        const i = Math.sqrt(
            (e.target.x - e.source.x) * (e.target.x - e.source.x) +
              (e.target.y - e.source.y) * (e.target.y - e.source.y)
          ),
          n =
            ((e.source.y - t.y) * (e.source.y - e.target.y) -
              (e.source.x - t.x) * (e.target.x - e.source.x)) /
            (i * i);
        return {
          x: e.source.x + n * (e.target.x - e.source.x),
          y: e.source.y + n * (e.target.y - e.source.y),
        };
      },
      m = (t, e, i) => {
        const r = n[t][e - 1],
          o = n[t][e + 1],
          a = n[t][e];
        let s = r.x - a.x + o.x - a.x,
          l = r.y - a.y + o.y - a.y;
        return (
          (s *= i),
          (l *= i),
          {
            x: s,
            y: l,
          }
        );
      },
      y = (t, e, r) => {
        const o = {
            x: 0,
            y: 0,
          },
          a = i[t];
        for (let i = 0; i < a.length; i++) {
          const r = {
            x: n[a[i]][e].x - n[t][e].x,
            y: n[a[i]][e].y - n[t][e].y,
          };
          if (Math.abs(r.x) > 1e-8 || Math.abs(r.y) > 1e-8) {
            const l =
              1 /
              Math.pow(
                ((s = {
                  source: n[a[i]][e],
                  target: n[t][e],
                }),
                Math.sqrt(
                  Math.pow(s.source.x - s.target.x, 2) +
                    Math.pow(s.source.y - s.target.y, 2)
                )),
                1
              );
            (o.x += r.x * l), (o.y += r.y * l);
          }
        }
        var s;
        return o;
      },
      v = (t, i, n) => {
        const o = r / (p(e[t]) * (i + 1)),
          a = [
            {
              x: 0,
              y: 0,
            },
          ];
        for (let e = 1; e < i + 1; e++) {
          const i = {
              x: 0,
              y: 0,
            },
            r = m(t, e, o),
            s = y(t, e);
          (i.x = n * (r.x + s.x)), (i.y = n * (r.y + s.y)), a.push(i);
        }
        return (
          a.push({
            x: 0,
            y: 0,
          }),
          a
        );
      },
      b = (i) => {
        for (let o = 0; o < e.length; o++)
          if (1 == i)
            n[o].push(t[e[o].source]),
              n[o].push(
                ((r = e[o]),
                {
                  x: (t[r.source].x + t[r.target].x) / 2,
                  y: (t[r.source].y + t[r.target].y) / 2,
                })
              ),
              n[o].push(t[e[o].target]);
          else {
            const r = f(o) / (i + 1);
            let a = r;
            const s = [];
            s.push(t[e[o].source]);
            for (let t = 1; t < n[o].length; t++) {
              let e = d(n[o][t], n[o][t - 1]);
              for (; e > a; ) {
                const i = a / e;
                let l = n[o][t - 1].x,
                  u = n[o][t - 1].y;
                (l += i * (n[o][t].x - n[o][t - 1].x)),
                  (u += i * (n[o][t].y - n[o][t - 1].y)),
                  s.push({
                    x: l,
                    y: u,
                  }),
                  (e -= a),
                  (a = r);
              }
              a -= e;
            }
            s.push(t[e[o].target]), (n[o] = s);
          }
        var r;
      },
      x = (e, i) => {
        const n = g(t[i.source], {
            source: t[e.source],
            target: t[e.target],
          }),
          r = g(t[i.target], {
            source: t[e.source],
            target: t[e.target],
          }),
          o = {
            x: (n.x + r.x) / 2,
            y: (n.y + r.y) / 2,
          },
          a = {
            x: (t[e.source].x + t[e.target].x) / 2,
            y: (t[e.source].y + t[e.target].y) / 2,
          };
        return Math.max(0, 1 - (2 * d(a, o)) / d(n, r));
      },
      _ = (e, i) => {
        const n =
          ((t, e) => {
            var i, n;
            return Math.abs(
              ((i = h(t)), (n = h(e)), (i.x * n.x + i.y * n.y) / (p(t) * p(e)))
            );
          })(e, i) *
          ((t, e) => {
            const i = (p(t) + p(e)) / 2;
            return 2 / (i / Math.min(p(t), p(e)) + Math.max(p(t), p(e)) / i);
          })(e, i) *
          ((e, i) => {
            const n = (p(e) + p(i)) / 2,
              r = {
                x: (t[e.source].x + t[e.target].x) / 2,
                y: (t[e.source].y + t[e.target].y) / 2,
              },
              o = {
                x: (t[i.source].x + t[i.target].x) / 2,
                y: (t[i.source].y + t[i.target].y) / 2,
              };
            return n / (n + d(r, o));
          })(e, i) *
          ((t, e) => Math.min(x(t, e), x(e, t)))(e, i);
        return n;
      };
    let S = o,
      M = l,
      C = 1;
    const w = () => {
      (S = o),
        (M = l),
        (C = 1),
        (() => {
          for (let t = 0; t < e.length; t++) n[t] = [];
        })(),
        (() => {
          for (let t = 0; t < e.length; t++) i[t] = [];
        })(),
        b(C),
        (() => {
          for (let r = 0; r < e.length - 1; r++)
            for (let o = r + 1; o < e.length; o++)
              r != o &&
                ((t = e[r]),
                (n = e[o]),
                _(t, n) >= c && (i[r].push(o), i[o].push(r)));
          var t, n;
        })();
      for (let t = 0; t < s; t++) {
        for (let t = 0; t < M; t++) {
          const t = [];
          for (let i = 0; i < e.length; i++) t[i] = v(i, C, S);
          for (let i = 0; i < e.length; i++)
            for (let e = 0; e < C + 1; e++)
              (n[i][e].x += t[i][e].x), (n[i][e].y += t[i][e].y);
        }
        (S /= 2), (C *= 2), (M *= u), b(C);
      }
      return n;
    };
    return (
      (w.nodes = function (e) {
        return 0 == arguments.length ? t : ((t = e), w);
      }),
      (w.edges = function (i) {
        return 0 == arguments.length
          ? e
          : ((e = ((e) => {
              const i = [];
              for (let n = 0; n < e.length; n++)
                t[e[n].source].x != t[e[n].target].x &&
                  t[e[n].source].y != t[e[n].target].y &&
                  i.push(e[n]);
              return i;
            })(i)),
            w);
      }),
      (w.bundling_stiffness = function (t) {
        return 0 == arguments.length ? r : ((r = t), w);
      }),
      (w.step_size = function (t) {
        return 0 == arguments.length ? o : ((o = t), w);
      }),
      (w.cycles = function (t) {
        return 0 == arguments.length ? s : ((s = t), w);
      }),
      (w.iterations = function (t) {
        return 0 == arguments.length ? l : ((l = t), w);
      }),
      (w.iterations_rate = function (t) {
        return 0 == arguments.length ? u : ((u = t), w);
      }),
      (w.subdivision_points_seed = function (t) {
        return 0 == arguments.length ? C : ((C = t), w);
      }),
      (w.subdivision_rate = function (t) {
        return 0 == arguments.length ? a : ((a = t), w);
      }),
      (w.compatibility_threshold = function (t) {
        return 0 == arguments.length ? c : ((c = t), w);
      }),
      w
    );
  },
  _W = (t, e) => {
    const { size: i = 10, boundary: n, tessellate: r } = e;
    if (0 === t.length) return t;
    let o = [];
    if (r) {
      const e = sm(n, Qf);
      o = ((t, e, i, n) => {
        const r = [],
          [o, a, s, l] = t,
          u = s - o,
          c = l - a,
          h = Math.floor(Math.abs(u) / e),
          p = Math.floor(Math.abs(c) / e),
          d = {};
        Object.keys(n).forEach((t) => {
          d[t] = null;
        });
        let f = o;
        for (let g = 0; g < h; g++) {
          let t = a;
          for (let n = 0; n < p; n++) {
            const n = ot(rt({}, d), {
              coordinates: [f + e / 2, t + e / 2],
            });
            Kw(
              {
                lng: n.coordinates[0],
                lat: n.coordinates[1],
              },
              i,
              Qw.intersect
            ) && r.push(n),
              (t += e);
          }
          f += e;
        }
        return r;
      })(Em(e), i, e, t[0]);
    }
    const {
        gridHash: a,
        xOffset: s,
        yOffset: l,
        offsets: u,
      } = ((t, e) => {
        const i = Qf([180, 90]);
        for (const a of t) a.coordinates[1];
        const { xOffset: n, yOffset: r } = ((t, e) => ({
          yOffset: t,
          xOffset: t,
        }))(e);
        if (n <= 0 || r <= 0)
          return {
            gridHash: {},
            xOffset: n,
            yOffset: r,
          };
        const o = {};
        for (const a of t) {
          const [t, e] = a.coordinates;
          if (Number.isFinite(t) && Number.isFinite(e)) {
            const s = Math.floor((t + i[0]) / n),
              l = Math.floor((e + i[1]) / r),
              u = `${l}-${s}`;
            (o[u] = o[u] || {
              count: 0,
              points: [],
              lngIdx: s,
              latIdx: l,
            }),
              (o[u].count += 1),
              o[u].points.push(a);
          }
        }
        return {
          gridHash: o,
          xOffset: n,
          yOffset: r,
          offsets: i,
        };
      })(t.concat(o), i),
      c = ((t, e, i, n, r) => {
        const o = new Array(Object.keys(t).length);
        let a = 0;
        for (const s in t) {
          const l = s.split("-"),
            u = parseInt(l[0], 10) + 0.5,
            c = parseInt(l[1], 10) + 0.5,
            h = a++;
          o[h] = rt(
            {
              index: h,
              x: -n[0] + e * c + r / 2,
              y: -n[1] + i * u + r / 2,
            },
            t[s]
          );
        }
        return o;
      })(a, s, l, u, i);
    return c;
  };
var SW = {
  exports: {},
};
!(function (t) {
  var e = {
    exports: {},
  };
  function i(t, e, i) {
    i = i || 2;
    var r,
      a,
      s,
      l,
      u,
      h,
      p,
      d = e && e.length,
      f = d ? e[0] * i : t.length,
      g = n(t, 0, f, i, !0),
      m = [];
    if (!g) return m;
    if ((d && (g = c(t, e, g, i)), t.length > 80 * i)) {
      (r = s = t[0]), (a = l = t[1]);
      for (var y = i; y < f; y += i)
        (u = t[y]) < r && (r = u),
          (h = t[y + 1]) < a && (a = h),
          u > s && (s = u),
          h > l && (l = h);
      p = 0 !== (p = Math.max(s - r, l - a)) ? 1 / p : 0;
    }
    return o(g, m, i, r, a, p), m;
  }
  function n(t, e, i, n, r) {
    var o, a;
    if (r === P(t, e, i, n) > 0)
      for (o = e; o < i; o += n) a = E(o, t[o], t[o + 1], a);
    else for (o = i - n; o >= e; o -= n) a = E(o, t[o], t[o + 1], a);
    return a && _(a, a.next) && (D(a), (a = a.next)), a;
  }
  function r(t, e) {
    if (!t) return t;
    e || (e = t);
    var i,
      n = t;
    do {
      if (
        ((i = !1), n.steiner || (!_(n, n.next) && 0 !== x(n.prev, n, n.next)))
      )
        n = n.next;
      else {
        if ((D(n), (n = e = n.prev) === n.next)) break;
        i = !0;
      }
    } while (i || n !== e);
    return e;
  }
  function o(t, e, i, n, c, h, p) {
    if (t) {
      !p && h && f(t, n, c, h);
      for (var d, g, m = t; t.prev !== t.next; )
        if (((d = t.prev), (g = t.next), h ? s(t, n, c, h) : a(t)))
          e.push(d.i / i),
            e.push(t.i / i),
            e.push(g.i / i),
            D(t),
            (t = g.next),
            (m = g.next);
        else if ((t = g) === m) {
          p
            ? 1 === p
              ? o((t = l(t, e, i)), e, i, n, c, h, 2)
              : 2 === p && u(t, e, i, n, c, h)
            : o(r(t), e, i, n, c, h, 1);
          break;
        }
    }
  }
  function a(t) {
    var e = t.prev,
      i = t,
      n = t.next;
    if (x(e, i, n) >= 0) return !1;
    for (var r = t.next.next; r !== t.prev; ) {
      if (
        v(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
        x(r.prev, r, r.next) >= 0
      )
        return !1;
      r = r.next;
    }
    return !0;
  }
  function s(t, e, i, n) {
    var r = t.prev,
      o = t,
      a = t.next;
    if (x(r, o, a) >= 0) return !1;
    for (
      var s = r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
        l = r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
        u = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
        c = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
        h = m(s, l, e, i, n),
        p = m(u, c, e, i, n),
        d = t.prevZ,
        f = t.nextZ;
      d && d.z >= h && f && f.z <= p;

    ) {
      if (
        d !== t.prev &&
        d !== t.next &&
        v(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
        x(d.prev, d, d.next) >= 0
      )
        return !1;
      if (
        ((d = d.prevZ),
        f !== t.prev &&
          f !== t.next &&
          v(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
          x(f.prev, f, f.next) >= 0)
      )
        return !1;
      f = f.nextZ;
    }
    for (; d && d.z >= h; ) {
      if (
        d !== t.prev &&
        d !== t.next &&
        v(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
        x(d.prev, d, d.next) >= 0
      )
        return !1;
      d = d.prevZ;
    }
    for (; f && f.z <= p; ) {
      if (
        f !== t.prev &&
        f !== t.next &&
        v(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
        x(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.nextZ;
    }
    return !0;
  }
  function l(t, e, i) {
    var n = t;
    do {
      var r = n.prev,
        o = n.next.next;
      !_(r, o) &&
        S(r, n, n.next, o) &&
        C(r, o) &&
        C(o, r) &&
        (e.push(r.i / i),
        e.push(n.i / i),
        e.push(o.i / i),
        D(n),
        D(n.next),
        (n = t = o)),
        (n = n.next);
    } while (n !== t);
    return n;
  }
  function u(t, e, i, n, a, s) {
    var l = t;
    do {
      for (var u = l.next.next; u !== l.prev; ) {
        if (l.i !== u.i && b(l, u)) {
          var c = A(l, u);
          return (
            (l = r(l, l.next)),
            (c = r(c, c.next)),
            o(l, e, i, n, a, s),
            void o(c, e, i, n, a, s)
          );
        }
        u = u.next;
      }
      l = l.next;
    } while (l !== t);
  }
  function c(t, e, i, o) {
    var a,
      s,
      l,
      u = [];
    for (a = 0, s = e.length; a < s; a++)
      (l = n(t, e[a] * o, a < s - 1 ? e[a + 1] * o : t.length, o, !1)) ===
        l.next && (l.steiner = !0),
        u.push(y(l));
    for (u.sort(h), a = 0; a < u.length; a++) p(u[a], i), (i = r(i, i.next));
    return i;
  }
  function h(t, e) {
    return t.x - e.x;
  }
  function p(t, e) {
    if ((e = d(t, e))) {
      var i = A(e, t);
      r(i, i.next);
    }
  }
  function d(t, e) {
    var i,
      n = e,
      r = t.x,
      o = t.y,
      a = -1 / 0;
    do {
      if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
        var s = n.x + ((o - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
        if (s <= r && s > a) {
          if (((a = s), s === r)) {
            if (o === n.y) return n;
            if (o === n.next.y) return n.next;
          }
          i = n.x < n.next.x ? n : n.next;
        }
      }
      n = n.next;
    } while (n !== e);
    if (!i) return null;
    if (r === a) return i.prev;
    var l,
      u = i,
      c = i.x,
      h = i.y,
      p = 1 / 0;
    for (n = i.next; n !== u; )
      r >= n.x &&
        n.x >= c &&
        r !== n.x &&
        v(o < h ? r : a, o, c, h, o < h ? a : r, o, n.x, n.y) &&
        ((l = Math.abs(o - n.y) / (r - n.x)) < p || (l === p && n.x > i.x)) &&
        C(n, t) &&
        ((i = n), (p = l)),
        (n = n.next);
    return i;
  }
  function f(t, e, i, n) {
    var r = t;
    do {
      null === r.z && (r.z = m(r.x, r.y, e, i, n)),
        (r.prevZ = r.prev),
        (r.nextZ = r.next),
        (r = r.next);
    } while (r !== t);
    (r.prevZ.nextZ = null), (r.prevZ = null), g(r);
  }
  function g(t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u = 1;
    do {
      for (i = t, t = null, o = null, a = 0; i; ) {
        for (a++, n = i, s = 0, e = 0; e < u && (s++, (n = n.nextZ)); e++);
        for (l = u; s > 0 || (l > 0 && n); )
          0 !== s && (0 === l || !n || i.z <= n.z)
            ? ((r = i), (i = i.nextZ), s--)
            : ((r = n), (n = n.nextZ), l--),
            o ? (o.nextZ = r) : (t = r),
            (r.prevZ = o),
            (o = r);
        i = n;
      }
      (o.nextZ = null), (u *= 2);
    } while (a > 1);
    return t;
  }
  function m(t, e, i, n, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function y(t) {
    var e = t,
      i = t;
    do {
      e.x < i.x && (i = e), (e = e.next);
    } while (e !== t);
    return i;
  }
  function v(t, e, i, n, r, o, a, s) {
    return (
      (r - a) * (e - s) - (t - a) * (o - s) >= 0 &&
      (t - a) * (n - s) - (i - a) * (e - s) >= 0 &&
      (i - a) * (o - s) - (r - a) * (n - s) >= 0
    );
  }
  function b(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !M(t, e) &&
      C(t, e) &&
      C(e, t) &&
      w(t, e)
    );
  }
  function x(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function _(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function S(t, e, i, n) {
    return (
      !!((_(t, e) && _(i, n)) || (_(t, n) && _(i, e))) ||
      (x(t, e, i) > 0 != x(t, e, n) > 0 && x(i, n, t) > 0 != x(i, n, e) > 0)
    );
  }
  function M(t, e) {
    var i = t;
    do {
      if (
        i.i !== t.i &&
        i.next.i !== t.i &&
        i.i !== e.i &&
        i.next.i !== e.i &&
        S(i, i.next, t, e)
      )
        return !0;
      i = i.next;
    } while (i !== t);
    return !1;
  }
  function C(t, e) {
    return x(t.prev, t, t.next) < 0
      ? x(t, e, t.next) >= 0 && x(t, t.prev, e) >= 0
      : x(t, e, t.prev) < 0 || x(t, t.next, e) < 0;
  }
  function w(t, e) {
    var i = t,
      n = !1,
      r = (t.x + e.x) / 2,
      o = (t.y + e.y) / 2;
    do {
      i.y > o != i.next.y > o &&
        i.next.y !== i.y &&
        r < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
        (n = !n),
        (i = i.next);
    } while (i !== t);
    return n;
  }
  function A(t, e) {
    var i = new T(t.i, t.x, t.y),
      n = new T(e.i, e.x, e.y),
      r = t.next,
      o = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (i.next = r),
      (r.prev = i),
      (n.next = i),
      (i.prev = n),
      (o.next = n),
      (n.prev = o),
      n
    );
  }
  function E(t, e, i, n) {
    var r = new T(t, e, i);
    return (
      n
        ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function D(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function T(t, e, i) {
    (this.i = t),
      (this.x = e),
      (this.y = i),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  function P(t, e, i, n) {
    for (var r = 0, o = e, a = i - n; o < i; o += n)
      (r += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
    return r;
  }
  (e.exports = i),
    (e.exports.default = i),
    (i.deviation = function (t, e, i, n) {
      var r = e && e.length,
        o = r ? e[0] * i : t.length,
        a = Math.abs(P(t, 0, o, i));
      if (r)
        for (var s = 0, l = e.length; s < l; s++) {
          var u = e[s] * i,
            c = s < l - 1 ? e[s + 1] * i : t.length;
          a -= Math.abs(P(t, u, c, i));
        }
      var h = 0;
      for (s = 0; s < n.length; s += 3) {
        var p = n[s] * i,
          d = n[s + 1] * i,
          f = n[s + 2] * i;
        h += Math.abs(
          (t[p] - t[f]) * (t[d + 1] - t[p + 1]) -
            (t[p] - t[d]) * (t[f + 1] - t[p + 1])
        );
      }
      return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a);
    }),
    (i.flatten = function (t) {
      for (
        var e = t[0][0].length,
          i = {
            vertices: [],
            holes: [],
            dimensions: e,
          },
          n = 0,
          r = 0;
        r < t.length;
        r++
      ) {
        for (var o = 0; o < t[r].length; o++)
          for (var a = 0; a < e; a++) i.vertices.push(t[r][o][a]);
        r > 0 && ((n += t[r - 1].length), i.holes.push(n));
      }
      return i;
    });
  var L = e.exports;
  function I(t, e) {
    var i = t[0] - e[0],
      n = t[1] - e[1];
    return i * i + n * n;
  }
  function N(t, e, i) {
    var n = e[0],
      r = e[1],
      o = i[0] - n,
      a = i[1] - r;
    if (0 !== o || 0 !== a) {
      var s = ((t[0] - n) * o + (t[1] - r) * a) / (o * o + a * a);
      s > 1 ? ((n = i[0]), (r = i[1])) : s > 0 && ((n += o * s), (r += a * s));
    }
    return (o = t[0] - n) * o + (a = t[1] - r) * a;
  }
  function R(t, e) {
    for (var i, n = t[0], r = [n], o = 1, a = t.length; o < a; o++)
      I((i = t[o]), n) > e && (r.push(i), (n = i));
    return n !== i && r.push(i), r;
  }
  function O(t, e, i, n, r) {
    for (var o, a = n, s = e + 1; s < i; s++) {
      var l = N(t[s], t[e], t[i]);
      l > a && ((o = s), (a = l));
    }
    a > n &&
      (o - e > 1 && O(t, e, o, n, r),
      r.push(t[o]),
      i - o > 1 && O(t, o, i, n, r));
  }
  function F(t, e) {
    var i = t.length - 1,
      n = [t[0]];
    return O(t, 0, i, e, n), n.push(t[i]), n;
  }
  function z(t, e, i) {
    if (t.length <= 2) return t;
    var n = void 0 !== e ? e * e : 1;
    return (t = F((t = i ? t : R(t, n)), n));
  }
  function k(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function B(t, e) {
    return t[0] * e[0] + t[1] * e[1];
  }
  function G(t, e) {
    var i = e[0],
      n = e[1],
      r = e[2],
      o = Math.sqrt(i * i + n * n + r * r);
    return (t[0] = i / o), (t[1] = n / o), (t[2] = r / o), t;
  }
  function U(t, e) {
    var i = e[0],
      n = e[1],
      r = Math.sqrt(i * i + n * n);
    return (t[0] = i / r), (t[1] = n / r), t;
  }
  function j(t, e, i) {
    return (t[0] = e[0] * i), (t[1] = e[1] * i), (t[2] = e[2] * i), t;
  }
  function H(t, e, i, n) {
    return (
      (t[0] = e[0] + i[0] * n),
      (t[1] = e[1] + i[1] * n),
      (t[2] = e[2] + i[2] * n),
      t
    );
  }
  function V(t, e, i) {
    return (t[0] = e[0] + i[0]), (t[1] = e[1] + i[1]), t;
  }
  function W(t, e, i) {
    return (t[0] = e[0] - i[0]), (t[1] = e[1] - i[1]), (t[2] = e[2] - i[2]), t;
  }
  function q(t, e) {
    var i = e[0],
      n = e[1],
      r = e[2],
      o = Math.sqrt(i * i + n * n + r * r);
    return (t[0] = i / o), (t[1] = n / o), (t[2] = r / o), t;
  }
  function Y(t, e, i) {
    var n = e[0],
      r = e[1],
      o = e[2],
      a = i[0],
      s = i[1],
      l = i[2];
    return (
      (t[0] = r * l - o * s), (t[1] = o * a - n * l), (t[2] = n * s - r * a), t
    );
  }
  var X = [];
  function Q(t, e, i, n) {
    var r = k(e, i),
      o = Math.acos(r) * n;
    return (
      H(X, i, e, -r), G(X, X), j(t, e, Math.cos(o)), H(t, t, X, Math.sin(o)), t
    );
  }
  function Z(t, e, i, n, r, o, a, s, l, u) {
    var c = a - r,
      h = s - o,
      p = (c * (e - o) - h * (t - r)) / (h * (i - t) - c * (n - e));
    return (
      l && ((l[(u = u || 0)] = t + p * (i - t)), (l[u + 1] = e + p * (n - e))),
      p
    );
  }
  function J(t, e, i) {
    if (i - e < 3) return 0;
    for (var n = 0, r = 2 * (i - 1), o = 2 * e; o < 2 * i; ) {
      var a = t[r],
        s = t[r + 1],
        l = t[o],
        u = t[o + 1];
      (r = o), (o += 2), (n += a * u - l * s);
    }
    return n;
  }
  function K(t, e) {
    return L(
      t,
      e,
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2
    );
  }
  function $(t) {
    return L.flatten(t);
  }
  var tt = [],
    et = [],
    it = [];
  function nt(t, e, i, n, r, o, a, s, l) {
    var u,
      c,
      h,
      p = null != a,
      d = r,
      f = null;
    p && (f = new Uint32Array(n - i));
    for (var g = [], m = i; m < n; m++) {
      var y = m === n - 1 ? i : m + 1,
        v = m === i ? n - 1 : m - 1,
        b = t[2 * v],
        x = t[2 * v + 1],
        _ = t[2 * m],
        S = t[2 * m + 1],
        M = t[2 * y],
        C = t[2 * y + 1];
      (tt[0] = _ - b),
        (tt[1] = S - x),
        (et[0] = M - _),
        (et[1] = C - S),
        U(tt, tt),
        U(et, et),
        p && (f[m] = d);
      var w = !1,
        A = void 0,
        E = void 0;
      if (s || m !== i)
        if (s || m !== n - 1) {
          V(it, et, tt);
          var D = it[1];
          (it[1] = -it[0]), (it[0] = D), U(it, it);
          var T = B(it, et),
            P = Math.sqrt(1 - T * T),
            L = o * Math.min(10, 1 / P);
          if (p && 1 / P > a && o * T < 0) {
            var I = _ + it[0] * o,
              N = S + it[1] * o,
              R = Math.acos(P) / 2,
              O = Math.tan(R) * Math.abs(o);
            (e[2 * d] = I + it[1] * O),
              (e[2 * d + 1] = N - it[0] * O),
              (e[2 * ++d] = I - it[1] * O),
              (e[2 * d + 1] = N + it[0] * O),
              d++;
          } else (A = _ + it[0] * L), (E = S + it[1] * L), (w = !0);
          if (w) {
            if (l && null != u) {
              var F = Z(b, x, u, c, _, S, A, E, g, 0);
              F >= -0.01 &&
                F <= 1.01 &&
                ((e[2 * h] = A = g[0]), (e[2 * h + 1] = E = g[1]));
            }
            (u = e[2 * d] = A), (c = e[2 * d + 1] = E), (h = d), d++;
          }
        } else
          (it[0] = tt[1]),
            (it[1] = -tt[0]),
            U(it, it),
            (A = _ + it[0] * o),
            (E = S + it[1] * o),
            (w = !0);
      else
        (it[0] = et[1]),
          (it[1] = -et[0]),
          U(it, it),
          (u = e[2 * d] = _ + it[0] * o),
          (c = e[2 * d + 1] = S + it[1] * o),
          (h = d),
          d++;
    }
    return f;
  }
  function rt(t, e, i, n, r) {
    var o = null != n ? [] : new Float32Array(t.length);
    if ((nt(t, o, 0, e && e.length ? e[0] : t.length / 2, 0, i, n, r, !0), e))
      for (var a = 0; a < e.length; a++) {
        var s = e[a];
        nt(
          t,
          o,
          s,
          e[a + 1] || t.length / 2,
          null != n ? o.length / 2 : s,
          i,
          n,
          r,
          !1
        );
      }
    return o;
  }
  function ot(t, e, i, n) {
    for (var r = 0; r < Math.floor((n - i) / 2); r++)
      for (var o = 0; o < e; o++) {
        var a = (r + i) * e + o,
          s = (n - r - 1) * e + o,
          l = t[a];
        (t[a] = t[s]), (t[s] = l);
      }
    return t;
  }
  function at(t, e) {
    var i = t.length / 2,
      n = 0,
      r = e && e.length ? e[0] : i;
    J(t, n, r) > 0 && ot(t, 2, n, r);
    for (var o = 1; o < (e ? e.length : 0) + 1; o++)
      J(t, (n = e[o - 1]), (r = e[o] || i)) < 0 && ot(t, 2, n, r);
  }
  function st(t) {
    (t.depth = t.depth || 1),
      (t.bevelSize = t.bevelSize || 0),
      (t.bevelSegments = null == t.bevelSegments ? 2 : t.bevelSegments),
      (t.smoothBevel = t.smoothBevel || !1),
      (t.simplify = t.simplify || 0),
      null == t.smoothSide && (t.smoothSide = "auto"),
      null == t.smoothSideThreshold && (t.smoothSideThreshold = 0.9),
      "number" == typeof t.depth &&
        (t.bevelSize = Math.min(
          t.bevelSegments > 0 ? t.bevelSize : 0,
          t.depth / 2
        )),
      t.bevelSize > 0 || (t.bevelSegments = 0),
      (t.bevelSegments = Math.round(t.bevelSegments));
    var e = t.boundingRect;
    if (
      ((t.translate = t.translate || [0, 0]),
      (t.scale = t.scale || [1, 1]),
      t.fitRect)
    ) {
      var i = null == t.fitRect.x ? e.x || 0 : t.fitRect.x,
        n = null == t.fitRect.y ? e.y || 0 : t.fitRect.y,
        r = t.fitRect.width,
        o = t.fitRect.height;
      null == r
        ? null != o
          ? (r = (o / e.height) * e.width)
          : ((r = e.width), (o = e.height))
        : null == o && (o = (r / e.width) * e.height),
        (t.scale = [r / e.width, o / e.height]),
        (t.translate = [(i - e.x) * t.scale[0], (n - e.y) * t.scale[1]]);
    }
  }
  function lt(t, e) {
    function i(t, e, i, n) {
      (t[0] = e), (t[1] = i), (t[2] = n);
    }
    for (
      var n = [],
        r = [],
        o = [],
        a = [],
        s = [],
        l = [],
        u = t.length,
        c = new Float32Array(e.length),
        h = 0;
      h < u;

    ) {
      var p = 3 * t[h++],
        d = 3 * t[h++],
        f = 3 * t[h++];
      i(n, e[p], e[p + 1], e[p + 2]),
        i(r, e[d], e[d + 1], e[d + 2]),
        i(o, e[f], e[f + 1], e[f + 2]),
        W(a, n, r),
        W(s, r, o),
        Y(l, a, s);
      for (var g = 0; g < 3; g++)
        (c[p + g] = c[p + g] + l[g]),
          (c[d + g] = c[d + g] + l[g]),
          (c[f + g] = c[f + g] + l[g]);
    }
    for (var m = 0; m < c.length; )
      i(l, c[m], c[m + 1], c[m + 2]),
        q(l, l),
        (c[m++] = l[0]),
        (c[m++] = l[1]),
        (c[m++] = l[2]);
    return c;
  }
  var ut = [
    [0, 0],
    [1, 0],
    [1, 1],
    [0, 0],
    [1, 1],
    [0, 1],
  ];
  function ct(t, e, i, n, r, o) {
    var a = e.vertices,
      s = e.topVertices,
      l = e.splittedMap,
      u = e.depth,
      c = e.rect,
      h = n - i,
      p = o.smoothBevel ? 1 : 2,
      d = Math.min(u / 2, o.bevelSize),
      f = o.bevelSegments,
      g = r.vertex,
      m = Math.max(c.width, c.height, u);
    function y(t) {
      var e = (t + 1) % h,
        i = a[2 * t],
        n = a[2 * t + 1],
        r = a[2 * e],
        o = a[2 * e + 1];
      return i === r && n === o;
    }
    if (d > 0)
      for (
        var v = [0, 0, 1],
          b = [],
          x = [0, 0, -1],
          _ = [],
          S = 0,
          M = new Float32Array(h),
          C = 0;
        C < 2;
        C++
      )
        for (var w = 0 === C ? u - d : d, A = 0; A <= f * p; A++) {
          for (var E = 0, D = void 0, T = void 0, P = 0; P < h; P++) {
            var L = 2 * ((P % h) + i),
              I = l ? 2 * l[L / 2] : L;
            (b[0] = a[L] - s[I]), (b[1] = a[L + 1] - s[I + 1]), (b[2] = 0);
            var N = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
            (b[0] /= N), (b[1] /= N);
            var R = (Math.floor(A / p) + (A % p)) / f;
            0 === C ? Q(_, v, b, R) : Q(_, b, x, R);
            var O = 0 === C ? R : 1 - R,
              F = d * Math.sin((O * Math.PI) / 2),
              z = N * Math.cos((O * Math.PI) / 2),
              k = (d * N) / Math.sqrt(F * F + z * z),
              B = _[0] * k + s[I],
              G = _[1] * k + s[I + 1],
              U = _[2] * k + w;
            if (
              ((t.position[3 * r.vertex] = B),
              (t.position[3 * r.vertex + 1] = G),
              (t.position[3 * r.vertex + 2] = U),
              P > 0 && (E += Math.sqrt((D - B) * (D - B) + (T - G) * (T - G))),
              A > 0 || C > 0)
            ) {
              var j = 3 * (r.vertex - h),
                H = t.position[j],
                V = t.position[j + 1],
                W = t.position[j + 2];
              M[P] += Math.sqrt(
                (H - B) * (H - B) + (V - G) * (V - G) + (W - U) * (W - U)
              );
            }
            if (
              ((t.uv[2 * r.vertex] = E / m),
              (t.uv[2 * r.vertex + 1] = M[P] / m),
              (D = B),
              (T = G),
              r.vertex++,
              !y(P) && ((p > 1 && A % p) || (1 === p && A >= 1)))
            )
              for (var q = 0; q < 6; q++) {
                var Y = (ut[q][0] + P) % h,
                  X = ut[q][1] + S;
                t.indices[r.index++] = (X - 1) * h + Y + g;
              }
          }
          S++;
        }
    else
      for (var Z = 0; Z < 2; Z++)
        for (
          var J = 0 === Z ? u - d : d, K = 0, $ = void 0, tt = void 0, et = 0;
          et < h;
          et++
        ) {
          var it = 2 * ((et % h) + i),
            nt = a[it],
            rt = a[it + 1];
          (t.position[3 * r.vertex] = nt),
            (t.position[3 * r.vertex + 1] = rt),
            (t.position[3 * r.vertex + 2] = J),
            et > 0 &&
              (K += Math.sqrt(($ - nt) * ($ - nt) + (tt - rt) * (tt - rt))),
            (t.uv[2 * r.vertex] = K / m),
            (t.uv[2 * r.vertex + 1] = J / m),
            ($ = nt),
            (tt = rt),
            r.vertex++;
        }
    for (var ot = d > 0 ? f * p + 1 : 1, at = 0; at < h; at++)
      if (!y(at))
        for (var st = 0; st < 6; st++) {
          var lt = (ut[st][0] + at) % h,
            ct = ut[st][1] + ot;
          t.indices[r.index++] = (ct - 1) * h + lt + g;
        }
  }
  function ht(t, e, i, n) {
    var r = t.indices,
      o = t.topVertices,
      a = t.rect,
      s = t.depth;
    if (!(o.length <= 4)) {
      for (var l = i.vertex, u = r.length, c = 0; c < u; c++)
        e.indices[i.index++] = l + r[c];
      for (
        var h = Math.max(a.width, a.height), p = 0;
        p < (n.excludeBottom ? 1 : 2);
        p++
      )
        for (var d = 0; d < o.length; d += 2) {
          var f = o[d],
            g = o[d + 1];
          (e.position[3 * i.vertex] = f),
            (e.position[3 * i.vertex + 1] = g),
            (e.position[3 * i.vertex + 2] = (1 - p) * s),
            (e.uv[2 * i.vertex] = (f - a.x) / h),
            (e.uv[2 * i.vertex + 1] = (g - a.y) / h),
            i.vertex++;
        }
      if (!n.excludeBottom)
        for (var m = o.length / 2, y = 0; y < u; y += 3)
          for (var v = 0; v < 3; v++)
            e.indices[i.index++] = l + m + r[y + 2 - v];
    }
  }
  function pt(t, e, i, n) {
    var r = null == i || "auto" === i;
    if (!0 === i)
      return {
        vertices: t,
        holes: e,
      };
    for (
      var o = [],
        a = e && [],
        s = t.length / 2,
        l = [],
        u = [],
        c = [],
        h = 0,
        p = 0,
        d = (e ? e.length : 0) + 1,
        f = 0;
      f < d;
      f++
    ) {
      0 === f
        ? (p = e && e.length ? e[0] : s)
        : ((h = e[f - 1]), (p = e[f] || s));
      for (var g = h; g < p; g++) {
        var m = t[2 * g],
          y = t[2 * g + 1],
          v = g === p - 1 ? h : g + 1,
          b = t[2 * v],
          x = t[2 * v + 1];
        if (r) {
          var _ = g === h ? p - 1 : g - 1,
            S = t[2 * _],
            M = t[2 * _ + 1];
          (l[0] = S - m),
            (l[1] = M - y),
            (u[0] = b - m),
            (u[1] = x - y),
            U(l, l),
            U(u, u),
            1 - (0.5 * B(l, u) + 0.5) > n
              ? (o.push(m, y), c.push(g))
              : (o.push(m, y, m, y), c.push(g, g));
        } else o.push(m, y, m, y), c.push(g, g);
      }
      f < d - 1 && a && a.push(o.length / 2);
    }
    return {
      vertices: new Float32Array(o),
      splittedMap: c,
      holes: a,
    };
  }
  function dt(t, e) {
    for (var i = 0, n = 0, r = 0; r < t.length; r++) {
      var o = t[r],
        a = o.indices,
        s = o.vertices,
        l = o.splittedMap,
        u = o.topVertices,
        c = o.holes,
        h = o.depth,
        p = Math.min(h / 2, e.bevelSize) > 0 ? e.bevelSegments : 0;
      (c = c || []),
        (i += a.length * (e.excludeBottom ? 1 : 2)),
        (n += (u.length / 2) * (e.excludeBottom ? 1 : 2));
      for (var d = 2 + 2 * p, f = 0, g = 0, m = 0; m < c.length + 1; m++) {
        0 === m
          ? (g = c.length ? c[0] : s.length / 2)
          : ((f = c[m - 1]), (g = c[m] || s.length / 2)),
          (i += 6 * ((l ? l[g - 1] + 1 : g) - (l ? l[f] : f)) * (d - 1));
        var y = g - f;
        n += y * d + (e.smoothBevel ? 0 : p * y * 2);
      }
    }
    for (
      var v = {
          position: new Float32Array(3 * n),
          indices: new (n > 65535 ? Uint32Array : Uint16Array)(i),
          uv: new Float32Array(2 * n),
        },
        b = {
          vertex: 0,
          index: 0,
        },
        x = 0;
      x < t.length;
      x++
    )
      ht(t[x], v, b, e);
    for (var _ = 0; _ < t.length; _++) {
      var S = t[_],
        M = S.holes,
        C = S.vertices.length / 2,
        w = 0,
        A = M && M.length ? M[0] : C;
      if ((ct(v, t[_], w, A, b, e), M))
        for (var E = 0; E < M.length; E++)
          (w = M[E]), (A = M[E + 1] || C), ct(v, t[_], w, A, b, e);
    }
    for (var D = 0; D < v.uv.length; D++) {
      var T = v.uv[D];
      T > 0 && Math.round(T) === T ? (v.uv[D] = 1) : (v.uv[D] = T % 1);
    }
    return (
      (v.normal = lt(v.indices, v.position)),
      (v.boundingRect = t[0] && t[0].rect),
      v
    );
  }
  function ft(t, e, i) {
    for (
      var n = i.lineWidth,
        r = t.length,
        o = new Float32Array(2 * r),
        a = i.translate || [0, 0],
        s = i.scale || [1, 1],
        l = 0,
        u = 0;
      l < r;
      l++
    )
      (o[u++] = t[l][0] * s[0] + a[0]), (o[u++] = t[l][1] * s[1] + a[1]);
    J(o, 0, r) < 0 && ot(o, 2, 0, r);
    var c = [],
      h = [],
      p = i.miterLimit,
      d = nt(o, h, 0, r, 0, -n / 2, p, !1, !0);
    ot(o, 2, 0, r);
    for (
      var f = nt(o, c, 0, r, 0, -n / 2, p, !1, !0),
        g = (c.length + h.length) / 2,
        m = new Float32Array(2 * g),
        y = 0,
        v = h.length / 2,
        b = 0;
      b < h.length;
      b++
    )
      m[y++] = h[b];
    for (var x = 0; x < c.length; x++) m[y++] = c[x];
    for (
      var _ = new (g > 65535 ? Uint32Array : Uint16Array)(
          3 * (2 * (r - 1) + (g - 2 * r))
        ),
        S = 0,
        M = 0;
      M < r - 1;
      M++
    ) {
      var C = M + 1;
      (_[S++] = v - 1 - d[M]),
        (_[S++] = v - 1 - d[M] - 1),
        (_[S++] = f[M] + 1 + v),
        (_[S++] = v - 1 - d[M]),
        (_[S++] = f[M] + 1 + v),
        (_[S++] = f[M] + v),
        f[C] - f[M] == 2
          ? ((_[S++] = f[M] + 2 + v),
            (_[S++] = f[M] + 1 + v),
            (_[S++] = v - d[C] - 1))
          : d[C] - d[M] == 2 &&
            ((_[S++] = f[C] + v),
            (_[S++] = v - 1 - (d[M] + 1)),
            (_[S++] = v - 1 - (d[M] + 2)));
    }
    var w = i.bevelSize > 0 ? rt(m, [], i.bevelSize, null, !0) : m,
      A = i.boundingRect,
      E = pt(m, null, i.smoothSide, i.smoothSideThreshold);
    return {
      vertices: E.vertices,
      rawVertices: vertices,
      splittedMap: E.splittedMap,
      indices: _,
      topVertices: w,
      rect: {
        x: A.x * s[0] + a[0],
        y: A.y * s[1] + a[1],
        width: A.width * s[0],
        height: A.height * s[1],
      },
      depth: "function" == typeof i.depth ? i.depth(e) : i.depth,
      holes: [],
    };
  }
  function gt(t, e) {
    for (var i = [], n = 0; n < t.length; n++) {
      for (
        var r = t[n],
          o = [],
          a = r.length,
          s = r[a - 1][0],
          l = r[a - 1][1],
          u = 0,
          c = 0;
        c < a;
        c++
      ) {
        var h = r[c][0],
          p = r[c][1],
          d = h - s,
          f = p - l;
        (u += Math.sqrt(d * d + f * f)) > e && (o.push(r[c]), (u = 0)),
          (s = h),
          (l = p);
      }
      o.length >= 3 && i.push(o);
    }
    return i.length > 0 ? i : null;
  }
  function mt(t, e) {
    for (var i = [], n = 0; n < t.length; n++) {
      var r = t[n];
      (r = z(r, e, !0)).length >= 3 && i.push(r);
    }
    return i.length > 0 ? i : null;
  }
  function yt(t, e) {
    e = Object.assign({}, e);
    for (var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0], r = 0; r < t.length; r++)
      bt(t[r][0], i, n);
    (e.boundingRect = e.boundingRect || {
      x: i[0],
      y: i[1],
      width: n[0] - i[0],
      height: n[1] - i[1],
    }),
      st(e);
    for (
      var o = [],
        a = e.translate || [0, 0],
        s = e.scale || [1, 1],
        l = e.boundingRect,
        u = {
          x: l.x * s[0] + a[0],
          y: l.y * s[1] + a[1],
          width: l.width * s[0],
          height: l.height * s[1],
        },
        c = Math.min(l.width, l.height) / 1e5,
        h = 0;
      h < t.length;
      h++
    ) {
      var p = gt(t[h], c);
      if (p) {
        var d = e.simplify / Math.max(s[0], s[1]);
        if ((d > 0 && (p = mt(p, d)), p)) {
          for (
            var f = L.flatten(p),
              g = f.vertices,
              m = f.holes,
              y = f.dimensions,
              v = 0;
            v < g.length;

          )
            (g[v] = g[v++] * s[0] + a[0]), (g[v] = g[v++] * s[1] + a[1]);
          if ((at(g, m), 2 !== y))
            throw new Error("Only 2D polygon points are supported");
          var b = e.bevelSize > 0 ? rt(g, m, e.bevelSize, null, !0) : g,
            x = K(b, m, y),
            _ = pt(g, m, e.smoothSide, e.smoothSideThreshold);
          o.push({
            indices: x,
            vertices: _.vertices,
            rawVertices: g,
            topVertices: b,
            holes: _.holes,
            splittedMap: _.splittedMap,
            rect: u,
            depth: "function" == typeof e.depth ? e.depth(h) : e.depth,
          });
        }
      }
    }
    return dt(o, e);
  }
  function vt(t, e) {
    e = Object.assign({}, e);
    for (var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0], r = 0; r < t.length; r++)
      bt(t[r], i, n);
    (e.boundingRect = e.boundingRect || {
      x: i[0],
      y: i[1],
      width: n[0] - i[0],
      height: n[1] - i[1],
    }),
      st(e);
    var o = e.scale || [1, 1];
    null == e.lineWidth && (e.lineWidth = 1),
      null == e.miterLimit && (e.miterLimit = 2);
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s],
        u = e.simplify / Math.max(o[0], o[1]);
      u > 0 && (l = z(l, u, !0)), a.push(ft(l, s, e));
    }
    return dt(a, e);
  }
  function bt(t, e, i) {
    for (var n = 0; n < t.length; n++)
      (e[0] = Math.min(t[n][0], e[0])),
        (e[1] = Math.min(t[n][1], e[1])),
        (i[0] = Math.max(t[n][0], i[0])),
        (i[1] = Math.max(t[n][1], i[1]));
  }
  function xt(t, e) {
    e = Object.assign({}, e);
    for (
      var i = [],
        n = [],
        r = [],
        o = [],
        a = [1 / 0, 1 / 0],
        s = [-1 / 0, -1 / 0],
        l = 0;
      l < t.features.length;
      l++
    ) {
      var u = t.features[l].geometry;
      if (u && u.coordinates)
        switch (u.type) {
          case "LineString":
            i.push(u.coordinates), r.push(l), bt(u.coordinates, a, s);
            break;
          case "MultiLineString":
            for (var c = 0; c < u.coordinates.length; c++)
              i.push(u.coordinates[c]), r.push(l), bt(u.coordinates[c], a, s);
            break;
          case "Polygon":
            n.push(u.coordinates), o.push(l), bt(u.coordinates[0], a, s);
            break;
          case "MultiPolygon":
            for (var h = 0; h < u.coordinates.length; h++)
              n.push(u.coordinates[h]),
                o.push(l),
                bt(u.coordinates[h][0], a, s);
        }
    }
    e.boundingRect = e.boundingRect || {
      x: a[0],
      y: a[1],
      width: s[0] - a[0],
      height: s[1] - a[1],
    };
    var p = e.depth;
    return {
      polyline: vt(
        i,
        Object.assign(e, {
          depth: function (e) {
            return "function" == typeof p ? p(t.features[r[e]]) : p;
          },
        })
      ),
      polygon: yt(
        n,
        Object.assign(e, {
          depth: function (e) {
            return "function" == typeof p ? p(t.features[o[e]]) : p;
          },
        })
      ),
    };
  }
  (t.extrudeGeoJSON = xt),
    (t.extrudePolygon = yt),
    (t.extrudePolyline = vt),
    (t.flatten = $),
    (t.offsetPolygon = rt),
    (t.triangulate = K),
    Object.defineProperty(t, "__esModule", {
      value: !0,
    });
})(SW.exports);
const MW = (t) => {
    const e = 1 / Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z);
    (t.x *= e), (t.y *= e), (t.z *= e);
  },
  CW = (t) => {
    const {
        segments: e = 3,
        radiusTop: i,
        shape: n,
        angle: r = 0,
        unExclude: o,
      } = t,
      a = [],
      s = new qs(),
      l = (2 * Math.PI) / e;
    for (let c = 0; c < e; c++) {
      const t = l * c + Math.PI / 12 + r,
        e = i * Math.sin(t + Math.PI / 4),
        n = i * Math.cos(t + Math.PI / 4);
      o ? (0 === c && s.moveTo(e, n), s.lineTo(e, n)) : a.push([e, n]);
    }
    let u;
    if (o) {
      const t = new NA(s);
      !(function (t) {
        var e, i;
        t.computeBoundingBox();
        const n = null == (e = t.boundingBox) ? void 0 : e.max,
          r = null == (i = t.boundingBox) ? void 0 : i.min,
          o = new Le(0 - r.x, 0 - r.y),
          a = new Le(n.x - r.x, n.y - r.y),
          s = t.getAttribute("uv"),
          l = t.getAttribute("position"),
          u = new Ye();
        for (let c = 0; c < l.count; c++)
          u.fromBufferAttribute(l, c),
            s.setXY(c, (u.x + o.x) / a.x, (u.y + o.y) / a.y);
      })(t),
        (u = {
          indices: t.index,
          position: t.getAttribute("position"),
          uv: t.getAttribute("uv"),
          normal: t.getAttribute("normal"),
        });
    } else
      u = SW.exports.extrudePolygon([[a]], {
        depth: Number(-1 !== n.indexOf("Column")),
      });
    return u;
  },
  wW = {
    cylinder: (t) => {
      const { radiusTop: e, radiusBottom: i, segments: n, texture: r = {} } = t,
        { top: o, side: a } = r,
        s = Number(!!o),
        l = Number(!!a),
        u = [];
      (u[0] = {
        x: 0,
        y: 0,
        z: 0,
        w: 0,
      }),
        (u[1] = {
          x: 0,
          y: 0,
          z: l,
          w: l,
        }),
        (u[2] = {
          x: 0,
          y: 0,
          z: s,
          w: s,
        });
      const c = ((t) => {
          const {
              height: e = 1,
              segments: i = 24,
              subdivisions: n = 1,
              faceUV: r = [],
            } = t,
            o = t.radiusTop || 1e-5,
            a = t.radiusBottom || 1e-5,
            s = [],
            l = [],
            u = [],
            c = [];
          for (let m = 0; m < 3; m++)
            r &&
              !r[m] &&
              (r[m] = {
                x: 0,
                y: 0,
                z: 1,
                w: 1,
              });
          const h = (2 * Math.PI) / i,
            p = (a - o) / e,
            d = {
              x: 0,
              y: 0,
              z: 0,
            },
            f = {
              x: 0,
              y: 0,
              z: 0,
            };
          for (let m = 0; m <= n; m++) {
            const t = m / n,
              s = t * (o - a) + a;
            for (let a = 0; a <= i; a++) {
              const g = a * h;
              (d.x = s * Math.cos(-g)),
                (d.y = t * e - e / 2),
                (d.z = s * Math.sin(-g)),
                0 === o && m === n
                  ? ((f.x = u[u.length - 3 * (i + 1)]),
                    (f.y = u[u.length - 3 * (i + 1) + 1]),
                    (f.z = u[u.length - 3 * (i + 1) + 2]))
                  : ((f.x = d.x),
                    (f.z = d.z),
                    (f.y = Math.sqrt(f.x * f.x + f.z * f.z) * p),
                    MW(f)),
                l.push(d.x, d.y, d.z),
                u.push(f.x, f.y, f.z);
              const y = r[1].y + (r[1].w - r[1].y) * t;
              c.push(r[1].x + ((r[1].z - r[1].x) * a) / i, y);
            }
          }
          for (let m = 0; m < n; m++)
            for (let t = 0; t < i; t++) {
              const e = m * (i + 1) + t,
                n = (m + 1) * (i + 1) + t,
                r = m * (i + 1) + (t + 1),
                o = (m + 1) * (i + 1) + (t + 1);
              s.push(e, n, r), s.push(o, r, n);
            }
          const g = (t) => {
            const n = t ? o : a;
            if (0 === n) return;
            let h;
            const p = t ? r[2] : r[0],
              d = l.length / 3,
              f = t ? e / 2 : -e / 2;
            l.push(0, f, 0), u.push(0, t ? 1 : -1, 0);
            const g = p.y + 0.5 * (p.w - p.y);
            c.push(p.x + 0.5 * (p.z - p.x), g);
            const m = [0.5, 0.5];
            for (h = 0; h <= i; h++) {
              const e = (2 * Math.PI * h) / i,
                r = Math.sin(-e),
                o = Math.cos(-e),
                a = [o * m[0] + 0.5, r * m[1] + 0.5];
              l.push(n * o, f, n * r), u.push(0, t ? 1 : -1, 0);
              const s = p.y + (p.w - p.y) * a[1];
              c.push(p.x + (p.z - p.x) * a[0], s);
            }
            for (h = 0; h < i; h++)
              t
                ? (s.push(d), s.push(d + (h + 2)), s.push(d + (h + 1)))
                : (s.push(d), s.push(d + (h + 1)), s.push(d + (h + 2)));
          };
          return (
            g(!0),
            g(!1),
            {
              indices: s,
              position: l,
              normal: u,
              uv: c,
            }
          );
        })({
          radiusTop: e,
          radiusBottom: i,
          faceUV: u,
          segments: n,
        }),
        { position: h } = c,
        p = [];
      for (let d = 0; d < h.length; d += 3) p.push(h[d], h[d + 2], h[d + 1]);
      return ot(rt({}, c), {
        position: p,
      });
    },
  },
  AW = (t, e) => {
    if (0 === t.length) return t;
    const { shape: i } = e,
      { indices: n, position: r, uv: o, normal: a } = (wW[i] || CW)(e, e),
      { colors: s, height: l } = ((t, e) => {
        const { unExclude: i } = e,
          n = [],
          r = [];
        for (let o = 0; o < t.length; o++) {
          const { color: e, opacity: a } = EA(t[o]._color_),
            s = [e.r, e.g, e.b, a];
          if ((r.push(...s), !i)) {
            const e = t[o]._height_ || 1e-5;
            n.push(e);
          }
        }
        return {
          colors: r,
          height: n,
        };
      })(t, e);
    return {
      indices: n,
      position: r,
      uv: o,
      normal: a,
      colors: s,
      height: l,
      dataArray: t,
    };
  };
var EW,
  DW,
  TW = Object.defineProperty,
  PW = Object.getOwnPropertyDescriptor,
  LW = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? PW(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && TW(e, i, o), o;
  };
class IW {
  constructor(t) {
    (this.props = t),
      (this.id = we()),
      (this.__cb = []),
      (this.__errorCb = []),
      (this.__isReady = !1),
      (this.__destroyed = !1),
      (this.version = ut),
      (this.__maps = []),
      (this.eventManager = new CG()),
      (this.layerManager = new OU()),
      (this.__initCameraSystem = () => {
        const { viewportConfig: t, width: e, height: i } = this.state;
        this.cameraSystem = new wG({
          config: t,
          width: e,
          height: i,
        });
      }),
      (this.__initSceneSystem = () => {
        const {
          sceneConfig: t,
          viewportConfig: e,
          containerDom: i,
        } = this.state;
        (this.sceneSystem = new IU({
          containerDom: i,
          config: t,
          viewportConfig: e,
          cameraSystem: this.cameraSystem,
          layerManager: this.layerManager,
        })),
          this.ee.on("viewportChange", (t) => {
            (this.sceneSystem.coreScene.ext.zoom = t.zoom),
              (this.sceneSystem.hudScene.ext.zoom = t.zoom);
          });
      }),
      (this.__initRenderSystem = () => {
        const { width: t, height: e, containerDom: i } = this.state;
        (this.renderSystem = new MU({
          containerDom: i,
          width: t,
          height: e,
          cameraSystem: this.cameraSystem,
          sceneSystem: this.sceneSystem,
        })),
          this.shaderService.registerBasicModule(),
          this.eventManager.ee.on("markerEnabled", ({ markerType: t }) => {
            const { width: e, height: i, containerDom: n } = this.props;
            this.renderSystem.markerRenderer ||
              (this.renderSystem.markerRenderer = new rW({
                sceneSystem: this.sceneSystem,
                cameraSystem: this.cameraSystem,
                controlsSystem: this.controlsSystem,
                containerDom: n,
                markerType: t,
                width: e,
                height: i,
              }));
          });
      }),
      (this.__initEventSystem = () => {
        const { containerDom: t, autoSize: e } = this.state;
        this.eventSystem = new gU({
          engine: sW,
          viewportSystem: this.viewportSystem,
          cameraSystem: this.cameraSystem,
          renderSystem: this.renderSystem,
          sceneSystem: this.sceneSystem,
          containerDom: t,
          autoSize: e,
          ee: this.ee,
          layerManager: this.layerManager,
          eventManager: this.eventManager,
        });
      }),
      (this.__initLightSystem = () => {
        const { lightConfig: t } = this.state;
        this.lightSystem = new xU({
          sceneSystem: this.sceneSystem,
          gis: this,
          config: t,
        });
      }),
      (this.__initHelperSystem = () => {
        const { dev: t } = this.state;
        if (t) {
          (this.renderSystem.coreRenderer.debug.checkShaderErrors = !1),
            new KU({
              length: 2e4,
              sceneSystem: this.sceneSystem,
            }),
            new nj({
              type: "cartesian",
              sceneSystem: this.sceneSystem,
              config: {
                size: 100,
                divisions: 10,
              },
            });
          const t = new QE(this.cameraSystem.coreCamera);
          this.sceneSystem.coreScene.add(t),
            this.lightSystem.lights.forEach((t) => {
              switch (t.type) {
                case "directional": {
                  const e = 5,
                    i = new qE(t.light, e);
                  return void this.sceneSystem.coreScene.add(i);
                }
                case "spot": {
                  const e = new GE(t.light);
                  return void this.sceneSystem.coreScene.add(e);
                }
              }
            });
        }
      }),
      (this.__syncMap = (t) => {
        this.__maps.forEach((e) => {
          e.setCenter(t.center, !0),
            e.setZoom(t.zoom, !0),
            e.setPitch(t.pitch, !0),
            e.setRotation(t.rotation, !0);
        });
      }),
      this.__init();
  }
  __init() {
    if (!this.__checkEnv()) return;
    this.__injectToGlobal(),
      (this.ee = new dt()),
      this.__initDataSet(),
      this.__mergeDefaultConfig(),
      this.__initCameraSystem(),
      this.__initSceneSystem(),
      this.__initRenderSystem(),
      this.__initLightSystem(),
      this.__initControlsSystem(),
      this.__initViewportSystem(),
      this.__initEventSystem();
    new Promise((t, e) => {
      this.__initBaseMapLayer(t, e);
    })
      .then(() => {
        this.__iniTickSystem(),
          this.tickSystem.start(),
          this.__initHelperSystem(),
          (this.__isReady = !0),
          setTimeout(() => {
            if (!this.__destroyed) {
              for (let t = 0; t < this.__cb.length; t++) this.__cb[t](this);
              (this.__cb = []), this.ee.emit("loaded", "");
            }
          }, 0);
      })
      .catch((t) => {
        for (let e = 0; e < this.__errorCb.length; e++) this.__errorCb[e](t);
        (this.__errorCb = []), this.ee.emit("loaded", "");
      });
  }
  __checkEnv() {
    return this.props.containerDom && this.props.containerDom.isConnected
      ? QD.isWebGL2Available()
        ? (QD.isGPUAcceleratorEnabled() ||
            this.logService.error(
              "检测到您已关闭浏览器硬件加速模式，请开启以获得更好的体验"
            ),
          !0)
        : (this.logService.error(
            "当前环境不支持 webgl2，请更新浏览器或显卡配置以获得更好的体验"
          ),
          !1)
      : (this.logService.error("Plane3D containerDom is required"), !1);
  }
  __injectToGlobal() {
    const { globalVariable: t = sk } = this.props;
    t &&
      ((window.__gis__ = this),
      Array.isArray(window.__gises__)
        ? window.__gises__.push(this)
        : (window.__gises__ = [this]));
  }
  __initDataSet() {
    const t = new ok();
    t.registerParser("geojson", Kz),
      t.registerParser("bytejson", Xw),
      t.registerTransform("projection", ML),
      t.registerTransform("hexagon", bW),
      t.registerTransform("grid", _W),
      t.registerTransform("filter", aT),
      t.registerTransform("map", mF),
      t.registerTransform("dissolve", gI),
      t.registerTransform("webgis", lW),
      (this.dataSet = t);
  }
  __mergeDefaultConfig() {
    const {
        autoSize: t,
        containerDom: e,
        baseMapLayer: i,
        width: n,
        height: r,
      } = this.props,
      o = null != t ? t : lk,
      a = null != n ? n : 1920,
      s = null != r ? r : 1080,
      l = null == i ? void 0 : i.baseZoom;
    this.state = af(
      {
        dev: false,
        globalVariable: sk,
        autoSize: lk,
        sceneConfig: hk,
        viewportConfig: af(uk, {
          mode: fW(this.props.viewportConfig),
        }),
        baseMapLayer: af(Rk, {
          baseZoom: l || -1,
        }),
        lightConfig: ck,
        controlType: "orbit",
      },
      ot(rt({}, this.props), {
        width: o ? e.clientWidth : a,
        height: o ? e.clientHeight : s,
      })
    );
  }
  __initControlsSystem() {
    const { viewportConfig: t } = this.state;
    (this.controlsSystem = new DG({
      sceneSystem: this.sceneSystem,
      renderSystem: this.renderSystem,
      cameraSystem: this.cameraSystem,
      config: t,
      layerManager: this.layerManager,
      gis: this,
    })),
      this.controlsSystem.gisStateApi.subscribe(AG.WebGis, this.__syncMap);
  }
  __initViewportSystem() {
    const { viewportConfig: t } = this.state;
    this.viewportSystem = new dW({
      sceneSystem: this.sceneSystem,
      renderSystem: this.renderSystem,
      cameraSystem: this.cameraSystem,
      controlsSystem: this.controlsSystem,
      config: t,
      layerManager: this.layerManager,
      gis: this,
    });
  }
  __iniTickSystem() {
    this.tickSystem = new JU({
      sceneSystem: this.sceneSystem,
      renderSystem: this.renderSystem,
      cameraSystem: this.cameraSystem,
      controlsSystem: this.controlsSystem,
      layerManager: this.layerManager,
    });
  }
  async __initBaseMapLayer(t, e) {
    const { baseMapLayer: i } = this.state;
    if (i.enabled)
      try {
        const e = new eW(this, i, t);
        await e.init();
      } catch (n) {
        e(n);
      }
    else t();
  }
  then(t) {
    return (
      this.__isReady
        ? setTimeout(() => {
            t(this);
          }, 0)
        : this.__cb.push(t),
      this
    );
  }
  catch(t) {
    return this.__errorCb.push(t), this;
  }
  on(t, e, i) {
    Fk(t) || this.eventSystem.mapContainerEvent.bindEventListeners(t),
      this.ee.on(t, e, i);
  }
  off(t, e) {
    Fk(t) || this.eventManager.removeMapEvent(this.id, t),
      this.ee.removeListener(t),
      e && e();
  }
  get performance() {
    return this.renderSystem.coreRenderer.info;
  }
  registerMap(t) {
    if (!t.__destroyed)
      if (this.__maps.find((e) => e.id === t.id))
        this.logService.warn("请不要重复绑定第三方地图");
      else {
        this.__maps.push(t);
        const e = this.controlsSystem.gisStateApi.getSourceState(),
          i = t.getMaxPitch(),
          n = t.getZooms();
        this.viewportSystem.set({
          maxPitch: Math.min(e.maxPitch, i),
          minZoom: n[0],
          maxZoom: n[1],
        }),
          this.__syncMap(this.controlsSystem.gisStateApi.get(AG.WebGis));
      }
  }
  unregisterMap(t) {
    this.__maps.splice(this.__maps.indexOf(t), 1);
  }
  destroy() {
    var t, e, i, n, r, o, a, s, l, u, c, h, p, d;
    if (this.__destroyed)
      return void this.logService.warn("请勿重复调用 destroy");
    (this.__destroyed = !0),
      this.ee.emit("destroy", ""),
      null == (t = this.eventSystem) || t.destroy(),
      null == (e = this.controlsSystem) || e.destroy(),
      null == (i = this.tickSystem) || i.destroy(),
      null == (n = this.layerManager) || n.destroy(),
      null == (r = this.lightSystem) || r.destroy(),
      null == (o = this.sceneSystem) || o.destroy(),
      null == (a = this.renderSystem) || a.destroy(),
      null == (s = this.dataSet) || s.destroy(),
      null == (l = this.controlsSystem) ||
        l.gisStateApi.unsubscribe(AG.WebGis, this.__syncMap),
      null == (u = this.viewportSystem) || u.destroy(),
      null == (c = this.__maps) || c.forEach((t) => t.destroy()),
      (null == (h = this.state) ? void 0 : h.containerDom) &&
        (this.state.containerDom.innerHTML = ""),
      (null == (p = window.__gis__) ? void 0 : p.id) === this.id &&
        (window.__gis__ = null);
    const f =
      null == (d = window.__gises__)
        ? void 0
        : d.findIndex((t) => t.id === this.id);
    f > -1 && window.__gises__.splice(f, 1);
  }
}
LW([_G(KB.IShaderService)], IW.prototype, "shaderService", 2),
  LW([_G(KB.ILogService)], IW.prototype, "logService", 2),
  ff("images", "waternormals.jpg"),
  ((DW = EW || (EW = {})).MIDDLE = "middle"),
  (DW.LEFT = "left"),
  (DW.RIGHT = "right"),
  (DW.TOP = "top"),
  (DW.BOTTOM = "bottom");
class NW extends oV {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e);
  }
  async _addPoiMesh(t) {
    var e;
    if (!(null == (e = this.state.poi) ? void 0 : e.enabled)) return;
    const i = this.state.poi,
      {
        orient: n,
        background: r,
        major: o,
        minor: a,
        alignment: s,
        offsetX: l,
        offsetY: u,
      } = i,
      { pointPosition: c, majorContent: h, minorContent: p, ext: d } = t,
      f = o.enabled && cf(h),
      g = a.enabled && cf(p);
    (f || g) &&
      (await this.poiGroup.addText(
        c,
        n,
        s,
        r,
        f
          ? {
              content: h,
              props: o,
            }
          : null,
        g
          ? {
              content: p,
              props: a,
            }
          : null,
        l,
        u,
        ot(rt({}, d), {
          position: [c.x, c.y, c.z],
          offsetX: l,
          offsetY: u,
        })
      ));
  }
  async initPOI() {
    var t;
    let e = this.dataView.latestData;
    if (!(null == (t = this.state.poi) ? void 0 : t.enabled) || !e)
      return void this.clearPoiGroup();
    e instanceof Array || (e = [e]), this.clearPoiGroup();
    const {
      poi: { major: i, minor: n },
      fields: r,
    } = this.state;
    for (let o = 0; o < e.length; o++) {
      const t = e[o],
        { layerManager: a } = this.gis,
        { lng: s, lat: l } = t,
        [u, c] = a.geo.project([s, l]),
        h = {
          x: u,
          y: c,
          z: this.coreGroup.position.z,
        };
      await this._addPoiMesh({
        pointPosition: h,
        majorContent: i.format
          ? i.format(t[r.majorPOIField])
          : t[r.majorPOIField],
        minorContent: n.format
          ? n.format(t[r.minorPOIField])
          : t[r.minorPOIField],
        ext: {
          relatedInstanceId: o,
        },
      });
    }
    this._updatePOI(!0);
  }
}
class RW extends NW {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e);
  }
  async initPOI() {
    const { poi: t, renderData: e } = this.state,
      { major: i, minor: n, anchor: r, enabled: o } = t;
    if (!o) return void this.clearPoiGroup();
    this.clearPoiGroup();
    const { height: a, dataArray: s } = e,
      l = s.length;
    let u = 0;
    for (let c = 0; c < l; c++) {
      const t = s[c],
        e = t.coordinates[0],
        o = t.coordinates[1],
        l = this._mapSize(a[c], "z");
      switch (((u = l), r)) {
        case EW.BOTTOM:
          u = 0;
          break;
        case EW.MIDDLE:
          u = l / 2;
        case EW.TOP:
      }
      await this._addPoiMesh({
        pointPosition: {
          x: e,
          y: o,
          z: u + this.coreGroup.position.z,
        },
        majorContent: i.format ? i.format(s[c]._majorPOI_) : s[c]._majorPOI_,
        minorContent: n.format ? n.format(s[c]._minorPOI_) : s[c]._minorPOI_,
        ext: {
          relatedInstanceId: c,
        },
      });
    }
    this._updatePOI(!0);
  }
}
const OW = {
    sizeField: "value",
    widthField: "value",
    heightField: "value",
    colorWeightField: "value",
    heightWeightField: "value",
    blurField: "value",
    colorField: "value",
    fromColorField: "value",
    toColorField: "value",
    mapField: "map",
    lngField: "lng",
    latField: "lat",
    coordinatesField: "coordinates",
    fromField: "from",
    toField: "to",
    adcodeField: "adcode",
    majorPOIField: "name",
    minorPOIField: "value",
  },
  FW = {
    light: {
      red: [
        "#FFECE8",
        "#FDCDC5",
        "#FBACA3",
        "#F98981",
        "#F76560",
        "#F53F3F",
        "#CB272D",
        "#A1151E",
        "#770813",
        "#4D000A",
      ],
      orangered: [
        "#FFF3E8",
        "#FDDDC3",
        "#FCC59F",
        "#FAAC7B",
        "#F99057",
        "#F77234",
        "#CC5120",
        "#A23511",
        "#771F06",
        "#4D0E00",
      ],
      orange: [
        "#FFF7E8",
        "#FFE4BA",
        "#FFCF8B",
        "#FFB65D",
        "#FF9A2E",
        "#FF7D00",
        "#D25F00",
        "#A64500",
        "#792E00",
        "#4D1B00",
      ],
      gold: [
        "#FFFCE8",
        "#FDF4BF",
        "#FCE996",
        "#FADC6D",
        "#F9CC45",
        "#F7BA1E",
        "#CC9213",
        "#A26D0A",
        "#774B04",
        "#4D2D00",
      ],
      yellow: [
        "#FEFFE8",
        "#FEFEBE",
        "#FDFA94",
        "#FCF26B",
        "#FBE842",
        "#FADC19",
        "#CFAF0F",
        "#A38408",
        "#785D03",
        "#4D3800",
      ],
      lime: [
        "#FCFFE8",
        "#EDF8BB",
        "#DCF190",
        "#C9E968",
        "#B5E241",
        "#9FDB1D",
        "#7EB712",
        "#5F940A",
        "#437004",
        "#2A4D00",
      ],
      green: [
        "#E8FFEA",
        "#AFF0B5",
        "#7BE188",
        "#4CD263",
        "#23C343",
        "#00B42A",
        "#009A29",
        "#008026",
        "#006622",
        "#004D1C",
      ],
      cyan: [
        "#E8FFFB",
        "#B7F4EC",
        "#89E9E0",
        "#5EDFD6",
        "#37D4CF",
        "#14C9C9",
        "#0DA5AA",
        "#07828B",
        "#03616C",
        "#00424D",
      ],
      blue: [
        "#E8F7FF",
        "#C3E7FE",
        "#9FD4FD",
        "#7BC0FC",
        "#57A9FB",
        "#3491FA",
        "#206CCF",
        "#114BA3",
        "#063078",
        "#001A4D",
      ],
      arcoblue: [
        "#E8F3FF",
        "#BEDAFF",
        "#94BFFF",
        "#6AA1FF",
        "#4080FF",
        "#165DFF",
        "#0E42D2",
        "#072CA6",
        "#031A79",
        "#000D4D",
      ],
      purple: [
        "#F5E8FF",
        "#DDBEF6",
        "#C396ED",
        "#A871E3",
        "#8D4EDA",
        "#722ED1",
        "#551DB0",
        "#3C108F",
        "#27066E",
        "#16004D",
      ],
      pinkpurple: [
        "#FFE8FB",
        "#F7BAEF",
        "#F08EE6",
        "#E865DF",
        "#E13EDB",
        "#D91AD9",
        "#B010B6",
        "#8A0993",
        "#650370",
        "#42004D",
      ],
      magenta: [
        "#FFE8F1",
        "#FDC2DB",
        "#FB9DC7",
        "#F979B7",
        "#F754A8",
        "#F5319D",
        "#CB1E83",
        "#A11069",
        "#77064F",
        "#4D0034",
      ],
      gray: [
        "#f7f8fa",
        "#f2f3f5",
        "#e5e6eb",
        "#c9cdd4",
        "#a9aeb8",
        "#86909c",
        "#6b7785",
        "#4e5969",
        "#272e3b",
        "#1d2129",
      ],
    },
    dark: {
      red: [
        "#4D000A",
        "#770611",
        "#A1161F",
        "#CB2E34",
        "#F54E4E",
        "#F76965",
        "#F98D86",
        "#FBB0A7",
        "#FDD1CA",
        "#FFF0EC",
      ],
      orangered: [
        "#4D0E00",
        "#771E05",
        "#A23714",
        "#CC5729",
        "#F77E45",
        "#F9925A",
        "#FAAD7D",
        "#FCC6A1",
        "#FDDEC5",
        "#FFF4EB",
      ],
      orange: [
        "#4D1B00",
        "#793004",
        "#A64B0A",
        "#D26913",
        "#FF8D1F",
        "#FF9626",
        "#FFB357",
        "#FFCD87",
        "#FFE3B8",
        "#FFF7E8",
      ],
      gold: [
        "#4D2D00",
        "#774B04",
        "#A26F0F",
        "#CC961F",
        "#F7C034",
        "#F9CC44",
        "#FADC6C",
        "#FCE995",
        "#FDF4BE",
        "#FFFCE8",
      ],
      yellow: [
        "#4D3800",
        "#785E07",
        "#A38614",
        "#CFB325",
        "#FAE13C",
        "#FBE94B",
        "#FCF374",
        "#FDFA9D",
        "#FEFEC6",
        "#FEFFF0",
      ],
      lime: [
        "#2A4D00",
        "#447006",
        "#629412",
        "#84B723",
        "#A8DB39",
        "#B8E24B",
        "#CBE970",
        "#DEF198",
        "#EEF8C2",
        "#FDFFEE",
      ],
      green: [
        "#004D1C",
        "#046625",
        "#0A802D",
        "#129A37",
        "#1DB440",
        "#27C346",
        "#50D266",
        "#7EE18B",
        "#B2F0B7",
        "#EBFFEC",
      ],
      cyan: [
        "#00424D",
        "#06616C",
        "#11838B",
        "#1FA6AA",
        "#30C9C9",
        "#3FD4CF",
        "#66DFD7",
        "#90E9E1",
        "#BEF4ED",
        "#F0FFFC",
      ],
      blue: [
        "#001A4D",
        "#052F78",
        "#134CA3",
        "#2971CF",
        "#469AFA",
        "#5AAAFB",
        "#7DC1FC",
        "#A1D5FD",
        "#C6E8FE",
        "#EAF8FF",
      ],
      arcoblue: [
        "#000D4D",
        "#041B79",
        "#0E32A6",
        "#1D4DD2",
        "#306FFF",
        "#3C7EFF",
        "#689FFF",
        "#93BEFF",
        "#BEDAFF",
        "#EAF4FF",
      ],
      purple: [
        "#16004D",
        "#27066E",
        "#3E138F",
        "#5A25B0",
        "#7B3DD1",
        "#8E51DA",
        "#A974E3",
        "#C59AED",
        "#DFC2F6",
        "#F7EDFF",
      ],
      pinkpurple: [
        "#42004D",
        "#650370",
        "#8A0D93",
        "#B01BB6",
        "#D92ED9",
        "#E13DDB",
        "#E866DF",
        "#F092E6",
        "#F7C1F0",
        "#FFF2FD",
      ],
      magenta: [
        "#4D0034",
        "#770850",
        "#A1176C",
        "#CB2B88",
        "#F545A6",
        "#F756A9",
        "#F97AB8",
        "#FB9EC8",
        "#FDC3DB",
        "#FFE8F1",
      ],
      gray: [
        "#f7f8fa",
        "#f2f3f5",
        "#e5e6eb",
        "#c9cdd4",
        "#a9aeb8",
        "#86909c",
        "#6b7785",
        "#4e5969",
        "#272e3b",
        "#1d2129",
      ],
    },
  },
  zW = {
    common: Sk,
    data: [],
    fields: OW,
    style: {
      tessellate: !0,
      padding: 10,
      size: 20,
      height: {
        type: $U.LINEAR,
        linear: {
          domain: [],
          range: [0, 70],
          clamp: !1,
        },
        threshold: {
          domain: [],
          range: [0, 100],
        },
        ordinal: {
          domain: [],
          range: [0, 100],
        },
        constant: 50,
        default: 0,
      },
      fill: {
        color: {
          type: $U.LINEAR,
          linear: {
            domain: [],
            range: ["rgba(255,199,113,1)", "rgba(255,100,58,1)"],
            clamp: !1,
          },
          threshold: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
          },
          ordinal: {
            domain: [],
            range: FW.light.arcoblue,
            unknown: "undefined",
          },
          constant: FW.light.arcoblue[1],
          default: "rgba(103,255,255,0.1)",
          calcMethod: "sum",
        },
      },
    },
    poi: {
      enabled: !1,
      hideOnMove: !1,
      alignment: "middle",
      offsetX: 0,
      offsetY: 0,
      coverEnable: !1,
      orient: "vertical",
      anchor: EW.TOP,
      major: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      minor: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      custom: {
        enabled: !1,
        markerType: "css2d",
        element: null,
      },
    },
    clipMode: Qw.intersect,
    interaction: {
      hover: {
        enabled: !1,
        trigger: "mousemove",
        effect: {
          color: vk,
          poi: !1,
        },
      },
      select: {
        enabled: !1,
        trigger: "click",
        multi: !1,
        effect: {
          color: bk,
          poi: !1,
        },
      },
    },
  };
class kW extends RW {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1),
      this.gis.shaderService.registerModule("hexagonShader", {
        vertexShader:
          "varying vec4 vColor;\nattribute vec4 color;\n#pragma common\nvoid main() {\n  vColor = color;\n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * caclPosition(position);\n}",
        fragmentShader:
          "precision highp float;\nvarying vec4 vColor;\nvoid main() {\n  gl_FragColor *= vec4(vColor);\n}",
        basicMaterial: ot(rt({}, mr.phong), {
          lights: !0,
        }),
        defines: {},
      }),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(zW);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "heatmap-hexagon-layer",
      layerType: "heatmap",
      label: t,
    });
  }
  _getParseData(t) {
    const { fields: e } = this.state,
      { lngField: i, latField: n } = e;
    return super._getParseData(
      ot(rt({}, t), {
        layerType: "Point",
        coordsField: {
          lngField: i,
          latField: n,
        },
      })
    );
  }
  _getLayoutData(t) {
    const { style: e, parseData: i } = this.state,
      { tessellate: n, size: r, padding: o } = e,
      { globalOpts: a } = this.gis,
      { bboxOption: s, boundary: l } = a,
      { bboxScale: u } = s,
      c = bW(i, {
        size: u * r * 1e4 * Bf,
        padding: u * o * 1e4 * Bf,
        boundary: l.features[0],
        tessellate: n,
      });
    this.state.layoutData = c;
  }
  _getScaleData() {
    const { style: t, fields: e, layoutData: i } = this.state,
      {
        fill: { color: n },
        height: r,
      } = t,
      o = {
        color: {
          field: e.colorField,
          calcMethod: n.calcMethod || "sum",
        },
        height: r && {
          field: e.heightField,
          calcMethod: r.calcMethod || "sum",
        },
        majorPOIField: e.majorPOIField,
        minorPOIField: e.minorPOIField,
      },
      a = YH(i, o, n.conditional),
      s = [
        {
          visual: n,
          scaleField: "colorField",
          dataField: "_color_",
        },
        {
          scaleField: "majorPOIField",
          dataField: "_majorPOI_",
        },
        {
          scaleField: "minorPOIField",
          dataField: "_minorPOI_",
        },
      ];
    return (
      r &&
        s.push({
          visual: r,
          scaleField: "heightField",
          dataField: "_height_",
        }),
      (this.state.scaleData = this.scaleService.apply(s, a)),
      this
    );
  }
  _getRenderData(t) {
    const { scaleData: e, style: i } = this.state,
      { size: n, padding: r, height: o } = i,
      a = o ? "hexagonColumn" : "hexagon",
      { globalOpts: s } = this.gis,
      { bboxOption: l } = s,
      { bboxScale: u } = l,
      c = u * n * 1e4 * Bf,
      h = u * r * 1e4 * Bf,
      p = AW(e, {
        radiusTop: c - h,
        radiusBottom: c - h,
        segments: 6,
        shape: a,
      });
    return (this.state.renderData = p), this;
  }
  add(t) {
    const e = t;
    return e && 0 !== e.length
      ? (this.state.data.push(...e),
        mf(
          this._getParseData.bind(this),
          this._getLayoutData.bind(this),
          this._getScaleData.bind(this),
          this._getRenderData.bind(this),
          this.__draw.bind(this)
        )({
          rawData: t,
        }),
        this)
      : this;
  }
  updateArea() {
    super.updateArea();
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  set(t) {
    return super.set(t), this;
  }
  async __draw() {
    const {
      poi: { anchor: t, enabled: e, major: i, minor: n },
      renderData: r,
      style: o,
    } = this.state;
    if (0 === r.length) return;
    const { height: a } = o,
      s = a ? "hexagonColumn" : "hexagon",
      {
        indices: l,
        position: u,
        uv: c,
        normal: h,
        colors: p,
        height: d,
        dataArray: f,
      } = r,
      g = f.length,
      m = new En();
    m.setAttribute("position", new bn(u, 3)), m.setIndex(new yn(l, 1));
    m.setAttribute("color", new ns(new Float32Array(p), 4, !1, 1)),
      m.setAttribute("normal", new bn(h, 3)),
      m.setAttribute("uv", new bn(c, 2)),
      m.computeVertexNormals();
    const y = this.gis.shaderService.getShaderModule("hexagonShader"),
      v = new Jn(
        ot(rt({}, y), {
          transparent: !0,
        })
      );
    if (((v.uniforms.diffuse.value = new ln("#E2E2E2")), this.instancedMesh)) {
      for (let x = 0; x < this.coreGroup.children.length; x++)
        if (this.coreGroup.children[x].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new ls(m, v, g)),
            this.coreGroup.remove(this.coreGroup.children[x]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new ls(m, v, g)),
        this.coreGroup.add(this.instancedMesh);
    this.instancedMesh.setRenderIndex(lU.HEXAGON_HEATMAP);
    let b = 0;
    for (let x = 0; x < g; x++) {
      const r = f[x],
        o = r.coordinates[0],
        a = r.coordinates[1];
      this.dummy.position.set(o, a, 0);
      const l = this._mapSize(d[x], "z");
      if (
        (-1 !== s.indexOf("Column") && this.dummy.scale.set(1, 1, l),
        this.dummy.updateMatrix(),
        this.instancedMesh.setMatrixAt(x, this.dummy.matrix),
        this.instancedMesh.setUserDataAt(x, rt({}, r)),
        e)
      ) {
        switch (((b = l), t)) {
          case EW.BOTTOM:
            b = 0;
            break;
          case EW.MIDDLE:
            b = l / 2;
          case EW.TOP:
        }
        await this._addPoiMesh({
          pointPosition: {
            x: o,
            y: a,
            z: b + this.coreGroup.position.z,
          },
          majorContent: i.format ? i.format(f[x]._majorPOI_) : f[x]._majorPOI_,
          minorContent: n.format ? n.format(f[x]._minorPOI_) : f[x]._minorPOI_,
          ext: {
            relatedInstanceId: x,
          },
        });
      }
    }
    (this.instancedMesh.instanceMatrix.needsUpdate = !0), this._updatePOI(!0);
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  _clearData() {
    super._clearData(), (this.state.layoutData = []);
  }
  clear() {
    super.clear(), (this.coreGroup.children = []), (this.instancedMesh = null);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "tessellate"],
            ["style", "padding"],
            ["style", "size"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getLayoutData.bind(this),
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "fill"],
            ["style", "height"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          super.initPOI();
        }),
      ]);
  }
}
const BW = {
  common: Sk,
  data: [],
  fields: OW,
  style: {
    tessellate: !0,
    padding: 10,
    size: 30,
    height: {
      type: $U.LINEAR,
      linear: {
        domain: [],
        range: [0, 70],
        clamp: !1,
      },
      threshold: {
        domain: [],
        range: [0, 100],
      },
      ordinal: {
        domain: [],
        range: [0, 100],
      },
      constant: 50,
      default: 0,
    },
    fill: {
      color: {
        type: $U.LINEAR,
        linear: {
          domain: [],
          range: ["rgba(255,199,113,1)", "rgba(255,100,58,1)"],
          clamp: !1,
        },
        threshold: {
          domain: [],
          range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
        },
        ordinal: {
          domain: [],
          range: FW.light.arcoblue,
          unknown: "undefined",
        },
        constant: FW.light.arcoblue[1],
        default: "rgba(103,255,255,0.1)",
        calcMethod: "sum",
      },
    },
  },
  poi: {
    enabled: !1,
    hideOnMove: !1,
    alignment: "middle",
    offsetX: 0,
    offsetY: 0,
    coverEnable: !1,
    orient: "vertical",
    anchor: EW.TOP,
    major: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    minor: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    custom: {
      enabled: !1,
      markerType: "css2d",
      element: null,
    },
  },
  clipMode: Qw.intersect,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class GW extends RW {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1),
      this.gis.shaderService.registerModule("gridShader", {
        vertexShader:
          "varying vec4 vColor;\nattribute vec4 color;\nvoid main() {\n  vColor = color;\n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n}",
        fragmentShader:
          "precision highp float;\nvarying vec4 vColor;\nvoid main() {\n  gl_FragColor *= vec4(vColor);\n}",
        basicMaterial: ot(rt({}, mr.phong), {
          lights: !0,
        }),
        defines: {},
      }),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(BW);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "heatmap-grid-layer",
      layerType: "heatmap",
      label: t,
    });
  }
  _getParseData(t) {
    const { fields: e } = this.state,
      { lngField: i, latField: n } = e;
    return super._getParseData(
      ot(rt({}, t), {
        layerType: "Point",
        coordsField: {
          lngField: i,
          latField: n,
        },
      })
    );
  }
  _getLayoutData(t) {
    const { style: e, parseData: i } = this.state,
      { size: n, padding: r, tessellate: o } = e,
      { globalOpts: a } = this.gis,
      { bboxOption: s, boundary: l } = a,
      { bboxScale: u } = s,
      c = _W(i, {
        size: u * n * 1e4 * Bf,
        padding: u * r * 1e4 * Bf,
        boundary: l.features[0],
        tessellate: o,
      });
    this.state.layoutData = c;
  }
  _getScaleData() {
    const { style: t, fields: e, layoutData: i } = this.state,
      {
        fill: { color: n },
        height: r,
      } = t,
      o = {
        color: {
          field: e.colorField,
          calcMethod: n.calcMethod || "sum",
        },
        height: r && {
          field: e.heightField,
          calcMethod: r.calcMethod || "sum",
        },
        majorPOIField: e.majorPOIField,
        minorPOIField: e.minorPOIField,
      },
      a = YH(i, o, n.conditional),
      s = [
        {
          visual: n,
          scaleField: "colorField",
          dataField: "_color_",
        },
        {
          scaleField: "majorPOIField",
          dataField: "_majorPOI_",
        },
        {
          scaleField: "minorPOIField",
          dataField: "_minorPOI_",
        },
      ];
    return (
      r &&
        s.push({
          visual: r,
          scaleField: "heightField",
          dataField: "_height_",
        }),
      (this.state.scaleData = this.scaleService.apply(s, a)),
      this
    );
  }
  _getRenderData(t) {
    const { scaleData: e, style: i } = this.state,
      { size: n, padding: r, height: o } = i,
      a = o ? "hexagonColumn" : "hexagon",
      { globalOpts: s } = this.gis,
      { bboxOption: l } = s,
      { bboxScale: u } = l,
      c = u * n * 1e4 * Bf,
      h = u * r * 1e4 * Bf,
      p = AW(e, {
        radiusTop: (c - h) / (2 * Math.cos(Math.PI / 4)),
        radiusBottom: (c - h) / (2 * Math.cos(Math.PI / 4)),
        angle: -Math.PI / 12,
        segments: 4,
        shape: a,
      });
    return (this.state.renderData = p), this;
  }
  add(t) {
    const e = t;
    return e && 0 !== e.length
      ? (this.state.data.push(...e),
        mf(
          this._getParseData.bind(this),
          this._getLayoutData.bind(this),
          this._getScaleData.bind(this),
          this._getRenderData.bind(this),
          this.__draw.bind(this)
        )({
          rawData: t,
        }),
        this)
      : this;
  }
  updateArea() {
    super.updateArea();
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  set(t) {
    return super.set(t), this;
  }
  async __draw() {
    const {
        poi: { anchor: t, enabled: e, major: i, minor: n },
        renderData: r,
        style: o,
      } = this.state,
      {
        indices: a,
        position: s,
        uv: l,
        normal: u,
        colors: c,
        height: h,
        dataArray: p,
      } = r;
    if (0 === r.length) return;
    const { height: d } = o,
      f = d ? "gridColumn" : "grid",
      g = p.length,
      m = new En();
    m.setAttribute("position", new bn(s, 3)), m.setIndex(new yn(a, 1));
    m.setAttribute("color", new ns(new Float32Array(c), 4, !1, 1)),
      m.setAttribute("normal", new bn(u, 3)),
      m.setAttribute("uv", new bn(l, 2)),
      m.computeVertexNormals();
    const y = this.gis.shaderService.getShaderModule("gridShader"),
      v = new Jn(
        ot(rt({}, y), {
          transparent: !0,
        })
      );
    if (((v.uniforms.diffuse.value = new ln("#E2E2E2")), this.instancedMesh)) {
      for (let x = 0; x < this.coreGroup.children.length; x++)
        if (this.coreGroup.children[x].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new ls(m, v, g)),
            this.coreGroup.remove(this.coreGroup.children[x]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new ls(m, v, g)),
        this.coreGroup.add(this.instancedMesh);
    this.instancedMesh.setRenderIndex(lU.HEXAGON_HEATMAP);
    let b = 0;
    for (let x = 0; x < g; x++) {
      const r = p[x],
        o = r.coordinates[0],
        a = r.coordinates[1];
      this.dummy.position.set(o, a, 0);
      const s = this._mapSize(h[x], "z");
      if (
        (-1 !== f.indexOf("Column") && this.dummy.scale.set(1, 1, s),
        this.dummy.updateMatrix(),
        this.instancedMesh.setMatrixAt(x, this.dummy.matrix),
        this.instancedMesh.setUserDataAt(x, rt({}, r)),
        e)
      ) {
        switch (((b = s), t)) {
          case EW.BOTTOM:
            b = 0;
            break;
          case EW.MIDDLE:
            b = s / 2;
          case EW.TOP:
        }
        await this._addPoiMesh({
          pointPosition: {
            x: o,
            y: a,
            z: b + this.coreGroup.position.z,
          },
          majorContent: i.format ? i.format(p[x]._majorPOI_) : p[x]._majorPOI_,
          minorContent: n.format ? n.format(p[x]._minorPOI_) : p[x]._minorPOI_,
          ext: {
            relatedInstanceId: x,
          },
        });
      }
    }
    (this.instancedMesh.instanceMatrix.needsUpdate = !0), this._updatePOI(!0);
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  _clearData() {
    super._clearData(), (this.state.layoutData = []);
  }
  clear() {
    super.clear(), (this.coreGroup.children = []), (this.instancedMesh = null);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "tessellate"],
            ["style", "padding"],
            ["style", "size"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getLayoutData.bind(this),
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "fill"],
            ["style", "height"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          super.initPOI();
        }),
      ]);
  }
}
const UW = "rgb(198,201,73)",
  jW = {
    inner: {
      hole: 1 / 4,
      radius: 0.5,
    },
    outer: {
      radius: 0.5,
      hole: 1 / 4,
      maxRadius: 2,
    },
  },
  HW = {
    common: Sk,
    fields: OW,
    speed: 1,
    size: 20,
    style: {
      fill: {
        colorConfig: {
          inner: {
            color: UW,
            maxOpacity: 1,
            minOpacity: 0,
          },
          outer: {
            color: UW,
            maxOpacity: 0.5,
            minOpacity: 0,
          },
        },
      },
    },
    poi: {
      enabled: !1,
      hideOnMove: !1,
      alignment: "middle",
      offsetX: 0,
      offsetY: 0,
      coverEnable: !1,
      orient: "vertical",
      major: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      minor: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      custom: {
        enabled: !1,
        markerType: "css2d",
        element: null,
      },
    },
  },
  VW = af(HW, {
    data: [],
    clipMode: Qw.intersect,
    interaction: {
      hover: {
        enabled: !1,
        trigger: "mousemove",
        effect: {
          color: vk,
          poi: !1,
        },
      },
      select: {
        enabled: !1,
        trigger: "click",
        multi: !1,
        effect: {
          color: bk,
          poi: !1,
        },
      },
    },
  }),
  WW = {
    common: Sk,
    fields: OW,
    data: [],
    style: {
      layout: "BezierCurve3",
      blend: "NoBlending",
      width: 4,
      fill: {
        fromColor: {
          type: $U.CONSTANT,
          linear: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
            clamp: !1,
          },
          threshold: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
          },
          ordinal: {
            domain: [],
            range: FW.light.arcoblue,
            unknown: "undefined",
          },
          constant: "rgba(158,238,255,0.1)",
          default: "rgba(255,255,255,0)",
        },
        toColor: {
          type: $U.CONSTANT,
          linear: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
            clamp: !1,
          },
          threshold: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
          },
          ordinal: {
            domain: [],
            range: FW.light.arcoblue,
            unknown: "undefined",
          },
          constant: "#9EEEFF",
          default: "rgba(255,255,255,0)",
        },
      },
    },
    animation: {
      enabled: !0,
      speed: 1,
    },
    breathPointLayer: af(HW, {
      clipMode: Qw.none,
    }),
    clipMode: Qw.intersect,
    interaction: {
      hover: {
        enabled: !1,
        trigger: "mousemove",
        effect: {
          color: vk,
          poi: !1,
        },
      },
      select: {
        enabled: !1,
        trigger: "click",
        multi: !1,
        effect: {
          color: bk,
          poi: !1,
        },
      },
    },
  },
  qW = new Mi(),
  YW = new Si(),
  XW = new fi(),
  QW = new Ye(),
  ZW = new Ye(),
  JW = new Ye(),
  KW = new Le(),
  $W = new Le(),
  tq = new Le(),
  eq = new Ye(),
  iq = new Ye();
function nq(t, e, i, n) {
  const r = i.geometry,
    o = i.material,
    a = i.matrixWorld;
  if (void 0 === o) return;
  if (
    (XW.set(new Ye(0, 0, 0), 0.5 * i.material.uniforms.resolution.value * n),
    XW.applyMatrix4(a),
    !1 === t.ray.intersectsSphere(XW))
  )
    return;
  if (
    (qW.copy(a).invert(),
    YW.copy(t.ray).applyMatrix4(qW),
    null !== r.boundingBox && !1 === YW.intersectsBox(r.boundingBox))
  )
    return;
  let s;
  if (r.isBufferGeometry) {
    const a = r.index,
      l = r.attributes.position,
      u = r.attributes.uv,
      c = r.attributes.uv2,
      h = r.groups,
      p = r.drawRange;
    if (null !== a)
      if (Array.isArray(o))
        for (let r = 0, d = h.length; r < d; r++) {
          const d = h[r],
            f = o[d.materialIndex];
          if (void 0 === f) continue;
          for (
            let r = Math.max(d.start, p.start),
              o = Math.min(
                a.count,
                Math.min(d.start + d.count, p.start + p.count)
              );
            r < o;
            r += 3
          ) {
            const o = a.getX(r),
              h = a.getX(r + 1),
              p = a.getX(r + 2);
            (s = rq(i, f, t, YW, l, u, c, o, h, p, n)),
              s &&
                ((s.faceIndex = Math.floor(r / 3)),
                (s.face.materialIndex = d.materialIndex),
                e.push(s));
          }
        }
      else {
        for (
          let r = Math.max(0, p.start),
            h = Math.min(a.count, p.start + p.count);
          r < h;
          r += 3
        ) {
          const h = a.getX(r),
            p = a.getX(r + 1),
            d = a.getX(r + 2);
          (s = rq(i, o, t, YW, l, u, c, h, p, d, n)),
            s && ((s.faceIndex = Math.floor(r / 3)), e.push(s));
        }
      }
    else if (void 0 !== l)
      if (Array.isArray(o))
        for (let r = 0, d = h.length; r < d; r++) {
          const a = h[r],
            d = o[a.materialIndex];
          for (
            let r = Math.max(a.start, p.start),
              o = Math.min(
                l.count,
                Math.min(a.start + a.count, p.start + p.count)
              );
            r < o;
            r += 3
          ) {
            (s = rq(i, d, t, YW, l, u, c, r, r + 1, r + 2, n)),
              s &&
                ((s.faceIndex = Math.floor(r / 3)),
                (s.face.materialIndex = a.materialIndex),
                e.push(s));
          }
        }
      else {
        for (
          let r = Math.max(0, p.start),
            a = Math.min(l.count, p.start + p.count);
          r < a;
          r += 3
        ) {
          (s = rq(i, o, t, YW, l, u, c, r, r + 1, r + 2, n)),
            s && ((s.faceIndex = Math.floor(r / 3)), e.push(s));
        }
      }
  } else
    r.isGeometry &&
      console.error(
        "@dp/gis-engine: Mesh.raycast() no longer supports Geometry. Use BufferGeometry instead."
      );
}
function rq(t, e, i, n, r, o, a, s, l, u, c) {
  QW.fromBufferAttribute(r, s),
    ZW.fromBufferAttribute(r, l),
    JW.fromBufferAttribute(r, u);
  const h = t.material.uniforms.resolution.value * c;
  QW.multiplyScalar(h), ZW.multiplyScalar(h), JW.multiplyScalar(h);
  const p = (function (t, e, i, n, r, o, a, s) {
    let l;
    if (
      ((l =
        e.side === bt
          ? n.intersectTriangle(a, o, r, !0, s)
          : n.intersectTriangle(r, o, a, e.side !== xt, s)),
      null === l)
    )
      return null;
    iq.copy(s), iq.applyMatrix4(t.matrixWorld);
    const u = i.ray.origin.distanceTo(iq);
    return u < i.near || u > i.far
      ? null
      : {
          distance: u,
          point: iq.clone(),
          object: t,
        };
  })(t, e, i, n, QW, ZW, JW, eq);
  if (p) {
    o &&
      (KW.fromBufferAttribute(o, s),
      $W.fromBufferAttribute(o, l),
      tq.fromBufferAttribute(o, u),
      (p.uv = tn.getUV(eq, QW, ZW, JW, KW, $W, tq, new Le()))),
      a &&
        (KW.fromBufferAttribute(a, s),
        $W.fromBufferAttribute(a, l),
        tq.fromBufferAttribute(a, u),
        (p.uv2 = tn.getUV(eq, QW, ZW, JW, KW, $W, tq, new Le())));
    const t = {
      a: s,
      b: l,
      c: u,
      normal: new Ye(),
      materialIndex: 0,
    };
    tn.getNormal(QW, ZW, JW, t.normal), (p.face = t);
  }
  return p;
}
function oq(t) {
  return (oq =
    "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
      ? function (t) {
          return typeof t;
        }
      : function (t) {
          return t &&
            "function" == typeof Symbol &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? "symbol"
            : typeof t;
        })(t);
}
function aq(t, e, i) {
  var n = i.value;
  if ("function" != typeof n)
    throw new TypeError(
      "@boundMethod decorator can only be applied to methods not: ".concat(
        oq(n)
      )
    );
  var r = !1;
  return {
    configurable: !0,
    get: function () {
      if (
        r ||
        this === t.prototype ||
        this.hasOwnProperty(e) ||
        "function" != typeof n
      )
        return n;
      var i = n.bind(this);
      return (
        (r = !0),
        Object.defineProperty(this, e, {
          configurable: !0,
          get: function () {
            return i;
          },
          set: function (t) {
            (n = t), delete this[e];
          },
        }),
        (r = !1),
        i
      );
    },
    set: function (t) {
      n = t;
    },
  };
}
function sq(t) {
  var e;
  return (
    "undefined" != typeof Reflect && "function" == typeof Reflect.ownKeys
      ? (e = Reflect.ownKeys(t.prototype))
      : ((e = Object.getOwnPropertyNames(t.prototype)),
        "function" == typeof Object.getOwnPropertySymbols &&
          (e = e.concat(Object.getOwnPropertySymbols(t.prototype)))),
    e.forEach(function (e) {
      if ("constructor" !== e) {
        var i = Object.getOwnPropertyDescriptor(t.prototype, e);
        "function" == typeof i.value &&
          Object.defineProperty(t.prototype, e, aq(t, e, i));
      }
    }),
    t
  );
}
function lq() {
  return 1 === arguments.length
    ? sq.apply(void 0, arguments)
    : aq.apply(void 0, arguments);
}
var uq = Object.defineProperty,
  cq = Object.getOwnPropertyDescriptor;
class hq {
  constructor(t, e, i, n = !1) {
    (this.renderSystem = t),
      (this.name = e),
      (this.structArray = i),
      (this.normalized = n),
      (this.attr = new ns(
        this.structArray.value,
        this.structArray.itemSize,
        n
      )),
      (this.capacity = this.structArray.capacity);
  }
  emplaceBack(...t) {
    this.structArray.emplaceBackWithArray(t), this.__checkCapacity();
  }
  emplaceBackWithArray(t) {
    this.structArray.emplaceBackWithArray(t), this.__checkCapacity();
  }
  emplaceWithArray(t, e) {
    this.structArray.emplaceWithArray(t, e);
  }
  refreshBuffer() {
    (this.attr.array = this.structArray.value),
      (this.attr.needsUpdate = !0),
      (this.attr.count = this.structArray.length);
  }
  bindGeometry(t) {
    (this.geometry = t),
      t.setAttribute(this.name, this.attr),
      (this.geometry._maxInstanceCount = this.structArray.capacity);
  }
  trim() {
    this.structArray.trim();
  }
  clear() {
    this.structArray.clear();
  }
  __checkCapacity() {
    if (this.capacity < this.structArray.capacity) {
      const t = this.attr;
      this.renderSystem.coreRenderer.attributes.remove(t),
        (this.attr = new ns(
          this.structArray.value,
          this.structArray.itemSize,
          this.normalized
        )),
        this.geometry &&
          ((this.geometry._maxInstanceCount = this.structArray.capacity),
          this.bindGeometry(this.geometry));
    }
    this.capacity = this.structArray.capacity;
  }
}
((t, e, i, n) => {
  for (
    var r, o = n > 1 ? void 0 : n ? cq(e, i) : e, a = t.length - 1;
    a >= 0;
    a--
  )
    (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
  n && o && uq(e, i, o);
})([lq], hq.prototype, "__checkCapacity", 1);
class pq {
  constructor() {
    (this.length = 0), (this.capacity = -1);
  }
  resize(t) {
    this.reserve(t);
  }
  reserve(t) {
    if (t > this.capacity) {
      (this.capacity = Math.max(t, Math.floor(4 * this.capacity))),
        (this.arrayBuffer = new ArrayBuffer(
          this.capacity * this.bytesPerElement
        ));
      const e = this.uint8;
      this._refreshViews(), e && this.uint8.set(e);
    }
  }
  trim() {
    this.length !== this.capacity &&
      ((this.capacity = this.length),
      (this.arrayBuffer = this.arrayBuffer.slice(
        0,
        this.length * this.bytesPerElement
      )),
      this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  emplaceWithArray(t, e) {
    this._isSafaIndex(t) && this.value.set(e, t * this.itemSize);
  }
  _isSafaIndex(t) {
    return this.value.length >= (t + 1) * this.itemSize;
  }
}
class dq extends pq {
  constructor(t = 256) {
    super(), (this.itemSize = 1), (this.bytesPerElement = 4), this.resize(t);
  }
  get value() {
    return this.float32;
  }
  emplaceBack(t) {
    const e = this.length;
    this.resize(e + 1), this.emplace(e, t), (this.length += 1);
  }
  emplaceBackWithArray(t) {
    const e = this.length;
    this.resize(e + 1), this.emplace(e, t[0]), (this.length += 1);
  }
  emplace(t, e) {
    const i = 1 * t;
    return (this.float32[i] = e), t;
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.float32 = new Float32Array(this.arrayBuffer));
  }
}
class fq extends pq {
  constructor(t = 256) {
    super(), (this.itemSize = 3), (this.bytesPerElement = 12), this.resize(t);
  }
  get value() {
    return this.float32;
  }
  emplaceBack(t, e, i) {
    const n = this.length;
    this.resize(n + 1), this.emplace(n, t, e, i), (this.length += 1);
  }
  emplaceBackWithArray(t) {
    const e = this.length;
    this.resize(e + 1), this.emplace(e, t[0], t[1], t[2]), (this.length += 1);
  }
  emplace(t, e, i, n) {
    const r = 3 * t;
    return (
      (this.float32[r] = e),
      (this.float32[r + 1] = i),
      (this.float32[r + 2] = n),
      t
    );
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.float32 = new Float32Array(this.arrayBuffer));
  }
}
class gq extends pq {
  constructor(t = 256) {
    super(), (this.itemSize = 4), (this.bytesPerElement = 4), this.resize(t);
  }
  get value() {
    return this.u8c;
  }
  emplaceBack(t, e, i, n) {
    const r = this.length;
    this.resize(r + 1), this.emplace(r, t, e, i, n), (this.length += 1);
  }
  emplaceBackWithArray(t) {
    const e = this.length;
    this.resize(e + 1),
      this.emplace(e, t[0], t[1], t[2], t[3]),
      (this.length += 1);
  }
  emplace(t, e, i, n, r) {
    const o = 4 * t;
    return (
      (this.u8c[o] = e),
      (this.u8c[o + 1] = i),
      (this.u8c[o + 2] = n),
      (this.u8c[o + 3] = r),
      t
    );
  }
  emplaceWithArray(t, e) {
    this.u8c.length >= 4 * t + 4 && this.u8c.set(e, 4 * t);
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.u8c = new Uint8ClampedArray(this.arrayBuffer));
  }
}
class mq extends pq {
  constructor(t = 256) {
    super(), (this.itemSize = 16), (this.bytesPerElement = 64), this.resize(t);
  }
  get value() {
    return this.float32;
  }
  emplaceBackWithArray(t) {
    const e = this.length;
    this.resize(e + 1), this.float32.set(t, 16 * e), (this.length += 1);
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.float32 = new Float32Array(this.arrayBuffer));
  }
}
function yq(t) {
  if (4 === t)
    return (function () {
      const t = 4,
        e = [],
        i = [];
      e.push(0, 0, 0, 0),
        e.push(0.5, 0.5, 0, 1),
        e.push(0.5, -0.5, 0, 1),
        e.push(-0.5, -0.5, 0, 1),
        e.push(-0.5, 0.5, 0, 1);
      let n = t;
      for (; n--; ) 0 === n ? i.push(0, n + 1, t) : i.push(0, n + 1, n);
      const r = new $a(new Float32Array(e), 4),
        o = new En();
      return (
        o.setAttribute("position", new es(r, 3, 0)),
        o.setAttribute("radius", new es(r, 1, 3)),
        o.setIndex(i),
        o
      );
    })();
  const e = [],
    i = [];
  e.push(0, 0, 0, 0);
  const n = (2 * Math.PI) / t;
  let r = t;
  for (; r--; ) e.push(Math.cos(n * r) / 2, Math.sin(n * r) / 2, 0, 1);
  for (r = t; r--; ) 0 === r ? i.push(0, r + 1, t) : i.push(0, r + 1, r);
  const o = new $a(new Float32Array(e), 4),
    a = new En();
  return (
    a.setAttribute("position", new es(o, 3, 0)),
    a.setAttribute("radius", new es(o, 1, 3)),
    a.setIndex(i),
    a
  );
}
const vq = Symbol("EmptyImage"),
  bq = 1024,
  xq = 128;
class _q extends Es {
  constructor() {
    const t = document.createElement("canvas");
    (t.height = bq),
      (t.width = bq),
      super(t),
      (this.urls = []),
      (this.transparentImages = new Int8Array(64)),
      (this.ctx = t.getContext("2d")),
      (this.ctx.fillStyle = "green"),
      (this.imageLoder = new nE());
  }
  static getImagesFromVisualConfig(t) {
    let e = [];
    switch (t.type) {
      case $U.CONSTANT:
        t.constant && e.push(t.constant);
        break;
      case $U.THRESHOLD:
        (e = [...t.threshold.range]),
          t.default && e.indexOf(t.default) < 0 && e.unshift(t.default),
          t.constant && e.indexOf(t.constant) < 0 && e.unshift(t.constant);
        break;
      case $U.ORDINAL:
        (e = [...t.ordinal.range]),
          t.default && e.indexOf(t.default) < 0 && e.unshift(t.default),
          t.constant && e.indexOf(t.constant) < 0 && e.unshift(t.constant);
    }
    return e;
  }
  async update(t) {
    var e, i;
    (e = t),
      (i = this.urls),
      (e.length !== i.length || e.some((t, e) => t !== i[e])) &&
        (await this._updateTexture(t), (this.urls = t));
  }
  getIconIndex(t) {
    return this.urls.indexOf(t);
  }
  getIconCount() {
    return this.urls.length;
  }
  async _updateTexture(t) {
    const { ctx: e } = this;
    e.clearRect(0, 0, bq, bq);
    const i = await Promise.all(
      t.map((t, e) => (t ? this.imageLoder.loadAsync(t) : vq))
    ).catch((t) => {});
    if (!i) return;
    const n = this.transparentImages.fill(0);
    i.forEach((t, i) => {
      const r = (i % 8) * xq,
        o = (7 - Math.floor(i / 8)) * xq;
      t === vq
        ? ((n[i] = 1), e.fillRect(r, o, xq, xq))
        : ((n[i] = gf(t) ? 1 : 0), e.drawImage(t, r, o, xq, xq));
    }),
      (this.transparentImages = n),
      (this.needsUpdate = !0);
  }
}
class Sq extends Jn {
  constructor() {
    super({
      vertexShader:
        "precision highp float;\nattribute float instanceSize;\nuniform vec2 valueRange;\nuniform bool usePixel;\n\nuniform float resolution;\nvarying float vInstanceValue;\n#if  defined(USE_ATTRIBUTE_COLOR)\nattribute vec4 color;\nvarying vec4 vColor;\n#endif\n\n#ifdef USE_IMAGE\nattribute float iconIndex;\nvarying vec2 vTextureCoord;\nvarying float vIconIndex;\n#endif\n\n#ifdef USE_RADIUS\nattribute float radius;\nvarying float vRadius;\n#endif\n\nuniform float scale;\n\nvoid main() {\n\n#ifdef USE_RADIUS\n  vRadius = radius;\n#endif\n#ifdef USE_COLORSCALE\n  float valueFactor = smoothstep(valueRange.x, valueRange.y, instanceSize);\n  vInstanceValue = valueFactor;\n#elif  defined(USE_ATTRIBUTE_COLOR)\n  vColor = color;\n#endif\n#ifdef USE_IMAGE\n  vTextureCoord = position.xy + 0.5;\n  vIconIndex = iconIndex;\n#endif\n  vec3 pos = position;\n  pos.xy *= scale;\n    \n  float valueFactor = smoothstep(valueRange.x, valueRange.y, instanceSize);\n  float size = instanceSize;\n  gl_Position = usePixel ? projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos * size * resolution, 1.) : projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.);\n    \n}",
      fragmentShader:
        "precision highp float;\n\nfloat between(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0., 1.);\n}\n\n#ifdef USE_COLORSCALE\nuniform sampler2D colorscale;\nvarying float vInstanceValue;\n#elif  defined(USE_ATTRIBUTE_COLOR)\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n\n#ifdef USE_IMAGE\nuniform sampler2D image;\nuniform bool transparentImage;\nuniform bool[MAX_ICON_ROW * MAX_ICON_ROW] uTransparentImages;\n\nvarying float vIconIndex;\nvec2 mixIconCoord(vec2 v) {\n    float maxIconCount = float(MAX_ICON_ROW);\n    float y = floor(vIconIndex / maxIconCount);\n    float x = mod(vIconIndex, maxIconCount);\n    return vec2(mix(between(0., maxIconCount, x), between(0., maxIconCount, x + 1.), v.x), mix(between(0., maxIconCount, y), between(0., maxIconCount, y + 1.), v.y));\n}\nvarying vec2 vTextureCoord;\n#endif\n\n#ifdef USE_RADIUS\nvarying float vRadius;\nuniform float inRadius;\n#endif\nuniform float opacity;\n\nvoid main() {\n\n    #if defined(USE_RADIUS) && !defined(USE_IMAGE)\n    if(vRadius < inRadius) {\n        discard;\n    }\n    #endif\n\n    vec4 finalColor = vec4(1.0, 0.0, 0.0, 0.0);\n    #ifndef USE_IMAGE\n    #ifdef USE_COLORSCALE\n    finalColor = texture2D(colorscale, vec2(vInstanceValue, 0.5));\n    #elif  defined(USE_ATTRIBUTE_COLOR)\n    finalColor = vColor;\n    #else\n    finalColor = color;\n\n    #endif\n    #else\n\n    vec2 coord = mixIconCoord(vTextureCoord);\n    \n    bool transparent = uTransparentImages[int(vIconIndex)];\n    if(!transparent) {\n        finalColor = texture2D(image, coord);\n    } else if(texture2D(image, coord).a == 1.) {\n        finalColor = texture2D(image, coord);\n    } else if(vColor.a == 0.) {\n        finalColor = texture2D(image, coord);\n    } else {\n        finalColor = vec4(vColor.rgb, texture2D(image, coord).a);\n    }\n\n    #endif\n    finalColor.a *= opacity;\n    gl_FragColor = finalColor;\n}",
      transparent: !0,
      depthTest: !1,
      uniforms: {
        scale: {
          value: 1,
        },
        opacity: {
          value: 1,
        },
        inRadius: {
          value: 0,
        },
        resolution: {
          value: 1,
        },
        color: {
          value: [0, 1, 0, 1],
        },
        image: {
          value: null,
        },
        valueRange: {
          value: [0, 1],
        },
        sizeRange: {
          value: [0, 1],
        },
        usePixel: {
          value: !1,
        },
        colorscale: {
          value: null,
        },
        uTransparentImages: {
          value: new Int8Array(64).fill(0),
        },
      },
      defines: {
        USE_ATTRIBUTE_COLOR: !0,
        MAX_ICON_ROW: 8,
      },
    });
  }
  set colorscale(t) {
    t ? (this.defines.USE_COLORSCALE = !0) : delete this.defines.USE_COLORSCALE,
      (this.uniforms.colorscale.value = t);
  }
  set image(t) {
    t ? (this.defines.USE_IMAGE = !0) : delete this.defines.USE_IMAGE,
      (this.uniforms.image.value = t);
  }
  set radius(t) {
    t <= 0
      ? (delete this.defines.USE_RADIUS, (this.uniforms.inRadius.value = 0))
      : ((this.defines.USE_RADIUS = !0), (this.uniforms.inRadius.value = t));
  }
}
const Mq = new Mi(),
  Cq = new Mi(),
  wq = [],
  Aq = new Wn();
class Eq extends ls {
  constructor(t, e) {
    super(yq(t), new Sq(), 0),
      (this.renderSystem = e),
      (this.instanceColorsAttr = new hq(
        this.renderSystem,
        "color",
        new gq(),
        !0
      )),
      (this.instanceSizeAttr = new hq(
        this.renderSystem,
        "instanceSize",
        new dq()
      )),
      (this.instanceIconIndexAttr = new hq(
        this.renderSystem,
        "iconIndex",
        new dq()
      )),
      (this.instanceMatrixAttr = new hq(
        this.renderSystem,
        "instanceMatrix",
        new mq()
      )),
      (this.segements = t),
      (this.matrixValue = new mq()),
      (this.positions = []),
      (this.dummy = new Hi()),
      this.instanceMatrix.setUsage(xe),
      this.__bindGeometry(this.geometry);
  }
  updateSegements(t) {
    (this.segements = t),
      this.geometry.dispose(),
      (this.geometry = yq(t)),
      this.__bindGeometry(this.geometry);
  }
  addBubble(t) {
    this.positions.push(t[0], t[1], t[2]),
      this.dummy.position.set(t[0], t[1], t[2]),
      this.dummy.scale.setX(1),
      this.dummy.scale.setY(1),
      this.dummy.updateMatrix(),
      this.instanceMatrixAttr.emplaceBackWithArray(this.dummy.matrix.elements),
      this.instanceColorsAttr.emplaceBack(0, 0, 0, 0),
      this.instanceSizeAttr.emplaceBack(0),
      this.instanceIconIndexAttr.emplaceBack(0),
      this.refreshBuffer();
  }
  setValueAt(t, e, i) {
    switch (e) {
      case "size":
        if (this.material.uniforms.usePixel.value) {
          const e = 3 * t,
            n = this.positions;
          if (0 === n.length) break;
          this.dummy.position.set(n[e + 0], n[e + 1], n[e + 2]),
            this.dummy.scale.setX(1),
            this.dummy.scale.setY(1),
            this.dummy.updateMatrix(),
            this.instanceMatrixAttr.emplaceWithArray(
              t,
              this.dummy.matrix.elements
            ),
            this.instanceSizeAttr.structArray.emplace(t, i);
        } else {
          const e = i,
            n = 3 * t,
            r = this.positions;
          if (0 === r.length) return;
          e &&
            (this.dummy.position.set(r[n + 0], r[n + 1], r[n + 2]),
            this.dummy.scale.setX(e),
            this.dummy.scale.setY(e),
            this.dummy.updateMatrix(),
            this.instanceMatrixAttr.emplaceWithArray(
              t,
              this.dummy.matrix.elements
            ));
        }
        break;
      case "color":
        this.instanceColorsAttr.emplaceWithArray(t, i);
        break;
      case "icon":
        this.instanceIconIndexAttr.structArray.emplace(t, i);
    }
  }
  refreshBuffer() {
    this.instanceSizeAttr.refreshBuffer(),
      this.instanceColorsAttr.refreshBuffer(),
      this.instanceIconIndexAttr.refreshBuffer(),
      this.instanceMatrixAttr.refreshBuffer(),
      (this.count = this.instanceMatrixAttr.structArray.length);
  }
  raycast(t, e) {
    if (!this.material.uniforms.usePixel.value) return super.raycast(t, e);
    const i = this.matrixWorld,
      n = this.count;
    if (
      ((Aq.geometry = this.geometry),
      (Aq.material = this.material),
      void 0 !== Aq.material)
    )
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, Mq),
          Cq.multiplyMatrices(i, Mq),
          (Aq.matrixWorld = Cq);
        const n = this.instanceSizeAttr.structArray.value[r];
        nq(t, wq, Aq, n);
        for (let t = 0, i = wq.length; t < i; t++) {
          const i = wq[t];
          (i.instanceId = r), (i.object = this), e.push(i);
        }
        wq.length = 0;
      }
  }
  trim() {
    this.instanceMatrixAttr.trim(),
      this.instanceSizeAttr.trim(),
      this.instanceColorsAttr.trim(),
      this.instanceIconIndexAttr.trim();
  }
  clear() {
    return (
      (this.positions = []),
      this.instanceSizeAttr.clear(),
      this.instanceColorsAttr.clear(),
      this.instanceIconIndexAttr.clear(),
      this.instanceMatrixAttr.clear(),
      this.refreshBuffer(),
      this
    );
  }
  __bindGeometry(t) {
    this.instanceColorsAttr.bindGeometry(this.geometry),
      this.instanceSizeAttr.bindGeometry(this.geometry),
      this.instanceIconIndexAttr.bindGeometry(this.geometry),
      this.instanceMatrixAttr.bindGeometry(this.geometry);
  }
}
class Dq extends NW {
  constructor(t, e, i = !1) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.innerWithFlyLine = i),
      (this.animationObjectGroup = new TE()),
      (this.tracks = []),
      this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      (this.__innerMesh = new Eq(30, this.gis.renderSystem)),
      (this.__outerMesh = new Eq(30, this.gis.renderSystem)),
      this.__innerMesh.setRenderIndex(lU.BREATH_POINT_LAYER_INNER_MESH),
      this.__outerMesh.setRenderIndex(lU.BREATH_POINT_LAYER_OUTER_MESH),
      (this.__innerMesh.material.radius = 0.5),
      (this.__outerMesh.material.radius = 0.5),
      this.__initAnimation(),
      this.animation.start(),
      super.registerInteraction(this.state.interaction, this.coreGroup, !0),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(VW);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "breath-point-layer",
      layerType: "point",
      label: t,
    });
  }
  updateArea() {
    if ((super.updateArea(), !this.innerWithFlyLine)) {
      const { data: t } = this.state;
      super.clear(),
        this.__destroyAnimation(),
        this.__clearData(),
        this.add(t),
        this.__initAnimation();
    }
  }
  async add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e);
    const {
        fields: { lngField: i, latField: n },
      } = this.state,
      { globalOpts: r } = this.gis,
      { clipMode: o, __pureData__: a } = this.state,
      { boundary: s } = r;
    if (a)
      for (let l = 0; l < e.length; l++) {
        const t = e[l];
        await this.__add(t);
      }
    else {
      const t = "Point",
        r = Yw(e[0]) ? "geojson" : "bytejson",
        a = !(!o || o === Qw.none),
        l = this.dataView
          .parse(e, {
            type: r,
            layerType: t,
            options: {
              coordsField: {
                lngField: i,
                latField: n,
              },
              layerType: t,
            },
          })
          .transform({
            type: "filter",
            options: {
              skip: !o || o === Qw.none,
              callback: a && ((t) => Kw(t, s.features[0], o)),
            },
          })
          .transform({
            type: "webgis",
            options: {
              as: "coordinates",
            },
          }).latestData;
      for (let e = 0; e < l.length; e++) {
        const t = l[e];
        await this.__add(t);
      }
    }
    return (
      this.coreGroup.add(this.__innerMesh),
      this.coreGroup.add(this.__outerMesh),
      this.__calcBreathPointSize(),
      this._updatePOI(!0),
      this
    );
  }
  set(t) {
    return super.set(t), this;
  }
  __calcBreathPointSize() {
    const {
        size: t,
        style: {
          fill: { colorConfig: e },
        },
        __pureData__: i,
        data: n,
      } = this.state,
      r = EA(e.inner.color),
      o = DA(r, e.inner.maxOpacity),
      a = [255 * r.color.r, 255 * r.color.g, 255 * r.color.b, 255 * o],
      s = this._mapSize(t, "xy");
    let l = i ? n : this.dataView.latestData;
    Array.isArray(l) || (l = [l]),
      l.forEach((t, e) => {
        this.__innerMesh.setValueAt(e, "size", s),
          this.__innerMesh.setValueAt(e, "color", a);
      }),
      this.__innerMesh.refreshBuffer();
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove(), this.__destroyAnimation();
  }
  async __add(t) {
    const { coordinates: e } = t,
      {
        poi: { major: i, minor: n },
        fields: r,
      } = this.state,
      o = {
        x: e[0],
        y: e[1],
        z: 0,
      };
    this.__addInnerMesh({
      pointPosition: o,
    }),
      this.__addOuterMesh({
        pointPosition: o,
      }),
      (o.z += this.coreGroup.position.z),
      await this._addPoiMesh({
        pointPosition: o,
        majorContent: i.format
          ? i.format(t[r.majorPOIField])
          : t[r.majorPOIField],
        minorContent: n.format
          ? n.format(t[r.minorPOIField])
          : t[r.minorPOIField],
      });
  }
  __addInnerMesh(t) {
    const { pointPosition: e } = t;
    this.__innerMesh.addBubble([e.x, e.y, e.z]);
  }
  __addOuterMesh(t) {
    const { pointPosition: e } = t;
    this.__outerMesh.addBubble([e.x, e.y, e.z]);
  }
  __initAnimation() {
    this.__breathPointAnimation &&
      this.animationObjectGroup.remove(this.__breathPointAnimation);
    const {
        style: {
          fill: { colorConfig: t },
        },
        size: e,
      } = this.state,
      i = this._mapSize(e, "xy") / 2,
      n = [0, 1e3],
      r = jW.outer,
      o = r.maxRadius / r.radius,
      a = new qA(".scale", n, [i, i, i, o * i, o * i, i]),
      s = EA(t.outer.color),
      l = new qA(".opacity", n, [
        DA(s, t.outer.maxOpacity),
        t.outer.minOpacity,
      ]);
    this.tracks.push(a, l),
      this.animationObjectGroup.add(
        new Tq(
          (t) => {
            const { __pureData__: e, data: i } = this.state;
            let n = e ? i : this.dataView.latestData;
            Array.isArray(n) || (n = [n]),
              n.forEach((e, i) => {
                this.__outerMesh.setValueAt(i, "size", t);
              }),
              this.__outerMesh.refreshBuffer();
          },
          (e) => {
            const { __pureData__: i, data: n } = this.state;
            let r = i ? n : this.dataView.latestData;
            Array.isArray(r) || (r = [r]);
            const o = EA(t.outer.color),
              a = [255 * o.color.r, 255 * o.color.g, 255 * o.color.b, 255 * e];
            r.forEach((t, e) => {
              this.__outerMesh.setValueAt(e, "color", a);
            }),
              this.__outerMesh.refreshBuffer();
          }
        )
      );
    (this.clip = new JA("breath-point", 1e3, this.tracks)),
      this.clip.optimize(),
      (this.mixer = new PE(this.animationObjectGroup)),
      (this.animationAction = this.mixer.clipAction(this.clip)),
      (this.animationAction.time = 0),
      this.__setSpeed(),
      (this.animationAction.loop = 2201),
      this.animationAction.play();
  }
  __setSpeed() {
    const { speed: t } = this.state;
    this.animationAction.timeScale = 1e3 * t;
  }
  __clearData() {
    (this.state.data = []),
      this.__innerMesh.destroy(),
      this.__outerMesh.destroy(),
      (this.__innerMesh = new Eq(30, this.gis.renderSystem)),
      (this.__outerMesh = new Eq(30, this.gis.renderSystem)),
      this.__innerMesh.setRenderIndex(lU.BREATH_POINT_LAYER_INNER_MESH),
      this.__outerMesh.setRenderIndex(lU.BREATH_POINT_LAYER_OUTER_MESH),
      (this.__innerMesh.material.radius = 0.5),
      (this.__outerMesh.material.radius = 0.5);
  }
  clear() {
    super.clear(), this.__innerMesh.destroy(), this.__outerMesh.destroy();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.__clearData(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule("", "always", () => {
          this.__setSpeed(),
            this.__calcBreathPointSize(),
            this.__destroyAnimation(),
            this.__initAnimation();
        }),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          super.initPOI();
        }),
      ]);
  }
  __destroyAnimation() {
    var t;
    (this.tracks = []),
      null == (t = this.mixer) || t.uncacheAction(this.clip, this.coreGroup),
      this.mixer.stopAllAction(),
      this.animationObjectGroup.uncache();
  }
  handleAnimation(t) {
    var e;
    const { deltaTime: i } = t;
    null == (e = this.mixer) || e.update(i);
  }
}
class Tq {
  constructor(t, e) {
    (this.scaleCb = t), (this.opacityCb = e), (this.uuid = we());
  }
  set scale(t) {
    this.scaleCb(t);
  }
  get scale() {
    return 1;
  }
  set opacity(t) {
    this.opacityCb(t);
  }
  get opacity() {
    return 1;
  }
}
const Pq = (t, e, i) => {
    const n = t.distanceTo(e);
    return t.lerp(e, i / n);
  },
  Lq = (t, e) => {
    if (0 === t.length) return t;
    const { height: i } = e,
      n = [],
      r = [],
      o = [];
    return (
      t.forEach((t, e) => {
        const { _fromColor_: a, _toColor_: s } = t,
          { color: l, opacity: u } = EA(a),
          { color: c, opacity: h } = EA(s);
        r.push(l.r, l.g, l.b, u), o.push(c.r, c.g, c.b, h);
        const p = t.coordinates.map((t) => new Ye(t[0], t[1], 0)),
          d = ((t, e, i) => {
            const n = (1.8 * t.angleTo(e)) / Math.PI / 0.1,
              r = 0.3 * n,
              o = n * n * 12,
              a = new Ye(0, 0, 0),
              s = new Si(
                a,
                ((t, e) => t.add(e).divideScalar(2))(t.clone(), e.clone())
              ),
              l = s.at(o / s.at(1, new Ye()).distanceTo(a), new Ye()),
              u = Pq(t.clone(), l, r),
              c = Pq(e.clone(), l, r);
            (u.z = i), (c.z = i);
            const h = new Bs(t, u, c, e).getPoints(50);
            return h.push(new Ye(-1, -1, -1)), h;
          })(p[0], p[p.length - 1], i);
        n.push(...d);
      }),
      {
        position: n,
        fromColor: r,
        toColor: o,
      }
    );
  };
class Iq extends oV {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e);
  }
}
class Nq extends En {
  constructor() {
    super(),
      (this.positions = []),
      (this.previous = []),
      (this.next = []),
      (this.side = []),
      (this.width = []),
      (this.indicesArray = []),
      (this.uvs = []),
      (this.counters = []),
      (this.fromColor = []),
      (this.toColor = []),
      (this._points = []),
      (this.type = "MeshLine"),
      (this.positions = []);
  }
  get geom() {
    if (!this._geom) throw new Error("Geometry has not been initialized yet");
    return this._geom;
  }
  set geom(t) {
    this.setGeometry(t);
  }
  get geometry() {
    return this;
  }
  set geometry(t) {
    this.setGeometry(t);
  }
  get points() {
    return this._points;
  }
  set points(t) {
    this.setPoints(t);
  }
  add2(t) {
    let e, i;
    (i = this.compareV3(0, t - 1) ? this.copyV3(t - 2) : this.copyV3(0)),
      this.previous.push(i[0], i[1], i[2]),
      this.previous.push(i[0], i[1], i[2]);
    for (let n = 0; n < t; n++) {
      if (
        (this.side.push(1),
        this.side.push(-1),
        (e = 1),
        this.width.push(1),
        this.width.push(1),
        this.uvs.push(n / (t - 1), 0),
        this.uvs.push(n / (t - 1), 1),
        n < t - 1)
      ) {
        (i = this.copyV3(n)),
          this.previous.push(i[0], i[1], i[2]),
          this.previous.push(i[0], i[1], i[2]);
        const t = 2 * n;
        this.indicesArray.push(t, t + 1, t + 2),
          this.indicesArray.push(t + 2, t + 1, t + 3);
      }
      n > 0 &&
        ((i = this.copyV3(n)),
        this.next.push(i[0], i[1], i[2]),
        this.next.push(i[0], i[1], i[2]));
    }
    (i = this.compareV3(t - 1, 0) ? this.copyV3(1) : this.copyV3(t - 1)),
      this.next.push(i[0], i[1], i[2]),
      this.next.push(i[0], i[1], i[2]);
  }
  process() {
    const t = this.positions.length / 6;
    (this.previous = []),
      (this.next = []),
      (this.side = []),
      (this.width = []),
      (this.indicesArray = []),
      (this.uvs = []),
      this.add2(t),
      this._attributes &&
      this._attributes.position.count === this.positions.length
        ? (this._attributes.position.copyArray(
            new Float32Array(this.positions)
          ),
          (this._attributes.position.needsUpdate = !0),
          this._attributes.previous.copyArray(new Float32Array(this.previous)),
          (this._attributes.previous.needsUpdate = !0),
          this._attributes.next.copyArray(new Float32Array(this.next)),
          (this._attributes.next.needsUpdate = !0),
          this._attributes.side.copyArray(new Float32Array(this.side)),
          (this._attributes.side.needsUpdate = !0),
          this._attributes.width.copyArray(new Float32Array(this.width)),
          (this._attributes.width.needsUpdate = !0),
          this._attributes.uv.copyArray(new Float32Array(this.uvs)),
          (this._attributes.uv.needsUpdate = !0),
          this._attributes.fromColor.copyArray(
            new Float32Array(this.fromColor)
          ),
          (this._attributes.fromColor.needsUpdate = !0),
          this._attributes.toColor.copyArray(new Float32Array(this.toColor)),
          (this._attributes.toColor.needsUpdate = !0),
          this._attributes.index.copyArray(new Uint16Array(this.indicesArray)),
          (this._attributes.index.needsUpdate = !0))
        : (this._attributes = {
            position: new gn(new Float32Array(this.positions), 3),
            previous: new gn(new Float32Array(this.previous), 3),
            next: new gn(new Float32Array(this.next), 3),
            side: new gn(new Float32Array(this.side), 1),
            width: new gn(new Float32Array(this.width), 1),
            uv: new gn(new Float32Array(this.uvs), 2),
            index: new gn(new Uint16Array(this.indicesArray), 1),
            counters: new gn(new Float32Array(this.counters), 1),
            fromColor: new gn(new Float32Array(this.fromColor), 4),
            toColor: new gn(new Float32Array(this.toColor), 4),
          }),
      this.setAttribute("position", this._attributes.position),
      this.setAttribute("previous", this._attributes.previous),
      this.setAttribute("next", this._attributes.next),
      this.setAttribute("side", this._attributes.side),
      this.setAttribute("width", this._attributes.width),
      this.setAttribute("uv", this._attributes.uv),
      this.setAttribute("counters", this._attributes.counters),
      this.setAttribute("fromColor", this._attributes.fromColor),
      this.setAttribute("toColor", this._attributes.toColor),
      this.setIndex(this._attributes.index);
  }
  setPoints(t, e) {
    const { position: i, fromColor: n, toColor: r } = t;
    (this._points = i),
      (this.lineNumber = e),
      (this.positions = []),
      (this.counters = []);
    const o = i.length / e;
    let a = Math.random(),
      s = [],
      l = [],
      u = 0;
    for (let c = 0; c < i.length; c++) {
      const t = i[c],
        e = c % o;
      0 === e &&
        ((a = Math.random()),
        (s = n.slice(4 * u, 4 * u + 4)),
        (l = r.slice(4 * u, 4 * u + 4)),
        (u += 1));
      const h = e / o + a;
      this.positions.push(t.x, t.y, t.z),
        this.positions.push(t.x, t.y, t.z),
        this.counters.push(h),
        this.counters.push(h),
        this.fromColor.push(...s),
        this.fromColor.push(...s),
        this.toColor.push(...l),
        this.toColor.push(...l);
    }
    this.process();
  }
  copyV3(t) {
    const e = 6 * t;
    return [this.positions[e], this.positions[e + 1], this.positions[e + 2]];
  }
  compareV3(t, e) {
    const i = 6 * t,
      n = 6 * e;
    return (
      this.positions[i] === this.positions[n] &&
      this.positions[i + 1] === this.positions[n + 1] &&
      this.positions[i + 2] === this.positions[n + 2]
    );
  }
  setGeometry(t) {
    (this._geom = t),
      t instanceof En
        ? this.setPoints(t.getAttribute("position").array)
        : this.setPoints(t);
  }
}
class Rq extends Jn {
  constructor(t) {
    super({
      defines: {
        USE_ANIMATION: !0,
        USE_COLOR_GRADIENT: !0,
        USE_OPACITY_GRADIENT: !1,
        USE_WIDTH_GRADIENT: !0,
      },
      vertexShader:
        "attribute vec3 previous;\nattribute vec3 next;\nattribute float side; \nattribute float width;\nattribute float counters;\nattribute vec4 color;\nattribute vec4 fromColor;\nattribute vec4 toColor;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\nuniform float dashArray;  \nuniform float dashOffset; \nuniform float dashRatio;  \n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec4 vfromColor;\nvarying vec4 vtoColor;\nvarying float vCounters;\nvarying float blur;\n\nvarying vec3 pos;\n\nvec2 fix(vec4 i, float aspect) {\n  \n  vec2 currentScreen = i.xy / i.w;\n  \n  currentScreen.x *= aspect;\n  return currentScreen;\n}\n\nvoid main() {\n  pos = position.xyz;\n  float aspect = resolution.x / resolution.y;\n  vCounters = counters;\n  vfromColor = fromColor;\n  vtoColor = toColor;\n  vUV = uv;\n  blur = 1.0;\n  #ifdef USE_ANIMATION\n  blur = mod((vCounters + dashOffset), (dashArray + dashArray * dashRatio));\n  blur /= dashArray;\n  #endif\n\n  mat4 mvp = projectionMatrix * modelViewMatrix;\n  \n  vec4 finalPosition = mvp * vec4(position, 1.0);\n  vec4 prevPos = mvp * vec4(previous, 1.0);\n  vec4 nextPos = mvp * vec4(next, 1.0);\n\n  vec2 currentP = fix(finalPosition, aspect);\n  vec2 prevP = fix(prevPos, aspect);\n  vec2 nextP = fix(nextPos, aspect);\n  \n  #ifdef USE_WIDTH_GRADIENT\n  float w = lineWidth * width * blur;\n  #else\n  float w = lineWidth * width;\n  #endif\n\n  vec2 dir;\n  if(nextP == currentP) {\n    dir = normalize(currentP - prevP);\n  } else if(prevP == currentP) {\n    dir = normalize(nextP - currentP);\n  } else {\n    vec2 dir1 = normalize(currentP - prevP);\n    vec2 dir2 = normalize(nextP - currentP);\n    dir = normalize(dir1 + dir2);\n    vec2 perp = vec2(-dir1.y, dir1.x);\n    vec2 miter = vec2(-dir.y, dir.x);\n    w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\n  }\n  \n  \n  vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\n  \n  normal.xy *= .5 * w;\n  normal *= projectionMatrix;\n  if(sizeAttenuation == 0.) {\n    normal.xy *= finalPosition.w;\n    normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy;\n  }\n\n  \n  vec4 offset = vec4(normal.xy * side, 0.0, 0.0);\n  gl_Position = finalPosition + offset;\n  gl_Position.z = 0.0;\n}",
      fragmentShader:
        "precision highp float;\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float useDash;\nuniform float dashArray;  \nuniform float dashOffset; \nuniform float dashRatio;  \n\nuniform float alphaTest;\nuniform vec2 repeat;\nvarying vec2 vUV;\nvarying float vCounters; \n\nvarying vec3 pos;\n\nuniform vec4 startColor;\nuniform vec4 endColor;\nvarying vec4 vfromColor;\nvarying vec4 vtoColor;\n\nfloat getOpacity(float x, float len) {\n    return 1.0 - 4.0 * (x - len / 2.0) * (x - len / 2.0) / (len * len);\n}\n\nvoid main() {\n    vec4 c = mix(vfromColor, vtoColor, vCounters);\n    #ifdef USE_ANIMATION\n    float blur = mod((vCounters + dashOffset), (dashArray + dashArray * dashRatio));\n    blur /= dashArray;\n    c = mix(vfromColor, vtoColor, blur);\n    #endif\n    if(pos.z < 0.0) { \n        discard;\n    }\n\n    if(useMap == 1.)\n        c *= texture2D(map, vUV * repeat);\n    if(useAlphaMap == 1.)\n        c.a *= texture2D(alphaMap, vUV * repeat).a;\n    if(c.a < alphaTest)\n        discard;\n    #ifdef USE_ANIMATION\n    if(useDash == 1.) {\n        \n        \n        float op = ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\n\n        if(blur >= 1.0 || blur < 0.2) {\n            discard;\n        } else {\n            \n        }\n    }\n    #endif\n\n    \n    gl_FragColor = c;\n\n    \n\n}",
      uniforms: {
        lineWidth: {
          value: 1,
        },
        map: {
          value: null,
        },
        useMap: {
          value: 0,
        },
        alphaMap: {
          value: null,
        },
        useAlphaMap: {
          value: 0,
        },
        color: {
          value: new ln(16777215),
        },
        opacity: {
          value: 1,
        },
        resolution: {
          value: new Le(1, 1),
        },
        sizeAttenuation: {
          value: 1,
        },
        dashArray: {
          value: 0,
        },
        dashOffset: {
          value: 0,
        },
        dashRatio: {
          value: 0.5,
        },
        useDash: {
          value: 0,
        },
        visibility: {
          value: 1,
        },
        alphaTest: {
          value: 0,
        },
        repeat: {
          value: new Le(1, 1),
        },
        lineCap: {
          value: 2,
        },
        startColor: {
          value: new je(0.72, 0.8, 1, 1),
        },
        endColor: {
          value: new je(0.03, 0.37, 0.75, 1),
        },
      },
    }),
      this.setValues(t),
      (this.type = "MeshLineMaterial");
  }
  copyMaterial(t) {
    const e = this.copy(t);
    return (
      (e.lineWidth = t.lineWidth),
      (e.map = t.map),
      (e.useMap = t.useMap),
      (e.alphaMap = t.alphaMap),
      (e.useAlphaMap = t.useAlphaMap),
      e.color.copy(t.color),
      (e.opacity = t.opacity),
      e.resolution.copy(t.resolution),
      (e.sizeAttenuation = t.sizeAttenuation),
      (e.dashArray = t.dashArray),
      (e.dashOffset = t.dashOffset),
      (e.dashRatio = t.dashRatio),
      (e.useDash = t.useDash),
      (e.visibility = t.visibility),
      (e.alphaTest = t.alphaTest),
      e.repeat.copy(t.repeat),
      e
    );
  }
  get lineWidth() {
    return this.uniforms.lineWidth.value;
  }
  set lineWidth(t) {
    this.uniforms.lineWidth.value = t;
  }
  get map() {
    return this.uniforms.map.value;
  }
  set map(t) {
    this.uniforms.map.value = t;
  }
  get useMap() {
    return this.uniforms.useMap.value;
  }
  set useMap(t) {
    this.uniforms.useMap.value = t;
  }
  get alphaMap() {
    return this.uniforms.alphaMap.value;
  }
  set alphaMap(t) {
    this.uniforms.alphaMap.value = t;
  }
  get useAlphaMap() {
    return this.uniforms.useAlphaMap.value;
  }
  set useAlphaMap(t) {
    this.uniforms.useAlphaMap.value = t;
  }
  get color() {
    return this.uniforms.color.value;
  }
  set color(t) {
    this.uniforms.color.value = t;
  }
  get lineOpacity() {
    return this.uniforms.opacity.value;
  }
  set lineOpacity(t) {
    this.uniforms.opacity.value = t;
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  get sizeAttenuation() {
    return this.uniforms.sizeAttenuation.value;
  }
  set sizeAttenuation(t) {
    this.uniforms.sizeAttenuation.value = t;
  }
  get dashArray() {
    return this.uniforms.dashArray.value;
  }
  set dashArray(t) {
    (this.uniforms.dashArray.value = t), (this.useDash = 0 !== t ? 1 : 0);
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  get dashRatio() {
    return this.uniforms.dashRatio.value;
  }
  set dashRatio(t) {
    this.uniforms.dashRatio.value = t;
  }
  get useDash() {
    return this.uniforms.useDash.value;
  }
  set useDash(t) {
    this.uniforms.useDash.value = t;
  }
  get visibility() {
    return this.uniforms.visibility.value;
  }
  set visibility(t) {
    this.uniforms.visibility.value = t;
  }
  get lineAlphaTest() {
    return this.uniforms.alphaTest.value;
  }
  set lineAlphaTest(t) {
    this.uniforms.alphaTest.value = t;
  }
  get repeat() {
    return this.uniforms.repeat.value;
  }
  set repeat(t) {
    this.uniforms.repeat.value.copy(t);
  }
}
const Oq = {
  NoBlending: 1,
  AdditiveBlending: 2,
};
class Fq extends Iq {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.extensions = {}),
      (this.pureData = []),
      this._initialState(),
      this._initLayerGroup();
    const { breathPointLayer: i, common: n } = this.state;
    (this.extensions.breathPointLayer = new Dq(
      this.gis,
      ot(rt({}, i), {
        common: {
          visible: !!n.visible && i.common.visible,
        },
        __pureData__: !0,
      }),
      !0
    )),
      this.animation.start(),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(WW);
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "fly-line-layer",
      layerType: "line",
    });
  }
  updateArea() {
    super.updateArea();
    const { globalOpts: t } = this.gis,
      { data: e } = this.state,
      { baseHeight: i } = t.bboxOption;
    this.clear(), this.add(e), this.coreGroup.position.setZ(i);
  }
  _getParseData(t) {
    const { fields: e } = this.state,
      { fromField: i, toField: n } = e;
    return super._getParseData(
      ot(rt({}, t), {
        layerType: "FlyLine",
        coordsField: {
          fromField: i,
          toField: n,
        },
      })
    );
  }
  _getScaleData() {
    const { style: t, fields: e } = this.state,
      { fill: i } = t,
      { fromColor: n, toColor: r } = i,
      o = [
        {
          visual: n,
          scaleField: e.fromColorField,
          dataField: "_fromColor_",
        },
        {
          visual: r,
          scaleField: e.toColorField,
          dataField: "_toColor_",
        },
      ];
    return super._getScaleData(o);
  }
  _getRenderData() {
    const { style: t, scaleData: e } = this.state,
      { layout: i } = t;
    let n = null;
    return (
      (n =
        "BezierCurve3" === i
          ? Lq(e, {
              height: this._mapSize(80, "z"),
            })
          : ((t, e) => {
              if (0 === t.length) return t;
              const i = {},
                n = [];
              t.forEach((t, e) => {
                const { coordinates: r } = t;
                0 === e
                  ? (i[e] = {
                      x: r[0][0],
                      y: r[0][1],
                    })
                  : ((i[e] = {
                      x: r[1][0],
                      y: r[1][1],
                    }),
                    n.push({
                      source: e,
                      target: "0",
                    }));
              });
              const r = xW().step_size(50).nodes(i).edges(n)(),
                o = [];
              for (let a = 1; a < r.length; a++) {
                const t = r[a].map((t) => [t.x, t.y, 0]);
                o.push(t);
              }
              return o;
            })(e)),
      (this.state.renderData =
        "BezierCurve3" === i ? n : this.__dataAdapter(n)),
      this
    );
  }
  add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e),
      mf(
        this._getParseData.bind(this),
        this._getScaleData.bind(this),
        this._getRenderData.bind(this),
        this.__draw.bind(this)
      )({
        rawData: e,
      });
    const { parseData: i } = this.state,
      n = [],
      r = {};
    return (
      i.forEach((t) => {
        this.__addBreathData(r, t, n);
      }),
      this.extensions.breathPointLayer.set({
        data: n,
      }),
      this
    );
  }
  __addBreathData(t, e, i) {
    const n = e.coordinates[0].join("-"),
      r = e.coordinates[1].join("-");
    t[n] ||
      i.push(
        ot(rt({}, e), {
          type: "from",
          coordinates: e.coordinates[0],
        })
      ),
      t[r] ||
        i.push(
          ot(rt({}, e), {
            type: "to",
            coordinates: e.coordinates[1],
          })
        ),
      (t[n] = !0),
      (t[r] = !0);
  }
  __dataAdapter(t) {
    const { scaleData: e } = this.state,
      i = [],
      n = [],
      r = [];
    return (
      t.forEach((t, o) => {
        t.forEach((t) => {
          i.push(new Ye(t[0], t[1], t[2]));
        }),
          i.push(new Ye(-1, -1, -1));
        const { _fromColor_: a, _toColor_: s } = e[o],
          { color: l, opacity: u } = EA(a),
          { color: c, opacity: h } = EA(s);
        n.push(l.r, l.g, l.b, u), r.push(c.r, c.g, c.b, h);
      }),
      {
        position: i,
        fromColor: n,
        toColor: r,
      }
    );
  }
  __draw() {
    const { renderData: t, scaleData: e } = this.state;
    if (!t || 0 === e.length) return;
    const i = e.length,
      {
        style: { blend: n, width: r },
        animation: o,
      } = this.state,
      a = new Nq();
    a.setPoints(t, i);
    const s = new Rq({
      transparent: !0,
      lineWidth: this._mapSize(r, "xy"),
      dashArray: 0.3,
      dashRatio: 0.2,
      dashOffset: 0,
      blending: Oq[n],
    });
    if (((s.defines.USE_ANIMATION = o.enabled), this.instancedMesh)) {
      for (let l = 0; l < this.coreGroup.children.length; l++)
        if (this.coreGroup.children[l].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new Wn(a.geometry, s)),
            this.coreGroup.remove(this.coreGroup.children[l]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new Wn(a.geometry, s)),
        this.coreGroup.add(this.instancedMesh);
    this.instancedMesh.setRenderIndex(lU.FLY_LINE_LAYER);
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove(),
      this.extensions.breathPointLayer &&
        (this.extensions.breathPointLayer.remove(),
        (this.extensions.breathPointLayer = null));
  }
  _clearData() {
    super._clearData(), (this.pureData = []);
  }
  clear() {
    var t;
    super.clear(),
      (this.instancedMesh = null),
      null == (t = this.extensions.breathPointLayer) || t.clear();
  }
  handleAnimation(t) {
    const { animation: e } = this.state,
      { enabled: i, speed: n } = e;
    if (i && this.coreGroup.children[0]) {
      const { material: t } = this.coreGroup.children[0],
        { uniforms: e } = t;
      e.dashOffset.value -= 0.01 * n;
    }
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule("breathPointLayer", "diffDeep", (t, e) => {
          this.extensions.breathPointLayer.set({
            common: {
              visible:
                !!this.state.common.visible &&
                this.state.breathPointLayer.common.visible,
            },
            speed: this.state.breathPointLayer.speed,
            size: this.state.breathPointLayer.size,
          });
        }),
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "fill"],
            ["style", "width"],
            ["style", "layout"],
            ["style", "blend"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          }
        ),
      ]);
  }
}
const zq = {
  common: Sk,
  fields: OW,
  data: [],
  style: {
    fill: {
      color: {
        type: $U.CONSTANT,
        linear: {
          domain: [],
          range: ["rgba(189,245,255,0.2)", "rgba(189,245,255,0.5)"],
          clamp: !1,
        },
        threshold: {
          domain: [],
          range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
        },
        ordinal: {
          domain: [],
          range: FW.light.arcoblue,
          unknown: "undefined",
        },
        constant: FW.light.arcoblue[1],
        default: FW.light.arcoblue[1],
      },
      map: {
        type: $U.CONSTANT,
        threshold: {
          domain: [],
          range: [],
        },
        ordinal: {
          domain: [],
          range: [],
        },
        constant: "",
        default: "",
      },
      mapAspect: {
        type: $U.CONSTANT,
        threshold: {
          domain: [],
          range: [],
        },
        ordinal: {
          domain: [],
          range: [],
        },
        constant: 1,
        default: 1,
      },
    },
    width: {
      type: $U.LINEAR,
      linear: {
        domain: null,
        range: [20, 120],
        clamp: !1,
      },
      threshold: {
        domain: null,
        range: [20, 120],
      },
      ordinal: {
        domain: null,
        range: [20, 120],
      },
      constant: 20,
      default: 20,
    },
  },
  animation: {
    enabled: !0,
    speed: 1,
  },
  lineJoin: "miter",
  usePixel: !1,
  clipMode: Qw.intersect,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
atob("Ynl0ZXRvcy5jb20=");
class kq extends En {
  constructor() {
    super(), (this.itemSize = 28), this.rotateX(Math.PI / 2);
  }
  addLine(t, e = "miter") {
    switch (
      ((t = (function (t) {
        let e = [NaN, NaN];
        const i = [];
        return (
          t.forEach((t) => {
            (t[0] === e[0] && t[1] === e[1]) || (i.push(t), (e = t));
          }),
          i
        );
      })(t)),
      e)
    ) {
      case "bevel":
        this.__addLineWithBevel(t);
        break;
      case "round":
        this.__addLineWithRound(t);
        break;
      default:
        this.__addLineWithMiter(t);
    }
    return this;
  }
  __addLineWithMiter(t) {
    let e = 0,
      i = e;
    const n = new Ye(0, 0, 0),
      r = new Ye(0, 0, 0),
      o = new Ye(0, 0, 0),
      a = new Ye(1, 1, 1),
      s = new Ye(1, 1, 1),
      l = new Ye(),
      u = new Ye(),
      c = new Ye();
    let h = 0;
    const p = new Ye(0, 0, -1),
      d = new Ye(0, 0, 0),
      f = new Ye(),
      g = new Ye(),
      m = new Ye(),
      y = 2 * (t.length - 1),
      v = new Gq(3 * y);
    for (let b = 0, x = t.length; b < x - 1; b++) {
      const y = t[b],
        x = t[b + 1],
        _ = t[b + 2];
      if (0 === b)
        if (t.length >= 3) {
          const t = y[0],
            e = y[1],
            i = x[0],
            l = x[1],
            u = _[0],
            c = _[1];
          n.set(t, e, 0),
            r.set(i, l, 0),
            o.set(u, c, 0),
            g.copy(r).sub(n).normalize(),
            f.copy(g),
            m.copy(o).sub(r).normalize(),
            a.copy(r).sub(n).cross(p).normalize(),
            s.copy(a).negate();
        } else {
          const t = y[0],
            e = y[1],
            i = x[0],
            o = x[1];
          n.set(t, e, 0),
            r.set(i, o, 0),
            g.copy(r).sub(n).normalize(),
            f.copy(g),
            m.copy(g),
            a.copy(r).sub(n).cross(p).normalize(),
            s.copy(a).negate();
        }
      else if (b == t.length - 2)
        n.copy(r), r.copy(o), f.copy(g), g.copy(m), a.copy(l), s.copy(u);
      else {
        const t = _[0],
          e = _[1];
        n.copy(r),
          r.copy(o),
          o.set(t, e, 0),
          f.copy(g),
          g.copy(m),
          m.copy(o).sub(r).normalize(),
          a.copy(l),
          s.copy(u);
      }
      g.clone().add(m).equals(d)
        ? (l.copy(m).cross(p).normalize(), u.copy(l).negate())
        : (l.copy(m).add(g).cross(p).normalize(), u.copy(l).negate()),
        (h =
          0 === b
            ? Math.abs(c.copy(m).cross(p).normalize().dot(l))
            : b == t.length - 2
            ? 1
            : Math.abs(c.copy(m).cross(p).normalize().dot(l))),
        l.divideScalar(h),
        u.divideScalar(h);
      (i += r.distanceTo(n)),
        v.emplaceBack(n.toArray(), a.toArray(), g.toArray(), 1, e),
        v.emplaceBack(n.toArray(), s.toArray(), g.toArray(), 0, e),
        v.emplaceBack(r.toArray(), l.toArray(), g.toArray(), 1, i),
        v.emplaceBack(r.toArray(), l.toArray(), g.toArray(), 1, i),
        v.emplaceBack(n.toArray(), s.toArray(), g.toArray(), 0, e),
        v.emplaceBack(r.toArray(), u.toArray(), g.toArray(), 0, i),
        (e = i);
    }
    return (
      this.setAttribute("position", new bn(v.positions.float32, 3)),
      this.setAttribute("normal", new bn(v.normals.float32, 3)),
      this.setAttribute("aDir", new bn(v.dirs.float32, 3)),
      this.setAttribute("aDistance", new bn(v.distances.float32, 1)),
      this.setAttribute("aUVy", new bn(v.uvys.float32, 1)),
      this
    );
  }
  __addLineWithBevel(t) {
    let e = 0,
      i = e;
    const n = 3 * (t.length - 1) - 1,
      r = new Ye(0, 0, 0),
      o = new Ye(0, 0, 0),
      a = new Ye(0, 0, 0),
      s = new Ye(),
      l = new Ye(),
      u = new Ye(),
      c = new Ye(),
      h = new Ye(),
      p = new Ye(),
      d = new Ye(),
      f = new Ye(),
      g = new Ye(),
      m = new Ye(),
      y = new Ye(),
      v = new Ye(),
      b = new Ye();
    let x = 0;
    const _ = new Ye(0, 0, -1),
      S = new Ye(0, 0, 0),
      M = new Ye(),
      C = new Ye(),
      w = new Ye(),
      A = new Gq(3 * n);
    for (let E = 0, D = t.length; E < D - 1; E++) {
      const n = t[E],
        D = t[E + 1],
        T = t[E + 2];
      if (0 === E)
        if (t.length >= 3) {
          const t = n[0],
            e = n[1],
            i = D[0],
            u = D[1],
            c = T[0],
            d = T[1];
          r.set(t, e, 0),
            o.set(i, u, 0),
            a.set(c, d, 0),
            C.copy(o).sub(r).normalize(),
            M.copy(C),
            w.copy(a).sub(o).normalize(),
            h.copy(C).cross(_),
            p.copy(h).negate(),
            s.copy(h),
            l.copy(s).negate();
        } else {
          const t = n[0],
            e = n[1],
            i = D[0],
            a = D[1];
          r.set(t, e, 0),
            o.set(i, a, 0),
            C.copy(o).sub(r).normalize(),
            M.copy(C),
            w.copy(C),
            h.copy(C).cross(_),
            p.copy(h).negate(),
            s.copy(h),
            l.copy(s).negate();
        }
      else if (E == t.length - 2)
        r.copy(o),
          o.copy(a),
          M.copy(C),
          C.copy(w),
          h.copy(m),
          p.copy(y),
          s.copy(u),
          l.copy(s).negate();
      else {
        const t = T[0],
          e = T[1];
        r.copy(o),
          o.copy(a),
          a.set(t, e, 0),
          M.copy(C),
          C.copy(w),
          w.copy(a).sub(o).normalize(),
          h.copy(m),
          p.copy(y),
          s.copy(u),
          l.copy(c);
      }
      C.clone().add(w).equals(S)
        ? (d.copy(w).cross(_).normalize(), u.copy(d), c.copy(u).negate())
        : (d.copy(w).cross(_).normalize(),
          u.copy(w).add(C).cross(_).normalize(),
          c.copy(u).negate()),
        (x =
          0 === E
            ? v.copy(d).normalize().dot(u)
            : E == t.length - 2
            ? 1
            : v.copy(d).normalize().dot(u)),
        u.divideScalar(x),
        c.divideScalar(x),
        b.copy(d).cross(h),
        b.z > 0 ? m.copy(d) : m.copy(u),
        b.z >= 0 ? y.copy(u).negate() : y.copy(d).negate(),
        b.z > 0 ? f.copy(C).cross(_) : f.copy(u),
        b.z >= 0 ? g.copy(u).negate() : g.copy(C).cross(_).negate();
      (i += o.distanceTo(r)),
        A.emplaceBack(r.toArray(), h.toArray(), C.toArray(), 1, e),
        A.emplaceBack(r.toArray(), p.toArray(), C.toArray(), 0, e),
        A.emplaceBack(o.toArray(), f.toArray(), C.toArray(), 1, i),
        A.emplaceBack(o.toArray(), f.toArray(), C.toArray(), 1, i),
        A.emplaceBack(r.toArray(), p.toArray(), C.toArray(), 0, e),
        A.emplaceBack(o.toArray(), g.toArray(), C.toArray(), 0, i),
        E < t.length - 2 &&
          (b.z >= 0
            ? (A.emplaceBack(o.toArray(), f.toArray(), C.toArray(), 1, i),
              A.emplaceBack(o.toArray(), g.toArray(), C.toArray(), 0, i),
              A.emplaceBack(o.toArray(), m.toArray(), C.toArray(), 1, i))
            : (A.emplaceBack(o.toArray(), f.toArray(), C.toArray(), 1, i),
              A.emplaceBack(o.toArray(), g.toArray(), C.toArray(), 0, i),
              A.emplaceBack(o.toArray(), y.toArray(), C.toArray(), 0, i))),
        (e = i);
    }
    return (
      this.setAttribute("position", new bn(A.positions.float32, 3)),
      this.setAttribute("normal", new bn(A.normals.float32, 3)),
      this.setAttribute("aDir", new bn(A.dirs.float32, 3)),
      this.setAttribute("aDistance", new bn(A.distances.float32, 1)),
      this.setAttribute("aUVy", new bn(A.uvys.float32, 1)),
      this.setDrawRange(0, 3 * A.currentIndex),
      this
    );
  }
  __addLineWithRound(t) {
    let e = 0,
      i = e;
    const n = 3 * (t.length - 1) - 1,
      r = new Ye(0, 0, 0),
      o = new Ye(0, 0, 0),
      a = new Ye(0, 0, 0),
      s = new Ye(),
      l = new Ye(),
      u = new Ye(),
      c = new Ye(),
      h = new Ye(),
      p = new Ye(),
      d = new Ye(),
      f = new Ye(),
      g = new Ye(),
      m = new Ye(),
      y = new Ye(),
      v = new Ye(),
      b = new Ye();
    let x = 0,
      _ = 0;
    const S = new Ye(0, 0, -1),
      M = new Ye(0, 0, 0),
      C = new Ye(),
      w = new Ye(),
      A = new Ye(),
      E = new Gq(3 * n);
    for (let D = 0, T = t.length; D < T - 1; D++) {
      const n = t[D],
        T = t[D + 1],
        P = t[D + 2];
      if (0 === D)
        if (t.length >= 3) {
          const t = n[0],
            e = n[1],
            i = T[0],
            u = T[1],
            c = P[0],
            d = P[1];
          r.set(t, e, 0),
            o.set(i, u, 0),
            a.set(c, d, 0),
            w.copy(o).sub(r).normalize(),
            C.copy(w),
            A.copy(a).sub(o).normalize(),
            h.copy(w).cross(S),
            p.copy(h).negate(),
            s.copy(h),
            l.copy(s).negate();
        } else {
          const t = n[0],
            e = n[1],
            i = T[0],
            a = T[1];
          r.set(t, e, 0),
            o.set(i, a, 0),
            w.copy(o).sub(r).normalize(),
            C.copy(w),
            A.copy(w),
            h.copy(w).cross(S),
            p.copy(h).negate(),
            s.copy(h),
            l.copy(s).negate();
        }
      else if (D == t.length - 2)
        r.copy(o),
          o.copy(a),
          C.copy(w),
          w.copy(A),
          h.copy(m),
          p.copy(y),
          s.copy(u),
          l.copy(s).negate();
      else {
        const t = P[0],
          e = P[1];
        r.copy(o),
          o.copy(a),
          a.set(t, e, 0),
          C.copy(w),
          w.copy(A),
          A.copy(a).sub(o).normalize(),
          h.copy(m),
          p.copy(y),
          s.copy(u),
          l.copy(c);
      }
      w.clone().add(A).equals(M)
        ? (d.copy(A).cross(S).normalize(), u.copy(d), c.copy(u).negate())
        : (d.copy(A).cross(S).normalize(),
          u.copy(A).add(w).cross(S).normalize(),
          c.copy(u).negate()),
        D == t.length - 2
          ? ((x = 1), (_ = 1))
          : ((x = v.copy(d).normalize().dot(u)), (_ = v.copy(A).dot(w))),
        u.divideScalar(x),
        c.divideScalar(x),
        b.copy(d).cross(h),
        b.z > 0 ? m.copy(d) : m.copy(u),
        b.z >= 0 ? y.copy(u).negate() : y.copy(d).negate(),
        b.z > 0 ? f.copy(w).cross(S) : f.copy(u),
        b.z >= 0 ? g.copy(u).negate() : g.copy(w).cross(S).negate();
      const L = o.distanceTo(r);
      (i += L),
        E.emplaceBack(r.toArray(), h.toArray(), w.toArray(), 1, e),
        E.emplaceBack(r.toArray(), p.toArray(), w.toArray(), 0, e),
        E.emplaceBack(o.toArray(), f.toArray(), w.toArray(), 1, i),
        E.emplaceBack(o.toArray(), f.toArray(), w.toArray(), 1, i),
        E.emplaceBack(r.toArray(), p.toArray(), w.toArray(), 0, e),
        E.emplaceBack(o.toArray(), g.toArray(), w.toArray(), 0, i),
        D < t.length - 2 &&
          (b.z >= 0
            ? Vq(f, m, x, _, (t, e) => {
                E.emplaceBack(o.toArray(), t.toArray(), w.toArray(), 1, i),
                  E.emplaceBack(o.toArray(), g.toArray(), w.toArray(), 0, i),
                  E.emplaceBack(o.toArray(), e.toArray(), w.toArray(), 1, i);
              })
            : Vq(g, y, x, _, (t, e) => {
                E.emplaceBack(o.toArray(), t.toArray(), w.toArray(), 0, i),
                  E.emplaceBack(o.toArray(), f.toArray(), w.toArray(), 1, i),
                  E.emplaceBack(o.toArray(), e.toArray(), w.toArray(), 0, i);
              })),
        (e = i);
    }
    return (
      E.trim(),
      this.setAttribute("position", new bn(E.positions.float32, 3)),
      this.setAttribute("normal", new bn(E.normals.float32, 3)),
      this.setAttribute("aDir", new bn(E.dirs.float32, 3)),
      this.setAttribute("aDistance", new bn(E.distances.float32, 1)),
      this.setAttribute("aUVy", new bn(E.uvys.float32, 1)),
      this.setDrawRange(0, 3 * E.currentIndex),
      this
    );
  }
}
class Bq extends Jn {
  constructor() {
    super({
      uniforms: {
        uOffset: {
          type: "float",
          value: 0,
        },
        uIcon: {
          type: "sampler2D",
          value: null,
        },
        uIconIndex: {
          type: "float",
          value: 0,
        },
        iconAspect: {
          type: "float",
          value: 1,
        },
        uColor: {
          type: "vec4",
          value: [0, 0, 0, 0],
        },
        uWidth: {
          type: "float",
          value: 5,
        },
        uResolution: {
          type: "float",
          value: 1,
        },
        uTransparentImages: {
          value: new Int8Array(64).fill(0),
        },
      },
      vertexShader:
        "attribute float aDistance;\nattribute vec3 aDir;\nattribute float aUVy;\n\nuniform float uWidth;\nuniform float uResolution;\n\nvarying float vDistance;\n\n#ifdef USE_ICON\nvarying float vUV;\n#endif\nvoid main() {\n  float halfWith = uWidth / 2.;\n  #ifdef USE_ICON\n  vUV = aUVy;\n  #endif\n  vec3 uOffset = normal * halfWith * uResolution;\n  float cosHalfAngle = dot(aDir, normal);\n  vDistance = aDistance / uResolution + (cosHalfAngle * halfWith);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position + uOffset, 1.);\n}",
      fragmentShader:
        "precision highp float;\nuniform float uOffset;\nuniform float uWidth;\nuniform float uIconIndex;\nuniform float iconAspect;\nuniform bool[MAX_ICON_ROW * MAX_ICON_ROW] uTransparentImages;\n\n#ifdef USE_ICON\nuniform sampler2D uIcon;\nvarying float vUV;\n#endif\nuniform vec4 uColor;\nvarying float vDistance;\n\nfloat between(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0., 1.);\n}\nvec2 mixIconCoord(vec2 v) {\n  float step = 1. / float(MAX_SPRITE_SIZE);\n  \n  float maxIconCount = float(MAX_ICON_ROW);\n  float y = floor(uIconIndex / maxIconCount);\n  float x = mod(uIconIndex, maxIconCount);\n  return vec2(mix(between(0., maxIconCount, x) + step, between(0., maxIconCount, x + 1.) - step, v.x), mix(between(0., maxIconCount, y) + step, between(0., maxIconCount, y + 1.) - step, v.y));\n}\n\nvoid main(void) {\n  vec4 finalColor = vec4(1.0, 0.0, 0.0, 0.0);\n\n  #ifdef USE_ICON\n\n  \n  \n  \n  \n  \n\n  bool transparent = uTransparentImages[int(uIconIndex)];\n\n  \n  vec2 coord = mixIconCoord(vec2(mod((vDistance - uOffset) / uWidth / iconAspect, 1.), vUV));\n  vec4 iconColor = texture2D(uIcon, coord);\n\n  if(!transparent) {\n    finalColor = iconColor;\n  } else if(iconColor.a == 1.) {\n    finalColor = iconColor;\n  } else if(uColor.a == 0.) {\n    finalColor = iconColor;\n  } else {\n    finalColor = vec4(uColor.rgb, iconColor.a);\n  }\n\n  gl_FragColor = finalColor;\n  #endif\n\n  #ifndef USE_ICON\n  gl_FragColor = uColor;\n  #endif\n}",
      side: xt,
      transparent: !0,
      defines: {
        MAX_ICON_ROW: 8,
        MAX_SPRITE_SIZE: bq,
      },
      depthTest: !1,
    });
  }
  set map(t) {
    (this.needsUpdate = !0),
      cf(t)
        ? ((this.defines.USE_ICON = !0), (this.uniforms.uIcon.value = t))
        : delete this.defines.USE_ICON;
  }
}
class Gq {
  constructor(t) {
    (this.currentIndex = 0),
      (this.positions = new jq(t)),
      (this.normals = new jq(t)),
      (this.distances = new Hq(t)),
      (this.uvys = new Hq(t)),
      (this.dirs = new jq(t));
  }
  emplaceBack(t, e, i, n, r) {
    this.positions.emplaceBackWithArray(t),
      this.normals.emplaceBackWithArray(e),
      this.dirs.emplaceBackWithArray(i),
      this.distances.emplaceBack(r),
      this.uvys.emplaceBack(n),
      (this.currentIndex += 1);
  }
  trim() {
    this.positions.trim(),
      this.normals.trim(),
      this.distances.trim(),
      this.uvys.trim(),
      this.dirs.trim();
  }
}
class Uq {
  constructor() {
    (this.length = 0), (this.capacity = -1);
  }
  resize(t) {
    this.reserve(t);
  }
  reserve(t) {
    if (t > this.capacity) {
      (this.capacity = Math.max(t, Math.floor(2 * this.capacity))),
        (this.arrayBuffer = new ArrayBuffer(
          this.capacity * this.bytesPerElement
        ));
      const e = this.uint8;
      this._refreshViews(), e && this.uint8.set(e);
    }
  }
  trim() {
    this.length !== this.capacity &&
      ((this.capacity = this.length),
      (this.arrayBuffer = this.arrayBuffer.slice(
        0,
        this.length * this.bytesPerElement
      )),
      this._refreshViews());
  }
}
class jq extends Uq {
  constructor(t = 256) {
    super(), (this.bytesPerElement = 12), this.resize(t);
  }
  emplaceBack(t, e, i) {
    const n = this.length;
    this.resize(n + 1), this.emplace(n, t, e, i), (this.length += 1);
  }
  emplaceBackWithArray(t) {
    const e = this.length;
    this.resize(e + 1), this.emplace(e, t[0], t[1], t[2]), (this.length += 1);
  }
  emplace(t, e, i, n) {
    const r = 3 * t;
    return (
      (this.float32[r + 0] = e),
      (this.float32[r + 1] = i),
      (this.float32[r + 2] = n),
      t
    );
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.float32 = new Float32Array(this.arrayBuffer));
  }
}
class Hq extends Uq {
  constructor(t = 256) {
    super(), (this.bytesPerElement = 4), this.resize(t);
  }
  emplaceBack(t) {
    const e = this.length;
    this.resize(e + 1), this.emplace(e, t), (this.length += 1);
  }
  emplace(t, e) {
    const i = t;
    return (this.float32[i + 0] = e), t;
  }
  _refreshViews() {
    (this.uint8 = new Uint8Array(this.arrayBuffer)),
      (this.float32 = new Float32Array(this.arrayBuffer));
  }
}
function Vq(t, e, i, n, r) {
  const o = 2 * Math.sqrt(2 - 2 * i),
    a = Math.round((180 * o) / Math.PI / 20),
    s = new Ye(),
    l = new Ye(),
    u = t.length();
  s.copy(t);
  for (let c = 1; c <= a; c++) {
    let i = c / a;
    if (0.5 !== i) {
      const t = i - 0.5;
      i +=
        i *
        t *
        (i - 1) *
        ((1.0904 + n * (n * (3.55645 - 1.43519 * n) - 3.2452)) * t * t +
          (0.848013 + n * (0.215638 * n - 1.06021)));
    }
    l.copy(e).sub(t).multiplyScalar(i).add(t).normalize().multiplyScalar(u),
      r(s, l),
      s.copy(l);
  }
}
var Wq = Object.defineProperty,
  qq = Object.getOwnPropertyDescriptor,
  Yq = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? qq(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && Wq(e, i, o), o;
  };
class Xq extends Iq {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.__sprites = new _q()),
      this._initialState(),
      this._initLayerGroup(),
      this.__handleZoomChange(),
      (this.__sprites.minFilter = Vt),
      (this.__sprites.generateMipmaps = !1),
      super.registerInteraction(this.state.interaction, this.coreGroup, !0),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(zq);
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "straight-line-layer",
      layerType: "line",
    });
  }
  updateArea() {
    super.updateArea();
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e);
    const i = this.__getParseData(e),
      n = this.__getScaleData(i);
    this.state.scaleData.push(...n);
    for (let r = 0; r < n.length; r++) {
      const t = n[r];
      this.__add(t);
    }
    return this.__updateMaterial(), this.__handleZoomChange(), this;
  }
  __getScaleData(t) {
    const { fields: e, style: i } = this.state,
      {
        fill: { color: n, map: r, mapAspect: o },
        width: a,
      } = i;
    return this.scaleService.apply(
      [
        {
          visual: n,
          scaleField: e.colorField,
          dataField: "_color_",
        },
        {
          visual: a,
          scaleField: e.widthField,
          dataField: "_width_",
        },
        {
          visual: r,
          scaleField: e.mapField,
          dataField: "_map_",
        },
        {
          visual: o,
          scaleField: e.mapField,
          dataField: "_mapAspect_",
        },
      ],
      t
    );
  }
  __getParseData(t) {
    this.state;
    const { clipMode: e } = this.state,
      { globalOpts: i } = this.gis,
      { boundary: n } = i,
      r = Yw(t[0]) ? "geojson" : "bytejson",
      o = !(!e || e === Qw.none),
      a = "Line";
    return this.dataView
      .parse(t, {
        type: r,
        options: {
          layerType: a,
          coordsField: {
            coordinatesField: "coordinates",
          },
        },
      })
      .transform({
        type: "filter",
        options: {
          callback: o && ((t) => Kw(t, n.features[0], e, a)),
        },
      })
      .transform({
        type: "webgis",
        options: {
          as: "coordinates",
        },
      }).latestData;
  }
  __add(t) {
    this.__addLine(t);
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  __addLine(t) {
    const { geometry: e, _width_: i } = t;
    if ("MultiLineString" === e.type) this.__addRing(e.coordinates[0], i);
    else this.__addRing(e.coordinates, i);
  }
  __addRing(t, e) {
    this.state;
    const i = [];
    t.map((t) => {
      i.push([1 * t[0], 1 * t[1], 0]);
    });
    const n = new kq().addLine(i, this.state.lineJoin),
      r = new Wn(n, new Bq());
    r.setRenderIndex(lU.PATH_LAYER_DIR), this.coreGroup.add(r);
  }
  handleAnimation(t) {
    const e = t.deltaTime * this.state.animation.speed * 10;
    this.coreGroup.children.forEach((t) => {
      t.material.uniforms.uOffset.value += e;
    });
  }
  __handleZoomChange() {
    const t = this.gis.controlsSystem.getCameraResolution(),
      { usePixel: e } = this.state;
    this.coreGroup.children.forEach((i) => {
      i.material.uniforms.uResolution.value = e ? t : 1;
    });
  }
  __updateMaterial() {
    this.__updateUniforms(), this.__getImagesFromMapConfig();
  }
  __refreshData() {
    const t = this.state.data;
    this.clear(), this.add(t);
  }
  __updateUniforms() {
    const { usePixel: t } = this.state;
    this.state.scaleData.forEach((e, i) => {
      const n = e._width_,
        r = e._color_,
        o = e._mapAspect_,
        a = EA(r),
        s = new je(a.color.r, a.color.g, a.color.b, DA(a, 1)),
        l = i,
        u = this.coreGroup.children[l];
      u &&
        ((u.material.uniforms.uColor.value = s),
        (u.material.uniforms.uWidth.value = t
          ? n
          : this._mapSize(n, "straightline")),
        (u.material.uniforms.iconAspect.value = o));
    });
  }
  async __getImagesFromMapConfig() {
    const t = _q.getImagesFromVisualConfig(this.state.style.fill.map);
    await this.__sprites.update(t),
      0 === this.__sprites.getIconCount()
        ? this.coreGroup.children.forEach((t) => {
            "MeshBasicMaterial" !== t.material.type &&
              ((t.material.map = null),
              (t.material.uniforms.uTransparentImages.value =
                this.__sprites.transparentImages),
              (t.material.needsUpdate = !0));
          })
        : (this.coreGroup.children.forEach((t) => {
            "MeshBasicMaterial" !== t.material.type &&
              ((t.material.map = this.__sprites),
              (t.material.uniforms.uTransparentImages.value =
                this.__sprites.transparentImages),
              (t.material.needsUpdate = !0));
          }),
          this.__calcIconIndex());
  }
  __calcIconIndex() {
    this.state.scaleData.forEach((t, e) => {
      const i = t._map_,
        n = this.__sprites.getIconIndex(i),
        r = e,
        o = this.coreGroup.children[r];
      o &&
        "MeshBasicMaterial" !== o.material.type &&
        ((o.material.uniforms.uIconIndex.value = n),
        (o.material.needsUpdate = !0));
    });
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule("", "always", () => {
          const { animation: t } = this.state;
          t.enabled ? this.animation.start() : this.animation.pause();
        }),
        this._propsWatch.defaultRule(
          ["data", "lineJoin", "style"],
          "diffAnyoneDeep",
          (t) => {
            this.__refreshData();
          }
        ),
      ]);
  }
  clear() {
    return super.clear(), this;
  }
}
Yq([aV("viewportChange"), lq], Xq.prototype, "__handleZoomChange", 1),
  Yq([lq], Xq.prototype, "__updateMaterial", 1),
  Yq([lq], Xq.prototype, "__refreshData", 1);
const Qq = {
    common: Sk,
    fields: OW,
    style: {
      fill: {
        color: {
          type: $U.LINEAR,
          linear: {
            domain: [],
            range: ["rgba(189,245,255,0.2)", "rgba(189,245,255,0.5)"],
            clamp: !1,
          },
          threshold: {
            domain: [],
            range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
          },
          ordinal: {
            domain: [],
            range: FW.light.arcoblue,
            unknown: "undefined",
          },
          constant: FW.light.arcoblue[1],
          default: "rgba(255,255,255,0)",
        },
        map: {
          type: $U.CONSTANT,
          threshold: {
            domain: [],
            range: [],
          },
          ordinal: {
            domain: [],
            range: [],
          },
          constant: `https://lf3-dpfe.${atob(
            "Ynl0ZXRvcy5jb20="
          )}/obj/gis/images/bubble.png`,
          default: "",
        },
      },
      size: {
        type: $U.LINEAR,
        linear: {
          domain: null,
          range: [40, 120],
          clamp: !1,
        },
        threshold: {
          domain: null,
          range: [40, 120],
        },
        ordinal: {
          domain: null,
          range: [40, 120],
        },
        constant: 40,
        default: 40,
      },
      stroke: {
        enabled: !1,
        width: 0.2,
        style: "solid",
        color: "rgba(0,0,255,1)",
      },
      segments: 30,
      usePixel: !1,
    },
    poi: {
      enabled: !1,
      hideOnMove: !1,
      alignment: "middle",
      offsetX: 0,
      offsetY: 0,
      coverEnable: !1,
      orient: "vertical",
      major: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      minor: {
        enabled: !0,
        color: fk,
        fontSize: pk,
        fontWeight: dk,
        format: null,
        offsetX: 0,
        offsetY: 0,
      },
      custom: {
        enabled: !1,
        markerType: "css2d",
        element: null,
      },
    },
    animation: {
      opacity: {
        enabled: !1,
        min: 0.2,
        max: 1,
        speed: 0.3,
        yoyo: !0,
      },
      scale: {
        enabled: !0,
        min: 0.5,
        max: 1,
        speed: 0.2,
        yoyo: !0,
      },
    },
  },
  Zq = af(Qq, {
    data: [],
    clipMode: Qw.intersect,
    interaction: {
      hover: {
        enabled: !1,
        trigger: "mousemove",
        effect: {
          color: vk,
          poi: !1,
        },
      },
      select: {
        enabled: !1,
        trigger: "click",
        multi: !1,
        effect: {
          color: bk,
          poi: !1,
        },
      },
    },
  });
class Jq {
  constructor(
    t = {
      min: 1,
      max: 1,
      speed: 0.5,
      yoyo: !0,
    }
  ) {
    (this._reverseTime = !1),
      (this.min = t.min),
      (this.max = t.max),
      (this.speed = t.speed),
      (this.yoyo = t.yoyo),
      (this._prevValue = this.min),
      (this._prevTime = 0);
  }
  set({ min: t, max: e, speed: i, yoyo: n }) {
    (this.min = t),
      (this.max = e),
      (this.speed = i),
      (this.yoyo = n),
      (this._prevValue = this.min);
  }
  getValue(t) {
    const e = t - this._prevTime,
      i = ((this.max - this.min) / 60) * e * this.speed;
    if (((this._prevTime = t), this.yoyo && this._reverseTime)) {
      const t = this._prevValue - i;
      return (
        (this._prevValue = t),
        t < this.min &&
          ((this._reverseTime = !1), (this._prevValue = this.min)),
        Ae(t, this.min, this.max)
      );
    }
    if (this.yoyo) {
      const t = this._prevValue + i;
      return (
        (this._prevValue = t),
        t > this.max &&
          ((this._reverseTime = !0), (this._prevValue = this.max)),
        Ae(t, this.min, this.max)
      );
    }
    {
      const t = this._prevValue + i;
      return (
        (this._prevValue = t),
        t > this.max &&
          ((this._reverseTime = !0), (this._prevValue = this.min)),
        Ae(t, this.min, this.max)
      );
    }
  }
}
var Kq = Object.defineProperty,
  $q = Object.getOwnPropertyDescriptor,
  tY = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? $q(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && Kq(e, i, o), o;
  };
class eY extends NW {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.activeGroups = []),
      (this.__sprites = new _q()),
      this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1),
      (this.__scaleAnimation = new Jq()),
      (this.__opacityAnimation = new Jq()),
      (this.__sprites.minFilter = 1008),
      (this.__sprites.generateMipmaps = !0),
      this.animation.start(),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(Zq);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "bubble-layer",
      layerType: "point",
      label: t,
    });
  }
  updateArea() {
    super.updateArea(), this.__refreshData();
  }
  async add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e);
    const i = this.__getParseData(e),
      n = this.__getScaleData(i);
    this.state.scaleData.push(...n);
    const r = this.__getRenderData(n);
    return (this.state.renderData = r), this.__draw(), this;
  }
  async __draw() {
    const {
      poi: { enabled: t, major: e, minor: i },
      renderData: n,
    } = this.state;
    if (!n || 0 === n.length) return;
    const {
      indices: r,
      position: o,
      uv: a,
      normal: s,
      colors: l,
      dataArray: u,
    } = n;
    this.__getImagesFromMapConfig();
    const c = u.length,
      h = new En();
    if (
      (h.setAttribute("position", o),
      h.setIndex(r),
      h.setAttribute("color", new ns(new Float32Array(l), 4)),
      h.setAttribute("normal", s),
      h.setAttribute("uv", a),
      h.computeVertexNormals(),
      (this.material = new Jn({
        vertexShader:
          "precision highp float;\n\nvarying vec2 vUv;\n\nattribute vec4 color;\nvarying vec4 vColor;\n\n#ifdef USE_IMAGE\nattribute float iconIndex;\nvarying float vIconIndex;\n#endif\n\nvoid main() {\n  vUv = uv;\n  vColor = color;\n#ifdef USE_IMAGE\n  vIconIndex = iconIndex;\n#endif\n  vec3 pos = position;\n  \n  \n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.);\n}",
        fragmentShader:
          "precision highp float;\n\nvarying vec4 vColor;\nuniform float uOpacity;\n\nvarying vec2 vUv;\n\nfloat between(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0., 1.);\n}\n\n#ifdef USE_IMAGE\nuniform sampler2D uImage;\nuniform bool[MAX_ICON_ROW * MAX_ICON_ROW] uTransparentImages;\nvarying float vIconIndex;\nvec2 mixIconCoord(vec2 v) {\n  float maxIconCount = float(MAX_ICON_ROW);\n  \n  float yIndex = floor(vIconIndex / maxIconCount);\n  float xIndex = mod(vIconIndex, maxIconCount);\n  \n  float uvX = (xIndex + 1.) / maxIconCount;\n  float uvY = (yIndex + 1.) / maxIconCount;\n  return vec2(v.x * uvX, v.y * uvY);\n}\n#endif\n\nvoid main() {\n  vec4 finalColor = vec4(0.0, 1.0, 0.0, 1.0);\n  #ifndef USE_IMAGE\n  finalColor = vColor;\n  #else\n  vec2 coord = mixIconCoord(vUv);\n  \n  bool transparent = uTransparentImages[int(vIconIndex)];\n  if(!transparent) {\n    finalColor = texture2D(uImage, coord);\n  } else if(texture2D(uImage, coord).a == 1.) {\n    finalColor = texture2D(uImage, coord);\n  } else if(vColor.a == 0.) {\n    finalColor = texture2D(uImage, coord);\n  } else {\n    finalColor = vec4(vColor.rgb, texture2D(uImage, coord).a);\n  }\n  #endif\n    \n  finalColor.a *= uOpacity;\n  gl_FragColor = finalColor;\n}",
        depthTest: !1,
        transparent: !0,
        uniforms: {
          uOpacity: {
            value: 1,
          },
          uImage: {
            value: null,
          },
          uTransparentImages: {
            value: new Int8Array(64).fill(0),
          },
        },
        defines: {
          USE_IMAGE: !1,
          MAX_ICON_ROW: 8,
        },
      })),
      this.instancedMesh)
    ) {
      for (let p = 0; p < this.coreGroup.children.length; p++)
        if (this.coreGroup.children[p].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new ls(h, this.material, c)),
            this.coreGroup.remove(this.coreGroup.children[p]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new ls(h, this.material, c)),
        this.coreGroup.add(this.instancedMesh);
    this.instancedMesh.setRenderIndex(lU.BUBBLE_LAYER_MESH),
      this.instancedMesh.instanceMatrix.setUsage(xe);
    for (let p = 0; p < c; p++) {
      const n = u[p],
        r = n._size_ / 2,
        o = n.coordinates[0],
        a = n.coordinates[1];
      if (
        (this.dummy.position.set(o, a, 0),
        this.dummy.scale.set(r, r, 1),
        this.dummy.updateMatrix(),
        this.instancedMesh.setMatrixAt(p, this.dummy.matrix),
        this.instancedMesh.setUserDataAt(
          p,
          ot(rt({}, n), {
            initialScale: r,
          })
        ),
        t)
      ) {
        const t = {
          x: o,
          y: a,
          z: 0,
        };
        (t.z += this.coreGroup.position.z),
          await this._addPoiMesh({
            pointPosition: t,
            majorContent: e.format
              ? e.format(u[p]._majorPOI_)
              : u[p]._majorPOI_,
            minorContent: i.format
              ? i.format(u[p]._minorPOI_)
              : u[p]._minorPOI_,
            ext: {
              relatedInstanceId: p,
            },
          });
      }
    }
    (this.instancedMesh.instanceMatrix.needsUpdate = !0), this._updatePOI(!0);
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  clear() {
    super.clear(), (this.instancedMesh = null);
  }
  __getParseData(t) {
    const { fields: e } = this.state,
      { lngField: i, latField: n } = e,
      { clipMode: r } = this.state,
      { globalOpts: o } = this.gis,
      { boundary: a } = o,
      s = Yw(t[0]) ? "geojson" : "bytejson",
      l = !(!r || r === Qw.none),
      u = "Point";
    return this.dataView
      .parse(t, {
        type: s,
        options: {
          layerType: u,
          coordsField: {
            lngField: i,
            latField: n,
          },
        },
      })
      .transform({
        type: "filter",
        options: {
          callback: l && ((t) => Kw(t, a.features[0], r, u)),
        },
      })
      .transform({
        type: "webgis",
        options: {
          as: "coordinates",
        },
      }).latestData;
  }
  __getScaleData(t) {
    const { fields: e, style: i } = this.state,
      {
        fill: { color: n, map: r },
        size: o,
      } = i;
    return this.scaleService.apply(
      [
        {
          scaleField: e.majorPOIField,
          dataField: "_majorPOI_",
        },
        {
          scaleField: e.minorPOIField,
          dataField: "_minorPOI_",
        },
        {
          visual: n,
          scaleField: e.colorField,
          dataField: "_color_",
        },
        {
          visual: o,
          scaleField: e.sizeField,
          dataField: "_size_",
        },
        {
          visual: r,
          scaleField: e.mapField,
          dataField: "_map_",
        },
      ],
      t
    );
  }
  __getRenderData(t) {
    const {
        style: { segments: e },
      } = this.state,
      i = this._mapSize(1, "xy");
    return AW(t, {
      segments: e,
      radiusTop: i,
      angle: -Math.PI / 12,
      shape: "bubble",
      unExclude: !0,
    });
  }
  async __getImagesFromMapConfig() {
    const t = _q.getImagesFromVisualConfig(this.state.style.fill.map);
    await this.__sprites.update(t),
      this.__sprites.getIconCount() > 0
        ? ((this.material.defines.USE_IMAGE = !0),
          (this.material.uniforms.uImage.value = this.__sprites))
        : ((this.material.defines.USE_IMAGE = !1),
          (this.material.uniforms.uImage.value = null)),
      (this.material.uniforms.uTransparentImages.value =
        this.__sprites.transparentImages),
      (this.material.needsUpdate = !0),
      this.__calcIconIndex();
  }
  __calcIconIndex() {
    const t = [];
    this.state.scaleData.forEach((e, i) => {
      const n = e._map_,
        r = this.__sprites.getIconIndex(n);
      t.push(r);
    }),
      this.instancedMesh.geometry.setAttribute(
        "iconIndex",
        new ns(new Uint16Array(t), 1, !1, 1)
      );
  }
  handleAnimation(t) {
    const { animation: e } = this.state;
    if (this.instancedMesh && this.material) {
      if (e.opacity.enabled) {
        const e = this.__opacityAnimation.getValue(t.tickTimes);
        this.material.uniforms.uOpacity.value = e;
      } else this.material.uniforms.uOpacity.value = 1;
      if (e.scale.enabled) {
        const e = this.__scaleAnimation.getValue(t.tickTimes);
        if (
          Object.keys(this.instancedMesh.userData).length <
          this.instancedMesh.count
        )
          return;
        for (let t = 0; t < this.instancedMesh.count; t++) {
          this.instancedMesh.getMatrixAt(t, this.dummy.matrix),
            this.dummy.copyMatrix4(this.dummy.matrix);
          const i = this.instancedMesh.getUserDataAt(t);
          this.dummy.scale.set(e * i.initialScale, e * i.initialScale, 1),
            this.dummy.updateMatrix(),
            this.instancedMesh.setMatrixAt(t, this.dummy.matrix);
        }
        (this.instancedMesh.instanceMatrix.needsUpdate = !0),
          (this.needRestoreScale = !0);
      } else if (this.needRestoreScale) {
        for (let t = 0; t < this.instancedMesh.count; t++) {
          this.instancedMesh.getMatrixAt(t, this.dummy.matrix),
            this.dummy.copyMatrix4(this.dummy.matrix);
          const e = this.state.renderData.dataArray[t]._size_ / 2;
          this.dummy.scale.set(e, e, 1),
            this.dummy.updateMatrix(),
            this.instancedMesh.setMatrixAt(t, this.dummy.matrix);
        }
        (this.instancedMesh.instanceMatrix.needsUpdate = !0),
          (this.needRestoreScale = !1);
      }
    }
  }
  __refreshData() {
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule("", "always", (t) => {
          this.__scaleAnimation.set(this.state.animation.scale),
            this.__opacityAnimation.set(this.state.animation.opacity);
        }),
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          ["fields", ["style", "size"], ["style", "fill"]],
          "diffAnyoneDeep",
          () => {
            this.__refreshData();
          }
        ),
        this._propsWatch.defaultRule(["style", "segments"], "diff", () => {
          this.__refreshData();
        }),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          super.initPOI();
        }),
      ]);
  }
}
tY([lq], eY.prototype, "__getParseData", 1),
  tY([lq], eY.prototype, "__getScaleData", 1);
const iY = {
  common: Sk,
  data: [],
  fields: OW,
  label: {
    enabled: !0,
    markerType: "css2d",
    element: null,
    anchor: {
      position: "center",
      offset: [0, 0],
    },
  },
  clipMode: Qw.intersect,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class nY extends NW {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1),
      this.gis.shaderService.registerModule("markerShader", {
        vertexShader:
          "void main() {\n  vec4 pos = vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * pos;\n}",
        fragmentShader:
          "void main(){\n        gl_FragColor = vec4(1, 1, 1, 0);\n      }",
      }),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(iY);
  }
  _initLayerGroup() {
    const { label: t } = this.state;
    super._initLayerGroup({
      layerName: "marker-layer",
      layerType: "point",
      label: t,
    });
  }
  updateArea() {
    super.updateArea();
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  _getParseData(t) {
    const { fields: e } = this.state,
      { lngField: i, latField: n } = e;
    return super._getParseData(
      ot(rt({}, t), {
        layerType: "Point",
        coordsField: {
          lngField: i,
          latField: n,
        },
      })
    );
  }
  _getRenderData(t) {
    const { parseData: e } = this.state;
    if (0 === e.length) return t;
    const i = AW(e, {
      segments: 3,
      radiusTop: 0.001,
      shape: "marker",
    });
    return (this.state.renderData = i), this;
  }
  add(t) {
    const e = t;
    return e && 0 !== e.length
      ? (this.state.data.push(...e),
        mf(
          this._getParseData.bind(this),
          this._getRenderData.bind(this),
          this.__draw.bind(this)
        )({
          rawData: e,
        }),
        this)
      : this;
  }
  __draw() {
    const { parseData: t, renderData: e } = this.state;
    if (0 === e.length) return this;
    const { position: i, indices: n, dataArray: r } = e,
      o = r.length,
      a = new En();
    a.setAttribute("position", new bn(i, 3)), a.setIndex(new yn(n, 1));
    const s = this.gis.shaderService.getShaderModule("markerShader"),
      l = new Jn(rt({}, s));
    if (this.instancedMesh) {
      for (let u = 0; u < this.coreGroup.children.length; u++)
        if (this.coreGroup.children[u].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new ls(a, l, o)),
            this.coreGroup.remove(this.coreGroup.children[u]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new ls(a, l, o)),
        this.coreGroup.add(this.instancedMesh);
    for (let u = 0; u < o; u++) {
      const e = r[u],
        n = e.coordinates[0],
        o = e.coordinates[1];
      this.dummy.position.set(n, o, 0),
        this.dummy.updateMatrix(),
        this.instancedMesh.setMatrixAt(u, this.dummy.matrix),
        this.instancedMesh.setUserDataAt(u, rt({}, e));
      const a = this.__addMarker(t[u]);
      a.position.set(i[0] + n, i[1] + o, i[2] + 0), this.instancedMesh.add(a);
    }
    return (
      (this.instancedMesh.instanceMatrix.needsUpdate = !0),
      this.coreGroup.add(this.instancedMesh),
      this
    );
  }
  __addMarker(t) {
    const {
      label: { markerType: e, element: i, anchor: n, enabled: r },
    } = this.state;
    let o = "function" == typeof i ? i(t) : i;
    (o = _f("marker", o, n)),
      o.setAttribute("data-layerid", this.id),
      this.group &&
        ((o.firstChild.style.display =
          this.group.visible && r ? "block" : "none"),
        (o.style.zIndex = this.group.zIndex + ""));
    return new nW[e](o);
  }
  remove() {
    super.remove();
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  clear() {
    var t, e;
    super.clear(),
      null == (t = this.instancedMesh) ||
        t.children.forEach((t) => {
          t.dispatchEvent({
            type: "removed",
          });
        }),
      null == (e = this.instancedMesh) || e.dispose(),
      (this.instancedMesh = null);
  }
  updateAnchor() {
    var t;
    const {
      label: { anchor: e },
    } = this.state;
    null == (t = this.instancedMesh) ||
      t.children.forEach((t) => {
        _f("normal", t.element.firstElementChild, e);
      });
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["label", "element"],
            ["label", "markerType"],
            ["label", "enabled"],
          ],
          "diffAnyoneDeep",
          (t, e) => {
            var i;
            this.clear(), this.add(null != (i = t.data) ? i : e.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(["label", "anchor"], "diffDeep", () => {
          this.updateAnchor();
        }),
      ]);
  }
}
const rY = {
  common: Sk,
  data: [],
  fields: OW,
  style: {
    fill: {
      color: {
        type: $U.LINEAR,
        linear: {
          domain: [],
          range: ["#041c22", "#40cad8"],
          clamp: !1,
        },
        threshold: {
          domain: [],
          range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
        },
        ordinal: {
          domain: [],
          range: FW.light.arcoblue,
          unknown: "undefined",
        },
        constant: FW.light.arcoblue[1],
        default: "rgba(255,255,255,0)",
      },
    },
  },
  poi: {
    enabled: !1,
    hideOnMove: !1,
    alignment: "middle",
    offsetX: 0,
    offsetY: 0,
    coverEnable: !1,
    orient: "vertical",
    major: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      nameMap: {},
      offsetX: 0,
      offsetY: 0,
    },
    minor: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      nameMap: {},
      offsetX: 0,
      offsetY: 0,
    },
  },
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class oY extends NW {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.subDistrictInfoArr = []),
      (this.currentRegionData = []),
      this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(rY);
  }
  clear() {
    super.clear(), (this.currentRegionData = []);
  }
  _initialScale() {
    const {
        style: {
          fill: { color: t },
        },
        data: e,
        fields: i,
      } = this.state,
      n = [];
    (this.state.scaleData = []), (this.currentRegionData = []);
    const r = this.gis.layerManager.baseMapLayer.state.data.region,
      o =
        r &&
        0 === this.gis.layerManager.baseMapLayer.currentLevel &&
        !this.gis.layerManager.baseMapLayer.currentRegion;
    o &&
      (e.forEach((t) => {
        var e;
        const o = Object.values(r).find((e) =>
          e.child.includes(t[i.adcodeField])
        );
        if (o) {
          const n =
              null ==
              (e = this.subDistrictInfoArr.find(
                (e) => e.adcode === t[i.adcodeField]
              ))
                ? void 0
                : e.centroid,
            r = this.currentRegionData.find((e) =>
              e._child_.includes(t[i.adcodeField])
            ),
            a = t[i.colorField];
          r
            ? (r._positions_.push(n), r._values_.push(a))
            : this.currentRegionData.push({
                [i.majorPOIField]: o.name,
                _child_: o.child,
                _positions_: [n],
                _rawPosition_: o.position,
                _values_: [a],
              });
        } else n.push(t);
      }),
      this.currentRegionData.forEach((t) => {
        let e;
        t[i.colorField] = t._values_.reduce((t, e) => Lf(t, e), 0);
        const n = t._rawPosition_;
        if (n) {
          e = [
            ...this.gis.layerManager.geo.project([n[0], n[1]]),
            this.coreGroup.position.z,
          ];
        } else {
          const i = Ww.points(t._positions_),
            n = Ww.center(i).geometry.coordinates;
          e = [n[0], n[1], this.coreGroup.position.z];
        }
        t._position_ = e;
      })),
      (this.state.scaleData = this.scaleService.apply(
        [
          {
            visual: t,
            scaleField: i.colorField,
            dataField: "_color_",
          },
          {
            scaleField: i.majorPOIField,
            dataField: "_majorPOI_",
          },
          {
            scaleField: i.minorPOIField,
            dataField: "_minorPOI_",
          },
        ],
        o ? [...n, ...this.currentRegionData] : e
      ));
  }
  _initLayerGroup() {
    (this.layerType = "heatmap"), (this.subLayerType = "district");
    const t = this.copySubDistrictFillGroup();
    super._initLayerGroup({
      layerName: `${this.subLayerType}-${this.layerType}-layer`,
      layerType: this.layerType,
      coreGroup: t,
    });
  }
  get() {
    return super.get();
  }
  add() {
    return this;
  }
  set(t) {
    return super.set(t), this;
  }
  release(t) {
    var e;
    this.clear(),
      null == (e = this.gis.sceneSystem.coreScene) || e.remove(this.group),
      (this.state = af(this.state, t)),
      super._baseLayerinit(),
      this._initLayerGroup(),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  remove() {
    super.remove();
  }
  copySubDistrictFillGroup() {
    const { layerManager: t } = this.gis,
      e = t.baseMapLayer;
    if (!e)
      return this.logService.error("行政区域热力 依赖基础地图层 不存在"), null;
    const i = e.subDistrictFillGroup;
    if (!i)
      return this.logService.error("行政区域热力 依赖省份划分 不存在"), null;
    this.subDistrictInfoArr = of(e.subDistrictInfoArr);
    const n = i.deepClone(!0);
    return n.applyMatrix4(e.coreGroup.matrix), n;
  }
  __calcSubDistrictMeshMaterial() {
    const {
      fields: t,
      style: {
        fill: {
          color: { default: e },
        },
      },
    } = this.state;
    this.coreGroup.children.forEach((i) => {
      const n = this.state.scaleData.find((e) =>
        ((e, i) =>
          e[t.adcodeField] === i.ext.adcode ||
          String(e._child_).includes(i.ext.adcode))(e, i)
      );
      let r;
      (r = n ? n._color_ : e), (i.ext = af(i.ext, n));
      const o = EA(r);
      i.setRenderIndex(lU.DISTRICT_LAYER_PROVINCE_MESH);
      const a = i.material;
      (a.map = null),
        (a.color = o.color),
        (a.opacity = o.opacity),
        (a.transparent = o.transparent),
        (a.needsUpdate = !0);
    });
  }
  async initPOI() {
    var t, e, i, n, r, o;
    const {
      fields: a,
      poi: { enabled: s, major: l, minor: u },
    } = this.state;
    if (!s) return void this.clearPoiGroup();
    this.clearPoiGroup();
    const c = null != (t = l.aliasMap) ? t : l.nameMap ? pf(l.nameMap) : null,
      h = null != (e = u.aliasMap) ? e : u.nameMap ? pf(u.nameMap) : null,
      p = (t, e) =>
        t[a.adcodeField] === e.ext.adcode ||
        String(t._child_).includes(e.ext.adcode);
    for (let d = 0; d < this.state.scaleData.length; d++) {
      const t = this.state.scaleData[d],
        e = this.coreGroup.children.filter((e) => p(t, e)),
        s = null == (i = null == e ? void 0 : e[0]) ? void 0 : i.ext;
      if (s)
        if (t._child_) {
          const i = t[a.majorPOIField],
            n = t[a.colorField],
            r = [t._position_[0], t._position_[1], this.coreGroup.position.z];
          await this._addPoiMesh({
            pointPosition: {
              x: r[0],
              y: r[1],
              z: r[2],
            },
            majorContent: l.format ? l.format(i) : i,
            minorContent: u.format ? u.format(n) : n,
            ext: {
              relatedMeshIds: e.map((t) => t.id),
            },
          });
        } else {
          const t =
            null ==
            (n = this.subDistrictInfoArr.find(
              (t) => t.adcode === s[a.adcodeField]
            ))
              ? void 0
              : n.centroid;
          if (!t) continue;
          const i = s._majorPOI_,
            p = null != (r = c[i]) ? r : i,
            d = s._minorPOI_,
            f = null != (o = h[d]) ? o : d,
            g = [t[0], t[1], this.coreGroup.position.z];
          await this._addPoiMesh({
            pointPosition: {
              x: g[0],
              y: g[1],
              z: g[2],
            },
            majorContent: l.format ? l.format(p) : p,
            minorContent: u.format ? u.format(f) : f,
            ext: {
              relatedMeshIds: e.map((t) => t.id),
            },
          });
        }
    }
    this._updatePOI(!0);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          ["data", "fields", ["style", "fill", "color"]],
          "diffAnyoneDeep",
          (t) => {
            this._initialScale();
          }
        ),
        this._propsWatch.defaultRule(
          "",
          "always",
          (t) => {
            this.__calcSubDistrictMeshMaterial(), this.initPOI();
          },
          !0
        ),
      ]);
  }
}
const aY = {
  common: Sk,
  style: {
    fill: {
      map: ff("images", "circle-background-2.webp"),
      normalMap: null,
      color: null,
      opacity: 1,
    },
  },
  center: null,
  width: 70,
  height: 70,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class sY extends oV {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  _initialState() {
    super._initialState(aY);
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      this._initPlane(),
      super.emitPropsWatch(),
      super.registerInteraction();
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "plane-layer",
      layerType: "env",
    });
  }
  _initPlane() {
    const { sceneSystem: t } = this.gis;
    this.state;
    const e = EA(t.state.background.color);
    (this.geometry = this.__initBufferGeometry()),
      (this.material = new Jn({
        vertexShader:
          "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        fragmentShader:
          "precision highp float;\nuniform sampler2D uPlaneTexture;\nvarying vec2 vUv;\nuniform vec3 uColor;\nuniform float uOpacity;\n\nvoid main() {\n  vec4 finalColor;\n  \n  #if defined(USE_IMAGE)\n  finalColor = texture2D(uPlaneTexture, vUv);\n  finalColor.a *= uOpacity;\n  #else\n  finalColor = vec4(uColor, uOpacity);\n  #endif\n  gl_FragColor = finalColor;\n\n}",
        uniforms: {
          uColor: {
            value: new Ye(e.color.r, e.color.g, e.color.b),
          },
          uOpacity: {
            value: e.opacity,
          },
          uPlaneTexture: {
            value: !1,
          },
        },
        transparent: e.transparent,
        defines: {
          USE_IMAGE: !1,
        },
        depthTest: !0,
        depthWrite: !1,
      })),
      (this.planeMesh = new Wn(this.geometry, this.material)),
      this.planeMesh.setRenderIndex(lU.PLANE_LAYER),
      (this.planeMesh.name = "plane-mesh"),
      this.coreGroup.add(this.planeMesh);
  }
  __initBufferGeometry() {
    const t = new En(),
      e = [],
      i = [],
      n = [],
      r = [];
    for (let o = 0; o < 2; o++) {
      const t = 1 * o - 0.5;
      for (let e = 0; e < 2; e++) {
        const a = 1 * e - 0.5;
        i.push(a, -t, 0), n.push(0, 0, 1), r.push(e / 1), r.push(1 - o / 1);
      }
    }
    for (let o = 0; o < 1; o++)
      for (let t = 0; t < 1; t++) {
        const i = t + 2 * o,
          n = t + 2 * (o + 1),
          r = t + 1 + 2 * (o + 1),
          a = t + 1 + 2 * o;
        e.push(i, n, a), e.push(n, r, a);
      }
    return (
      t.setIndex(e),
      t.setAttribute("position", new bn(i, 3)),
      t.setAttribute("normal", new bn(n, 3)),
      t.setAttribute("uv", new bn(r, 2)),
      t
    );
  }
  updateArea() {
    this.__updateMesh(this.planeMesh),
      this._updateOffset(this.state.common.offset);
  }
  updateBaseHeight() {}
  add(t) {
    return this;
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  __updateMaterial(t) {
    if (t)
      if (sf(t, "map"))
        if (lf(t.map)) {
          this.material.defines.USE_IMAGE = !1;
          const t = this.state.style.fill.color;
          if (t) {
            const e = EA(t);
            (this.material.uniforms.uColor.value = new Ye(
              e.color.r,
              e.color.g,
              e.color.b
            )),
              (this.material.uniforms.uOpacity.value = e.opacity),
              (this.material.transparent = e.transparent),
              (this.material.needsUpdate = !0);
          }
        } else
          this.textureManager("map").setTexture(
            (e) => {
              this.textureManager("map").loader.load(t.map, (t) => {
                e(t);
              });
            },
            (e) => {
              (this.material.defines.USE_IMAGE = !0),
                (this.material.uniforms.uPlaneTexture.value = e),
                (this.material.transparent = t.opacity < 1 || !!gf(e.image)),
                t.opacity &&
                  (this.material.uniforms.uOpacity.value = t.opacity),
                (this.material.needsUpdate = !0);
            }
          );
      else if (sf(t, "color")) {
        if (this.state.style.fill.map) return;
        if (lf(t.color))
          (this.material.defines.USE_IMAGE = !1),
            (this.material.uniforms.uColor.value = new Ye(CU.r, CU.g, CU.b)),
            (this.material.uniforms.uOpacity.value = 1),
            (this.material.transparent = wU),
            (this.material.needsUpdate = !0);
        else {
          this.textureManager("map").abort();
          const e = EA(t.color);
          (this.material.uniforms.uColor.value = new Ye(
            e.color.r,
            e.color.g,
            e.color.b
          )),
            (this.material.uniforms.uOpacity.value = e.opacity),
            (this.material.transparent = e.transparent),
            (this.material.needsUpdate = !0);
        }
      }
  }
  __updateMesh(t) {
    const { width: e, height: i, center: n } = this.state,
      { globalOpts: r, layerManager: o } = this.gis,
      { centerProj: a, bboxScale: s } = r.bboxOption;
    let l = a;
    n && (l = o.geo.project(n)),
      (this._width = e * s * sV),
      (this._height = i * s * sV),
      t.position.setX(l[0]),
      t.position.setY(l[1]),
      cf(e) && t.scale.setX(this._width),
      cf(i) && t.scale.setY(this._height);
  }
  _updateOffset(t) {
    const { width: e, height: i } = this.state,
      [n, r, o] = t,
      { globalOpts: a } = this.gis,
      { bboxScale: s, size: l } = a.bboxOption,
      u = i * s * sV,
      c = TA(e * s * sV, n),
      h = TA(u, r),
      p = TA(l.bboxSize, o);
    this.group.position.setX(c),
      this.group.position.setY(h),
      this.group.position.setZ(p);
  }
  handleAnimation() {
    const { axis: t, speed: e } = this.animation.state;
    let i;
    switch (t) {
      case "x":
        i = new Ye(1, 0, 0);
        break;
      case "z":
        i = new Ye(0, 0, 1);
        break;
      case "y":
        i = new Ye(0, 1, 0);
    }
    this.planeMesh.rotateOnAxis(i, e);
  }
  clear() {
    super.clear();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule("", "always", () => {
          var t;
          this.__updateMaterial(
            null == (t = this.state.style) ? void 0 : t.fill
          ),
            this.__updateMesh(this.planeMesh);
        }),
      ]);
  }
}
const lY = {
  common: Sk,
  style: {
    fill: {
      map: `https://lf3-dpfe.${atob(
        "Ynl0ZXRvcy5jb20="
      )}/obj/gis/images/sprite.png`,
    },
  },
  count: 20,
  size: 20,
  scope: {
    width: 65,
    height: 65,
    altitude: 65,
  },
  center: null,
  minSpeed: 0.1,
  maxSpeed: 0.2,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class uY extends oV {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  _initialState() {
    super._initialState(lY);
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      super.emitPropsWatch({
        count: 0,
      }),
      super.registerInteraction();
  }
  __initTexture() {
    const {
      style: {
        fill: { map: t },
      },
    } = this.state;
    this.texture = this.textureManager("map").loader.load(t);
  }
  updateArea() {
    this.__updateMesh(), this._updateOffset(this.state.common.offset);
  }
  updateBaseHeight() {}
  __updateMesh() {
    const {
        maxSpeed: t,
        minSpeed: e,
        count: i,
        scope: { width: n, height: r, altitude: o },
        size: a,
        center: s,
      } = this.state,
      { globalOpts: l, layerManager: u } = this.gis,
      { centerProj: c, bboxScale: h } = l.bboxOption;
    let p = c;
    s && (p = u.geo.project(s));
    const d = n * h * sV,
      f = r * h * sV,
      g = o * h * sV;
    (this.realMinX = -d / 2),
      (this.realMaxX = d / 2),
      (this.realMinY = -f / 2),
      (this.realMaxY = f / 2),
      (this.realMaxZ = g),
      (this.realMinZ = 0),
      (this.realMinSpeed = e * h * sV),
      (this.realMaxSpeed = t * h * sV),
      (this.realSize = a * h * sV),
      this.particle.position.setX(p[0]),
      this.particle.position.setY(p[1]);
    const m = this.particle.geometry.attributes.position,
      y = this.particle.geometry.attributes.size;
    for (let v = 0; v < i; v++) {
      const t = Ys(this.realMinX, this.realMaxX),
        e = Ys(this.realMinY, this.realMaxY),
        i = Ys(this.realMinZ, this.realMaxZ),
        n = Ys(this.realMinSpeed, this.realMaxSpeed);
      (this.particle.ext.speed[v] = n),
        m.setXYZ(v, t, e, i),
        y.setX(v, 20 * this.realSize);
    }
    (this.particle.geometry.attributes.position.needsUpdate = !0),
      (this.particle.geometry.attributes.size.needsUpdate = !0);
  }
  _updateOffset(t) {
    const {
        scope: { width: e, height: i, altitude: n },
      } = this.state,
      [r, o, a] = t,
      { globalOpts: s } = this.gis,
      { bboxScale: l } = s.bboxOption,
      u = i * l * sV,
      c = n * l * sV,
      h = TA(e * l * sV, r),
      p = TA(u, o),
      d = TA(c, a);
    this.group.position.setX(h),
      this.group.position.setY(p),
      this.group.position.setZ(d);
  }
  __addParticle(t = 1) {
    const e = new En(),
      i = new Array(3 * t),
      n = new Array(t);
    e.setAttribute("position", new bn(i, 3).setUsage(xe)),
      e.setAttribute("size", new bn(n, 1).setUsage(xe)),
      (this.particle = new Cs(e, this.particleMaterial)),
      this.particle.setRenderIndex(lU.PARTICLE_LAYER),
      (this.particle.name = "particle"),
      (this.particle.ext = {
        speed: {},
      }),
      this.coreGroup.add(this.particle);
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "particle-layer",
      layerType: "env",
    }),
      this.animation.start();
  }
  add(t) {
    const { count: e } = t;
    return (
      this.__addParticle(e),
      (this.state = af(this.state, {
        count: this.state.count + e,
      })),
      this.updateArea(),
      this
    );
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  handleAnimation() {
    const { count: t } = this.state,
      e = this.particle.geometry.attributes.position;
    for (let i = 0; i < t; i++) {
      const t = e.getZ(i);
      if (t > df(this.realMaxZ)) e.setZ(i, this.realMinZ);
      else if (t < df(this.realMinZ)) e.setZ(i, this.realMaxZ);
      else {
        const n = this.particle.ext.speed[i];
        e.setZ(i, t + n);
      }
    }
    this.particle.geometry.attributes.position.needsUpdate = !0;
  }
  clear() {
    super.clear();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(["style", "fill", "map"], "diff", () => {
          this.__initTexture(),
            this.particleMaterial
              ? (this.particleMaterial.uniforms.uPointTexture.value =
                  this.texture)
              : (this.particleMaterial = new Jn({
                  vertexShader:
                    "attribute float size;\n\nvoid main() {\n  \n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  \n  gl_PointSize = size / -mvPosition.z;\n  gl_Position = projectionMatrix * mvPosition;\n\n  \n  \n  \n\n  \n  \n  \n\n}",
                  fragmentShader:
                    "precision highp float;\nuniform sampler2D uPointTexture;\n\nvoid main() {\n\n  \n  vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n  gl_FragColor = texture2D(uPointTexture, uv);\n\n}",
                  uniforms: {
                    uPointTexture: {
                      value: this.texture,
                    },
                  },
                  transparent: !0,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                }));
        }),
        this._propsWatch.defaultRule("count", "diff", (t, e) => {
          t.count > e.count
            ? (this.clear(),
              (this.state.count = 0),
              this.add({
                count: t.count,
              }))
            : this.particle.geometry.setDrawRange(0, t.count);
        }),
        this._propsWatch.defaultRule("", "always", (t) => {
          this.__updateMesh();
        }),
      ]);
  }
}
const cY = {
  common: Sk,
  style: {
    fill: {
      maps: [
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-1.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-2.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-3.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-4.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-5.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-6.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-7.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-8.webp`,
        `https://lf3-dpfe.${atob(
          "Ynl0ZXRvcy5jb20="
        )}/obj/gis/images/raising-sprite-number-9.webp`,
      ],
    },
  },
  flash: 40,
  count: 20,
  size: {
    minWidth: 6,
    maxWidth: 6,
    minHeight: 8,
    maxHeight: 8,
  },
  scope: {
    width: 65,
    height: 65,
    altitude: 65,
  },
  center: null,
  minSpeed: 0.1,
  maxSpeed: 0.2,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class hY extends oV {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  _initialState() {
    super._initialState(cY);
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1),
      super.emitPropsWatch({
        count: 0,
      }),
      super.registerInteraction();
  }
  __initTexture() {
    (this.textures = []), (this.textureIndex = 0);
    const {
      style: {
        fill: { maps: t },
      },
    } = this.state;
    t.forEach((t, e) => {
      this.textures.push(this.textureManager(`map-${e}`).loader.load(t));
    });
  }
  updateArea() {
    this.__updateMesh(), this._updateOffset(this.state.common.offset);
  }
  updateBaseHeight() {}
  __updateMesh() {
    const {
        maxSpeed: t,
        minSpeed: e,
        scope: { width: i, height: n, altitude: r },
        size: { minWidth: o, maxWidth: a, minHeight: s, maxHeight: l },
        center: u,
      } = this.state,
      { globalOpts: c, layerManager: h } = this.gis,
      { centerProj: p, bboxScale: d } = c.bboxOption;
    let f = p;
    u && (f = h.geo.project(u));
    const g = i * d * sV,
      m = n * d * sV,
      y = r * d * sV;
    (this.realMinWidth = o * d * sV),
      (this.realMinHeight = s * d * sV),
      (this.realMaxWidth = a * d * sV),
      (this.realMaxHeight = l * d * sV),
      (this.realMinX = -g / 2),
      (this.realMaxX = g / 2),
      (this.realMinY = -m / 2),
      (this.realMaxY = m / 2),
      (this.realMaxZ = y),
      (this.realMinZ = 0),
      (this.realMinSpeed = e * d * sV),
      (this.realMaxSpeed = t * d * sV),
      this.stream.position.setX(f[0]),
      this.stream.position.setY(f[1]);
    for (let v = 0; v < this.stream.count; v++) {
      const t = Ys(this.realMinX, this.realMaxX),
        e = Ys(this.realMinY, this.realMaxY),
        i = Ys(this.realMinZ, this.realMaxZ);
      this.dummy.position.set(t, e, i),
        this.dummy.scale.set(
          Ys(this.realMinWidth, this.realMaxWidth),
          Ys(this.realMinHeight, this.realMaxHeight),
          1
        ),
        (this.dummy.rotation.x = Math.PI / 2),
        this.dummy.updateMatrix(),
        this.stream.setMatrixAt(v, this.dummy.matrix),
        this.stream.setUserDataAt(v, {
          speed: Ys(this.realMinSpeed, this.realMaxSpeed),
        });
    }
    this.stream.instanceMatrix.needsUpdate = !0;
  }
  __addstream(t = 1) {
    const e = new dr();
    (this.stream = new ls(e, this.streamMaterial, t)),
      this.stream.setRenderIndex(lU.STREAM_LAYER),
      this.stream.instanceMatrix.setUsage(xe),
      (this.stream.name = "rasing-stream-number"),
      this.coreGroup.add(this.stream);
  }
  _updateOffset(t) {
    const {
        scope: { width: e, height: i, altitude: n },
      } = this.state,
      [r, o, a] = t,
      { globalOpts: s } = this.gis,
      { bboxScale: l } = s.bboxOption,
      u = i * l * sV,
      c = n * l * sV,
      h = TA(e * l * sV, r),
      p = TA(u, o),
      d = TA(c, a);
    this.group.position.setX(h),
      this.group.position.setY(p),
      this.group.position.setZ(d);
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "stream-layer",
      layerType: "env",
    }),
      this.animation.start();
  }
  add(t) {
    const { count: e } = t;
    return (
      this.__addstream(e),
      (this.state = af(this.state, {
        count: this.state.count + e,
      })),
      this.updateArea(),
      this
    );
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  updateTexture(t, e) {
    return (
      this.textures.splice(
        t,
        1,
        this.textureManager(`map-${t}`).loader.load(e)
      ),
      this
    );
  }
  addTexture(t, e) {
    return (
      this.textures.splice(
        t,
        0,
        this.textureManager(`map-${t}`).loader.load(e)
      ),
      this
    );
  }
  deleteTexture(t) {
    return (this.textureIndex = 0), this.textures.splice(t, 1), this;
  }
  _toogleTexture() {
    this.textureIndex >= this.textures.length - 1
      ? (this.textureIndex = 0)
      : this.textureIndex++,
      (this.streamMaterial.uniforms.uStreamTexture.value =
        this.textures[this.textureIndex]);
  }
  handleAnimation(t) {
    const { flash: e } = this.state,
      { tickTimes: i } = t;
    i % e == 0 && this._toogleTexture();
    for (let n = 0; n < this.stream.count; n++) {
      if (
        (this.stream.getMatrixAt(n, this.dummy.matrix),
        this.dummy.copyMatrix4(this.dummy.matrix),
        this.dummy.position.z > this.realMaxZ)
      )
        this.dummy.position.setZ(this.realMinZ);
      else {
        const t = this.stream.getUserDataAt(n);
        this.dummy.position.setZ(this.dummy.position.z + t.speed);
      }
      this.dummy.updateMatrix(), this.stream.setMatrixAt(n, this.dummy.matrix);
    }
    this.stream.instanceMatrix.needsUpdate = !0;
  }
  clear() {
    super.clear();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          ["style", "fill", "maps"],
          "diffDeep",
          () => {
            this.__initTexture(),
              this.streamMaterial
                ? (this.streamMaterial.uniforms.uStreamTexture.value =
                    this.textures[0])
                : (this.streamMaterial = new Jn({
                    vertexShader:
                      "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n}",
                    fragmentShader:
                      "precision highp float;\nuniform sampler2D uStreamTexture;\nvarying vec2 vUv;\n\nvoid main() {\n\n  gl_FragColor = texture2D(uStreamTexture, vUv);\n\n}",
                    uniforms: {
                      uStreamTexture: {
                        value: this.textures[0],
                      },
                    },
                    transparent: !0,
                    side: xt,
                    depthTest: !1,
                    depthWrite: !1,
                  }));
          }
        ),
        this._propsWatch.defaultRule("count", "diff", (t, e) => {
          t.count > e.count
            ? (this.clear(),
              (this.state.count = 0),
              this.add({
                count: t.count,
              }))
            : (this.stream.count = t.count);
        }),
        this._propsWatch.defaultRule("", "always", (t) => {
          this.__updateMesh();
        }),
      ]);
  }
}
const pY = {
  common: Sk,
  data: [],
  fields: OW,
  style: {
    fill: {
      color: {
        type: $U.LINEAR,
        linear: {
          domain: [],
          range: ["rgba(158,238,255,0.5)", "rgba(158,238,255,1)"],
          clamp: !1,
        },
        threshold: {
          domain: [],
          range: [FW.light.arcoblue[1], FW.light.arcoblue[9]],
        },
        ordinal: {
          domain: [],
          range: FW.light.arcoblue,
          unknown: "undefined",
        },
        constant: FW.light.arcoblue[1],
        default: "rgba(255,255,255,0)",
      },
    },
    height: {
      type: $U.LINEAR,
      linear: {
        domain: [],
        range: [0, 100],
        clamp: !1,
      },
      threshold: {
        domain: [],
        range: [0, 100],
      },
      ordinal: {
        domain: [],
        range: [0, 100],
      },
      constant: 50,
      default: 0,
    },
    radiusTop: 4,
    radiusBottom: 4,
    segments: 4,
  },
  animation: {
    enabled: !1,
  },
  topStyle: {
    fill: {
      map: null,
    },
  },
  sideStyle: {
    fill: {
      map: null,
    },
    gradientColorConfig: {},
    gradientOpacityConfig: {},
  },
  poi: {
    enabled: !1,
    hideOnMove: !1,
    alignment: "middle",
    offsetX: 0,
    offsetY: 0,
    coverEnable: !1,
    orient: "vertical",
    anchor: EW.TOP,
    major: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    minor: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    custom: {
      enabled: !1,
      markerType: "css2d",
      element: null,
    },
  },
  clipMode: Qw.intersect,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
class dY extends RW {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      this._initialState(),
      this._initLayerGroup(),
      (this.dummy = new Hi()),
      (this.dummy.matrixAutoUpdate = !1);
    const { animation: i, topStyle: n, sideStyle: r } = this.state,
      {
        fill: { map: o },
      } = n,
      {
        fill: { map: a },
        gradientColorConfig: s,
        gradientOpacityConfig: l,
      } = r,
      { enabled: u } = i;
    u && this.animation.start();
    const { range: c } = s,
      { range: h } = l,
      [p, d] = c || [],
      f = EA(p),
      g = EA(d);
    this.gis.shaderService.registerModule("barShader", {
      vertexShader:
        "varying vec2 vUv;\nuniform float uTime;\nvarying float vZ;\n\nvoid main() {\n  vColor = color;\n  #if (defined USE_TOP_TEXTURE) || (defined USE_SIDE_TEXTURE)\n  vUv = uv;\n  #endif\n  vZ = position.z;\n  vec4 pos = vec4(position.xy, position.z * uTime, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * pos;\n}",
      fragmentShader:
        "precision highp float;\n\nvarying vec2 vUv;\nvarying float vZ; \nuniform sampler2D uTopTexture; \nuniform sampler2D uSideTexture; \nuniform vec4 uFromColor; \nuniform vec4 uToColor; \nuniform vec2 uGradientOpacity;\nvoid main() {\n  #if (defined USE_TOP_TEXTURE) || (defined USE_SIDE_TEXTURE)\n  if(vUv.x > 0.0 && vUv.y > 0.0) {\n    gl_FragColor = vZ < 1.0 ? texture2D(uSideTexture, vUv) : texture2D(uTopTexture, vUv);\n  } else {\n    #ifdef USE_COLOR_GRADIENT\n    gl_FragColor = mix(uFromColor, uToColor, vZ);\n    #endif\n    #ifdef USE_OPACITY_GRADIENT\n    gl_FragColor.a *= mix(uGradientOpacity.x, uGradientOpacity.y, vZ);\n    #endif\n  }\n  #else\n  #ifdef USE_COLOR_GRADIENT\n  gl_FragColor = mix(uFromColor, uToColor, vZ);\n  #endif\n  #ifdef USE_OPACITY_GRADIENT\n  gl_FragColor.a *= mix(uGradientOpacity.x, uGradientOpacity.y, vZ);\n  #endif\n  #endif\n}",
      uniforms: {
        uTime: {
          type: "float",
          value: Number(!u),
        },
        uTopTexture: {
          type: "sampler2D",
          value: new rE().load(o),
        },
        uSideTexture: {
          type: "sampler2D",
          value: new rE().load(a),
        },
        uFromColor: {
          type: "vec4",
          value: new je(f.color.r, f.color.g, f.color.b, f.opacity),
        },
        uToColor: {
          type: "vec4",
          value: new je(g.color.r, g.color.g, g.color.b, g.opacity),
        },
        uGradientOpacity: {
          type: "vec2",
          value: h,
        },
      },
      defines: {
        USE_TOP_TEXTURE: !!o,
        USE_SIDE_TEXTURE: !!a,
        USE_COLOR_GRADIENT: !!c && c.length > 1,
        USE_OPACITY_GRADIENT: !!h,
        USE_COLOR_ALPHA: !0,
      },
      basicMaterial: ot(rt({}, mr.phong), {
        lights: !0,
      }),
    }),
      super.registerInteraction(),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(pY);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "bar-layer",
      layerType: "point",
      label: t,
    });
  }
  updateArea() {
    super.updateArea();
    const { data: t } = this.state,
      { animation: e } = this.state,
      { enabled: i } = e;
    if ((this.clear(), i && this.instancedMesh)) {
      const { uniforms: t } = this.instancedMesh.material;
      (t.uTime.value = 0), this.animation.start();
    }
    this.add(t);
  }
  _getParseData(t) {
    const { fields: e } = this.state,
      { lngField: i, latField: n } = e;
    return super._getParseData(
      ot(rt({}, t), {
        layerType: "Point",
        coordsField: {
          lngField: i,
          latField: n,
        },
      })
    );
  }
  _getScaleData() {
    const { style: t, fields: e } = this.state,
      {
        fill: { color: i },
        height: n,
      } = t,
      r = [
        {
          visual: i,
          scaleField: e.colorField,
          dataField: "_color_",
        },
        {
          visual: n,
          scaleField: e.heightField,
          dataField: "_height_",
        },
        {
          scaleField: e.majorPOIField,
          dataField: "_majorPOI_",
        },
        {
          scaleField: e.minorPOIField,
          dataField: "_minorPOI_",
        },
      ];
    return super._getScaleData(r);
  }
  _getRenderData() {
    const { style: t, topStyle: e, sideStyle: i, scaleData: n } = this.state,
      {
        fill: { map: r },
      } = e,
      {
        fill: { map: o },
      } = i,
      { radiusTop: a, radiusBottom: s, segments: l } = t,
      u = this._mapSize(a, "xy"),
      c = this._mapSize(s, "xy"),
      h = AW(n, {
        radiusTop: u,
        radiusBottom: c,
        segments: l,
        shape: "cylinder",
        texture: {
          top: r,
          side: o,
        },
      });
    return (this.state.renderData = h), this;
  }
  add(t) {
    const e = t;
    return e && 0 !== e.length
      ? (this.state.data.push(...e),
        mf(
          this._getParseData.bind(this),
          this._getScaleData.bind(this),
          this._getRenderData.bind(this),
          this.__draw.bind(this)
        )({
          rawData: e,
        }),
        this)
      : this;
  }
  async __draw() {
    const {
      poi: { anchor: t, enabled: e, major: i, minor: n },
      renderData: r,
    } = this.state;
    if (!r || 0 === r.length) return;
    const {
        indices: o,
        position: a,
        uv: s,
        normal: l,
        colors: u,
        height: c,
        dataArray: h,
      } = r,
      p = h.length,
      d = new En();
    d.setAttribute("position", new bn(a, 3)), d.setIndex(new yn(o, 1));
    d.setAttribute("color", new ns(new Float32Array(u), 4, !1, 1)),
      d.setAttribute("normal", new bn(l, 3)),
      d.setAttribute("uv", new bn(s, 2)),
      d.translate(0, 0, 0.5),
      d.computeVertexNormals();
    const f = this.gis.shaderService.getShaderModule("barShader"),
      g = new Jn(
        ot(rt({}, f), {
          transparent: !0,
        })
      );
    if (this.instancedMesh) {
      for (let y = 0; y < this.coreGroup.children.length; y++)
        if (this.coreGroup.children[y].uuid === this.instancedMesh.uuid) {
          (this.instancedMesh = new ls(d, g, p)),
            this.coreGroup.remove(this.coreGroup.children[y]),
            this.coreGroup.add(this.instancedMesh);
          break;
        }
    } else
      (this.instancedMesh = new ls(d, g, p)),
        this.coreGroup.add(this.instancedMesh);
    this.instancedMesh.setRenderIndex(lU.HEXAGON_HEATMAP);
    let m = 0;
    for (let y = 0; y < p; y++) {
      const r = h[y],
        o = r.coordinates[0],
        a = r.coordinates[1];
      this.dummy.position.set(o, a, 0);
      const s = this._mapSize(c[y], "z");
      if (
        (this.dummy.scale.set(1, 1, this._mapSize(c[y], "z")),
        this.dummy.updateMatrix(),
        this.instancedMesh.setMatrixAt(y, this.dummy.matrix),
        this.instancedMesh.setUserDataAt(y, rt({}, r)),
        e)
      ) {
        switch (((m = s), t)) {
          case EW.BOTTOM:
            m = 0;
            break;
          case EW.MIDDLE:
            m = s / 2;
          case EW.TOP:
        }
        await this._addPoiMesh({
          pointPosition: {
            x: o,
            y: a,
            z: m + this.coreGroup.position.z,
          },
          majorContent: i.format ? i.format(h[y]._majorPOI_) : h[y]._majorPOI_,
          minorContent: n.format ? n.format(h[y]._minorPOI_) : h[y]._minorPOI_,
          ext: {
            relatedInstanceId: y,
          },
        });
      }
    }
    (this.instancedMesh.instanceMatrix.needsUpdate = !0), this._updatePOI(!0);
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  handleAnimation(t) {
    if (!this.instancedMesh) return;
    const { material: e } = this.instancedMesh,
      { uniforms: i } = e;
    i.uTime.value >= 1 ? this.animation.pause() : (i.uTime.value += 0.01);
  }
  clear() {
    super.clear(), (this.instancedMesh = null);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "segments"],
            ["style", "radiusBottom"],
            ["style", "radiusTop"],
            ["style", "topStyle"],
            ["style", "sideStyle"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule(
          [
            ["style", "fill"],
            ["style", "height"],
          ],
          "diffAnyoneDeep",
          (t) => {
            mf(
              this._getScaleData.bind(this),
              this._getRenderData.bind(this),
              this.__draw.bind(this)
            )(this.state);
          },
          !0
        ),
        this._propsWatch.defaultRule("poi", "diffDeep", (t) => {
          super.initPOI();
        }),
      ]);
  }
}
(dY.point = new Ye()), (dY.axis = new Ye());
const fY = {
  common: Sk,
  fields: OW,
  data: [],
  style: {
    colorPalette: {
      type: $U.LINEAR,
      linear: {
        range: [
          "rgba(37,115,178,0.5)",
          "rgba(25,214,195,1)",
          "rgba(255,202,66,1)",
          "rgba(223,36,13,1)",
        ],
        domain: [0.35, 0.55, 0.85, 1],
      },
      threshold: {
        range: [
          "rgba(37,115,178,0.5)",
          "rgba(25,214,195,1)",
          "rgba(255,202,66,1)",
          "rgba(223,36,13,1)",
        ],
        domain: [0.35, 0.55, 0.85, 1],
      },
    },
    colorWeight: {
      type: $U.LINEAR,
      linear: {
        domain: null,
        range: [0.1, 1],
        clamp: !1,
      },
      threshold: {
        domain: null,
        range: [0, 1],
      },
      ordinal: {
        domain: null,
        range: [0, 1],
      },
    },
    heightWeight: {
      type: $U.LINEAR,
      linear: {
        domain: null,
        range: [0.1, 1],
        clamp: !1,
      },
      threshold: {
        domain: null,
        range: [0, 1],
      },
      ordinal: {
        domain: null,
        range: [0, 1],
      },
    },
    size: {
      type: $U.CONSTANT,
      linear: {
        domain: null,
        range: [0, 26],
        clamp: !1,
      },
      threshold: {
        domain: null,
        range: [0, 26],
      },
      ordinal: {
        domain: null,
        range: [0, 26],
      },
      constant: 26,
      default: 26,
    },
    height: {
      type: $U.LINEAR,
      linear: {
        range: [0, 50],
      },
      custom: {
        name: "bezier",
        factor: [0.4, 0.2, 0.7, 0.5],
        range: [0, 100],
      },
    },
  },
  clipMode: Qw.intersect,
};
class gY extends Es {
  constructor(t = "earth") {
    const e = document.createElement("canvas");
    (e.height = 1),
      (e.width = 256),
      super(e),
      (this.wrapS = Bt),
      (this.wrapT = Bt),
      (this.ctx = e.getContext("2d")),
      (this.ctx.globalCompositeOperation = "copy");
  }
  update(t) {
    !(function (t, e) {
      const i = e.createLinearGradient(0, 0, 256, 1),
        n = 0;
      for (let r = 0; r < t.colors.length; ++r)
        if ("ordinal" === t.type)
          0 == r
            ? (i.addColorStop(0, t.colors[r]),
              i.addColorStop(t.positions[r + 1] - n, t.colors[r]))
            : (i.addColorStop(t.positions[r - 1], t.colors[r]),
              i.addColorStop(t.positions[r], t.colors[r]));
        else i.addColorStop(t.positions[r], t.colors[r]);
      (e.fillStyle = i), e.fillRect(0, 0, 256, 1);
    })(t, this.ctx),
      (this.needsUpdate = !0);
  }
  get(t) {
    return this.ctx.getImageData(255 * (t || 0), 0, 1, 1).data;
  }
  updateWithVisual(t) {
    switch (t.type) {
      case $U.LINEAR:
        {
          const e = t.linear,
            i = e.range,
            n = e.domain;
          this.update({
            colors: i,
            positions: n,
            type: "linear",
          });
        }
        break;
      case $U.THRESHOLD:
        {
          const e = t.threshold,
            i = e.range,
            n = e.domain;
          this.update({
            colors: i,
            positions: n,
            type: "ordinal",
          });
        }
        break;
      default:
        console.error("Invalid scale type for colorscale");
    }
  }
}
class mY extends Cr {
  constructor() {
    super({
      transparent: !0,
      vertexShader:
        "precision highp float;\n\n#define LINEAR 0\n#define BEZIER 1\n\nattribute vec2 position;\nvarying vec2 vTextureCoord;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform sampler2D uHeatmapHeight;\nuniform float uBaseHeight;\nuniform vec4 uBbox;\nuniform float uMinHeight;\nuniform float uMaxHeight;\nuniform int uHeightFunc;\nuniform vec4 uHightFuncFactor;\nvec2 pos2coord(vec2 pos) {\n    vec2 tmp = uBbox.zw - uBbox.xy;\n    return uBbox.xy + (pos * tmp);\n\n}\n\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    float one_minus_t3 = one_minus_t2 * one_minus_t;\n    return p0 * one_minus_t3 +\n        p1 * one_minus_t2 * t * 3.0 +\n        p2 * one_minus_t * t2 * 3.0 +\n        p3 * t3;\n}\nfloat toBezier(float value) {\n    return bezier(vec2(0.0, 0.0), uHightFuncFactor.xy, uHightFuncFactor.zw, vec2(1.0, 1.0), value).y;\n}\nfloat linear(float value) {\n    return value;\n}\nvoid main() {\n    vTextureCoord = (position + 0.5);\n    vec2 tmp = vTextureCoord;\n    float weight = texture2D(uHeatmapHeight, tmp).r;\n    float heightScale = (uMaxHeight - uMinHeight);\n    float z = 0.;\n    if(uHeightFunc == BEZIER) {\n        z = (uMinHeight + toBezier(weight) * heightScale) * uBaseHeight / 100.;\n    } else {\n        z = (uMinHeight + linear(weight) * heightScale) * uBaseHeight / 100.;\n    }\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos2coord(tmp), z, 1);\n\n}",
      fragmentShader:
        "precision highp float;\nuniform sampler2D uHeatmapColor;\nuniform sampler2D uColorScale;\nuniform float uOpacity;\n\nvarying vec2 vTextureCoord;\n\nvoid main() {\n    vec4 weight = texture2D(uHeatmapColor, vTextureCoord);\n    gl_FragColor = texture2D(uColorScale, vec2(weight.r, 0.5));\n    gl_FragColor.a *= weight.a;\n    gl_FragColor.a *= uOpacity;\n\n}",
      depthTest: !0,
      uniforms: {
        uHeatmapColor: {
          value: null,
        },
        uHeatmapHeight: {
          value: null,
        },
        uColorScale: {
          value: null,
        },
        uBaseHeight: {
          value: 100,
        },
        uMinHeight: {
          value: 0,
        },
        uMaxHeight: {
          value: 100,
        },
        uHeightFunc: {
          value: 0,
        },
        uHightFuncFactor: {
          value: [0, 0, 1, 1],
        },
        uBbox: {
          value: [0, 0, 1, 1],
        },
        uResolution: {
          value: 100,
        },
        uOpacity: {
          value: 1,
        },
      },
      blending: 1,
    }),
      (this.type = "PointHeatmapTexture3DMaterial");
  }
}
class yY extends Cr {
  constructor() {
    super({
      transparent: !0,
      side: xt,
      vertexShader:
        "precision highp float;\n\nuniform float uResolution;\nuniform float uHeight;\nuniform vec4 uBbox;\n\nattribute vec3 position;\nattribute vec3 offset;\nattribute float size;\n\nvarying vec2 vNormal;\nvarying float vValue;\nvec2 pos2coord(vec2 pos) {\n  float t_x = (pos.x - uBbox.x) / (uBbox.z - uBbox.x);\n  float t_y = (pos.y - uBbox.y) / (uBbox.w - uBbox.y);\n\n    \n    \n    \n  return vec2((t_x - 0.5) * 2.0, (t_y - 0.5) * 2.0);\n}\n\nvoid main() {\n\n  vNormal = position.xy;\n  vValue = offset.z;\n  vec3 pos = position * uResolution * size + vec3(offset.xy, uHeight);\n  gl_Position = vec4(pos2coord(pos.xy), 0.0, 1.0);\n    \n}",
      fragmentShader:
        "precision highp float;\n\nvarying vec2 vNormal;\n\nvarying float vValue;\n\nvoid main() {\n\n    \n    \n    \n    float d = smoothstep(0., 1., 1.0 - length(vNormal));\n\n    float weight = d * vValue;\n    gl_FragColor = vec4(weight, weight, weight, weight);\n}",
      blending: 5,
      blendEquation: _t,
      depthTest: !1,
      blendSrc: 201,
      blendDst: 201,
      uniforms: {
        uResolution: {
          value: 1e3,
        },
        uBbox: {
          value: [0, 0, 1, 1],
        },
      },
    }),
      (this.type = "PointHeatmapMaterial");
  }
}
const vY = new Float32Array([
  -1, -1, 0, 1, -1, 0, 1, 1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0,
]);
class bY extends dE {
  constructor(t) {
    super(),
      (this.renderSystem = t),
      (this.type = "PointHeatmapGeometry"),
      (this.offsetAttr = new hq(this.renderSystem, "offset", new fq())),
      (this.sizeAttr = new hq(this.renderSystem, "size", new dq())),
      (this.blurAttr = new hq(this.renderSystem, "blur", new dq())),
      this.__initNormal(),
      this.__initValue();
  }
  add(t, e, i, n) {
    this.offsetAttr.emplaceBack(t[0], t[1], e),
      this.sizeAttr.emplaceBack(i),
      this.blurAttr.emplaceBack(n),
      this.__refreshBuffer();
  }
  clear() {
    this.offsetAttr.structArray.clear(),
      this.sizeAttr.structArray.clear(),
      this.blurAttr.structArray.clear(),
      (this.instanceCount = 0);
  }
  __refreshBuffer() {
    this.offsetAttr.refreshBuffer(),
      this.sizeAttr.refreshBuffer(),
      this.blurAttr.refreshBuffer(),
      (this.instanceCount = this.offsetAttr.structArray.length);
  }
  __initNormal() {
    const t = new bn(vY, 3);
    this.setAttribute("position", t);
  }
  __initValue() {
    this.offsetAttr.bindGeometry(this),
      this.sizeAttr.bindGeometry(this),
      this.blurAttr.bindGeometry(this),
      this.__refreshBuffer();
  }
}
class xY extends Wn {
  constructor(t) {
    super(new bY(t), new yY()), (this.frustumCulled = !1);
  }
  addValue(t, e, i, n) {
    this.geometry.add(t, e, i, n);
  }
  reset() {
    this.geometry.clear();
  }
}
var _Y,
  SY,
  MY = Object.defineProperty,
  CY = Object.getOwnPropertyDescriptor,
  wY = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? CY(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && MY(e, i, o), o;
  };
class AY extends oV {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.__dataBounds = [0, 0, 0, 0]),
      this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      super.registerInteraction(),
      this.dataView.parse([]),
      this._initHeatmapMesh(),
      super.emitPropsWatch();
  }
  _initHeatmapMesh() {
    (this.__heatmapColorTarget = this.gis.renderSystem.newRT()),
      (this.__heatmapHeightTarget = this.gis.renderSystem.newRT()),
      (this.__heatmapColorMesh = new xY(this.gis.renderSystem)),
      (this.__heatmapHeightMesh = new xY(this.gis.renderSystem)),
      (this.__colorscale = new gY());
    const t = new mY();
    (t.uniforms.uHeatmapColor.value = this.__heatmapColorTarget.texture),
      (t.uniforms.uHeatmapHeight.value = this.__heatmapHeightTarget.texture),
      (t.uniforms.uColorScale.value = this.__colorscale),
      (this.__heatmapTextureMesh = new Wn(new dr(1, 1, 256, 256), t)),
      (this.__heatmapTextureMesh.frustumCulled = !1),
      this.__heatmapTextureMesh.setRenderIndex(lU.POINT_HEATMAP3D_LAYER),
      this.coreGroup.add(this.__heatmapTextureMesh),
      this.updateArea(),
      this.__calcRenderBBox(),
      this.__calcColorScale(),
      this.__handleZoomChange(),
      setTimeout(() => {
        this.renderHeatmapRT();
      }, 0);
  }
  _initialState() {
    super._initialState(fY);
  }
  _initLayerGroup() {
    (this.layerType = "heatmap"),
      (this.subLayerType = "point"),
      super._initLayerGroup({
        layerName: `${this.subLayerType}-${this.layerType}-layer`,
        layerType: this.layerType,
      });
  }
  set(t) {
    return super.set(t), this;
  }
  add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e);
    const i = this.__getParseData(e),
      n = this.__getScaleData(i);
    this.state.scaleData.push(...n);
    for (let r = 0; r < n.length; r++) {
      const t = n[r];
      this.__add(t);
    }
    return this.__calcDataBBox(), this.__calcRenderBBox(), this;
  }
  __add(t) {
    const {
      coordinates: e,
      _weightColor_: i,
      _weightHeight_: n,
      _size_: r,
      _blur_: o,
    } = t;
    this.__heatmapColorMesh.addValue([e[0], e[1], 0], i, r, o),
      this.__heatmapHeightMesh.addValue([e[0], e[1], 0], n, r, o);
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove(),
      this.gis.renderSystem.removeRT(this.__heatmapColorTarget),
      this.gis.renderSystem.removeRT(this.__heatmapHeightTarget);
  }
  handleAnimation() {}
  updateArea() {
    super.updateArea();
    const { globalOpts: t } = this.gis;
    t &&
      (this.__heatmapTextureMesh.material.uniforms.uBaseHeight.value =
        this.gis.globalOpts.bboxOption.baseHeight),
      this.__refreshData(),
      this.__calcDataBBox(),
      this.__calcRenderBBox();
  }
  __handleZoomChange() {
    const t = this.gis.controlsSystem.getCameraResolution();
    (this.__heatmapColorMesh.material.uniforms.uResolution.value = t),
      (this.__heatmapHeightMesh.material.uniforms.uResolution.value = t),
      (this.__heatmapTextureMesh.material.uniforms.uResolution.value = t),
      this.__calcRenderBBox(),
      this.renderHeatmapRT();
  }
  __calcDataBBox() {
    let t = 1 / 0,
      e = 1 / 0,
      i = -1 / 0,
      n = -1 / 0;
    this.state.scaleData.forEach((r) => {
      (t = Math.min(t, r.coordinates[0])),
        (e = Math.min(e, r.coordinates[1])),
        (i = Math.max(i, r.coordinates[0])),
        (n = Math.max(n, r.coordinates[1]));
    }),
      (this.__dataBounds = [t, e, i, n]);
  }
  __calcRenderBBox() {
    const t = this.state.scaleData.reduce((t, e) => Math.max(t, e._size_), 0),
      e = this.gis.controlsSystem.getCameraResolution();
    this.dataView;
    const i = this.gis.controlsSystem.getBounds();
    let [n, r, o, a] = this.__dataBounds;
    const s = e * t * 2;
    (n = Math.max(n, i[0]) - s),
      (r = Math.max(r, i[1]) - s),
      (o = Math.min(o, i[2]) + s),
      (a = Math.min(a, i[3]) + s),
      (this.__heatmapTextureMesh.material.uniforms.uBbox.value = [n, r, o, a]),
      (this.__heatmapColorMesh.material.uniforms.uBbox.value = [n, r, o, a]),
      (this.__heatmapHeightMesh.material.uniforms.uBbox.value = [n, r, o, a]);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(["style", "height"], "diffDeep", () => {
          this.__calcHeightScale();
        }),
        this._propsWatch.defaultRule("data", "has", () => {
          this.__refreshData();
        }),
        this._propsWatch.defaultRule(
          [
            "fields",
            ["style", "size"],
            ["style", "colorWeight"],
            ["style", "heightWeight"],
          ],
          "diffAnyoneDeep",
          () => {
            this.__refreshData();
          }
        ),
        this._propsWatch.defaultRule(
          [["style", "colorPalette"]],
          "diffAnyoneDeep",
          () => {
            this.__calcColorScale();
          }
        ),
      ]);
  }
  __calcColorScale() {
    const { style: t } = this.state,
      { colorPalette: e } = t;
    this.__colorscale.updateWithVisual(e);
  }
  __calcHeightScale() {
    const t = this.state.style.height;
    switch (t.type) {
      case $U.CUSTOM:
        "bezier" === t.custom.name
          ? ((this.__heatmapTextureMesh.material.uniforms.uHeightFunc.value = 1),
            (this.__heatmapTextureMesh.material.uniforms.uHightFuncFactor.value =
              t.custom.factor))
          : (this.__heatmapTextureMesh.material.uniforms.uHeightFunc.value = 0),
          (this.__heatmapTextureMesh.material.uniforms.uMinHeight.value =
            t.custom.range[0]),
          (this.__heatmapTextureMesh.material.uniforms.uMaxHeight.value =
            t.custom.range[1]);
        break;
      case $U.LINEAR:
      default:
        (this.__heatmapTextureMesh.material.uniforms.uHeightFunc.value = 0),
          (this.__heatmapTextureMesh.material.uniforms.uMinHeight.value =
            t.linear.range[0]),
          (this.__heatmapTextureMesh.material.uniforms.uMaxHeight.value =
            t.linear.range[1]);
    }
  }
  __refreshData() {
    const t = this.state.data;
    (this.state.data = []),
      (this.state.scaleData = []),
      this.__heatmapColorMesh.geometry.clear(),
      this.__heatmapHeightMesh.geometry.clear(),
      this.add(t),
      this.__calcColorScale();
  }
  renderHeatmapRT() {
    const { coreRenderer: t } = this.gis.renderSystem;
    t.setRenderTarget(this.__heatmapColorTarget),
      t.clear(),
      t.render(this.__heatmapColorMesh, this.gis.cameraSystem.coreCamera),
      t.setRenderTarget(this.__heatmapHeightTarget),
      t.clear(),
      t.render(this.__heatmapHeightMesh, this.gis.cameraSystem.coreCamera);
  }
  __getParseData(t) {
    const { fields: e, clipMode: i } = this.state,
      { lngField: n, latField: r } = e,
      { globalOpts: o } = this.gis,
      { boundary: a } = o,
      s = Yw(t[0]) ? "geojson" : "bytejson",
      l = !(!i || i === Qw.none);
    return this.dataView
      .parse(t, {
        type: s,
        layerType: "Point",
        options: {
          layerType: "Point",
          coordsField: {
            lngField: n,
            latField: r,
          },
        },
      })
      .transform({
        type: "filter",
        options: {
          callback: l && ((t) => Kw(t, a.features[0], i)),
        },
      })
      .transform({
        type: "webgis",
        options: {
          as: "coordinates",
        },
      }).latestData;
  }
  __getScaleData(t) {
    const { fields: e, style: i } = this.state,
      { colorWeight: n, heightWeight: r, size: o } = i;
    return this.scaleService.apply(
      [
        {
          visual: n,
          scaleField: e.colorWeightField,
          dataField: "_weightColor_",
        },
        {
          visual: r,
          scaleField: e.heightWeightField,
          dataField: "_weightHeight_",
        },
        {
          visual: o,
          scaleField: e.sizeField,
          dataField: "_size_",
        },
      ],
      t
    );
  }
}
wY([aV("viewportChange"), lq], AY.prototype, "__handleZoomChange", 1),
  wY([lq], AY.prototype, "renderHeatmapRT", 1),
  wY([lq], AY.prototype, "__getParseData", 1),
  wY([lq], AY.prototype, "__getScaleData", 1),
  ((SY = _Y || (_Y = {}))[(SY["bottom-left"] = 0)] = "bottom-left"),
  (SY[(SY["bottom-right"] = 1)] = "bottom-right"),
  (SY[(SY["top-left"] = 2)] = "top-left"),
  (SY[(SY["top-right"] = 3)] = "top-right");
const EY = {
  common: af(Sk, {
    offset: [14, 14, 0],
  }),
  data: {
    type: xk.GEOBUF_URL,
    data: `https://lf3-dpfe.${atob(
      "Ynl0ZXRvcy5jb20="
    )}/obj/gis/data/chinasouthseaaggregate_aggregatecssea_kld_gc.pbf`,
  },
  style: {
    fill: {
      color: "rgba(8,34,47,1)",
    },
    stroke: {
      color: "rgba(36,157,182,1)",
      width: 1,
    },
    border: {
      color: "rgba(36,157,182,1)",
      width: 1,
    },
    background: {
      color: "rgba(7,28,37,1)",
    },
  },
  scale: 6,
  position: _Y["bottom-right"],
  poi: {
    enabled: !0,
    data: {
      type: xk.GEOBUF_URL,
      data: `https://lf3-dpfe.${atob(
        "Ynl0ZXRvcy5jb20="
      )}/obj/gis/data/chinasouthseaaggregate_aggregatecssea_name_kld_gc.pbf`,
    },
    hideOnMove: !1,
    alignment: "middle",
    offsetX: 0,
    offsetY: 0,
    coverEnable: !0,
    orient: "vertical",
    major: {
      enabled: !0,
      fontFamily: gk,
      fontSize: 7,
      color: fk,
      fontWeight: dk,
      nameMap: {},
      offsetX: 0,
      offsetY: 0,
    },
    minor: {
      enabled: !1,
    },
  },
};
class DY {
  constructor(t, e) {
    (this.multiLinePoints = t),
      (this.rawMaterial = e),
      (this.geometry = this.createGeometry()),
      (this.material = this.createMaterial()),
      (this.mesh = new Wn(this.geometry, this.material));
  }
  createMaterial() {
    const { color: t, lineWidth: e, resolution: i } = this.rawMaterial,
      n = EA(t);
    return new Jn({
      uniforms: {
        uColor: {
          value: n.color,
        },
        uOpacity: {
          value: n.opacity,
        },
        uLineWidth: {
          value: e,
        },
        uResolution: {
          value: new Le(...i),
        },
      },
      vertexShader:
        "attribute float side;\nattribute vec3 prevPoint;\nattribute vec3 nextPoint;\nuniform float uLineWidth;\nuniform vec2 uResolution;\n\nvoid main() {\n\n   \n  float aspect = uResolution.x / uResolution.y;\n\n  mat4 mvpMatrix = projectionMatrix * modelViewMatrix;\n  \n  vec4 currentV4 = mvpMatrix * vec4(position, 1.0);\n  vec4 prevV4 = mvpMatrix * vec4(prevPoint, 1.0);\n  vec4 nextV4 = mvpMatrix * vec4(nextPoint, 1.0);\n\n  \n  vec2 currentV2 = currentV4.xy / currentV4.w;\n  vec2 prevV2 = prevV4.xy / prevV4.w;\n  vec2 nextV2 = nextV4.xy / nextV4.w;\n\n  vec2 dir;\n\n  \n  if(currentV2 == prevV2) {\n    dir = normalize(nextV2 - currentV2);\n  }\n  \n  else if(currentV2 == nextV2) {\n\n    dir = normalize(currentV2 - prevV2);\n  }\n  \n  else {\n\n  \n    vec2 dir1 = normalize(nextV2 - currentV2);\n  \n    vec2 dir2 = normalize(currentV2 - prevV2);\n    dir = normalize(dir1 + dir2);\n\n  }\n\n  \n  \n  \n  \n  \n  \n\n  dir.x *= aspect;\n  \n  dir = normalize(dir);\n\n  vec2 normal = vec2(-dir.y, dir.x);\n\n  normal *= uLineWidth;\n  normal.x /= aspect;\n  normal /= uResolution.y;\n\n  dir.x /= aspect;\n\n  vec4 offset = vec4(normal * side, 0.0, 0.0);\n  gl_Position = currentV4 + offset;\n\n}",
      fragmentShader:
        "precision highp float;\n\nuniform vec3 uColor;\nuniform float uOpacity;\n\nvoid main() {\n  vec4 color = vec4(uColor, 1.0);\n      \n      \n      \n  gl_FragColor = vec4(color.xyz, uOpacity);\n\n}",
      transparent: n.transparent,
    });
  }
  createGeometry() {
    const t = new En(),
      e = [],
      i = [],
      n = [],
      r = [],
      o = [];
    return (
      this.multiLinePoints.forEach((t) => {
        const a = t.length,
          s = 3 * a * 2,
          l = new Array(s),
          u = new Array(s),
          c = new Array(s),
          h = new Array(s),
          p = new Array(1 * a * 2);
        for (let i = 0; i < 2 * a; i += 2) {
          (p[i] = 1), (p[i + 1] = -1);
          const n = t[i / 2],
            r = t[(0 === i ? i : i - 2) / 2],
            o = t[(i === 2 * (a - 1) ? i : i + 2) / 2];
          if (i > 0) {
            const t = i - 2 + e.length / 3;
            h.push(t, t + 1, t + 2), h.push(t + 2, t + 1, t + 3);
          }
          const s = 3 * i;
          (l[s] = n[0]),
            (l[s + 1] = n[1]),
            (l[s + 2] = 0),
            (l[s + 3] = n[0]),
            (l[s + 4] = n[1]),
            (l[s + 5] = 0),
            (u[s] = r[0]),
            (u[s + 1] = r[1]),
            (u[s + 2] = 0),
            (u[s + 3] = r[0]),
            (u[s + 4] = r[1]),
            (u[s + 5] = 0),
            (c[s] = o[0]),
            (c[s + 1] = o[1]),
            (c[s + 2] = 0),
            (c[s + 3] = o[0]),
            (c[s + 4] = o[1]),
            (c[s + 5] = 0);
        }
        e.push(...l), i.push(...u), n.push(...c), o.push(...p), r.push(...h);
      }),
      t.setAttribute("position", new bn(e, 3)),
      t.setAttribute("prevPoint", new bn(i, 3)),
      t.setAttribute("nextPoint", new bn(n, 3)),
      t.setAttribute("side", new bn(o, 1)),
      t.setIndex(r),
      t
    );
  }
}
class TY extends NW {
  constructor(t, e) {
    super(t, e),
      (this.gis = t),
      (this.props = e),
      (this.__isReady = !1),
      (this.__cb = []),
      this.__init();
  }
  async __init() {
    var t, e;
    this._initialState(),
      this._initLayerGroup(),
      await this.loadGeoData(),
      (
        null == (e = null == (t = this.gis) ? void 0 : t.layerManager)
          ? void 0
          : e.baseMapLayer
      )
        ? (await this._initAttach(),
          this.gis.ee.on("resize", ({ width: t, height: e }) => {
            this.__updatePosition(), this.__updateResolution(t, e);
          }),
          (this.__isReady = !0),
          setTimeout(() => {
            for (let t = 0; t < this.__cb.length; t++) this.__cb[t](this);
            (this.__cb = []), this.ee.emit("loaded", "");
          }, 0))
        : this.logService.error("baseMapLayer is required");
  }
  then(t) {
    this.__isReady
      ? setTimeout(() => {
          t(this);
        }, 0)
      : this.__cb.push(t);
  }
  async _initAttach() {
    const {
        scale: t,
        style: { stroke: e, border: i },
      } = this.state,
      n = e.width / t / 2,
      r = i.width / t;
    (this.borderBox = [
      this.geoBBox[0] - n - r,
      this.geoBBox[1] - n - r,
      this.geoBBox[2] + n + r,
      this.geoBBox[3] + n + r,
    ]),
      (this.borderBoxWidth = this.borderBox[2] - this.borderBox[0]),
      (this.borderBoxHeight = this.borderBox[3] - this.borderBox[1]),
      (this.borderBoxCenter = [
        (this.borderBox[0] + this.borderBox[2]) / 2,
        (this.borderBox[1] + this.borderBox[3]) / 2,
        0,
      ]),
      this.initFullAndStroke(),
      this.initBackground(),
      this.initBorder(),
      this.coreGroup.scale.set(t, t, 1),
      await this.initPOI(),
      this.__updatePosition();
  }
  updateArea() {}
  __updatePosition() {
    const { renderSystem: t } = this.gis,
      e = t.coreRenderer._width,
      i = t.coreRenderer._height,
      {
        position: n,
        scale: r,
        common: { offset: o },
      } = this.state,
      [a, s] = o;
    (this.realWidth = this.borderBoxWidth * r),
      (this.realHeight = this.borderBoxHeight * r);
    let l = 0,
      u = 0;
    switch (n) {
      case _Y["bottom-left"]:
        (l = -e / 2 + a + this.realWidth / 2),
          (u = -i / 2 + s + this.realHeight / 2);
        break;
      case _Y["bottom-right"]:
        (l = e / 2 - a - this.realWidth / 2),
          (u = -i / 2 + s + this.realHeight / 2);
        break;
      case _Y["top-left"]:
        (l = -e / 2 + a + this.realWidth / 2),
          (u = i / 2 - s - this.realHeight / 2);
        break;
      case _Y["top-right"]:
        (l = e / 2 - a - this.realWidth / 2),
          (u = i / 2 - s - this.realHeight / 2);
        break;
      default:
        this.logService.error(`传入${n}无法解析`);
    }
    (this.realCenter = [l, u]), this.group.position.set(l, u, 0);
  }
  _updateOffset() {}
  _initialState() {
    super._initialState(EY);
  }
  _initLayerGroup() {
    super._initLayerGroup({
      layerName: "attach-layer",
      layerType: "env",
      isHudScene: !0,
    }),
      (this.poiGroup = new eV(cU.ATTACH_LAYER_POI)),
      this.group.add(this.poiGroup);
  }
  _updatePOI() {}
  async loadGeoData() {
    const { data: t, poi: e } = this.state;
    await ZV(t, {
      useProject: !1,
    });
    const i = t.__geojson_process__;
    (this.geoBBox = am.bbox(i)),
      await ZV(e.data, {
        useProject: !1,
      });
  }
  initFullAndStroke() {
    const {
        data: t,
        style: { fill: e, stroke: i },
      } = this.state,
      { renderSystem: n } = this.gis,
      r = [],
      o = {
        index: [],
        position: [],
      };
    t.__geojson_process__.features.forEach((t) => {
      const e = t.geometry.coordinates;
      r.push(...e);
      const { vertices: i, holes: n, dimensions: a } = _l.flatten(e),
        s = _l.default(i, n, a),
        { index: l, position: u } = o,
        c = u.length / 3;
      let h;
      const p = [];
      for (h = 0; h < i.length; h += a)
        (p[0] = i[h]), (p[1] = i[h + 1]), (p[2] = 0), u.push(...p);
      let d, f, g;
      for (h = 2; h < s.length; h += 3)
        (d = s[h - 2] + c),
          (f = s[h - 1] + c),
          (g = s[h] + c),
          l.push(d, f, g),
          (d *= 3),
          (f *= 3),
          (g *= 3);
    });
    const a = RV(o),
      s = EA(e.color);
    (this.fillMesh = new Wn(
      a,
      new pn({
        color: s.color,
        opacity: s.opacity,
        transparent: s.transparent,
      })
    )),
      (this.fillMesh.name = "attach-fill-mesh"),
      this.fillMesh.setRenderIndex(cU.ATTACH_LAYER_FILL_MESH),
      this.fillMesh.position.set(
        -this.borderBoxCenter[0],
        -this.borderBoxCenter[1],
        0
      ),
      this.coreGroup.add(this.fillMesh),
      (this.strokeMesh = new DY(r, {
        color: i.color,
        lineWidth: i.width,
        resolution: n.getContainerSize(),
      }).mesh),
      (this.strokeMesh.name = "attach-stroke-mesh"),
      this.strokeMesh.position.set(
        -this.borderBoxCenter[0],
        -this.borderBoxCenter[1],
        0
      ),
      this.strokeMesh.setRenderIndex(cU.ATTACH_LAYER_STROKE_MESH),
      this.coreGroup.add(this.strokeMesh);
  }
  initBackground() {
    const {
        style: { background: t },
      } = this.state,
      e = EA(t.color);
    (this.backgroundMesh = new Wn(
      new dr(this.borderBoxWidth, this.borderBoxHeight),
      new pn({
        color: e.color,
        opacity: e.opacity,
        transparent: e.transparent,
      })
    )),
      (this.backgroundMesh.name = "attach-backgroud-mesh"),
      this.backgroundMesh.setRenderIndex(cU.ATTACH_LAYER_BACKGROUND_MESH),
      this.coreGroup.add(this.backgroundMesh);
  }
  initBorder() {
    const {
        style: { border: t },
        scale: e,
      } = this.state,
      i = [this.borderBox[0], this.borderBox[1], 0],
      n = [this.borderBox[2], this.borderBox[1], 0],
      r = [this.borderBox[2], this.borderBox[3], 0],
      o = [this.borderBox[0], this.borderBox[3], 0],
      a = t.width / e,
      s = [this.borderBox[0] + a, this.borderBox[1] + a, 0],
      l = [this.borderBox[2] - a, this.borderBox[1] + a, 0],
      u = [this.borderBox[2] - a, this.borderBox[3] - a, 0],
      c = [this.borderBox[0] + a, this.borderBox[3] - a, 0],
      h = new En(),
      p = i.concat(n, r, o, s, l, u, c);
    h.setIndex(
      new mn(
        [
          0, 1, 4, 4, 1, 5, 5, 1, 6, 6, 1, 2, 3, 6, 2, 3, 7, 6, 3, 4, 7, 0, 4,
          3,
        ],
        1
      )
    ),
      h.setAttribute("position", new bn(p, 3));
    const d = EA(t.color);
    (this.borderMesh = new Wn(
      h,
      new pn({
        color: d.color,
        opacity: d.opacity,
        transparent: d.transparent,
      })
    )),
      (this.borderMesh.name = "attach-border-mesh"),
      this.borderMesh.setRenderIndex(cU.ATTACH_LAYER_BORDER_MESH),
      this.borderMesh.position.set(
        -this.borderBoxCenter[0],
        -this.borderBoxCenter[1],
        0
      ),
      this.coreGroup.add(this.borderMesh);
  }
  async initPOI() {
    var t, e, i, n, r;
    const { scale: o, poi: a } = this.state;
    if (!(null == (t = this.state.poi) ? void 0 : t.enabled))
      return void this.clearPoiGroup();
    this.clearPoiGroup();
    const s =
      null !=
      (n = null == (e = null == a ? void 0 : a.major) ? void 0 : e.aliasMap)
        ? n
        : (null == (i = null == a ? void 0 : a.major) ? void 0 : i.nameMap)
        ? pf(a.major.nameMap)
        : null;
    for (let l = 0; l < a.data.__geojson__.features.length; l++) {
      const t = a.data.__geojson__.features[l],
        [e, i] = t.geometry.coordinates;
      await this._addPoiMesh({
        pointPosition: {
          x: e * o,
          y: i * o,
          z: 0,
        },
        majorContent:
          null != (r = null == s ? void 0 : s[t.properties.name])
            ? r
            : t.properties.name,
      });
    }
    this.poiGroup.position.set(
      -this.borderBoxCenter[0] * o,
      -this.borderBoxCenter[1] * o,
      0
    );
  }
  updateBaseHeight() {}
  add(t) {
    return this;
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  __updateResolution(t, e) {
    this.strokeMesh.material.uniforms.uResolution.value = [t, e];
  }
  clear() {
    this.clearCoreGroup(), this.clearPoiGroup(), this.clearInteractionGroup();
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          [["common", "offset"], ["position"]],
          "diffAnyoneDeep",
          async (t) => {
            this.__updatePosition();
          }
        ),
        this._propsWatch.defaultRule("poi", "diffDeep", async (t) => {
          await this.initPOI();
        }),
        this._propsWatch.defaultRule("scale", "diff", async (t) => {
          const e = t.scale;
          this.coreGroup.scale.set(e, e, 1),
            await this.initPOI(),
            this.__updatePosition();
        }),
        this._propsWatch.defaultRule(
          ["data", "style"],
          "diffAnyoneDeep",
          () => {
            this.clear(), this._initAttach();
          }
        ),
      ]);
  }
}
const PY = {
  common: Sk,
  data: [],
  originPoints: [],
  fields: OW,
  style: {
    fill: {
      color: "rgba(0,255,0,0.3)",
    },
    stroke: {
      color: "rgba(0,255,0,1)",
      width: 4,
    },
  },
  poi: {
    enabled: !1,
    hideOnMove: !1,
    alignment: "middle",
    offsetX: 0,
    offsetY: 0,
    coverEnable: !1,
    orient: "vertical",
    major: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    minor: {
      enabled: !0,
      color: fk,
      fontSize: pk,
      fontWeight: dk,
      format: null,
      offsetX: 0,
      offsetY: 0,
    },
    custom: {
      enabled: !1,
      markerType: "css2d",
      element: null,
    },
  },
  clipMode: Qw.intersect,
  interaction: {
    hover: {
      enabled: !1,
      trigger: "mousemove",
      effect: {
        color: vk,
        poi: !1,
      },
    },
    select: {
      enabled: !1,
      trigger: "click",
      multi: !1,
      effect: {
        color: bk,
        poi: !1,
      },
    },
  },
};
var LY = Object.defineProperty,
  IY = Object.getOwnPropertyDescriptor,
  NY = (t, e, i, n) => {
    for (
      var r, o = n > 1 ? void 0 : n ? IY(e, i) : e, a = t.length - 1;
      a >= 0;
      a--
    )
      (r = t[a]) && (o = (n ? r(e, i, o) : r(o)) || o);
    return n && o && LY(e, i, o), o;
  };
class RY extends NW {
  constructor(t, e) {
    super(t, e), (this.gis = t), (this.props = e), this.__init();
  }
  __init() {
    this._initialState(),
      this._initLayerGroup(),
      super.registerInteraction(this.state.interaction, this.fillMeshGroup, !1),
      super.emitPropsWatch();
  }
  _initialState() {
    super._initialState(PY);
  }
  _initLayerGroup() {
    const { custom: t } = this.state.poi;
    super._initLayerGroup({
      layerName: "polygon-layer",
      layerType: "polygon",
      label: t,
    }),
      this.__releaseLayerGroup();
  }
  __releaseLayerGroup() {
    (this.fillMeshGroup = new As()),
      (this.fillMeshGroup.name = "polygon-fill"),
      super.registerInteraction(this.state.interaction, this.fillMeshGroup, !1),
      (this.strokeMeshGroup = new As()),
      (this.strokeMeshGroup.name = "polygon-stroke"),
      this.coreGroup.add(this.fillMeshGroup, this.strokeMeshGroup);
  }
  updateArea() {
    super.updateArea(), this.__refreshData();
  }
  add(t) {
    const e = t;
    if (!e || 0 === e.length) return this;
    this.state.data.push(...e);
    const i = this.__getParseData(e),
      n = this.__getScaleData(i);
    this.state.scaleData.push(...n);
    const r = this.__getRenderData(n);
    return (this.state.renderData = r), this.__draw(), this;
  }
  async __draw() {
    const {
      poi: { enabled: t, major: e, minor: i },
      renderData: n,
      originPoints: r,
      style: { fill: o, stroke: a },
    } = this.state;
    if (n && 0 !== n.length) {
      for (let s = 0; s < n.length; s++) {
        const l = n[s],
          u = r[s];
        if (0 === l.length) continue;
        const c = new qs(),
          h = [];
        for (let t = 0; t < l.length; t++) {
          const [e, i] = l[t].coordinates;
          0 === t && c.moveTo(e, i), h.push(e, i, 0), c.lineTo(e, i);
        }
        const p = new YD();
        p.setPositions(h);
        const d = EA(a.color),
          f = new TD({
            color: new ln(d.color).getHex(),
            opacity: DA(d, a.opacity),
            transparent: d.transparent,
            linewidth: a.width,
          });
        f.resolution.set(
          this.gis.props.containerDom.clientWidth,
          this.gis.props.containerDom.clientHeight
        );
        const g = new XD(p, f);
        g.setRenderIndex(lU.POLYGON_STROKE);
        const m = new NA(c),
          y = EA(o.color),
          v = new pn({
            color: y.color,
            opacity: y.opacity,
            transparent: y.transparent,
          }),
          b = new Wn(m, v);
        if (
          ((b.ext = of(l[0].ext)),
          b.setRenderIndex(lU.POLYGON_MESH),
          this.fillMeshGroup.add(b),
          this.strokeMeshGroup.add(g),
          t)
        ) {
          const { layerManager: t } = this.gis,
            { lng: n, lat: r, majorPOI: o, minorPOI: a } = u;
          u._relatedMeshId = b.id;
          const [s, l] = t.geo.project([n, r]),
            c = {
              x: s,
              y: l,
              z: 0,
            };
          (c.z += this.coreGroup.position.z),
            await this._addPoiMesh({
              pointPosition: c,
              majorContent: e.format ? e.format(o) : o,
              minorContent: i.format ? i.format(a) : a,
              ext: {
                relatedMeshIds: [b.id],
              },
            });
        }
      }
      this._updatePOI(!0);
    }
  }
  set(t) {
    return super.set(t), this;
  }
  get() {
    return super.get();
  }
  remove() {
    super.remove();
  }
  clear() {
    super.clear(), this.__releaseLayerGroup();
  }
  __getParseData(t) {
    const { fields: e, originPoints: i } = this.state,
      { lngField: n, latField: r } = e,
      { clipMode: o } = this.state,
      { globalOpts: a } = this.gis,
      { boundary: s } = a,
      l = !(!o || o === Qw.none),
      u = "Point",
      c = [];
    return (
      t.forEach((t, e) => {
        const a = i[e],
          h = Yw(t[0]) ? "geojson" : "bytejson",
          p = this.dataView
            .parse(t, {
              type: h,
              options: {
                layerType: u,
                coordsField: {
                  lngField: n,
                  latField: r,
                },
              },
            })
            .transform({
              type: "filter",
              options: {
                callback:
                  l &&
                  ((t) =>
                    Kw(
                      a
                        ? {
                            lng: a.lng,
                            lat: a.lat,
                            geometry: {
                              type: "Point",
                              coordinates: [a.lng, a.lat],
                            },
                          }
                        : t,
                      s.features[0],
                      o,
                      u
                    )),
              },
            })
            .transform({
              type: "webgis",
              options: {
                as: "coordinates",
              },
            }).latestData;
        c.push(p);
      }),
      c
    );
  }
  __getScaleData(t) {
    return t;
  }
  __getRenderData(t) {
    return t;
  }
  handleAnimation(t) {}
  __refreshData() {
    const { data: t } = this.state;
    this.clear(), this.add(t);
  }
  async initPOI() {
    var t;
    let e = this.state.originPoints;
    if (!(null == (t = this.state.poi) ? void 0 : t.enabled) || !e)
      return void this.clearPoiGroup();
    e instanceof Array || (e = [e]), this.clearPoiGroup();
    const {
      poi: { major: i, minor: n },
    } = this.state;
    for (let r = 0; r < e.length; r++) {
      const t = e[r],
        { layerManager: o } = this.gis,
        { lng: a, lat: s, majorPOI: l, minorPOI: u } = t,
        [c, h] = o.geo.project([a, s]),
        p = {
          x: c,
          y: h,
          z: this.coreGroup.position.z,
        };
      await this._addPoiMesh({
        pointPosition: p,
        majorContent: i.format ? i.format(l) : l,
        minorContent: n.format ? n.format(u) : u,
        ext: {
          relatedMeshIds: [t._relatedMeshId],
        },
      });
    }
    this._updatePOI(!0);
  }
  _initPropsWatchRule() {
    super._initPropsWatchRule(),
      this._propsWatch.addWatch([
        this._propsWatch.defaultRule(
          "data",
          "has",
          (t) => {
            this.clear(), this.add(t.data);
          },
          !0
        ),
        this._propsWatch.defaultRule(["style"], "diffDeep", () => {
          this.__refreshData();
        }),
        this._propsWatch.defaultRule("poi", "diffDeep", () => {
          this.initPOI();
        }),
      ]);
  }
}
NY([lq], RY.prototype, "__getParseData", 1),
  NY([lq], RY.prototype, "__getScaleData", 1);
const { typo: OY } = i,
  FY = {
    key: "tips",
    title_cn: "图表异常信息提示",
    title_en: "Tips",
    type: n.Panel,
    properties: [
      {
        key: "tips.backgroundColor",
        prefix: "text",
        layout_size: r.Large,
        title_cn: "背景颜色",
        title_en: "Background Color",
        type: n.Color,
        alias: o.TitleSplitHalf,
        path: "tips.backgroundColor",
      },
      {
        key: "tips.fontFamily",
        prefix: "icon",
        icon_type: "fontFamily",
        layout_size: r.Medium,
        title_cn: "字体",
        title_en: "Font Family",
        path: "tips.fontFamily",
        items: [],
        alias: o.FontFamily,
      },
      {
        key: "tips.fontWeight",
        prefix: "icon",
        icon_type: "fontWeight",
        layout_size: r.Medium,
        title_cn: "字重",
        title_en: "Font Weight",
        type: n.Enum,
        items: [
          "100",
          "200",
          "300",
          "400",
          "500",
          "600",
          "bold",
          "bolder",
          "normal",
        ].map((t) => ({
          value: t,
          title_en: t,
          title_cn: t,
        })),
        path: "tips.fontWeight",
      },
      {
        key: "tips.fontSize",
        prefix: "icon",
        icon_type: "fontSize",
        layout_size: r.Medium,
        title_cn: "字号",
        title_en: "Font Size",
        type: n.Number,
        min: 1,
        max: 1e3,
        mode: a.INTEGER,
        unit: "px",
        alias: o.FontSize,
        path: "tips.fontSize",
      },
      {
        key: "tips.color",
        layout_size: r.Medium,
        title_cn: "文字颜色",
        title_en: "Text Color",
        type: n.Color,
        path: "tips.color",
      },
    ],
  },
  zY = [
    {
      key: "viewport",
      title_cn: "视图配置",
      title_en: "Viewport",
      type: n.Panel,
      properties: [
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "经度",
          title_en: "center lng",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLng",
          path: "viewport.centerLng",
          ...U("-180,180"),
        },
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "纬度",
          title_en: "center lat",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLat",
          path: "viewport.centerLat",
          ...U("-90,90"),
        },
        {
          title_cn: "旋转角度",
          title_en: "rotation",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minRotation",
          maxPath: "viewport.maxRotation",
          key: "viewport.rotation",
          path: "viewport.rotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最小旋转角度",
          title_en: "min rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minRotation",
          path: "viewport.minRotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最大旋转角度",
          title_en: "max rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxRotation",
          path: "viewport.maxRotation",
          ...U("-90,90"),
        },
        {
          key: "viewport.pitch",
          title_cn: "倾斜角度",
          title_en: "pitch",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minPitch",
          maxPath: "viewport.maxPitch",
          path: "viewport.pitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最小倾斜角度",
          title_en: "min pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minPitch",
          path: "viewport.minPitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最大倾斜角度",
          title_en: "max pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxPitch",
          path: "viewport.maxPitch",
          ...U("0,80"),
        },
        {
          key: "viewport.zoom",
          title_cn: "缩放层级",
          title_en: "zoom",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minZoom",
          maxPath: "viewport.maxZoom",
          path: "viewport.zoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最小缩放层级",
          title_en: "min zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minZoom",
          path: "viewport.minZoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最大缩放层级",
          title_en: "max zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxZoom",
          path: "viewport.maxZoom",
          ...U("0,24"),
        },
      ],
    },
    {
      key: "gesture",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "手势交互",
          title_en: "Gesture Enable",
          type: n.Boolean,
          key: "interaction.sceneChangeEnable",
          path: "interaction.sceneChangeEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可缩放",
          title_en: "Zoom Enable",
          type: n.Boolean,
          key: "interaction.zoomEnable",
          path: "interaction.zoomEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可平移",
          title_en: "Translation Enable",
          type: n.Boolean,
          key: "interaction.translationEnable",
          path: "interaction.translationEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可倾斜",
          title_en: "Pitch Enable",
          type: n.Boolean,
          key: "interaction.pitchEnable",
          path: "interaction.pitchEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可旋转",
          title_en: "Rotation Enable",
          type: n.Boolean,
          key: "interaction.rotationEnable",
          path: "interaction.rotationEnable",
        },
      ],
    },
    {
      type: n.Panel,
      key: "data-region",
      properties: [
        {
          key: "interaction.initialLevelName",
          layout_size: r.Large,
          alias: o.TitleSplitHalf,
          title_cn: "地图数据",
          title_en: "Map Data",
          tag: "panel",
          type: "chinaMapCascader",
          path: "interaction.initialLevelName",
        },
        {
          key: "data.region",
          path: "data.region",
          alias: o.TitleSplitHalf,
          layout_size: r.Large,
          title_cn: "大区配置",
          title_en: "Initial Type",
          type: "mapRegionModal",
          tag: "panel",
        },
      ],
    },
    {
      key: "baseMapLayer",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "行政地图",
          title_en: "baseMapLayer show",
          type: n.Boolean,
          key: "baseMapLayer.show",
          path: "baseMapLayer.show",
        },
        {
          key: "districtOutline",
          title_cn: "外描边",
          title_en: "District Outline",
          type: n.Panel,
          properties: [
            {
              key: "districtOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "districtOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "districtOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "districtOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "districtOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "mapStyle.borderColor",
            },
          ],
        },
        {
          key: "provinceOutline",
          title_cn: "内描边",
          title_en: "Province Outline",
          type: n.Panel,
          properties: [
            {
              key: "provinceOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "provinceOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "provinceOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "provinceOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "provinceOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "provinceOutline.borderColor",
            },
          ],
        },
        {
          key: "innerShadow",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边发光",
              title_en: "innerShadow",
              type: n.Boolean,
              key: "innerShadow.enable",
              path: "innerShadow.enable",
            },
            {
              key: "innerShadow.width",
              path: "innerShadow.width",
              type: n.Number,
              title_cn: "发散范围",
              title_en: "innerShadow width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,1"),
            },
            {
              key: "innerShadow.color",
              path: "innerShadow.color",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "发光颜色",
              title_en: "innerShadow color",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "boundaryStreamer",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边流光",
              title_en: "boundaryStreamer",
              type: n.Boolean,
              key: "boundaryStreamer.enable",
              path: "boundaryStreamer.enable",
            },
            {
              key: "boundaryStreamer.length",
              path: "boundaryStreamer.length",
              type: n.Number,
              title_cn: "流光长度",
              title_en: "boundaryStreamer length",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.width",
              path: "boundaryStreamer.width",
              type: n.Number,
              title_cn: "流光宽度",
              title_en: "boundaryStreamer width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.speed",
              path: "boundaryStreamer.speed",
              type: n.Number,
              title_cn: "流光速度",
              title_en: "boundaryStreamer speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("-100,100"),
            },
            {
              key: "boundaryStreamer.headColor",
              path: "boundaryStreamer.headColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "头部颜色",
              title_en: "boundaryStreamer headColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
            {
              key: "boundaryStreamer.endColor",
              path: "boundaryStreamer.endColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "尾部颜色",
              title_en: "boundaryStreamer endColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "extrude",
          type: n.Panel,
          title_cn: "地图厚度",
          title_en: "Extrude",
          properties: [
            {
              key: "extrude.topColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "顶部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.topColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.bottomColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "底部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.bottomColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.height",
              path: "extrude.height",
              title_cn: "厚度",
              title_en: "Height",
              layout_size: r.Large,
              prefix: "text",
              type: n.Number,
              alias: o.TitleSplitHalf,
              ...U("0,10"),
            },
            {
              key: "mapStyle",
              title_cn: "填充样式",
              title_en: "Map display",
              type: n.Panel,
              properties: [
                {
                  key: "mapStyle.backgroundColor",
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "填充色",
                  title_en: "Background color",
                  type: n.Color,
                  path: "mapStyle.backgroundColor",
                  alias: o.TitleSplitHalf,
                },
                {
                  key: "mapStyle.metalness",
                  path: "mapStyle.metalness",
                  title_cn: "金属质感",
                  title_en: "metalness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  key: "mapStyle.roughness",
                  path: "mapStyle.roughness",
                  title_cn: "粗糙程度",
                  title_en: "roughness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  type: n.Panel,
                  key: "mapStyle-image",
                  properties: [
                    {
                      key: "mapStyle-image-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-image-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.backgroundType",
                          path: "mapStyle.backgroundType",
                        },
                        {
                          key: "mapStyle-image-tab-1",
                          type: n.Panel,
                          title_cn: "填充贴图",
                          title_en: "Background image",
                          properties: [
                            {
                              key: "mapStyle.backgroundImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "Background image",
                              type: "image",
                              path: "mapStyle.backgroundImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-image-tab-2",
                          type: n.Panel,
                          title_cn: "填充瓦片服务",
                          title_en: "Background tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.backgroundTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "Background tile",
                              path: "mapStyle.backgroundTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle-tile-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-tile-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.normalType",
                          path: "mapStyle.normalType",
                        },
                        {
                          key: "mapStyle-tile-tab-1",
                          type: n.Panel,
                          title_cn: "法线贴图",
                          title_en: "Normal image",
                          properties: [
                            {
                              key: "mapStyle.normalImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "normal image",
                              type: "image",
                              path: "mapStyle.normalImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-tile-tab-2",
                          type: n.Panel,
                          title_cn: "法线瓦片服务",
                          title_en: "Normal Tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.normalTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "normal tile",
                              path: "mapStyle.normalTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle.normalScale",
                      path: "mapStyle.normalScale",
                      title_cn: "法线强度",
                      title_en: "normalScale",
                      layout_size: r.Large,
                      prefix: "text",
                      type: n.Number,
                      alias: o.TitleSplitHalf,
                      ...U("0,100"),
                    },
                  ],
                },
                {
                  key: "mapStyle.fontStyle",
                  title_cn: "标注文本",
                  title_en: "Font style",
                  type: n.Panel,
                  alias: o.Typography,
                  properties: [
                    {
                      key: "mapStyle.fontStyle.fontFamily",
                      prefix: "icon",
                      icon_type: "fontFamily",
                      layout_size: r.Medium,
                      ...OY.fontFamily,
                      path: "mapStyle.fontStyle.fontFamily",
                    },
                    {
                      key: "mapStyle.fontStyle.fontWeight",
                      prefix: "icon",
                      icon_type: "fontWeight",
                      layout_size: r.Medium,
                      ...OY.fontWeight,
                      path: "mapStyle.fontStyle.fontWeight",
                    },
                    {
                      key: "mapStyle.fontStyle.color",
                      layout_size: r.Medium,
                      ...OY.textColor,
                      path: "mapStyle.fontStyle.color",
                    },
                    {
                      key: "mapStyle.fontStyle.fontSize",
                      prefix: "icon",
                      icon_type: "fontSize",
                      layout_size: r.Medium,
                      ...OY.fontSize,
                      path: "mapStyle.fontStyle.fontSize",
                    },
                  ],
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "展示标注文本",
                  title_en: "Label Enable",
                  type: n.Boolean,
                  key: "mapStyle.labelEnable",
                  path: "mapStyle.labelEnable",
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "文字遮挡隐藏",
                  title_en: "Text Cover Enable",
                  type: n.Boolean,
                  key: "mapStyle.coverEnable",
                  path: "mapStyle.coverEnable",
                },
              ],
            },
          ],
        },
      ],
    },
    {
      key: "componentBackground",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "componentBackground.hasColor",
          path: "componentBackground.hasColor",
          prefix: "text",
          title_cn: "背景填充",
          title_en: "componentBackground hasColor",
          type: n.Boolean,
        },
        {
          key: "componentBackground.backgroundColor",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "背景颜色",
          title_en: "Background color",
          path: "componentBackground.backgroundColor",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    {
      key: "nanhai",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "南海附图",
          title_en: "Nanhai",
          type: n.Boolean,
          key: "nanhai.enable",
          path: "nanhai.enable",
        },
        {
          key: "nanhai.position",
          path: "nanhai.position",
          title_cn: "相对位置",
          title_en: "Nanhai position",
          type: n.Enum,
          prefix: "text",
          layout_size: r.Large,
          alias: o.TitleSplitHalf,
          items: [
            {
              title_cn: "左上",
              title_en: "Nahai position top-left",
              value: _Y["top-left"],
            },
            {
              title_cn: "右上",
              title_en: "Nahai position top-right",
              value: _Y["top-right"],
            },
            {
              title_cn: "右下",
              title_en: "Nahai position bottom-right",
              value: _Y["bottom-right"],
            },
            {
              title_cn: "左下",
              title_en: "Nahai position bottom-left",
              value: _Y["bottom-left"],
            },
          ],
        },
        {
          key: "nanhai.scale",
          path: "nanhai.scale",
          title_cn: "缩放比例",
          title_en: "Scale",
          layout_size: r.Large,
          prefix: "text",
          type: n.Number,
          alias: o.TitleSplitHalf,
          ...U("0,100"),
        },
        {
          key: "nanhai.offsetX",
          path: "nanhai.offsetX",
          type: n.Number,
          title_cn: "横向边距",
          title_en: "Offset X",
          layout_size: r.Medium,
          prefix: "text",
          min: 0,
          unit: "px",
        },
        {
          key: "nanhai.offsetY",
          path: "nanhai.offsetY",
          type: n.Number,
          title_cn: "纵向边距",
          title_en: "Offset Y",
          layout_size: r.Medium,
          prefix: "text",
          min: 0,
          unit: "px",
        },
        {
          key: "nanhai.background",
          path: "nanhai.background",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "背景颜色",
          title_en: "Nahai Background color",
          type: n.Color,
          alias: o.TitleSplitHalf,
        },
        {
          key: "nanhai.fill",
          path: "nanhai.fill",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "填充颜色",
          title_en: "Nahai fill color",
          type: n.Color,
          alias: o.TitleSplitHalf,
        },
        {
          key: "nanhai.stroke",
          title_cn: "描边样式",
          title_en: "Nanhai stroke",
          type: n.Panel,
          properties: [
            {
              key: "nanhai.stroke.width",
              path: "nanhai.stroke.width",
              layout_size: r.Medium,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "nanhai.stroke.color",
              path: "nanhai.stroke.color",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
            },
          ],
        },
        {
          key: "nanhai.border",
          title_cn: "边框样式",
          title_en: "Nanhai border",
          type: n.Panel,
          properties: [
            {
              key: "nanhai.border.width",
              path: "nanhai.border.width",
              layout_size: r.Medium,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "nanhai.border.color",
              path: "nanhai.border.color",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
            },
          ],
        },
        {
          key: "nanhai.fontStyle",
          title_cn: "标注文本",
          title_en: "Font style",
          type: n.Panel,
          alias: o.Typography,
          properties: [
            {
              key: "nanhai.fontStyle.fontFamily",
              prefix: "icon",
              icon_type: "fontFamily",
              layout_size: r.Medium,
              ...OY.fontFamily,
              path: "nanhai.fontStyle.fontFamily",
            },
            {
              key: "nanhai.fontStyle.fontWeight",
              prefix: "icon",
              icon_type: "fontWeight",
              layout_size: r.Medium,
              ...OY.fontWeight,
              path: "nanhai.fontStyle.fontWeight",
            },
            {
              key: "nanhai.fontStyle.color",
              layout_size: r.Medium,
              ...OY.textColor,
              path: "nanhai.fontStyle.color",
            },
            {
              key: "nanhai.fontStyle.fontSize",
              prefix: "icon",
              icon_type: "fontSize",
              layout_size: r.Medium,
              ...OY.fontSize,
              path: "nanhai.fontStyle.fontSize",
            },
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "展示标注文本",
              title_en: "Label Enable",
              type: n.Boolean,
              key: "nanhai.fontStyle.enable",
              path: "nanhai.fontStyle.enable",
            },
          ],
        },
      ],
    },
    {
      key: "light",
      title_cn: "光照阴影",
      title_en: "Light & Shadow",
      type: n.Panel,
      properties: [
        {
          key: "light.ambient.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "环境光颜色",
          title_en: "Ambient color",
          path: "light.ambient.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.ambient.intensity",
          type: n.Number,
          title_cn: "环境光强度",
          title_en: "Ambient Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.ambient.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "平行光颜色",
          title_en: "Directional color",
          path: "light.directional.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.directional.intensity",
          type: n.Number,
          title_cn: "平行光强度",
          title_en: "Directional Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.x",
          type: n.Number,
          title_cn: "平行光源位置X",
          title_en: "Directional X",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.x",
          ...U("-1,1"),
        },
        {
          key: "light.directional.y",
          type: n.Number,
          title_cn: "平行光源位置Y",
          title_en: "Directional Y",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.y",
          ...U("-1,1"),
        },
        {
          key: "light.directional.z",
          type: n.Number,
          title_cn: "平行光源位置Z",
          title_en: "Directional Z",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.z",
          ...U("0,1"),
        },
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "开启阴影",
          title_en: "Shadow Enable",
          type: n.Boolean,
          key: "light.shadow.enabled",
          path: "light.shadow.enabled",
        },
        {
          key: "light.shadow.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "阴影颜色",
          title_en: "Shadow color",
          path: "light.shadow.color",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    {
      key: "amap",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "高德底图",
          title_en: "AMap",
          type: n.Boolean,
          key: "amap.enable",
          path: "amap.enable",
        },
        {
          type: n.Panel,
          key: "amap-config",
          properties: [
            {
              key: "amap-style",
              tag: "panel",
              alias: "mapDataTab",
              path: "amap-style",
              layout_size: r.Large,
              properties: [
                {
                  key: "amap.type",
                  path: "amap.type",
                },
                {
                  key: "amap.default",
                  type: n.Panel,
                  title_cn: "标准模版",
                  properties: [
                    {
                      key: "amap.style",
                      path: "amap.style",
                      title_cn: "样式主题",
                      title_en: "AMap style",
                      type: n.Enum,
                      prefix: "text",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      items: [
                        {
                          title_cn: "幻影黑",
                          title_en: "AMap style dark",
                          value: "dark",
                        },
                        {
                          title_cn: "极夜蓝",
                          title_en: "AMap style darkblue",
                          value: "darkblue",
                        },
                        {
                          title_cn: "雅士灰",
                          title_en: "AMap style grey",
                          value: "grey",
                        },
                        {
                          title_cn: "草色青",
                          title_en: "AMap style fresh",
                          value: "fresh",
                        },
                        {
                          title_cn: "月光银",
                          title_en: "AMap style light",
                          value: "light",
                        },
                      ],
                    },
                  ],
                },
                {
                  key: "amap.custom",
                  type: n.Panel,
                  title_cn: "自定义",
                  properties: [
                    {
                      type: n.String,
                      key: "amap.custom.key",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "高德Key",
                      title_en: "AMap Key",
                      path: "amap.custom.key",
                    },
                    {
                      type: n.String,
                      key: "amap.custom.securityJsCode",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "高德安全密钥",
                      title_en: "AMap SecurityJsCode",
                      path: "amap.custom.securityJsCode",
                    },
                    {
                      type: n.String,
                      key: "amap.custom.id",
                      layout_size: r.Large,
                      alias: o.TitleSplitHalf,
                      title_cn: "样式ID",
                      title_en: "Style ID",
                      path: "amap.custom.id",
                    },
                  ],
                },
              ],
            },
            {
              key: "amap.content",
              title_cn: "内容控制",
              title_en: "AMap content",
              type: n.Panel,
              alias: o.Typography,
              properties: [
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "文字标注",
                  title_en: "AMap label",
                  type: n.Boolean,
                  key: "amap.content.label",
                  path: "amap.content.label",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "基础地图",
                  title_en: "AMap nebula",
                  type: n.Boolean,
                  key: "amap.content.nebula",
                  path: "amap.content.nebula",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "道路网络",
                  title_en: "AMap roadnet",
                  type: n.Boolean,
                  key: "amap.content.roadnet",
                  path: "amap.content.roadnet",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "实时交通",
                  title_en: "AMap roadnet",
                  type: n.Boolean,
                  key: "amap.content.traffic",
                  path: "amap.content.traffic",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "3D建筑",
                  title_en: "AMap buildings",
                  type: n.Boolean,
                  key: "amap.content.buildings",
                  path: "amap.content.buildings",
                },
                {
                  prefix: "text",
                  layout_size: r.Medium,
                  title_cn: "3D地形",
                  title_en: "AMap terrain",
                  type: n.Boolean,
                  key: "amap.content.terrain",
                  path: "amap.content.terrain",
                },
              ],
            },
          ],
        },
        {
          key: "amap.filter",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Medium,
              title_cn: "风格滤镜",
              title_en: "Filter",
              type: n.Boolean,
              key: "amap.filter.enable",
              path: "amap.filter.enable",
            },
            {
              key: "amap.filter.brightness",
              path: "amap.filter.brightness",
              type: n.Number,
              title_cn: "亮度",
              title_en: "brightness",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.contrast",
              path: "amap.filter.contrast",
              type: n.Number,
              title_cn: "对比度",
              title_en: "contrast",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.grayscale",
              path: "amap.filter.grayscale",
              type: n.Number,
              title_cn: "灰度",
              title_en: "grayscale",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
            {
              key: "amap.filter.hueRotate",
              path: "amap.filter.hueRotate",
              type: n.Number,
              title_cn: "色相",
              title_en: "hueRotate",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,360"),
            },
            {
              key: "amap.filter.invert",
              path: "amap.filter.invert",
              type: n.Number,
              title_cn: "反转",
              title_en: "invert",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
            {
              key: "amap.filter.saturate",
              path: "amap.filter.saturate",
              type: n.Number,
              title_cn: "饱和度",
              title_en: "saturate",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,10"),
            },
            {
              key: "amap.filter.sepia",
              path: "amap.filter.sepia",
              type: n.Number,
              title_cn: "墨度",
              title_en: "sepia",
              layout_size: r.Large,
              prefix: "text",
              alias: o.RangeInput,
              ...U("0,1"),
            },
          ],
        },
      ],
    },
    FY,
  ],
  { typo: kY } = i,
  BY = {
    key: "tips",
    title_cn: "图表异常信息提示",
    title_en: "Tips",
    type: n.Panel,
    properties: [
      {
        key: "tips.backgroundColor",
        prefix: "text",
        layout_size: r.Large,
        title_cn: "背景颜色",
        title_en: "Background Color",
        type: n.Color,
        alias: o.TitleSplitHalf,
        path: "tips.backgroundColor",
      },
      {
        key: "tips.fontFamily",
        prefix: "icon",
        icon_type: "fontFamily",
        layout_size: r.Medium,
        title_cn: "字体",
        title_en: "Font Family",
        path: "tips.fontFamily",
        items: [],
        alias: o.FontFamily,
      },
      {
        key: "tips.fontWeight",
        prefix: "icon",
        icon_type: "fontWeight",
        layout_size: r.Medium,
        title_cn: "字重",
        title_en: "Font Weight",
        type: n.Enum,
        items: [
          "100",
          "200",
          "300",
          "400",
          "500",
          "600",
          "bold",
          "bolder",
          "normal",
        ].map((t) => ({
          value: t,
          title_en: t,
          title_cn: t,
        })),
        path: "tips.fontWeight",
      },
      {
        key: "tips.fontSize",
        prefix: "icon",
        icon_type: "fontSize",
        layout_size: r.Medium,
        title_cn: "字号",
        title_en: "Font Size",
        type: n.Number,
        min: 1,
        max: 1e3,
        mode: a.INTEGER,
        unit: "px",
        alias: o.FontSize,
        path: "tips.fontSize",
      },
      {
        key: "tips.color",
        layout_size: r.Medium,
        title_cn: "文字颜色",
        title_en: "Text Color",
        type: n.Color,
        path: "tips.color",
      },
    ],
  },
  GY = [
    {
      key: "viewport",
      title_cn: "视图配置",
      title_en: "Viewport",
      type: n.Panel,
      properties: [
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "经度",
          title_en: "center lng",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLng",
          path: "viewport.centerLng",
          ...U("-180,180"),
        },
        {
          type: n.Number,
          alias: o.MapDynamicNumber,
          title_cn: "纬度",
          title_en: "center lat",
          layout_size: r.Medium,
          prefix: "text",
          key: "viewport.centerLat",
          path: "viewport.centerLat",
          ...U("-90,90"),
        },
        {
          title_cn: "旋转角度",
          title_en: "rotation",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minRotation",
          maxPath: "viewport.maxRotation",
          key: "viewport.rotation",
          path: "viewport.rotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最小旋转角度",
          title_en: "min rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minRotation",
          path: "viewport.minRotation",
          ...U("-90,90"),
        },
        {
          type: n.Number,
          title_cn: "最大旋转角度",
          title_en: "max rotation",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxRotation",
          path: "viewport.maxRotation",
          ...U("-90,90"),
        },
        {
          key: "viewport.pitch",
          title_cn: "倾斜角度",
          title_en: "pitch",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minPitch",
          maxPath: "viewport.maxPitch",
          path: "viewport.pitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最小倾斜角度",
          title_en: "min pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minPitch",
          path: "viewport.minPitch",
          ...U("0,80"),
        },
        {
          type: n.Number,
          title_cn: "最大倾斜角度",
          title_en: "max pitch",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxPitch",
          path: "viewport.maxPitch",
          ...U("0,80"),
        },
        {
          key: "viewport.zoom",
          title_cn: "缩放层级",
          title_en: "zoom",
          layout_size: r.Medium,
          prefix: "text",
          type: n.Number,
          alias: o.MapDynamicNumber,
          minPath: "viewport.minZoom",
          maxPath: "viewport.maxZoom",
          path: "viewport.zoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最小缩放层级",
          title_en: "min zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMin",
          key: "viewport.minZoom",
          path: "viewport.minZoom",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "最大缩放层级",
          title_en: "max zoom",
          layout_size: r.Small,
          prefix: "icon",
          icon_type: "axisDomainMax",
          key: "viewport.maxZoom",
          path: "viewport.maxZoom",
          ...U("0,24"),
        },
      ],
    },
    {
      key: "gesture",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "手势交互",
          title_en: "Gesture Enable",
          type: n.Boolean,
          key: "interaction.sceneChangeEnable",
          path: "interaction.sceneChangeEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可缩放",
          title_en: "Zoom Enable",
          type: n.Boolean,
          key: "interaction.zoomEnable",
          path: "interaction.zoomEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可平移",
          title_en: "Translation Enable",
          type: n.Boolean,
          key: "interaction.translationEnable",
          path: "interaction.translationEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可倾斜",
          title_en: "Pitch Enable",
          type: n.Boolean,
          key: "interaction.pitchEnable",
          path: "interaction.pitchEnable",
        },
        {
          prefix: "text",
          layout_size: r.Medium,
          title_cn: "可旋转",
          title_en: "Rotation Enable",
          type: n.Boolean,
          key: "interaction.rotationEnable",
          path: "interaction.rotationEnable",
        },
      ],
    },
    {
      type: n.Panel,
      key: "data-region",
      properties: [
        {
          key: "interaction.initialLevelName",
          layout_size: r.Large,
          alias: o.TitleSplitHalf,
          title_cn: "地图数据",
          title_en: "Map Data",
          tag: "panel",
          type: "worldMapCascader",
          path: "interaction.initialLevelName",
        },
        {
          key: "data.region",
          path: "data.region",
          alias: o.TitleSplitHalf,
          layout_size: r.Large,
          title_cn: "大区配置",
          title_en: "Initial Type",
          type: "mapRegionModal",
          tag: "panel",
        },
      ],
    },
    {
      key: "baseMapLayer",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "行政地图",
          title_en: "baseMapLayer show",
          type: n.Boolean,
          key: "baseMapLayer.show",
          path: "baseMapLayer.show",
        },
        {
          key: "districtOutline",
          title_cn: "外描边",
          title_en: "District Outline",
          type: n.Panel,
          properties: [
            {
              key: "districtOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "districtOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "districtOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "districtOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "districtOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "mapStyle.borderColor",
            },
          ],
        },
        {
          key: "provinceOutline",
          title_cn: "内描边",
          title_en: "Province Outline",
          type: n.Panel,
          properties: [
            {
              key: "provinceOutline.width",
              layout_size: r.Small,
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "provinceOutline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "provinceOutline.opacity",
              layout_size: r.Small,
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "provinceOutline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "provinceOutline.borderColor",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "provinceOutline.borderColor",
            },
          ],
        },
        {
          key: "innerShadow",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边发光",
              title_en: "innerShadow",
              type: n.Boolean,
              key: "innerShadow.enable",
              path: "innerShadow.enable",
            },
            {
              key: "innerShadow.width",
              path: "innerShadow.width",
              type: n.Number,
              title_cn: "发散范围",
              title_en: "innerShadow width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,1"),
            },
            {
              key: "innerShadow.color",
              path: "innerShadow.color",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "发光颜色",
              title_en: "innerShadow color",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "boundaryStreamer",
          type: n.Panel,
          alias: o.CollapsePanel,
          properties: [
            {
              prefix: "text",
              layout_size: r.Large,
              title_cn: "外描边流光",
              title_en: "boundaryStreamer",
              type: n.Boolean,
              key: "boundaryStreamer.enable",
              path: "boundaryStreamer.enable",
            },
            {
              key: "boundaryStreamer.length",
              path: "boundaryStreamer.length",
              type: n.Number,
              title_cn: "流光长度",
              title_en: "boundaryStreamer length",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.width",
              path: "boundaryStreamer.width",
              type: n.Number,
              title_cn: "流光宽度",
              title_en: "boundaryStreamer width",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("0,100"),
            },
            {
              key: "boundaryStreamer.speed",
              path: "boundaryStreamer.speed",
              type: n.Number,
              title_cn: "流光速度",
              title_en: "boundaryStreamer speed",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              ...U("-100,100"),
            },
            {
              key: "boundaryStreamer.headColor",
              path: "boundaryStreamer.headColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "头部颜色",
              title_en: "boundaryStreamer headColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
            {
              key: "boundaryStreamer.endColor",
              path: "boundaryStreamer.endColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "尾部颜色",
              title_en: "boundaryStreamer endColor",
              type: n.Color,
              alias: o.TitleSplitHalf,
            },
          ],
        },
        {
          key: "extrude",
          type: n.Panel,
          title_cn: "地图厚度",
          title_en: "Extrude",
          properties: [
            {
              key: "extrude.topColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "顶部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.topColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.bottomColor",
              prefix: "text",
              layout_size: r.Large,
              title_cn: "底部颜色",
              title_en: "Background color",
              type: n.Color,
              path: "extrude.bottomColor",
              alias: o.TitleSplitHalf,
            },
            {
              key: "extrude.height",
              path: "extrude.height",
              title_cn: "厚度",
              title_en: "Height",
              layout_size: r.Large,
              prefix: "text",
              type: n.Number,
              alias: o.TitleSplitHalf,
              ...U("0,10"),
            },
            {
              key: "mapStyle",
              title_cn: "填充样式",
              title_en: "Map display",
              type: n.Panel,
              properties: [
                {
                  key: "mapStyle.backgroundColor",
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "填充色",
                  title_en: "Background color",
                  type: n.Color,
                  path: "mapStyle.backgroundColor",
                  alias: o.TitleSplitHalf,
                },
                {
                  key: "mapStyle.metalness",
                  path: "mapStyle.metalness",
                  title_cn: "金属质感",
                  title_en: "metalness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  key: "mapStyle.roughness",
                  path: "mapStyle.roughness",
                  title_cn: "粗糙程度",
                  title_en: "roughness",
                  layout_size: r.Large,
                  prefix: "text",
                  type: n.Number,
                  alias: o.TitleSplitHalf,
                  ...U("0,1"),
                },
                {
                  type: n.Panel,
                  key: "mapStyle-image",
                  properties: [
                    {
                      key: "mapStyle-image-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-image-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.backgroundType",
                          path: "mapStyle.backgroundType",
                        },
                        {
                          key: "mapStyle-image-tab-1",
                          type: n.Panel,
                          title_cn: "填充贴图",
                          title_en: "Background image",
                          properties: [
                            {
                              key: "mapStyle.backgroundImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "Background image",
                              type: "image",
                              path: "mapStyle.backgroundImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-image-tab-2",
                          type: n.Panel,
                          title_cn: "填充瓦片服务",
                          title_en: "Background tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.backgroundTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "Background tile",
                              path: "mapStyle.backgroundTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle-tile-tab",
                      tag: "panel",
                      alias: "mapDataTab",
                      path: "mapStyle-tile-tab",
                      layout_size: r.Large,
                      properties: [
                        {
                          key: "mapStyle.normalType",
                          path: "mapStyle.normalType",
                        },
                        {
                          key: "mapStyle-tile-tab-1",
                          type: n.Panel,
                          title_cn: "法线贴图",
                          title_en: "Normal image",
                          properties: [
                            {
                              key: "mapStyle.normalImage",
                              layout_size: r.Large,
                              title_cn: "图片",
                              title_en: "normal image",
                              type: "image",
                              path: "mapStyle.normalImage",
                            },
                          ],
                        },
                        {
                          key: "mapStyle-tile-tab-2",
                          type: n.Panel,
                          title_cn: "法线瓦片服务",
                          title_en: "Normal Tile",
                          properties: [
                            {
                              type: n.String,
                              key: "mapStyle.normalTile",
                              layout_size: r.Large,
                              alias: o.TitleSplitHalf,
                              title_cn: "服务地址",
                              title_en: "normal tile",
                              path: "mapStyle.normalTile",
                            },
                          ],
                        },
                      ],
                    },
                    {
                      key: "mapStyle.normalScale",
                      path: "mapStyle.normalScale",
                      title_cn: "法线强度",
                      title_en: "normalScale",
                      layout_size: r.Large,
                      prefix: "text",
                      type: n.Number,
                      alias: o.TitleSplitHalf,
                      ...U("0,100"),
                    },
                  ],
                },
                {
                  key: "mapStyle.fontStyle",
                  title_cn: "标注文本",
                  title_en: "Font style",
                  type: n.Panel,
                  alias: o.Typography,
                  properties: [
                    {
                      key: "mapStyle.fontStyle.fontFamily",
                      prefix: "icon",
                      icon_type: "fontFamily",
                      layout_size: r.Medium,
                      ...kY.fontFamily,
                      path: "mapStyle.fontStyle.fontFamily",
                    },
                    {
                      key: "mapStyle.fontStyle.fontWeight",
                      prefix: "icon",
                      icon_type: "fontWeight",
                      layout_size: r.Medium,
                      ...kY.fontWeight,
                      path: "mapStyle.fontStyle.fontWeight",
                    },
                    {
                      key: "mapStyle.fontStyle.color",
                      layout_size: r.Medium,
                      ...kY.textColor,
                      path: "mapStyle.fontStyle.color",
                    },
                    {
                      key: "mapStyle.fontStyle.fontSize",
                      prefix: "icon",
                      icon_type: "fontSize",
                      layout_size: r.Medium,
                      ...kY.fontSize,
                      path: "mapStyle.fontStyle.fontSize",
                    },
                  ],
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "展示标注文本",
                  title_en: "Label Enable",
                  type: n.Boolean,
                  key: "mapStyle.labelEnable",
                  path: "mapStyle.labelEnable",
                },
                {
                  prefix: "text",
                  layout_size: r.Large,
                  title_cn: "文字遮挡隐藏",
                  title_en: "Text Cover Enable",
                  type: n.Boolean,
                  key: "mapStyle.coverEnable",
                  path: "mapStyle.coverEnable",
                },
              ],
            },
          ],
        },
      ],
    },
    {
      key: "componentBackground",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "componentBackground.hasColor",
          path: "componentBackground.hasColor",
          prefix: "text",
          title_cn: "背景填充",
          title_en: "componentBackground hasColor",
          type: n.Boolean,
        },
        {
          key: "componentBackground.backgroundColor",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "背景颜色",
          title_en: "Background color",
          path: "componentBackground.backgroundColor",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    {
      key: "light",
      title_cn: "光照阴影",
      title_en: "Light & Shadow",
      type: n.Panel,
      properties: [
        {
          key: "light.ambient.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "环境光颜色",
          title_en: "Ambient color",
          path: "light.ambient.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.ambient.intensity",
          type: n.Number,
          title_cn: "环境光强度",
          title_en: "Ambient Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.ambient.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "平行光颜色",
          title_en: "Directional color",
          path: "light.directional.color",
          alias: o.TitleSplitHalf,
        },
        {
          key: "light.directional.intensity",
          type: n.Number,
          title_cn: "平行光强度",
          title_en: "Directional Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.intensity",
          ...U("0,100"),
        },
        {
          key: "light.directional.x",
          type: n.Number,
          title_cn: "平行光源位置X",
          title_en: "Directional X",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.x",
          ...U("-1,1"),
        },
        {
          key: "light.directional.y",
          type: n.Number,
          title_cn: "平行光源位置Y",
          title_en: "Directional Y",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.y",
          ...U("-1,1"),
        },
        {
          key: "light.directional.z",
          type: n.Number,
          title_cn: "平行光源位置Z",
          title_en: "Directional Z",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "light.directional.z",
          ...U("0,1"),
        },
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "开启阴影",
          title_en: "Shadow Enable",
          type: n.Boolean,
          key: "light.shadow.enabled",
          path: "light.shadow.enabled",
        },
        {
          key: "light.shadow.color",
          prefix: "text",
          layout_size: r.Large,
          type: n.Color,
          title_cn: "阴影颜色",
          title_en: "Shadow color",
          path: "light.shadow.color",
          alias: o.TitleSplitHalf,
        },
      ],
    },
    BY,
  ],
  UY = [
    H(),
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "无值底色",
          title_en: "Default Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "color.defaultColor",
          path: "color.defaultColor",
        },
      ],
    },
    V(),
  ],
  jY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "无值底色",
          title_en: "Default Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.color.defaultColor",
          path: "style.color.defaultColor",
        },
      ],
    },
    {
      key: "size",
      type: n.Panel,
      properties: [
        {
          type: n.Number,
          title_cn: "网格尺寸",
          title_en: "Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.size",
          path: "style.size",
          ...U("20,100"),
        },
        {
          type: n.Number,
          title_cn: "网格间距",
          title_en: "Padding",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.padding",
          path: "style.padding",
          ...U("0,100"),
        },
      ],
    },
  ],
  HY = [
    H({
      showAllLevelData: !0,
    }),
    {
      type: n.Panel,
      key: "size",
      properties: [
        {
          key: "style.radius",
          type: n.Number,
          title_cn: "热力半径",
          title_en: "Radius",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "style.radius",
          ...U("0,100"),
        },
        {
          key: "style.height",
          type: n.Number,
          title_cn: "热力高度",
          title_en: "Height",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "style.height",
          ...U("0,100"),
        },
        {
          key: "style.intensity",
          type: n.Number,
          title_cn: "全局强度",
          title_en: "Intensity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          path: "style.intensity",
          ...U("0,1"),
        },
        {
          key: "color",
          title_cn: "热力颜色",
          title_en: "Color",
          type: n.Panel,
          properties: [
            {
              type: n.Color,
              title_cn: "颜色 1",
              title_en: "Color 1",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "style.color.color1",
              path: "style.color.color1",
            },
            {
              type: n.Color,
              title_cn: "颜色 2",
              title_en: "Color 2",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "style.color.color2",
              path: "style.color.color2",
            },
            {
              type: n.Color,
              title_cn: "颜色 3",
              title_en: "Color 3",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "style.color.color3",
              path: "style.color.color3",
            },
            {
              type: n.Color,
              title_cn: "颜色 4",
              title_en: "Color 4",
              layout_size: r.Large,
              prefix: "text",
              alias: o.TitleSplitHalf,
              key: "style.color.color4",
              path: "style.color.color4",
            },
          ],
        },
      ],
    },
  ],
  VY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "无值底色",
          title_en: "Default Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.color.defaultColor",
          path: "style.color.defaultColor",
        },
      ],
    },
    {
      key: "size",
      type: n.Panel,
      properties: [
        {
          type: n.Number,
          title_cn: "蜂窝尺寸",
          title_en: "Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.size",
          path: "style.size",
          ...U("20,100"),
        },
        {
          type: n.Number,
          title_cn: "蜂窝间距",
          title_en: "Padding",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.padding",
          path: "style.padding",
          ...U("0,100"),
        },
      ],
    },
  ],
  WY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "lineStyle",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "起点颜色",
          title_en: "Start Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "lineStyle.startColor",
          path: "lineStyle.startColor",
        },
        {
          type: n.Number,
          title_cn: "飞线速度",
          title_en: "Line Speed",
          layout_size: r.Medium,
          prefix: "text",
          key: "lineStyle.speed",
          path: "lineStyle.speed",
          ...U("-10,10"),
        },
        {
          type: n.Number,
          title_cn: "飞线粗细",
          title_en: "Line Size",
          layout_size: r.Medium,
          prefix: "icon",
          icon_type: "lineWidth",
          key: "lineStyle.size",
          path: "lineStyle.size",
          ...U("0,100"),
        },
      ],
    },
    {
      key: "breathPoint",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "breathPoint.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "附带呼吸点层",
          title_en: "Point Enable",
          type: n.Boolean,
          path: "breathPoint.enable",
        },
        {
          type: n.Number,
          title_cn: "呼吸速度",
          title_en: "Breath Speed",
          layout_size: r.Medium,
          prefix: "text",
          key: "breathPoint.speed",
          path: "breathPoint.speed",
          ...U("0,10"),
        },
        {
          type: n.Number,
          title_cn: "呼吸点尺寸",
          title_en: "Breath Size",
          layout_size: r.Medium,
          prefix: "icon",
          icon_type: "lineWidth",
          key: "breathPoint.size",
          path: "breathPoint.size",
          ...U("0,10"),
        },
      ],
    },
  ],
  qY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "lineStyle",
      type: n.Panel,
      properties: [
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "lineStyle.image",
          path: "icon.image",
        },
        {
          type: n.Number,
          title_cn: "运动速度",
          title_en: "Speed",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "lineStyle.speed",
          path: "speed",
          ...U("0,10"),
        },
      ],
    },
    {
      key: "startPoint",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "startPoint.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "轨迹起点",
          title_en: "Start Point Enable",
          type: n.Boolean,
          path: "startPoint.enable",
        },
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "startPoint.image",
          path: "startPoint.image",
        },
        {
          type: n.Number,
          title_cn: "起点尺寸",
          title_en: "Start Point Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "startPoint.size",
          path: "startPoint.size",
          ...U("0,100"),
        },
      ],
    },
    {
      key: "nodePoint",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "nodePoint.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "轨迹节点",
          title_en: "Node Point Enable",
          type: n.Boolean,
          path: "nodePoint.enable",
        },
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "nodePoint.image",
          path: "nodePoint.image",
        },
        {
          type: n.Number,
          title_cn: "节点尺寸",
          title_en: "Node Point Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "nodePoint.size",
          path: "nodePoint.size",
          ...U("0,100"),
        },
      ],
    },
    {
      key: "endPoint",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "endPoint.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "轨迹终点",
          title_en: "End Point Enable",
          type: n.Boolean,
          path: "endPoint.enable",
        },
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "endPoint.image",
          path: "endPoint.image",
        },
        {
          type: n.Number,
          title_cn: "终点尺寸",
          title_en: "End Point Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "endPoint.size",
          path: "endPoint.size",
          ...U("0,100"),
        },
      ],
    },
  ],
  YY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "display",
      type: n.Panel,
      properties: [
        {
          type: n.Boolean,
          title_cn: "使用圆形",
          title_en: "Use Cylinder",
          prefix: "text",
          layout_size: r.Medium,
          key: "display.useCylinder",
          path: "display.useCylinder",
        },
        {
          type: n.Number,
          title_cn: "气泡边数",
          title_en: "Column Edge Number",
          layout_size: r.Medium,
          prefix: "text",
          key: "display.segments",
          path: "display.segments",
          ...U("0,24"),
        },
      ],
    },
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "color.image",
          path: "icon.image",
        },
        {
          type: n.Color,
          title_cn: "无值底色",
          title_en: "Default Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "color.defaultColor",
          path: "color.defaultColor",
        },
      ],
    },
    {
      key: "scale",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "呼吸动画",
          title_en: "AMap",
          type: n.Boolean,
          key: "scale.enable",
          path: "scale.enable",
        },
        {
          type: n.Number,
          title_cn: "最小缩放比例",
          title_en: "Min scale",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "scale.min",
          path: "scale.min",
          ...U("0,10"),
        },
        {
          type: n.Number,
          title_cn: "最大缩放比例",
          title_en: "Max scale",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "scale.max",
          path: "scale.max",
          ...U("0,10"),
        },
        {
          type: n.Number,
          title_cn: "呼吸速度",
          title_en: "scale speed",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "scale.speed",
          path: "scale.speed",
          ...U("0,10"),
        },
      ],
    },
    {
      key: "opacity",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "渐隐动画",
          title_en: "AMap",
          type: n.Boolean,
          key: "opacity.enable",
          path: "opacity.enable",
        },
        {
          type: n.Number,
          title_cn: "最小不透明度",
          title_en: "Min opacity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "opacity.min",
          path: "opacity.min",
          ...U("0,1"),
        },
        {
          type: n.Number,
          title_cn: "最大不透明度",
          title_en: "Max opacity",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "opacity.max",
          path: "opacity.max",
          ...U("0,1"),
        },
        {
          type: n.Number,
          title_cn: "渐隐速度",
          title_en: "opacity speed",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "opacity.speed",
          path: "opacity.speed",
          ...U("0,10"),
        },
      ],
    },
    V(),
  ],
  XY = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "display",
      type: n.Panel,
      properties: [
        {
          type: n.Boolean,
          title_cn: "使用圆柱",
          title_en: "Use Cylinder",
          prefix: "text",
          layout_size: r.Medium,
          key: "display.useCylinder",
          path: "display.useCylinder",
        },
        {
          type: n.Number,
          title_cn: "柱边数",
          title_en: "Column Edge Number",
          layout_size: r.Medium,
          prefix: "text",
          key: "display.segments",
          path: "display.segments",
          ...U("0,24"),
        },
        {
          type: n.Number,
          title_cn: "顶面半径",
          title_en: "Top Radius",
          layout_size: r.Medium,
          prefix: "text",
          key: "display.radiusTop",
          path: "display.radiusTop",
          min: 0,
        },
        {
          type: n.Number,
          title_cn: "底面半径",
          title_en: "Bottom Radius",
          layout_size: r.Medium,
          prefix: "text",
          key: "display.radiusBottom",
          path: "display.radiusBottom",
          min: 0,
        },
      ],
    },
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "无值底色",
          title_en: "Default Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "color.defaultColor",
          path: "color.defaultColor",
        },
      ],
    },
    V({
      hasAnchor: !0,
    }),
  ],
  QY = "000000",
  ZY = "100000",
  JY = "460000",
  KY = 0.01,
  $Y = "Region:";
var tX, eX, iX, nX;
((eX = tX || (tX = {})).CHINA_GIS = "gis_map"),
  (eX.WOLRD_GIS = "gis_world_map"),
  (eX.CUSTOM_GIS = "gis_custom_map"),
  (eX.FlyLine = "flyLine"),
  (eX.Path = "path"),
  (eX.DistrictHeatMap = "districtHeatMap"),
  (eX.HeatMap = "heatMap"),
  (eX.HexagonHeatMap = "hexagonHeatMap"),
  (eX.GridHeatMap = "gridHeatMap"),
  (eX.Isochrone = "isochrone"),
  (eX.Column = "column"),
  (eX.Bubble = "bubble"),
  (eX.Ground = "ground"),
  (eX.Raising = "raising"),
  (eX.Particle = "particle"),
  (eX.LabelScatter = "labelScatter"),
  (eX.InformationLabel = "informationLabel"),
  ((nX = iX || (iX = {}))[(nX.country = 0)] = "country"),
  (nX[(nX.province = 1)] = "province"),
  (nX[(nX.city = 2)] = "city"),
  (nX[(nX.district = 3)] = "district");
var rX, oX, aX, sX, lX, uX;
((oX = rX || (rX = {})).Center = "center"),
  (oX.TopLeft = "bottom-right"),
  (oX.TopCenter = "bottom-center"),
  (oX.TopRight = "bottom-left"),
  (oX.MiddleLeft = "middle-right"),
  (oX.MiddleRight = "middle-left"),
  (oX.BottomLeft = "top-right"),
  (oX.BottomCenter = "top-center"),
  (oX.BottomRight = "top-left"),
  ((sX = aX || (aX = {})).None = "none"),
  (sX.Gradient = "gradient"),
  (sX.FlyLeft = "fly-left"),
  (sX.FlyRight = "fly-right"),
  (sX.FlyTop = "fly-top"),
  (sX.FlyBottom = "fly-bottom"),
  ((uX = lX || (lX = {})).Random = "random"),
  (uX.InOrder = "inOrder");
const cX = {
  [ZY]: {
    bbox: [116.960434, 10.60466187, 142.31169291, 18.0005],
    direction: "bottom",
  },
  [JY]: {
    bbox: [111.090434, 10.60466187, 142.31169291, 18.0005],
    direction: "bottom-right",
  },
};
var hX, pX;
((pX = hX || (hX = {})).CHINA_GIS = "@dp/aeolian-package-geography://gis_map"),
  (pX.WOLRD_GIS = "@dp/aeolian-package-geography://gis_world_map"),
  (pX.CUSTOM_GIS = "@dp/aeolian-package-geography://gis_custom_map");
const dX = [
    {
      key: "common",
      title_cn: "通用配置",
      title_en: "Common Config",
      type: n.Panel,
      layout: "top",
      properties: [
        {
          type: n.Boolean,
          title_cn: "展示全部层级数据",
          title_en: "show all level data",
          layout_size: r.Large,
          prefix: "text",
          key: "common.showAllLevelData",
          path: "common.showAllLevelData",
        },
      ],
    },
    {
      key: "marker",
      type: n.Panel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "初始化展示全部标签",
          title_en: "Show All Labels",
          type: n.Boolean,
          key: "marker.showAll",
          path: "marker.showAll",
        },
      ],
    },
    {
      key: "anchor",
      type: n.Panel,
      properties: [
        {
          type: n.Enum,
          title_cn: "相对位置",
          title_en: "Position",
          prefix: "text",
          layout_size: r.Large,
          key: "anchor.position",
          path: "anchor.position",
          items: [
            {
              title_cn: "中心",
              title_en: "center",
              value: rX.Center,
            },
            {
              title_cn: "左上",
              title_en: "top left",
              value: rX.TopLeft,
            },
            {
              title_cn: "正上",
              title_en: "top center",
              value: rX.TopCenter,
            },
            {
              title_cn: "右上",
              title_en: "top right",
              value: rX.TopRight,
            },
            {
              title_cn: "左中",
              title_en: "middle left",
              value: rX.MiddleLeft,
            },
            {
              title_cn: "右中",
              title_en: "middle right",
              value: rX.MiddleRight,
            },
            {
              title_cn: "左下",
              title_en: "bottom left",
              value: rX.BottomLeft,
            },
            {
              title_cn: "正下",
              title_en: "bottom center",
              value: rX.BottomCenter,
            },
            {
              title_cn: "右下",
              title_en: "bottom right",
              value: rX.BottomRight,
            },
          ],
        },
        {
          alias: "inputGroupWithTitle",
          title_cn: "偏移",
          title_en: "Offset",
          layout_size: r.Large,
          key: "anchor.offset",
          properties: [
            {
              type: n.Number,
              title_cn: "横向偏移",
              title_en: "offset x",
              layout_size: r.Medium,
              key: "anchor.offset.x",
              path: "anchor.offset.x",
              unit: "px",
            },
            {
              type: n.Number,
              title_cn: "纵向偏移",
              title_en: "offset y",
              layout_size: r.Medium,
              key: "anchor.offset.y",
              path: "anchor.offset.y",
              unit: "px",
            },
          ],
        },
      ],
    },
    {
      key: "carousel",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          prefix: "text",
          layout_size: r.Large,
          title_cn: "轮播",
          title_en: "Carousel Enable",
          type: n.Boolean,
          key: "carousel.enable",
          path: "carousel.enable",
        },
        {
          layout_size: r.Large,
          title_cn: "标签数量",
          title_en: "Number Once",
          type: n.Number,
          prefix: "text",
          min: 0,
          key: "carousel.onceNumber",
          path: "carousel.onceNumber",
        },
        {
          type: n.Enum,
          title_cn: "轮播方式",
          title_en: "Carousel Type",
          prefix: "text",
          layout_size: r.Large,
          key: "carousel.type",
          path: "carousel.type",
          items: [
            {
              title_cn: "顺序轮播",
              title_en: "In Order",
              value: lX.InOrder,
            },
            {
              title_cn: "随机轮播",
              title_en: "Random",
              value: lX.Random,
            },
          ],
        },
        {
          type: n.Enum,
          title_cn: "进入动画",
          title_en: "Animation In",
          layout_size: r.Large,
          key: "carousel.animationIn",
          path: "carousel.animationIn",
          prefix: "text",
          items: [
            {
              title_cn: "无动画",
              title_en: "no animation",
              value: aX.None,
            },
            {
              title_cn: "渐变出现",
              title_en: "gradient",
              value: aX.Gradient,
            },
            {
              title_cn: "左飞入",
              title_en: "fly left",
              value: aX.FlyLeft,
            },
            {
              title_cn: "右飞入",
              title_en: "fly right",
              value: aX.FlyRight,
            },
            {
              title_cn: "上飞入",
              title_en: "fly top",
              value: aX.FlyTop,
            },
            {
              title_cn: "下飞入",
              title_en: "fly bottom",
              value: aX.FlyBottom,
            },
          ],
        },
        {
          alias: o.TitleSplitHalf,
          type: n.Number,
          title_cn: "进入动画时长",
          title_en: "Duration In",
          layout_size: r.Large,
          key: "carousel.durationIn",
          path: "carousel.durationIn",
          unit: "s",
          ...U("0,10"),
        },
        {
          type: n.Enum,
          title_cn: "消失动画",
          title_en: "Animation Out",
          layout_size: r.Large,
          key: "carousel.animationOut",
          path: "carousel.animationOut",
          prefix: "text",
          items: [
            {
              title_cn: "无动画",
              title_en: "no animation",
              value: aX.None,
            },
            {
              title_cn: "渐变消失",
              title_en: "gradient",
              value: aX.Gradient,
            },
            {
              title_cn: "左飞出",
              title_en: "fly left",
              value: aX.FlyLeft,
            },
            {
              title_cn: "右飞出",
              title_en: "fly right",
              value: aX.FlyRight,
            },
            {
              title_cn: "上飞出",
              title_en: "fly top",
              value: aX.FlyTop,
            },
            {
              title_cn: "下飞出",
              title_en: "fly bottom",
              value: aX.FlyBottom,
            },
          ],
        },
        {
          alias: o.TitleSplitHalf,
          type: n.Number,
          title_cn: "消失动画时长",
          title_en: "Duration Out",
          layout_size: r.Large,
          key: "carousel.durationOut",
          path: "carousel.durationOut",
          unit: "s",
          ...U("0,10"),
        },
        {
          alias: o.TitleSplitHalf,
          type: n.Number,
          title_cn: "停留时长",
          title_en: "Stay",
          layout_size: r.Large,
          prefix: "text",
          key: "carousel.stay",
          path: "carousel.stay",
          min: 0,
          unit: "s",
        },
      ],
    },
    {
      tag: "data",
      title_cn: "展示标签城市",
      title_en: "Show Label City",
      path: "showLabelCity",
      type: n.String,
    },
  ],
  fX = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "icon",
      type: n.Panel,
      properties: [
        {
          type: n.Enum,
          title_cn: "图标类型",
          title_en: "Icon Type",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "icon.type",
          path: "icon.type",
          items: [
            {
              title_cn: "圆",
              title_en: "circle",
              value: 30,
            },
            {
              title_cn: "三角形",
              title_en: "triangle",
              value: 3,
            },
            {
              title_cn: "正方形",
              title_en: "square",
              value: 4,
            },
            {
              title_cn: "五边形",
              title_en: "pentagon",
              value: 5,
            },
            {
              title_cn: "六边形",
              title_en: "hexagon",
              value: 6,
            },
          ],
        },
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "icon.image",
          path: "icon.image",
        },
      ],
    },
    {
      key: "color",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "颜色",
          title_en: "Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "color.color",
          path: "color.color",
        },
      ],
    },
    V(),
  ],
  gX = [
    H({
      showAllLevelData: !0,
    }),
    {
      key: "feature",
      type: n.Panel,
      properties: [
        {
          type: n.String,
          title_cn: "Mapbox Token",
          title_en: "Mapbox Token",
          placeholder_cn: "请绑定后使用",
          placeholder_en: "Please bind the token before using it",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "feature.token",
          path: "feature.token",
        },
        {
          type: n.Enum,
          title_cn: "交通方式",
          title_en: "Profile",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "feature.profile",
          path: "feature.profile",
          items: [
            {
              title_en: "Walking",
              title_cn: "步行",
              value: "walking",
            },
            {
              title_en: "Cycling",
              title_cn: "骑行",
              value: "cycling",
            },
            {
              title_en: "Driving",
              title_cn: "驾车",
              value: "driving",
            },
          ],
        },
        {
          type: n.Number,
          title_cn: "时长",
          title_en: "Minutes",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "feature.minutes",
          path: "feature.minutes",
          unit: "min",
          ...U("1,60"),
        },
      ],
    },
    {
      key: "style",
      type: n.Panel,
      properties: [
        {
          type: n.Color,
          title_cn: "填充颜色",
          title_en: "Fill Color",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "style.color",
          path: "style.color",
        },
        {
          key: "outline",
          title_cn: "外描边",
          title_en: "Outline",
          type: n.Panel,
          properties: [
            {
              key: "style.outline.width",
              layout_size: "small",
              title_cn: "边线宽度",
              title_en: "Border Width",
              type: n.Number,
              path: "style.outline.width",
              prefix: "icon",
              icon_type: "lineWidth",
              ...U("0,100"),
            },
            {
              key: "style.outline.opacity",
              layout_size: "small",
              title_cn: "不透明度",
              title_en: "Border Opacity",
              type: n.Number,
              path: "style.outline.opacity",
              prefix: "icon",
              icon_type: "opacity",
              ...U("0,1"),
            },
            {
              key: "style.outline.color",
              layout_size: r.Medium,
              title_cn: "边线颜色",
              title_en: "Border Color",
              type: n.Color,
              path: "style.outline.color",
            },
          ],
        },
      ],
    },
    {
      key: "centerPoint",
      type: n.Panel,
      alias: o.CollapsePanel,
      properties: [
        {
          key: "centerPoint.enable",
          prefix: "text",
          layout_size: r.Large,
          title_cn: "中心点",
          title_en: "Point Enable",
          type: n.Boolean,
          path: "centerPoint.enable",
        },
        {
          layout_size: r.Large,
          title_cn: "自定义上传图标",
          title_en: "Image",
          type: n.Image,
          key: "centerPoint.image",
          path: "centerPoint.image",
        },
        {
          type: n.Number,
          title_cn: "尺寸",
          title_en: "Point Size",
          layout_size: r.Large,
          prefix: "text",
          alias: o.TitleSplitHalf,
          key: "centerPoint.size",
          path: "centerPoint.size",
          ...U("0,100"),
        },
      ],
    },
    V(),
  ];
var mX, yX;
(yX = mX || (mX = {}))[(yX.VolcanoBlue = 0)] = "VolcanoBlue";
const vX = mX.VolcanoBlue,
  bX = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      surface: {
        image:
          "data:image/png;base64,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",
        width: 70,
        height: 70,
        opacity: 60,
        offsetX: 5,
        offsetY: 5,
        offsetZ: 0,
      },
      rotate: {
        enable: !0,
        speed: -3,
      },
    },
  },
  xX = {
    name: "地表装饰层",
    name_en: "Ground Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Ground,
    nodeType: "ghost",
    iconType: "ground",
    presets: bX[vX],
    plot: [0, 0],
  };
const _X = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      display: {
        count: 20,
        size: 20,
        image:
          "data:image/png;base64,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",
      },
      scope: {
        width: 65,
        length: 65,
        height: 65,
      },
      animation: {
        speedMin: 10,
        speedMax: 20,
      },
    },
  },
  SX = {
    name: "粒子系统装饰层",
    name_en: "Particle Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Particle,
    nodeType: "ghost",
    iconType: "particle",
    presets: _X[vX],
    plot: [0, 0],
  };
const MX = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      display: {
        count: 10,
        width: 2,
        height: 10,
      },
      scope: {
        width: 65,
        length: 65,
        height: 65,
      },
      animation: {
        flashSpeed: 50,
        speedMin: 10,
        speedMax: 20,
      },
    },
  },
  CX = {
    name: "上升字符流装饰层",
    name_en: "Rising Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Raising,
    nodeType: "ghost",
    iconType: "raising",
    presets: MX[vX],
    plot: [0, 0],
  },
  wX = [xX, CX, SX];
function AX() {
  var t, e;
  return !(null ===
    (e =
      null === (t = window.__vfc__) || void 0 === t
        ? void 0
        : t.unavailableGisFeatures) || void 0 === e
    ? void 0
    : e.includes("convert-lnglat"));
}
function EX() {
  var t, e;
  return !(null ===
    (e =
      null === (t = window.__vfc__) || void 0 === t
        ? void 0
        : t.unavailableGisFeatures) || void 0 === e
    ? void 0
    : e.includes("map-tile"));
}
function DX() {
  var t, e;
  return !(null ===
    (e =
      null === (t = window.__vfc__) || void 0 === t
        ? void 0
        : t.unavailableGisFeatures) || void 0 === e
    ? void 0
    : e.includes("normal-tile"));
}
const TX = {
    [mX.VolcanoBlue]: {
      tips: {
        backgroundColor: "rgba(28,37,67,0.8)",
        fontFamily: "inherit",
        fontWeight: "normal",
        fontSize: 12,
        color: "rgba(255,255,255,0.7)",
      },
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      viewport: {
        centerLng: 106,
        centerLat: 35,
        zoom: 4.26,
        pitch: 40,
        rotation: 13,
        minZoom: 2,
        maxZoom: 20,
        maxPitch: 80,
        minPitch: 0,
        maxRotation: 90,
        minRotation: -90,
      },
      interaction: {
        drillEnable: !0,
        initialLevelName: `${ZY},${ZY}`,
        sceneChangeEnable: !0,
        zoomEnable: !0,
        rotationEnable: !0,
        translationEnable: !0,
        pitchEnable: !0,
      },
      componentBackground: {
        hasColor: !1,
        backgroundColor: "#080c11",
      },
      baseMapLayer: {
        show: !0,
      },
      districtOutline: {
        width: 2,
        opacity: 1,
      },
      innerShadow: {
        enable: !0,
        color: "rgba(0,102,255,1)",
        width: 0.1,
      },
      boundaryStreamer: {
        enable: !0,
        headColor: "#895EE6",
        endColor: "#6392FF",
        width: 5,
        speed: -10,
        length: 60,
      },
      extrude: {
        height: 0.6,
        topColor: "rgba(34,117,211,1)",
        bottomColor: "rgba(1,61,128,0.58)",
      },
      provinceOutline: {
        width: 1,
        opacity: 1,
        borderColor: "rgba(154,184,254,0.5)",
      },
      data: {
        custom: {
          data: {
            name: null,
            url: null,
          },
        },
        region: [],
      },
      mapStyle: {
        backgroundColor: "rgba(21,41,81,0.9)",
        metalness: 0.2,
        roughness: 0.8,
        backgroundType: "mapStyle-image-tab-1",
        backgroundImage: "",
        backgroundTile: EX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/gaode/t2/{z}/{x}/{y}.jpg`
          : "",
        normalType: "mapStyle-tile-tab-2",
        normalImage: "",
        normalTile: DX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/nextzen/{z}/{x}/{y}.png`
          : "",
        normalScale: 20,
        borderColor: "rgba(154,184,254,0.8)",
        fontStyle: {
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "rgba(214,242,255,0.6)",
        },
        coverEnable: !1,
        labelEnable: !0,
      },
      nanhai: {
        enable: !0,
        position: _Y["bottom-right"],
        offsetX: 10,
        offsetY: 10,
        scale: 8,
        fill: "rgba(29,58,124,1)",
        stroke: {
          color: "#2A59C5",
          width: 1,
        },
        border: {
          color: "rgba(45,63,109,1)",
          width: 1,
        },
        background: "rgba(12,20,36,1)",
        fontStyle: {
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 8,
          color: "rgba(255,255,255,0.7)",
        },
      },
      light: {
        ambient: {
          color: "#FFFFFF",
          intensity: 35,
        },
        directional: {
          color: "#FFFFFF",
          intensity: 35,
          x: 0.3,
          y: -0.5,
          z: 0.5,
        },
        shadow: {
          enabled: !0,
          color: "#000000",
        },
      },
      amap: {
        enable: !1,
        type: "amap.default",
        custom: {
          key: "",
          securityJsCode: "",
          id: "",
        },
        style: "darkblue",
        content: {
          label: !1,
          nebula: !0,
          roadnet: !1,
          traffic: !1,
          buildings: !1,
          terrain: !1,
        },
        filter: {
          enabled: !0,
          brightness: 1,
          contrast: 1.1,
          grayscale: 0.5,
          hueRotate: 0,
          invert: 0,
          saturate: 0.5,
          sepia: 0,
        },
      },
    },
  },
  PX = {
    name: "3D中国地图",
    name_en: "3D CN Map",
    category_cn: "场景",
    category_en: "Scene",
    snapshot:
      "data:image/png;base64,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",
    editingSpace: ["default"],
    renderType: tX.CHINA_GIS,
    iconType: "china_map",
    nodeType: "host",
    presets: TX[vX],
    dataPresets: {},
    plot: [1024, 768],
  };
function LX(t) {
  return void 0 !== t;
}
const IX = function (t, ...e) {
  return l(u(t), ...e, (t, e) =>
    c(t) || c(e) ? e : void 0 === e ? null : void 0
  );
};
new Proxy(
  {},
  {
    get: (t, e) => (t) => NX(e, t),
  }
);
const NX = (t, e) => {
    const i = document.createElement(t);
    return (i.style.cssText = e), i;
  },
  RX = (t) =>
    "inherit" !== t
      ? t
      : "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol";
function OX(t, e, i, n, r = 0) {
  switch (i.source.type) {
    case h.VizQuery:
    case h.Report:
      return e.cells[0].column[n];
    default:
      return e.cells[0].column.find((e) => {
        var n, o;
        return (
          (null ===
            (o =
              null === (n = i.vizFieldBlock[t]) || void 0 === n
                ? void 0
                : n[r]) || void 0 === o
            ? void 0
            : o.id) === e
        );
      });
  }
}
function FX(t, e) {
  const i = Object.entries(e.fieldMap),
    n = i.find((e) => e[1].location === t);
  if (n) return n[0];
  {
    const t = i.find((t) => "measure" === t[1].location);
    return t ? t[0] : void 0;
  }
}
const zX = {
    广东: "广东省",
    江苏: "江苏省",
    山东: "山东省",
    河南: "河南省",
    河北: "河北省",
    浙江: "浙江省",
    四川: "四川省",
    安徽: "安徽省",
    辽宁: "辽宁省",
    陕西: "陕西省",
    山西: "山西省",
    湖北: "湖北省",
    北京: "北京市",
    湖南: "湖南省",
    黑龙江: "黑龙江省",
    福建: "福建省",
    内蒙古: "内蒙古自治区",
    云南: "云南省",
    江西: "江西省",
    重庆: "重庆市",
    上海: "上海市",
    贵州: "贵州省",
    吉林: "吉林省",
    天津: "天津市",
    广西: "广西壮族自治区",
    甘肃: "甘肃省",
    新疆: "新疆维吾尔自治区",
    宁夏: "宁夏回族自治区",
    海南: "海南省",
    青海: "青海省",
    西藏: "西藏自治区",
    香港: "香港特别行政区",
    台湾: "台湾省",
    澳门: "澳门特别行政区",
  },
  kX = R(zX),
  BX = {
    石家庄: "石家庄市",
    唐山: "唐山市",
    秦皇岛: "秦皇岛市",
    邯郸: "邯郸市",
    邢台: "邢台市",
    保定: "保定市",
    张家口: "张家口市",
    承德: "承德市",
    沧州: "沧州市",
    廊坊: "廊坊市",
    衡水: "衡水市",
    太原: "太原市",
    大同: "大同市",
    阳泉: "阳泉市",
    长治: "长治市",
    晋城: "晋城市",
    朔州: "朔州市",
    晋中: "晋中市",
    运城: "运城市",
    忻州: "忻州市",
    临汾: "临汾市",
    吕梁: "吕梁市",
    呼和浩特: "呼和浩特市",
    包头: "包头市",
    乌海: "乌海市",
    赤峰: "赤峰市",
    通辽: "通辽市",
    鄂尔多斯: "鄂尔多斯市",
    呼伦贝尔: "呼伦贝尔市",
    巴彦淖尔: "巴彦淖尔市",
    乌兰察布: "乌兰察布市",
    兴安盟: "兴安盟",
    锡林郭勒盟: "锡林郭勒盟",
    阿拉善盟: "阿拉善盟",
    沈阳: "沈阳市",
    大连: "大连市",
    鞍山: "鞍山市",
    抚顺: "抚顺市",
    本溪: "本溪市",
    丹东: "丹东市",
    锦州: "锦州市",
    营口: "营口市",
    阜新: "阜新市",
    辽阳: "辽阳市",
    盘锦: "盘锦市",
    铁岭: "铁岭市",
    朝阳: "朝阳市",
    葫芦岛: "葫芦岛市",
    长春: "长春市",
    吉林: "吉林市",
    四平: "四平市",
    辽源: "辽源市",
    通化: "通化市",
    白山: "白山市",
    松原: "松原市",
    白城: "白城市",
    延边: "延边朝鲜族自治州",
    哈尔滨: "哈尔滨市",
    齐齐哈尔: "齐齐哈尔市",
    鸡西: "鸡西市",
    鹤岗: "鹤岗市",
    双鸭山: "双鸭山市",
    大庆: "大庆市",
    伊春: "伊春市",
    佳木斯: "佳木斯市",
    七台河: "七台河市",
    牡丹江: "牡丹江市",
    黑河: "黑河市",
    绥化: "绥化市",
    大兴安岭: "大兴安岭地区",
    南京: "南京市",
    无锡: "无锡市",
    徐州: "徐州市",
    常州: "常州市",
    苏州: "苏州市",
    南通: "南通市",
    连云港: "连云港市",
    淮安: "淮安市",
    盐城: "盐城市",
    扬州: "扬州市",
    镇江: "镇江市",
    泰州: "泰州市",
    宿迁: "宿迁市",
    杭州: "杭州市",
    宁波: "宁波市",
    温州: "温州市",
    嘉兴: "嘉兴市",
    湖州: "湖州市",
    绍兴: "绍兴市",
    金华: "金华市",
    衢州: "衢州市",
    舟山: "舟山市",
    台州: "台州市",
    丽水: "丽水市",
    合肥: "合肥市",
    芜湖: "芜湖市",
    蚌埠: "蚌埠市",
    淮南: "淮南市",
    马鞍山: "马鞍山市",
    淮北: "淮北市",
    铜陵: "铜陵市",
    安庆: "安庆市",
    黄山: "黄山市",
    滁州: "滁州市",
    阜阳: "阜阳市",
    宿州: "宿州市",
    六安: "六安市",
    亳州: "亳州市",
    池州: "池州市",
    宣城: "宣城市",
    福州: "福州市",
    厦门: "厦门市",
    莆田: "莆田市",
    三明: "三明市",
    泉州: "泉州市",
    漳州: "漳州市",
    南平: "南平市",
    龙岩: "龙岩市",
    宁德: "宁德市",
    南昌: "南昌市",
    景德镇: "景德镇市",
    萍乡: "萍乡市",
    九江: "九江市",
    新余: "新余市",
    鹰潭: "鹰潭市",
    赣州: "赣州市",
    吉安: "吉安市",
    宜春: "宜春市",
    抚州: "抚州市",
    上饶: "上饶市",
    济南: "济南市",
    青岛: "青岛市",
    淄博: "淄博市",
    枣庄: "枣庄市",
    东营: "东营市",
    烟台: "烟台市",
    潍坊: "潍坊市",
    济宁: "济宁市",
    泰安: "泰安市",
    威海: "威海市",
    日照: "日照市",
    临沂: "临沂市",
    德州: "德州市",
    聊城: "聊城市",
    滨州: "滨州市",
    菏泽: "菏泽市",
    郑州: "郑州市",
    开封: "开封市",
    洛阳: "洛阳市",
    平顶山: "平顶山市",
    安阳: "安阳市",
    鹤壁: "鹤壁市",
    新乡: "新乡市",
    焦作: "焦作市",
    濮阳: "濮阳市",
    许昌: "许昌市",
    漯河: "漯河市",
    三门峡: "三门峡市",
    南阳: "南阳市",
    商丘: "商丘市",
    信阳: "信阳市",
    周口: "周口市",
    驻马店: "驻马店市",
    济源: "济源市",
    武汉: "武汉市",
    黄石: "黄石市",
    十堰: "十堰市",
    宜昌: "宜昌市",
    襄阳: "襄阳市",
    鄂州: "鄂州市",
    荆门: "荆门市",
    孝感: "孝感市",
    荆州: "荆州市",
    黄冈: "黄冈市",
    咸宁: "咸宁市",
    随州: "随州市",
    恩施: "恩施土家族苗族自治州",
    仙桃: "仙桃市",
    潜江: "潜江市",
    天门: "天门市",
    神农架: "神农架林区",
    长沙: "长沙市",
    株洲: "株洲市",
    湘潭: "湘潭市",
    衡阳: "衡阳市",
    邵阳: "邵阳市",
    岳阳: "岳阳市",
    常德: "常德市",
    张家界: "张家界市",
    益阳: "益阳市",
    郴州: "郴州市",
    永州: "永州市",
    怀化: "怀化市",
    娄底: "娄底市",
    湘西: "湘西土家族苗族自治州",
    广州: "广州市",
    韶关: "韶关市",
    深圳: "深圳市",
    珠海: "珠海市",
    汕头: "汕头市",
    佛山: "佛山市",
    江门: "江门市",
    湛江: "湛江市",
    茂名: "茂名市",
    肇庆: "肇庆市",
    惠州: "惠州市",
    梅州: "梅州市",
    汕尾: "汕尾市",
    河源: "河源市",
    阳江: "阳江市",
    清远: "清远市",
    东莞: "东莞市",
    中山: "中山市",
    潮州: "潮州市",
    揭阳: "揭阳市",
    云浮: "云浮市",
    南宁: "南宁市",
    柳州: "柳州市",
    桂林: "桂林市",
    梧州: "梧州市",
    北海: "北海市",
    防城港: "防城港市",
    钦州: "钦州市",
    贵港: "贵港市",
    玉林: "玉林市",
    百色: "百色市",
    贺州: "贺州市",
    河池: "河池市",
    来宾: "来宾市",
    崇左: "崇左市",
    海口: "海口市",
    三亚: "三亚市",
    三沙: "三沙市",
    儋州: "儋州市",
    五指山: "五指山市",
    琼海: "琼海市",
    文昌: "文昌市",
    万宁: "万宁市",
    东方: "东方市",
    定安: "定安县",
    屯昌: "屯昌县",
    澄迈: "澄迈县",
    临高: "临高县",
    白沙: "白沙黎族自治县",
    昌江: "昌江黎族自治县",
    乐东: "乐东黎族自治县",
    陵水: "陵水黎族自治县",
    保亭: "保亭黎族苗族自治县",
    琼中: "琼中黎族苗族自治县",
    成都: "成都市",
    自贡: "自贡市",
    攀枝花: "攀枝花市",
    泸州: "泸州市",
    德阳: "德阳市",
    绵阳: "绵阳市",
    广元: "广元市",
    遂宁: "遂宁市",
    内江: "内江市",
    乐山: "乐山市",
    南充: "南充市",
    眉山: "眉山市",
    宜宾: "宜宾市",
    广安: "广安市",
    达州: "达州市",
    雅安: "雅安市",
    巴中: "巴中市",
    资阳: "资阳市",
    阿坝: "阿坝藏族羌族自治州",
    甘孜: "甘孜藏族自治州",
    凉山: "凉山彝族自治州",
    贵阳: "贵阳市",
    六盘水: "六盘水市",
    遵义: "遵义市",
    安顺: "安顺市",
    毕节: "毕节市",
    铜仁: "铜仁市",
    黔西南: "黔西南布依族苗族自治州",
    黔东南: "黔东南苗族侗族自治州",
    黔南: "黔南布依族苗族自治州",
    昆明: "昆明市",
    曲靖: "曲靖市",
    玉溪: "玉溪市",
    保山: "保山市",
    昭通: "昭通市",
    丽江: "丽江市",
    普洱: "普洱市",
    临沧: "临沧市",
    楚雄: "楚雄彝族自治州",
    红河: "红河哈尼族彝族自治州",
    文山: "文山壮族苗族自治州",
    西双版纳: "西双版纳傣族自治州",
    大理: "大理白族自治州",
    德宏: "德宏傣族景颇族自治州",
    怒江: "怒江傈僳族自治州",
    迪庆: "迪庆藏族自治州",
    拉萨: "拉萨市",
    日喀则: "日喀则市",
    昌都: "昌都市",
    林芝: "林芝市",
    山南: "山南市",
    那曲: "那曲市",
    阿里: "阿里地区",
    西安: "西安市",
    铜川: "铜川市",
    宝鸡: "宝鸡市",
    咸阳: "咸阳市",
    渭南: "渭南市",
    延安: "延安市",
    汉中: "汉中市",
    榆林: "榆林市",
    安康: "安康市",
    商洛: "商洛市",
    兰州: "兰州市",
    嘉峪关: "嘉峪关市",
    金昌: "金昌市",
    白银: "白银市",
    天水: "天水市",
    武威: "武威市",
    张掖: "张掖市",
    平凉: "平凉市",
    酒泉: "酒泉市",
    庆阳: "庆阳市",
    定西: "定西市",
    陇南: "陇南市",
    临夏: "临夏回族自治州",
    甘南: "甘南藏族自治州",
    西宁: "西宁市",
    海东: "海东市",
    海北: "海北藏族自治州",
    黄南: "黄南藏族自治州",
    海南: "海南藏族自治州",
    果洛: "果洛藏族自治州",
    玉树: "玉树藏族自治州",
    海西: "海西蒙古族藏族自治州",
    银川: "银川市",
    石嘴山: "石嘴山市",
    吴忠: "吴忠市",
    固原: "固原市",
    中卫: "中卫市",
    乌鲁木齐: "乌鲁木齐市",
    克拉玛依: "克拉玛依市",
    吐鲁番: "吐鲁番市",
    哈密: "哈密市",
    昌吉: "昌吉回族自治州",
    博尔塔拉: "博尔塔拉蒙古自治州",
    巴音郭楞: "巴音郭楞蒙古自治州",
    阿克苏: "阿克苏地区",
    克孜勒苏柯尔: "克孜勒苏柯尔克孜自治州",
    喀什: "喀什地区",
    和田: "和田地区",
    伊犁哈: "伊犁哈萨克自治州",
    塔城: "塔城地区",
    阿勒泰: "阿勒泰地区",
    石河子: "石河子市",
    阿拉尔: "阿拉尔市",
    图木舒克: "图木舒克市",
    五家渠: "五家渠市",
    北屯: "北屯市",
    铁门关: "铁门关市",
    双河: "双河市",
    可克达拉: "可克达拉市",
    昆玉: "昆玉市",
    胡杨河: "胡杨河市",
    新星: "新星市",
    台北: "台北市",
    新北: "新北市",
    台中: "台中市",
    台南: "台南市",
    高雄: "高雄市",
    桃园: "桃园市",
    基隆: "基隆市",
    新竹: "新竹县",
    嘉义: "嘉义县",
    苗栗: "苗栗县",
    彰化: "彰化县",
    南投: "南投县",
    云林: "云林县",
    屏东: "屏东县",
    宜兰: "宜兰县",
    花莲: "花莲县",
    台东: "台东县",
    澎湖: "澎湖县",
    新界: "新界",
    九龙: "九龙半岛",
    香港: "香港岛",
    澳门: "澳门半岛",
    氹仔: "氹仔岛",
    路氹: "路氹城",
    路环: "路环岛",
  },
  GX = R(BX),
  UX = p({}, BX, zX),
  jX = {
    en_US: p(
      {
        阿巴嘎旗: "Abaga flag",
        东乌珠穆沁旗: "Dongwu Jumuqin Banner",
        多伦县: "Duolun County",
        二连浩特市: "Erenhot City",
        苏尼特右旗: "Sunite right flag",
        苏尼特左旗: "Sunite Left Banner",
        太仆寺旗: "Taipu Temple Banner",
        西乌珠穆沁旗: "Xiwu Zhumuqin Banner",
        锡林浩特市: "Xilinhot City",
        镶黄旗: "Yellow inlaid flag",
        正蓝旗: "Zhenglan Flag",
        正镶白旗: "Positive inlaid white flag",
        阿坝县: "Aba county",
        黑水县: "Heishui county",
        红原县: "Hongyuan county",
        金川县: "Jinchuan county",
        九寨沟县: "Jiuzhaigou county",
        理县: "Li county",
        马尔康市: "Marcon city",
        茂县: "Mao county",
        壤塘县: "Rangtang county",
        若尔盖县: "Zoige county",
        松潘县: "Songpan county",
        汶川县: "Wenchuan county",
        小金县: "Xiaojin county",
        阿城区: "Acheng District",
        巴彦县: "Bayan county",
        宾县: "Bin county",
        道里区: "Daoli District",
        道外区: "Off-road area",
        方正县: "Fangzheng county",
        呼兰区: "Hulan District",
        木兰县: "Mulan county",
        南岗区: "Nangang District",
        平房区: "Bungalow area",
        尚志市: "Shangzhi City",
        双城区: "Shuangcheng District",
        松北区: "Songbei District",
        通河县: "Tonghe county",
        五常市: "Wuchang City",
        香坊区: "Xiangfang District",
        延寿县: "Yanshou county",
        依兰县: "Yilan county",
        阿尔山市: "Arxan city",
        科尔沁右翼前旗: "Horqin right-wing front flag",
        科尔沁右翼中旗: "Horqin right-wing middle flag",
        突泉县: "Tuquan county",
        乌兰浩特市: "Ulanhot city",
        扎赉特旗: "Zareth flag",
        阿合奇县: "Aheqi county",
        阿克陶县: "Aktau county",
        阿图什市: "Atushi City",
        乌恰县: "Ucha county",
        阿克塞哈萨克族自治县: "Aksai Kazakh Autonomous County",
        敦煌市: "Dunhuang City",
        瓜州县: "Guazhou county",
        金塔县: "Jinta county",
        肃北蒙古族自治县: "Subei Mongolian Autonomous County",
        肃州区: "Suzhou District",
        玉门市: "Yumen City",
        阿克苏市: "Aksu City",
        阿瓦提县: "Avati county",
        拜城县: "Baicheng county",
        柯坪县: "Keping county",
        库车市: "Kuche City",
        沙雅县: "Shaya county",
        温宿县: "Wensu county",
        乌什县: "Wushi county",
        新和县: "Xinhe County",
        阿拉尔市: "City of Aral",
        阿拉山口市: "Alashankou City",
        博乐市: "Bole city",
        精河县: "Jinghe county",
        温泉县: "Wenquan county",
        阿拉善右旗: "Alashan Right Banner",
        阿拉善左旗: "Alashan Left Banner",
        额济纳旗: "Ejina Banner",
        阿勒泰市: "Altay City",
        布尔津县: "Burqin county",
        福海县: "Fuhai county",
        富蕴县: "Fuyun county",
        哈巴河县: "Habahe county",
        吉木乃县: "Jimunai county",
        青河县: "Qinghe county",
        阿鲁科尔沁旗: "Arukorqin flag",
        敖汉旗: "Aohan Banner",
        巴林右旗: "Bahrain right flag",
        巴林左旗: "Bahrain Left Flag",
        红山区: "Hongshan District",
        喀喇沁旗: "Karachin flag",
        克什克腾旗: "Keshikten flag",
        林西县: "Linxi county",
        宁城县: "Ningcheng county",
        松山区: "Songshan District",
        翁牛特旗: "Weng Niute Banner",
        元宝山区: "Yuanbaoshan District",
        阿荣旗: "Arong flag",
        陈巴尔虎旗: "Chenbalhu flag",
        额尔古纳市: "Erguna City",
        鄂伦春自治旗: "Oroqen Autonomous Banner",
        鄂温克族自治旗: "Ewenki Autonomous Banner",
        根河市: "Genhe City",
        海拉尔区: "Hailar District",
        满洲里市: "Manzhouli City",
        莫力达瓦达斡尔族自治旗: "Molidawada Daur Autonomous Banner",
        新巴尔虎右旗: "New Balhu Right Banner",
        新巴尔虎左旗: "New Balhu Left Banner",
        牙克石市: "Yakeshi City",
        扎赉诺尔区: "Zalainor district",
        扎兰屯市: "Zalantun City",
        爱辉区: "Aihui District",
        北安市: "Beian City",
        嫩江市: "Nenjiang City",
        孙吴县: "Sunwu county",
        五大连池市: "Wudalianchi City",
        逊克县: "Xunke county",
        爱民区: "Aimin District",
        东安区: "Dong'an District",
        东宁市: "Dongning City",
        海林市: "Hailin City",
        林口县: "Linkou county",
        穆棱市: "Muling city",
        宁安市: "Ning'an City",
        绥芬河市: "Suifenhe City",
        西安区: "Xi'an District",
        阳明区: "Yangming District",
        安次区: "Anci district",
        霸州市: "Bazhou City",
        大厂回族自治县: "Dachang Hui Autonomous County",
        大城县: "Dacheng county",
        固安县: "Gu'an county",
        广阳区: "Guangyang District",
        三河市: "Sanhe City",
        文安县: "Wen'an county",
        香河县: "Xianghe county",
        永清县: "Yongqing county",
        安达市: "Anda City",
        北林区: "Beilin District",
        海伦市: "City of Helen",
        兰西县: "Lanxi county",
        明水县: "Mingshui county",
        青冈县: "Qinggang county",
        庆安县: "Qing'an county",
        绥棱县: "Suiling county",
        望奎县: "Wangkui county",
        肇东市: "Zhaodong City",
        安定区: "Anding area",
        临洮县: "Lintao county",
        陇西县: "Longxi county",
        岷县: "Min county",
        通渭县: "Tongwei county",
        渭源县: "Weiyuan county",
        漳县: "Zhang county",
        安多县: "Amdo county",
        巴青县: "Baqing county",
        班戈县: "Bangor county",
        比如县: "Such as county",
        嘉黎县: "Jiali county",
        尼玛县: " county",
        聂荣县: "Nie Rong County",
        色尼区: "Sanni area",
        申扎县: "Shenza county",
        双湖县: "Shuanghu county",
        索县: "Suo County",
        安福县: "Anfu county",
        吉安县: "Jian county",
        吉水县: "Jishui county",
        吉州区: "Jizhou District",
        井冈山市: "Jinggangshan City",
        青原区: "Qingyuan District",
        遂川县: "Suichuan county",
        泰和县: "Taihe County",
        万安县: "Wan'an County",
        峡江县: "Xiajiang county",
        新干县: "Xigan county",
        永丰县: "Yongfeng county",
        永新县: "Yongxin county",
        安国市: "Anguo City",
        安新县: "Anxin county",
        博野县: "Boye county",
        定兴县: "Dingxing county",
        定州市: "Dingzhou city",
        阜平县: "Fuping county",
        高碑店市: "Gaobeidian city",
        高阳县: "Gaoyang county",
        竞秀区: "Competition area",
        涞水县: "Laishui county",
        涞源县: "Laiyuan county",
        蠡县: "Li county",
        莲池区: "Lianchi District",
        满城区: "Mancheng District",
        清苑区: "Qingyuan District",
        曲阳县: "Quyang county",
        容城县: "Rongcheng county",
        顺平县: "Shunping county",
        唐县: "Tang County",
        望都县: "Wangdu county",
        雄县: "Xiongxian",
        徐水区: "Xushui District",
        易县: "Yi county",
        涿州市: "Zhuozhou City",
        安化县: "Anhua county",
        赫山区: "Heshan District",
        南县: "Nan County",
        桃江县: "Taojiang county",
        沅江市: "Yuanjiang City",
        资阳区: "Ziyang District",
        安吉县: "Anji county",
        德清县: "Deqing county",
        南浔区: "Nanxun District",
        吴兴区: "Wuxing District",
        长兴县: "Changxing county",
        安居区: "Residential area",
        船山区: "Chuanshan District",
        大英县: "Great Britain County",
        蓬溪县: "Pengxi county",
        射洪市: "Shehong City",
        安龙县: "Anlong county",
        册亨县: "Ceheng county",
        普安县: "Pu'an County",
        晴隆县: "Qinglong county",
        望谟县: "Wangmo county",
        兴仁市: "Xingren City",
        兴义市: "Xingyi city",
        贞丰县: "Zhenfeng county",
        安陆市: "Anlu City",
        大悟县: "Dawu county",
        汉川市: "Hanchuan City",
        孝昌县: "Xiaochang county",
        孝南区: "Xiaonan District",
        应城市: "Yingcheng City",
        云梦县: "Yunmeng county",
        安宁区: "Anning District",
        城关区: "Chengguan District",
        皋兰县: "Gaolan county",
        红古区: "Honggu District",
        兰州新区: "Lanzhou New Area",
        七里河区: "Qilihe District",
        西固区: "Xigu District",
        永登县: "Yongdeng county",
        榆中县: "Yuzhong county",
        安宁市: "Anning city",
        呈贡区: "Chenggong District",
        东川区: "Dongchuan District",
        富民县: "Fumin county",
        官渡区: "Guandu District",
        晋宁区: "Jinning district",
        禄劝彝族苗族自治县: "Luquan Yi and Miao Autonomous County",
        盘龙区: "Panlong District",
        石林彝族自治县: "Shilin Yi Autonomous County",
        嵩明县: "Songming county",
        五华区: "Wuhua District",
        西山区: "Xishan District",
        寻甸回族彝族自治县: "Xundian Hui and Yi Autonomous County",
        宜良县: "Yiliang county",
        安平县: "Anping county",
        阜城县: "Fucheng county",
        故城县: "Gucheng County",
        冀州区: "Jizhou District",
        景县: "Jing county",
        饶阳县: "Raoyang county",
        深州市: "Shenzhou City",
        桃城区: "Taocheng District",
        武强县: "Wuqiang county",
        武邑县: "Wuyi county",
        枣强县: "Zaoqiang county",
        安丘市: "Anqiu City",
        昌乐县: "Changle county",
        昌邑市: "Changyi City",
        坊子区: "Fangzi District",
        高密市: "Gaomi City",
        寒亭区: "Hanting District",
        奎文区: "Quevan district",
        临朐县: "Linqu county",
        青州市: "Qingzhou City",
        寿光市: "Shouguang City",
        潍城区: "Weicheng District",
        诸城市: "Zhucheng City",
        安仁县: "Anren county",
        北湖区: "Beihu District",
        桂东县: "Guidong county",
        桂阳县: "Guiyang county",
        嘉禾县: "Jiahe county",
        临武县: "Linwu county",
        汝城县: "Rucheng county",
        苏仙区: "Suxian District",
        宜章县: "Yizhang county",
        永兴县: "Yongxing county",
        资兴市: "Zixing city",
        安塞区: "Ansai district",
        宝塔区: "Baota District",
        富县: "Fu county",
        甘泉县: "Ganquan county",
        黄陵县: "Huangling county",
        黄龙县: "Huanglong county",
        洛川县: "Luochuan county",
        吴起县: "Wuqi county",
        延川县: "Yanchuan county",
        延长县: "Yanchang county",
        宜川县: "Yichuan county",
        志丹县: "Zhidan county",
        子长市: "Zichang City",
        安图县: "Antu county",
        敦化市: "Dunhua City",
        和龙市: "Holong City",
        珲春市: "Hunchun City",
        龙井市: "Longjing City",
        图们市: "Tumen city",
        汪清县: "Wangqing county",
        延吉市: "Yanji City",
        安溪县: "Anxi county",
        德化县: "Dehua county",
        丰泽区: "Fengze District",
        惠安县: "Huian county",
        金门县: "Kinmen county",
        晋江市: "Jinjiang City",
        鲤城区: "Licheng District",
        洛江区: "Luojiang District",
        南安市: "Nan'an City",
        泉港区: "Quangang District",
        石狮市: "Shishi City",
        永春县: "Yongchun county",
        安乡县: "Anxiang county",
        鼎城区: "Dingcheng District",
        汉寿县: "Hanshou county",
        津市市: "Tsuji City",
        澧县: "Lixian County",
        临澧县: "Linli county",
        石门县: "Shimen county",
        桃源县: "Taoyuan county",
        武陵区: "Wuling District",
        安阳县: "Anyang county",
        北关区: "Beiguan District",
        滑县: "Hua county",
        林州市: "Linzhou City",
        龙安区: "Long'an District",
        内黄县: "Neihuang county",
        汤阴县: "Tangyin county",
        文峰区: "Wenfeng District",
        殷都区: "Yindu District",
        安义县: "Anyi county",
        东湖区: "Donghu District",
        红谷滩区: "Honggutan District",
        进贤县: "Jinxian county",
        南昌县: "Nanchang county",
        青山湖区: "Qingshan Lake District",
        青云谱区: "Qingyunpu area",
        西湖区: "West Lake District",
        新建区: "Newly created area",
        安源区: "Anyuan District",
        莲花县: "Lianhua county",
        芦溪县: "Luxi county",
        上栗县: "Shangli county",
        湘东区: "Xiangdong District",
        安远县: "Anyuan county",
        崇义县: "Chongyi county",
        大余县: "Dayu county",
        定南县: "Dingnan county",
        赣县区: "Ganxian District",
        会昌县: "Huichang county",
        龙南市: "Longnan City",
        南康区: "Nankang District",
        宁都县: "Ningdu county",
        全南县: "Quannan county",
        瑞金市: "Ruijin City",
        上犹县: "Shangyou county",
        石城县: "Shicheng county",
        信丰县: "Xinfeng county",
        兴国县: "Xingguo county",
        寻乌县: "Xunwu county",
        于都县: "Yudu county",
        章贡区: "Zhanggong district",
        安岳县: "Anyue county",
        乐至县: "Lezhi county",
        雁江区: "Yanjiang District",
        安泽县: "Anze county",
        大宁县: "Daning county",
        汾西县: "Fenxi county",
        浮山县: "Fushan county",
        古县: "Ancient county",
        洪洞县: "Hongdong county",
        侯马市: "Houma city",
        霍州市: "Huozhou City",
        吉县: "Ji County",
        蒲县: "Puxian",
        曲沃县: "Quwo county",
        隰县: "Xi county",
        乡宁县: "Xiangning county",
        襄汾县: "Xiangfen county",
        尧都区: "Yaodu District",
        翼城县: "Yicheng county",
        永和县: "Yonghe county",
        安州区: "Anzhou District",
        北川羌族自治县: "Beichuan Qiang Autonomous County",
        涪城区: "Fucheng District",
        江油市: "Jiangyou City",
        平武县: "Pingwu county",
        三台县: "Santai county",
        盐亭县: "Yanting county",
        游仙区: "Youxian District",
        梓潼县: "Zitong county",
        昂昂溪区: "Angangxi district",
        拜泉县: "Baiquan county",
        富拉尔基区: "Fularki district",
        富裕县: "Fuyu County",
        甘南县: "Gannan county",
        建华区: "Jianhua District",
        克东县: "Kedong county",
        克山县: "Keshan county",
        龙江县: "Longjiang county",
        龙沙区: "Longsha District",
        梅里斯达斡尔族区: "Merisdaur district",
        讷河市: "Nehe City",
        碾子山区: "Nianzi Mountain District",
        泰来县: "Tailai county",
        铁锋区: "Iron front zone",
        依安县: "Yi'an County",
        昂仁县: "Angren county",
        白朗县: "Bailang county",
        定结县: "Dingjie county",
        定日县: "Dingri county",
        岗巴县: "Gangba county",
        吉隆县: "Jilong County",
        江孜县: "Jiangzi county",
        康马县: "Kangma county",
        拉孜县: "Lazi county",
        南木林县: "Nanmulin county",
        聂拉木县: "Neramu county",
        仁布县: "Renbu county",
        萨嘎县: "Saga county",
        萨迦县: "Saga county",
        桑珠孜区: "Sangzhuzi district",
        谢通门县: "Xietongmen county",
        亚东县: "Yadong county",
        仲巴县: "Zhongba county",
        八步区: "Eight-step area",
        富川瑶族自治县: "Fuchuan Yao Autonomous County",
        平桂区: "Pinggui District",
        昭平县: "Zhaoping county",
        钟山县: "Zhongshan county",
        八公山区: "Bagong Mountain Area",
        大通区: "Datong area",
        凤台县: "Fengtai county",
        潘集区: "Panji district",
        寿县: "Shouxian",
        田家庵区: "Tianjia'an District",
        谢家集区: "Xiejiaji District",
        八宿县: "Basu county",
        边坝县: "Bianba county",
        察雅县: "Chaya county",
        丁青县: "Dingqing county",
        贡觉县: "Gongjue county",
        江达县: "Jiangda county",
        卡若区: "Karo district",
        类乌齐县: "Tyuqi county",
        洛隆县: "Luolong county",
        芒康县: "Mangkang county",
        左贡县: "Zuogong county",
        巴楚县: "Bachu county",
        伽师县: "Jiashi county",
        喀什市: "Kashgar City",
        麦盖提县: "Maigaiti county",
        莎车县: "Shache county",
        疏附县: "Shufu county",
        疏勒县: "Shule county",
        塔什库尔干塔吉克自治县: "Tashkurgan Tajik Autonomous County",
        叶城县: "Yecheng county",
        英吉沙县: "Ingisha county",
        岳普湖县: "Yuepu Lake County",
        泽普县: "Zeep county",
        巴东县: "Badong county",
        恩施市: "Enshi city",
        鹤峰县: "Hefeng county",
        建始县: "Jianshi county",
        来凤县: "Laifeng county",
        利川市: "Icheon City",
        咸丰县: "Xianfeng county",
        宣恩县: "Xuan'en County",
        巴里坤哈萨克自治县: "Balikun Kazakh Autonomous County",
        伊吾县: "Yiwu county",
        伊州区: "Illinois District",
        巴马瑶族自治县: "Bama Yao Autonomous County",
        大化瑶族自治县: "Dahua Yao Autonomous County",
        东兰县: "Donglan county",
        都安瑶族自治县: "Du'an Yao Autonomous County",
        凤山县: "Fengshan county",
        环江毛南族自治县: "Huanjiang Maonan Autonomous County",
        金城江区: "Jinchengjiang District",
        罗城仫佬族自治县: "Luocheng Mulao Autonomous County",
        南丹县: "Nandan county",
        天峨县: "Tiane county",
        宜州区: "Yizhou District",
        巴塘县: "Batang county",
        白玉县: "Baiyu county",
        丹巴县: "Danba county",
        道孚县: "Daofu county",
        稻城县: "Daocheng county",
        得荣县: "Derong county",
        德格县: "Degg county",
        甘孜县: "Ganzi county",
        九龙县: "Kowloon County",
        康定市: "Kangding city",
        理塘县: "Litang county",
        炉霍县: "Luhuo county",
        泸定县: "Luding county",
        色达县: "Seda county",
        石渠县: "Shiqu county",
        乡城县: "Xiangcheng County",
        新龙县: "Xinlong county",
        雅江县: "Yajiang county",
        巴宜区: "Bayi District",
        波密县: "Bomi county",
        察隅县: "Chayu county",
        工布江达县: "Gongbujiangda county",
        朗县: "Lang county",
        米林县: "Milin county",
        墨脱县: "Motuo county",
        巴州区: "Bazhou District",
        恩阳区: "Enyang District",
        南江县: "Nanjiang county",
        平昌县: "Pyeongchang county",
        通江县: "Tongjiang county",
        鲅鱼圈区: "Bayuquan District",
        大石桥市: "Dashiqiao City",
        盖州市: "Gaizhou City",
        老边区: "Old side area",
        西市区: "West downtown",
        站前区: "Station front area",
        灞桥区: "Baqiao District",
        碑林区: "Beilin District",
        高陵区: "Gaoling District",
        鄠邑区: "Huyi District",
        蓝田县: "Lantian county",
        莲湖区: "Lianhu District",
        临潼区: "Lintong District",
        未央区: "Weiyang District",
        新城区: "Xincheng District",
        阎良区: "Yanliang District",
        雁塔区: "Wild Goose Pagoda District",
        长安区: "Chang'an District",
        周至县: "Zhouzhi county",
        白河县: "Baihe county",
        汉滨区: "Hanbin District",
        汉阴县: "Hanyin county",
        岚皋县: "Langao county",
        宁陕县: "Ningshan county",
        平利县: "Pingli county",
        石泉县: "Shiquan county",
        旬阳市: "Xunyang City",
        镇坪县: "Zhenping county",
        紫阳县: "Ziyang county",
        白碱滩区: "White alkali beach area",
        独山子区: "Dushanzi District",
        克拉玛依区: "Karamay district",
        乌尔禾区: "Wuerhe District",
        白沙黎族自治县: "Baisha Li Autonomous County",
        白水县: "Baishui county",
        澄城县: "Chengcheng county",
        大荔县: "Dali county",
        富平县: "Fuping county",
        韩城市: "Hancheng City",
        合阳县: "Heyang county",
        华阴市: "Huayin City",
        华州区: "Huazhou District",
        临渭区: "Linwei District",
        蒲城县: "Pucheng county",
        潼关县: "Tongguan county",
        白塔区: "Baita District",
        灯塔市: "Lighthouse City",
        弓长岭区: "Gongchangling District",
        宏伟区: "Magnificent District",
        辽阳县: "Liaoyang county",
        太子河区: "Taizihe District",
        文圣区: "Wensheng District",
        白银区: "Silver zone",
        会宁县: "Huining county",
        景泰县: "Jingtai county",
        靖远县: "Jingyuan county",
        平川区: "Hirakawa Ward",
        白云鄂博矿区: "Baiyun Obo Mining Area",
        达尔罕茂明安联合旗: "Darhan Maumeen'an United Flag",
        东河区: "Donghe District",
        固阳县: "Guyang county",
        九原区: "Kyuhara Ward",
        昆都仑区: "Kundulun District",
        青山区: "Qingshan District",
        石拐区: "Shiguai District",
        土默特右旗: "Tumet right flag",
        白云区: "Baiyun District",
        观山湖区: "Guanshanhu District",
        花溪区: "Huaxi District",
        开阳县: "Kaiyang county",
        南明区: "Nanming District",
        清镇市: "Qingzhen City",
        乌当区: "Wudang District",
        息烽县: "Xifeng county",
        修文县: "Xiuwen county",
        云岩区: "Cloud rock area",
        从化区: "Conghua district",
        番禺区: "Panyu District",
        海珠区: "Haizhu District",
        花都区: "Huadu District",
        黄埔区: "Huangpu District",
        荔湾区: "Liwan District",
        南沙区: "Nansha District",
        天河区: "Tianhe District",
        越秀区: "Yuexiu District",
        增城区: "Zengcheng District",
        柏乡县: "Baixiang county",
        广宗县: "Guangzong county",
        巨鹿县: "Julu county",
        临城县: "Lincheng county",
        临西县: "Linxi county",
        隆尧县: "Longyao county",
        南宫市: "Nangong City",
        南和区: "Nanhe District",
        内丘县: "Neiqiu county",
        宁晋县: "Ningjin county",
        平乡县: "Pingxiang county",
        清河县: "Qinghe county",
        任泽区: "Renze District",
        沙河市: "Shahe City",
        威县: "Weixian",
        襄都区: "Xiangdu District",
        新河县: "Xinhe county",
        信都区: "Xindu District",
        班玛县: "Banma county",
        达日县: "Dari county",
        甘德县: "Gander county",
        久治县: "Jiuzhi county",
        玛多县: "Mado County",
        玛沁县: "Maqin county",
        板芙镇: "Banfu Town",
        大涌镇: "Dayong town",
        东凤镇: "Dongfeng Town",
        东区街道: "Dongqu Street",
        阜沙镇: "Fusha Town",
        港口镇: "Port town",
        古镇镇: "Ancient town",
        横栏镇: "Henglan town",
        黄圃镇: "Huangpu Town",
        民众街道: "People's streets",
        南朗街道: "Nanlang Street",
        南区街道: "Nanqu Street",
        南头镇: "Nantou town",
        三角镇: "Triangle town",
        三乡镇: "Sanxiang town",
        沙溪镇: "Shaxi town",
        神湾镇: "Shenwan Town",
        石岐街道: "Shiqi Street",
        坦洲镇: "Tanzhou town",
        五桂山街道: "Wuguishan Street",
        西区街道: "Xiqu Street",
        小榄镇: "Xiaolan Town",
        中山港街道: "Zhongshan Port Street",
        蚌山区: "Bengshan District",
        固镇县: "Guzhen county",
        怀远县: "Huaiyuan county",
        淮上区: "Huai Shang District",
        龙子湖区: "Longzihu District",
        五河县: "Wuhe county",
        禹会区: "Yuhui District",
        包河区: "Baohe District",
        巢湖市: "Chaohu City",
        肥东县: "Feidong county",
        肥西县: "Feixi county",
        庐江县: "Lujiang county",
        庐阳区: "Luyang District",
        蜀山区: "Shushan District",
        瑶海区: "Yaohai District",
        长丰县: "Changfeng county",
        宝安区: "Bao'an District",
        福田区: "Futian District",
        光明区: "Guangming District",
        龙岗区: "Longgang District",
        龙华区: "Longhua District",
        罗湖区: "Luohu District",
        南山区: "Nanshan District",
        坪山区: "Pingshan District",
        盐田区: "Yantian District",
        宝丰县: "Baofeng county",
        郏县: "Jia County",
        鲁山县: "Lushan county",
        汝州市: "Ruzhou City",
        石龙区: "Shilong District",
        卫东区: "Weidong District",
        舞钢市: "Wugang City",
        新华区: "Xinhua District",
        叶县: "Ye County",
        湛河区: "Zhanhe District",
        宝清县: "Baoqing county",
        宝山区: "Baoshan District",
        集贤县: "Jixian county",
        尖山区: "Jianshan District",
        岭东区: "Lingdong District",
        饶河县: "Raohe county",
        四方台区: "Sifangtai district",
        友谊县: "Friendship county",
        宝兴县: "Baoxing county",
        汉源县: "Hanyuan county",
        芦山县: "Lushan county",
        名山区: "Of mountainous",
        石棉县: "Asbestos county",
        天全县: "Tianquan county",
        荥经县: "Xingjing county",
        雨城区: "Yucheng District",
        宝应县: "Baoying county",
        高邮市: "Gaoyou City",
        广陵区: "Guangling District",
        邗江区: "Hanjiang District",
        江都区: "Jiangdu District",
        仪征市: "Yizheng city",
        保德县: "Baode county",
        代县: "Dai county",
        定襄县: "Dingxiang county",
        繁峙县: "Fanzhi county",
        河曲县: "Hequ county",
        静乐县: "Jingle county",
        岢岚县: "Kelan county",
        宁武县: "Ningwu county",
        偏关县: "Pianguan county",
        神池县: "Shenchi county",
        五台山风景名胜区: "Wutai Mountain Scenic Area",
        五台县: "Wutai county",
        五寨县: "Wuzhai county",
        忻府区: "Xinfu District",
        原平市: "Yuanping City",
        保靖县: "Baojing county",
        凤凰县: "Fenghuang County",
        古丈县: "Guzhang county",
        花垣县: "Huayuan county",
        吉首市: "Jishou City",
        龙山县: "Longshan county",
        泸溪县: "Luxi county",
        永顺县: "Yongshun county",
        保康县: "Baokang county",
        樊城区: "Fancheng District",
        谷城县: "Gucheng county",
        老河口市: "Laohekou City",
        南漳县: "Nanzhang County",
        襄城区: "Xiangcheng District",
        襄州区: "Xiangzhou District",
        宜城市: "Yicheng City",
        枣阳市: "Zaoyang City",
        保亭黎族苗族自治县: "Baoting Li and Miao Autonomous County",
        北戴河区: "Beidaihe District",
        昌黎县: "Changli county",
        抚宁区: "Funing District",
        海港区: "Harbour District",
        卢龙县: "Lulong county",
        青龙满族自治县: "Qinglong Manchu Autonomous County",
        山海关区: "Shanhaiguan District",
        北流市: "Beiliu City",
        博白县: "Bobai county",
        福绵区: "Fumian District",
        陆川县: "Luchuan county",
        容县: "Rong county",
        兴业县: "Xingye county",
        玉州区: "Yuzhou District",
        北仑区: "Beilun District",
        慈溪市: "Cixi City",
        奉化区: "Fenghua District",
        海曙区: "Haishu District",
        江北区: "Jiangbei District",
        宁海县: "Ninghai county",
        象山县: "Xiangshan county",
        鄞州区: "Yinzhou District",
        余姚市: "Yuyao City",
        镇海区: "Zhenhai District",
        北票市: "Beipiao City",
        朝阳县: "Chaoyang county",
        建平县: "Jianping county",
        喀喇沁左翼蒙古族自治县: "Kalaqin Left-wing Mongolian Autonomous County",
        凌源市: "Lingyuan City",
        龙城区: "Longcheng District",
        双塔区: "Twin towers area",
        北区: "North District",
        大埔区: "Tai Po District",
        葵青区: "Kwai Tsing District",
        离岛区: "Islands District",
        荃湾区: "Tsuen Wan District",
        沙田区: "Sha Tin District",
        屯门区: "Tuen Mun District",
        西贡区: "Sai Kung District",
        元朗区: "Yuen Long District",
        北塔区: "North Tower District",
        城步苗族自治县: "Chengbu Miao Autonomous County",
        大祥区: "Daxiang District",
        洞口县: "Dongkou county",
        隆回县: "Longhui county",
        邵东市: "Shaodong City",
        邵阳县: "Shaoyang county",
        双清区: "Shuangqing District",
        绥宁县: "Suining county",
        武冈市: "Wugang City",
        新宁县: "Xinning county",
        新邵县: "Xinshao county",
        北屯市: "Beitun city",
        北镇市: "Beizhen City",
        古塔区: "Ghouta district",
        黑山县: "Montenegro County",
        凌海市: "Linghai City",
        凌河区: "Linghe District",
        太和区: "Taihe District",
        义县: "Yixian",
        本溪满族自治县: "Benxi Manchu Autonomous County",
        桓仁满族自治县: "Huanren Manchu Autonomous County",
        明山区: "Mingshan District",
        南芬区: "Nanfen District",
        平山区: "Pingshan District",
        溪湖区: "Xihu District",
        碧江区: "Bijiang District",
        德江县: "Dejiang county",
        江口县: "Eguchi prefecture",
        石阡县: "Shiqian county",
        思南县: "Sinan county",
        松桃苗族自治县: "Songtao Miao Autonomous County",
        万山区: "Million mountainous",
        沿河土家族自治县: "Yanhe Tujia Autonomous County",
        印江土家族苗族自治县: "Yinjiang Tujia and Miao Autonomous County",
        玉屏侗族自治县: "Yuping Dong Autonomous County",
        宾川县: "Binchuan county",
        大理市: "Dali City",
        洱源县: "Eryuan county",
        鹤庆县: "Heqing county",
        剑川县: "Jianchuan county",
        弥渡县: "Midu county",
        南涧彝族自治县: "Nanjian Yi Autonomous County",
        巍山彝族回族自治县: "Weishan Yi and Hui Autonomous County",
        祥云县: "Xiangyun county",
        漾濞彝族自治县: "Yangbi Yi Autonomous County",
        永平县: "Yongping county",
        云龙县: "Yunlong county",
        宾阳县: "Binyang county",
        横州市: "Yokoshu City",
        江南区: "Jiangnan District",
        良庆区: "Liangqing District",
        隆安县: "Long'an county",
        马山县: "Mashan county",
        青秀区: "Qingxiu District",
        上林县: "Shanglin county",
        武鸣区: "Wuming District",
        西乡塘区: "Xixiangtang District",
        兴宁区: "Xingning District",
        邕宁区: "Yongning District",
        彬州市: "Binzhou City",
        淳化县: "Chunhua county",
        泾阳县: "Jingyang county",
        礼泉县: "Liquan county",
        乾县: "Qian county",
        秦都区: "Qindu District",
        三原县: "Sanyuan county",
        渭城区: "Weicheng District",
        武功县: "Wugong county",
        兴平市: "Xingping City",
        旬邑县: "Xunyi county",
        杨陵区: "Yangling District",
        永寿县: "Yongshou county",
        长武县: "Changwu county",
        滨城区: "Bincheng District",
        博兴县: "Boxing county",
        惠民县: "Huimin county",
        无棣县: "Wudi county",
        阳信县: "Yangxin county",
        沾化区: "Contaminated zone",
        邹平市: "Zouping City",
        滨海县: "Binhai county",
        大丰区: "Dafeng District",
        东台市: "Dongtai city",
        阜宁县: "Funing county",
        建湖县: "Jianhu county",
        射阳县: "Sheyang county",
        亭湖区: "Tinghu District",
        响水县: "Xiangshui county",
        盐都区: "Yandu District",
        滨湖区: "Binhu District",
        惠山区: "Huishan District",
        江阴市: "Jiangyin City",
        梁溪区: "Liangxi District",
        锡山区: "Xishan District",
        新吴区: "Xinwu District",
        宜兴市: "Yixing City",
        滨江区: "Binjiang District",
        淳安县: "Chun'an county",
        富阳区: "Fuyang District",
        拱墅区: "Gongshu District",
        建德市: "Jiande city",
        临安区: "Lin'an District",
        临平区: "Linping District",
        钱塘区: "Qiantang District",
        上城区: "Shangcheng District",
        桐庐县: "Tonglu county",
        萧山区: "Xiaoshan District",
        余杭区: "Yuhang District",
        播州区: "Bozhou District",
        赤水市: "Chishui City",
        道真仡佬族苗族自治县: "Daozhen Gelao and Miao Autonomous County",
        凤冈县: "Fenggang county",
        红花岗区: "Honghuagang District",
        汇川区: "Huichuan District",
        湄潭县: "Meitan county",
        仁怀市: "Renhuai city",
        绥阳县: "Suiyang county",
        桐梓县: "Tongzi county",
        务川仡佬族苗族自治县: "Wuchuan Gelao and Miao Autonomous County",
        习水县: "Xishui county",
        余庆县: "Yuqing county",
        正安县: "Zheng'an county",
        勃利县: "Burley county",
        茄子河区: "Eggplant River District",
        桃山区: "Taoshan District",
        新兴区: "Emerging regions",
        博爱县: "Boai county",
        解放区: "Liberated areas",
        马村区: "Machun district",
        孟州市: "Mengzhou City",
        沁阳市: "Qinyang City",
        山阳区: "Shanyang District",
        温县: "Wen County",
        武陟县: "Wuzhi county",
        修武县: "Xiuwu county",
        中站区: "Middle station area",
        博湖县: "Bohu county",
        和静县: "Hejing county",
        和硕县: "Heshuo county",
        库尔勒市: "Korla City",
        轮台县: "Luntai county",
        且末县: "Qiemo county",
        若羌县: "Ruoqiang county",
        尉犁县: "Yuli county",
        焉耆回族自治县: "Yanqi Hui Autonomous County",
        博罗县: "Boluo county",
        惠城区: "Huicheng District",
        惠东县: "Huidong county",
        惠阳区: "Huiyang District",
        龙门县: "Longmen county",
        博山区: "Boshan District",
        高青县: "Gaoqing county",
        桓台县: "Huantai county",
        临淄区: "Linzi District",
        沂源县: "Yiyuan county",
        张店区: "Zhangdian District",
        周村区: "Zhoucun District",
        淄川区: "Zichuan District",
        博望区: "Bowang District",
        当涂县: "Dangtu county",
        含山县: "Hanshan county",
        和县: "And county",
        花山区: "Huashan District",
        雨山区: "Rain mountain area",
        布拖县: "Butuo county",
        德昌县: "Dechang county",
        甘洛县: "Ganluo county",
        会东县: "Huidong county",
        会理市: "Huili city",
        金阳县: "Jinyang county",
        雷波县: "Lebo county",
        美姑县: "Meigu county",
        冕宁县: "Mianning county",
        木里藏族自治县: "Muli Tibetan Autonomous County",
        宁南县: "Ningnan county",
        普格县: "Pugh county",
        西昌市: "Xichang City",
        喜德县: "Xide county",
        盐源县: "Yanyuan county",
        越西县: "Yuexi county",
        昭觉县: "Zhaojue county",
        蔡甸区: "Caidian District",
        东西湖区: "Dongxihu District",
        汉南区: "Hannan District",
        汉阳区: "Hanyang District",
        洪山区: "Hongshan District",
        黄陂区: "Huangpi District",
        江岸区: "Riverbank district",
        江汉区: "Jianghan District",
        江夏区: "Jiangxia District",
        硚口区: "Qiaokou District",
        武昌区: "Wuchang District",
        新洲区: "Xinzhou District",
        仓山区: "Cangshan District",
        福清市: "Fuqing City",
        鼓楼区: "Gulou District",
        晋安区: "Jin'an District",
        连江县: "Lianjiang county",
        罗源县: "Luoyuan county",
        马尾区: "Horsetail area",
        闽侯县: "Minhou county",
        闽清县: "Minqing county",
        平潭县: "Pingtan county",
        台江区: "Taijiang District",
        永泰县: "Yongtai county",
        长乐区: "Changle District",
        苍南县: "Cangnan county",
        洞头区: "Dongtou District",
        乐清市: "Yueqing City",
        龙港市: "Longgang City",
        龙湾区: "Longwan District",
        鹿城区: "Lucheng District",
        瓯海区: "Ouhai District",
        平阳县: "Pingyang county",
        瑞安市: "Ruian City",
        泰顺县: "Taishun county",
        文成县: "Wencheng county",
        永嘉县: "Yongjia county",
        苍梧县: "Cangwu county",
        岑溪市: "Cenxi city",
        龙圩区: "Longwei District",
        蒙山县: "Mengshan county",
        藤县: "Teng County",
        万秀区: "Wanxiu District",
        长洲区: "Cheung Chau District",
        苍溪县: "Cangxi county",
        朝天区: "Chaotian District",
        剑阁县: "Jiange Prefecture",
        利州区: "Lizhou District",
        青川县: "Qingchuan county",
        旺苍县: "Wangcang county",
        昭化区: "Zhaohua District",
        沧县: "Cang county",
        东光县: "Dongguang county",
        海兴县: "Haixing county",
        河间市: "Hejian City",
        黄骅市: "Huanghua City",
        孟村回族自治县: "Mengcun Hui Autonomous County",
        南皮县: "Nanpi county",
        泊头市: "Botou City",
        青县: "Qing County",
        任丘市: "Renqiu city",
        肃宁县: "Suning county",
        吴桥县: "Wuqiao county",
        献县: "Xian county",
        盐山县: "Yanshan county",
        运河区: "Canal zone",
        沧源佤族自治县: "Cangyuan Wa Autonomous County",
        凤庆县: "Fengqing county",
        耿马傣族佤族自治县: "Gengma Dai and Wa Autonomous County",
        临翔区: "Linxiang District",
        双江拉祜族佤族布朗族傣族自治县: '"Shuangjiang Lahu',
        永德县: "Yongde county",
        云县: "Yun County",
        镇康县: "Zhenkang county",
        曹妃甸区: "Caofeidian district",
        丰南区: "Fengnan District",
        丰润区: "Rich zone",
        古冶区: "Ancient metallurgical area",
        开平区: "Kaiping District",
        乐亭县: "Leting county",
        路北区: "Lubei District",
        路南区: "Lunan District",
        滦南县: "Luannan county",
        滦州市: "Luanzhou City",
        迁安市: "Qian'an city",
        迁西县: "Qianxi county",
        玉田县: "Yutian county",
        遵化市: "Zunhua City",
        曹县: "Cao County",
        成武县: "Chengwu county",
        单县: "Shan County",
        定陶区: "Fixed pottery area",
        东明县: "Dongming county",
        巨野县: "Juye county",
        鄄城县: "Juancheng county",
        牡丹区: "Peony District",
        郓城县: "Yuncheng county",
        策勒县: "Celle county",
        和田市: "Hotan City",
        和田县: "Hotan county",
        洛浦县: "Luopu county",
        民丰县: "Minfeng county",
        墨玉县: "Moyu county",
        皮山县: "Pishan county",
        于田县: "Yutian county",
        岑巩县: "Cengong county",
        从江县: "Congjiang county",
        丹寨县: "Danzhai county",
        黄平县: "Huangping county",
        剑河县: "Jianhe county",
        锦屏县: "Jinping county",
        凯里市: "City of Kaili",
        雷山县: "Leishan county",
        黎平县: "Liping county",
        麻江县: "Majiang county",
        榕江县: "Rongjiang county",
        三穗县: "Sansui county",
        施秉县: "Shibing county",
        台江县: "Taijiang county",
        天柱县: "Tianzhu county",
        镇远县: "Zhenyuan county",
        曾都区: "Zengdu District",
        广水市: "Guangshui City",
        随县: "Suixian",
        茶陵县: "Chaling county",
        荷塘区: "Lotus pond district",
        醴陵市: "Liling city",
        芦淞区: "Lusong District",
        渌口区: "Lukou District",
        石峰区: "Shifeng District",
        天元区: "Tianyuan District",
        炎陵县: "Yanling county",
        攸县: "You county",
        茶山镇: "Chashan Town",
        常平镇: "Changping town",
        大朗镇: "Dalang town",
        大岭山镇: "Dalingshan Town",
        道滘镇: "Daojiao town",
        东城街道: "Dongcheng Street",
        东坑镇: "Dongkeng town",
        凤岗镇: "Fenggang town",
        高埗镇: "Kao Po Town",
        莞城街道: "Guancheng Street",
        横沥镇: "Hengli town",
        洪梅镇: "Hongmei town",
        厚街镇: "Houjie Town",
        虎门镇: "Humen Town",
        黄江镇: "Huangjiang Town",
        寮步镇: "Liaobu town",
        麻涌镇: "Ma Chung Town",
        南城街道: "Nancheng Street",
        企石镇: "Qishi Town",
        桥头镇: "Qiaotou town",
        清溪镇: "Qingxi Town",
        沙田镇: "Sha Tin Town",
        石碣镇: "Shijie town",
        石龙镇: "Shilong town",
        石排镇: "Shipai town",
        塘厦镇: "Tangxia town",
        万江街道: "Wanjiang Street",
        望牛墩镇: "Wangniudun town",
        谢岗镇: "Xiegang Town",
        樟木头镇: "Zhangmutou Town",
        长安镇: "Chang'an Town",
        中堂镇: "Zhongtang town",
        察布查尔锡伯自治县: "Chabuchar Xibo Autonomous County",
        巩留县: "Gongliu county",
        霍城县: "Huocheng county",
        霍尔果斯市: "Khorgos City",
        奎屯市: "Kuitun City",
        尼勒克县: "Nilek county",
        特克斯县: "Turks county",
        新源县: "Xinyuan county",
        伊宁市: "Yining City",
        伊宁县: "Yining county",
        昭苏县: "Zhaosu county",
        察哈尔右翼后旗: "Chahar right rear flag",
        察哈尔右翼前旗: "Right wing front flag of Chahar",
        察哈尔右翼中旗: "Chahar right wing middle flag",
        丰镇市: "Fengzhen City",
        化德县: "Huade county",
        集宁区: "Jining District",
        凉城县: "Liangcheng county",
        商都县: "Shangdu county",
        四子王旗: "Four Wang Qi ",
        兴和县: "Xinghe County",
        卓资县: "Zhuozi county",
        柴桑区: "Chaisang District",
        德安县: "De'an County",
        都昌县: "Duchang county",
        共青城市: "Gongqingcheng city",
        湖口县: "Hukou county",
        濂溪区: "Lianxi District",
        庐山市: "Lushan City",
        彭泽县: "Pengze county",
        瑞昌市: "Ruichang City",
        武宁县: "Wuning county",
        修水县: "Xiushui county",
        浔阳区: "Xunyang District",
        永修县: "Yongxiu county",
        禅城区: "Chancheng District",
        高明区: "Gaoming District",
        南海区: "Nanhai District",
        三水区: "Sanshui District",
        顺德区: "Shunde District",
        瀍河回族区: "Luhe Hui area",
        涧西区: "Jianxi District",
        老城区: "Old town",
        栾川县: "Luanchuan county",
        洛龙区: "Luolong District",
        洛宁县: "Luoning county",
        孟津区: "Mengjin District",
        汝阳县: "Ruyang county",
        嵩县: "Song county",
        西工区: "Xigong District",
        新安县: "Xin'an county",
        偃师区: "Yanshi District",
        伊川县: "Ikawa Prefecture",
        宜阳县: "Yiyang county",
        昌吉市: "Changji City",
        阜康市: "Fukang City",
        呼图壁县: "Hutubi county",
        吉木萨尔县: "Jimsar county",
        玛纳斯县: "Manas county",
        木垒哈萨克自治县: "Mulei Kazakh Autonomous County",
        奇台县: "Qitai county",
        昌江黎族自治县: "Changjiang Li Autonomous County",
        昌江区: "Changjiang District",
        浮梁县: "Fuliang county",
        乐平市: "Leping City",
        珠山区: "Zhushan District",
        昌宁县: "Changning county",
        龙陵县: "Longling county",
        隆阳区: "Longyang District",
        施甸县: "Shidian county",
        腾冲市: "Tengchong city",
        昌图县: "Changtu county",
        调兵山市: "Diaobenshan City",
        开原市: "Kaiyuan City",
        清河区: "Qinghe District",
        铁岭县: "Tieling county",
        西丰县: "Xifeng county",
        银州区: "Yinzhou District",
        昌邑区: "Changyi District",
        船营区: "Ship camp area",
        丰满区: "Plump zone",
        桦甸市: "Huadian City",
        蛟河市: "Jiaohe City",
        龙潭区: "Longtan District",
        磐石市: "ROCK City",
        舒兰市: "Shulan City",
        永吉县: "Yongji county",
        常宁市: "Changning City",
        衡东县: "Hengdong county",
        衡南县: "Hengnan county",
        衡山县: "Hengshan county",
        衡阳县: "Hengyang county",
        耒阳市: "Leiyang City",
        南岳区: "Nanyue District",
        祁东县: "Qidong county",
        石鼓区: "Shigu District",
        雁峰区: "Yanfeng District",
        蒸湘区: "Steaming Xiang District",
        珠晖区: "Zhuhui District",
        常山县: "Changshan county",
        江山市: "Jiangshan City",
        开化县: "Kaihua county",
        柯城区: "Kecheng District",
        龙游县: "Longyou county",
        衢江区: "Qujiang District",
        常熟市: "Changshu City",
        姑苏区: "Gusu District",
        虎丘区: "Huqiu District",
        昆山市: "Kunshan City",
        苏州工业园区: "Suzhou Industrial Park",
        太仓市: "Taicang City",
        吴江区: "Wujiang District",
        吴中区: "Wuzhong District",
        相城区: "Xiangcheng District",
        张家港市: "Zhangjiagang city",
        朝阳区: "Chaoyang District",
        德惠市: "Dehui City",
        二道区: "Erdao District",
        公主岭市: "Gongzhuling City",
        九台区: "Jiutai District",
        宽城区: "Kuancheng District",
        绿园区: "Green Park District",
        南关区: "Nanguan District",
        农安县: "Nong'an County",
        双阳区: "Shuangyang District",
        榆树市: "Yushu City",
        潮安区: "Chao'an District",
        饶平县: "Raoping county",
        湘桥区: "Xiangqiao District",
        潮南区: "Chaonan District",
        潮阳区: "Chaoyang District",
        澄海区: "Chenghai District",
        濠江区: "Haojiang District",
        金平区: "Jinping District",
        龙湖区: "Longhu District",
        南澳县: "Nan ao county",
        辰溪县: "Chenxi county",
        鹤城区: "Hecheng District",
        洪江市: "Hongjiang City",
        会同县: "Tongtong county",
        靖州苗族侗族自治县: "Jingzhou Miao and Dong Autonomous County",
        麻阳苗族自治县: "Mayang Miao Autonomous County",
        通道侗族自治县: "Tongdao Dong Autonomous County",
        新晃侗族自治县: "Xinhuang Dong Autonomous County",
        溆浦县: "Xupu county",
        沅陵县: "Yuanling county",
        芷江侗族自治县: "Zhijiang Dong Autonomous County",
        中方县: "Chinese counties",
        陈仓区: "Chencang District",
        凤县: "Feng county",
        凤翔区: "Fengxiang District",
        扶风县: "Fufeng county",
        金台区: "Jintai District",
        麟游县: "Linyou county",
        陇县: "Long county",
        眉县: "Mei County",
        岐山县: "Qishan county",
        千阳县: "Qianyang county",
        太白县: "Taibai county",
        渭滨区: "Weibin District",
        称多县: "Chengduo County",
        囊谦县: "Nangqian county",
        曲麻莱县: "Qumalai county",
        玉树市: "Yushu City",
        杂多县: "Zado county",
        治多县: "Zhiduo county",
        成安县: "Cheng'an county",
        磁县: "Ci county",
        丛台区: "Congtai district",
        大名县: "Daming county",
        肥乡区: "Feixiang District",
        峰峰矿区: "Fengfeng mining area",
        复兴区: "Renaissance Zone",
        馆陶县: "Guantao county",
        广平县: "Guangping county",
        邯山区: "Handan District",
        鸡泽县: "Jize county",
        临漳县: "Linzhang county",
        邱县: "Qiu County",
        曲周县: "Quzhou county",
        涉县: "Shexian",
        魏县: "Wei county",
        武安市: "Wu'an City",
        永年区: "Yongnian District",
        成华区: "Chenghua District",
        崇州市: "Chongzhou City",
        大邑县: "Dayi county",
        都江堰市: "Dujiangyan City",
        简阳市: "Jianyang City",
        金牛区: "Taurus District",
        金堂县: "Jintang county",
        锦江区: "Jinjiang District",
        龙泉驿区: "Longquanyi District",
        彭州市: "Pengzhou City",
        郫都区: "Pidu District",
        蒲江县: "Pujiang county",
        青白江区: "Qingbaijiang District",
        青羊区: "Qingyang District",
        邛崃市: "Qionglai City",
        双流区: "Two-flow region",
        温江区: "Wenjiang District",
        武侯区: "Wuhou District",
        新都区: "Xindu District",
        新津区: "Xinjin District",
        成县: "Chengxian",
        宕昌县: "Dangchang county",
        徽县: "Huixian",
        康县: "Kang county",
        礼县: "Lixian",
        两当县: "Liangdang county",
        文县: "Wen county",
        武都区: "Wudu District",
        西和县: "Xihe county",
        承德县: "Chengde county",
        丰宁满族自治县: "Fengning Manchu Autonomous County",
        宽城满族自治县: "Kuancheng Manchu Autonomous County",
        隆化县: "Longhua county",
        滦平县: "Luanping county",
        平泉市: "Hiraizumi city",
        双滦区: "Shuangluan District",
        双桥区: "Shuangqiao District",
        围场满族蒙古族自治县: "Weichang Manchu Mongolian Autonomous County",
        兴隆县: "Xinglong county",
        鹰手营子矿区: "Eagle Hand Yingzi Mining Area",
        城北区: "Chengbei District",
        城东区: "Chengdong District",
        城西区: "Chengxi District",
        城中区: "Chengzhong District",
        大通回族土族自治县: "Datong Hui Autonomous County",
        湟源县: "Huangyuan county",
        湟中区: "Huangzhong District",
        城固县: "Chenggu county",
        佛坪县: "Foping county",
        汉台区: "Hantai District",
        留坝县: "Liuba county",
        略阳县: "Lueyang county",
        勉县: "Mian county",
        南郑区: "Nanzheng District",
        宁强县: "Ningqiang county",
        西乡县: "Xixiang county",
        洋县: "Yang county",
        镇巴县: "Zhenba county",
        达孜区: "Dazi district",
        当雄县: "Dangxiong county",
        堆龙德庆区: "Duilongdeqing District",
        林周县: "Linzhou county",
        墨竹工卡县: "Mozhu Gongka County",
        尼木县: "Nimu county",
        曲水县: "Qushui county",
        城区: "Urban area",
        高平市: "Gaoping City",
        陵川县: "Lingchuan county",
        沁水县: "Qinshui county",
        阳城县: "Yangcheng county",
        泽州县: "Zezhou County",
        郊区: "Suburbs",
        矿区: "Mining area",
        平定县: "Pingding county",
        盂县: "Yuxian County",
        海丰县: "Haifeng county",
        陆丰市: "Lufeng City",
        陆河县: "Luhe county",
        城厢区: "Chengxiang District",
        涵江区: "Hanjiang District",
        荔城区: "Licheng District",
        仙游县: "Xianyou county",
        秀屿区: "Xiuyu District",
        城阳区: "Chengyang District",
        黄岛区: "Huangdao District",
        即墨区: "Jimo District",
        胶州市: "Jiaozhou City",
        莱西市: "Lacey City",
        崂山区: "Laoshan District",
        李沧区: "Licang District",
        平度市: "Pingdu City",
        市北区: "Shibei District",
        市南区: "Shinan District",
        柳北区: "Liubei District",
        柳城县: "Liucheng county",
        柳江区: "Liujiang District",
        柳南区: "Liunan District",
        鹿寨县: "Luzhai county",
        融安县: "Rong'an county",
        融水苗族自治县: "Rongshui Miao Autonomous County",
        三江侗族自治县: "Sanjiang Dong Autonomous County",
        鱼峰区: "Yufeng District",
        城子河区: "Chengzihe District",
        滴道区: "Drip zone",
        恒山区: "Hengshan District",
        虎林市: "Hulin City",
        鸡东县: "Jidong county",
        鸡冠区: "Cockcomb area",
        梨树区: "Pear tree district",
        麻山区: "Mashan District",
        密山市: "Mishan City",
        澄江市: "Chengjiang City",
        峨山彝族自治县: "Eshan Yi Autonomous County",
        红塔区: "Hongta District",
        华宁县: "Huaning county",
        江川区: "Jiangchuan District",
        通海县: "Tonghai county",
        新平彝族傣族自治县: "Xinping Yi and Dai Autonomous County",
        易门县: "Yimen county",
        元江哈尼族彝族傣族自治县: '"Yuanjiang Hani',
        澄迈县: "Chengmai county",
        茌平区: "Chiping district",
        东阿县: "Dong'e county",
        东昌府区: "Dongchangfu District",
        高唐县: "Gaotang county",
        冠县: "Guan county",
        临清市: "Linqing City",
        莘县: "Shen County",
        阳谷县: "Yanggu county",
        赤壁市: "Chibi City",
        崇阳县: "Chongyang county",
        嘉鱼县: "Jiayu county",
        通城县: "Tongcheng county",
        通山县: "Tongshan county",
        咸安区: "Xian'an District",
        赤城县: "Akagi county",
        崇礼区: "Chongli District",
        沽源县: "Guyuan county",
        怀安县: "Huai'an county",
        怀来县: "Huailai county",
        康保县: "Kangbao county",
        桥东区: "Qiaodong District",
        桥西区: "Qiaoxi District",
        尚义县: "Shangyi county",
        万全区: "Million district",
        蔚县: "Wei county",
        下花园区: "Lower garden area",
        宣化区: "Xuanhua District",
        阳原县: "Yangyuan county",
        张北县: "Zhangbei county",
        涿鹿县: "Zhuolu county",
        赤坎区: "Chikan district",
        雷州市: "Leizhou City",
        廉江市: "Lianjiang city",
        麻章区: "Mazhang District",
        坡头区: "Potou district",
        遂溪县: "Suixi county",
        吴川市: "Wuchuan City",
        霞山区: "Xiashan District",
        徐闻县: "Xuwen county",
        崇川区: "Chongchuan District",
        海安市: "Hai'an City",
        海门区: "Haimen District",
        启东市: "Qidong City",
        如东县: "Rudong county",
        如皋市: "Rugao City",
        通州区: "Tongzhou District",
        崇仁县: "Chongren county",
        东乡区: "Dongxiang District",
        广昌县: "Guangchang county",
        金溪县: "Jinxi county",
        乐安县: "Le'an county",
        黎川县: "Lichuan county",
        临川区: "Linchuan District",
        南城县: "Nancheng county",
        南丰县: "Nanfeng county",
        宜黄县: "Yihuang county",
        资溪县: "Zixi county",
        崇信县: "Chongxin county",
        华亭市: "Huating City",
        泾川县: "Jingchuan county",
        静宁县: "Jingning county",
        崆峒区: "Kongtong District",
        灵台县: "Lingtai county",
        庄浪县: "Zhuanglang county",
        楚雄市: "Chuxiong City",
        大姚县: "Dayao county",
        禄丰市: "Lufeng City",
        牟定县: "Mouding county",
        南华县: "Nanhua county",
        双柏县: "Shuangbai county",
        武定县: "Wuding county",
        姚安县: "Yao'an county",
        永仁县: "Yongren county",
        元谋县: "Yuanmou county",
        川汇区: "Chuanhui District",
        郸城县: "Dancheng county",
        扶沟县: "Fugou county",
        淮阳区: "Huaiyang District",
        鹿邑县: "Luyi county",
        商水县: "Shangshui county",
        沈丘县: "Shenqiu county",
        太康县: "Taikang county",
        西华县: "Xihua county",
        项城市: "Xiangcheng City",
        慈利县: "Cili county",
        桑植县: "Sangzhi county",
        武陵源区: "Wulingyuan District",
        永定区: "Yongding district",
        枞阳县: "Zongyang county",
        铜官区: "Tongguan District",
        义安区: "Yian District",
        翠屏区: "Cuiping District",
        高县: "Gao county",
        珙县: "Gong county",
        江安县: "Jiang'an county",
        南溪区: "Nanxi District",
        屏山县: "Pingshan county",
        兴文县: "Xingwen county",
        叙州区: "Xuzhou District",
        筠连县: "Junlian county",
        长宁县: "Changning county",
        措美县: "Cuomei county",
        错那县: "Cuona county",
        贡嘎县: "Gongga county",
        加查县: "Gacha county",
        浪卡子县: "Langkazi county",
        隆子县: "Longzi county",
        洛扎县: "Loza county",
        乃东区: "Nai Dong District",
        琼结县: "Qiongjie county",
        曲松县: "Qusong county",
        桑日县: "Sangri county",
        扎囊县: "ZhaNang county",
        措勤县: "Cuoqin county",
        噶尔县: "Gar county",
        改则县: "Gaize county",
        革吉县: "Geji county",
        普兰县: "Pulan county",
        日土县: "Hitu prefecture",
        札达县: "Zada county",
        达坂城区: "Dabancheng District",
        米东区: "Midong District",
        沙依巴克区: "Shaibak district",
        水磨沟区: "Watermill ditch area",
        天山区: "Tianshan District",
        头屯河区: "Toutunhe district",
        乌鲁木齐县: "Urumqi county",
        新市区: "New urban area",
        达川区: "Dachuan District",
        大竹县: "Dazhu county",
        开江县: "Kaijiang county",
        渠县: "Qu county",
        通川区: "Tongchuan district",
        万源市: "Wanyuan City",
        宣汉县: "Xuanhan county",
        达拉特旗: "Dalat flag",
        东胜区: "Dongsheng District",
        鄂托克旗: "Etok flag",
        鄂托克前旗: "Etok front flag",
        杭锦旗: "Hangjin Banner",
        康巴什区: "Kangbashi district",
        乌审旗: "Wushen Banner",
        伊金霍洛旗: "Ijinhoro flag",
        准格尔旗: "Junggar flag",
        大安区: "Da'an District",
        富顺县: "Fushun county",
        贡井区: "Gongjing district",
        荣县: "Rong county",
        沿滩区: "Beachfront area",
        自流井区: "Artesian well area",
        大安市: "Da'an City",
        洮北区: "Taobei District",
        洮南市: "TaoNan city",
        通榆县: "Tongyu county",
        镇赉县: "Zhenlai county",
        大柴旦行政区: "Dachaidan administrative region",
        德令哈市: "Delingha City",
        都兰县: "Dulan county",
        格尔木市: "Golmud city",
        茫崖市: "Mangya City",
        天峻县: "Tianjun county",
        乌兰县: "Ulan county",
        大东区: "Dadong District",
        法库县: "Faku county",
        和平区: "Zone of peace",
        皇姑区: "Huanggu District",
        浑南区: "Hunnan District",
        康平县: "Kangping county",
        辽中区: "Liaozhong District",
        沈北新区: "Shenbei New District",
        沈河区: "Shenhe District",
        苏家屯区: "Sujiatun District",
        铁西区: "Tiexi District",
        新民市: "Xinmin City",
        于洪区: "Yuhong District",
        大方县: "Dafang county",
        赫章县: "Hezhang county",
        金沙县: "Jinsha County",
        纳雍县: "Nayong county",
        七星关区: "Qixingguan District",
        黔西市: "Qianxi City",
        威宁彝族回族苗族自治县: '"Weining Yi',
        织金县: "Zhijin county",
        大关县: "Daguan county",
        鲁甸县: "Ludian county",
        巧家县: "Qiaojia county",
        水富市: "Mizuho City",
        绥江县: "Suijiang county",
        威信县: "Weixin county",
        盐津县: "Yanjin county",
        彝良县: "Yiliang county",
        永善县: "Yongshan county",
        昭阳区: "Zhaoyang District",
        镇雄县: "Zhenxiong county",
        大观区: "Daguan District",
        怀宁县: "Huaining county",
        潜山市: "Qianshan City",
        宿松县: "Susong county",
        太湖县: "Taihu County",
        桐城市: "Tongcheng City",
        望江县: "Wangjiang county",
        宜秀区: "Yixiu District",
        迎江区: "Yingjiang District",
        岳西县: "Yuexi county",
        大埔县: "Tai Po County",
        丰顺县: "Fengshun county",
        蕉岭县: "Jiaoling county",
        梅江区: "Meijiang District",
        梅县区: "Meixian District",
        平远县: "Pingyuan county",
        五华县: "Wuhua county",
        兴宁市: "Xingning City",
        大箐山县: "Daqingshan county",
        丰林县: "Fenglin county",
        嘉荫县: "Jiayin county",
        金林区: "Jinlin District",
        南岔县: "Nancha county",
        汤旺县: "Tangwang county",
        铁力市: "Tieli City",
        乌翠区: "Wucui District",
        伊美区: "Yimei District",
        友好区: "Friendly zone",
        大堂区: "Lobby area",
        风顺堂区: "Fengshun Parish",
        花地玛堂区: "Parish of Huadima",
        花王堂区: "Flower King Parish",
        望德堂区: "Wangde Parish",
        大田县: "Daejeon prefecture",
        建宁县: "Jianning county",
        将乐县: "Jiangle county",
        明溪县: "Mingxi county",
        宁化县: "Ninghua county",
        清流县: "Qingliu county",
        三元区: "Ternary region",
        沙县区: "Shaxian District",
        泰宁县: "Taining county",
        永安市: "Yong'an City",
        尤溪县: "Youxi county",
        大同区: "Datong District",
        杜尔伯特蒙古族自治县: "Durbert Mongolian Autonomous County",
        红岗区: "Honggang District",
        林甸县: "Lindian county",
        龙凤区: "Longfeng District",
        让胡路区: "Jeanhulu district",
        萨尔图区: "Sartu district",
        肇源县: "Zhaoyuan county",
        肇州县: "Zhaozhou County",
        大洼区: "Dawa District",
        盘山县: "Panshan county",
        双台子区: "Shuangtaizi area",
        兴隆台区: "Xinglongtai district",
        大武口区: "Dawukou District",
        惠农区: "Huinong District",
        平罗县: "Pingluo county",
        大新县: "Daxin county",
        扶绥县: "Fusui county",
        江州区: "Jiangzhou District",
        龙州县: "Longzhou county",
        宁明县: "Ningming county",
        凭祥市: "Pingxiang City",
        天等县: "Tianping county",
        大冶市: "Daye City",
        黄石港区: "Yellowstone Harbor Area",
        铁山区: "Tieshan District",
        西塞山区: "Xisai Mountains",
        下陆区: "Downland zone",
        阳新县: "Yangxin county",
        岱山县: "Daishan county",
        定海区: "Dinghai area",
        普陀区: "Putuo District",
        嵊泗县: "Shengsi county",
        岱岳区: "Daiyue District",
        东平县: "Dongping county",
        肥城市: "Feicheng City",
        宁阳县: "Ningyang county",
        泰山区: "Taishan District",
        新泰市: "Xintai City",
        丹凤县: "Danfeng county",
        洛南县: "Luonan county",
        山阳县: "Shanyang county",
        商南县: "Shangnan county",
        商州区: "Shangzhou District",
        柞水县: "Zhashui county",
        镇安县: "Zhen'an county",
        丹江口市: "Danjiangkou City",
        房县: "Fang county",
        茅箭区: "Maojian District",
        郧西县: "Yunxi county",
        郧阳区: "Yunyang District",
        张湾区: "Zhangwan District",
        竹山县: "Zhushan county",
        竹溪县: "Zhuxi county",
        丹棱县: "Danling county",
        东坡区: "Dongpo District",
        洪雅县: "Hongya county",
        彭山区: "Pengshan District",
        青神县: "Qingshen county",
        仁寿县: "Renshou county",
        丹徒区: "Dantu District",
        丹阳市: "Danyang City",
        京口区: "Jingkou District",
        句容市: "Jurong city",
        润州区: "Runzhou District",
        扬中市: "Yangzhong City",
        儋州市: "Danzhou city",
        当阳市: "Dangyang City",
        点军区: "Point area",
        五峰土家族自治县: "Wufeng Tujia Autonomous County",
        伍家岗区: "Wujiagang District",
        西陵区: "Xiling District",
        猇亭区: "Xiaoting District",
        兴山县: "Xingshan county",
        夷陵区: "Yiling District",
        宜都市: "Yidu City",
        远安县: "Yuan'an county",
        长阳土家族自治县: "Changyang Tujia Autonomous County",
        枝江市: "Zhijiang City",
        秭归县: "Zigui county",
        砀山县: "Dangshan county",
        灵璧县: "Lingbi county",
        泗县: "Si county",
        萧县: "Xiao County",
        埇桥区: "Yongqiao District",
        道县: "Dao county",
        东安县: "Dong'an county",
        江华瑶族自治县: "Jianghua Yao Autonomous County",
        江永县: "Jiangyong county",
        蓝山县: "Lanshan County",
        冷水滩区: "Coldwater beach area",
        零陵区: "Lingling District",
        宁远县: "Ningyuan county",
        祁阳市: "Qiyang City",
        双牌县: "Shuangpai county",
        新田县: "Xintian county",
        德保县: "Debao county",
        靖西市: "Jingxi City",
        乐业县: "Leye county",
        凌云县: "Lingyun county",
        隆林各族自治县: "Longlin Autonomous County",
        那坡县: "Napo county",
        平果市: "Pingguo City",
        田东县: "Tiandong county",
        田林县: "Tianlin county",
        田阳区: "Tianyang District",
        西林县: "Xilin county",
        右江区: "Youjiang District",
        德城区: "Decheng District",
        乐陵市: "Leling City",
        临邑县: "Linyi county",
        陵城区: "Lingcheng District",
        宁津县: "Ningjin county",
        平原县: "Pingyuan county",
        齐河县: "Qihe county",
        庆云县: "Qingyun county",
        武城县: "Wucheng county",
        夏津县: "Xiajin county",
        禹城市: "Yucheng City",
        德钦县: "Deqin county",
        维西傈僳族自治县: "Weixi Lisu Autonomous County",
        香格里拉市: "Shangri-La City",
        德庆县: "Deqing county",
        鼎湖区: "Dinghu District",
        端州区: "Duanzhou District",
        封开县: "Fengkai county",
        高要区: "High-key area",
        广宁县: "Guangning county",
        怀集县: "Huaiji county",
        四会市: "Sihui City",
        德兴市: "Dexing City",
        广丰区: "Guangfeng District",
        广信区: "Guangxin District",
        横峰县: "Hengfeng county",
        鄱阳县: "Poyang county",
        铅山县: "Qianshan county",
        万年县: "Wannian County",
        婺源县: "Wuyuan county",
        信州区: "Shinshu Ward",
        弋阳县: "Yiyang county",
        余干县: "Yugan county",
        玉山县: "Yushan county",
        登封市: "Dengfeng City",
        二七区: "Erqi District",
        巩义市: "Gongyi city",
        管城回族区: "Guancheng Hui area",
        惠济区: "Huiji District",
        金水区: "Jinshui District",
        上街区: "Shangjie District",
        新密市: "Xinmi City",
        新郑市: "Xinzheng City",
        荥阳市: "Xingyang City",
        中牟县: "Zhongmou county",
        中原区: "Zhongyuan District",
        邓州市: "Dengzhou City",
        方城县: "Fangcheng county",
        南召县: "Nanzhao county",
        内乡县: "Neixiang county",
        社旗县: "Sheqi county",
        唐河县: "Tanghe county",
        桐柏县: "Tongbai county",
        宛城区: "Wancheng District",
        卧龙区: "Wolong District",
        西峡县: "Xixia county",
        淅川县: "Xichuan county",
        新野县: "Xinye prefecture",
        镇平县: "Zhenping county",
        磴口县: "Dengkou county",
        杭锦后旗: "Hangjin Houqi",
        临河区: "Linhe District",
        乌拉特后旗: "Urat rear flag",
        乌拉特前旗: "Front flag of urat",
        乌拉特中旗: "Urat Middle Banner",
        五原县: "Wuyuan county",
        电白区: "Electric white area",
        高州市: "Gaozhou City",
        化州市: "Huazhou City",
        茂南区: "Maonan District",
        信宜市: "Xinyi City",
        迭部县: "Diebu county",
        合作市: "Cooperative city",
        临潭县: "Lintan county",
        碌曲县: "Luqu county",
        玛曲县: "Maqu county",
        夏河县: "Xiahe county",
        舟曲县: "Zhouqu county",
        卓尼县: "Zhuoni County",
        叠彩区: "Overlapping area",
        恭城瑶族自治县: "Gongcheng Yao Autonomous County",
        灌阳县: "Guanyang county",
        荔浦市: "Lipu City",
        临桂区: "Lingui District",
        灵川县: "Lingchuan county",
        龙胜各族自治县: "Longsheng Autonomous County",
        平乐县: "Pingle county",
        七星区: "Seven-star region",
        全州县: "Jeonju County",
        象山区: "Xiangshan District",
        兴安县: "Xing'an county",
        秀峰区: "Xiufeng District",
        雁山区: "Yanshan District",
        阳朔县: "Yangshuo county",
        永福县: "Yongfu county",
        资源县: "Resource County",
        定安县: "Ding'an county",
        定边县: "Dingbian county",
        府谷县: "Fugu county",
        横山区: "Hengshan District",
        佳县: "Jiaxian",
        靖边县: "Jingbian county",
        米脂县: "Mizhi county",
        清涧县: "Qingjian county",
        神木市: "Shenmu City",
        绥德县: "Suide county",
        吴堡县: "Wubao county",
        榆阳区: "Yuyang District",
        子洲县: "Zizhou county",
        定远县: "Dingyuan county",
        凤阳县: "Fengyang county",
        来安县: "Lai'an County",
        琅琊区: "Langya District",
        明光市: "Mingguang City",
        南谯区: "Nanqiao District",
        全椒县: "Quanjiao county",
        天长市: "Tianchang City",
        东宝区: "Dongbao District",
        掇刀区: "Duodao district",
        京山市: "Jingshan City",
        沙洋县: "Shayang county",
        钟祥市: "Zhongxiang City",
        东昌区: "Dongchang District",
        二道江区: "Erdaojiang District",
        辉南县: "Huinan county",
        集安市: "Ji'an City",
        柳河县: "Liuhe county",
        梅河口市: "Meihekou City",
        通化县: "Tonghua county",
        东方市: "Dongfang City",
        东丰县: "Dongfeng county",
        东辽县: "Dongliao county",
        龙山区: "Longshan District",
        东风区: "Dongfeng District",
        抚远市: "Fuyuan city",
        富锦市: "Fujin City",
        桦川县: "Huachuan county",
        桦南县: "Huanan county",
        前进区: "Advance zone",
        汤原县: "Tangyuan county",
        同江市: "Tongjiang City",
        向阳区: "Sunward area",
        东港区: "Donggang District",
        莒县: "Juxian County",
        岚山区: "Arashiyama District",
        五莲县: "Wulian county",
        东港市: "Donggang City",
        凤城市: "Fengcheng City",
        宽甸满族自治县: "Kuandian Manchu Autonomous County",
        元宝区: "Yuanbao District",
        振安区: "Zhen'an District",
        振兴区: "Revitalization area",
        东海县: "Donghai county",
        赣榆区: "Ganyu District",
        灌南县: "Guannan county",
        灌云县: "Guanyun county",
        海州区: "Haizhou District",
        连云区: "Lianyun District",
        东区: "East District",
        米易县: "Miyi county",
        仁和区: "Renhe District",
        西区: "West District",
        盐边县: "Yanbian county",
        南区: "Southern District",
        湾仔区: "Wan Chai District",
        中西区: "Central and Western Region",
        东山区: "Dongshan District",
        工农区: "Industrial and agricultural areas",
        萝北县: "Luobei county",
        绥滨县: "Suibin county",
        兴安区: "Xing'an District",
        兴山区: "Xingshan District",
        东山县: "Dongshan county",
        华安县: "Hua'an county",
        龙海区: "Longhai District",
        龙文区: "Longwen District",
        南靖县: "Nanjing county",
        平和县: "Pinghe county",
        芗城区: "Xiangcheng District",
        云霄县: "Yunxiao county",
        漳浦县: "Zhangpu county",
        长泰区: "Changtai District",
        诏安县: "Zhao'an county",
        东乡族自治县: "Dongxiang autonomous county",
        广河县: "Guanghe county",
        和政县: "Hozheng county",
        积石山保安族东乡族撒拉族自治县:
          "Jishi Mountain Baoan Ethnic Dongxiang Salar Autonomous County",
        康乐县: "Kangle county",
        临夏市: "Linxia City",
        临夏县: "Linxia county",
        永靖县: "Yongjing county",
        东兴区: "Dongxing District",
        隆昌市: "Longchang City",
        市中区: "Shizhong District",
        威远县: "Weiyuan county",
        资中县: "Zizhong county",
        东兴市: "Dongxing City",
        防城区: "Fangcheng District",
        港口区: "Port area",
        上思县: "Shangsi county",
        东阳市: "Dongyang City",
        金东区: "Jindong District",
        兰溪市: "Lanxi City",
        磐安县: "Pan'an county",
        浦江县: "Pujiang county",
        武义县: "Wuyi county",
        婺城区: "Wucheng District",
        义乌市: "Yiwu City",
        永康市: "Yongkang City",
        东营区: "Dongying District",
        广饶县: "Guangrao county",
        河口区: "Estuarine area",
        垦利区: "Kenli District",
        利津县: "Lijin county",
        东源县: "Dongyuan county",
        和平县: "Heping county",
        连平县: "Lianping county",
        龙川县: "Longchuan county",
        源城区: "Yuancheng District",
        紫金县: "Zijin county",
        东至县: "Dongzhi County",
        贵池区: "Guichi District",
        青阳县: "Qingyang county",
        石台县: "Shitai county",
        东洲区: "Dongzhou District",
        抚顺县: "Fushun county",
        清原满族自治县: "Qingyuan Manchu Autonomous County",
        顺城区: "Shuncheng District",
        望花区: "Wanghua District",
        新宾满族自治县: "Xinbin Manchu Autonomous County",
        新抚区: "Xinfu District",
        都匀市: "Duyun city",
        独山县: "Dushan county",
        福泉市: "Fuquan City",
        贵定县: "Guiding county",
        惠水县: "Huishui county",
        荔波县: "Libo county",
        龙里县: "Longli county",
        罗甸县: "Luodian county",
        平塘县: "Pingtang county",
        三都水族自治县: "Sandu Shuizu Autonomous County",
        瓮安县: "Weng'an county",
        长顺县: "Changshun county",
        斗门区: "Doumen District",
        金湾区: "Golden Bay Area",
        香洲区: "Xiangzhou District",
        杜集区: "Duji district",
        烈山区: "Lieshan District",
        濉溪县: "Suixi county",
        相山区: "Xiangshan District",
        峨边彝族自治县: "Ebian Yi Autonomous County",
        峨眉山市: "Emei Mountain City",
        夹江县: "Jiajiang county",
        犍为县: "Qianwei county",
        金口河区: "Jinkouhe District",
        井研县: "Jingyan county",
        马边彝族自治县: "Mabian yi autonomous county",
        沐川县: "Muchuan county",
        沙湾区: "Shawan District",
        五通桥区: "Wutongqiao District",
        额敏县: "Emin county",
        和布克赛尔蒙古自治县: "Hebuksel Mongolian Autonomous County",
        沙湾市: "Shawan City",
        塔城市: "Tacheng City",
        托里县: "Tory county",
        乌苏市: "Wusu City",
        裕民县: "Yumin county",
        鄂城区: "Echeng District",
        华容区: "Huarong District",
        梁子湖区: "Liangzihu District",
        恩平市: "Enping city",
        鹤山市: "Heshan City",
        江海区: "Jianghai District",
        开平市: "Kaiping city",
        蓬江区: "Pengjiang District",
        台山市: "Taishan City",
        新会区: "Xinhui District",
        繁昌区: "Fanchang District",
        镜湖区: "Jinghu District",
        鸠江区: "Jiujiang District",
        南陵县: "Nanling county",
        湾沚区: "Wanzhi District",
        无为市: "Wuwei City",
        弋江区: "Yijiang District",
        范县: "Fan county",
        华龙区: "Hualong District",
        南乐县: "Nanle county",
        濮阳县: "Puyang county",
        清丰县: "Qingfeng county",
        台前县: "Taiqian county",
        方山县: "Fangshan county",
        汾阳市: "Fenyang City",
        交城县: "Jiaocheng county",
        交口县: "Jiaokou county",
        岚县: "Lan county",
        离石区: "Lishi district",
        临县: "Linxian",
        柳林县: "Liulin county",
        石楼县: "Shilou county",
        文水县: "Wenshui county",
        孝义市: "Xiaoyi City",
        兴县: "Xing county",
        中阳县: "Zhongyang county",
        费县: "Fei County",
        河东区: "Hedong District",
        莒南县: "Junan county",
        兰陵县: "Lanling county",
        兰山区: "Lanshan District",
        临沭县: "Linshu county",
        罗庄区: "Luozhuang District",
        蒙阴县: "Mengyin county",
        平邑县: "Pingyi county",
        郯城县: "Tancheng county",
        沂南县: "Yinan County",
        沂水县: "Yishui county",
        分宜县: "Fenyi county",
        渝水区: "Yushui District",
        丰城市: "Fengcheng City",
        奉新县: "Fengxin county",
        高安市: "Gao'an City",
        靖安县: "Jing'an county",
        上高县: "Shanggao county",
        铜鼓县: "Tonggu county",
        万载县: "Wanzai county",
        宜丰县: "Yifeng county",
        袁州区: "Yuanzhou District",
        樟树市: "Zhangshu City",
        丰县: "Feng county",
        贾汪区: "Jiawang District",
        沛县: "Pei county",
        邳州市: "Pizhou City",
        泉山区: "Quanshan District",
        睢宁县: "Suining county",
        铜山区: "Tongshan District",
        新沂市: "Xinyi City",
        云龙区: "Yunlong District",
        封丘县: "Fengqiu county",
        凤泉区: "Fengquan District",
        红旗区: "Red Flag District",
        辉县市: "Huixian City",
        获嘉县: "Huojia county",
        牧野区: "Makino district",
        卫滨区: "Ehama district",
        卫辉市: "Weihui City",
        新乡县: "Xinxiang county",
        延津县: "Yanjin county",
        原阳县: "Yuanyang county",
        长垣市: "Changyuan City",
        扶余市: "Fuyu City",
        宁江区: "Ningjiang District",
        前郭尔罗斯蒙古族自治县: "Former Goros Mongolian Autonomous County",
        乾安县: "Qian'an county",
        长岭县: "Changling county",
        芙蓉区: "Furong District",
        开福区: "Kaifu District",
        浏阳市: "Liuyang City",
        宁乡市: "Ningxiang city",
        天心区: "Tianxin District",
        望城区: "Wangcheng District",
        雨花区: "Yuhua District",
        岳麓区: "Yuelu district",
        长沙县: "Changsha County",
        佛冈县: "Fogang County",
        连南瑶族自治县: "Liannan Yao Autonomous County",
        连山壮族瑶族自治县: "Lianshan Zhuang and Yao Autonomous County",
        连州市: "Lianzhou City",
        清城区: "Qingcheng District",
        清新区: "Fresh area",
        阳山县: "Yangshan county",
        英德市: "Yingde City",
        福安市: "Fuan City",
        福鼎市: "Fuding City",
        古田县: "Gutian county",
        蕉城区: "Jiaocheng District",
        屏南县: "Pingnan county",
        寿宁县: "Shouning county",
        霞浦县: "Xiapu county",
        柘荣县: "Zherong county",
        周宁县: "Zhouning county",
        福贡县: "Fugong county",
        贡山独龙族怒族自治县: "Gongshan Dulong Nu Autonomous County",
        兰坪白族普米族自治县: "Lanping Bai and Pumi Autonomous County",
        泸水市: "Lushui City",
        福山区: "Fukuyama District",
        海阳市: "Haiyang City",
        莱山区: "Laishan District",
        莱阳市: "Laiyang City",
        莱州市: "Laizhou City",
        龙口市: "Longkou City",
        牟平区: "Muping District",
        蓬莱区: "Penglai District",
        栖霞市: "Qixia City",
        招远市: "Zhaoyuan City",
        芝罘区: "Zhifu District",
        抚松县: "Fusong county",
        浑江区: "Hunjiang District",
        江源区: "Jiangyuan District",
        靖宇县: "Jingyu county",
        临江市: "Linjiang City",
        长白朝鲜族自治县: "Changbai Korean Autonomous County",
        阜南县: "Funan county",
        界首市: "Jieshou City",
        临泉县: "Linquan county",
        太和县: "Taihe County",
        颍东区: "Yingdong District",
        颍泉区: "Yingquan District",
        颍上县: "Yingshang county",
        颍州区: "Yingzhou District",
        阜新蒙古族自治县: "Fuxin Mongolian Autonomous County",
        清河门区: "Qinghemen District",
        太平区: "Taiping District",
        细河区: "Xihe District",
        新邱区: "Xinqiu District",
        彰武县: "Zhangwu county",
        富宁县: "Funing county",
        广南县: "Guangnan county",
        麻栗坡县: "Malipo county",
        马关县: "Maguan county",
        丘北县: "Qiubei county",
        文山市: "Wenshan City",
        西畴县: "Xichou county",
        砚山县: "Yanshan county",
        富源县: "Fuyuan county",
        会泽县: "Huize county",
        陆良县: "Luliang county",
        罗平县: "Luoping county",
        马龙区: "Ma Long District",
        麒麟区: "Qilin District",
        师宗县: "Shizong county",
        宣威市: "Xuanwei City",
        沾益区: "Zhanyi area",
        甘谷县: "Gangu county",
        麦积区: "Wheat area",
        秦安县: "Qin'an county",
        秦州区: "Qinzhou District",
        清水县: "Qingshui county",
        武山县: "Wushan county",
        张家川回族自治县: "Zhangjiachuan Hui Autonomous County",
        甘井子区: "Ganjingzi district",
        金州区: "Jinzhou District",
        旅顺口区: "Lushunkou District",
        普兰店区: "Pulandian District",
        沙河口区: "Shahekou District",
        瓦房店市: "Wafangdian city",
        西岗区: "Xigang District",
        长海县: "Changhai county",
        中山区: "Zhongshan District",
        庄河市: "Zhuanghe City",
        甘州区: "Ganzhou District",
        高台县: "Gaotai county",
        临泽县: "Linze county",
        民乐县: "Minle county",
        山丹县: "Shandan county",
        肃南裕固族自治县: "Sunan Yugur Autonomous County",
        刚察县: "Gangcha county",
        海晏县: "Haiyan county",
        门源回族自治县: "Menyuan Hui Autonomous County",
        祁连县: "Qilian county",
        钢城区: "Gangcheng District",
        槐荫区: "Huaiyin District",
        济阳区: "Jiyang District",
        莱芜区: "Laiwu District",
        历城区: "Licheng District",
        历下区: "Lixia District",
        平阴县: "Pingyin county",
        商河县: "Shanghe county",
        天桥区: "Tianqiao District",
        章丘区: "Zhangqiu district",
        长清区: "Changqing District",
        港北区: "Gangbei District",
        港南区: "Gangnan District",
        桂平市: "Guiping City",
        平南县: "Pingnan county",
        覃塘区: "Qintang District",
        高昌区: "Gaochang District",
        鄯善县: "Shanshan county",
        托克逊县: "Tockson county",
        高淳区: "Gaochun District",
        建邺区: "Jianye District",
        江宁区: "Jiangning District",
        溧水区: "Lishui District",
        六合区: "Liuhe District",
        浦口区: "Pukou District",
        栖霞区: "Qixia District",
        秦淮区: "Qinhuai District",
        玄武区: "Xuanwu District",
        雨花台区: "Yuhuatai District",
        高港区: "Gaogang District",
        海陵区: "Hailing District",
        姜堰区: "Jiangyan District",
        靖江市: "Jingjiang City",
        泰兴市: "Taixing City",
        兴化市: "Xinghua City",
        高坪区: "Gaoping District",
        嘉陵区: "Jialing District",
        阆中市: "Langzhong City",
        南部县: "Southern County",
        蓬安县: "Peng'an County",
        顺庆区: "Shunqing District",
        西充县: "Xichong county",
        仪陇县: "Yilong county",
        营山县: "Yingshan county",
        高雄市: "Kaohsiung City",
        高邑县: "Gaoyi county",
        藁城区: "Gaocheng District",
        晋州市: "Jinzhou City",
        井陉矿区: "Jingxing mining area",
        井陉县: "Jingxing county",
        灵寿县: "Lingshou county",
        鹿泉区: "Luquan District",
        栾城区: "Luancheng District",
        平山县: "Pingshan county",
        深泽县: "Fukasawa Prefecture",
        无极县: "Wuji county",
        辛集市: "Xinji City",
        新乐市: "Xinle City",
        行唐县: "Xingtang county",
        裕华区: "Yuhua District",
        元氏县: "Yuanshi county",
        赞皇县: "Zanhuang county",
        赵县: "Zhao County",
        正定县: "Zhengding county",
        个旧市: "Gejiu City",
        河口瑶族自治县: "Hekou Yao Autonomous County",
        红河县: "Honghe county",
        建水县: "Jianshui county",
        金平苗族瑶族傣族自治县: '"Jinping Miao',
        开远市: "Kaiyuan City",
        泸西县: "Luxi county",
        绿春县: "Lvchun county",
        蒙自市: "Mengzi City",
        弥勒市: "Maitreya City",
        屏边苗族自治县: "Pingbian Miao Autonomous County",
        石屏县: "Shiping county",
        元阳县: "Yuanyang county",
        公安县: "Gongguan County",
        洪湖市: "Honghu City",
        监利市: "Jianli city",
        江陵县: "Jiangling county",
        荆州区: "Jingzhou District",
        沙市区: "Shashi District",
        石首市: "Shishou City",
        松滋市: "Songzi City",
        共和县: "Republic County",
        贵德县: "Guide county",
        贵南县: "Guinan county",
        同德县: "Tongde county",
        兴海县: "Xinghai county",
        古城区: "Ancient city district",
        华坪县: "Huaping county",
        宁蒗彝族自治县: "Ninglang Yi Autonomous County",
        永胜县: "Yongsheng county",
        玉龙纳西族自治县: "Yulong Naxi Autonomous County",
        古交市: "Gujiao City",
        尖草坪区: "Jianlawn District",
        晋源区: "Jinyuan District",
        娄烦县: "Loufan county",
        清徐县: "Qingxu county",
        万柏林区: "Wanberlin District",
        小店区: "Small shop area",
        杏花岭区: "Xinghualing District",
        阳曲县: "Yangqu county",
        迎泽区: "Yingze District",
        古浪县: "Gulang county",
        凉州区: "Liangzhou District",
        民勤县: "Minqin county",
        天祝藏族自治县: "Tianzhu Tibetan Autonomous County",
        古蔺县: "Gulin county",
        合江县: "Hejiang county",
        江阳区: "Jiangyang District",
        龙马潭区: "Longmatan District",
        泸县: "Lu County",
        纳溪区: "Naxi district",
        叙永县: "Xuyong county",
        兰考县: "Lankao county",
        龙亭区: "Longting District",
        杞县: "Qixian County",
        顺河回族区: "Shunhe Hui area",
        通许县: "Tongxu county",
        尉氏县: "Weishi county",
        祥符区: "Xiangfu District",
        禹王台区: "Yuwangtai District",
        固始县: "Gushi county",
        光山县: "Guangshan county",
        淮滨县: "Huaibin county",
        潢川县: "Huangchuan county",
        罗山县: "Luoshan county",
        平桥区: "Pingqiao District",
        商城县: "Shangcheng county",
        浉河区: "Shihe District",
        息县: "Xi county",
        新县: "Xin County",
        关岭布依族苗族自治县: "Guanling Buyi and Miao Autonomous County",
        平坝区: "Pingba area",
        普定县: "Puding county",
        西秀区: "Xixiu District",
        镇宁布依族苗族自治县: "Zhenning Buyi and Miao Autonomous County",
        紫云苗族布依族自治县: "Ziyun Miao and Buyi Autonomous County",
        观塘区: "Kwun Tong District",
        黄大仙区: "Wong Tai Sin District",
        九龙城区: "Kowloon City District",
        深水埗区: "Sham Shui Po District",
        油尖旺区: "Yau Tsim Wang District",
        光泽县: "Guangze county",
        建瓯市: "Jianou city",
        建阳区: "Jianyang District",
        浦城县: "Pucheng county",
        邵武市: "Shaowu City",
        顺昌县: "Shunchang county",
        松溪县: "Songxi county",
        武夷山市: "Wuyishan City",
        延平区: "Yanping district",
        政和县: "Zhenghe County",
        广安区: "Guang'an District",
        华蓥市: "Huaying City",
        邻水县: "Linshui county",
        前锋区: "Forward area",
        武胜县: "Wusheng county",
        岳池县: "Yuechi county",
        广德市: "Guangde City",
        绩溪县: "Jixi county",
        泾县: "Jing county",
        旌德县: "Jingde county",
        郎溪县: "Langxi county",
        宁国市: "Ningguo City",
        宣州区: "Xuanzhou District",
        广汉市: "Guanghan City",
        旌阳区: "Jingyang district",
        罗江区: "Luojiang District",
        绵竹市: "Mianzhu City",
        什邡市: "Shifang City",
        中江县: "Zhongjiang county",
        广灵县: "Guangling county",
        浑源县: "Hunyuan county",
        灵丘县: "Lingqiu county",
        平城区: "Pingcheng District",
        天镇县: "Tianzhen county",
        新荣区: "Xinrong District",
        阳高县: "Yanggao county",
        云冈区: "Yungang District",
        云州区: "Yunzhou District",
        左云县: "Zuoyun County",
        贵溪市: "Guixi City",
        余江区: "Yujiang District",
        月湖区: "Moon lake area",
        海勃湾区: "Heibo Bay Area",
        海南区: "Hainan District",
        乌达区: "Uda district",
        海沧区: "Haicang District",
        湖里区: "Huli District",
        集美区: "Jimei District",
        思明区: "Siming District",
        同安区: "Tong'an District",
        翔安区: "Xiang'an District",
        海城区: "Haicheng District",
        合浦县: "Hepu county",
        铁山港区: "Tieshan Port District",
        银海区: "Silver Sea District",
        海城市: "Sea City",
        立山区: "Tatsuyama District",
        千山区: "Qianshan District",
        台安县: "Tai'an county",
        铁东区: "Tiedong District",
        岫岩满族自治县: "Xiuyan Manchu Autonomous County",
        海宁市: "Haining City",
        海盐县: "Haiyan county",
        嘉善县: "Jiashan county",
        南湖区: "Nanhu District",
        平湖市: "Pinghu City",
        桐乡市: "Tongxiang City",
        秀洲区: "Xiuzhou District",
        海棠区: "Haitang District",
        吉阳区: "Jiyang District",
        天涯区: "Tianya District",
        崖州区: "Yazhou District",
        海原县: "Haiyuan county",
        沙坡头区: "Shapotou District",
        中宁县: "Zhongning county",
        合山市: "Heshan City",
        金秀瑶族自治县: "Jinxiu Yao Autonomous County",
        武宣县: "Wuxuan county",
        象州县: "Xiangzhou County",
        忻城县: "Xincheng county",
        兴宾区: "Xingbin District",
        合水县: "Heshui county",
        华池县: "Huachi county",
        环县: "Huan County",
        宁县: "Ning county",
        庆城县: "Qingcheng county",
        西峰区: "Xifeng District",
        镇原县: "Zhenyuan county",
        正宁县: "Zhengning county",
        和林格尔县: "Helinger county",
        回民区: "Hui areas",
        清水河县: "Qingshuihe county",
        赛罕区: "Saihan District",
        土默特左旗: "Tumet Left Banner",
        托克托县: "Tokto county",
        武川县: "Wuchuan county",
        玉泉区: "Yuquan District",
        和顺县: "Heshun county",
        介休市: "Jiexiu City",
        灵石县: "Lingshi county",
        平遥县: "Pingyao county",
        祁县: "Qi county",
        寿阳县: "Shouyang county",
        太谷区: "Taigu District",
        昔阳县: "Xiyang county",
        榆次区: "Yuci District",
        榆社县: "Yushe county",
        左权县: "Zuoquan county",
        河津市: "Kawazu City",
        稷山县: "Jishan county",
        绛县: "Jiang county",
        临猗县: "Linyi county",
        平陆县: "Pinglu county",
        芮城县: "Ruicheng county",
        万荣县: "Wanrong County",
        闻喜县: "Wenxi county",
        夏县: "Xia County",
        新绛县: "Xinjiang county",
        盐湖区: "Salt lake area",
        永济市: "Yongji City",
        垣曲县: "Yuanqu county",
        河南蒙古族自治县: "Henan Mongolian Autonomous County",
        尖扎县: "Jianzha county",
        同仁市: "Tongren city",
        泽库县: "Zeku county",
        贺兰县: "Helan County",
        金凤区: "Jinfeng District",
        灵武市: "Lingwu City",
        西夏区: "Xixia District",
        兴庆区: "Xingqing District",
        永宁县: "Yongning county",
        鹤山区: "Heshan District",
        浚县: "Junxian",
        淇滨区: "Qibin District",
        淇县: "Qi County",
        山城区: "Shancheng District",
        红安县: "Hong'an county",
        黄梅县: "Huangmei County",
        黄州区: "Huangzhou District",
        罗田县: "Luotian county",
        麻城市: "Macheng City",
        蕲春县: "Qichun county",
        团风县: "Tuanfeng county",
        武穴市: "Wuxue City",
        浠水县: "Xishui county",
        英山县: "Yingshan county",
        红寺堡区: "Red Temple District",
        利通区: "Litong District",
        青铜峡市: "Qingtongxia City",
        同心县: "Tongxin county",
        盐池县: "Yanchi county",
        洪泽区: "Hongze District",
        淮安区: "Huai'an District",
        淮阴区: "Huaiyin District",
        金湖县: "Jinhu County",
        涟水县: "Lianshui county",
        清江浦区: "Qingjiangpu District",
        盱眙县: "Xuyi county",
        呼玛县: "Huma county",
        呼中区: "Huzhong District",
        加格达奇区: "Gagdach district",
        漠河市: "Mohe City",
        松岭区: "Songling District",
        塔河县: "Tahe county",
        新林区: "Xinlin District",
        胡杨河市: "Hu Yang River City",
        壶关县: "Huguan county",
        黎城县: "Licheng county",
        潞城区: "Lucheng District",
        潞州区: "Luzhou District",
        平顺县: "Pingshun county",
        沁县: "Qin county",
        沁源县: "Qinyuan county",
        上党区: "Shangdang District",
        屯留区: "Tunliu District",
        武乡县: "Wuxiang county",
        襄垣县: "Xiangyuan county",
        长子县: "Longson county",
        湖滨区: "Lakeside District",
        灵宝市: "Lingbao City",
        卢氏县: "Lushi County",
        渑池县: "Mianchi county",
        陕州区: "Shaanxi District",
        义马市: "Yima City",
        互助土族自治县: "Mutual aid tuzu autonomous county",
        化隆回族自治县: "Hualong Hui Autonomous County",
        乐都区: "Ledu District",
        民和回族土族自治县: "Minhe Hui Tu Autonomous County",
        平安区: "Ping An District",
        循化撒拉族自治县: "Xunhua Salar Autonomous County",
        花莲县: "Hualien county",
        华容县: "Huarong county",
        君山区: "Junshan District",
        临湘市: "Linxiang City",
        汨罗市: "Miluo City",
        平江县: "Pingjiang county",
        湘阴县: "Xiangyin county",
        岳阳楼区: "Yueyang building area",
        岳阳县: "Yueyang county",
        云溪区: "Yunxi District",
        怀仁市: "Huairen City",
        平鲁区: "Pinglu District",
        山阴县: "Shanyin prefecture",
        朔城区: "Shuocheng District",
        应县: "Ying county",
        右玉县: "Youyu county",
        环翠区: "Huancui District",
        荣成市: "Rongcheng city",
        乳山市: "Rushan City",
        文登区: "Wendeng district",
        黄山区: "Huangshan District",
        徽州区: "Huizhou District",
        祁门县: "Qimen county",
        歙县: "Shexian",
        屯溪区: "Tunxi District",
        休宁县: "Xiuning county",
        黟县: "Yixian County",
        黄岩区: "Huangyan area",
        椒江区: "Jiaojiang District",
        临海市: "Linhai City",
        路桥区: "Luqiao District",
        三门县: "Sanmen county",
        天台县: "Tiantai county",
        温岭市: "Wenling City",
        仙居县: "Xianju county",
        玉环市: "Yuhuan City",
        惠来县: "Huilai county",
        揭东区: "Jiedong District",
        揭西县: "Jiexi county",
        普宁市: "Puning City",
        榕城区: "Rongcheng District",
        霍林郭勒市: "Holingole city",
        开鲁县: "Kailu county",
        科尔沁区: "Horqin district",
        科尔沁左翼后旗: "Horqin left-wing rear flag",
        科尔沁左翼中旗: "Horqin Left Wing Flag",
        库伦旗: "Coulomb flag",
        奈曼旗: "Naiman flag",
        扎鲁特旗: "Zalut flag",
        霍邱县: "Huoqiu county",
        霍山县: "Huoshan county",
        金安区: "Jin'an District",
        金寨县: "Jinzhai county",
        舒城县: "Shucheng county",
        叶集区: "Leaf gathering area",
        裕安区: "Yu'an District",
        基隆市: "Keelung City",
        济源市: "Jiyuan city",
        嘉模堂区: "Camo parish",
        嘉祥县: "Jiaxiang county",
        金乡县: "Jinxiang county",
        梁山县: "Liangshan county",
        曲阜市: "Qufu City",
        任城区: "Rencheng District",
        泗水县: "Sishui county",
        微山县: "Weishan county",
        汶上县: "Wenshang county",
        兖州区: "Yanzhou District",
        鱼台县: "Yutai county",
        邹城市: "Zoucheng City",
        嘉义市: "Chiayi City",
        嘉义县: "Chiayi county",
        建安区: "Jian'an District",
        魏都区: "Weidu District",
        襄城县: "Xiangcheng county",
        鄢陵县: "Yanling county",
        禹州市: "Yuzhou City",
        长葛市: "Changge City",
        建昌县: "Jianchang county",
        连山区: "Lianshan District",
        龙港区: "Longgang District",
        南票区: "Nanpiao District",
        绥中县: "Suizhong county",
        兴城市: "Xingcheng City",
        江城哈尼族彝族自治县: "Jiangcheng Hani and Yi Autonomous County",
        景东彝族自治县: "Jingdong Yi Autonomous County",
        景谷傣族彝族自治县: "Jinggu Dai and Yi Autonomous County",
        澜沧拉祜族自治县: "Lancang Lahu Autonomous County",
        孟连傣族拉祜族佤族自治县: "Menglian Dai and Lahu Wa Autonomous County",
        墨江哈尼族自治县: "Mojiang Hani Autonomous County",
        宁洱哈尼族彝族自治县: "Ning'er Hani and Yi Autonomous County",
        思茅区: "Simao District",
        西盟佤族自治县: "Ximeng Wa Autonomous County",
        镇沅彝族哈尼族拉祜族自治县: '"Zhenyuan Yi',
        江城区: "Jiangcheng District",
        阳春市: "Yangchun City",
        阳东区: "Yangdong District",
        阳西县: "Yangxi county",
        金川区: "Jinchuan District",
        永昌县: "Yongchang county",
        金坛区: "Jintan District",
        溧阳市: "Liyang City",
        天宁区: "Tianning District",
        武进区: "Wujin District",
        新北区: "New Taipei District",
        钟楼区: "Bell tower",
        缙云县: "Jinyun County",
        景宁畲族自治县: "Jingning She Autonomous County",
        莲都区: "Liandu District",
        龙泉市: "Longquan City",
        青田县: "Qingtian county",
        庆元县: "Qingyuan county",
        松阳县: "Songyang county",
        遂昌县: "Suichang county",
        云和县: "Yunhe County",
        泾源县: "Jingyuan county",
        隆德县: "Lund county",
        彭阳县: "Pengyang county",
        西吉县: "Xiji county",
        原州区: "Wonju Ward",
        景洪市: "Jinghong City",
        勐海县: "Menghai county",
        勐腊县: "Mengla county",
        柯桥区: "Keqiao District",
        上虞区: "Shangyu District",
        嵊州市: "Shengzhou City",
        新昌县: "Xinchang county",
        越城区: "Yuecheng District",
        诸暨市: "Zhuji City",
        可克达拉市: "Cocodara City",
        昆玉市: "Kunyu City",
        乐昌市: "Lechang City",
        南雄市: "Nanxiong City",
        曲江区: "Qujiang District",
        仁化县: "Renhua county",
        乳源瑶族自治县: "Ruyuan Yao Autonomous County",
        始兴县: "Shixing county",
        翁源县: "Wengyuan county",
        武江区: "Wujiang District",
        新丰县: "Xinfeng county",
        浈江区: "Zhenjiang District",
        乐东黎族自治县: "Ledong Li Autonomous County",
        冷水江市: "Lengshuijiang City",
        涟源市: "Lianyuan city",
        娄星区: "Louxing District",
        双峰县: "Shuangfeng county",
        新化县: "Xinhua county",
        梨树县: "Lishu county",
        双辽市: "Shuangliao city",
        伊通满族自治县: "Yitong Manchu Autonomous County",
        利辛县: "Lixin county",
        蒙城县: "Mengcheng county",
        谯城区: "Qiaocheng District",
        涡阳县: "Woyang county",
        连城县: "Liancheng county",
        上杭县: "Shanghang county",
        武平县: "Wuping county",
        新罗区: "Silla District",
        漳平市: "Zhangping city",
        长汀县: "Changting county",
        梁河县: "Lianghe county",
        陇川县: "Longchuan county",
        芒市: "Mangshi",
        瑞丽市: "Ruili City",
        盈江县: "Yingjiang county",
        梁园区: "Liangyuan District",
        民权县: "Minquan county",
        宁陵县: "Ningling county",
        睢县: "Suixian",
        睢阳区: "Suiyang District",
        夏邑县: "Xiayi county",
        永城市: "Yongcheng City",
        虞城县: "Yucheng county",
        柘城县: "Zhecheng county",
        临高县: "Lingao county",
        临颍县: "Linying county",
        舞阳县: "Wuyang county",
        郾城区: "Yancheng District",
        源汇区: "Source and sink area",
        召陵区: "Zhaoling District",
        灵山县: "Lingshan county",
        浦北县: "Pubei county",
        钦北区: "Qinbei District",
        钦南区: "Qinnan District",
        陵水黎族自治县: "Lingshui Li Autonomous County",
        六枝特区: "Liuzhi Special Zone",
        盘州市: "Panzhou City",
        水城区: "Water city",
        钟山区: "Zhongshan District",
        美兰区: "Meilan District",
        琼山区: "Qiongshan District",
        秀英区: "Xiuying District",
        路氹填海区: "Cotai reclamation area",
        罗定市: "Luoding city",
        新兴县: "Xinxing County",
        郁南县: "Yunan county",
        云安区: "Yun'an District",
        云城区: "Yuncheng District",
        泌阳县: "Biyang county",
        平舆县: "Pingyu county",
        确山县: "Queshan county",
        汝南县: "Runan county",
        上蔡县: "Shangcai county",
        遂平县: "Suiping county",
        西平县: "Xiping county",
        新蔡县: "Xincai county",
        驿城区: "Yicheng District",
        正阳县: "Zhengyang county",
        苗栗县: "Miaoli county",
        西沙区: "Xisha District",
        南投县: "Nantou county",
        澎湖县: "Penghu county",
        屏东县: "Pingtung county",
        潜江市: "Qianjiang City",
        琼海市: "Qionghai City",
        琼中黎族苗族自治县: "Qiongzhong Li and Miao Autonomous County",
        山亭区: "Shanting District",
        台儿庄区: "Taierzhuang District",
        滕州市: "Tengzhou City",
        薛城区: "Xuecheng District",
        峄城区: "Yicheng District",
        韶山市: "Shaoshan City",
        湘潭县: "Xiangtan county",
        湘乡市: "Xiangxiang City",
        雨湖区: "Rainy lake area",
        岳塘区: "Yuetang District",
        神农架林区: "Shennongjia Forest Area",
        圣方济各堂区: "St. Francis Parish",
        石河子市: "Shihezi City",
        市辖区: "Municipal districts",
        沭阳县: "Shuyang county",
        泗洪县: "Sihong county",
        泗阳县: "Siyang county",
        宿城区: "Sucheng District",
        宿豫区: "Suyu District",
        双河市: "Shuanghe City",
        台北市: "Taipei City",
        台东县: "Taitung county",
        台南市: "Tainan City",
        台中市: "Taichung City",
        桃园市: "Taoyuan City",
        天门市: "Tianmen City",
        铁门关市: "Tiemenguan City",
        图木舒克市: "Tumshuk city",
        屯昌县: "Tunchang county",
        万宁市: "Wanning City",
        王益区: "Wangyi District",
        耀州区: "Yaozhou District",
        宜君县: "Yijun county",
        印台区: "Plate area",
        文昌市: "Wenchang City",
        五家渠市: "Wujiaqu City",
        五指山市: "Wuzhishan City",
        仙桃市: "Xiantao City",
        新北市: "New Taipei City",
        新星市: "Xinxing City",
        新竹市: "Hsinchu City",
        新竹县: "Hsinchu county",
        云林县: "Yunlin county",
        彰化县: "Changhua county",
        宜兰县: "Yilan county",
      },
      {
        阿坝藏族羌族自治州: "Aba Tibetan and Qiang Autonomous Prefecture",
        巴中市: "Bazhong City",
        成都市: "Chengdu City",
        达州市: "Dazhou City",
        德阳市: "Deyang City",
        甘孜藏族自治州: "Ganzi Tibetan Autonomous Prefecture",
        广安市: "Guang'an City",
        广元市: "Guangyuan City",
        乐山市: "Leshan City",
        凉山彝族自治州: "Liangshan Yi Autonomous Prefecture",
        泸州市: "Luzhou City",
        眉山市: "Meishan City",
        绵阳市: "Mianyang City",
        南充市: "Nanchong City",
        内江市: "Neijiang city",
        攀枝花市: "Panzhihua City",
        遂宁市: "Suining City",
        雅安市: "Ya'an City",
        宜宾市: "Yibin City",
        资阳市: "Ziyang city",
        自贡市: "Zigong City",
        阿克苏地区: "Aksu region",
        阿拉尔市: "City of Aral",
        阿勒泰地区: "Altai region",
        巴音郭楞蒙古自治州: "Bayingolin Mongolian Autonomous Prefecture",
        北屯市: "Beitun city",
        博尔塔拉蒙古自治州: "Bortala Mongolian Autonomous Prefecture",
        昌吉回族自治州: "Changji Hui Autonomous Prefecture",
        哈密市: "Hami City",
        和田地区: "Hotan area",
        胡杨河市: "Hu Yang River City",
        喀什地区: "Kashgar region",
        可克达拉市: "Cocodara City",
        克拉玛依市: "Karamay City",
        克孜勒苏柯尔克孜自治州: "Kizilsu Kirgiz Autonomous Oblast",
        昆玉市: "Kunyu City",
        石河子市: "Shihezi City",
        双河市: "Shuanghe City",
        塔城地区: "Tacheng area",
        铁门关市: "Tiemenguan City",
        图木舒克市: "Tumshuk city",
        吐鲁番市: "Turpan city",
        乌鲁木齐市: "Urumqi City",
        五家渠市: "Wujiaqu City",
        新星市: "Xinxing City",
        伊犁哈萨克自治州: "Ili Kazakh Autonomous Prefecture",
        阿拉善盟: "League of Alxa",
        巴彦淖尔市: "Bayannur city",
        包头市: "Baotou city",
        赤峰市: "Chifeng City",
        鄂尔多斯市: "Ordos City",
        呼和浩特市: "Hohhot City",
        呼伦贝尔市: "Hulunbuir City",
        通辽市: "Tongliao City",
        乌海市: "Wuhai City",
        乌兰察布市: "Ulanqab city",
        锡林郭勒盟: "Xilingol League",
        兴安盟: "Xing'an League",
        阿里地区: "Ali region",
        昌都市: "Chamdo City",
        拉萨市: "Lhasa City",
        林芝市: "Nyingchi City",
        那曲市: "Nagqu city",
        日喀则市: "Shigatse City",
        山南市: "Shannan City",
        安康市: "Ankang City",
        宝鸡市: "Baoji City",
        汉中市: "Hanzhong City",
        商洛市: "Shangluo City",
        铜川市: "Tongchuan City",
        渭南市: "Weinan City",
        西安市: "Xi'an City",
        咸阳市: "Xianyang City",
        延安市: "Yan'an City",
        榆林市: "Yulin City",
        安庆市: "Anqing City",
        蚌埠市: "Bengbu City",
        亳州市: "Bozhou City",
        池州市: "Chizhou City",
        滁州市: "Chuzhou City",
        阜阳市: "Fuyang City",
        合肥市: "Hefei City",
        淮北市: "Huaibei City",
        淮南市: "Huainan City",
        黄山市: "Huangshan City",
        六安市: "Lu'an City",
        马鞍山市: "Ma'anshan City",
        宿州市: "Suzhou City",
        铜陵市: "Tongling City",
        芜湖市: "Wuhu City",
        宣城市: "Xuancheng City",
        安顺市: "Anshun city",
        毕节市: "Bijie city",
        贵阳市: "Guiyang City",
        六盘水市: "Liupanshui City",
        黔东南苗族侗族自治州: "Qiandongnan Miao and Dong Autonomous Prefecture",
        黔南布依族苗族自治州: "Qiannan Buyi and Miao Autonomous Prefecture",
        黔西南布依族苗族自治州: "Qianxinan Buyi and Miao Autonomous Prefecture",
        铜仁市: "Tongren city",
        遵义市: "Zunyi City",
        安阳市: "Anyang City",
        鹤壁市: "Hebi City",
        济源市: "Jiyuan city",
        焦作市: "Jiaozuo City",
        开封市: "Kaifeng City",
        洛阳市: "Luoyang City",
        漯河市: "Luohe City",
        南阳市: "Nanyang City",
        平顶山市: "Pingdingshan City",
        濮阳市: "Puyang City",
        三门峡市: "Sanmenxia City",
        商丘市: "Shangqiu City",
        新乡市: "Xinxiang City",
        信阳市: "Xinyang City",
        许昌市: "Xuchang City",
        郑州市: "Zhengzhou City",
        周口市: "Zhoukou City",
        驻马店市: "Zhumadian city",
        鞍山市: "Anshan City",
        本溪市: "Benxi City",
        朝阳市: "Chaoyang City",
        大连市: "Dalian City",
        丹东市: "Dandong City",
        抚顺市: "Fushun city",
        阜新市: "Fuxin City",
        葫芦岛市: "Huludao City",
        锦州市: "Jinzhou City",
        辽阳市: "Liaoyang City",
        盘锦市: "Panjin City",
        沈阳市: "Shenyang City",
        铁岭市: "Tieling City",
        营口市: "Yingkou City",
        澳门半岛: "Macau Peninsula",
        氹仔岛: "Taipa Island",
        路氹城: "Cotai City",
        路环岛: "Coloane island",
        白城市: "Baicheng City",
        白山市: "Baishan City",
        吉林市: "Jilin City",
        辽源市: "Liaoyuan City",
        四平市: "Siping city",
        松原市: "Songyuan City",
        通化市: "Tonghua City",
        延边朝鲜族自治州: "Yanbian Korean Autonomous Prefecture",
        长春市: "Changchun City",
        白沙黎族自治县: "Baisha Li Autonomous County",
        保亭黎族苗族自治县: "Baoting Li and Miao Autonomous County",
        昌江黎族自治县: "Changjiang Li Autonomous County",
        澄迈县: "Chengmai county",
        儋州市: "Danzhou city",
        定安县: "Ding'an county",
        东方市: "Dongfang City",
        海口市: "Haikou City",
        乐东黎族自治县: "Ledong Li Autonomous County",
        临高县: "Lingao county",
        陵水黎族自治县: "Lingshui Li Autonomous County",
        琼海市: "Qionghai City",
        琼中黎族苗族自治县: "Qiongzhong Li and Miao Autonomous County",
        三沙市: "Sansha City",
        三亚市: "Sanya City",
        屯昌县: "Tunchang county",
        万宁市: "Wanning City",
        文昌市: "Wenchang City",
        五指山市: "Wuzhishan City",
        白银市: "Silver market",
        定西市: "Dingxi city",
        甘南藏族自治州: "Gannan Tibetan Autonomous Prefecture",
        嘉峪关市: "Jiayuguan City",
        金昌市: "Jinchang City",
        酒泉市: "Jiuquan City",
        兰州市: "Lanzhou City",
        临夏回族自治州: "Linxia Hui Autonomous Prefecture",
        陇南市: "Longnan City",
        平凉市: "Pingliang City",
        庆阳市: "Qingyang City",
        天水市: "Tianshui City",
        武威市: "Wuwei City",
        张掖市: "Zhangye City",
        百色市: "Baise City",
        北海市: "Beihai City",
        崇左市: "Chongzuo city",
        防城港市: "Fangchenggang city",
        贵港市: "Guigang City",
        桂林市: "Guilin City",
        河池市: "Hechi City",
        贺州市: "Hezhou City",
        来宾市: "Laibin City",
        柳州市: "Liuzhou City",
        南宁市: "Nanning City",
        钦州市: "Qinzhou City",
        梧州市: "Wuzhou City",
        玉林市: "Yulin City",
        保定市: "Baoding city",
        沧州市: "Cangzhou City",
        承德市: "Chengde city",
        邯郸市: "Handan City",
        衡水市: "Hengshui City",
        廊坊市: "Langfang City",
        秦皇岛市: "Qinhuangdao City",
        石家庄市: "Shijiazhuang City",
        唐山市: "Tangshan City",
        邢台市: "Xingtai City",
        张家口市: "Zhangjiakou City",
        保山市: "Baoshan City",
        楚雄彝族自治州: "Chuxiong Yi Autonomous Prefecture",
        大理白族自治州: "Dali Bai Autonomous Prefecture",
        德宏傣族景颇族自治州: "Dehong Dai and Jingpo Autonomous Prefecture",
        迪庆藏族自治州: "Diqing Tibetan Autonomous Prefecture",
        红河哈尼族彝族自治州: "Honghe Hani and Yi Autonomous Prefecture",
        昆明市: "Kunming City",
        丽江市: "Lijiang City",
        临沧市: "Lincang city",
        怒江傈僳族自治州: "Nujiang Lisu Autonomous Prefecture",
        普洱市: "Pu'er City",
        曲靖市: "Qujing City",
        文山壮族苗族自治州: "Wenshan Zhuang and Miao Autonomous Prefecture",
        西双版纳傣族自治州: "Xishuangbanna Dai Autonomous Prefecture",
        玉溪市: "Yuxi City",
        昭通市: "Zhaotong City",
        滨州市: "Binzhou City",
        德州市: "Texas City",
        东营市: "Dongying City",
        菏泽市: "Heze City",
        济南市: "Jinan City",
        济宁市: "Jining City",
        聊城市: "Liaocheng City",
        临沂市: "Linyi City",
        青岛市: "Qingdao City",
        日照市: "Rizhao City",
        泰安市: "Tai'an City",
        威海市: "Weihai City",
        潍坊市: "Weifang City",
        烟台市: "Yantai City",
        枣庄市: "Zaozhuang City",
        淄博市: "Zibo City",
        常德市: "Changde City",
        郴州市: "Chenzhou City",
        衡阳市: "Hengyang City",
        怀化市: "Huaihua City",
        娄底市: "Loudi City",
        邵阳市: "Shaoyang City",
        湘潭市: "Xiangtan City",
        湘西土家族苗族自治州: "Xiangxi Tujia and Miao Autonomous Prefecture",
        益阳市: "Yiyang City",
        永州市: "Yongzhou City",
        岳阳市: "Yueyang City",
        张家界市: "Zhangjiajie city",
        长沙市: "Changsha City",
        株洲市: "Zhuzhou City",
        常州市: "Changzhou City",
        淮安市: "Huai'an City",
        连云港市: "Lianyungang City",
        南京市: "Nanjing City",
        南通市: "Nantong City",
        苏州市: "Suzhou City",
        宿迁市: "Suqian City",
        泰州市: "Taizhou City",
        无锡市: "Wuxi City",
        徐州市: "Xuzhou City",
        盐城市: "Yancheng City",
        扬州市: "Yangzhou City",
        镇江市: "Zhenjiang City",
        潮州市: "Chaozhou City",
        东莞市: "Dongguan City",
        佛山市: "Foshan City",
        广州市: "Guangzhou City",
        河源市: "Heyuan City",
        惠州市: "Huizhou City",
        江门市: "Jiangmen City",
        揭阳市: "Jieyang City",
        茂名市: "Maoming City",
        梅州市: "Meizhou City",
        清远市: "Qingyuan City",
        汕头市: "Shantou City",
        汕尾市: "Shanwei City",
        韶关市: "Shaoguan City",
        深圳市: "Shenzhen City",
        阳江市: "Yangjiang City",
        云浮市: "Yunfu City",
        湛江市: "Zhanjiang City",
        肇庆市: "Zhaoqing City",
        中山市: "Zhongshan City",
        珠海市: "Zhuhai City",
        大庆市: "Daqing City",
        大兴安岭地区: "Greater Khingan Mountains area",
        哈尔滨市: "Harbin City",
        鹤岗市: "Hegang City",
        黑河市: "Heihe City",
        鸡西市: "Jixi city",
        佳木斯市: "Jiamusi City",
        牡丹江市: "Mudanjiang City",
        七台河市: "Qitaihe City",
        齐齐哈尔市: "Qiqihar city",
        双鸭山市: "Shuangyashan City",
        绥化市: "Suihua City",
        伊春市: "Yichun City",
        大同市: "Datong City",
        晋城市: "Jincheng City",
        晋中市: "Jinzhong city",
        临汾市: "Linfen City",
        吕梁市: "Lvliang City",
        朔州市: "Shuozhou City",
        太原市: "Taiyuan City",
        忻州市: "Xinzhou City",
        阳泉市: "Yangquan City",
        运城市: "Yuncheng City",
        长治市: "Changzhi City",
        鄂州市: "Ezhou City",
        恩施土家族苗族自治州: "Enshi Tujia and Miao Autonomous Prefecture",
        黄冈市: "Huanggang City",
        黄石市: "Yellowstone City",
        荆门市: "Jingmen City",
        荆州市: "Jingzhou City",
        潜江市: "Qianjiang City",
        神农架林区: "Shennongjia Forest Area",
        十堰市: "Shiyan City",
        随州市: "Suizhou City",
        天门市: "Tianmen City",
        武汉市: "Wuhan City",
        仙桃市: "Xiantao City",
        咸宁市: "Xianning City",
        襄阳市: "Xiangyang City",
        孝感市: "Xiaogan City",
        宜昌市: "Yichang City",
        福州市: "Fuzhou City",
        龙岩市: "Longyan City",
        南平市: "Nanping City",
        宁德市: "City of CATL",
        莆田市: "Putian City",
        泉州市: "Quanzhou City",
        三明市: "Sanming City",
        厦门市: "Xiamen City",
        漳州市: "Zhangzhou City",
        抚州市: "Fuzhou City",
        赣州市: "Ganzhou City",
        吉安市: "Jian City",
        景德镇市: "Jingdezhen City",
        九江市: "Jiujiang City",
        南昌市: "Nanchang City",
        萍乡市: "Pingxiang City",
        上饶市: "Shangrao City",
        新余市: "Xinyu City",
        宜春市: "Yichun City",
        鹰潭市: "Yingtan City",
        高雄市: "Kaohsiung City",
        花莲县: "Hualien county",
        基隆市: "Keelung City",
        嘉义市: "Chiayi City",
        嘉义县: "Chiayi county",
        苗栗县: "Miaoli county",
        南投县: "Nantou county",
        澎湖县: "Penghu county",
        屏东县: "Pingtung county",
        台北市: "Taipei City",
        台东县: "Taitung county",
        台南市: "Tainan City",
        台中市: "Taichung City",
        桃园市: "Taoyuan City",
        新北市: "New Taipei City",
        新竹市: "Hsinchu City",
        新竹县: "Hsinchu county",
        云林县: "Yunlin county",
        彰化县: "Changhua county",
        宜兰县: "Yilan county",
        固原市: "Guyuan City",
        石嘴山市: "Shizuishan City",
        吴忠市: "Wuzhong City",
        银川市: "Yinchuan City",
        中卫市: "Zhongwei City",
        果洛藏族自治州: "Guoluo Tibetan Autonomous Prefecture",
        海北藏族自治州: "Haibei Tibetan Autonomous Prefecture",
        海东市: "Haidong City",
        海南藏族自治州: "Hainan Tibetan Autonomous Prefecture",
        海西蒙古族藏族自治州: "Haixi Mongolian Tibetan Autonomous Prefecture",
        黄南藏族自治州: "Huangnan Tibetan Autonomous Prefecture",
        西宁市: "Xining City",
        玉树藏族自治州: "Yushu Tibetan Autonomous Prefecture",
        杭州市: "Hangzhou City",
        湖州市: "Huzhou City",
        嘉兴市: "Jiaxing City",
        金华市: "Jinhua City",
        丽水市: "Lishui City",
        宁波市: "Ningbo City",
        衢州市: "Quzhou City",
        绍兴市: "Shaoxing City",
        台州市: "Taizhou City",
        温州市: "Wenzhou City",
        舟山市: "Zhoushan City",
        九龙半岛: "Kowloon Peninsula",
        香港岛: "Hong Kong Island",
        新界: "New Territories",
        昌平区: "Changping District",
        朝阳区: "Chaoyang District",
        大兴区: "Daxing District",
        东城区: "Dongcheng District",
        房山区: "Fangshan District",
        丰台区: "Fengtai District",
        海淀区: "Haidian District",
        怀柔区: "Huairou District",
        门头沟区: "Mentougou District",
        密云区: "Miyun district",
        平谷区: "Pinggu district",
        石景山区: "Shijingshan District",
        顺义区: "Shunyi District",
        通州区: "Tongzhou District",
        西城区: "Xicheng District",
        延庆区: "Yanqing District",
        宝坻区: "Baodi District",
        北辰区: "Beichen District",
        滨海新区: "Binhai New Area",
        东丽区: "Toray District",
        和平区: "Zone of peace",
        河北区: "Hebei District",
        河东区: "Hedong District",
        河西区: "Hexi District",
        红桥区: "Hongqiao District",
        蓟州区: "Jizhou District",
        津南区: "Jinnan District",
        静海区: "Jinghai District",
        南开区: "Nankai University",
        宁河区: "Ninghe District",
        武清区: "Wuqing District",
        西青区: "Xiqing District",
        宝山区: "Baoshan District",
        崇明区: "Chongming District",
        奉贤区: "Fengxian District",
        虹口区: "Hongkou District",
        黄浦区: "Huangpu District",
        嘉定区: "Jiading District",
        金山区: "Jinshan District",
        静安区: "Jing'an District",
        闵行区: "Minhang District",
        浦东新区: "Pudong New Area",
        普陀区: "Putuo District",
        青浦区: "Qingpu District",
        松江区: "Songjiang District",
        徐汇区: "Xuhui District",
        杨浦区: "Yangpu District",
        长宁区: "Changning District",
        巴南区: "Banan district",
        北碚区: "Beibei District",
        璧山区: "Bishan District",
        城口县: "Chengkou county",
        大渡口区: "Dadukou District",
        大足区: "Dazu District",
        垫江县: "Dianjiang county",
        丰都县: "Fengdu county",
        奉节县: "Fengjie county",
        涪陵区: "Fuling District",
        合川区: "Hechuan District",
        江北区: "Jiangbei District",
        江津区: "Jiangjin District",
        九龙坡区: "Jiulongpo District",
        开州区: "Kaizhou District",
        梁平区: "Liangping District",
        南岸区: "South Bank District",
        南川区: "Nanchuan District",
        彭水苗族土家族自治县: "Pengshui Miao and Tujia Autonomous County",
        綦江区: "Qijiang District",
        黔江区: "Qianjiang District",
        荣昌区: "Rongchang District",
        沙坪坝区: "Shapingba District",
        石柱土家族自治县: "Shizhu Tujia Autonomous County",
        铜梁区: "Copper beam area",
        潼南区: "Tongnan District",
        万州区: "Wanzhou District",
        巫山县: "Wushan county",
        巫溪县: "Wuxi county",
        武隆区: "Wulong District",
        秀山土家族苗族自治县: "Xiushan Tujia and Miao Autonomous County",
        永川区: "Yongchuan District",
        酉阳土家族苗族自治县: "Youyang Tujia and Miao Autonomous County",
        渝北区: "Yubei District",
        渝中区: "Yuzhong District",
        云阳县: "Yunyang county",
        长寿区: "Longevity zone",
        忠县: "Zhong county",
      },
      {
        广东省: "Guangdong",
        江苏省: "Jiangsu",
        山东省: "Shandong",
        河南省: "Henan",
        河北省: "Hebei",
        浙江省: "Zhejiang",
        四川省: "Sichuan",
        安徽省: "Anhui",
        辽宁省: "Liaoning",
        陕西省: "Shaanxi",
        山西省: "Shanxi",
        湖北省: "Hubei",
        北京市: "Beijing",
        湖南省: "Hunan",
        黑龙江省: "Heilongjiang",
        福建省: "Fujian",
        内蒙古自治区: "Inner Mongolia",
        云南省: "Yunnan",
        江西省: "Jiangxi",
        重庆市: "Chongqing",
        上海市: "Shanghai",
        贵州省: "Guizhou",
        吉林省: "Jilin",
        天津市: "Tianjin",
        广西壮族自治区: "Guangxi",
        甘肃省: "Gansu",
        新疆维吾尔自治区: "Xinjiang",
        宁夏回族自治区: "Ningxia",
        海南省: "Hainan",
        青海省: "Qinghai",
        西藏自治区: "Xizang",
        香港特别行政区: "Hong Kong",
        台湾省: "Taiwan",
        澳门特别行政区: "Macao",
      }
    ),
    zh_CN: p({}, GX, kX),
  },
  HX = {
    en_US: {
      南海诸岛: "Nanhai Zhudao",
      曾母暗沙: "Zengmu Ansha",
      南沙群岛: "Nansha Qundao",
      黄岩岛: "Huangyan Island",
      西沙群岛: "Xisha Qundao",
      中沙群岛: "Zhongsha Qundao",
      海南岛: "Hainan Island",
      东沙群岛: "Dongsha Qundao",
      海口: "Haikou",
      南宁: "Nanning",
      广州: "Guangzhou",
      澳门: "Macao",
      香港: "Hong Kong",
      台湾岛: "Taiwan Island",
    },
    zh_CN: {
      南海诸岛: "南海诸岛",
      曾母暗沙: "曾母暗沙",
      南沙群岛: "南沙群岛",
      黄岩岛: "黄岩岛",
      西沙群岛: "西沙群岛",
      中沙群岛: "中沙群岛",
      海南岛: "海南岛",
      东沙群岛: "东沙群岛",
      海口: "海口",
      南宁: "南宁",
      广州: "广州",
      澳门: "澳门",
      香港: "香港",
      台湾岛: "台湾岛",
    },
  },
  VX = {
    MOZ: "莫桑比克",
    BEN: "贝宁",
    LTU: "立陶宛",
    MTQ: "马提尼克（法）",
    SGP: "新加坡",
    NER: "尼日尔",
    PAK: "巴基斯坦",
    POL: "波兰",
    TZA: "坦桑尼亚",
    JAM: "牙买加",
    OMN: "阿曼",
    PNG: "巴布亚新几内亚",
    CAN: "加拿大",
    KWT: "科威特",
    ECU: "厄瓜多尔",
    BHR: "巴林",
    RUS: "俄罗斯",
    CPV: "佛得角",
    SUR: "苏里南",
    QAT: "卡塔尔",
    BRB: "巴巴多斯",
    LSO: "莱索托",
    SLV: "萨尔瓦多",
    KAZ: "哈萨克斯坦",
    ALB: "阿尔巴尼亚",
    GNQ: "赤道几内亚",
    TCD: "乍得",
    MNG: "蒙古",
    ZWE: "津巴布韦",
    EST: "爱沙尼亚",
    TMP: "东帝汶",
    CRI: "哥斯达黎加",
    SEN: "塞内加尔",
    GTM: "危地马拉",
    DJI: "吉布提",
    PYF: "法属玻利尼西亚",
    MMR: "缅甸",
    MNP: "北马里亚纳群岛（美）",
    LCA: "圣卢西亚",
    DEU: "德国",
    GUF: "法属圭亚那",
    GLP: "瓜德罗普（法）",
    FRO: "法罗群岛（丹）",
    CHE: "瑞士",
    GIN: "几内亚",
    KOR: "韩国",
    GAB: "加蓬",
    MKD: "马其顿",
    ARE: "阿拉伯联合酋长国",
    AGO: "安哥拉",
    LIE: "列支敦士登",
    GRC: "希腊",
    SLE: "塞拉利昂",
    PLW: "帕劳",
    THA: "泰国",
    ESH: "西撒哈拉",
    NZL: "新西兰",
    COG: "刚果",
    FIN: "芬兰",
    NOR: "挪威",
    SLB: "所罗门群岛",
    SVN: "斯洛文尼亚",
    PRT: "葡萄牙",
    SVK: "斯洛伐克",
    YEM: "也门",
    STP: "圣多美和普林西比",
    MRT: "毛里塔尼亚",
    BWA: "博茨瓦纳",
    DNK: "丹麦",
    VEN: "委内瑞拉",
    UGA: "乌干达",
    DZA: "阿尔及利亚",
    IRL: "爱尔兰",
    LBN: "黎巴嫩",
    EGY: "埃及",
    ITA: "意大利",
    GNB: "几内亚比绍",
    PSE: "巴勒斯坦",
    URY: "乌拉圭",
    PRK: "朝鲜",
    LBY: "利比亚",
    ISR: "以色列",
    CHL: "智利",
    ARG: "阿根廷",
    UZB: "乌兹别克斯坦",
    SSD: "南苏丹",
    BFA: "布基纳法索",
    CIV: "科特迪瓦",
    COL: "哥伦比亚",
    TJK: "塔吉克斯坦",
    MNE: "黑山",
    GBR: "英国",
    ETH: "埃塞俄比亚",
    FRA: "法国",
    REU: "留尼汪（法）",
    CZE: "捷克",
    KGZ: "吉尔吉斯斯坦",
    IRQ: "伊拉克",
    MAR: "摩洛哥",
    AZE: "阿塞拜疆",
    BLZ: "伯利兹",
    BOL: "玻利维亚",
    ISL: "冰岛",
    USA: "美国",
    GHA: "加纳",
    ZAF: "南非",
    AUS: "澳大利亚",
    MCO: "摩纳哥",
    BGD: "孟加拉国",
    FJI: "斐济",
    DOM: "多米尼加",
    LKA: "斯里兰卡",
    LUX: "卢森堡",
    BRN: "文莱",
    PRY: "巴拉圭",
    JPN: "日本",
    BLR: "白俄罗斯",
    HRV: "克罗地亚",
    MLT: "马耳他",
    FLK: "马尔维纳斯群岛（阿根、英争议）（英称福克兰群岛）",
    HUN: "匈牙利",
    CYP: "塞浦路斯",
    ABW: "阿鲁巴（荷）",
    PER: "秘鲁",
    LAO: "老挝",
    MLI: "马里",
    NLD: "荷兰",
    RWA: "卢旺达",
    TGO: "多哥",
    MYS: "马来西亚",
    LVA: "拉脱维亚",
    BGR: "保加利亚",
    SWE: "瑞典",
    ERI: "厄立特里亚",
    NPL: "尼泊尔",
    NCL: "新喀里多尼亚",
    SDN: "苏丹",
    NGA: "尼日利亚",
    GRD: "格林纳达",
    SRB: "塞尔维亚",
    AFG: "阿富汗",
    MUS: "毛里求斯",
    MEX: "墨西哥",
    GUY: "圭亚那",
    IND: "印度",
    VNM: "越南",
    CMR: "喀麦隆",
    ESP: "西班牙",
    ATG: "安提瓜和巴布达",
    BHS: "巴哈马",
    TTO: "特立尼达和多巴哥",
    VCT: "圣文森特和格林纳丁斯",
    COD: "刚果民主共和国",
    KHM: "柬埔寨",
    NIU: "纽埃",
    ROM: "罗马尼亚",
    MDA: "摩尔多瓦",
    ANT: "库拉索（荷）",
    BIH: "波斯尼亚和黑塞哥维那",
    SOM: "索马里",
    WSM: "萨摩亚",
    BRA: "巴西",
    IRN: "伊朗",
    VUT: "瓦努阿图",
    TKM: "土库曼斯坦",
    MWI: "马拉维",
    SAU: "沙特阿拉伯",
    TON: "汤加",
    SYR: "叙利亚",
    TUR: "土耳其",
    LBR: "利比里亚",
    NAM: "纳米比亚",
    SWZ: "斯威士兰",
    NIC: "尼加拉瓜",
    PHL: "菲律宾",
    ARM: "亚美尼亚",
    UKR: "乌克兰",
    AUT: "奥地利",
    AND: "安道尔",
    CUB: "古巴",
    COM: "科摩罗",
    BEL: "比利时",
    HND: "洪都拉斯",
    GMB: "冈比亚",
    DMA: "多米尼克",
    PAN: "巴拿马",
    JOR: "约旦",
    GRL: "格陵兰（丹）",
    IDN: "印度尼西亚",
    MDG: "马达加斯加",
    BTN: "不丹",
    BDI: "布隆迪",
    KIR: "基里巴斯",
    HTI: "海地",
    TUN: "突尼斯",
    CAF: "中非",
    GEO: "格鲁吉亚",
    PRI: "波多黎各（美）",
    FSM: "密克罗尼西亚联邦",
    ZMB: "赞比亚",
    KEN: "肯尼亚",
    CHN: "中华人民共和国",
    MZ: "莫桑比克",
    BJ: "贝宁",
    LT: "立陶宛",
    MQ: "马提尼克（法）",
    SG: "新加坡",
    NE: "尼日尔",
    PK: "巴基斯坦",
    PL: "波兰",
    TZ: "坦桑尼亚",
    JM: "牙买加",
    OM: "阿曼",
    PG: "巴布亚新几内亚",
    CA: "加拿大",
    KW: "科威特",
    EC: "厄瓜多尔",
    BH: "巴林",
    RU: "俄罗斯",
    CV: "佛得角",
    SR: "苏里南",
    QA: "卡塔尔",
    BB: "巴巴多斯",
    LS: "莱索托",
    SV: "萨尔瓦多",
    KZ: "哈萨克斯坦",
    AL: "阿尔巴尼亚",
    GQ: "赤道几内亚",
    TD: "乍得",
    MN: "蒙古",
    ZW: "津巴布韦",
    EE: "爱沙尼亚",
    TL: "东帝汶",
    CR: "哥斯达黎加",
    SN: "塞内加尔",
    GT: "危地马拉",
    DJ: "吉布提",
    PF: "法属玻利尼西亚",
    MM: "缅甸",
    MP: "北马里亚纳群岛（美）",
    LC: "圣卢西亚",
    DE: "德国",
    GF: "法属圭亚那",
    GP: "瓜德罗普（法）",
    FO: "法罗群岛（丹）",
    CH: "瑞士",
    GN: "几内亚",
    KR: "韩国",
    GA: "加蓬",
    MK: "马其顿",
    AE: "阿拉伯联合酋长国",
    AO: "安哥拉",
    LI: "列支敦士登",
    GR: "希腊",
    SL: "塞拉利昂",
    PW: "帕劳",
    TH: "泰国",
    EH: "西撒哈拉",
    NZ: "新西兰",
    CG: "刚果",
    FI: "芬兰",
    NO: "挪威",
    SB: "所罗门群岛",
    SI: "斯洛文尼亚",
    PT: "葡萄牙",
    SK: "斯洛伐克",
    YE: "也门",
    ST: "圣多美和普林西比",
    MR: "毛里塔尼亚",
    BW: "博茨瓦纳",
    DK: "丹麦",
    VE: "委内瑞拉",
    UG: "乌干达",
    DZ: "阿尔及利亚",
    IE: "爱尔兰",
    LB: "黎巴嫩",
    EG: "埃及",
    IT: "意大利",
    GW: "几内亚比绍",
    PS: "巴勒斯坦",
    UY: "乌拉圭",
    KP: "朝鲜",
    LY: "利比亚",
    IL: "以色列",
    CL: "智利",
    AR: "阿根廷",
    UZ: "乌兹别克斯坦",
    SS: "南苏丹",
    BF: "布基纳法索",
    CI: "科特迪瓦",
    CO: "哥伦比亚",
    TJ: "塔吉克斯坦",
    ME: "黑山",
    GB: "英国",
    ET: "埃塞俄比亚",
    FR: "法国",
    RE: "留尼汪（法）",
    CZ: "捷克",
    KG: "吉尔吉斯斯坦",
    IQ: "伊拉克",
    MA: "摩洛哥",
    AZ: "阿塞拜疆",
    BZ: "伯利兹",
    BO: "玻利维亚",
    IS: "冰岛",
    US: "美国",
    GH: "加纳",
    ZA: "南非",
    AU: "澳大利亚",
    MC: "摩纳哥",
    BD: "孟加拉国",
    FJ: "斐济",
    DO: "多米尼加",
    LK: "斯里兰卡",
    LU: "卢森堡",
    BN: "文莱",
    PY: "巴拉圭",
    JP: "日本",
    BY: "白俄罗斯",
    HR: "克罗地亚",
    MT: "马耳他",
    FK: "马尔维纳斯群岛（阿根、英争议）（英称福克兰群岛）",
    HU: "匈牙利",
    CY: "塞浦路斯",
    AW: "阿鲁巴（荷）",
    PE: "秘鲁",
    LA: "老挝",
    ML: "马里",
    NL: "荷兰",
    RW: "卢旺达",
    TG: "多哥",
    MY: "马来西亚",
    LV: "拉脱维亚",
    BG: "保加利亚",
    SE: "瑞典",
    ER: "厄立特里亚",
    NP: "尼泊尔",
    NC: "新喀里多尼亚",
    SD: "苏丹",
    NG: "尼日利亚",
    GD: "格林纳达",
    RS: "塞尔维亚",
    AF: "阿富汗",
    MU: "毛里求斯",
    MX: "墨西哥",
    GY: "圭亚那",
    IN: "印度",
    VN: "越南",
    CM: "喀麦隆",
    ES: "西班牙",
    AG: "安提瓜和巴布达",
    BS: "巴哈马",
    TT: "特立尼达和多巴哥",
    VC: "圣文森特和格林纳丁斯",
    CD: "刚果民主共和国",
    KH: "柬埔寨",
    NU: "纽埃",
    RO: "罗马尼亚",
    MD: "摩尔多瓦",
    CW: "库拉索（荷）",
    BA: "波斯尼亚和黑塞哥维那",
    SO: "索马里",
    WS: "萨摩亚",
    BR: "巴西",
    IR: "伊朗",
    VU: "瓦努阿图",
    TM: "土库曼斯坦",
    MW: "马拉维",
    SA: "沙特阿拉伯",
    TO: "汤加",
    SY: "叙利亚",
    TR: "土耳其",
    LR: "利比里亚",
    NA: "纳米比亚",
    SZ: "斯威士兰",
    NI: "尼加拉瓜",
    PH: "菲律宾",
    AM: "亚美尼亚",
    UA: "乌克兰",
    AT: "奥地利",
    AD: "安道尔",
    CU: "古巴",
    KM: "科摩罗",
    BE: "比利时",
    HN: "洪都拉斯",
    GM: "冈比亚",
    DM: "多米尼克",
    PA: "巴拿马",
    JO: "约旦",
    GL: "格陵兰（丹）",
    ID: "印度尼西亚",
    MG: "马达加斯加",
    BT: "不丹",
    BI: "布隆迪",
    KI: "基里巴斯",
    HT: "海地",
    TN: "突尼斯",
    CF: "中非",
    GE: "格鲁吉亚",
    PR: "波多黎各（美）",
    FM: "密克罗尼西亚联邦",
    ZM: "赞比亚",
    KE: "肯尼亚",
    CN: "中华人民共和国",
    中国: "中华人民共和国",
    黑山共和国: "黑山",
  },
  WX = {
    en_US: {
      莫桑比克: "Mozambique",
      贝宁: "Benin",
      立陶宛: "Lithuania",
      "马提尼克（法）": "Martinique",
      新加坡: "Singapore",
      尼日尔: "Niger",
      巴基斯坦: "Pakistan",
      波兰: "Poland",
      坦桑尼亚: "Tanzania",
      牙买加: "Jamaica",
      阿曼: "Oman",
      巴布亚新几内亚: "Papua New Guinea",
      加拿大: "Canada",
      科威特: "Kuwait",
      厄瓜多尔: "Ecuador",
      巴林: "Bahrain",
      俄罗斯: "Russian Federation",
      佛得角: "Cape Verde",
      苏里南: "Suriname",
      卡塔尔: "Qatar",
      巴巴多斯: "Barbados",
      莱索托: "Lesotho",
      萨尔瓦多: "El Salvador",
      哈萨克斯坦: "Kazakhstan",
      阿尔巴尼亚: "Albania",
      赤道几内亚: "Equatorial Guinea",
      乍得: "Chad",
      蒙古: "Mongolia",
      津巴布韦: "Zimbabwe",
      爱沙尼亚: "Estonia",
      东帝汶: "Timor Timur",
      哥斯达黎加: "Costa Rica",
      塞内加尔: "Senegal",
      危地马拉: "Guatemala",
      吉布提: "Djibouti",
      法属玻利尼西亚: "French Polynesia",
      缅甸: "Myanmar",
      "北马里亚纳群岛（美）": "Northern Mariana Islands(U.S.)",
      圣卢西亚: "St. Lucia",
      德国: "Germany",
      法属圭亚那: "French Guiana",
      "瓜德罗普（法）": "Guadeloupe",
      "法罗群岛（丹）": "Faroe Islands",
      瑞士: "Switzerland",
      几内亚: "Guinea",
      韩国: "Korea, Republic of",
      加蓬: "Gabon",
      马其顿: "The Former Yugoslav Republic of Macedonia",
      阿拉伯联合酋长国: "United Arab Emirates",
      安哥拉: "Angola",
      列支敦士登: "Liechtenstein",
      希腊: "Greece",
      塞拉利昂: "Sierra Leone",
      帕劳: "Palau",
      泰国: "Thailand",
      西撒哈拉: "Western Sahara",
      新西兰: "New Zealand",
      刚果: "Congo",
      芬兰: "Finland",
      挪威: "Norway",
      所罗门群岛: "Solomon Islands",
      斯洛文尼亚: "Slovenia",
      葡萄牙: "Portugal",
      斯洛伐克: "Slovakia",
      也门: "Yemen",
      圣多美和普林西比: "Sao Tome and Principe",
      毛里塔尼亚: "Mauritania",
      博茨瓦纳: "Botswana",
      丹麦: "Denmark",
      委内瑞拉: "Venezuela",
      乌干达: "Uganda",
      阿尔及利亚: "Algeria",
      爱尔兰: "Ireland",
      黎巴嫩: "Lebanon",
      埃及: "Egypt",
      意大利: "Italy",
      几内亚比绍: "Guinea-bissau",
      巴勒斯坦: "Palestine",
      乌拉圭: "Uruguay",
      朝鲜: "Democratic People's Republic of Korea",
      利比亚: "Libya",
      以色列: "Israel",
      智利: "Chile",
      阿根廷: "Argentina",
      乌兹别克斯坦: "Uzbekistan",
      南苏丹: "South Sudan",
      布基纳法索: "Burkina Faso",
      科特迪瓦: "Cote Divoire",
      哥伦比亚: "Colombia",
      塔吉克斯坦: "Tajikistan",
      黑山: "Montenegro",
      英国: "United Kingdom",
      埃塞俄比亚: "Ethiopia",
      法国: "France",
      "留尼汪（法）": "Reunion",
      捷克: "Czech Republic",
      吉尔吉斯斯坦: "Kyrgyzstan",
      伊拉克: "Iraq",
      摩洛哥: "Morocco",
      阿塞拜疆: "Azerbaijan",
      伯利兹: "Belize",
      玻利维亚: "Bolivia",
      冰岛: "Iceland",
      美国: "United States",
      加纳: "Ghana",
      南非: "South Africa",
      澳大利亚: "Australia",
      摩纳哥: "Monaco",
      孟加拉国: "Bangladesh",
      斐济: "Fiji",
      多米尼加: "Dominican Republic",
      斯里兰卡: "Srilanka",
      卢森堡: "Letzebuerg",
      文莱: "Brunei",
      巴拉圭: "Paraguay",
      日本: "Japan",
      白俄罗斯: "Belarus",
      克罗地亚: "Croatia",
      马耳他: "Malta",
      "马尔维纳斯群岛（阿根、英争议）（英称福克兰群岛）":
        "Is.malvinas(CLAIMED BY ARG.&U.K.) (FALKLAND IS.)",
      匈牙利: "Hungary",
      塞浦路斯: "Cyprus",
      "阿鲁巴（荷）": "Aruba",
      秘鲁: "Peru",
      老挝: "Laos",
      马里: "Mali",
      荷兰: "Netherlands",
      卢旺达: "Rwanda",
      多哥: "Togo",
      马来西亚: "Malaysia",
      拉脱维亚: "Latvia",
      保加利亚: "Bulgaria",
      瑞典: "Sweden",
      厄立特里亚: "Eritrea",
      尼泊尔: "Nepal",
      新喀里多尼亚: "New Caledonia",
      苏丹: "Sudan",
      尼日利亚: "Nigeria",
      格林纳达: "Grenada",
      塞尔维亚: "Serbia",
      阿富汗: "Afghanistan",
      毛里求斯: "Mauritius",
      墨西哥: "Mexico",
      圭亚那: "Guyana",
      印度: "India",
      越南: "Viet Nam",
      喀麦隆: "Cameroon",
      西班牙: "Spain",
      安提瓜和巴布达: "Antigua and Barbuda",
      巴哈马: "Bahamas",
      特立尼达和多巴哥: "Trinidad and Tobago",
      圣文森特和格林纳丁斯: "Saint Vincent and The Grenadines",
      刚果民主共和国: "D.r.congo",
      柬埔寨: "Cambodia",
      纽埃: "Niue",
      罗马尼亚: "Romania",
      摩尔多瓦: "Moldova",
      "库拉索（荷）": "Curacao (Neth.)",
      波斯尼亚和黑塞哥维那: "Bosnia and Herzegovina",
      索马里: "Somalia",
      萨摩亚: "Samoa",
      巴西: "Brazil",
      伊朗: "Iran",
      瓦努阿图: "Vanuatu",
      土库曼斯坦: "Turkmenistan",
      马拉维: "Malawi",
      沙特阿拉伯: "Saudi Arabia",
      汤加: "Tonga",
      叙利亚: "Syria",
      土耳其: "Turkey",
      利比里亚: "Liberia",
      纳米比亚: "Namibia",
      斯威士兰: "Swaziland",
      尼加拉瓜: "Nicaragua",
      菲律宾: "Philippines",
      亚美尼亚: "Armenia",
      乌克兰: "Ukraine",
      奥地利: "Austria",
      安道尔: "Andorra",
      古巴: "Cuba",
      科摩罗: "Mayotte",
      比利时: "Belgium",
      洪都拉斯: "Honduras",
      冈比亚: "Gambia",
      多米尼克: "Dominica",
      巴拿马: "Panama",
      约旦: "Jordan",
      "格陵兰（丹）": "Greenland (Den.)",
      印度尼西亚: "Indonesia",
      马达加斯加: "Madagascar",
      不丹: "Bhutan",
      布隆迪: "Burundi",
      基里巴斯: "Kiribati",
      海地: "Haiti",
      突尼斯: "Tunisia",
      中非: "Central Africa",
      格鲁吉亚: "Georgia",
      "波多黎各（美）": "Puerto Rico",
      密克罗尼西亚联邦: "Micronesia",
      赞比亚: "Zambia",
      肯尼亚: "Kenya",
      中华人民共和国: "China",
    },
  };
function qX(t, e) {
  var i, n;
  switch (t) {
    case hX.CHINA_GIS:
      return null !== (i = UX[e]) && void 0 !== i ? i : e;
    case hX.WOLRD_GIS:
      return null !== (n = VX[e]) && void 0 !== n ? n : e;
    case hX.CUSTOM_GIS:
    default:
      return e;
  }
}
function YX(t) {
  switch (t) {
    case hX.CHINA_GIS:
      return Qw.intersect;
    case hX.WOLRD_GIS:
    case hX.CUSTOM_GIS:
    default:
      return Qw.none;
  }
}
const XX = {};
let QX = null;
async function ZX(t, e) {
  let i = "";
  if (XX[t]) return XX[t];
  if (e) {
    const i = e.layerManager.baseMapLayer.subDistrictInfoArr.find(
      (e) => e.alias === t || e.name === t
    );
    if (i) return (XX[t] = i.adcode), i.adcode;
  }
  if (!QX) {
    const t = await fetch(aQ("cn_name_table.json"));
    QX = await t.json();
  }
  const n = QX.features.filter((e) => {
    var i;
    return null === (i = e.properties.name) || void 0 === i
      ? void 0
      : i.includes(t);
  });
  return (
    n.sort((t, e) => t.properties.level - e.properties.level),
    (i = n[0].properties.id),
    (XX[t] = i),
    i
  );
}
const JX = [
  ["/aeolus/api", "/aeolus/openApi"],
  ["/vqs/api", "/vqs/openApi"],
];
const KX = async (t, e) => {
  const i = new URL(window.location.href).searchParams,
    n = i.get("token"),
    r = i.get("jwtToken"),
    o = i.get("externalHeader"),
    a = (() => {
      const t = new URL(window.location.href).pathname.split("/");
      return Number(t[3] || 0);
    })();
  let s = String(t);
  const l = {
    ...u(e),
  };
  n &&
    (JX.forEach(([t, e]) => {
      s = s.replace(t, e);
    }),
    (l.headers = {
      ...l.headers,
      "app-id": a.toString(),
      "open-api-token": n,
      "external-header": o || "",
    })),
    r &&
      (l.headers = {
        ...l.headers,
        Authorization: `Bearer ${r}`,
      });
  const c = await fetch(s, l);
  let h = await c.text();
  if (
    ((h = JSON.parse(
      (function (t) {
        const e = atob("aHVvc2hhbnN0YXRpYy5jb20=");
        return t.replace(
          /-hscdn-tos\.pstatp\.com\/obj\/dp-fe-static/g,
          `-cdn-tos.${e}/obj/maat-public`
        );
      })(h)
    )),
    ("aeolus/ok" === h.code || "OK" === h.msg) && h.data)
  )
    return h.data;
  if ("aeolus/ok" !== h.code && "OK" !== h.msg) {
    const t = new Error(h.msg);
    throw (
      ((t.extra_msg = ((e) => {
        try {
          return "string" == typeof e ? JSON.parse(e) : e;
        } catch (t) {
          return e;
        }
      })(h.extra_msg)),
      (t.code = h.code),
      t)
    );
  }
};
async function $X(t) {
  var e, i, n, r, o, a;
  const s = location.href.split("?")[1],
    l = new URLSearchParams(s),
    u = l.get("openMode"),
    c = l.get("accessKey"),
    h = l.get("accessToken"),
    p =
      null !==
        (n =
          null !== (e = l.get("id")) && void 0 !== e
            ? e
            : null === (i = location.href.split("/edit/")[1]) || void 0 === i
            ? void 0
            : i.split("?")[0]) && void 0 !== n
        ? n
        : null === (r = location.href.split("/vScreen/")[1]) || void 0 === r
        ? void 0
        : r.split("?")[0];
  let d;
  d =
    "1" === u && c
      ? {
          ...t,
          openMode: u,
          accessKey: c,
          largeScreenId: p,
        }
      : {
          ...t,
        };
  const f = `${
      (null === (o = window.__afc__) || void 0 === o ? void 0 : o.basePath) ||
      ""
    }${
      (null === (a = window.__afc__) || void 0 === a ? void 0 : a.pagePath) ||
      ""
    }`,
    g = f ? `${f}/aeolus/api/v3/geo/lnglat` : "/aeolus/api/v3/geo/lnglat";
  let m = {
    "Content-Type": "application/json;charset=utf-8;",
  };
  return (
    h &&
      (m = {
        "Content-Type": "application/json;charset=utf-8;",
        accessToken: String(h),
      }),
    await KX(g, {
      method: "post",
      headers: m,
      body: JSON.stringify(d),
    })
  );
}
const tQ = new RegExp("^[-\\+]?([0-9]+\\.?)?[0-9]+$");
function eQ(t) {
  const [e, i] = t.split(",");
  return tQ.test(e) && tQ.test(i)
    ? {
        isLngLat: !0,
        lng: e,
        lat: i,
      }
    : {
        isLngLat: !1,
        lng: !1,
        lat: !1,
      };
}
function iQ(t) {
  return !!t.includes("]");
}
const nQ = async (t, e) =>
    t.includes(",") ? t.split(",").at(-1) : rQ(t) ? ZY : await ZX(t, e),
  rQ = (t) =>
    "全国" === t ||
    "中国" == t ||
    "中华人民共和国" == t ||
    "CHN" == t ||
    "chn" == t,
  oQ = () => {
    var t;
    return `${
      (null === (t = window.__vfc__) || void 0 === t
        ? void 0
        : t.staticResourcePrefix) || ""
    }`;
  };
function aQ(t) {
  return `${oQ()}/${t}`;
}
function sQ(t, e) {
  var i;
  if (e) return !0;
  if (
    (null !== (i = t.layerManager.baseMapLayer.currentLevel) && void 0 !== i
      ? i
      : iX.country) === iX.district
  )
    return !0;
  return !1;
}
async function lQ(t) {
  var e, i, n;
  const {
      vizData: r,
      analytic: o,
      gis: a,
      hasColorChannel: s,
      hasSizeChannel: l,
      hasPoiChannel: u,
      useValueQuery: c,
      showAllLevelData: h,
      renderType: p,
    } = t,
    d = sQ(a, h),
    f = OX("location", r, o, 0),
    g = OX("value", r, o, 1),
    m = OX("majorLabel", r, o, 1),
    y = OX("subLabel", r, o, 2),
    v = FX("size", r),
    b = FX("color", r),
    x =
      1 === a.layerManager.baseMapLayer.subDistrictInfoArr.length
        ? a.layerManager.baseMapLayer.subDistrictInfoArr[0].name
        : null,
    _ = [],
    S = r.datasets,
    M = [],
    C = [],
    w =
      null ===
        (i = null === (e = r.displayConf) || void 0 === e ? void 0 : e.color) ||
      void 0 === i
        ? void 0
        : i.conditionalConfig;
  for (let A = 0; A < S.length; A++) {
    const t = S[A],
      e = null !== (n = t[f]) && void 0 !== n ? n : "";
    if (e) {
      let i = {
        ...t,
        name: e,
      };
      uQ(i, c, t, g),
        cQ(i, s, t, b),
        hQ(i, l, t, v),
        dQ(i, u, t, m, y),
        pQ(i, Boolean(w), t, w);
      const n = eQ(e);
      n.isLngLat
        ? ((i.lng = Number(n.lng)), (i.lat = Number(n.lat)), C.push(i))
        : M.push(i);
    }
  }
  if (M.length) {
    const t = [];
    if (
      (M.forEach((e, i) => {
        const n = qX(p, e.name),
          r = XV.getGeoCoordByAlias(n, a);
        r
          ? (h || e.name !== x) && ((e.lng = r.lng), (e.lat = r.lat))
          : d && t.push(e);
      }),
      AX() && t.length > 0)
    ) {
      const e = await $X({
        address: t.map((t) => t.name),
      });
      t.forEach((t, i) => {
        const n = e[i].location;
        if (n) {
          const [e, i] = n.split(",");
          (t.lng = Number(e)), (t.lat = Number(i));
        }
      });
    }
  }
  return _.push(...C, ...M.filter((t) => void 0 !== t.lng)), _;
}
function uQ(t, e, i, n) {
  e && n && (t.value = +i[n]);
}
function cQ(t, e, i, n) {
  e && n && (t.color = i[n]);
}
function hQ(t, e, i, n) {
  e && n && (t.size = +i[n]);
}
function pQ(t, e, i, n) {
  e &&
    n.forEach((e) => {
      var n;
      null === (n = e.exps) ||
        void 0 === n ||
        n.forEach((e) => {
          e.type === d.Field &&
            e.value &&
            !(e.value in t) &&
            (t[e.value] = i[e.value]);
        });
    });
}
function dQ(t, e, i, n, r) {
  var o, a;
  e &&
    (n && (t.majorPOI = null !== (o = i[n]) && void 0 !== o ? o : ""),
    r && (t.minorPOI = +(null !== (a = i[r]) && void 0 !== a ? a : "")));
}
const fQ = {
    [mX.VolcanoBlue]: {
      tips: {
        backgroundColor: "rgba(28,37,67,0.8)",
        fontFamily: "inherit",
        fontWeight: "normal",
        fontSize: 12,
        color: "rgba(255,255,255,0.7)",
      },
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      viewport: {
        centerLng: 120.329293,
        centerLat: 30.351721,
        zoom: 14.8,
        pitch: 30,
        rotation: 0,
        minZoom: 2,
        maxZoom: 20,
        maxPitch: 80,
        minPitch: 0,
        maxRotation: 90,
        minRotation: -90,
      },
      interaction: {
        drillEnable: !1,
        initialLevelName: `${ZY},${ZY}`,
        sceneChangeEnable: !0,
        zoomEnable: !0,
        rotationEnable: !0,
        translationEnable: !0,
        pitchEnable: !0,
      },
      componentBackground: {
        hasColor: !1,
        backgroundColor: "#080c11",
      },
      baseMapLayer: {
        show: !0,
      },
      districtOutline: {
        width: 2,
        opacity: 1,
      },
      innerShadow: {
        enable: !0,
        color: "rgba(0,102,255,1)",
        width: 0.1,
      },
      boundaryStreamer: {
        enable: !0,
        headColor: "#895EE6",
        endColor: "#6392FF",
        width: 5,
        speed: -10,
        length: 60,
      },
      extrude: {
        height: 0.7,
        topColor: "rgba(34,117,211,1)",
        bottomColor: "rgba(1,61,128,0.58)",
      },
      provinceOutline: {
        width: 1,
        opacity: 1,
        borderColor: "rgba(154,184,254,0.5)",
      },
      data: {
        custom: {
          data: {
            name: "custom_3d_map.json",
            url: aQ("custom_3d_map.json"),
          },
        },
        region: [],
      },
      mapStyle: {
        backgroundColor: "rgba(21,41,81,0.9)",
        metalness: 0.2,
        roughness: 0.8,
        backgroundType: "mapStyle-image-tab-1",
        backgroundImage: "",
        backgroundTile: EX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/gaode/t2/{z}/{x}/{y}.jpg`
          : "",
        normalType: "mapStyle-tile-tab-2",
        normalImage: "",
        normalTile: DX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/nextzen/{z}/{x}/{y}.png`
          : "",
        normalScale: 20,
        borderColor: "rgba(154,184,254,0.8)",
        fontStyle: {
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "bolder",
          fontSize: 12,
          color: "rgba(255,255,255,0.6)",
        },
        coverEnable: !1,
        labelEnable: !0,
      },
      nanhai: {
        enable: !1,
        position: _Y["bottom-right"],
        offsetX: 10,
        offsetY: 10,
        scale: 8,
        fill: "rgba(29,58,124,1)",
        stroke: {
          color: "#2A59C5",
          width: 1,
        },
        border: {
          color: "rgba(45,63,109,1)",
          width: 1,
        },
        background: "rgba(12,20,36,1)",
        fontStyle: {
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 8,
          color: "rgba(255,255,255,0.7)",
        },
      },
      light: {
        ambient: {
          color: "#FFFFFF",
          intensity: 35,
        },
        directional: {
          color: "#FFFFFF",
          intensity: 35,
          x: 0.3,
          y: -0.5,
          z: 0.5,
        },
        shadow: {
          enabled: !0,
          color: "#000000",
        },
      },
      amap: {
        enable: !1,
        type: "amap.default",
        custom: {
          key: "",
          securityJsCode: "",
          id: "",
        },
        style: "darkblue",
        content: {
          label: !1,
          nebula: !0,
          roadnet: !1,
          traffic: !1,
          buildings: !1,
          terrain: !1,
        },
        filter: {
          enabled: !0,
          brightness: 1,
          contrast: 1.1,
          grayscale: 0.5,
          hueRotate: 0,
          invert: 0,
          saturate: 0.5,
          sepia: 0,
        },
      },
    },
  },
  gQ = {
    name: "3D自定义地图",
    name_en: "3D Custom Map",
    category_cn: "场景",
    category_en: "Scene",
    snapshot:
      "data:image/png;base64,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",
    editingSpace: ["default"],
    renderType: tX.CUSTOM_GIS,
    iconType: "map_3d",
    nodeType: "host",
    presets: fQ[vX],
    dataPresets: {},
    plot: [1024, 768],
  };
const mQ = {
    [mX.VolcanoBlue]: {
      tips: {
        backgroundColor: "rgba(28,37,67,0.8)",
        fontFamily: "inherit",
        fontWeight: "normal",
        fontSize: 12,
        color: "rgba(255,255,255,0.7)",
      },
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      viewport: {
        centerLng: 17,
        centerLat: 38,
        zoom: 1.8,
        pitch: 40,
        rotation: 0,
        minZoom: 0,
        maxZoom: 24,
        maxPitch: 80,
        minPitch: 0,
        maxRotation: 90,
        minRotation: -90,
      },
      interaction: {
        drillEnable: !1,
        initialLevelName: `${QY},${QY}`,
        sceneChangeEnable: !0,
        zoomEnable: !0,
        rotationEnable: !0,
        translationEnable: !0,
        pitchEnable: !0,
      },
      componentBackground: {
        hasColor: !1,
        backgroundColor: "#080c11",
      },
      baseMapLayer: {
        show: !0,
      },
      districtOutline: {
        width: 1,
        opacity: 1,
      },
      innerShadow: {
        enable: !0,
        color: "rgba(0,102,255,1)",
        width: 0.1,
      },
      boundaryStreamer: {
        enable: !1,
        headColor: "#895EE6",
        endColor: "#6392FF",
        width: 5,
        speed: -10,
        length: 60,
      },
      extrude: {
        height: 0.6,
        topColor: "rgba(34,117,211,1)",
        bottomColor: "rgba(1,61,128,0.58)",
      },
      provinceOutline: {
        width: 1,
        opacity: 1,
        borderColor: "rgba(225,234,255,0.2)",
      },
      data: {
        custom: {
          data: {
            name: null,
            url: null,
          },
        },
        region: [],
      },
      mapStyle: {
        backgroundColor: "rgba(21,41,81,0.9)",
        metalness: 0.2,
        roughness: 0.8,
        backgroundType: "mapStyle-image-tab-1",
        backgroundImage: "",
        backgroundTile: EX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/gaode/t2/{z}/{x}/{y}.jpg`
          : "",
        normalType: "mapStyle-tile-tab-2",
        normalImage: "",
        normalTile: DX()
          ? `${atob(
              "aHR0cHM6Ly9sZi1kaWdpdGFsdHdpbi1jaW0uYnl0ZXRvcy5jb20"
            )}/obj/bytedcimplus/nextzen/{z}/{x}/{y}.png`
          : "",
        normalScale: 20,
        borderColor: "rgba(225,234,255,0.5)",
        fontStyle: {
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "rgba(214,242,255,0.6)",
        },
        coverEnable: !0,
        labelEnable: !1,
      },
      nanhai: {
        enable: !1,
        position: _Y["bottom-right"],
        offsetX: 10,
        offsetY: 10,
        scale: 8,
        fill: "rgba(29,58,124,1)",
        stroke: {
          color: "#2A59C5",
          width: 1,
        },
        border: {
          color: "rgba(45,63,109,1)",
          width: 1,
        },
        background: "rgba(12,20,36,1)",
        fontStyle: {
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 8,
          color: "rgba(255,255,255,0.7)",
        },
      },
      light: {
        ambient: {
          color: "#FFFFFF",
          intensity: 35,
        },
        directional: {
          color: "#FFFFFF",
          intensity: 35,
          x: 0.3,
          y: -0.5,
          z: 0.5,
        },
        shadow: {
          enabled: !0,
          color: "#000000",
        },
      },
      amap: {
        enable: !1,
        type: "amap.default",
        custom: {
          key: "",
          securityJsCode: "",
          id: "",
        },
        style: "darkblue",
        content: {
          label: !1,
          nebula: !0,
          roadnet: !1,
          traffic: !1,
          buildings: !1,
          terrain: !1,
        },
        filter: {
          enabled: !0,
          brightness: 1,
          contrast: 1.1,
          grayscale: 0.5,
          hueRotate: 0,
          invert: 0,
          saturate: 0.5,
          sepia: 0,
        },
      },
    },
  },
  yQ = {
    name: "3D世界地图",
    name_en: "3D World Map",
    category_cn: "场景",
    category_en: "Scene",
    snapshot:
      "data:image/png;base64,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",
    editingSpace: ["default"],
    renderType: tX.WOLRD_GIS,
    iconType: "world_map",
    nodeType: "host",
    presets: mQ[vX],
    dataPresets: {},
    plot: [1024, 768],
  },
  vQ = [PX, yQ, gQ];
const bQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        province: [
          {
            id: "htzcGRm2Iqc4",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "province",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        city: [
          {
            id: "zNzFnY3jq1VF",
            sourceDataFieldId: "From City",
            name: "From City",
            customizedName: "From City",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "city",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        district: [],
        majorLabel: [
          {
            id: "6MnrCan1NSMB",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        subLabel: [
          {
            id: "ZZionNur9Gn0",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "rgba(21,41,81,0.9)",
              theme: "custom",
              middle: null,
              colors: [
                "rgba(34,49,99,1)",
                "rgba(1,122,255,1)",
                "rgba(1,122,255,1)",
              ],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "B5k7c9iY8H6F",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  xQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        province: [
          {
            id: "ZZ1HZYrRMyhh",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "province",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        city: [],
        district: [],
        majorLabel: [
          {
            id: "nJ8cEKrSmcHA",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "ZZionNur9Gn0",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(34,49,99,1)",
                "rgba(1,122,255,1)",
                "rgba(1,122,255,1)",
              ],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(21,41,81,0.9)",
            },
          },
          vizField: {
            id: "B5k7c9iY8H6F",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  _Q = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        province: [
          {
            id: "PMXJ8QMaywiU",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "province",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        city: [],
        district: [],
        majorLabel: [
          {
            id: "G2iMid9KRr64",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "ZZionNur9Gn0",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(34,49,99,1)",
                "rgba(1,122,255,1)",
                "rgba(1,122,255,1)",
              ],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(21,41,81,0.9)",
            },
          },
          vizField: {
            id: "B5k7c9iY8H6F",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  SQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
      },
      color: {
        defaultColor: "rgba(21,41,81,0.9)",
      },
      poi: {
        enable: !1,
        orient: "vertical",
        trigger: "show",
        alignment: "top",
        coverEnable: !1,
        offsetX: 0,
        offsetY: 30,
        labelFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "rgba(215,242,255,1)",
          offsetX: 0,
          offsetY: 0,
        },
        valueFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "D-DIN",
          fontWeight: "normal",
          fontSize: 14,
          color: "rgba(215,242,255,1)",
          offsetX: 0,
          offsetY: 5,
        },
        background: {
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAA5CAYAAACvbxAVAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFNSURBVHgB7dwhTgNRFIbRN81gcBgMojVdARuo7CLQsAcMi0CxEVJcSTAk4EkqaAXsgTBpmWlo0tANzE/OETPvXf3lyldN3zej0pRRgRR1WQ620dZlWCBB12rbbL29NGU1G1fzAj03XWwm3X9QIFD1d3B0Nr4r0DPfH4ur/buNSyThEkm4RBIukYRLJOESSbhEEi6RhEsk4RJJuEQSLpGESyThEkm4RBIukYRLJOES6SDck6fbywI9cnx9cX66erjZn9m4RBIukYRLJOESSbhEEi6RhEsk4RJJuEQSLpEOwv26f34t0CPNy9vner1+3J95ZpQInhnlXxAukYRLJOESSbhEEi6RhEsk4RJJuEQSLpGESyThEkm4RBIukYRLJOESSbhEqqaLzaQ7zMbVvEDP7Xq1cYlU/36Hu5Kh19pWS1NWdXtYtgfI0EbbNfsDsto0NEjP8JUAAAAASUVORK5CYII=",
          opacity: 0.8,
          color: "rgba(10,10,26,0.6)",
          shadow: {
            color: "rgba(1,11,13,0.7)",
            blur: 2,
            offsetX: 0,
            offsetY: 0,
          },
          padding: {
            top: 6,
            left: 6,
            right: 6,
            bottom: 6,
          },
          borderRadius: {
            topLeft: 2,
            topRight: 2,
            bottomRight: 2,
            bottomLeft: 2,
          },
        },
      },
    },
  },
  MQ = {
    name: "行政区域热力层",
    name_en: "District Heatmap Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.DistrictHeatMap,
    analyticPresets: bQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: bQ[vX],
      [hX.WOLRD_GIS]: xQ[vX],
      [hX.CUSTOM_GIS]: _Q[vX],
    },
    nodeType: "ghost",
    iconType: "districtHeatMap",
    presets: SQ[vX],
    plot: [0, 0],
  };
const CQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "hB8il7vaNjTa",
            sourceDataFieldId: "From Coordinate",
            name: "From Coordinate",
            customizedName: "From Coordinate",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "rgba(255,255,255,0)",
              theme: "custom",
              middle: null,
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "1cpV72fdYK2l",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "vCKdzt5EKU02",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  wQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "vZq4vkrXjJ33",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(255,255,255,0)",
            },
          },
          vizField: {
            id: "1cpV72fdYK2l",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "vCKdzt5EKU02",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  AQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "7FEIBMayAeAt",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(255,255,255,0)",
            },
          },
          vizField: {
            id: "1cpV72fdYK2l",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "vCKdzt5EKU02",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  EQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      style: {
        size: 50,
        padding: 30,
        color: {
          defaultColor: "rgba(92,162,255,0.3)",
        },
      },
    },
  },
  DQ = {
    name: "网格热力层",
    name_en: "Grid Heatmap Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.GridHeatMap,
    analyticPresets: CQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: CQ[vX],
      [hX.WOLRD_GIS]: wQ[vX],
      [hX.CUSTOM_GIS]: AQ[vX],
    },
    nodeType: "ghost",
    iconType: "gridHeatMap",
    presets: EQ[vX],
    plot: [0, 0],
  };
const TQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "rVmmTQmmgD9N",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        value: [
          {
            id: "EFsiW02kkHPW",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "value",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  PQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "s4sGa1MIctc1",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        value: [
          {
            id: "EFsiW02kkHPW",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "value",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  LQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "j0YNhwWgYaJA",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        value: [
          {
            id: "EFsiW02kkHPW",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "value",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  IQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      style: {
        intensity: 0.5,
        radius: 10,
        height: 10,
        color: {
          color1: "rgba(25,96,214,0.5)",
          color2: "rgba(25,193,214,0.5)",
          color3: "rgba(255,191,66,0.5)",
          color4: "rgba(253,128,70,0.5)",
        },
      },
    },
  },
  NQ = {
    name: "经典热力层",
    name_en: "Heatmap Layer",
    snapshot:
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAC+lBMVEUAAAANDS0NDCcICzQGDjAIEjUEDjAIDisFCyxQb65pfadgfbhNXoo6SnyDmsMdCgoeCwyHncdPbKmnttGHnMVEYp19kLmnttB3ksZ7jrmuvdagtNdkgLmAmMqludqBmcqrvdugr8ocCgpxg7CKn8WClLfA1eWmtdBxh7NHZ6iKodCyxeGKodB0jsGKoclGZ6fQ3+6ltdJziblJRFKDm8pFO0BodJZvhLAdCAjI1uhUcKteea4sHSKGnsbI2OYeDAytwszG0uC6y+RRbq3I1eaXorp7iqqzwNhldJt5iq5qdpmtwN+xxOBzhbBkbIbP3OthfLaou9xjX2nG1uY8LjFVWXCgs9XN2+tFODyNoshdZIAdCQnM2OfW3+5gd6wfCQkZERFrh77C0+aFncdticDJ1+llgbtwi8Gou9hzjsNphb1WdLGEm8ZyjMJEX6TM2uzH1uhvisBohLxGYaVBXKOswNt1j8RObaypvdmJoMmGnsh2kMU9WKA6Vp7D0+iGn8jB0uXA0OSuwNyrvtqCm8yMosqBmcR8lcFngrxkgLpYdrI2UZvF1OewwuCywtysvdmEnc18lchNbKutv9uJodCAmctQb65Jaak/WqE3U5w0UJnM2eq6yuKzxeGnu9uGn8+Rps1+mMp9l8l6lMd5k8d8k8B3jrxif7lee7Zad7PI2Oy2x+G0xt+pvNyitNN/lsJ6kL1Qa6zO3Oysv9+juNquvtmDm8WAmMN6lMBTcK9IY6c5VJ3F1emyxN6rvt6nudeXqs+OpMx4ksZ4kcWCl8R5kr90i7pNZ6tKaapIaKnP3O7K2Oq/0Oe1xN2vwdyfs9eartKKocpgfbddebZUcrBLa6tMa6pKZanE0+a7y+S3yeOuweC4yN+mt9aTqNB+lsJbebTS4O+7y+KlutudsdWXrdRbd7RRbq1HZ6hDXqNAXKHV4fDQ3u69zeOqu9iitdekttSKnseBmsV/lcBTcq8xTpe9zuZUba6Mo9BNZqZEZKafsdBVcrFwhrmH4Lv2AAAAYXRSTlMABQcJDQwPChH+Kv4vHeMVmouHgmxZTB3++vjv4eDdwqVmRzw2FxD6+fDv4eDMx8PBuba2squXlYZ/eGpgUkEqDPjw8Ovr6+rm5eLg3NXTz8O8u7mloZaOiHlzc2lYTToeobttfgAAB9NJREFUWMPtlGdU0mEUxpMAzfbee++9995779IsCwIKSbCkpIg0RkVpBRgNSGXEiFILxcpKS5Oy1ByVI9t7j3O67x8KKG2d07eeA5zDh99zn3vf+75l/uufq3bLlkP+Em21sHrXRvXqta7bpu7Ebr1a/Cm9YHomLf+ZNj73STxXqVQqdJWqtqhc+XfxIX1HBIH4/Phnz3J9OdqXSp3u5cljY7vPX/xbfNPREi9ksCkzU5gb7+srStE+V+iOvVS8HNW9z5Jfj63rxxwwAH6TF98nSOwLDmJhSq7l+Uudru6kKgPcf1G+/kdt0CUvoJEyaRJ+DucJUyTmCFNyTE+efRw5o89PR1HdpNVqfXy+GrAzT9MuUX2CUjaLRCKT2CQUptTrWaVZ6XyvJyIY/SOancc8+HzaJQmVlpmfYgITkck0rXSHGsocU+6zHAN/E5KNB2WCB80HXHwyH+ekmFqXmmGggpUjio+XSPheXoCzEWbXJfjS4K9EYjBIhs6pXPL8KyU+SWHGM+7Q2F5soIPyValiji+TKU5NVase86ngYksyuVWJBp14Jx6nMn35htOotpTpaxdYMDdv3iziSGkGCYpDNcwucQBbo3OlDCbzEfU0bZPQl4lIhJrEIBE4iMUcFf8RFWRIHlRSA7xooYrBVD+k+khRSTEnVWgWPdFq07SwjEIhB5Sami95ZDAYkru4/WAw92R0tFTN2MwJesyAcgyONo/lfeyrnstz1WqzMFVgVm+68/DOo0c/RoAAPDAAlMHYzEgtJG8FnTt3Er6YTgSkmaUqmVqtunn6zsOHP0SYyYuO5uWoOQwkjtBy4gQZPgEsLjeBy+U+9yaTyd4BFmn+TVBWltel5Bau/OBxiWAQny/EeHMa2dvbm8WVs5SR79+/f/v5uUXOZT1nWblPHwc9zsp68+bN5b6uEQacT1TweBulN81CoVmd5u0dwErgrvG/eD1p//7t2/edoivkFnkCN0GeF36ZfRmpvQvvNk+XGM3j3WL5qvPN8QneARu5CeeTwi7e2OVfbt++DXsDAze8P29Js+Tl5RUVaaSnkTxdDHongsGtWydfvDgB4YG3ku4lhe3aVS7U/1QxKYQU4+fnpyfnFqYVpRUWXrlSEKc53tTZgDgmUaHg3Tq59cUJMuKtrHL3wsKuQ/3Q0BskUkjk7RC/+xR6cEL40yugp0+PHy+o7hygchtlIg8zAH7jRpY8EvJf9/cPjXn1Cvi7t69F0Cn09OXLD1+JCz+OqaCJm5PB4PPnlcCf3GrjuYlY/8DHpAMfQ4mMeEuh64O3rV219OBxQZwmHDTV2aACGCggADQQgALchvzAl3v1iRQScvcunRJLyYhcjvhly9YcztPIBALBBJybs4FSpzi2dSuZDAE2WuVh1yF/udCYdOAjb1D89BERwRi/dNmaFatXrju8e/e7hg4DNzdPZIBNIAAScMlY/tDii/67YH4ZxVevHg1evhzVR/y6devrHDm8s6FzAk8lDBEC2DpIWAu8P2Xf9n2BG+gXLhRfLX/Upf76M2cO7zzknABXVgcB0ARghgHWPNKu2Ado/wLB4FrEj/yRIzsPHWzsnKBsJQW2AgHQAivh/K4HaIFPBW7YsNcv0pZ/2/f8nh4uBp1YcN+ARrz1YthedAECA4H3y4D6wa71DyN+S9WyuG8GuLJV0+RcK4tltXLlugf7T+2H/DaeEvtd/rN2fsvAsm5OBjVv3JKnWSwW+cvY169fA4/lf+B3nx57FOb/A79ny46WLi1UpFA+hJFCXiUhHHh7ftj/kOXboP9lX/kz9vo7GhOcDXDunT98uHcP9vfefuBt+R8gvrjk/DsO1HB3NagJfBK6P3TsAYH8e/0osP9HbfwK5/qQf8cBT5ihwwB6aJsEPNzfMDg/NACMJ0H/Jdbf3ZgABg7hcO7VksLQ+1MuNNDRv94p/0r7+WHlD+yuhY3AuYeKbbH7F5OeTkfzR/VjYxw8yr/TXh8C9MC7f2dQltAP3Z9X6P6THuxF9WMz9Bi/DOPrvCt6h/Go/m5PAtoCFwcCvnMxPEDY+6WH8wc+48KqVd/qay5nZamK9uzA+KquAZAgQoXhMemIv3stohjqx2ZcuLDt2/kXvZFlZ8tuajC+AxFGCAbfR6iZnm7jI8rHZCBefxTj0f2XqoxxRqNAVYB4T4K7owPHGAn4aig/8Oj+XABef+3r+RVlCeKMMmO2IOvd7nbN8c5n6FhndzyxWuTt2xER2P0NvqbXv/20YsdxcWFh3tObMmMc+yE7O1t1pV1z1wYcy4RDDk7vx9q3b+9ekZrh/ZTJBEYj+04yNVsgq9+ciHduwPUo8cSaDRzvx91P56RGeMA1caDLD6lRYNDIE3gcBCjVocKU4K/7u/baU1l4gYD9RiWTQf2oqCjjrIpEPAGHBlC6A7F/g2/7ozGHF1y6Q6UmJydTo6Ko42sR8Yh3K80ABokcPPo1sO9/oUoTbjQAC2K3r+EB5e0DLDUDTBJP9PDo3w07v50ygUaTHZVMPT2sSS0PIpGIFgD4nznYQ3hUXNS7Y8czWziagvqNmlSvVdEDKw/z+7kB2gdkAR5gAqpQAf0CDd1Deaz/XxigNsACPBwCGnXvaP9XFigFAUzsIkBx91/irrNEHhAEyQY7N/97MdzABEBAgf1THDmAgEICtnT6Cylx7PnvAybGAAAAAElFTkSuQmCC",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.HeatMap,
    analyticPresets: TQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: TQ[vX],
      [hX.WOLRD_GIS]: PQ[vX],
      [hX.CUSTOM_GIS]: LQ[vX],
    },
    nodeType: "ghost",
    iconType: "heatMap",
    presets: IQ[vX],
    plot: [0, 0],
  };
const RQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "5B1jt38kraFJ",
            sourceDataFieldId: "From Coordinate",
            name: "From Coordinate",
            customizedName: "From Coordinate",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "rgba(255,255,255,0)",
              theme: "custom",
              middle: null,
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "4MUkjeuPulTO",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "irEWPq71q70I",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  OQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "pavXXKm9Kg3M",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(255,255,255,0)",
            },
          },
          vizField: {
            id: "4MUkjeuPulTO",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "irEWPq71q70I",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  FQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "G2mnWPFGHeub",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(255,255,255,0)",
            },
          },
          vizField: {
            id: "4MUkjeuPulTO",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [0, 30],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "irEWPq71q70I",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  zQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      style: {
        size: 30,
        padding: 20,
        color: {
          defaultColor: "rgba(92,162,255,0.3)",
        },
      },
    },
  },
  kQ = {
    name: "蜂窝热力层",
    name_en: "Hexagon Heatmap",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.HexagonHeatMap,
    analyticPresets: RQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: RQ[vX],
      [hX.WOLRD_GIS]: OQ[vX],
      [hX.CUSTOM_GIS]: FQ[vX],
    },
    nodeType: "ghost",
    iconType: "hexagonHeatMap",
    presets: zQ[vX],
    plot: [0, 0],
  },
  BQ = [MQ, NQ, kQ, DQ];
const GQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        startLocation: [
          {
            id: "26ST3lWuMGep",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "startLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        endLocation: [
          {
            id: "igViSNRoTXQa",
            sourceDataFieldId: "To Province",
            name: "To Province",
            customizedName: "To Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "endLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "#B8E7FE",
              theme: "custom",
              middle: null,
              colors: ["rgba(190,214,255,0)", "#bed6ff", "#bed6ff"],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "8zgefw2pRp6V",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  UQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        startLocation: [
          {
            id: "Pnq25vqLJxAG",
            sourceDataFieldId: "From Country",
            name: "From Country",
            customizedName: "From Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "startLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        endLocation: [
          {
            id: "CKfMo5C75Umq",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "endLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(190,214,255,0)", "#bed6ff", "#bed6ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "#B8E7FE",
            },
          },
          vizField: {
            id: "8zgefw2pRp6V",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  jQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        startLocation: [
          {
            id: "RHRdF3RXCBDn",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "startLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        endLocation: [
          {
            id: "CrIAX7xgTLZu",
            sourceDataFieldId: "To Location",
            name: "To Location",
            customizedName: "To Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "endLocation",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(190,214,255,0)", "#bed6ff", "#bed6ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "#B8E7FE",
            },
          },
          vizField: {
            id: "8zgefw2pRp6V",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  HQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      lineStyle: {
        startColor: "#BED6FF",
        speed: 0.8,
        size: 3,
      },
      breathPoint: {
        enable: !1,
        speed: 1,
        size: 2,
      },
    },
  },
  VQ = {
    name: "飞线层",
    name_en: "Fly Line",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.FlyLine,
    analyticPresets: GQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: GQ[vX],
      [hX.WOLRD_GIS]: UQ[vX],
      [hX.CUSTOM_GIS]: jQ[vX],
    },
    nodeType: "ghost",
    iconType: "flyLine",
    presets: HQ[vX],
    plot: [0, 0],
  };
const WQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "758H0Pwu6OSu",
            sourceDataFieldId: "Route 1",
            name: "Route 1",
            customizedName: "Route 1",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "custom",
              themeName: "自定义",
              fieldColorMap: [],
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
              ],
              middle: null,
              theme: "custom",
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "2cnFmV9f6VYq",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [3, 4],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "GIfcGUCMKP24",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        limit: 10,
        type: "none",
        unit: "rows",
      },
    },
  },
  qQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "G8jvNsvEtKqm",
            sourceDataFieldId: "Route Country",
            name: "Route Country",
            customizedName: "Route Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-18",
                  endDate: "2024-12-18",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
              ],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
            },
          },
          vizField: {
            id: "2cnFmV9f6VYq",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [3, 4],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "GIfcGUCMKP24",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  YQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "rVQ0Pfnew0yD",
            sourceDataFieldId: "Route Location",
            name: "Route Location",
            customizedName: "Route Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-18",
                  endDate: "2024-12-18",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: [
                "rgba(98,189,255,1)",
                "rgba(134,255,245,1)",
                "rgba(134,255,245,1)",
              ],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
            },
          },
          vizField: {
            id: "2cnFmV9f6VYq",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [3, 4],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "GIfcGUCMKP24",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  XQ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      icon: {
        image: "",
      },
      speed: 3,
      startPoint: {
        enable: !0,
        image:
          "data:image/png;base64,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",
        size: 30,
      },
      nodePoint: {
        enable: !0,
        image:
          "data:image/png;base64,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",
        size: 10,
      },
      endPoint: {
        enable: !0,
        image:
          "data:image/png;base64,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",
        size: 20,
      },
    },
  },
  QQ = {
    name: "轨迹线层",
    name_en: "Path Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Path,
    analyticPresets: WQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: WQ[vX],
      [hX.WOLRD_GIS]: qQ[vX],
      [hX.CUSTOM_GIS]: YQ[vX],
    },
    nodeType: "ghost",
    iconType: "pathLine",
    presets: XQ[vX],
    plot: [0, 0],
  },
  ZQ = [VQ, QQ];
const JQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "dviDxKmn9pMh",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        majorLabel: [
          {
            id: "obxeVHvApYr6",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "#f5222d",
              theme: "custom",
              middle: null,
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "gc23NWm9UrPF",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [30, 70],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "6PMACrzawmkI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 9,
        unit: "rows",
      },
    },
  },
  KQ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "7tsLzLjbbJzx",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "B21K4lQprV0p",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "#f5222d",
            },
          },
          vizField: {
            id: "gc23NWm9UrPF",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [30, 70],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "6PMACrzawmkI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 9,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  $Q = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "6Ry3rGxuOtZe",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "jqqxzMjNzwXq",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "#f5222d",
            },
          },
          vizField: {
            id: "gc23NWm9UrPF",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [30, 70],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "6PMACrzawmkI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 9,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  tZ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      display: {
        useCylinder: !0,
        segments: 3,
      },
      color: {
        defaultColor: "rgba(252,169,42,1)",
      },
      icon: {
        image:
          "data:image/png;base64,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",
      },
      opacity: {
        enable: !1,
        min: 0.2,
        max: 1,
        speed: 0.3,
      },
      scale: {
        enable: !0,
        min: 0.8,
        max: 1,
        speed: 0.2,
      },
      poi: {
        enable: !1,
        orient: "vertical",
        trigger: "show",
        alignment: "top",
        coverEnable: !1,
        offsetX: 0,
        offsetY: 30,
        labelFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 0,
        },
        valueFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "D-DIN",
          fontWeight: "normal",
          fontSize: 14,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 5,
        },
        background: {
          image: "",
          opacity: 0.4,
          color: "rgba(10,10,26,0.6)",
          shadow: {
            color: "rgba(1,11,13,0.7)",
            blur: 2,
            offsetX: 0,
            offsetY: 0,
          },
          padding: {
            top: 6,
            left: 6,
            right: 6,
            bottom: 6,
          },
          borderRadius: {
            topLeft: 2,
            topRight: 2,
            bottomRight: 2,
            bottomLeft: 2,
          },
        },
      },
    },
  },
  eZ = {
    name: "气泡层",
    name_en: "Bubble Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Bubble,
    analyticPresets: JQ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: JQ[vX],
      [hX.WOLRD_GIS]: KQ[vX],
      [hX.CUSTOM_GIS]: $Q[vX],
    },
    nodeType: "ghost",
    iconType: "bubble",
    presets: tZ[vX],
    plot: [0, 0],
  };
const iZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "lwtGCr3r9R5A",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        majorLabel: [
          {
            id: "obxeVHvApYr6",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              manualColorMap: [],
              theme: "volcanoBlue",
              themeName: "火山蓝",
              fieldColorMap: [],
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
            },
            continuousConfig: {
              min: null,
              isThreeColors: !1,
              themeName: "自定义",
              defaultColor: "rgba(194,255,238,0)",
              theme: "custom",
              middle: null,
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              isReverse: !1,
              gradientType: "continuous",
              max: null,
              gradientSteps: 3,
            },
          },
          vizField: {
            id: "5iFSdl8I1oMT",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [10, 50],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "j5LLl7UH6KDI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  nZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "fiUIWhtMftcu",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "i2XEyiepK6yN",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(194,255,238,0)",
            },
          },
          vizField: {
            id: "5iFSdl8I1oMT",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [10, 50],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "j5LLl7UH6KDI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  rZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "bsy6fnpHfrPL",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "tPVW5Xdj5oFw",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        color: {
          colorConfig: {
            type: "continuous",
            defaultType: "continuous",
            discreteConfig: {
              theme: "volcanoBlue",
              themeName: "火山蓝",
              colors: [
                "#006EFF",
                "#00E5E5",
                "#2E55EA",
                "#B8E7FE",
                "#00D689",
                "#B7F9F5",
                "#FBCC71",
                "#F46E50",
              ],
              fieldColorMap: [],
              manualColorMap: [],
              useGradient: !0,
            },
            continuousConfig: {
              theme: "custom",
              themeName: "自定义",
              colors: ["rgba(208,249,255,0.15)", "#7ec9ff", "#7ec9ff"],
              gradientType: "continuous",
              gradientSteps: 3,
              isReverse: !1,
              isThreeColors: !1,
              max: null,
              middle: null,
              min: null,
              defaultColor: "rgba(194,255,238,0)",
            },
          },
          vizField: {
            id: "5iFSdl8I1oMT",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "color",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [10, 50],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "j5LLl7UH6KDI",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  oZ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      display: {
        useCylinder: !0,
        segments: 3,
        radiusTop: 3,
        radiusBottom: 2,
      },
      color: {
        defaultColor: "rgba(194,255,238,0)",
      },
      poi: {
        enable: !1,
        anchor: "top",
        orient: "vertical",
        trigger: "show",
        alignment: "top",
        coverEnable: !1,
        offsetX: 40,
        offsetY: 40,
        labelFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 0,
        },
        valueFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "D-DIN",
          fontWeight: "normal",
          fontSize: 14,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 5,
        },
        background: {
          image: "",
          opacity: 0.4,
          color: "rgba(10,10,26,0.6)",
          shadow: {
            color: "rgba(1,11,13,0.7)",
            blur: 2,
            offsetX: 0,
            offsetY: 0,
          },
          padding: {
            top: 6,
            left: 6,
            right: 6,
            bottom: 6,
          },
          borderRadius: {
            topLeft: 2,
            topRight: 2,
            bottomRight: 2,
            bottomLeft: 2,
          },
        },
      },
    },
  },
  aZ = {
    name: "柱状层",
    name_en: "Column Layer",
    snapshot:
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAC8VBMVEUAAACGm8yzv+O0wOSwveK0weewveOuuuCfsNk+X6Kuu+G5xOd4kspFZqivvuWywOXP1/Gtu+HFz+25w+XV2e+8yeesuuCywOe9yemxvuS6xeeuu+DL0+1pi8fBzepbebW2w+avvOLGz+u/yelLa6uUqdXBzey7x+q4xOi1webAyerCzOzY3fNLa6q6yeRMbKfCzeqktdxDcb28yeqwvOJ8lMdTfMLI0e6wveOEnc7O1u6/yOtefrtoisTP2O+8x+Zui8SGns7J0OrU2vKKns3J1O+ZqdSKotFIaKlPesFgfbdJdr/T2vKKoc94ksbS2fN2kMStud7ByeiIoNCzv+HT2fDDzOiDnM1McbZtiMA5YKfV3PHY3vJ/l8pScK9visE5W56cq9WAmMqBmctvisBQb65BYaVMdbpTe8BphbxBY6RDZ6uCmsxSeb06XJ6Hn8+KodHW2++Kos9zjL8jSZN3kcWFo9duicByjcJvisBCY6V5k8Z0jsRsh79ng7xvk85xi8Jphb1qj8tmgrtJaamBodV1mNCCmst9lsl8lchrhr56lMdMbKtEZKZ1kMVHZ6ipu+N4mtF/mMpjgLpLaqo2WZ+4xuisvONskc1OecGrveWDnM2AmctFc71RcK5njMpObq1AYaQ/YaM6XKCywOKarNZylc9Bb7xlgbpbebVUc7AzVpynuuV+n9SQpNFagsRFZqg9X6KpvOe1w+RYdrO6yet8nNKLn89ki8phiMhXgMRWe7zDz+6sv+eluOOJnc5ehsZUfsNRfMJLdLs8bLpffLdWdLLF0vK/y+2jstqLqNmHptiTptKNodCFnc5RdrjP2POywum8yOivwOegtuCmtduHn8+Gns5JdsBhfrk8XqEwU5soTJWquN2Yq9WIodBHcbhaeLRFa67K1PG0xel5l8xggb1GbLI+Zas4XKMtUJmQrNtmicVLcLQ/aLA4X6fV3vWdtN6MotB0k8lhhMJphr9IaKpCbrhKbK6BntE3YKtOXmnNAAAAdXRSTlMA/sa4wOPexv7+z8cg/vn02tfQuhgN7uzc1828u6JOIPXltrNf/e3p593OxqJ7LhD6+fjx7+/e2dDFw72BfnhvZl83Jf7w8O/v7Ofh39/fzr+6o5+blZGQkI+NgVgv7+7s5d/ez8/PyL+/v7mvr5mAf3BgUFD+GoIIAAAGZUlEQVRYw+2WV1xSYRjGEzRXlmm5bWh777333nvvvUvclhXa0EJJDCwUhJIhRIgmoCmkokG4c+TIbaa211Xfd3CQh+zXve/9/3mfd53vdOuKrug0xszbcXKljEyWTzm2bVD//6ZnTXn88GF9s5wsk5Ebxcb0I4N6/A/uOOEx4AsKQH5ZsjiZ/yRQHR/vCCR2bZ7hNKfPP/A+jhNeQP57OVkuCJGL+XyJ5Idawn4fPnuOhak+1tJ5Yad8v5UvEL6pvJxcGxL5Tc1PSoqPfxZ+9er9wVPtMIb69tgNfTvhZ09A+KZmTp2cXEuLFBg3JsU/Q/igITa200wMDe2xY/6K93V8oclfz+Fw6gQVjQIBjfaNj/CXcxcP627b28RQH9vvrwI7in8h/MM6Tn2dgCxONqZ5eARGIHwDafFQg+69ocICXbkXLujb7dKbN29Cmr+D/jeFyMnJYr6aTgP8F8j7VSWQhgwz6G47DWPaB42fdxgxwmbLPiDw7l1zQYG8vlYGeL7Y7JskKTz86n1QQBWXMG4iVLCbi84/ysESY2I73IoN+OLicnJdbTLgQf9/SDT1X8aLEriJhHFDhg4zWD0Wxe9ysNQ3NOnd3drKvai4mMMJqS+vaFRL4Pxa+EeirKdcbmIioaeRN3E72oAzVh/wA616qZQpUKBWXiHgq8H8WvmPogQgwCUQ/AuJUddQpzHDGWsIBSYN0FvE43mEhERGeqglfJg/HOGDpFlPQSQkukPe53hHAQdnLMak90CrSb309J6rmG60oiJjeqCHpDW/H06RACKnAecNed9bHS1sdrLETIMVjAcCz1VKHlFAB/N/IgnX8H6xoqqcrFwcDneNCHnv2R0EFs6YaWoLK4iDAnFxvFIXMH+zuwFfNHxQNEHKbcDjcJ+joiDvuhd1QQ52w4cbDGBCHiqomBGBT+5ev866j/C5HzIzpXgc3hX4h7z7ld2oG960f8mSUiVPpYqDoRrMMrt7/d69CDbg/aI/ZKalVX7EuxFbebd5qEmeeVfMiaSmuustYg5WKpU8hA+IYF1OZae4fKhMS0sb/DWqjfdyRAkc5YDxw/kVBcakuLhQAR8QEEGNiWGnxrxVAAfS4Gvt/J11KIHlTSEILzCmewQG3gX1B0REUKnsVMCzfEVpIhefdt7LZQ1KoIBcjvACeH9PkPpvefrreabGfCayrsD+a/Oek1ECZLLMA/jXzB/6dyORhKRsBu/tV3wQLtaVqOXfxfP2TbSATFYRWQS/H5r8bqRQAiE0hxQaFF1d6EOM6sDfQPdAllxRREf8w/oDGBRwegRKFumnD89Ir4W/0sYHowSmJIsrjKF/M6T/UdkERIBC8s7OrKxkdsgffBAlcFosMW6rP6KmmkTgcgFPqbqZKVUopMF/8g+mowS2qWmAN0P4gJpHQSKKRiDUP1MhEilUf/L+W1ECg+g0Wkt+KqvGz4+S9RRGziffSqlCpPB3db+jvOHVyofNRwmMpdOQ+tlf3mvuryorgULJoRCJntlSKdPV3T+bRGK28mE6ntoTmv7D+33kFxQUi0/MIWXlVoP+u/u7AP9CYWgog/EJ4V+BFqBitMY/zA/56Gg8uH+8L5ifL1I/iQH2IlQ4Ph/wr0EF6BqWIf2nXkX4WIR/6dWyP25uXqWkUBA9Bwxghr3OhxWgLWjur6Y9P85Le//yhFCgZ6+hVryNCIC2AHlqTRv/8ustb639CRbmQN7awMYGPE06LQCcyo553+o/Qylk8Nrnf/s1iQH54Tbm5jt1/6UcBjz4fhRWa/gGRrpRnvb+GGX3srY2WGU+1cLCQucL338P5N+yfCD/MkOYx2TmtfE3wfxKJlobmJtbjLCzMx25QJfCIIRnpdyBfO44IcOIqb2/YWUTh9qsArwpBoPZorsNCJ9SWJ2RkZHNKClhlLbzcP68IVPNLUYC3lDfUncjZyE8Mco1I1eYl55eYvQHn1823nztSFNTwNtjNAC6ihWAB98vTyPQwvR0poa/Afn8/LKlF3auHTnTUl/ffv0mnTjs5ArI+/r6Qwd5n7Tyl5Wt3g3/RWZaYu3X27ePAV2GZv9KQQ+Yrfmh/6Xn+sI3bJSTMxaL1d4ltAlHZP94H0vb8ofll21sOYA+c5ycNoD8nUaPeYfa5vcAud+zIPv/RY+L29etmXzzxuQDp7bO79GtK7qis/gNZdgx58JsjnsAAAAASUVORK5CYII=",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Column,
    analyticPresets: iZ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: iZ[vX],
      [hX.WOLRD_GIS]: nZ[vX],
      [hX.CUSTOM_GIS]: rZ[vX],
    },
    nodeType: "ghost",
    iconType: "column",
    presets: oZ[vX],
    plot: [0, 0],
  };
var sZ =
  "data:image/png;base64,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";
const lZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "qGrK16DWGz8y",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        information: [
          {
            id: "ncCwWo9SlfMC",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
          {
            id: "FghP73ko3yAU",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  uZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "wwf01uKsquGz",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        information: [
          {
            id: "aeWtqlcsUTQt",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
          {
            id: "FghP73ko3yAU",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  cZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "QOp38DPktrzt",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        information: [
          {
            id: "fSlqNvaBjrHM",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
          {
            id: "FghP73ko3yAU",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "information",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  hZ = {
    [mX.VolcanoBlue]: {
      common: {
        showAllLevelData: !1,
      },
      marker: {
        showAll: !1,
      },
      anchor: {
        position: rX.Center,
        offset: {
          x: 0,
          y: 0,
        },
      },
      carousel: {
        enable: !0,
        type: lX.InOrder,
        onceNumber: 5,
        animationIn: aX.Gradient,
        animationOut: aX.Gradient,
        durationIn: 0.5,
        durationOut: 0.5,
        stay: 5,
      },
    },
  },
  pZ = {
    name: "信息标签层",
    name_en: "Information Label Layer",
    snapshot: sZ,
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.InformationLabel,
    analyticPresets: lZ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: lZ[vX],
      [hX.WOLRD_GIS]: uZ[vX],
      [hX.CUSTOM_GIS]: cZ[vX],
    },
    nodeType: "host",
    iconType: "informationLabel",
    presets: hZ[vX],
    dataPresets: {
      showLabelCity: "",
    },
    plot: [200, 100],
  };
const dZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "qGrK16DWGz8y",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        majorLabel: [
          {
            id: "obxeVHvApYr6",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [20, 60],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "I7eLJZ12qeQp",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-15",
                  endDate: "2023-06-15",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  fZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "PXXaFb3kGm8z",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "PdeWu56QprR6",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [10, 60],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "I7eLJZ12qeQp",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-15",
                  endDate: "2023-06-15",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  gZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "GKt05cHcsVkT",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "DGKUjcOAiALE",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {
        size: {
          config: {
            type: "continuous",
            discrete: {
              mainPercent: 100,
              sizeMappingList: {
                auto: [],
                manual: [],
              },
            },
            continuous: {
              percent: [10, 60],
              min: null,
              max: null,
            },
          },
          vizField: {
            id: "I7eLJZ12qeQp",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "size",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-15",
                  endDate: "2023-06-15",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        },
      },
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  mZ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      icon: {
        type: 30,
        image:
          "data:image/png;base64,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",
      },
      color: {
        color: "#E2FFFF",
      },
      poi: {
        enable: !0,
        orient: "vertical",
        trigger: "show",
        alignment: "top",
        coverEnable: !1,
        offsetX: 0,
        offsetY: 30,
        labelFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 0,
        },
        valueFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "D-DIN",
          fontWeight: "normal",
          fontSize: 14,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 5,
        },
        background: {
          image: "",
          opacity: 0.4,
          color: "rgba(10,10,26,0.6)",
          shadow: {
            color: "rgba(1,11,13,0.7)",
            blur: 2,
            offsetX: 0,
            offsetY: 0,
          },
          padding: {
            top: 6,
            left: 6,
            right: 6,
            bottom: 6,
          },
          borderRadius: {
            topLeft: 2,
            topRight: 2,
            bottomRight: 2,
            bottomLeft: 2,
          },
        },
      },
    },
  },
  yZ = {
    name: "图标散点层",
    name_en: "Label Scatter Layer",
    snapshot: sZ,
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.LabelScatter,
    analyticPresets: dZ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: dZ[vX],
      [hX.WOLRD_GIS]: fZ[vX],
      [hX.CUSTOM_GIS]: gZ[vX],
    },
    nodeType: "ghost",
    iconType: "labelScatter",
    presets: mZ[vX],
    plot: [0, 0],
  },
  vZ = [eZ, yZ, aZ, pZ];
const bZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "hB8il7vaNjTa",
            sourceDataFieldId: "From Coordinate",
            name: "From Coordinate",
            customizedName: "From Coordinate",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        majorLabel: [
          {
            id: "obxeVHvApYr6",
            sourceDataFieldId: "From Province",
            name: "From Province",
            customizedName: "From Province",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
              },
            },
            timeGranularity: {
              unit: "None",
            },
          },
        ],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
    },
  },
  xZ = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "1UuToDXwyoFI",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "5xZr95BRC2PZ",
            sourceDataFieldId: "To Country",
            name: "To Country",
            customizedName: "To Country",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  _Z = {
    [mX.VolcanoBlue]: {
      source: {
        request: {
          type: "auto",
          interval: 30,
        },
        dataSourceId: "default_map_1",
        type: "query",
        config: {
          query: {
            id: "default_map_1",
          },
          vizQuery: {
            vizQueryHistoryId: null,
            datasetId: null,
          },
          report: {
            id: null,
            name: "",
            datasetId: null,
          },
        },
      },
      vizFieldBlock: {
        location: [
          {
            id: "tHKOcTRtPHbq",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "location",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        majorLabel: [
          {
            id: "SiX7E0kkxeLF",
            sourceDataFieldId: "From Location",
            name: "From Location",
            customizedName: "From Location",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "majorLabel",
            visible: !0,
            vizFieldType: "Text",
            role: "Dimension",
            configDescription: null,
            isPartitionField: !1,
            aggregation: {
              type: "none",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2024-12-16",
                  endDate: "2024-12-16",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        subLabel: [
          {
            id: "cTGSQzOaJgRB",
            sourceDataFieldId: "Sales",
            name: "Sales",
            customizedName: "Sales",
            deficiency: !1,
            queryId: "default_map_1",
            description: "",
            blockName: "subLabel",
            visible: !0,
            vizFieldType: "Number",
            role: "Measure",
            configDescription: null,
            aggregation: {
              type: "sum",
            },
            dataFormat: {
              type: "auto",
              numberFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
                unit: "none",
                kSep: !0,
              },
              percentageFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
              permilleFormatConfig: {
                prefix: "",
                suffix: "",
                precision: {
                  type: "decimal",
                  digit: 2,
                },
              },
            },
            calculation: {
              type: "None",
              periodComparison: {
                mode: "LastPeriod",
                valueType: "Ratio",
                fixedDateConfig: {
                  beginDate: "2023-06-5",
                  endDate: "2023-06-5",
                },
                dynamicDateConfig: {
                  quantity: 1,
                  unit: "Day",
                },
                fieldMode: "Group",
              },
            },
            timeGranularity: {
              unit: "None",
            },
            drill: {
              enable: !1,
            },
          },
        ],
        detail: [],
      },
      displayChannel: {},
      filters: [],
      sort: [],
      topN: {
        type: "none",
        limit: 10,
        unit: "rows",
      },
      referenceLine: [],
    },
  },
  SZ = {
    [mX.VolcanoBlue]: {
      common: {
        zoomMin: 0,
        zoomMax: 24,
        showAllLevelData: !1,
      },
      feature: {
        token: "",
        profile: "driving",
        minutes: 60,
      },
      style: {
        color: "rgba(63,200,255,0.4)",
        outline: {
          width: 2,
          opacity: 1,
          color: "#3FC8FF",
        },
      },
      centerPoint: {
        enable: !0,
        image:
          "data:image/webp;base64,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",
        size: 10,
      },
      poi: {
        enable: !1,
        orient: "vertical",
        trigger: "show",
        alignment: "top",
        coverEnable: !1,
        offsetX: 0,
        offsetY: 30,
        labelFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "SourceHanSansCN-Normal",
          fontWeight: "normal",
          fontSize: 12,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 0,
        },
        valueFontStyle: {
          prefix: "",
          suffix: "",
          enable: !0,
          fontFamily: "D-DIN",
          fontWeight: "normal",
          fontSize: 14,
          color: "#FFFFFF",
          offsetX: 0,
          offsetY: 5,
        },
        background: {
          image: "",
          opacity: 0.4,
          color: "rgba(10,10,26,0.6)",
          shadow: {
            color: "rgba(1,11,13,0.7)",
            blur: 2,
            offsetX: 0,
            offsetY: 0,
          },
          padding: {
            top: 6,
            left: 6,
            right: 6,
            bottom: 6,
          },
          borderRadius: {
            topLeft: 2,
            topRight: 2,
            bottomRight: 2,
            bottomLeft: 2,
          },
        },
      },
    },
  },
  MZ = {
    name: "等时圈层",
    name_en: "Isochrone Layer",
    snapshot:
      "data:image/png;base64,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",
    category_cn: "3D地图",
    category_en: "3D Map",
    editingSpace: ["gisSurface"],
    renderType: tX.Isochrone,
    analyticPresets: bZ[vX],
    extraAnalyticPresets: {
      [hX.CHINA_GIS]: bZ[vX],
      [hX.WOLRD_GIS]: xZ[vX],
      [hX.CUSTOM_GIS]: _Z[vX],
    },
    nodeType: "ghost",
    iconType: "isochronous",
    presets: SZ[vX],
    plot: [0, 0],
  },
  CZ = [...vQ, ...vZ, ...ZQ, ...BQ, ...[MZ], ...wX];
class wZ {
  constructor(t) {
    Object.defineProperty(this, "parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t,
    }),
      Object.defineProperty(this, "watchers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [],
      });
  }
  addWatch(t) {
    t instanceof Array
      ? Array.prototype.push.apply(this.watchers, t)
      : this.watchers.push(t),
      this.watchers.sort((t, e) => (t.priority || 10) - (e.priority || 10));
  }
  async compare(t, e) {
    if (e && t)
      for (let i = 0, n = this.watchers.length; i < n; i++) {
        const n = this.watchers[i],
          { rule: r, cb: o } = n;
        if (this.__calcRuleAndProps(r, e, t) && (await o(e, t), n.serial))
          break;
      }
  }
  defaultRule(t, e, i, n = !1) {
    return this.parent.defaultRule(t, e, i, n);
  }
  __calcRuleAndProps(t, e, i) {
    let n = !1;
    switch (t.type) {
      case "all":
        t.rules && (n = t.rules.every((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      case "some":
        t.rules && (n = t.rules.some((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      default: {
        const n =
          "custom" === t.type ? t.ruleFunc : this.parent.ruleFuncMap[t.type];
        return !!n && n(e, i, t.key);
      }
    }
    return n;
  }
}
const AZ = new (class {
  constructor() {
    Object.defineProperty(this, "ruleFuncMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {},
    });
  }
  registerRule(t, e) {
    this.ruleFuncMap[t] = e;
  }
  createPropsWatch() {
    return new wZ(this);
  }
  defaultRule(t, e, i, n = !1) {
    return {
      rule: {
        type: e,
        key: t,
      },
      cb: i,
      serial: n,
    };
  }
})();
function EZ(t, e) {
  if ("string" == typeof e) return t[e];
  {
    const i = e.length;
    let n,
      r,
      o = -1;
    for (; ++o < i && ((n = e[o]), Object.hasOwnProperty.call(t, n)); )
      r = t = t[n];
    return o === i ? r : void 0;
  }
}
function DZ() {
  if (this.editMode === g.View) {
    this.getRenderer().emit(m.Loaded, {
      target: this.POMNode,
    });
  }
  this.asyncFontsTask && this.onFontsUpdated();
}
function TZ() {
  var t;
  const { gisLayer: e } = this.variableContext;
  (this.asyncFontsTask = !0),
    null === (t = null == e ? void 0 : e.initPOI) || void 0 === t || t.call(e);
}
function PZ() {
  this.propsWatch.compare(this.preProperties, this.properties),
    (this.preProperties = u(this.properties));
}
function LZ() {
  const { gisLayer: t } = this.variableContext,
    e = this.getLayerConfig();
  null == t || t.set(e);
}
function IZ() {
  this.asyncTaskPool.forEach((t) => t.abort()), (this.asyncTaskPool = []);
}
function NZ() {
  var t;
  const e =
    null !== (t = this.errorTip) && void 0 !== t
      ? t
      : new y(
          v.MissFields,
          `\n ${this.POMNode.name}: Please Config Data Bind First`
        );
  this.renderTips(e);
}
function RZ() {
  var t;
  null === (t = this.parent) || void 0 === t || t.tickOnce();
}
function OZ() {
  var t;
  null === (t = this.parent) || void 0 === t || t.tickLoop();
}
function FZ() {
  this.propsWatch.addWatch([
    this.propsWatch.defaultRule(
      [
        ["common", "zoomMin"],
        ["common", "zoomMax"],
      ],
      "diffAnyoneDeep",
      (t) => {
        this.setLayerConfig(), this.tickOnce();
      }
    ),
  ]);
}
function zZ(t) {
  kZ.call(this, t),
    this.variableContext.gisLayer
      ? ((this.preVizData = void 0),
        this.variableContext.gisLayer.set({
          data: [],
        }),
        this.tickOnce())
      : this.render(!0);
}
function kZ(t) {
  var e;
  t
    ? (null === (e = this.errorTip) || void 0 === e
        ? void 0
        : e.message.includes(t.message)) ||
      (t.message =
        t.type === v.MissFields
          ? `${t.message}`
          : `${this.POMNode.name}: ${t.message}`)
    : (t = new y(
        v.MissFields,
        `${this.POMNode.name}: Please Config Data Bind First`
      )),
    t.message.includes("\n") || (t.message = `\n${t.message}`),
    t.type !== v.MissFields &&
      t.message.length > 100 &&
      (t.message = t.message.slice(0, 97) + "..."),
    (this.errorTip = t),
    this.plot.visible &&
      this.parent &&
      this.errorTip &&
      ((this.parent.variableContext.tipsPool[this.POMNode.id] = this.errorTip),
      this.parent.renderTips());
}
function BZ(t = !0) {
  var e;
  this.parent &&
    (null === (e = this.parent.variableContext) ||
      void 0 === e ||
      delete e.tipsPool[this.POMNode.id],
    this.parent.renderTips()),
    t && (this.errorTip = void 0);
}
function GZ(t) {
  this.variableContext.gis &&
    (this.variableContext.gisLayer.set({
      common: {
        visible: t,
      },
    }),
    t && this.errorTip ? this.renderTips(this.errorTip) : this.removeTips(!1),
    this.tickOnce());
}
function UZ(t) {
  if (!1 === t.plot.visible) return !1;
  let e = t.POMNode.parent;
  for (; null == e ? void 0 : e.isGroupNode; ) {
    if (!1 === e.visible) return !1;
    e = e.parent;
  }
  return !0;
}
function jZ() {
  if (this.editMode === g.Edit) this.setElementVisibility(this.plot.visible);
  else {
    const t = UZ(this);
    this.setElementVisibility(t);
  }
}
function HZ(t) {
  var e;
  if (!this.POMNode) return;
  let i;
  if (t) i = t;
  else {
    i = 100 * (this.POMNode.page.descendants.length - this.POMNode.index - 1);
  }
  const n =
    null === (e = this.variableContext) || void 0 === e ? void 0 : e.gisLayer;
  n &&
    n.set({
      common: {
        zIndex: i,
      },
    }),
    (this.zIndex = i);
}
function VZ() {
  var t;
  this.removeTips(),
    (null === (t = this.variableContext) || void 0 === t
      ? void 0
      : t.gisLayer) &&
      (this.variableContext.gisLayer.remove(),
      (this.variableContext.gisLayer = null)),
    (this.preVizData = void 0),
    this.tickOnce();
}
AZ.registerRule("has", (t, e, i) => LX(EZ(t, i))),
  AZ.registerRule("diff", (t, e, i) => {
    const n = EZ(t, i),
      r = EZ(e, i);
    return LX(n) && n !== r;
  }),
  AZ.registerRule("diffDeep", (t, e, i) => {
    const n = EZ(t, i),
      r = EZ(e, i);
    return (
      LX(n) && n !== r && (Array.isArray(n) ? !f(n, r) : !f(IX({}, r, n), r))
    );
  }),
  AZ.registerRule("diffAnyone", (t, e, i) =>
    i.some((i) => {
      const n = EZ(t, i),
        r = EZ(e, i);
      return LX(n) && n !== r;
    })
  ),
  AZ.registerRule("diffAnyoneDeep", (t, e, i) =>
    i.some((i) => {
      const n = EZ(t, i),
        r = EZ(e, i);
      return (
        LX(n) && n !== r && (Array.isArray(n) ? !f(n, r) : !f(IX({}, r, n), r))
      );
    })
  ),
  AZ.registerRule("always", () => !0),
  AZ.registerRule("hasAndClose", (t, e, i) => {
    const n = EZ(t, i);
    return LX(n) && !n;
  });
class WZ extends O {
  constructor(t, e) {
    super(t, e),
      Object.defineProperty(this, "parent", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "preVizData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "propsWatch", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "preProperties", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {},
      }),
      Object.defineProperty(this, "asyncTaskPool", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [],
      }),
      Object.defineProperty(this, "errorTip", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "zIndex", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "comboTimer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "comboTimeout", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 200,
      }),
      Object.defineProperty(this, "asyncFontsTask", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "variableContext", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {
          tipDOM: null,
        },
      }),
      Object.defineProperty(this, "selectedItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null,
      }),
      (this.POMNode.interaction = !1),
      this.POMNode.viz || (this.POMNode.viz = {}),
      (this.propsWatch = AZ.createPropsWatch()),
      this.initPropsWatchRule();
  }
  initHandle() {
    return DZ.call(this);
  }
  onFontsUpdated() {
    return TZ.call(this);
  }
  update() {
    return PZ.call(this);
  }
  setLayerConfig() {
    return LZ.call(this);
  }
  asyncTaskAbort() {
    return IZ.call(this);
  }
  renderDefaultTips() {
    return NZ.call(this);
  }
  tickOnce() {
    return RZ.call(this);
  }
  tickLoop() {
    return OZ.call(this);
  }
  initPropsWatchRule() {
    return FZ.call(this);
  }
  renderTips(t) {
    return zZ.call(this, t);
  }
  removeTips(t = !0) {
    return BZ.call(this, t);
  }
  updateGisLayerVisible() {
    return jZ.call(this);
  }
  updateZIndex(t) {
    return HZ.call(this, t);
  }
  setElementVisibility(t) {
    return GZ.call(this, t);
  }
  destroy() {
    VZ.call(this), super.destroy();
  }
}
Object.defineProperty(WZ, "events", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [
    {
      title_cn: "加载前",
      title_en: "Before Element Load",
      value: b.BeforeLoad,
    },
    {
      title_cn: "加载完成",
      title_en: "Element Loaded",
      value: b.Loaded,
    },
  ],
});
class qZ extends F {
  constructor(t, e) {
    super(t, e),
      Object.defineProperty(this, "parent", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "preVizData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "propsWatch", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "preProperties", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {},
      }),
      Object.defineProperty(this, "asyncTaskPool", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [],
      }),
      Object.defineProperty(this, "errorTip", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "zIndex", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "asyncFontsTask", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "variableContext", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {
          tipDOM: null,
        },
      }),
      (this.POMNode.interaction = !1),
      this.POMNode.viz || (this.POMNode.viz = {}),
      (this.propsWatch = AZ.createPropsWatch()),
      this.initPropsWatchRule();
  }
  initHandle() {
    return DZ.call(this);
  }
  onFontsUpdated() {
    return TZ.call(this);
  }
  update() {
    return PZ.call(this);
  }
  setLayerConfig() {
    return LZ.call(this);
  }
  asyncTaskAbort() {
    return IZ.call(this);
  }
  renderDefaultTips() {
    return NZ.call(this);
  }
  tickOnce() {
    return RZ.call(this);
  }
  tickLoop() {
    return OZ.call(this);
  }
  initPropsWatchRule() {
    return FZ.call(this);
  }
  renderTips(t) {
    return zZ.call(this, t);
  }
  removeTips(t = !0) {
    return BZ.call(this, t);
  }
  updateGisLayerVisible() {
    return jZ.call(this);
  }
  updateZIndex(t) {
    return HZ.call(this, t);
  }
  setElementVisibility(t) {
    return GZ.call(this, t);
  }
  destroy(t) {
    VZ.call(this), super.destroy(t);
  }
}
const YZ = [
  "data:image/webp;base64,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",
  "data:image/webp;base64,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",
  "data:image/webp;base64,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",
  "data:image/webp;base64,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",
  "data:image/webp;base64,UklGRr4jAABXRUJQVlA4WAoAAAAQAAAAswAAvAAAQUxQSOcIAAABGTJpG9p39S95GiL6H1AFU88eU45AIGl/8g0iIggzSG4bSZIc1f//cU9qlojom2afiZgAiAHYtm08KYCEkHRIsj+whe2fKUnS7x8nKzMLibLRxti2bc9ccnev9sq2bds7ttu27e4yspLnnPg9z2REZF3ls5cRwcBt20a9lWbVSDpuvSDju3oXZ8GHtp4zQaKG0OZVZBXJX06pjhbi5s6QCaGTTo64euIKFCiFdhrFle8yCi9EaHsSE4PDHQLdlRMl9u4AUfa7kRBSsACY/mgfFozNFoQAgUkp0x8FGmWiJZzaigREBNqQUSgq0M0cb5QRJBAqIyLKHFAEdPN0FATERgbCCwXigMLAzZNhSai2TBtMHaGlYorL3VtWtNCmVGhKhSKAAITtCRikDwix3AkpVtWiSsHQgw3CcqGIUMzJycBhTmEowPAVOiGUGTZF7REw4iLhZXZ4SE2ARQy9UISOqgA3jeiSsAmEJkMB9Te0MT+6f5+Qln235MOaORVIGGn9ge8z3jRX/fPFMpq7G7xtiAKvJxNK31jatlounltY/GD/F0cPXI4Cn2qx5iGLp6WxcDCj6mc/v+Zjt3W9XtC8AJtFk7aiGQiFty+//fowXzg4+puz0+dEiaN/RwWBUIKEgNr93Ttbg+H3rroq/8olUnCEU67ViCEWJdj7Xc+DKHpapBmJKHGxekohIp5Soj7kQwmoRVkwSilKHYm5G6YmUSYt21IWa1bpwMC93XUemTv+0mEHJ6TUxDpk8bdqzETyO5/ZftkcOaFidbvLvHdWnjXn1IaJ666++HdRpiO5/QgvP17UZ398NMVj1fPV93vP3dFPQDfqF5YgojgGwZ9q2xs8hIWhUgDR3T+pFACN/2s3Ip7IkeUSi03lI+AY3Png2CtLtICXP/bXl/zqzVySuvHxyVeWBhhjE7sVqXLaDWiC+t2uRY9Mvr6+0YgRjsWUUOBkHFg+984zHxCGO7nZgVxPmjjwo/6bTyu+v776KcFIJvHCkyR56BfQFhD0crUbg3yN0NENYTkysAIGR5IEgebzmyITSweByXopW7PThZt5xrMCMP/1I8PQYk2r/LonDv99HrZt4tmnnfecIkESu472fSKjvSgjOiBWVG0IPvrl269K6rn3ElNrnX7sbv7LNYu6G6KYWDlmWLhV0pHEYLuSCjc4sLqIERPCdEonhoYUrYtVZX1LJlNh2tW60KEHnPY4V781UabcmODX30WfXPn2ZBULDyEVXZPhyvDSSz+15J1pPtYGpLLOv7CZc5d97foLrvnsS++N31Wx30NLr3WR0s0dk/9tvP4cn7sjn3pnK+t+tejKDcuI0X+0DFWIEcyyB7c39YyPCIChAJBcZxCY2OmBli7Cqh9STI7F7zojszE0AzfdDBUtAZCd12HynY1aGxoPFMy6pS4k7hl5dzNY/WR09DrqZUeu771/8K2tmF701hs33CD6mvW/mndd56Mrn4swQ9yJpFZaY+/PF167yZF2q3raCN6InH//++8LuOMnAQ+MO/TIjZ8VZccooPmKgRVyqqic7hyfMGKUaB8e1BOm5fm0m15fp3jJ0WMDty95+8CwZJeW0FPAGdfot4ukS8sODHRfAj3av36C2ub6Aft4wccgfO70BTTkjpX7/3dRWia37nvu0s7hakkB2PZH8+en5dTVry+W9TRpvbMS0LU1X2IBQAMB4apFGEpGT2+Oi7A4tqNQPf8NSD+SNH960tP/HEHAcFQAF9cfPtafPnzSm923+APAa2SgIxrUKLAhMRQfiBxL6TwiDmzetEDB9kP9p1GAAR7egYjipmCGRCP/387GuCKKE6e0488ivTJyUImY8SEs5+0ktXKtZQG5Jo2kkqouT4ImFISj7GVnS3H52BVNxW2boDmYLTiT0/XX+FHUX/TWnoAiTLboldvrHo+8efy089qtezM9IWBSnz2cAq/MNehxBxi4pQA7TnT2cvPglQnu3eFAZAfp4OXWhvEs/pzMFzXigOXYMKKk3JIJwnAosxsw118HDLdckiDLpaNe5Y5bMNxSQYOfzKDxujgo42/mhpXQE+28/uCGWbHJQd2RGNg+DNlFRKQ46+5MeOoQB+ZEEQGrgM42wCOvXNid0rMAhMcMIIjQkwWzSxJ96biH/K7RaugLhFFjZqdrEkOM0AuipnNdIA0oiym/aeUMlgI5MNU1MmaUZMfIoB9qjZn2BVtIOW/0QHLBbgbgxlGL+ZpQ58HeDhwd09rdSd32EvuPsIPZ7tCSmsViJ/Ko33KuYrCudQE0jyVfLswsGahH4cTU/jWpkSr5S5GxbxcxfoOCxYbikt8KGqthayRBe1K1igXErdS07R+IZffm5jWUjp4ywianYYalbY6w/gw/Bpy2aWiBAbVSprjvSMOFNTsnunrS5slwL4Qd8+tD9OcadIGGCAHK8UyiHYNTc5MYP25gcaMtT8H65lh2Givq/ByJftoVaUU9KgL4kzCOw0pXZoCEAmBGSjCiSJogrBmXDjBeJCnuu4T4nBOjFgrAinSEQ2qgBIAX699a7G4Ee+zsEqoyAi0tx8shuHgmAb8IgRhASsBg4Tb/JYa2QsT1XkXv5ZMtEseIt1X8FkikORPYpONcRyokVBAx/RJELBGFP+EzAm4U7TU4lUGiG0LoQ8XGGmal2v1TcZ2bRkNdQ7V7SUHYNze5QqwvIAGXR0BuYBCWjjQlI0G8CSxMMRAAxO42AY6hNhYRBpkQW4QIu87y4vJjh4LWAmbJ7APhBVq+xJbBYjzIVQoIQawhVzDCFqvP5Salt0drAKomf1Kiqlre35TNNBFVscaiaenXhAB+WFdkLCxFa8PQoSIXgflAxYEw4yUEjP1QExiLeqRPf9wLDZnkXoKRae3D9GFWQzE9aQHEGPCOeqegVkAlGpa+ZYMSi3wo1DFBUKqG3iDlqychxROGEBW6JVBcALSvJSolesolk2LEoac80co0CSjXFrh2RdH0ynqWvWPg6KAuCnKHc0ZwH65bhF9ORQZVg8pavpsqWN21IHmr9kbEvxE7AABWUDggsBoAAFBSAJ0BKrQAvQAAAAAlN34+TKoCB/VdJ46D+In7E/2X5IqR/OPvL+2X+A9wD8QOcTlzybfG/yf+e/jj/ZP+v8bP7p+AHyM/JP+A9wD9If5r/PP1d/p//P+aX1Afrn6gP5V/L/63/d/vy+3T+Rf43+je4D9Uf8B7gH8T/i/z2fbJ/mfYA/oH9u9gL+Lfxj53ftN/un+m/yX36fgt+v/+u/zPwDfyT+Z/Pl/svwA9AD1MP4B2AH8N/Cf9S/E7+Lfhf+0PqX+MfH/1/8dv3H/y/wM/w3dA51/0Xkc+rP2X8bv3T/znw1/dfsA9E/gPqBfk38j/sv5If2j/v/6r2u/4b8RvAK0L+s/7j+s+wL6s/Lf7N/eP2p/wP7getJ+7/kB7gfUn/h+4B/Ff49/W/yV/wf/O+V/6V/qPGE+o/1r9XvgA/jv8l/vv9R/xX+q/1v/s+1H9z/0v+P/zP+b/vP/r9335z/dP9//lP3o/yf2Dfyn+W/4T+4f5b/Yf2r/2fVn///bl+3fsWfqSmnxRcWSmDBsd/7HqVHxqFcNUDLhy2GxgbRMaLRDVQR1+YVUbMAQTFLamLY1p+tMVBVXuIH+ZPGgpKlTsOEJVdl7yQcFO2SOHTLRq+2opYpzTfgCvmTxY1gkx2k60xTESNmzLI0A0wI8bqDcB7w4Mlqxvd5RV27KD+oA501Q1xXhGcTxAF0+ZO7wkQgKamuuZOmhDXl7Gv8Ibzh402gLNhpIAF4njpc+ctNTk7FITe+yU+ZO5EWIkjexCQ8+zrVymkRZUG6INLZvz+cPK/8Mq56vjo+mN3Gn7zfJF0pE+mnbRjKyTNXC1zCjXkNu9H7a/s7dV5TfcPcw8HlrwEsf+pg1i0PYkt7v52ITWRPGm38r7XwAA/v/77dvtRS19NzEwENWi1mkHdCn/ovzuFGd1qn5dZkH9oN1EuTdjzEqWtGQWToqQrSajtOfxcIQZUcOqHpGs3e3/Q+NZmsOBB5KajbYwZhpqBmgGjp55v2P9/YW6HFJlIhkWXd/9c0/lebECqSx2FQ1iUbBx2lT+INSLN8nYXVjZOKvlot2sWj46g3BE/94CE2o/5o392gJvrhdVcxe5KXayNswrUZ8+yJgWribqV7c2OupgzUZuuDtw5Ke/Yazkg7mQEiDGpWPuiZjb0d3NK9tIqVb8V1beea+VYV9vKfvgcHLx9UB6V9CUZl/0efWghVsE9PuWItDLQBbLWW1Ol5p+1K0ND3g9YDRuqc6qlqRiqsh6kNBzAPa9lkdD4Pyzjd7xUxkKlHz6F4hitJoO/ex+Vnrog63q70OUmpSgq41K8dy5SrzgJb7T2ZJeaTyP4lEI8m10SaYW1X0dA5UPKaqYQqoFT9h4Y3BbertKKusxICs7dTYnN/nAq8jLCVuv483Q5sz1GCE5dZD6tWwdvliNCR8IP4yrj+IchksbLLgBM59OgCXuk4cNSIZ2H1ui+Tg7Qxp7fqmpa6ZnnUTbhsuwytc7SxJ5lYw8HGDKqHJU2OUoqXxf1DEu63RQ9KoeVDCf3OoW9jZSuPLtVVmy0uOOO6wJaZtIOqhPxX0SSJs4+Pz45e1nvY1t1hMjZ9/huHk2cWVG0AgTozXe/3bCAimVdyn0zzA10gI/MsjhU1GG9VBvmK/ppbyf89mtV9UBPyBElMAZoSj9DVOCszGQOlICYhooN3nFoPOMWelVY/NDHoV8v2zw2hI8kvpWQpNIWrNeS16Kj+MY0jgTYJJut/Bub70IZ6HUlXph3AyNAsaAH9Dc1ZWm9JDdCaA+Hv4C41ZTTukzuvCXBwuiVRYxS8+caAPaW7ZqbviIt1Py+JYviNQtLZrzlQJQeur4AkNJBQXyqMH1kiQ3GZaooft1lVcv8hQeENtOybFkarz2WC8IuDf4TF2cwGWbSLFSaQI4ZASv3nI0V98GgGNTE9nmx3sFRVKk6ZDbeGX5IxrxzrZLDnN7suEY5IXYG+3hTTDYkf6aPLlkl9L6gfJsB9NPltu6Ctz/33OEYxXapiCXHb0ycxq6//GGO8G6QUuiTCG5JWoOxV8l5JEBIoMDjpCxXrnWyOV9Y5MGYacqOenuo/MhMQiiYLs69LfHuc54jnlwLm4FDPm+qnp9y8webpbuLmHoAuOcz0dLLFxuFde+e7c8CB6fCeI3WC9fq7Mms44RCn7AuOBsIy5xYcxLZRqf3G/nuc/2zPyOniYTV0qf9IMWA7ynruBOz1yHNXrtmLKNUp2WtvaTO2y4o4anU2EN11L5i2753g+38nMRQpAleQD5DV6MUa5t6aifUXykzhr+NixbJcbHoEP9uZ0QsGbqyeUOcpLPHF8jgtN+TYD152BAGnwZivwFe698riDmfll2CKjwb8VESWVd9cdsETsBF/uTS17i1zMyP6RyQzlGv1hmxIER5KPUK9des3TEks88rgq3HljjOz+ZS9NiibRy6LxGmESgZ4CyNFHbUaS9slUi4J4rS3XegCngC2VRZmTr+XYAJ9ukoF+fh7LqDVFh6+O7yIzgIhgffRFNCvgfSlLQmg5INf1V2Th8k4TmyZXjMz/Hlz4SomboLENN/inXEkE2GPxlHLzWNsDXlCGhSdvQHgQZRXPKEphkjLaUH+Hff5RW4lBEIa+oDaM+Gj6jXxunTGIWpKrwtIGJP7X/i8lXQwElylvcVERoigl5zOLvpF+bxMx0i8ULaUfgWazHOl/fsl7bbTPxDGtFCRVHabgMxfK/dcdhlWh+nOYJHQrWediG3pjbJtjPMPj8G3+klidw3+mTCuWPM8HcgIDM/uAtUQyRBqP0BkmAnpLbwz9TXWhlY+RCfAPGyvjFYDLE7/s0xgzX/4voDxVIPmfcSobHyr2lPXTWm9kVet9a1jHZlx4eCGXvpUztXuC76ZchrZNFiV4UmQJEiw2fo+UjZ2Ly2Gl2QDlSR+miP6+IowGGqJnclQZR/44of/iOCveMKiUVBsiiYUzbUeDTqdHQV7U05QP4Is6OxaDqj46dJoKYCnMbc6nilBCcJ9PjAsBJSeMsDqOpUbShJLsRj2FOTgVijSEWpFtElDBrfpBvzuBlxNlI0/W+6Edtt1u4o3Q04MVezNxKjGvXIAJFHH/co54N9v7cPKrCETa6apDxyvYwlJ9IA3p7W+FRc+3gyLuQ3EJfk+3CLBXZVGvT1ar0wfC1PQUha9a8mbGG1r0Qp7lkRoIHokE8/G/qulMVsP5XTGya/j3dfSccfGaZAegjkqa/b1VKjxkFDAVUJiL5MRJoHCAbi/r7p15UK7riZVVuX3lBIZA2JYkR4Dlz44I1AZDCqi+Awh7f9X6L/wqvQS/LEE05KF8OwD9wKqicilj8lpB6sMpfwppM58CTgjh0NvI081sFgKQnpY8/4lEkg1U3qMhtOHXgGUwFyRzGA7d7t+OT99uFyR0f7CHBVEgnlIx/pcjHy6/YW6IBp9/szj/V8aKNmpPmVqC/K09rFBgrY6AQs+Dzb8B1Ip5eDcdR20I+4HtNOffPRElCtqyULNFmlfIukQlZbT5fl0EaFshsDOjQMHgLzJlkXijbKqwGeMRlPhd9EEpdmGtpQ8SfMytg6cbGQlEFltzcMNSyqS/wX1qY2//WcA6t32GG14n/XhwsG/ikOlZpjCWqJixafAr+iYmkC0ODPrkUnsCqaRMYl7yTKakD5iH6coaQB88WnvCt31/5NVfne0RiBx6DrdnnjKsqaTg8QM+dbuUdtws/PfQHmfFjR4FYB7v+fbZ8ZCw+p0P1jek/TE6BmIuXu4p8PVqSFXA7ZHhzT5VxBo3yyVJY/2rxGCUWR3hk5XYNBLiAtIHz22f4/wmVNy+NORY8QFzDkVxLQ7f+UabHDm+1gl0PCqYS9p1Hx2LCxAUcvZ6VIJXucTKDRc3Henf8uVnUty05dFKiN0LLAIVB/3wrgiQuGJc/0OlT69tO8bPHHpVdNCQZ4ncwK687oY2rZwRrDgfFb3iBZntW5JrA1aWFLSaApTTnnyGYCamHGTI3//vzT//9zOAIEXJnxBj5ZKdvqpFNecz2aKBZ3cBoIwYZ6NwdHY/+pZC7D3TGZJmS2y3M0nWCCt+HL7IUQLYLB7du8tb7TRVJLcHtLSQblM9MHUOIs1+GPG4S6aE1RX5ES5O/+sUnPMeqCMxsSf/DhHgfdHs7sD6K0PLzQL0y1rktmjFRnc27fzWOsYDq1Fr65ImMJ+1x7FDFdBUTaOdCDc7hlqoKFQeG8wu70X2YH3tZKxCLOtPRbTr29xQyBsZQEtroMvR/8LnXT6nlDWfA8Gw2z/KmAFgqhwyQtp9P+FWqeoTf9OOi/PprfbMgeg/K3/6MSGp+iXDDZKHrbL6/Ln0XGJQ9zA25uh5B7f9RkqGcRqIdYVMfnF3XbYlZ0ara2Gxq5D3GFgnZmRgkpKn5At3hkPLY3iM67lYREbRzLDEhH6oD9gW2tBLIpTIu9fXYr8gfJnsQpd/2NTVD9rxQ/iOdaPqKobQynYAE3E6OII6r855IZNOh8sOZaH9Sln1VDui9irOxm0LyVjRXPbKz1eZwkqlSHz28k1MFQKsfE+vpvY00HhU3xXsdzzjng7I+veGF+BflmmvyATDnX0cKDyKBUW+ajXTeclRB8bBVZwzZqU1+M6sOxJAdlewOaSPxPdVDpYy5o/Prir3SlNF1Z/0Jd/QuIG6F7EisDC6gs+t0mxHQjnD4QOdTWXIdyBnn//7AoBQpOXdKQ1YWGmF+2LBMTA9sZvbnkg9nFF/fi/+jY+nEd89Aks0Y1grv1JutPYfPqqCtxuAE1yL/XRMNTdUB6gw3Ri5+qtgVUU827x8K/n9RmXXxZgfRSZx7AgSu32SC6yHuQrEq7m0ISR54bdt4Z7pUBFtBlqXmmfXMNaWmwMIZX71FEb20m1DpQB4LAQGd9eY8r8t+GINf2VsJIMHf8L8STuQQxKljkA75tJHtC9WxmD85xgTz8QSpadoqS1oLjoI2JP/IgBNxsUwv+7+NR0vjigW/IpoNCOib6fUt8uM4cY/2dlGbGwQjd8ZuPzln2v6wBcfOtzyALAL63RYvpFqYjlqvDIh/RtuLSiUXO+uouQ66EO+L7GeFd8oeMDM7O9V5Sj+GjDItNjV9j6LTfg2dwH0vyAgX+T3TqlWvjMrR3fkWOjoIEOSw10BsvtELRXU5xZqw+PYz4MF9aZGZka9yiHxkTM4F4BLsRfkQ+WfRog0Xaxnx17fe5SBoBlnlpdIXId/uYW9hVmK3msb/HiaK923Ly9BHrUwj0Tja+MGAPIZ5Kq5jUYQQPM65o57vnCgBZqzWy+T24Wn6sSI6raXiUfO77lEjBg78a2x31RccNzGUTtmz/Eo0Q6T3NsTuiwGo7Lsh+ltH1nuRH4r1BCWL/4KcQAqnR6nXurUjgetcHBI4NSrlt/CsRdllMCluwjR4SxQeTQh5jSIziVBqNg3J7/xAsvi5kZz1W0RqqHwPUeVdgnNqZkB37FrrwC1IR+WsGcyy3rzpwi6H1FqI4Yem60WlVHhD1mXzc7eEwCOZlh1maV7gJ8uvj4tJw+EY9AocWe92oQ+uOqGRxD7ERl6jVPPkUsUPi+gaJUc3NZFN8TrE1WligWpD1rxTZMdz+7wjZ45WLuVX0sEMcWVpuQzKy/qYKfP6BIPFkx0mthcZfHuvTMb8kgPn5e7U9rcqPbDMk2DF9XQTXkl6NLwCxOYE1npziFhUgGju0mOHIxBc+NDfjOuvOzncPUUt9Ea75Lg88XT6Cg1hfnNMzzZujgmIHKEf71NWuVm4QQc61FrtGKPRSGv/fo3nFz2xxAxBjDiJaBwCV2bERhSM17BClLZc9o4HQkkwAeQ0rtsgWx43ce81z6qRJyoMWTgmgAWNdcvU5Q7ucZxILeHgPLV/4vM2FDtwzOQ+9Xg0DG3kh1cZUrRiYMpuTDmpy/+91TqpzoGTvTVgsACopBCy8+bmf2v3TOn9OWVUBk5MAItB+P4YhDx/qQuL9kCyAUCJDYeUMZ7F+6XDGbmDPg7bR8oZ5OUdq7l7pISRj2646GDMvPyyNQT0WKll7+9xa9nSaJ/wgQYuocZej20DXGmT+p38IPIAqeDUs0YIdvhqQ4pY73hZ6JDA1P/UtCgJ0dLpki2rr2OP/O6m5ZmjplVO/9nkbtg1cElCd0+7qqN0CjzrDpf8LX7TIOuGty/9isQR2F0ZlZ2WuUp1JATGSMLM6GSr1bRlX3gB2kGEIFi1mTtiYS3rswy2h5eXgR24HArdNQKADOmvKEfvZ3Pia9zUmroOrkAEpjwmHErYwWZ34AKQ810G/6Tm6xLmS9TdSGIPQAVuVJCmthM92IsQAB2xI7Ef/mN+es8CWrGQEtRvT+CkT71OobInxbmJE+1+XdU2QtDfCRaq/AWlQ5zXG/p7puqUyhIbdx4EYgZFcOkXd6/pH5AVEXn/KDubz7GdlnWHKywEd3sx3Olf3ezu+pXUr1UcQe6IxQgcnB2QILPTuElqyVmiTBaKvDWNX/u6IMNpNCnM9e/DFLJi4UZXTJIuhyVyBjC+ur3aNthz1FLuklPKXrBUoV3lGHOBH+ZThb+wnrMshb0RJM4/IAP6IweGb4RGKH8FdVftAA7ppnRL4XOIULVHf7Q1Z0He6YF4c/+e3Dw7vm5BJIfRl6jCpPxKj8/FW2BUjmLzIV1rOYtddaenD/bJfRej2tPD3r1BGAypvy2LFmSZ435OpZNhOx4ly5NzhJVho3L3JCoUDY18OWK7t/VU2CMb5VKX8UZhQ1ONpfKhKW+GjbU3W+j1Z2LBKkArkFrkAWs/jRqt9E6OrO6FsNx3xUPTv3UQX0Nu0CuMiZSxaUqrrZeGiNs7UgMasEBdqsSEs/4P9ol9uxPQcBsuQOWfNchdPqtXF4D3c3yJnDPYV/6MdhKLkBJPl/dUWpyxnW50BqRbIhHJgLrEwNIBMzondOiYGMi9Y0sAbtDhhgoXcOjM6gQZrNC5viJMun/UpCLvBe916VITDeoU2oQim8PnAZpHGNSkK1HthCR0NH7Ds33V0nRr9+UjgAEci3AFK0bm3e3/6rSIzKC6Dv3bVgI7mS9764+aegEwJnVLdnUKUG4gsfAEuamEgS+/gknV13urc9tXkpv/0RLZWrn0FzZhzbAKoMlhiLbrMt9Ffr4H8x5QYnhkaeOeGASHTBy8xSNZzB56H8Ebe63wXlLOcHICshn19D0gYjdxmSuh77Zwr2TD/stjL0l1okUG5kgqAjeSMmvavZGq51UrQV7t+LBriL7HzobTx6V41VGFr4gdqQ06MOFNalfgzvw0MpiItTUWZvr9SmTVoy4TNDgsR+U3bWCh4wvpTxgP96g0GJcSPC1AZ8DnbhfqdKHbG5ttysO8TGkjtzCcBc3ulMFJdunIYZrK37Z6V8x73+tRN6uxFVrUp5jQtmZqWdqYsOPX0y6wsgGiX4X2WCUFAJHte8o7Nw7aQd8CaIjO7AfWx4Euf2jyx/Ly9kErXgLcvV2TJDPY62QjZxPC07cUtwxfvtn8smmMrOIfRU953LzkEuQB0rfbV2ezAqp7r4O+lDTWhHyXNitYtU1/tnlGxfCzljJRErd7w7zcJ4sgfIirI9eH6+beN9QucnUhbKy/fzcsOIQn31XEr37JgQhNpkXIUjV1AuedJX/9V1XdXdDHDBdezqZ68YaEQc8gS8+taBALf8qWH/L+wQReKNWwzqASLKRVpDwFe55Q/aMFbNAj7aox+Ii6Yrk8lH1N374jX5W2uWK/7Xv0ylCEQ5UslP6C28+dMvZrvC349LAKnfUX/aAd/8XhesQOVPZtgEtmut4KoRHfWbtJE6+6nX2AOWqCUYns+2Y1fkSV6x+4c/2pl4sO7HbtigYAl74Rj32cgTl3Dtym2k0qffldywF3N1pbwfbORlp7sc1+6nK738GM6lFRvOY3Zd8yp4ROeB4L/JsgswhoL/zQsSgjp5FTrr5N5QeSZuZ7HRLJd2ywnKrgAR8NAvdRpshcmY8Jg92rfXkgv3C+9u9FLk3W7iGwDzU3VvJIGRh9GpBR5R8TdHJfgecInf2twSsZb/QBbZuxheXU1YO2Me74o3gk+zF3aK/qjICOVGDuq8e2dDAgJgU0+GkHxB76JXcI1oAra8DliaoFyfn5csNZpVcIo9NDRG6PTA60RTx/MtLIoTan5CBAMiMl18/tb/Cd2SjSOBMaBpLgogT30hTHvDo2RmL6ubzZgatpgqVRBDUF63J5BxhW9fBtrET6N+cP/3p5VavJ2AKO9T5OnbF7XQufRUJI5hEjn9PZPMXVzfyZ0ZhKheIygT0svhS2nYTv72hV0iH8Nd/vnYmypa3iY8VtrvuYYRgbW2VxackMaEhdJfIql8fsDL8/zXYnL+y5FKI6lYLtMb2ZHvcucr02RqLTqrDE/9W+mJdWvxlQAaHiCVjqtbcLYKmwmOYOneC60VxXPLLObhVdnQaNeIVauAIMifrL26crkSdh+ItCfHpwItVK1//qh98L3on6XsNuM5fkrOpSpCZkIt8nSSni6KVs5crXqg/ooEBZXhcmggTeWeGvuRHEv4Wwg9543cE4RtK4aI5dAmFkmvrAqvr/Gc8H6PTdLLbc8BkT8xO4+kbuQAVgEG2j03E8GjgHsZNf29xUjlxd9tLAJoe2FLL+zgxxDhZV5hi/4a5fWLYVnwIqHuZx6jt7IhvIFiO6IDoSQuWip6VeANUhT1JDWs4sTgFZEt8niDC0Uqdm5i3APAbzKRNJa4w54DNz9P9UAf9/BFt7ZA8Rvc2o7SrmuKJvU+U3WkB6++Q3knBsp8JGDTjsNvGQpiQUeaTYeTg0BYIVKcy+77VWq3nsdsHF3MjbgABXKO1LUIzGuAk2ZoAXT53JEOF9bGa51hZ/QNSgWsjCJY9gGjwnZ1cTcgmO4m7AoOHbwK1GZFheVnlT+kBk77eJxEVNbb4WNlp9D0FhPw+OsOtqtTc9jMJ1/qfTzD/iR7SERy+crJgAVJ9pB3L+89QQpdoFpqBBctHsmz9JsN3Xpt0I38rEofyz4wYvniUJOrsgvIEAMNxyU6TBZ8dOP0/OvuqzWOqm7VSLyqB0NprvbWk2XrVKeJnyIV0nO1Fk1An9irmqRZOhs8AAAAA=",
  "data:image/webp;base64,UklGRgojAABXRUJQVlA4WAoAAAAQAAAAswAAvAAAQUxQSIAIAAABGTJpG9p39S95GiL6H1AFU88eU46Ctm2YlD/st0GIiAkA4X8uyW0kSZLMq/7/4+7QId0966TeZyImwIEkSW0jgo69u2UdAfsHlrf/MyTZ+v4iy9W2j23btv0P+HJ5t1re5+5s2/ax0bcxZmPaOoWuyvh9n2cyIqpXtY4IB27bONL2TRshmZtt94KMn+oiwQmf2nzuhEQNoS9rKCqSb05pjh4Slu5QCKHGoER20hPRpQkBfhklVO+EwgsR+pHEZQiEQ6CrcnKJvwQgkribE0IMHoAbj/7qYWyyIAQI3CPjxqNAUSZawmlsSEBEoI6OQjGBLua4XEaQQGicjBj3B0VAm6ajICC2MhCRFUgAhYGnd0OSUG5y7Ag1Rc/EVZc3V1Q00yZV6GqFIoAAhB8JGE4fEOKFE1K8U++oFAw+2CBMJooIxR2cHA53CEMBhq7QMWHctBlq5HTDxM4+zAkPqQ2wiGNnRRg4FeCpOTolbAyhK0jcxaGQ2z77w+/3/C7Jx+vWVCA2ddvom1PWCJhuqVaivHnCdSEKvH6ZMHryXZcMv//OuzNgHEUHHo4Cn2zxxiFPpvKvmSsuvviSSzLv/70qpqBpATaJJmNDNxEG+/7y4eLFF198wSVaMYgSR3+OykWtBAkBI+TWhx++H194fufQcMERTrFeI45ajEDERJCVf0JjaUIiSjxY/UohIpExYo7LkbipGA+jlKI0kbiL4+oeQNp6VhaGlkWaVXhAzste+Nn3JxJSbOKt8tSV4xN7ICAI87ApckLF63bRaY+yPj0xcSRRR5mK5MrPP3fh+aedD2yusYm++o6nfh4Vzjrn7BNGNVlKaJbqR0Drme27oVu23mKMT2xhIs8V0tBKiQ6EJHDnA+1OA5t/+nPzk9CTXvuMbKc/rkiu5YmvvtylSKXTb0CJE/V/fx09r3B46oYbTwQCxyJKyAhk5H1e/yVxCOIPucmRe3tOfP7+/oI5brLw1+lmOEyRDsCuLxtjAKgHgp4Ov2cNvh8sVwY2YHB0kqAL0bdcA6bXi9kbnRyB4LRnX/mZi7TOo5V+4kmRMRCkcdPZH0XAMIM47wERihDQE4kVVVuCD/4vEhEncYeDceRu4z9M+9cF63i4ZTJkQArCFrDqxMkJ4QZlkKEhRasLNwWEKRDwiqSfIXPthZ2p9f+8HWaC2gyZZ/65fN29APqf/NqE12deGmHcftGnXm7Rf7+Gq245jffcgFTUX+6/6VbwyicxxEW/r4qtvJ5d/NuTrr0gnT0ZnP6AuyKf/AatHP1Zqrs1jY152yBHcouaUpclsVVA8pzBhgBas5Li5seTJyB0VYuaLkyLALfedux/0wbAFXf/8WV0OX6QcuDJYy9PA5u2pfnp6Cv1/wP9jy2+vMcwCvREv/OG3Tt+9vWDD9tIjzLCDAkV0tlOf+P0q0fj9z8KlN0qnz7B61+pANzz3ZS14IFxh5yzvBwZgqjrDrSKpzs2y8uvo/NyNHbpxHjAjdjPCYdzc9YkCK0nd/HAkGQXdtINOnf4yIJT6ZCVHThzaHT0Wtk+cjgfkArGHPhRbuTEE/pPpf+GIhzJ6odeltzI2GixRoRqqe4Dqc2vqomd0u+JAobmpkvMAOgQEKGzZinGCIEzb37rdc0Nwzl9c7N1EFC30oarAlg8N+LSzMyCpVUPxWnMQDaomHxlbKT3EtTnrHMtO7Bp85oEWx9GZmB0uH/ETU5xY3BToo7rsXeRGhwsLCNCcvfu1TM+SiphuW8nqca7lnkgerwE2T5YmSEcioXJr/RdLcsfzLLJ/uFMLbpuWfxgPmGAIOzP41sX9t42/96Sd2+mRwScc15az9z721PO779r4p0pBnazRllRk9K9vznlnPkAkR2kk7888dJdk4Td/ds64oAiC+vlvb+J4wTBoglKApmJyyLOb4c+jlssnYvXYGFzFZm27U0SqyIzEqZv7RA5tHahcOnleqDL0SM9tWVrsW0M1c227lOmhyA7i8jq/r1tt5iJlbHTsgmOlcFgG+ACz4awfCFUFxyQLktuptnxM7IbU1vntNcOLDTDWKBTw71/MQK8641RiGF6QVQ6fkYCwyoOCI6TeJ5vA5kdaLxe2H/Gof2GKBPfgeL6BimgyUQMwM1HFQegeKrEa+srZajVcCd1KwuHult7RLaX0fQ0pPiF3NxtMl1dnfkBUnks8XYmWVswyHV0ZEpN8i9FoVGgMk94Yige+b2ksRm2RhLuGQhv8kDsUgkODFZmthOGnqHZxUBAjsNNSzrffdHyTBVgIc8FBtRSk6CFrguW5qpqDVpnWNQurg/2dZ5bzmiZhggBCi3rR1P9fVn5eMljMUO8SKsHKmA8K0V7fI/RIIeZ8ooRIXQLznpY8coOGnNQdmQEIZd/zcp31VctQDAA4+UkxckMM+3C5RUNP91ZORnqd1Ztqvvk1VWqRyM4YyqK7PpWV2t3vLKu5RA8PJNAR6+yfXM211XoXV/A8MJt/0toTSxiVOeyXWuMUPzziVyV1p71TQCVmYCJ3wGJ3DokgYJHOO51pEFBoegjYNqieonZjC2Drap5vGuw6TeQWlwkdMHVGkbltVpJF3PlOJMubNjxQ/yhSWu1lJVaPaf0FIDcwiCsMtshMXNgXGbgEiN29w/qq0WxZeYjW7UOiOEX1/FlAxCU/Th2KOhfwFydvyK8QC+W+Dp4gptYJcOtNCHptIjW6gGVX8nWkEqRykzFSu5vyJTJWmpcRyptAEBv6JzX0pEwlhSMjQMmchYodWMMFFAqo1dDao0hgKgXW7UwAGD2qlLcSJpY0PH1z7sLagmUQFpoOaAEwjTHaAhcf4FGBnavKsU78i1g9kqXJS7KFAC9cblLvUsQNe6GkKsvotC7uZbygoCAqfFCoO+lCrpHQfJmn4T4b0QJVlA4IGQaAADwUgCdASq0AL0AAAAAJTd+PkyqAgf1XSr+jfh/+yX9l+SKkf0P7mftd/g/dm5BOMP8V5tvjn5X/SP7X+wn92/6nxs/xn4Z/Iz8j/4b3AP0x/nP9V/s39X/qvxVeoD9W/8b7AP5b/Nv6t/ffv4+2r+Yf6P+ue4D9Tv8f7gH8W/j/z5fa9/sfYA/nn+U9gL+I/yD56vtL/uP+m/yP36fgt+v/+9/zPwDfyT+Yfc/++P2AegB6l/8A/oXaAfw38J/1L8T/4v+FX7T+pP4z8b/Z/6x+wf9x/4n+Q+ED9p7k/L/+08j31i+wf2/9cf7j/y/9n8i/4vwT+Ff9V9gHyBflf8b/sn5Ifu1/nfZj/gPxm8ArUv7H/xPUC9cfl/9n/Kj+/f9r/keu1+3fjv7gfUz/a+4B/Ff5J/Yf6z+yn99+CP7t/o/Fa+l/3r9gPgA/jf8f/wf9H/xH+s/z//q+1n9n/1H+P/af/Nf+r3ifO3+3/wv7pf5b7Bv5V/Mf7//aP8f/sP7h/6vqt///tv/aT2Pf1S+9lO0Ci4slMGDY7/2PUqPjUK4aoGXDlsNjA2iY0WiGqgjr8wqo2YAglutsv+xrT+dT41DewaZH+w4K7jpU7DhCVXXnsJ5TJTf5sjMmFXuwTxEg927xj5k0zPmeFX35z5vys8fi5X2V4QHQkiS07aLerGBwmx5Ldslpt8hIaYW+KWj5yUmNNn/NqPtp6Sj8fum0LLy5e9mmQb9SnzJ3lskq0rOmqqxceirOsHImewvwN1k8aYfa7qY5boHV83GzoBExVT/LY2QpWDJ4vtQlTX5VV6Mfc20dGKRzPPYXd9p20XB67DI9CqySfiqIRQfiQi08iNfG86fMnHgYpdbMTWtaMh3O+7+dVIzvGm0VISTlwAA/v/77dvtRS16tuCfWZqYlelsbni/0X53CqELyNLXhUNnoSLKusOh9G+pX3lYZL1Hb1GT2btJZHMnJt4uO2Wkkl/hfI6SeArnz80Ne2PaqMhLujxHOLAoi/aG64FHLDnxTCAT5Lcf65uqBig9QWgoN4v/M8tEPRW3+rhBiZetigYjUyrAJF4Bdp4IkJzj7/7wGNwJPqe0hCTBFEmaH8Fi+gq0TqQ0bIvOXTy91PsbypoL34eIBYE0fJeNsWB/WAFMeJZ2B9GkHlNcYIIbYre+tVRU8UE4a5DWFbsu/wnapBK03YniVXftaOH+5MR/4eSYLH8JzpBIqF0bg82T44Fw/dL/wY8oo7s35RQKxm61u99qu+pEd9v3I/W5VAPDsF5mgf14RY9FMheZAoVNxqQtUhurjlWZLDk91/oYCAEgVEpBKDHoWMh+2RkaaT2UahEvIgHo6ZJErG6chrWPVyluC9tJ59kIuueMimSBkFCzo9N1gyCUuTff5wK0WDXhN3Q9ieji9Bdpeg4VMi2aoiv1Jzo9Iohi37vB/QK3gQn9Q7i7LPa/jfuIGxU2JUibej5FjmtJI6RXX8/o0URNM5vdcGThiDW5tzIj73hPg5z+SvlNvJnLidYe2OBoo1IKyB19s3rz7XV1q4VNTCKgMPrsD+deIE2EZSfyT0JyjSutCuEsbqGxBh2Fpnl0Ft6xzT/ZwIRfENLGwoHAUqelzalrwwKJ0PP7Azxrhcus7xO7slu/pfffYIqEMf+UZq38tAYA9//ls9PeSKoxHSRh95p+y2Vtln6m5HC1qRA96K1uOMt/0Gfj2lV3wlzimS2tq5b/tObRevIecJyA/27gM/R6Q9zbpCwEhDdaIxh8FZqMLWM1qAnB71+hbOO9cycyUB8pkZkqV3/KhgT4ANWYYzK7o6Yr8lGdEBfDH4VKhR+Nt8r8QVom50a3jWjlLOcJ9uXhdq4XuXBN1j/1VKhlXz8eiuvIX2CLIXeevUKAsMtF1XHu/srRbm4fIby7QsyBKnlEWmPP+PRnv16NLEF9Y+sy/ytkUWSF44yj+Cjud7t5AuO7RK6IOXW7KS6VREE0BwcfXywLIqoRem6JCoWV4MlXndolADM5MKVMzKKV2VQYeyaiRBdbsh4UKr+aNLgAaPaGnkDnK63OapdzHy89dNYz5YqZ9NyHDxa/xvWnSysq/Xx2D4bdDzqcg+NejN+BDBjBHj0Oo02bCgMYEjK1C/xZ0Gl9ZeUDcpgrk1JKjatH4KCZiDnmwsNvKmMZBCwz4vVBnRHHKBsuM0qLCSYWn31Qam3ozLvGSk7XnvVdTtzdoGAufs5aCHtRSWo9NzU22ppZDSQhpbsb4Gyd6qzDtbvFWLOpkN9uIDcdAAe/eD/XTWm+l2154VPj/4wBSZ8UiNvj1eis28raIKx0xjIVaArkrmyRIdkp7zd4CEbW00Y+oc6Zj/641CkZFQUSSHtIEsZR6ZX1gsiis5T9nkX67F4coyFR/VqWMin4rLwN5nYk9wTEtv1AxmrP6aFSbmy5qEnhCRTeMkNEMhodY0doMC2ePQh3j9v1kyEwN8vaI4DWINjBB+WcWqGAB4ldIfl09DiQ8XjJN7t52RUmU1MCyvzyqbFvuUMIqoMQnXJXy/yas1vTGqjFHYRKT3k7y8pCrLLW+bn2ST3z3QnGSU+pwWIVsLhsHM2+zBXIoRc7pje908LwbkPh43Oiyi/sQxfKXbAaf8mY5DdSG5RD2sAw3BTKPGrLg31CYSjzdbObdjw0f/amMahcNKAUHhowYTNHBrjkxYHD3dL2KrnuOvSzHiXV2bqqhGpbHvPSNERJaf8zgAZ5ZiPtjrQKRaPjQFB8UkDd8yxSCvBLtv6eRgpeNe5lLnbZiJyvIShwR62TaKG8Oy8PtpZz/8qRZ0ULjXiKT+F0cG1DNM3VDucM6MosOsiSAdNh0w6WqAogEPtEenC9fRH284Cv5Jd9RW4yGCO72jfwDvvFfrBOA8AEvO9UVaG2FhuussGS5vqMTypb/wSiq5owCfM+ZRwMVKucFh9cvSWR50d1PZZZ9vbjPz6yjeBvB3AnY1nPVTOIeG1/jFuqrRXVbxIL01+EQl5+81UtfbGt8wvIOfXq5oCzdPIGTe8m2awMsrVz0htjNW0eN4YdoT/1IBpQtjehhdBouZNrC2PEgci+TOCh4+loc/+Hh46HqFP9opoCFpndFu700KAhp3BeF3UGEaUFttCRm8XcyjXmHaHEGmZQMEO3/Jkf27vBC4XDHjSmNMWnXuou2xFxqj6Ey1Uc98jVSPnNSTIEXFdl/XEIBCTTnV5q8MTIFd8GxecVPeS5uSmX7JI7Cw12IF9Eg0ga8Fn65y/iCUc7tGcn17BzfeMiMGZ8EUypJUpUY2AZQXAtNDIiE5bZ2VJQII6VUCJAYstuXEj+4EGTJ1bhl4ZgVlvg0Zb8x3X0XF1NQYuFAuXSo/HGTZzwKQUB/jYxIFnUu+YgAxFNOLLCNLmZJf1X+SIFtXFqwtWp/AbJI56iRkcoSr7Riw6nUvGNjY90azJK/QRmCM2+dLZRtzkHIVi2JCmpwQb7K+r8umMGLb1M7vr5eW3Rxh8eGjFapV20A36QmREr/IvlifSfoHRldCK0qgBM0NJpaO2agHRmVTJI6q7m3JL0f36p1sCQPO5PioNXvCZtUtLoZLwPI8hk0NWJzhO72xp1IiSmdOynCuKjkp5TYg7OZ/9d4rf4smTBoXxIRP6SYXTvHWhmri4jQ0g/1ri0/Awgbe0qmsxoTTsRIDu92KZqNIHFzb8e59SYozGxhqaCq1kKdMyQP3oHpNs6UbDn0xxFhG/Rb6G+EXkv55yL9zYF2oZTVLePtZDVv5iow3kG78vQp3q7PDYRD8Hc0j4gattpI55ID4f8BY0GdJwsr3sWi1KVj2n8AUxXBsZdYGWAL4AcrSSd2hEXVBJOHafC+AnRDdYPEND0tq97DM+ktHXWmUvNwOGfkMUPw1gDx6QL0bNccsw6Gozctec0rY3H2WgV6JkXbliGXUybuFGvNQRlFJyMRtHp2zx194h/pvu82tqiIgASL2ChSInG///780///czgCBFyZ9mObLCyNxn2V1TuK4f9fpYlzdwScLstj430E3SvRlHd/Qyer0kRvVeWqdTh5hIi6Agt1r3uFZ+NReaHuSf1O4xbfwjxj2sPjJ4onIeiXqGtSUDfIakuikqwZUAWsZsszKcaMBqO8Of/kydbGcL8JNAbY0mLIQQeRPLEBKja5f8A6z5/NWK9l/IS/xHXvQSXP5YMc1KVo4vlwHmCAV8dHLcGwlkcQQMv0Rfi3lnCs3Kfx8wTMTKGeUxvG6fIfBlRdu2n3TH1T+pzkovKje4+n729TVxnZOIjrHTa0OEVUVfvmIYTf979fmuCHubpH87y85K1Z2Zfckj+XrAeIrdT3qFuc5fAHuc++yn8+UU6VyFzvyNj6LM/DLA9I0eqAFIXNdkUHi7sHIXp8l9KPMoCrQdphP7NwTf2HXk2kz7EqGho0TwdO2F03i+GMEUoB7edM2RHWYHpVdCbDeP5utvnnjDogHlYXMuqT79JhW1AL6z0tMP9gb/ocB7MRJsIVdCdzt+Avpk8fpDGu3giDrZiuD05asm3rhzkx1I8c1vJXDx7gPIiNXwoEFxekrQNuXXLVDD3UfHCKzimXZWqNOLOYahuhuUj/vc8xg9js0UfOjcNA8/IXK8Cd6Y8IqA/n0LYJKtlJnMhhjIrx5n6Y36wKM1x/7L1///YFAZsOA37dDRp23uradt2wgLMqbvdYpv62yItF9rlch3SSfuJ/uMc2+l1B4TOIocH6ruPQOE/sfmTev5lGay8exl99+5qg4Fyu6ZhpQGVZquH7GmVNGF8fzluQ1WrvlqX5ZOs84l81t/hFIngKYG0reAsaxgAM9YwYjwtaXyYJbk9b+U4j7TzujZabGxd+xhCVWHmM8tbnSjuLua8S0L/v/0r7G05Xc0AvJpj0wu+LrDOsbFXtkF6ojCwC/bfmUbry27EZm20hRtpngs8Zd+tJM5gNv67avXLC8n/pHSxJft+ZkVBXHFkh2FdMazphRBw+OZNUeeS5KvRk27kqB+fJ4MUnQu+Ll1gj1ocejytONn0d8KnAqq9V0pG6aKSoopMqJ01C4cAdl/cvURQYElMLjan4441I7rwr3Kehh0qzsIVimFXa9plnJUjagJCKkGy2DlAFWiKfPOiD7ZlwHs5P3IDXaxE/oxq2rkfSAJrdnz46piwNwXH4pR2Q3mRMiZQIS8+NIc9g9WxjBfIonUVBz3ZP3Aj9dOrKhNeujYH+ZVYb4/+E7reZRDQiy16SuG1y273cUSr5vD7Q9QdriJQKMlNWqzGc7LlB4wn8iZalIeCaBke1yA4HZJUDRX4ne69cKbrjzLtqPodUAJCCNJfPJbHDaXcMSjqT8N6l2zJujOTM3o9JlaX45G9Ra6KeSYGL+Y1/qQlO92qEw+0t3hsc3/31T4fzf57nqAEJuo6z68GilSLk+Ssy9/VR6YRqZtV5ioQBE+Z+nECUKOkCe77AmxMYDWY6kZkbF/2pl0jXs+bhTkk3BRP06BduslqS1mvdWSaSoB0AgfWxDx9llA1JsHIyVMuZ7+2IrAYmRJJuhjNXX+cNFVYKbxEv3+vMF79I3yrtDqVLefCJKIDfIhzCbCvUrw9yDkzCfkHMfyXUQpdZQ5G5dla6PVXxIYt/JqVfTbx2GIwLDzAStCjrPwvmJ8+Gf9m3/Og8g3PBXsfHYo4jqNauMv1NGOaC0/uC4Q5koFHuY4EKopywIkzNFot2c2lBY3u5hsR/1JVmPutRTWUfmIeF0qVzRAjhwSjtGxnRrSQqe/5X1uuJ3bjddsm53xgKkNhheoZ0Gt4HGpXtCqRs9Lv0LY1WW6tQdzTsfOewb1opT3tvWT8MG33En7s7Ef+K4yyVAMp6uX6qTOiQj9ZRLv4KYE14T92ew0yEnbx50qKnHYM3A9kgs+vE+J7txYq5OB5z6sfyRt5huEUYmIYEagdq2ykT54vqWSU6Jl5kZFfrCd1oJlXJnTs9VLpICUIN4zpU2EH6RtnX6xjwkXrCEZjPKTJTLfa77+iHDQRAuTHGKPKGWFRIb6Nks/KFaq6Ki64jAgJ3kSaiJHmzKC4RwciNsBBFm2BVSV0Vf+d1DkU/7gOfsXzryEAvGdYwlad1YMRjVHaT+UU//CH1MCsM5pPS9scZuHzv8rmNca5zh6R8HWJzIMTGXuhRAp035bIGda5mDJI0V6XIJkSGg7sWjQwc5VNL/PeeVGOTfzqL3SurYDIaD/4BfgMEZUYnetpfUacjMfbIoJJOcfSgiSM4U49FF7I0fcqhZO3ZNGzc4h/NnJnCyfis+dR2CSAhQKu9FlXTGXPJn2bIq8N/NMhYCmh7+aK9gCecXaAs8co3H5LtHoEf96R6URx9hN23pOIFcOpP/yUfpjnjgBPmAhQ923ehWSk68c4KsNO/mnqa2DtD/aISP8XD9EXUnVQ5S0P541dDSZ5Z/NrqE4TE9Fg1OtY789Ff7ZAia4bRMslJCjvwJLJ0H55iHZZIWhtIE7N9vQwbVQx613VrbCaD9AuSkMM0KJQHYe4o2Pb1L96ZgUNwBGadElwc5uXaor30YUhuptNDYbjvf/PbjPSzhsZeo1vb8jrMKsr/vMxOORqVkp1LW+VesrPmYHt3l6lmTQ4qo1oVRlZcIqNXGx4yekysuqcFqFIdqK11TwdF4zSPW906t2sEPQvHrliSB5V9YNqfZwXgboPJ/Pb4pgUr046K+OXCYlaMJQyjChzEuAUQb/qwT7vIEh6drmMu/DPdmJqYrjkWC9bRm8/+MoVmvBghLUrYXVqjT4GrwW1Gim7oOwRHpMm6ED6b2hv1LIMmBbCdRrxf5Y6MvMjLhxvAbsj1PVlK0Jw9uJZtW7STozPrwRneR4pAFCoiqCKoknQtU97MP1ssFa0v7mdDLXhlLEH4TmKhvNTmCdjriAfC1YuaVLiLak4o0/JcNp6VrRWU3KjDWh3OW2s4dhtyL4+r7qCRXn0N1J8fMkIV9mR2ni3T47dgwZLoxiloYe9nG3SW95DfdWI70wzpHqvHiMWslxK2tjzhKkZGMrunMeUfh14DQw4YH4SENRTdxdHGp3MJ3MSLPIuEgc0WtewF5XgKd/qeBUXxoJVs6gD/Tul2biqy7KeL+BwQ3NOyl9cpLICRVmBXwsgiDCZoVbADF9uZdSs72Fb9TRF9EnlfzsZj3wWpInFyYZM4Ck/nHSIYb4Mt68AU79eh4v0WPXP0ojOpNk/K9JQyj7+89uTrPCJLhV6PboiTN+RLgLCXoyyueRR7pnRPCWrQqvQyzzzJrl2dT7iY5LYKEiWi3qGCR06piFaG0o1+HbuOSVvI4qCSngNaTBbd6BCfFW/hnOvZH2K1Kqk2g8jJxNSq6VqHUMptpD9mVClJKrDDMfzvdAF2m4idVeOEGr7HU+dEYQVfuB78MEBb7odK5PtCuqUjX40pp0wkcSjmyA9+ZqC1o+ho0/7vOT2s3F9bTWGVNJiGDTunRR/iiX4HsHnt9ROBrkEdi6rzKvAFjpnZv98VfEuVzrGTUuNEZl1cE1xr+/tmDVWnuUqSsNc6rGqXGTnJ3th7kjgL4EUbhOQjbuZ7Q92tVXn4xAUBtpOV4cTEZwYAtAHPWNXi1Poy1/umvPdFxivSrOyJBvgW6Uo36vuapXEbeB8t6PlwEP0tKhIPEoogu1UZu/3DUAHM8QkrDXAQYUokgOM/kfw7sxtdGaWlddvYhYZ8nHhugAjCASpKvF2BEHm4TT9CDPkY1r0FYdAwMWmTToMggQ2reE7XHCeWnEOVb01KSV+g4yTemicC4PjElzEvYBVCi5GHu1CCIrbuRoFXhkQGxGB+A1hxdwbI2LA8ZI/MnX2Opp8HzY6i5AVigavceMHdl/D/y2gPQBxLpzVBsIGOSkcQPAQvGgPVdC13e2WEzfXi69L3KXdqHBrxzZDdp7Kv/bbnsgPCyhst+1gzvaQ5xrz3y/iuqWZ3ALG1+MJEpRLsF91MMPmhb5s6zerwOEgrLpU5JOcwHI2siCj71V41nctGKZmQSCUapfxmc7F3TAtnpuDMhV3AHqgR+czExrTD9wWvvecf88QTWMslKzzjSKUEdURzGxptxpE/YkTAhLfBJWxPPx5oD4n6dDAWaKQH2mODUwm7yOEBCtd8+oB0so09CMtexq31dR7HTprU1WQaXbuC1ta3ISr8xSqXvnymHD1ARvtkLNfV1t82Z/0tUnmXWHKk0p18x7wYbOPIL1cE30pFuTYqxj4xJtl99hzptBw6XfuDmavDqLteL+n7GeYkGMja4QIl0Eh9OosPATxxIHVK+C6lhCf4HFrXxLgQX9aWDfq2bQMQN5wwR1HBO1Stls6BhYZ8ZhwJSFvF6bdTTC7AN1IUYEyHr3L6K2cKkwLm8OLnT9ylyGs9mRy8VoiX80ec8qf07nU9RHhiO/5ipQ6ko70egIe4GnOBGmEtl/1SmcA2EFtFUM2Xo9FPD2r4YQlnYVNJGPbWp9r8vamnLJ7bJLgaxkk4yA9pXBfZEMCQNBIEGfygfxZdONmHq1mQeBotGwxK+5qfwuRN7a9mlSxbG7IdDO6d+aLsb/H0DnARLwBDtJ92dNmBYTrof5ZTdKt99cZr17D2d7QJQ+C5dO95DoIwEJ7bGK4FY7S/kYgscK9Qh4n/Xi5JiaX7ieXXbz4GcR6kWVpeUNKGEmxRyN33TeEBH2KtzfqvRSQBohLrUm/1cGmLmzwx1D/c3SulO75u6ER1ijo4AljIwFGjRmswt/FXvNREKa8JnnagiWOWz/o+9g4Om8yrwSvE0TmdUass2htG+COW2aVSV7d6m/koqO06zhTHRMR3q9Vf2Mi8tzkCLO5191e4iXMgfVR/g6DAe8a0Kj5U+A4zkP53joASIryFR7c8mHSd5Ezj0fnBGhXkKSYSJdGkgx/pf7tY891vjTqsjQFPErZvzdRq9GWCCsypT1RShuXTJdp1t7/RNiduvx6/Lyo0XmWlZsL1PFgMS6C7E6HIBZfKpQYK0r0juT9RcgVi6CpvZladuh/nlXSiZ4AAAA=",
  "data:image/webp;base64,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",
  "data:image/webp;base64,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",
  "data:image/webp;base64,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",
];
var XZ = "0.15.25";
function QZ(t) {
  if (t.__esModule) return t;
  var e = Object.defineProperty({}, "__esModule", {
    value: !0,
  });
  return (
    Object.keys(t).forEach(function (i) {
      var n = Object.getOwnPropertyDescriptor(t, i);
      Object.defineProperty(
        e,
        i,
        n.get
          ? n
          : {
              enumerable: !0,
              get: function () {
                return t[i];
              },
            }
      );
    }),
    e
  );
}
var ZZ = {
  exports: {},
};
function JZ(t, e, i) {
  i = i || 2;
  var n,
    r,
    o,
    a,
    s,
    l,
    u,
    c = e && e.length,
    h = c ? e[0] * i : t.length,
    p = KZ(t, 0, h, i, !0),
    d = [];
  if (!p || p.next === p.prev) return d;
  if (
    (c &&
      (p = (function (t, e, i, n) {
        var r,
          o,
          a,
          s = [];
        for (r = 0, o = e.length; r < o; r++)
          (a = KZ(t, e[r] * n, r < o - 1 ? e[r + 1] * n : t.length, n, !1)) ===
            a.next && (a.steiner = !0),
            s.push(uJ(a));
        for (s.sort(oJ), r = 0; r < s.length; r++)
          i = $Z((i = aJ(s[r], i)), i.next);
        return i;
      })(t, e, p, i)),
    t.length > 80 * i)
  ) {
    (n = o = t[0]), (r = a = t[1]);
    for (var f = i; f < h; f += i)
      (s = t[f]) < n && (n = s),
        (l = t[f + 1]) < r && (r = l),
        s > o && (o = s),
        l > a && (a = l);
    u = 0 !== (u = Math.max(o - n, a - r)) ? 1 / u : 0;
  }
  return tJ(p, d, i, n, r, u), d;
}
function KZ(t, e, i, n, r) {
  var o, a;
  if (r === SJ(t, e, i, n) > 0)
    for (o = e; o < i; o += n) a = bJ(o, t[o], t[o + 1], a);
  else for (o = i - n; o >= e; o -= n) a = bJ(o, t[o], t[o + 1], a);
  return a && dJ(a, a.next) && (xJ(a), (a = a.next)), a;
}
function $Z(t, e) {
  if (!t) return t;
  e || (e = t);
  var i,
    n = t;
  do {
    if (
      ((i = !1), n.steiner || (!dJ(n, n.next) && 0 !== pJ(n.prev, n, n.next)))
    )
      n = n.next;
    else {
      if ((xJ(n), (n = e = n.prev) === n.next)) break;
      i = !0;
    }
  } while (i || n !== e);
  return e;
}
function tJ(t, e, i, n, r, o, a) {
  if (t) {
    !a &&
      o &&
      (function (t, e, i, n) {
        var r = t;
        do {
          null === r.z && (r.z = lJ(r.x, r.y, e, i, n)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== t);
        (r.prevZ.nextZ = null),
          (r.prevZ = null),
          (function (t) {
            var e,
              i,
              n,
              r,
              o,
              a,
              s,
              l,
              u = 1;
            do {
              for (i = t, t = null, o = null, a = 0; i; ) {
                for (
                  a++, n = i, s = 0, e = 0;
                  e < u && (s++, (n = n.nextZ));
                  e++
                );
                for (l = u; s > 0 || (l > 0 && n); )
                  0 !== s && (0 === l || !n || i.z <= n.z)
                    ? ((r = i), (i = i.nextZ), s--)
                    : ((r = n), (n = n.nextZ), l--),
                    o ? (o.nextZ = r) : (t = r),
                    (r.prevZ = o),
                    (o = r);
                i = n;
              }
              (o.nextZ = null), (u *= 2);
            } while (a > 1);
          })(r);
      })(t, n, r, o);
    for (var s, l, u = t; t.prev !== t.next; )
      if (((s = t.prev), (l = t.next), o ? iJ(t, n, r, o) : eJ(t)))
        e.push(s.i / i),
          e.push(t.i / i),
          e.push(l.i / i),
          xJ(t),
          (t = l.next),
          (u = l.next);
      else if ((t = l) === u) {
        a
          ? 1 === a
            ? tJ((t = nJ($Z(t), e, i)), e, i, n, r, o, 2)
            : 2 === a && rJ(t, e, i, n, r, o)
          : tJ($Z(t), e, i, n, r, o, 1);
        break;
      }
  }
}
function eJ(t) {
  var e = t.prev,
    i = t,
    n = t.next;
  if (pJ(e, i, n) >= 0) return !1;
  for (var r = t.next.next; r !== t.prev; ) {
    if (
      cJ(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
      pJ(r.prev, r, r.next) >= 0
    )
      return !1;
    r = r.next;
  }
  return !0;
}
function iJ(t, e, i, n) {
  var r = t.prev,
    o = t,
    a = t.next;
  if (pJ(r, o, a) >= 0) return !1;
  for (
    var s = r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
      l = r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
      u = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
      c = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
      h = lJ(s, l, e, i, n),
      p = lJ(u, c, e, i, n),
      d = t.prevZ,
      f = t.nextZ;
    d && d.z >= h && f && f.z <= p;

  ) {
    if (
      d !== t.prev &&
      d !== t.next &&
      cJ(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
      pJ(d.prev, d, d.next) >= 0
    )
      return !1;
    if (
      ((d = d.prevZ),
      f !== t.prev &&
        f !== t.next &&
        cJ(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
        pJ(f.prev, f, f.next) >= 0)
    )
      return !1;
    f = f.nextZ;
  }
  for (; d && d.z >= h; ) {
    if (
      d !== t.prev &&
      d !== t.next &&
      cJ(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
      pJ(d.prev, d, d.next) >= 0
    )
      return !1;
    d = d.prevZ;
  }
  for (; f && f.z <= p; ) {
    if (
      f !== t.prev &&
      f !== t.next &&
      cJ(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
      pJ(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.nextZ;
  }
  return !0;
}
function nJ(t, e, i) {
  var n = t;
  do {
    var r = n.prev,
      o = n.next.next;
    !dJ(r, o) &&
      fJ(r, n, n.next, o) &&
      yJ(r, o) &&
      yJ(o, r) &&
      (e.push(r.i / i),
      e.push(n.i / i),
      e.push(o.i / i),
      xJ(n),
      xJ(n.next),
      (n = t = o)),
      (n = n.next);
  } while (n !== t);
  return $Z(n);
}
function rJ(t, e, i, n, r, o) {
  var a = t;
  do {
    for (var s = a.next.next; s !== a.prev; ) {
      if (a.i !== s.i && hJ(a, s)) {
        var l = vJ(a, s);
        return (
          (a = $Z(a, a.next)),
          (l = $Z(l, l.next)),
          tJ(a, e, i, n, r, o),
          void tJ(l, e, i, n, r, o)
        );
      }
      s = s.next;
    }
    a = a.next;
  } while (a !== t);
}
function oJ(t, e) {
  return t.x - e.x;
}
function aJ(t, e) {
  var i = (function (t, e) {
    var i,
      n = e,
      r = t.x,
      o = t.y,
      a = -1 / 0;
    do {
      if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
        var s = n.x + ((o - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
        if (s <= r && s > a) {
          if (((a = s), s === r)) {
            if (o === n.y) return n;
            if (o === n.next.y) return n.next;
          }
          i = n.x < n.next.x ? n : n.next;
        }
      }
      n = n.next;
    } while (n !== e);
    if (!i) return null;
    if (r === a) return i;
    var l,
      u = i,
      c = i.x,
      h = i.y,
      p = 1 / 0;
    n = i;
    do {
      r >= n.x &&
        n.x >= c &&
        r !== n.x &&
        cJ(o < h ? r : a, o, c, h, o < h ? a : r, o, n.x, n.y) &&
        ((l = Math.abs(o - n.y) / (r - n.x)),
        yJ(n, t) &&
          (l < p || (l === p && (n.x > i.x || (n.x === i.x && sJ(i, n))))) &&
          ((i = n), (p = l))),
        (n = n.next);
    } while (n !== u);
    return i;
  })(t, e);
  if (!i) return e;
  var n = vJ(i, t),
    r = $Z(i, i.next);
  return $Z(n, n.next), e === i ? r : e;
}
function sJ(t, e) {
  return pJ(t.prev, t, e.prev) < 0 && pJ(e.next, t, t.next) < 0;
}
function lJ(t, e, i, n, r) {
  return (
    (t =
      1431655765 &
      ((t =
        858993459 &
        ((t =
          252645135 &
          ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
            (t << 4))) |
          (t << 2))) |
        (t << 1))) |
    ((e =
      1431655765 &
      ((e =
        858993459 &
        ((e =
          252645135 &
          ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
            (e << 4))) |
          (e << 2))) |
        (e << 1))) <<
      1)
  );
}
function uJ(t) {
  var e = t,
    i = t;
  do {
    (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
  } while (e !== t);
  return i;
}
function cJ(t, e, i, n, r, o, a, s) {
  return (
    (r - a) * (e - s) - (t - a) * (o - s) >= 0 &&
    (t - a) * (n - s) - (i - a) * (e - s) >= 0 &&
    (i - a) * (o - s) - (r - a) * (n - s) >= 0
  );
}
function hJ(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !(function (t, e) {
      var i = t;
      do {
        if (
          i.i !== t.i &&
          i.next.i !== t.i &&
          i.i !== e.i &&
          i.next.i !== e.i &&
          fJ(i, i.next, t, e)
        )
          return !0;
        i = i.next;
      } while (i !== t);
      return !1;
    })(t, e) &&
    ((yJ(t, e) &&
      yJ(e, t) &&
      (function (t, e) {
        var i = t,
          n = !1,
          r = (t.x + e.x) / 2,
          o = (t.y + e.y) / 2;
        do {
          i.y > o != i.next.y > o &&
            i.next.y !== i.y &&
            r < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
            (n = !n),
            (i = i.next);
        } while (i !== t);
        return n;
      })(t, e) &&
      (pJ(t.prev, t, e.prev) || pJ(t, e.prev, e))) ||
      (dJ(t, e) && pJ(t.prev, t, t.next) > 0 && pJ(e.prev, e, e.next) > 0))
  );
}
function pJ(t, e, i) {
  return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
}
function dJ(t, e) {
  return t.x === e.x && t.y === e.y;
}
function fJ(t, e, i, n) {
  var r = mJ(pJ(t, e, i)),
    o = mJ(pJ(t, e, n)),
    a = mJ(pJ(i, n, t)),
    s = mJ(pJ(i, n, e));
  return (
    (r !== o && a !== s) ||
    !(0 !== r || !gJ(t, i, e)) ||
    !(0 !== o || !gJ(t, n, e)) ||
    !(0 !== a || !gJ(i, t, n)) ||
    !(0 !== s || !gJ(i, e, n))
  );
}
function gJ(t, e, i) {
  return (
    e.x <= Math.max(t.x, i.x) &&
    e.x >= Math.min(t.x, i.x) &&
    e.y <= Math.max(t.y, i.y) &&
    e.y >= Math.min(t.y, i.y)
  );
}
function mJ(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function yJ(t, e) {
  return pJ(t.prev, t, t.next) < 0
    ? pJ(t, e, t.next) >= 0 && pJ(t, t.prev, e) >= 0
    : pJ(t, e, t.prev) < 0 || pJ(t, t.next, e) < 0;
}
function vJ(t, e) {
  var i = new _J(t.i, t.x, t.y),
    n = new _J(e.i, e.x, e.y),
    r = t.next,
    o = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (i.next = r),
    (r.prev = i),
    (n.next = i),
    (i.prev = n),
    (o.next = n),
    (n.prev = o),
    n
  );
}
function bJ(t, e, i, n) {
  var r = new _J(t, e, i);
  return (
    n
      ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function xJ(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function _J(t, e, i) {
  (this.i = t),
    (this.x = e),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function SJ(t, e, i, n) {
  for (var r = 0, o = e, a = i - n; o < i; o += n)
    (r += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
  return r;
}
(ZZ.exports = JZ),
  (ZZ.exports.default = JZ),
  (JZ.deviation = function (t, e, i, n) {
    var r = e && e.length,
      o = r ? e[0] * i : t.length,
      a = Math.abs(SJ(t, 0, o, i));
    if (r)
      for (var s = 0, l = e.length; s < l; s++) {
        var u = e[s] * i,
          c = s < l - 1 ? e[s + 1] * i : t.length;
        a -= Math.abs(SJ(t, u, c, i));
      }
    var h = 0;
    for (s = 0; s < n.length; s += 3) {
      var p = n[s] * i,
        d = n[s + 1] * i,
        f = n[s + 2] * i;
      h += Math.abs(
        (t[p] - t[f]) * (t[d + 1] - t[p + 1]) -
          (t[p] - t[d]) * (t[f + 1] - t[p + 1])
      );
    }
    return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a);
  }),
  (JZ.flatten = function (t) {
    for (
      var e = t[0][0].length,
        i = {
          vertices: [],
          holes: [],
          dimensions: e,
        },
        n = 0,
        r = 0;
      r < t.length;
      r++
    ) {
      for (var o = 0; o < t[r].length; o++)
        for (var a = 0; a < e; a++) i.vertices.push(t[r][o][a]);
      r > 0 && ((n += t[r - 1].length), i.holes.push(n));
    }
    return i;
  });
var MJ =
    "object" == typeof global && global && global.Object === Object && global,
  CJ = "object" == typeof self && self && self.Object === Object && self,
  wJ = MJ || CJ || Function("return this")(),
  AJ = wJ.Symbol,
  EJ = Object.prototype,
  DJ = EJ.hasOwnProperty,
  TJ = EJ.toString,
  PJ = AJ ? AJ.toStringTag : void 0;
var LJ = Object.prototype.toString;
var IJ = "[object Null]",
  NJ = "[object Undefined]",
  RJ = AJ ? AJ.toStringTag : void 0;
function OJ(t) {
  return null == t
    ? void 0 === t
      ? NJ
      : IJ
    : RJ && RJ in Object(t)
    ? (function (t) {
        var e = DJ.call(t, PJ),
          i = t[PJ];
        try {
          t[PJ] = void 0;
          var n = !0;
        } catch (o) {}
        var r = TJ.call(t);
        return n && (e ? (t[PJ] = i) : delete t[PJ]), r;
      })(t)
    : (function (t) {
        return LJ.call(t);
      })(t);
}
function FJ(t) {
  return null != t && "object" == typeof t;
}
var zJ = Array.isArray;
function kJ(t) {
  var e = typeof t;
  return null != t && ("object" == e || "function" == e);
}
function BJ(t) {
  return t;
}
var GJ = "[object AsyncFunction]",
  UJ = "[object Function]",
  jJ = "[object GeneratorFunction]",
  HJ = "[object Proxy]";
function VJ(t) {
  if (!kJ(t)) return !1;
  var e = OJ(t);
  return e == UJ || e == jJ || e == GJ || e == HJ;
}
var WJ = wJ["__core-js_shared__"],
  qJ = (function () {
    var t = /[^.]+$/.exec((WJ && WJ.keys && WJ.keys.IE_PROTO) || "");
    return t ? "Symbol(src)_1." + t : "";
  })();
var YJ = Function.prototype.toString;
function XJ(t) {
  if (null != t) {
    try {
      return YJ.call(t);
    } catch (e) {}
    try {
      return t + "";
    } catch (e) {}
  }
  return "";
}
var QJ = /^\[object .+?Constructor\]$/,
  ZJ = Function.prototype,
  JJ = Object.prototype,
  KJ = ZJ.toString,
  $J = JJ.hasOwnProperty,
  tK = RegExp(
    "^" +
      KJ.call($J)
        .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function eK(t) {
  return (
    !(
      !kJ(t) ||
      (function (t) {
        return !!qJ && qJ in t;
      })(t)
    ) && (VJ(t) ? tK : QJ).test(XJ(t))
  );
}
function iK(t, e) {
  var i = (function (t, e) {
    return null == t ? void 0 : t[e];
  })(t, e);
  return eK(i) ? i : void 0;
}
var nK = iK(wJ, "WeakMap"),
  rK = Object.create,
  oK = (function () {
    function t() {}
    return function (e) {
      if (!kJ(e)) return {};
      if (rK) return rK(e);
      t.prototype = e;
      var i = new t();
      return (t.prototype = void 0), i;
    };
  })(),
  aK = oK;
function sK(t, e) {
  var i = -1,
    n = t.length;
  for (e || (e = Array(n)); ++i < n; ) e[i] = t[i];
  return e;
}
var lK = Date.now;
var uK = (function () {
    try {
      var t = iK(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch (e) {}
  })(),
  cK = uK,
  hK = cK
    ? function (t, e) {
        return cK(t, "toString", {
          configurable: !0,
          enumerable: !1,
          value:
            ((i = e),
            function () {
              return i;
            }),
          writable: !0,
        });
        var i;
      }
    : BJ,
  pK = (function (t) {
    var e = 0,
      i = 0;
    return function () {
      var n = lK(),
        r = 16 - (n - i);
      if (((i = n), r > 0)) {
        if (++e >= 800) return arguments[0];
      } else e = 0;
      return t.apply(void 0, arguments);
    };
  })(hK),
  dK = pK;
var fK = 9007199254740991,
  gK = /^(?:0|[1-9]\d*)$/;
function mK(t, e) {
  var i = typeof t;
  return (
    !!(e = null == e ? fK : e) &&
    ("number" == i || ("symbol" != i && gK.test(t))) &&
    t > -1 &&
    t % 1 == 0 &&
    t < e
  );
}
function yK(t, e, i) {
  "__proto__" == e && cK
    ? cK(t, e, {
        configurable: !0,
        enumerable: !0,
        value: i,
        writable: !0,
      })
    : (t[e] = i);
}
function vK(t, e) {
  return t === e || (t != t && e != e);
}
var bK = Object.prototype.hasOwnProperty;
function xK(t, e, i) {
  var n = t[e];
  (bK.call(t, e) && vK(n, i) && (void 0 !== i || e in t)) || yK(t, e, i);
}
function _K(t, e, i, n) {
  var r = !i;
  i || (i = {});
  for (var o = -1, a = e.length; ++o < a; ) {
    var s = e[o],
      l = n ? n(i[s], t[s], s, i, t) : void 0;
    void 0 === l && (l = t[s]), r ? yK(i, s, l) : xK(i, s, l);
  }
  return i;
}
var SK = Math.max;
function MK(t, e) {
  return dK(
    (function (t, e, i) {
      return (
        (e = SK(void 0 === e ? t.length - 1 : e, 0)),
        function () {
          for (
            var n = arguments, r = -1, o = SK(n.length - e, 0), a = Array(o);
            ++r < o;

          )
            a[r] = n[e + r];
          r = -1;
          for (var s = Array(e + 1); ++r < e; ) s[r] = n[r];
          return (
            (s[e] = i(a)),
            (function (t, e, i) {
              switch (i.length) {
                case 0:
                  return t.call(e);
                case 1:
                  return t.call(e, i[0]);
                case 2:
                  return t.call(e, i[0], i[1]);
                case 3:
                  return t.call(e, i[0], i[1], i[2]);
              }
              return t.apply(e, i);
            })(t, this, s)
          );
        }
      );
    })(t, e, BJ),
    t + ""
  );
}
var CK = 9007199254740991;
function wK(t) {
  return "number" == typeof t && t > -1 && t % 1 == 0 && t <= CK;
}
function AK(t) {
  return null != t && wK(t.length) && !VJ(t);
}
function EK(t) {
  return MK(function (e, i) {
    var n = -1,
      r = i.length,
      o = r > 1 ? i[r - 1] : void 0,
      a = r > 2 ? i[2] : void 0;
    for (
      o = t.length > 3 && "function" == typeof o ? (r--, o) : void 0,
        a &&
          (function (t, e, i) {
            if (!kJ(i)) return !1;
            var n = typeof e;
            return (
              !!("number" == n
                ? AK(i) && mK(e, i.length)
                : "string" == n && (e in i)) && vK(i[e], t)
            );
          })(i[0], i[1], a) &&
          ((o = r < 3 ? void 0 : o), (r = 1)),
        e = Object(e);
      ++n < r;

    ) {
      var s = i[n];
      s && t(e, s, n, o);
    }
    return e;
  });
}
var DK = Object.prototype;
function TK(t) {
  var e = t && t.constructor;
  return t === (("function" == typeof e && e.prototype) || DK);
}
function PK(t) {
  return FJ(t) && "[object Arguments]" == OJ(t);
}
var LK = Object.prototype,
  IK = LK.hasOwnProperty,
  NK = LK.propertyIsEnumerable,
  RK = PK(
    (function () {
      return arguments;
    })()
  )
    ? PK
    : function (t) {
        return FJ(t) && IK.call(t, "callee") && !NK.call(t, "callee");
      };
var OK = "object" == typeof exports && exports && !exports.nodeType && exports,
  FK = OK && "object" == typeof module && module && !module.nodeType && module,
  zK = FK && FK.exports === OK ? wJ.Buffer : void 0,
  kK =
    (zK ? zK.isBuffer : void 0) ||
    function () {
      return !1;
    },
  BK = {};
function GK(t) {
  return function (e) {
    return t(e);
  };
}
(BK["[object Float32Array]"] =
  BK["[object Float64Array]"] =
  BK["[object Int8Array]"] =
  BK["[object Int16Array]"] =
  BK["[object Int32Array]"] =
  BK["[object Uint8Array]"] =
  BK["[object Uint8ClampedArray]"] =
  BK["[object Uint16Array]"] =
  BK["[object Uint32Array]"] =
    !0),
  (BK["[object Arguments]"] =
    BK["[object Array]"] =
    BK["[object ArrayBuffer]"] =
    BK["[object Boolean]"] =
    BK["[object DataView]"] =
    BK["[object Date]"] =
    BK["[object Error]"] =
    BK["[object Function]"] =
    BK["[object Map]"] =
    BK["[object Number]"] =
    BK["[object Object]"] =
    BK["[object RegExp]"] =
    BK["[object Set]"] =
    BK["[object String]"] =
    BK["[object WeakMap]"] =
      !1);
var UK = "object" == typeof exports && exports && !exports.nodeType && exports,
  jK = UK && "object" == typeof module && module && !module.nodeType && module,
  HK = jK && jK.exports === UK && MJ.process,
  VK = (function () {
    try {
      var t = jK && jK.require && jK.require("util").types;
      return t || (HK && HK.binding && HK.binding("util"));
    } catch (e) {}
  })(),
  WK = VK && VK.isTypedArray,
  qK = WK
    ? GK(WK)
    : function (t) {
        return FJ(t) && wK(t.length) && !!BK[OJ(t)];
      },
  YK = Object.prototype.hasOwnProperty;
function XK(t, e) {
  var i = zJ(t),
    n = !i && RK(t),
    r = !i && !n && kK(t),
    o = !i && !n && !r && qK(t),
    a = i || n || r || o,
    s = a
      ? (function (t, e) {
          for (var i = -1, n = Array(t); ++i < t; ) n[i] = e(i);
          return n;
        })(t.length, String)
      : [],
    l = s.length;
  for (var u in t)
    (!e && !YK.call(t, u)) ||
      (a &&
        ("length" == u ||
          (r && ("offset" == u || "parent" == u)) ||
          (o && ("buffer" == u || "byteLength" == u || "byteOffset" == u)) ||
          mK(u, l))) ||
      s.push(u);
  return s;
}
function QK(t, e) {
  return function (i) {
    return t(e(i));
  };
}
var ZK = QK(Object.keys, Object),
  JK = Object.prototype.hasOwnProperty;
function KK(t) {
  return AK(t)
    ? XK(t)
    : (function (t) {
        if (!TK(t)) return ZK(t);
        var e = [];
        for (var i in Object(t))
          JK.call(t, i) && "constructor" != i && e.push(i);
        return e;
      })(t);
}
var $K = Object.prototype.hasOwnProperty;
function t$(t) {
  if (!kJ(t))
    return (function (t) {
      var e = [];
      if (null != t) for (var i in Object(t)) e.push(i);
      return e;
    })(t);
  var e = TK(t),
    i = [];
  for (var n in t) ("constructor" != n || (!e && $K.call(t, n))) && i.push(n);
  return i;
}
function e$(t) {
  return AK(t) ? XK(t, !0) : t$(t);
}
var i$ = iK(Object, "create");
var n$ = Object.prototype.hasOwnProperty;
var r$ = Object.prototype.hasOwnProperty;
function o$(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
function a$(t, e) {
  for (var i = t.length; i--; ) if (vK(t[i][0], e)) return i;
  return -1;
}
(o$.prototype.clear = function () {
  (this.__data__ = i$ ? i$(null) : {}), (this.size = 0);
}),
  (o$.prototype.delete = function (t) {
    var e = this.has(t) && delete this.__data__[t];
    return (this.size -= e ? 1 : 0), e;
  }),
  (o$.prototype.get = function (t) {
    var e = this.__data__;
    if (i$) {
      var i = e[t];
      return "__lodash_hash_undefined__" === i ? void 0 : i;
    }
    return n$.call(e, t) ? e[t] : void 0;
  }),
  (o$.prototype.has = function (t) {
    var e = this.__data__;
    return i$ ? void 0 !== e[t] : r$.call(e, t);
  }),
  (o$.prototype.set = function (t, e) {
    var i = this.__data__;
    return (
      (this.size += this.has(t) ? 0 : 1),
      (i[t] = i$ && void 0 === e ? "__lodash_hash_undefined__" : e),
      this
    );
  });
var s$ = Array.prototype.splice;
function l$(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
(l$.prototype.clear = function () {
  (this.__data__ = []), (this.size = 0);
}),
  (l$.prototype.delete = function (t) {
    var e = this.__data__,
      i = a$(e, t);
    return (
      !(i < 0) &&
      (i == e.length - 1 ? e.pop() : s$.call(e, i, 1), --this.size, !0)
    );
  }),
  (l$.prototype.get = function (t) {
    var e = this.__data__,
      i = a$(e, t);
    return i < 0 ? void 0 : e[i][1];
  }),
  (l$.prototype.has = function (t) {
    return a$(this.__data__, t) > -1;
  }),
  (l$.prototype.set = function (t, e) {
    var i = this.__data__,
      n = a$(i, t);
    return n < 0 ? (++this.size, i.push([t, e])) : (i[n][1] = e), this;
  });
var u$ = iK(wJ, "Map");
function c$(t, e) {
  var i,
    n,
    r = t.__data__;
  return (
    "string" == (n = typeof (i = e)) ||
    "number" == n ||
    "symbol" == n ||
    "boolean" == n
      ? "__proto__" !== i
      : null === i
  )
    ? r["string" == typeof e ? "string" : "hash"]
    : r.map;
}
function h$(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
function p$(t, e) {
  for (var i = -1, n = e.length, r = t.length; ++i < n; ) t[r + i] = e[i];
  return t;
}
(h$.prototype.clear = function () {
  (this.size = 0),
    (this.__data__ = {
      hash: new o$(),
      map: new (u$ || l$)(),
      string: new o$(),
    });
}),
  (h$.prototype.delete = function (t) {
    var e = c$(this, t).delete(t);
    return (this.size -= e ? 1 : 0), e;
  }),
  (h$.prototype.get = function (t) {
    return c$(this, t).get(t);
  }),
  (h$.prototype.has = function (t) {
    return c$(this, t).has(t);
  }),
  (h$.prototype.set = function (t, e) {
    var i = c$(this, t),
      n = i.size;
    return i.set(t, e), (this.size += i.size == n ? 0 : 1), this;
  });
var d$ = QK(Object.getPrototypeOf, Object),
  f$ = "[object Object]",
  g$ = Function.prototype,
  m$ = Object.prototype,
  y$ = g$.toString,
  v$ = m$.hasOwnProperty,
  b$ = y$.call(Object);
function x$(t) {
  var e = (this.__data__ = new l$(t));
  this.size = e.size;
}
(x$.prototype.clear = function () {
  (this.__data__ = new l$()), (this.size = 0);
}),
  (x$.prototype.delete = function (t) {
    var e = this.__data__,
      i = e.delete(t);
    return (this.size = e.size), i;
  }),
  (x$.prototype.get = function (t) {
    return this.__data__.get(t);
  }),
  (x$.prototype.has = function (t) {
    return this.__data__.has(t);
  }),
  (x$.prototype.set = function (t, e) {
    var i = this.__data__;
    if (i instanceof l$) {
      var n = i.__data__;
      if (!u$ || n.length < 199)
        return n.push([t, e]), (this.size = ++i.size), this;
      i = this.__data__ = new h$(n);
    }
    return i.set(t, e), (this.size = i.size), this;
  });
var _$ = "object" == typeof exports && exports && !exports.nodeType && exports,
  S$ = _$ && "object" == typeof module && module && !module.nodeType && module,
  M$ = S$ && S$.exports === _$ ? wJ.Buffer : void 0,
  C$ = M$ ? M$.allocUnsafe : void 0;
function w$(t, e) {
  if (e) return t.slice();
  var i = t.length,
    n = C$ ? C$(i) : new t.constructor(i);
  return t.copy(n), n;
}
function A$() {
  return [];
}
var E$ = Object.prototype.propertyIsEnumerable,
  D$ = Object.getOwnPropertySymbols,
  T$ = D$
    ? function (t) {
        return null == t
          ? []
          : ((t = Object(t)),
            (function (t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length, r = 0, o = [];
                ++i < n;

              ) {
                var a = t[i];
                e(a, i, t) && (o[r++] = a);
              }
              return o;
            })(D$(t), function (e) {
              return E$.call(t, e);
            }));
      }
    : A$,
  P$ = T$;
var L$ = Object.getOwnPropertySymbols
    ? function (t) {
        for (var e = []; t; ) p$(e, P$(t)), (t = d$(t));
        return e;
      }
    : A$,
  I$ = L$;
function N$(t, e, i) {
  var n = e(t);
  return zJ(t) ? n : p$(n, i(t));
}
function R$(t) {
  return N$(t, KK, P$);
}
function O$(t) {
  return N$(t, e$, I$);
}
var F$ = iK(wJ, "DataView"),
  z$ = iK(wJ, "Promise"),
  k$ = iK(wJ, "Set"),
  B$ = "[object Map]",
  G$ = "[object Promise]",
  U$ = "[object Set]",
  j$ = "[object WeakMap]",
  H$ = "[object DataView]",
  V$ = XJ(F$),
  W$ = XJ(u$),
  q$ = XJ(z$),
  Y$ = XJ(k$),
  X$ = XJ(nK),
  Q$ = OJ;
((F$ && Q$(new F$(new ArrayBuffer(1))) != H$) ||
  (u$ && Q$(new u$()) != B$) ||
  (z$ && Q$(z$.resolve()) != G$) ||
  (k$ && Q$(new k$()) != U$) ||
  (nK && Q$(new nK()) != j$)) &&
  (Q$ = function (t) {
    var e = OJ(t),
      i = "[object Object]" == e ? t.constructor : void 0,
      n = i ? XJ(i) : "";
    if (n)
      switch (n) {
        case V$:
          return H$;
        case W$:
          return B$;
        case q$:
          return G$;
        case Y$:
          return U$;
        case X$:
          return j$;
      }
    return e;
  });
var Z$ = Q$,
  J$ = Object.prototype.hasOwnProperty;
var K$ = wJ.Uint8Array;
function $$(t) {
  var e = new t.constructor(t.byteLength);
  return new K$(e).set(new K$(t)), e;
}
var t0 = /\w*$/;
var e0 = AJ ? AJ.prototype : void 0,
  i0 = e0 ? e0.valueOf : void 0;
function n0(t, e) {
  var i = e ? $$(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.length);
}
var r0 = "[object Boolean]",
  o0 = "[object Date]",
  a0 = "[object Map]",
  s0 = "[object Number]",
  l0 = "[object RegExp]",
  u0 = "[object Set]",
  c0 = "[object String]",
  h0 = "[object Symbol]",
  p0 = "[object ArrayBuffer]",
  d0 = "[object DataView]",
  f0 = "[object Float32Array]",
  g0 = "[object Float64Array]",
  m0 = "[object Int8Array]",
  y0 = "[object Int16Array]",
  v0 = "[object Int32Array]",
  b0 = "[object Uint8Array]",
  x0 = "[object Uint8ClampedArray]",
  _0 = "[object Uint16Array]",
  S0 = "[object Uint32Array]";
function M0(t, e, i) {
  var n,
    r = t.constructor;
  switch (e) {
    case p0:
      return $$(t);
    case r0:
    case o0:
      return new r(+t);
    case d0:
      return (function (t, e) {
        var i = e ? $$(t.buffer) : t.buffer;
        return new t.constructor(i, t.byteOffset, t.byteLength);
      })(t, i);
    case f0:
    case g0:
    case m0:
    case y0:
    case v0:
    case b0:
    case x0:
    case _0:
    case S0:
      return n0(t, i);
    case a0:
      return new r();
    case s0:
    case c0:
      return new r(t);
    case l0:
      return (function (t) {
        var e = new t.constructor(t.source, t0.exec(t));
        return (e.lastIndex = t.lastIndex), e;
      })(t);
    case u0:
      return new r();
    case h0:
      return (n = t), i0 ? Object(i0.call(n)) : {};
  }
}
function C0(t) {
  return "function" != typeof t.constructor || TK(t) ? {} : aK(d$(t));
}
var w0 = VK && VK.isMap,
  A0 = w0
    ? GK(w0)
    : function (t) {
        return FJ(t) && "[object Map]" == Z$(t);
      };
var E0 = VK && VK.isSet,
  D0 = E0
    ? GK(E0)
    : function (t) {
        return FJ(t) && "[object Set]" == Z$(t);
      },
  T0 = 1,
  P0 = 2,
  L0 = 4,
  I0 = "[object Arguments]",
  N0 = "[object Function]",
  R0 = "[object GeneratorFunction]",
  O0 = "[object Object]",
  F0 = {};
function z0(t, e, i, n, r, o) {
  var a,
    s = e & T0,
    l = e & P0,
    u = e & L0;
  if ((i && (a = r ? i(t, n, r, o) : i(t)), void 0 !== a)) return a;
  if (!kJ(t)) return t;
  var c = zJ(t);
  if (c) {
    if (
      ((a = (function (t) {
        var e = t.length,
          i = new t.constructor(e);
        return (
          e &&
            "string" == typeof t[0] &&
            J$.call(t, "index") &&
            ((i.index = t.index), (i.input = t.input)),
          i
        );
      })(t)),
      !s)
    )
      return sK(t, a);
  } else {
    var h = Z$(t),
      p = h == N0 || h == R0;
    if (kK(t)) return w$(t, s);
    if (h == O0 || h == I0 || (p && !r)) {
      if (((a = l || p ? {} : C0(t)), !s))
        return l
          ? (function (t, e) {
              return _K(t, I$(t), e);
            })(
              t,
              (function (t, e) {
                return t && _K(e, e$(e), t);
              })(a, t)
            )
          : (function (t, e) {
              return _K(t, P$(t), e);
            })(
              t,
              (function (t, e) {
                return t && _K(e, KK(e), t);
              })(a, t)
            );
    } else {
      if (!F0[h]) return r ? t : {};
      a = M0(t, h, s);
    }
  }
  o || (o = new x$());
  var d = o.get(t);
  if (d) return d;
  o.set(t, a),
    D0(t)
      ? t.forEach(function (n) {
          a.add(z0(n, e, i, n, t, o));
        })
      : A0(t) &&
        t.forEach(function (n, r) {
          a.set(r, z0(n, e, i, r, t, o));
        });
  var f = c ? void 0 : (u ? (l ? O$ : R$) : l ? e$ : KK)(t);
  return (
    (function (t, e) {
      for (
        var i = -1, n = null == t ? 0 : t.length;
        ++i < n && !1 !== e(t[i], i, t);

      );
    })(f || t, function (n, r) {
      f && (n = t[(r = n)]), xK(a, r, z0(n, e, i, r, t, o));
    }),
    a
  );
}
(F0[I0] =
  F0["[object Array]"] =
  F0["[object ArrayBuffer]"] =
  F0["[object DataView]"] =
  F0["[object Boolean]"] =
  F0["[object Date]"] =
  F0["[object Float32Array]"] =
  F0["[object Float64Array]"] =
  F0["[object Int8Array]"] =
  F0["[object Int16Array]"] =
  F0["[object Int32Array]"] =
  F0["[object Map]"] =
  F0["[object Number]"] =
  F0[O0] =
  F0["[object RegExp]"] =
  F0["[object Set]"] =
  F0["[object String]"] =
  F0["[object Symbol]"] =
  F0["[object Uint8Array]"] =
  F0["[object Uint8ClampedArray]"] =
  F0["[object Uint16Array]"] =
  F0["[object Uint32Array]"] =
    !0),
  (F0["[object Error]"] = F0[N0] = F0["[object WeakMap]"] = !1);
function k0(t) {
  var e = -1,
    i = null == t ? 0 : t.length;
  for (this.__data__ = new h$(); ++e < i; ) this.add(t[e]);
}
function B0(t, e) {
  for (var i = -1, n = null == t ? 0 : t.length; ++i < n; )
    if (e(t[i], i, t)) return !0;
  return !1;
}
(k0.prototype.add = k0.prototype.push =
  function (t) {
    return this.__data__.set(t, "__lodash_hash_undefined__"), this;
  }),
  (k0.prototype.has = function (t) {
    return this.__data__.has(t);
  });
var G0 = 1,
  U0 = 2;
function j0(t, e, i, n, r, o) {
  var a = i & G0,
    s = t.length,
    l = e.length;
  if (s != l && !(a && l > s)) return !1;
  var u = o.get(t),
    c = o.get(e);
  if (u && c) return u == e && c == t;
  var h = -1,
    p = !0,
    d = i & U0 ? new k0() : void 0;
  for (o.set(t, e), o.set(e, t); ++h < s; ) {
    var f = t[h],
      g = e[h];
    if (n) var m = a ? n(g, f, h, e, t, o) : n(f, g, h, t, e, o);
    if (void 0 !== m) {
      if (m) continue;
      p = !1;
      break;
    }
    if (d) {
      if (
        !B0(e, function (t, e) {
          if (((a = e), !d.has(a) && (f === t || r(f, t, i, n, o))))
            return d.push(e);
          var a;
        })
      ) {
        p = !1;
        break;
      }
    } else if (f !== g && !r(f, g, i, n, o)) {
      p = !1;
      break;
    }
  }
  return o.delete(t), o.delete(e), p;
}
function H0(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (t, n) {
      i[++e] = [n, t];
    }),
    i
  );
}
function V0(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (t) {
      i[++e] = t;
    }),
    i
  );
}
var W0 = 1,
  q0 = 2,
  Y0 = "[object Boolean]",
  X0 = "[object Date]",
  Q0 = "[object Error]",
  Z0 = "[object Map]",
  J0 = "[object Number]",
  K0 = "[object RegExp]",
  $0 = "[object Set]",
  t1 = "[object String]",
  e1 = "[object Symbol]",
  i1 = "[object ArrayBuffer]",
  n1 = "[object DataView]",
  r1 = AJ ? AJ.prototype : void 0,
  o1 = r1 ? r1.valueOf : void 0;
var a1 = 1,
  s1 = Object.prototype.hasOwnProperty;
var l1 = 1,
  u1 = "[object Arguments]",
  c1 = "[object Array]",
  h1 = "[object Object]",
  p1 = Object.prototype.hasOwnProperty;
function d1(t, e, i, n, r, o) {
  var a = zJ(t),
    s = zJ(e),
    l = a ? c1 : Z$(t),
    u = s ? c1 : Z$(e),
    c = (l = l == u1 ? h1 : l) == h1,
    h = (u = u == u1 ? h1 : u) == h1,
    p = l == u;
  if (p && kK(t)) {
    if (!kK(e)) return !1;
    (a = !0), (c = !1);
  }
  if (p && !c)
    return (
      o || (o = new x$()),
      a || qK(t)
        ? j0(t, e, i, n, r, o)
        : (function (t, e, i, n, r, o, a) {
            switch (i) {
              case n1:
                if (
                  t.byteLength != e.byteLength ||
                  t.byteOffset != e.byteOffset
                )
                  return !1;
                (t = t.buffer), (e = e.buffer);
              case i1:
                return !(
                  t.byteLength != e.byteLength || !o(new K$(t), new K$(e))
                );
              case Y0:
              case X0:
              case J0:
                return vK(+t, +e);
              case Q0:
                return t.name == e.name && t.message == e.message;
              case K0:
              case t1:
                return t == e + "";
              case Z0:
                var s = H0;
              case $0:
                var l = n & W0;
                if ((s || (s = V0), t.size != e.size && !l)) return !1;
                var u = a.get(t);
                if (u) return u == e;
                (n |= q0), a.set(t, e);
                var c = j0(s(t), s(e), n, r, o, a);
                return a.delete(t), c;
              case e1:
                if (o1) return o1.call(t) == o1.call(e);
            }
            return !1;
          })(t, e, l, i, n, r, o)
    );
  if (!(i & l1)) {
    var d = c && p1.call(t, "__wrapped__"),
      f = h && p1.call(e, "__wrapped__");
    if (d || f) {
      var g = d ? t.value() : t,
        m = f ? e.value() : e;
      return o || (o = new x$()), r(g, m, i, n, o);
    }
  }
  return (
    !!p &&
    (o || (o = new x$()),
    (function (t, e, i, n, r, o) {
      var a = i & a1,
        s = R$(t),
        l = s.length;
      if (l != R$(e).length && !a) return !1;
      for (var u = l; u--; ) {
        var c = s[u];
        if (!(a ? c in e : s1.call(e, c))) return !1;
      }
      var h = o.get(t),
        p = o.get(e);
      if (h && p) return h == e && p == t;
      var d = !0;
      o.set(t, e), o.set(e, t);
      for (var f = a; ++u < l; ) {
        var g = t[(c = s[u])],
          m = e[c];
        if (n) var y = a ? n(m, g, c, e, t, o) : n(g, m, c, t, e, o);
        if (!(void 0 === y ? g === m || r(g, m, i, n, o) : y)) {
          d = !1;
          break;
        }
        f || (f = "constructor" == c);
      }
      if (d && !f) {
        var v = t.constructor,
          b = e.constructor;
        v == b ||
          !("constructor" in t) ||
          !("constructor" in e) ||
          ("function" == typeof v &&
            v instanceof v &&
            "function" == typeof b &&
            b instanceof b) ||
          (d = !1);
      }
      return o.delete(t), o.delete(e), d;
    })(t, e, i, n, r, o))
  );
}
function f1(t, e, i, n, r) {
  return (
    t === e ||
    (null == t || null == e || (!FJ(t) && !FJ(e))
      ? t != t && e != e
      : d1(t, e, i, n, f1, r))
  );
}
var g1 = (function (t) {
    return function (e, i, n) {
      for (var r = -1, o = Object(e), a = n(e), s = a.length; s--; ) {
        var l = a[t ? s : ++r];
        if (!1 === i(o[l], l, o)) break;
      }
      return e;
    };
  })(),
  m1 = g1;
function y1(t, e, i) {
  ((void 0 !== i && !vK(t[e], i)) || (void 0 === i && !(e in t))) &&
    yK(t, e, i);
}
function v1(t, e) {
  if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e)
    return t[e];
}
function b1(t, e, i, n, r, o, a) {
  var s = v1(t, i),
    l = v1(e, i),
    u = a.get(l);
  if (u) y1(t, i, u);
  else {
    var c,
      h = o ? o(s, l, i + "", t, e, a) : void 0,
      p = void 0 === h;
    if (p) {
      var d = zJ(l),
        f = !d && kK(l),
        g = !d && !f && qK(l);
      (h = l),
        d || f || g
          ? zJ(s)
            ? (h = s)
            : FJ((c = s)) && AK(c)
            ? (h = sK(s))
            : f
            ? ((p = !1), (h = w$(l, !0)))
            : g
            ? ((p = !1), (h = n0(l, !0)))
            : (h = [])
          : (function (t) {
              if (!FJ(t) || OJ(t) != f$) return !1;
              var e = d$(t);
              if (null === e) return !0;
              var i = v$.call(e, "constructor") && e.constructor;
              return (
                "function" == typeof i && i instanceof i && y$.call(i) == b$
              );
            })(l) || RK(l)
          ? ((h = s),
            RK(s)
              ? (h = (function (t) {
                  return _K(t, e$(t));
                })(s))
              : (kJ(s) && !VJ(s)) || (h = C0(l)))
          : (p = !1);
    }
    p && (a.set(l, h), r(h, l, n, o, a), a.delete(l)), y1(t, i, h);
  }
}
function x1(t, e, i, n, r) {
  t !== e &&
    m1(
      e,
      function (o, a) {
        if ((r || (r = new x$()), kJ(o))) b1(t, e, a, i, x1, n, r);
        else {
          var s = n ? n(v1(t, a), o, a + "", t, e, r) : void 0;
          void 0 === s && (s = o), y1(t, a, s);
        }
      },
      e$
    );
}
var _1 = EK(function (t, e, i, n) {
  x1(t, e, i, n);
});
function S1(t, e) {
  return f1(t, e);
}
var M1 = EK(function (t, e, i) {
  x1(t, e, i);
});
!(function () {
  try {
    return (
      0 ===
      document
        .createElement("canvas")
        .toDataURL("image/webp", 0.5)
        .indexOf("data:image/webp")
    );
  } catch (t) {
    return !1;
  }
})();
const C1 = function (t, ...e) {
  return _1(z0(t, 5), ...e, (t, e) =>
    zJ(e) ? e : void 0 === e ? null : void 0
  );
};
function w1(t) {
  return !(function (t) {
    return null == t;
  })(t);
}
const A1 = class {
  static create(t, e, i) {
    const n = document.createElement(t);
    return (n.className = e || ""), i && i.appendChild(n), n;
  }
  static remove(t) {
    const e = t.parentNode;
    e && e.removeChild(t);
  }
  static addClass(t, e) {
    if (t.classList) {
      const i = D1(e).split(/\s+/);
      for (let e = 0, n = i.length; e < n; e++) t.classList.add(i[e]);
    } else if (!A1.hasClass(t, e)) {
      const i = A1.getClass(t);
      A1.setClass(t, (i ? i + " " : "") + e);
    }
  }
  static removeClass(t, e) {
    t.classList
      ? t.classList.remove(e)
      : A1.setClass(
          t,
          D1((" " + A1.getClass(t) + " ").replace(" " + e + " ", " "))
        );
  }
  static hasClass(t, e) {
    if (t.classList) return t.classList.contains(e);
    const i = A1.getClass(t);
    return i.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(i);
  }
  static setClass(t, e) {
    t instanceof HTMLElement ? (t.className = e) : (t.className.baseVal = e);
  }
  static getClass(t) {
    var e;
    return (
      t instanceof SVGElement && (t = t.correspondingElement),
      null != (e = t.className.baseVal) ? e : t.className
    );
  }
  static empty(t) {
    for (; t && t.firstChild; ) t.removeChild(t.firstChild);
  }
  static setTransform(t, e) {
    t.style[A1.transformProp] = e;
  }
  static testProp(t) {
    if (!A1.docStyle) return t[0];
    for (const e in t) if (t[e] && t[e] in A1.docStyle) return t[e];
    return t[0];
  }
  static createHTMLDomByStr(t) {
    const e = window.document.createDocumentFragment(),
      i = window.document.createElement("body");
    let n;
    for (i.innerHTML = t; (n = i.firstChild), n; ) e.appendChild(n);
    return e;
  }
  static setVisible(t, e) {
    t.style.visibility = e ? "visible" : "hidden";
  }
};
let E1 = A1;
function D1(t) {
  return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
}
(E1.transformProp = A1.testProp(["transform", "WebkitTransform"])),
  (E1.docStyle = window.document.documentElement.style);
const T1 = {
  enabled: !1,
  brightness: 1,
  contrast: 1,
  grayscale: 0,
  hueRotate: 0,
  invert: 0,
  saturate: 1,
  sepia: 0,
};
function P1(t, e) {
  if ("string" == typeof e) return t[e];
  {
    const i = e.length;
    let n,
      r,
      o = -1;
    for (; ++o < i && ((n = e[o]), Object.hasOwnProperty.call(t, n)); )
      r = t = t[n];
    return o === i ? r : void 0;
  }
}
class L1 {
  constructor(t) {
    (this.parent = t), (this.watchers = []);
  }
  addWatch(t) {
    t instanceof Array
      ? Array.prototype.push.apply(this.watchers, t)
      : this.watchers.push(t),
      this.watchers.sort((t, e) => (t.priority || 10) - (e.priority || 10));
  }
  compare(t, e) {
    if (e && t)
      for (let i = 0, n = this.watchers.length; i < n; i++) {
        const n = this.watchers[i],
          { rule: r, cb: o } = n;
        if (this.__calcRuleAndProps(r, e, t) && (o(e, t), n.serial)) break;
      }
  }
  defaultRule(t, e, i, n = !1) {
    return this.parent.defaultRule(t, e, i, n);
  }
  __calcRuleAndProps(t, e, i) {
    let n = !1;
    switch (t.type) {
      case "all":
        t.rules && (n = t.rules.every((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      case "some":
        t.rules && (n = t.rules.some((t) => this.__calcRuleAndProps(t, e, i)));
        break;
      default: {
        const n =
          "custom" === t.type ? t.ruleFunc : this.parent.ruleFuncMap[t.type];
        return !!n && n(e, i, t.key);
      }
    }
    return n;
  }
}
const I1 = new (class {
  constructor() {
    this.ruleFuncMap = {};
  }
  registerRule(t, e) {
    this.ruleFuncMap[t] = e;
  }
  createPropsWatch() {
    return new L1(this);
  }
  defaultRule(t, e, i, n = !1) {
    return {
      rule: {
        type: e,
        key: t,
      },
      cb: i,
      serial: n,
    };
  }
})();
I1.registerRule("has", (t, e, i) => w1(P1(t, i))),
  I1.registerRule("diff", (t, e, i) => {
    const n = P1(t, i),
      r = P1(e, i);
    return w1(n) && n !== r;
  }),
  I1.registerRule("diffDeep", (t, e, i) => {
    const n = P1(t, i),
      r = P1(e, i);
    return (
      w1(n) && n !== r && (Array.isArray(n) ? !S1(n, r) : !S1(M1({}, r, n), r))
    );
  }),
  I1.registerRule("diffAnyone", (t, e, i) =>
    i.some((i) => {
      const n = P1(t, i),
        r = P1(e, i);
      return w1(n) && n !== r;
    })
  ),
  I1.registerRule("diffAnyoneDeep", (t, e, i) =>
    i.some((i) => {
      const n = P1(t, i),
        r = P1(e, i);
      return (
        w1(n) &&
        n !== r &&
        (Array.isArray(n) ? !S1(n, r) : !S1(M1({}, r, n), r))
      );
    })
  ),
  I1.registerRule("always", () => !0),
  I1.registerRule("hasAndClose", (t, e, i) => {
    const n = P1(t, i);
    return w1(n) && !n;
  });
const N1 = Math.PI / 180;
for (let p7 = 0; p7 <= 31; p7++) {
  R1(p7, 1);
  const t = [];
  for (let e = 0; e < 10; e++) t.push(R1(p7 + 0.1 * e, 1));
}
function R1(t, e) {
  0 === e && (e = 512);
  return (
    (e * (1565.4303392804097 / Math.pow(2, t))) /
    2 /
    Math.tan(((56 - Math.floor(10 * t) / 10) * N1) / 2)
  );
}
var O1 = Object.prototype.hasOwnProperty;
function F1(t, e, i, n, r, o) {
  3 === arguments.length && ((n = o = Array), (r = null));
  for (
    var a = new n((t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))),
      s = new o(t),
      l = t - 1,
      u = 0;
    u < t;
    ++u
  )
    a[u] = r;
  return {
    set: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return (s[u] = o);
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    maybeSet: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) throw new Error("full hashmap");
        c = a[(u = (u + 1) & l)];
      }
      return (a[u] = n), (s[u] = o), o;
    },
    get: function (n, o) {
      for (var u = e(n) & l, c = a[u], h = 0; c != r; ) {
        if (i(c, n)) return s[u];
        if (++h >= t) break;
        c = a[(u = (u + 1) & l)];
      }
      return o;
    },
    keys: function () {
      for (var t = [], e = 0, i = a.length; e < i; ++e) {
        var n = a[e];
        n != r && t.push(n);
      }
      return t;
    },
  };
}
function z1(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
var k1 = new ArrayBuffer(16),
  B1 = new Float64Array(k1),
  G1 = new Uint32Array(k1);
function U1(t) {
  (B1[0] = t[0]), (B1[1] = t[1]);
  var e = G1[0] ^ G1[1];
  return 2147483647 & (e = (e << 5) ^ (e >> 7) ^ G1[2] ^ G1[3]);
}
function j1(t) {
  var e,
    i,
    n,
    r,
    o = t.coordinates,
    a = t.lines,
    s = t.rings,
    l = (function () {
      for (
        var t = F1(1.4 * o.length, _, S, Int32Array, -1, Int32Array),
          e = new Int32Array(o.length),
          i = 0,
          n = o.length;
        i < n;
        ++i
      )
        e[i] = t.maybeSet(i, i);
      return e;
    })(),
    u = new Int32Array(o.length),
    c = new Int32Array(o.length),
    h = new Int32Array(o.length),
    p = new Int8Array(o.length),
    d = 0;
  for (e = 0, i = o.length; e < i; ++e) u[e] = c[e] = h[e] = -1;
  for (e = 0, i = a.length; e < i; ++e) {
    var f = a[e],
      g = f[0],
      m = f[1];
    for (n = l[g], r = l[++g], ++d, p[n] = 1; ++g <= m; )
      x(e, n, (n = r), (r = l[g]));
    ++d, (p[r] = 1);
  }
  for (e = 0, i = o.length; e < i; ++e) u[e] = -1;
  for (e = 0, i = s.length; e < i; ++e) {
    var y = s[e],
      v = y[0] + 1,
      b = y[1];
    for (x(e, l[b - 1], (n = l[v - 1]), (r = l[v])); ++v <= b; )
      x(e, n, (n = r), (r = l[v]));
  }
  function x(t, e, i, n) {
    if (u[i] !== t) {
      u[i] = t;
      var r = c[i];
      if (r >= 0) {
        var o = h[i];
        (r === e && o === n) || (r === n && o === e) || (++d, (p[i] = 1));
      } else (c[i] = e), (h[i] = n);
    }
  }
  function _(t) {
    return U1(o[t]);
  }
  function S(t, e) {
    return z1(o[t], o[e]);
  }
  u = c = h = null;
  var M,
    C = (function (t, e, i, n, r) {
      3 === arguments.length && ((n = Array), (r = null));
      for (
        var o = new n(
            (t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))
          ),
          a = t - 1,
          s = 0;
        s < t;
        ++s
      )
        o[s] = r;
      return {
        add: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) throw new Error("full hashset");
            l = o[(s = (s + 1) & a)];
          }
          return (o[s] = n), !0;
        },
        has: function (n) {
          for (var s = e(n) & a, l = o[s], u = 0; l != r; ) {
            if (i(l, n)) return !0;
            if (++u >= t) break;
            l = o[(s = (s + 1) & a)];
          }
          return !1;
        },
        values: function () {
          for (var t = [], e = 0, i = o.length; e < i; ++e) {
            var n = o[e];
            n != r && t.push(n);
          }
          return t;
        },
      };
    })(1.4 * d, U1, z1);
  for (e = 0, i = o.length; e < i; ++e) p[(M = l[e])] && C.add(o[M]);
  return C;
}
function H1(t, e, i, n) {
  V1(t, e, i), V1(t, e, e + n), V1(t, e + n, i);
}
function V1(t, e, i) {
  for (var n, r = e + ((i-- - e) >> 1); e < r; ++e, --i)
    (n = t[e]), (t[e] = t[i]), (t[i] = n);
}
function W1(t) {
  var e,
    i,
    n = {};
  for (e in t)
    n[e] =
      null == (i = t[e])
        ? {
            type: null,
          }
        : ("FeatureCollection" === i.type
            ? q1
            : "Feature" === i.type
            ? Y1
            : X1)(i);
  return n;
}
function q1(t) {
  var e = {
    type: "GeometryCollection",
    geometries: t.features.map(Y1),
  };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function Y1(t) {
  var e,
    i = X1(t.geometry);
  for (e in (null != t.id && (i.id = t.id),
  null != t.bbox && (i.bbox = t.bbox),
  t.properties)) {
    i.properties = t.properties;
    break;
  }
  return i;
}
function X1(t) {
  if (null == t)
    return {
      type: null,
    };
  var e =
    "GeometryCollection" === t.type
      ? {
          type: "GeometryCollection",
          geometries: t.geometries.map(X1),
        }
      : "Point" === t.type || "MultiPoint" === t.type
      ? {
          type: t.type,
          coordinates: t.coordinates,
        }
      : {
          type: t.type,
          arcs: t.coordinates,
        };
  return null != t.bbox && (e.bbox = t.bbox), e;
}
function Q1(t) {
  var e,
    i = t[0],
    n = t[1];
  return n < i && ((e = i), (i = n), (n = e)), i + 31 * n;
}
function Z1(t, e) {
  var i,
    n = t[0],
    r = t[1],
    o = e[0],
    a = e[1];
  return (
    r < n && ((i = n), (n = r), (r = i)),
    a < o && ((i = o), (o = a), (a = i)),
    n === o && r === a
  );
}
var J1 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        topology: function (t, e) {
          var i = (function (t) {
              var e = 1 / 0,
                i = 1 / 0,
                n = -1 / 0,
                r = -1 / 0;
              function o(t) {
                null != t && O1.call(a, t.type) && a[t.type](t);
              }
              var a = {
                GeometryCollection: function (t) {
                  t.geometries.forEach(o);
                },
                Point: function (t) {
                  s(t.coordinates);
                },
                MultiPoint: function (t) {
                  t.coordinates.forEach(s);
                },
                LineString: function (t) {
                  l(t.arcs);
                },
                MultiLineString: function (t) {
                  t.arcs.forEach(l);
                },
                Polygon: function (t) {
                  t.arcs.forEach(l);
                },
                MultiPolygon: function (t) {
                  t.arcs.forEach(u);
                },
              };
              function s(t) {
                var o = t[0],
                  a = t[1];
                o < e && (e = o),
                  o > n && (n = o),
                  a < i && (i = a),
                  a > r && (r = a);
              }
              function l(t) {
                t.forEach(s);
              }
              function u(t) {
                t.forEach(l);
              }
              for (var c in t) o(t[c]);
              return n >= e && r >= i ? [e, i, n, r] : void 0;
            })((t = W1(t))),
            n =
              e > 0 &&
              i &&
              (function (t, e, i) {
                var n = e[0],
                  r = e[1],
                  o = e[2],
                  a = e[3],
                  s = o - n ? (i - 1) / (o - n) : 1,
                  l = a - r ? (i - 1) / (a - r) : 1;
                function u(t) {
                  return [
                    Math.round((t[0] - n) * s),
                    Math.round((t[1] - r) * l),
                  ];
                }
                function c(t, e) {
                  for (
                    var i,
                      o,
                      a,
                      u,
                      c,
                      h = -1,
                      p = 0,
                      d = t.length,
                      f = new Array(d);
                    ++h < d;

                  )
                    (i = t[h]),
                      (u = Math.round((i[0] - n) * s)),
                      (c = Math.round((i[1] - r) * l)),
                      (u === o && c === a) || (f[p++] = [(o = u), (a = c)]);
                  for (f.length = p; p < e; ) p = f.push([f[0][0], f[0][1]]);
                  return f;
                }
                function h(t) {
                  return c(t, 2);
                }
                function p(t) {
                  return c(t, 4);
                }
                function d(t) {
                  return t.map(p);
                }
                function f(t) {
                  null != t && O1.call(g, t.type) && g[t.type](t);
                }
                var g = {
                  GeometryCollection: function (t) {
                    t.geometries.forEach(f);
                  },
                  Point: function (t) {
                    t.coordinates = u(t.coordinates);
                  },
                  MultiPoint: function (t) {
                    t.coordinates = t.coordinates.map(u);
                  },
                  LineString: function (t) {
                    t.arcs = h(t.arcs);
                  },
                  MultiLineString: function (t) {
                    t.arcs = t.arcs.map(h);
                  },
                  Polygon: function (t) {
                    t.arcs = d(t.arcs);
                  },
                  MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(d);
                  },
                };
                for (var m in t) f(t[m]);
                return {
                  scale: [1 / s, 1 / l],
                  translate: [n, r],
                };
              })(t, i, e),
            r = (function (t) {
              var e,
                i,
                n,
                r,
                o = t.coordinates,
                a = t.lines,
                s = t.rings,
                l = a.length + s.length;
              for (
                delete t.lines, delete t.rings, n = 0, r = a.length;
                n < r;
                ++n
              )
                for (e = a[n]; (e = e.next); ) ++l;
              for (n = 0, r = s.length; n < r; ++n)
                for (i = s[n]; (i = i.next); ) ++l;
              var u = F1(2 * l * 1.4, U1, z1),
                c = (t.arcs = []);
              for (n = 0, r = a.length; n < r; ++n) {
                e = a[n];
                do {
                  h(e);
                } while ((e = e.next));
              }
              for (n = 0, r = s.length; n < r; ++n)
                if ((i = s[n]).next)
                  do {
                    h(i);
                  } while ((i = i.next));
                else p(i);
              function h(t) {
                var e, i, n, r, a, s, l, h;
                if ((n = u.get((e = o[t[0]]))))
                  for (l = 0, h = n.length; l < h; ++l)
                    if (d((r = n[l]), t))
                      return (t[0] = r[0]), void (t[1] = r[1]);
                if ((a = u.get((i = o[t[1]]))))
                  for (l = 0, h = a.length; l < h; ++l)
                    if (f((s = a[l]), t))
                      return (t[1] = s[0]), void (t[0] = s[1]);
                n ? n.push(t) : u.set(e, [t]),
                  a ? a.push(t) : u.set(i, [t]),
                  c.push(t);
              }
              function p(t) {
                var e, i, n, r, a;
                if ((i = u.get(o[t[0]])))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                if ((i = u.get((e = o[t[0] + y(t)]))))
                  for (r = 0, a = i.length; r < a; ++r) {
                    if (g((n = i[r]), t))
                      return (t[0] = n[0]), void (t[1] = n[1]);
                    if (m(n, t)) return (t[0] = n[1]), void (t[1] = n[0]);
                  }
                i ? i.push(t) : u.set(e, [t]), c.push(t);
              }
              function d(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1];
                if (i - r != n - e[1]) return !1;
                for (; i <= r; ++i, ++n) if (!z1(o[i], o[n])) return !1;
                return !0;
              }
              function f(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1];
                if (i - r != n - a) return !1;
                for (; i <= r; ++i, --a) if (!z1(o[i], o[a])) return !1;
                return !0;
              }
              function g(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1] - i;
                if (r !== e[1] - n) return !1;
                for (var a = y(t), s = y(e), l = 0; l < r; ++l)
                  if (!z1(o[i + ((l + a) % r)], o[n + ((l + s) % r)]))
                    return !1;
                return !0;
              }
              function m(t, e) {
                var i = t[0],
                  n = e[0],
                  r = t[1],
                  a = e[1],
                  s = r - i;
                if (s !== a - n) return !1;
                for (var l = y(t), u = s - y(e), c = 0; c < s; ++c)
                  if (!z1(o[i + ((c + l) % s)], o[a - ((c + u) % s)]))
                    return !1;
                return !0;
              }
              function y(t) {
                for (
                  var e = t[0], i = t[1], n = e, r = n, a = o[n];
                  ++n < i;

                ) {
                  var s = o[n];
                  (s[0] < a[0] || (s[0] === a[0] && s[1] < a[1])) &&
                    ((r = n), (a = s));
                }
                return r - e;
              }
              return t;
            })(
              (function (t) {
                var e,
                  i,
                  n,
                  r = j1(t),
                  o = t.coordinates,
                  a = t.lines,
                  s = t.rings;
                for (i = 0, n = a.length; i < n; ++i)
                  for (var l = a[i], u = l[0], c = l[1]; ++u < c; )
                    r.has(o[u]) &&
                      ((e = {
                        0: u,
                        1: l[1],
                      }),
                      (l[1] = u),
                      (l = l.next = e));
                for (i = 0, n = s.length; i < n; ++i)
                  for (
                    var h = s[i], p = h[0], d = p, f = h[1], g = r.has(o[p]);
                    ++d < f;

                  )
                    r.has(o[d]) &&
                      (g
                        ? ((e = {
                            0: d,
                            1: h[1],
                          }),
                          (h[1] = d),
                          (h = h.next = e))
                        : (H1(o, p, f, f - d),
                          (o[f] = o[p]),
                          (g = !0),
                          (d = p)));
                return t;
              })(
                (function (t) {
                  var e = -1,
                    i = [],
                    n = [],
                    r = [];
                  function o(t) {
                    t && O1.call(a, t.type) && a[t.type](t);
                  }
                  var a = {
                    GeometryCollection: function (t) {
                      t.geometries.forEach(o);
                    },
                    LineString: function (t) {
                      t.arcs = s(t.arcs);
                    },
                    MultiLineString: function (t) {
                      t.arcs = t.arcs.map(s);
                    },
                    Polygon: function (t) {
                      t.arcs = t.arcs.map(l);
                    },
                    MultiPolygon: function (t) {
                      t.arcs = t.arcs.map(u);
                    },
                  };
                  function s(t) {
                    for (var n = 0, o = t.length; n < o; ++n) r[++e] = t[n];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return i.push(a), a;
                  }
                  function l(t) {
                    for (var i = 0, o = t.length; i < o; ++i) r[++e] = t[i];
                    var a = {
                      0: e - o + 1,
                      1: e,
                    };
                    return n.push(a), a;
                  }
                  function u(t) {
                    return t.map(l);
                  }
                  for (var c in t) o(t[c]);
                  return {
                    type: "Topology",
                    coordinates: r,
                    lines: i,
                    rings: n,
                    objects: t,
                  };
                })(t)
              )
            ),
            o = r.coordinates,
            a = F1(1.4 * r.arcs.length, Q1, Z1);
          function s(t) {
            t && O1.call(l, t.type) && l[t.type](t);
          }
          (t = r.objects),
            (r.bbox = i),
            (r.arcs = r.arcs.map(function (t, e) {
              return a.set(t, e), o.slice(t[0], t[1] + 1);
            })),
            delete r.coordinates,
            (o = null);
          var l = {
            GeometryCollection: function (t) {
              t.geometries.forEach(s);
            },
            LineString: function (t) {
              t.arcs = u(t.arcs);
            },
            MultiLineString: function (t) {
              t.arcs = t.arcs.map(u);
            },
            Polygon: function (t) {
              t.arcs = t.arcs.map(u);
            },
            MultiPolygon: function (t) {
              t.arcs = t.arcs.map(c);
            },
          };
          function u(t) {
            var e = [];
            do {
              var i = a.get(t);
              e.push(t[0] < t[1] ? i : ~i);
            } while ((t = t.next));
            return e;
          }
          function c(t) {
            return t.map(u);
          }
          for (var h in t) s(t[h]);
          return (
            n &&
              ((r.transform = n),
              (r.arcs = (function (t) {
                for (var e = -1, i = t.length; ++e < i; ) {
                  for (
                    var n,
                      r,
                      o = t[e],
                      a = 0,
                      s = 1,
                      l = o.length,
                      u = o[0],
                      c = u[0],
                      h = u[1];
                    ++a < l;

                  )
                    (n = (u = o[a])[0]),
                      (r = u[1]),
                      (n === c && r === h) ||
                        ((o[s++] = [n - c, r - h]), (c = n), (h = r));
                  1 === s && (o[s++] = [0, 0]), (o.length = s);
                }
                return t;
              })(r.arcs))),
            r
          );
        },
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  K1 = QZ(J1);
function $1(t) {
  return t;
}
function t2(t) {
  if (null == t) return $1;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u);
    for (c[0] = (e += t[0]) * n + o, c[1] = (i += t[1]) * r + a; l < u; )
      (c[l] = t[l]), ++l;
    return c;
  };
}
function e2(t) {
  var e,
    i = t2(t.transform),
    n = 1 / 0,
    r = n,
    o = -n,
    a = -n;
  function s(t) {
    (t = i(t))[0] < n && (n = t[0]),
      t[0] > o && (o = t[0]),
      t[1] < r && (r = t[1]),
      t[1] > a && (a = t[1]);
  }
  function l(t) {
    switch (t.type) {
      case "GeometryCollection":
        t.geometries.forEach(l);
        break;
      case "Point":
        s(t.coordinates);
        break;
      case "MultiPoint":
        t.coordinates.forEach(s);
    }
  }
  for (e in (t.arcs.forEach(function (t) {
    for (var e, s = -1, l = t.length; ++s < l; )
      (e = i(t[s], s))[0] < n && (n = e[0]),
        e[0] > o && (o = e[0]),
        e[1] < r && (r = e[1]),
        e[1] > a && (a = e[1]);
  }),
  t.objects))
    l(t.objects[e]);
  return [n, r, o, a];
}
function i2(t, e) {
  var i = e.id,
    n = e.bbox,
    r = null == e.properties ? {} : e.properties,
    o = n2(t, e);
  return null == i && null == n
    ? {
        type: "Feature",
        properties: r,
        geometry: o,
      }
    : null == n
    ? {
        type: "Feature",
        id: i,
        properties: r,
        geometry: o,
      }
    : {
        type: "Feature",
        id: i,
        bbox: n,
        properties: r,
        geometry: o,
      };
}
function n2(t, e) {
  var i = t2(t.transform),
    n = t.arcs;
  function r(t, e) {
    e.length && e.pop();
    for (var r = n[t < 0 ? ~t : t], o = 0, a = r.length; o < a; ++o)
      e.push(i(r[o], o));
    t < 0 &&
      (function (t, e) {
        for (var i, n = t.length, r = n - e; r < --n; )
          (i = t[r]), (t[r++] = t[n]), (t[n] = i);
      })(e, a);
  }
  function o(t) {
    return i(t);
  }
  function a(t) {
    for (var e = [], i = 0, n = t.length; i < n; ++i) r(t[i], e);
    return e.length < 2 && e.push(e[0]), e;
  }
  function s(t) {
    for (var e = a(t); e.length < 4; ) e.push(e[0]);
    return e;
  }
  function l(t) {
    return t.map(s);
  }
  return (function t(e) {
    var i,
      n = e.type;
    switch (n) {
      case "GeometryCollection":
        return {
          type: n,
          geometries: e.geometries.map(t),
        };
      case "Point":
        i = o(e.coordinates);
        break;
      case "MultiPoint":
        i = e.coordinates.map(o);
        break;
      case "LineString":
        i = a(e.arcs);
        break;
      case "MultiLineString":
        i = e.arcs.map(a);
        break;
      case "Polygon":
        i = l(e.arcs);
        break;
      case "MultiPolygon":
        i = e.arcs.map(l);
        break;
      default:
        return null;
    }
    return {
      type: n,
      coordinates: i,
    };
  })(e);
}
function r2(t, e) {
  var i = {},
    n = {},
    r = {},
    o = [],
    a = -1;
  function s(t, e) {
    for (var n in t) {
      var r = t[n];
      delete e[r.start],
        delete r.start,
        delete r.end,
        r.forEach(function (t) {
          i[t < 0 ? ~t : t] = 1;
        }),
        o.push(r);
    }
  }
  return (
    e.forEach(function (i, n) {
      var r,
        o = t.arcs[i < 0 ? ~i : i];
      o.length < 3 &&
        !o[1][0] &&
        !o[1][1] &&
        ((r = e[++a]), (e[a] = i), (e[n] = r));
    }),
    e.forEach(function (e) {
      var i,
        o,
        a = (function (e) {
          var i,
            n = t.arcs[e < 0 ? ~e : e],
            r = n[0];
          t.transform
            ? ((i = [0, 0]),
              n.forEach(function (t) {
                (i[0] += t[0]), (i[1] += t[1]);
              }))
            : (i = n[n.length - 1]);
          return e < 0 ? [i, r] : [r, i];
        })(e),
        s = a[0],
        l = a[1];
      if ((i = r[s]))
        if ((delete r[i.end], i.push(e), (i.end = l), (o = n[l]))) {
          delete n[o.start];
          var u = o === i ? i : i.concat(o);
          n[(u.start = i.start)] = r[(u.end = o.end)] = u;
        } else n[i.start] = r[i.end] = i;
      else if ((i = n[l]))
        if ((delete n[i.start], i.unshift(e), (i.start = s), (o = r[s]))) {
          delete r[o.end];
          var c = o === i ? i : o.concat(i);
          n[(c.start = o.start)] = r[(c.end = i.end)] = c;
        } else n[i.start] = r[i.end] = i;
      else n[((i = [e]).start = s)] = r[(i.end = l)] = i;
    }),
    s(r, n),
    s(n, r),
    e.forEach(function (t) {
      i[t < 0 ? ~t : t] || o.push([t]);
    }),
    o
  );
}
function o2(t, e, i) {
  var n, r, o;
  if (arguments.length > 1)
    n = (function (t, e, i) {
      var n,
        r = [],
        o = [];
      function a(t) {
        var e = t < 0 ? ~t : t;
        (o[e] || (o[e] = [])).push({
          i: t,
          g: n,
        });
      }
      function s(t) {
        t.forEach(a);
      }
      function l(t) {
        t.forEach(s);
      }
      function u(t) {
        t.forEach(l);
      }
      function c(t) {
        switch (((n = t), t.type)) {
          case "GeometryCollection":
            t.geometries.forEach(c);
            break;
          case "LineString":
            s(t.arcs);
            break;
          case "MultiLineString":
          case "Polygon":
            l(t.arcs);
            break;
          case "MultiPolygon":
            u(t.arcs);
        }
      }
      return (
        c(e),
        o.forEach(
          null == i
            ? function (t) {
                r.push(t[0].i);
              }
            : function (t) {
                i(t[0].g, t[t.length - 1].g) && r.push(t[0].i);
              }
        ),
        r
      );
    })(0, e, i);
  else for (r = 0, n = new Array((o = t.arcs.length)); r < o; ++r) n[r] = r;
  return {
    type: "MultiLineString",
    arcs: r2(t, n),
  };
}
function a2(t, e) {
  var i = {},
    n = [],
    r = [];
  function o(t) {
    t.forEach(function (e) {
      e.forEach(function (e) {
        (i[(e = e < 0 ? ~e : e)] || (i[e] = [])).push(t);
      });
    }),
      n.push(t);
  }
  function a(e) {
    return (function (t) {
      for (var e, i = -1, n = t.length, r = t[n - 1], o = 0; ++i < n; )
        (e = r), (r = t[i]), (o += e[0] * r[1] - e[1] * r[0]);
      return Math.abs(o);
    })(
      n2(t, {
        type: "Polygon",
        arcs: [e],
      }).coordinates[0]
    );
  }
  return (
    e.forEach(function t(e) {
      switch (e.type) {
        case "GeometryCollection":
          e.geometries.forEach(t);
          break;
        case "Polygon":
          o(e.arcs);
          break;
        case "MultiPolygon":
          e.arcs.forEach(o);
      }
    }),
    n.forEach(function (t) {
      if (!t._) {
        var e = [],
          n = [t];
        for (t._ = 1, r.push(e); (t = n.pop()); )
          e.push(t),
            t.forEach(function (t) {
              t.forEach(function (t) {
                i[t < 0 ? ~t : t].forEach(function (t) {
                  t._ || ((t._ = 1), n.push(t));
                });
              });
            });
      }
    }),
    n.forEach(function (t) {
      delete t._;
    }),
    {
      type: "MultiPolygon",
      arcs: r
        .map(function (e) {
          var n,
            r = [];
          if (
            (e.forEach(function (t) {
              t.forEach(function (t) {
                t.forEach(function (t) {
                  i[t < 0 ? ~t : t].length < 2 && r.push(t);
                });
              });
            }),
            (n = (r = r2(t, r)).length) > 1)
          )
            for (var o, s, l = 1, u = a(r[0]); l < n; ++l)
              (o = a(r[l])) > u &&
                ((s = r[0]), (r[0] = r[l]), (r[l] = s), (u = o));
          return r;
        })
        .filter(function (t) {
          return t.length > 0;
        }),
    }
  );
}
function s2(t, e) {
  for (var i = 0, n = t.length; i < n; ) {
    var r = (i + n) >>> 1;
    t[r] < e ? (i = r + 1) : (n = r);
  }
  return i;
}
function l2(t) {
  if (null == t) return $1;
  var e,
    i,
    n = t.scale[0],
    r = t.scale[1],
    o = t.translate[0],
    a = t.translate[1];
  return function (t, s) {
    s || (e = i = 0);
    var l = 2,
      u = t.length,
      c = new Array(u),
      h = Math.round((t[0] - o) / n),
      p = Math.round((t[1] - a) / r);
    for (c[0] = h - e, e = h, c[1] = p - i, i = p; l < u; ) (c[l] = t[l]), ++l;
    return c;
  };
}
var u2 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bbox: e2,
        feature: function (t, e) {
          return (
            "string" == typeof e && (e = t.objects[e]),
            "GeometryCollection" === e.type
              ? {
                  type: "FeatureCollection",
                  features: e.geometries.map(function (e) {
                    return i2(t, e);
                  }),
                }
              : i2(t, e)
          );
        },
        mesh: function (t) {
          return n2(t, o2.apply(this, arguments));
        },
        meshArcs: o2,
        merge: function (t) {
          return n2(t, a2.apply(this, arguments));
        },
        mergeArcs: a2,
        neighbors: function (t) {
          var e = {},
            i = t.map(function () {
              return [];
            });
          function n(t, i) {
            t.forEach(function (t) {
              t < 0 && (t = ~t);
              var n = e[t];
              n ? n.push(i) : (e[t] = [i]);
            });
          }
          function r(t, e) {
            t.forEach(function (t) {
              n(t, e);
            });
          }
          var o = {
            LineString: n,
            MultiLineString: r,
            Polygon: r,
            MultiPolygon: function (t, e) {
              t.forEach(function (t) {
                r(t, e);
              });
            },
          };
          for (var a in (t.forEach(function t(e, i) {
            "GeometryCollection" === e.type
              ? e.geometries.forEach(function (e) {
                  t(e, i);
                })
              : e.type in o && o[e.type](e.arcs, i);
          }),
          e))
            for (var s = e[a], l = s.length, u = 0; u < l; ++u)
              for (var c = u + 1; c < l; ++c) {
                var h,
                  p = s[u],
                  d = s[c];
                (h = i[p])[(a = s2(h, d))] !== d && h.splice(a, 0, d),
                  (h = i[d])[(a = s2(h, p))] !== p && h.splice(a, 0, p);
              }
          return i;
        },
        quantize: function (t, e) {
          if (t.transform) throw new Error("already quantized");
          if (e && e.scale) s = t.bbox;
          else {
            if (!((i = Math.floor(e)) >= 2)) throw new Error("n must be ≥2");
            var i,
              n = (s = t.bbox || e2(t))[0],
              r = s[1],
              o = s[2],
              a = s[3];
            e = {
              scale: [
                o - n ? (o - n) / (i - 1) : 1,
                a - r ? (a - r) / (i - 1) : 1,
              ],
              translate: [n, r],
            };
          }
          var s,
            l,
            u = l2(e),
            c = t.objects,
            h = {};
          function p(t) {
            return u(t);
          }
          function d(t) {
            var e;
            switch (t.type) {
              case "GeometryCollection":
                e = {
                  type: "GeometryCollection",
                  geometries: t.geometries.map(d),
                };
                break;
              case "Point":
                e = {
                  type: "Point",
                  coordinates: p(t.coordinates),
                };
                break;
              case "MultiPoint":
                e = {
                  type: "MultiPoint",
                  coordinates: t.coordinates.map(p),
                };
                break;
              default:
                return t;
            }
            return (
              null != t.id && (e.id = t.id),
              null != t.bbox && (e.bbox = t.bbox),
              null != t.properties && (e.properties = t.properties),
              e
            );
          }
          for (l in c) h[l] = d(c[l]);
          return {
            type: "Topology",
            bbox: s,
            transform: e,
            objects: h,
            arcs: t.arcs.map(function (t) {
              var e,
                i = 0,
                n = 1,
                r = t.length,
                o = new Array(r);
              for (o[0] = u(t[0], 0); ++i < r; )
                ((e = u(t[i], i))[0] || e[1]) && (o[n++] = e);
              return 1 === n && (o[n++] = [0, 0]), (o.length = n), o;
            }),
          };
        },
        transform: t2,
        untransform: l2,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  c2 = QZ(u2);
K1.topology, c2.merge;
var h2 = function (t, e) {
  (this.p1 = t), (this.p2 = e);
};
(h2.prototype.rise = function () {
  return this.p2[1] - this.p1[1];
}),
  (h2.prototype.run = function () {
    return this.p2[0] - this.p1[0];
  }),
  (h2.prototype.slope = function () {
    return this.rise() / this.run();
  }),
  (h2.prototype.yIntercept = function () {
    return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
  }),
  (h2.prototype.isVertical = function () {
    return !isFinite(this.slope());
  }),
  (h2.prototype.isHorizontal = function () {
    return this.p1[1] == this.p2[1];
  }),
  (h2.prototype._perpendicularDistanceHorizontal = function (t) {
    return Math.abs(this.p1[1] - t[1]);
  }),
  (h2.prototype._perpendicularDistanceVertical = function (t) {
    return Math.abs(this.p1[0] - t[0]);
  }),
  (h2.prototype._perpendicularDistanceHasSlope = function (t) {
    var e = this.slope(),
      i = this.yIntercept();
    return Math.abs(e * t[0] - t[1] + i) / Math.sqrt(Math.pow(e, 2) + 1);
  }),
  (h2.prototype.perpendicularDistance = function (t) {
    return this.isVertical()
      ? this._perpendicularDistanceVertical(t)
      : this.isHorizontal()
      ? this._perpendicularDistanceHorizontal(t)
      : this._perpendicularDistanceHasSlope(t);
  });
var p2,
  d2 = h2,
  f2 = function (t, e) {
    for (var i = 0, n = 0, r = 1; r <= t.length - 2; r++) {
      var o = new d2(t[0], t[t.length - 1]).perpendicularDistance(t[r]);
      o > i && ((n = r), (i = o));
    }
    if (i > e)
      var a = f2(t.slice(0, n), e),
        s = f2(t.slice(n, t.length), e),
        l = a.concat(s);
    else l = t.length > 1 ? [t[0], t[t.length - 1]] : [t[0]];
    return l;
  },
  g2 = f2;
!(function (t) {
  var e = g2;
  function i(e, i) {
    var n = e.geometry,
      r = n.type;
    if ("LineString" === r)
      n.coordinates = t.exports.simplify(n.coordinates, i);
    else if ("Polygon" === r || "MultiLineString" === r)
      for (var o = 0; o < n.coordinates.length; o++)
        n.coordinates[o] = t.exports.simplify(n.coordinates[o], i);
    else if ("MultiPolygon" === r)
      for (var a = 0; a < n.coordinates.length; a++)
        for (var s = 0; s < n.coordinates[a].length; s++)
          n.coordinates[a][s] = t.exports.simplify(n.coordinates[a][s], i);
    return e;
  }
  (t.exports = function (t, e, n) {
    return (
      n || (t = JSON.parse(JSON.stringify(t))),
      t.features
        ? (function (t, e) {
            for (var n = 0; n < t.features.length; n++)
              t.features[n] = i(t.features[n], e);
            return t;
          })(t, e)
        : t.type && "Feature" === t.type
        ? i(t, e)
        : new Error("FeatureCollection or individual Feature required")
    );
  }),
    (t.exports.simplify = function (t, i) {
      return e(t, i);
    });
})({
  exports: {},
}),
  (function (t) {
    (t.contain = "contain"),
      (t.intersect = "intersect"),
      (t.intersectClip = "intersectClip"),
      (t.none = "none");
  })(p2 || (p2 = {}));
for (let p7 = 0; p7 < 256; p7++) p7.toString(16);
var m2 = {
  exports: {},
};
!(function (t) {
  var e = Object.prototype.hasOwnProperty,
    i = "~";
  function n() {}
  function r(t, e, i) {
    (this.fn = t), (this.context = e), (this.once = i || !1);
  }
  function o(t, e, n, o, a) {
    if ("function" != typeof n)
      throw new TypeError("The listener must be a function");
    var s = new r(n, o || t, a),
      l = i ? i + e : e;
    return (
      t._events[l]
        ? t._events[l].fn
          ? (t._events[l] = [t._events[l], s])
          : t._events[l].push(s)
        : ((t._events[l] = s), t._eventsCount++),
      t
    );
  }
  function a(t, e) {
    0 == --t._eventsCount ? (t._events = new n()) : delete t._events[e];
  }
  function s() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (i = !1)),
    (s.prototype.eventNames = function () {
      var t,
        n,
        r = [];
      if (0 === this._eventsCount) return r;
      for (n in (t = this._events)) e.call(t, n) && r.push(i ? n.slice(1) : n);
      return Object.getOwnPropertySymbols
        ? r.concat(Object.getOwnPropertySymbols(t))
        : r;
    }),
    (s.prototype.listeners = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      if (!n) return [];
      if (n.fn) return [n.fn];
      for (var r = 0, o = n.length, a = new Array(o); r < o; r++)
        a[r] = n[r].fn;
      return a;
    }),
    (s.prototype.listenerCount = function (t) {
      var e = i ? i + t : t,
        n = this._events[e];
      return n ? (n.fn ? 1 : n.length) : 0;
    }),
    (s.prototype.emit = function (t, e, n, r, o, a) {
      var s = i ? i + t : t;
      if (!this._events[s]) return !1;
      var l,
        u,
        c = this._events[s],
        h = arguments.length;
      if (c.fn) {
        switch ((c.once && this.removeListener(t, c.fn, void 0, !0), h)) {
          case 1:
            return c.fn.call(c.context), !0;
          case 2:
            return c.fn.call(c.context, e), !0;
          case 3:
            return c.fn.call(c.context, e, n), !0;
          case 4:
            return c.fn.call(c.context, e, n, r), !0;
          case 5:
            return c.fn.call(c.context, e, n, r, o), !0;
          case 6:
            return c.fn.call(c.context, e, n, r, o, a), !0;
        }
        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
        c.fn.apply(c.context, l);
      } else {
        var p,
          d = c.length;
        for (u = 0; u < d; u++)
          switch (
            (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), h)
          ) {
            case 1:
              c[u].fn.call(c[u].context);
              break;
            case 2:
              c[u].fn.call(c[u].context, e);
              break;
            case 3:
              c[u].fn.call(c[u].context, e, n);
              break;
            case 4:
              c[u].fn.call(c[u].context, e, n, r);
              break;
            default:
              if (!l)
                for (p = 1, l = new Array(h - 1); p < h; p++)
                  l[p - 1] = arguments[p];
              c[u].fn.apply(c[u].context, l);
          }
      }
      return !0;
    }),
    (s.prototype.on = function (t, e, i) {
      return o(this, t, e, i, !1);
    }),
    (s.prototype.once = function (t, e, i) {
      return o(this, t, e, i, !0);
    }),
    (s.prototype.removeListener = function (t, e, n, r) {
      var o = i ? i + t : t;
      if (!this._events[o]) return this;
      if (!e) return a(this, o), this;
      var s = this._events[o];
      if (s.fn)
        s.fn !== e || (r && !s.once) || (n && s.context !== n) || a(this, o);
      else {
        for (var l = 0, u = [], c = s.length; l < c; l++)
          (s[l].fn !== e || (r && !s[l].once) || (n && s[l].context !== n)) &&
            u.push(s[l]);
        u.length ? (this._events[o] = 1 === u.length ? u[0] : u) : a(this, o);
      }
      return this;
    }),
    (s.prototype.removeAllListeners = function (t) {
      var e;
      return (
        t
          ? ((e = i ? i + t : t), this._events[e] && a(this, e))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prefixed = i),
    (s.EventEmitter = s),
    (t.exports = s);
})(m2);
var y2,
  v2,
  b2 = m2.exports;
if (!window) throw Error("AMap JSAPI can only be used in Browser.");
((v2 = y2 || (y2 = {})).notload = "notload"),
  (v2.loading = "loading"),
  (v2.loaded = "loaded"),
  (v2.failed = "failed");
let x2 = {
    key: "",
    AMap: {
      version: "2.0",
      plugins: [],
    },
  },
  _2 = {
    AMap: y2.notload,
  };
const S2 = [],
  M2 = (t) =>
    new Promise((e, i) => {
      if (_2.AMap == y2.failed) i("");
      else if (_2.AMap == y2.notload) {
        const { key: n, version: r, plugins: o } = t;
        if (!n) return void i("请填写key");
        (x2.key = n),
          (x2.AMap.version = r || x2.AMap.version),
          (x2.AMap.plugins = o || x2.AMap.plugins),
          (_2.AMap = y2.loading);
        const a = document.body || document.head;
        window.___onAPILoaded = (t) => {
          if ((delete window.___onAPILoaded, t)) (_2.AMap = y2.failed), i(t);
          else
            for (_2.AMap = y2.loaded, e(window.AMap); S2.length; )
              S2.splice(0, 1)[0]();
        };
        const s = document.createElement("script");
        (s.type = "text/javascript"),
          (s.src =
            "https://webapi.amap.com/maps?callback=___onAPILoaded&v=" +
            x2.AMap.version +
            "&key=" +
            n +
            "&plugin=" +
            x2.AMap.plugins.join(",")),
          (s.onerror = (t) => {
            (_2.AMap = y2.failed), i(t);
          }),
          a.appendChild(s);
      } else if (_2.AMap == y2.loaded) {
        if (
          (t.key && (t.key, x2.key), t.version && t.version !== x2.AMap.version)
        )
          return void i("不允许多个版本 JSAPI 混用");
        const n = [];
        if (t.plugins)
          for (let e = 0; e < t.plugins.length; e += 1)
            -1 == x2.AMap.plugins.indexOf(t.plugins[e]) && n.push(t.plugins[e]);
        n.length
          ? window.AMap.plugin(n, () => {
              e(window.AMap);
            })
          : e(window.AMap);
      } else {
        if (
          (t.key && (t.key, x2.key), t.version && t.version !== x2.AMap.version)
        )
          return void i("不允许多个版本 JSAPI 混用");
        const r = [];
        if (t.plugins)
          for (let e = 0; e < t.plugins.length; e += 1)
            -1 == x2.AMap.plugins.indexOf(t.plugins[e]) && r.push(t.plugins[e]);
        (n = () => {
          r.length
            ? window.AMap.plugin(r, () => {
                e(window.AMap);
              })
            : e(window.AMap);
        }),
          _2.AMap !== y2.loaded ? S2.push(n) : n(window.AMap);
      }
      var n;
    });
function C2() {
  delete window.AMap,
    (x2 = {
      key: "",
      AMap: {
        version: "2.0",
        plugins: [],
      },
    }),
    (_2 = {
      AMap: y2.notload,
    });
}
const w2 = {
    darkblue: "amap://styles/darkblue",
    dark: "amap://styles/dark",
    light: "amap://styles/light",
    normal: "amap://styles/normal",
    whitesmoke: "amap://styles/whitesmoke",
    grey: "amap://styles/grey",
    fresh: "amap://styles/fresh",
    graffiti: "amap://styles/graffiti",
    macaron: "amap://styles/macaron",
    blue: "amap://styles/blue",
    wine: "amap://styles/wine",
  },
  A2 = "255b6b2933a0084ac1ea75faf6994e47",
  E2 = {
    id: "map",
    key: A2,
    securityJsCode: "22658a511592b5249bf6a69b9911e149",
    style: w2.darkblue,
    filter: {
      enabled: !1,
      brightness: 1,
      contrast: 1,
      grayscale: 0,
      hueRotate: 328,
      invert: 0,
      saturate: 0.5,
      sepia: 0,
    },
    viewMode: "3D",
    center: [116.333926, 39.997245],
    zoom: 2,
    pitch: 0,
    rotation: 0,
    version: "2.1Beta",
    plugin: [],
    minZoom: 2,
    maxZoom: 20,
    features: ["bg", "road", "point"],
    dragEnable: !0,
    zoomEnable: !0,
    rotateEnable: !0,
    pitchEnable: !0,
    keyboardEnable: !1,
    doubleClickZoom: !1,
    showLabel: !0,
    terrain: !1,
    showIndoorMap: !1,
    resizeEnable: !0,
    layers: {
      nebula: {
        zIndex: 0,
        visible: !0,
        zooms: [2, 26],
      },
      traffic: {
        autoRefresh: !0,
        interval: 60,
        zooms: [7, 26],
        dataZooms: [7, 17],
        opacity: 1,
        visible: !1,
        zIndex: 4,
      },
      roadnet: {
        tileUrl:
          "http://wprd0{1,2,3,4}.is.autonavi.com/appmaptile?x=[x]&y=[y]&z=[z]&lang=zh_cn&size=1&scl=1&style=8&ltype=11",
        zIndex: 3,
        tileSize: 256,
        opacity: 1,
        zooms: [2, 26],
        dataZooms: [3, 18],
        visible: !1,
      },
      satellite: {
        tileUrl:
          "http://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=6&x=[x]&y=[y]&z=[z]",
        zIndex: 2,
        tileSize: 256,
        opacity: 1,
        zooms: [2, 26],
        dataZooms: [3, 18],
        visible: !1,
      },
      buildings: {
        zIndex: 10,
        opacity: 1,
        heightFactor: 2,
        zooms: [17, 20],
        visible: !1,
      },
      indoorMap: {
        zIndex: 1e3,
        opacity: 1,
        hideFloorBar: !1,
        visible: !1,
      },
    },
  };
let D2 = 0;
class T2 extends b2 {
  constructor(t) {
    super(),
      (this.props = t),
      (this.id = (function () {
        let t = new Date().getTime();
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
          /[xy]/g,
          function (e) {
            const i = (t + 16 * Math.random()) % 16 | 0;
            return (
              (t = Math.floor(t / 16)),
              ("x" === e ? i : (3 & i) | 8).toString(16)
            );
          }
        );
      })()),
      (this.__cb = []),
      (this.__isReady = !1),
      (this.__destroyed = !1),
      (this.version = XZ),
      (this.layers = {}),
      this.__init();
  }
  async __init() {
    await new Promise((t) => {
      this.state = C1(E2, this.props);
      const {
        key: e,
        securityJsCode: i,
        version: n,
        plugin: r,
        id: o,
        mapInstance: a,
      } = this.state;
      a
        ? console.error("[xGis]", "暂不支持直接传入 amap 实例")
        : (i &&
            (window._AMapSecurityConfig = {
              securityJsCode: i,
            }),
          (this.__mapContainer = this.__creatAmapContainer(o)),
          M2({
            key: e,
            version: n,
            plugins: r,
          })
            .then((e) => {
              if (this.__destroyed) return;
              if (!this.__mapContainer || !this.__mapContainer.isConnected)
                return void console.error(
                  "[xGis]",
                  "GaodeMap containerDom is required"
                );
              const {
                  style: i,
                  zoom: n,
                  pitch: r,
                  filter: o,
                  rotation: a,
                  center: s,
                  minZoom: l,
                  maxZoom: u,
                  viewMode: c,
                  features: h,
                  dragEnable: p,
                  zoomEnable: d,
                  rotateEnable: f,
                  pitchEnable: g,
                  keyboardEnable: m,
                  doubleClickZoom: y,
                  showIndoorMap: v,
                  resizeEnable: b,
                  showLabel: x,
                  mask: _,
                  terrain: S,
                } = this.state,
                M = this.__initLayers();
              (this.__map = new e.Map(this.__mapContainer, {
                zoom: n,
                pitch: r,
                rotation: a,
                zooms: [l, u],
                center: s,
                layers: M,
                terrain: S,
                features: h,
                viewMode: c,
                mapStyle: this.__getMapStyle(i),
                dragEnable: p,
                zoomEnable: d,
                rotateEnable: f,
                pitchEnable: g,
                keyboardEnable: m,
                doubleClickZoom: y,
                showIndoorMap: v,
                resizeEnable: b,
                showLabel: x,
                mask: _,
              })),
                this.setFilter(o),
                this.__map.on("firstPaint", () => {
                  requestAnimationFrame(() => {
                    this.emit("firstPaintEnd");
                  });
                }),
                (this.__isReady = !0),
                setTimeout(() => {
                  for (let t = 0; t < this.__cb.length; t++) this.__cb[t](this);
                  (this.__cb = []), t();
                }, 0);
            })
            .catch((t) => {
              console.error("[xGis]", t);
            }));
    });
  }
  __initLayers() {
    return (
      (this.layers.nebula = AMap.createDefaultLayer
        ? new AMap.createDefaultLayer(this.state.layers.nebula)
        : new AMap.TileLayer(this.state.layers.nebula)),
      (this.layers.satellite = new AMap.TileLayer.Satellite(
        this.state.layers.satellite
      )),
      (this.layers.roadnet = new AMap.TileLayer.RoadNet(
        this.state.layers.roadnet
      )),
      (this.layers.traffic = new AMap.TileLayer.Traffic(
        this.state.layers.traffic
      )),
      (this.layers.buildings = new AMap.BuildingLayer(
        this.state.layers.buildings
      )),
      (this.layers.indoorMap = new AMap.IndoorMap(this.state.layers.indoorMap)),
      this.state.layers.roadnet.visible ||
        setTimeout(() => {
          this.layers.roadnet.hide();
        }, 0),
      this.state.layers.indoorMap.visible ||
        setTimeout(() => {
          this.layers.indoorMap.hide();
        }, 0),
      [
        this.layers.nebula,
        this.layers.satellite,
        this.layers.roadnet,
        this.layers.traffic,
        this.layers.buildings,
        this.layers.indoorMap,
      ]
    );
  }
  __creatAmapContainer(t) {
    let e = t;
    if (("string" == typeof t && (e = document.getElementById(t)), !e))
      return void console.error("[xGis]", `Error: 传入 ${t} 无对应 dom`);
    const i = document.createElement("div");
    return (
      (i.style.cssText +=
        "\n      position: absolute;\n      top: 0;\n      height: 100%;\n      width: 100%;\n      // background-image: none !important ;\n      background: transparent !important;\n    "),
      (i.id = "gis_amap_div" + D2++),
      e.appendChild(i),
      i
    );
  }
  show(t) {
    if ("label" === t) (this.__map.showLabel = !0), this.__map.render();
    else this.layers[t].show();
  }
  hide(t) {
    if ("label" === t) (this.__map.showLabel = !1), this.__map.render();
    else this.layers[t].hide();
  }
  __getMapStyle(t) {
    return w2[t] ? w2[t] : t;
  }
  getContainer() {
    return this.__mapContainer;
  }
  getType() {
    return "amap";
  }
  setMapStyle(t) {
    var e;
    (this.state = C1(this.state, {
      style: t,
    })),
      null == (e = this.__map) || e.setMapStyle(this.__getMapStyle(t));
  }
  getZooms() {
    return this.__map
      ? this.__map.getZooms()
      : [this.state.minZoom, this.state.maxZoom];
  }
  getMaxPitch() {
    return 80;
  }
  setZoom(t, e = !1) {
    var i;
    (this.state = C1(this.state, {
      zoom: t,
    })),
      null == (i = this.__map) || i.setZoom(t, e);
  }
  setCenter(t, e = !1) {
    var i;
    (this.state = C1(this.state, {
      center: t,
    })),
      null == (i = this.__map) || i.setCenter(t, e);
  }
  setPitch(t, e = !1) {
    var i;
    (this.state = C1(this.state, {
      pitch: t,
    })),
      null == (i = this.__map) || i.setPitch(t, e);
  }
  setFilter(t) {
    var e;
    this.state = C1(this.state, {
      filter: t,
    });
    !(function (t, e) {
      if (!t)
        return void console.error(
          "[xGis]",
          "container 不存在，无法设置风格滤镜"
        );
      const i = C1(T1, e),
        {
          brightness: n,
          contrast: r,
          grayscale: o,
          invert: a,
          saturate: s,
          sepia: l,
          hueRotate: u,
        } = i.enabled ? i : T1,
        c = `\n    brightness( ${n} )\n    contrast( ${r} )\n    grayscale( ${o} )\n    hue-rotate( ${u}deg )\n    invert( ${a} )\n    saturate( ${s} )\n    sepia( ${l} )`;
      t.style.filter = c;
    })(
      null == (e = this.__mapContainer)
        ? void 0
        : e.getElementsByClassName("amap-maps")[0],
      t
    );
  }
  setRotation(t, e = !1) {
    var i;
    (this.state = C1(this.state, {
      rotation: t,
    })),
      null == (i = this.__map) || i.setRotation(t, e);
  }
  then(t) {
    this.__isReady ? t(this) : this.__cb.push(t);
  }
  destroy() {
    var t, e, i, n, r;
    this.__destroyed ||
      ((this.__destroyed = !0),
      this.__map &&
        (this.__map.removeLayer(this.layers.nebula),
        this.__map.removeLayer(this.layers.satellite),
        this.__map.removeLayer(this.layers.roadnet),
        this.__map.removeLayer(this.layers.traffic),
        this.__map.removeLayer(this.layers.buildings),
        this.__map.removeLayer(this.layers.indoorMap),
        this.layers.nebula.destroy(),
        this.layers.satellite.destroy(),
        this.layers.roadnet.destroy(),
        this.layers.traffic.destroy(),
        this.layers.buildings.destroy(),
        this.layers.indoorMap.destroy(),
        this.__map.clearInfoWindow(),
        this.__map.clearLimitBounds(),
        this.__map.clearMap(),
        ("2.0" !== this.state.version && "2.1Beta" !== this.state.version) ||
          null ==
            (n =
              null ==
              (i =
                null == (e = null == (t = this.__map) ? void 0 : t.getContext())
                  ? void 0
                  : e.gl)
                ? void 0
                : i.getExtension("WEBGL_lose_context")) ||
          n.loseContext(),
        this.__map.destroy(),
        (this.__map.gl = null),
        (this.__map = null)),
      null == (r = this.__mapContainer) || r.remove(),
      (this.__mapContainer = null),
      (this.layers = null),
      (this.state = null),
      this.destroyAMapLoader());
  }
  destroyAMapLoader() {
    C2();
  }
}
class P2 {
  constructor({ executeCallback: t, revokeCallback: e }) {
    Object.defineProperty(this, "executeCallback", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0,
    }),
      Object.defineProperty(this, "revokeCallback", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.executeCallback = t),
      (this.revokeCallback = e);
  }
  execute() {
    this.executeCallback();
  }
  revoke() {
    this.revokeCallback();
  }
}
const L2 = new Map();
function I2(t) {
  var e;
  switch (t) {
    case hX.CHINA_GIS:
      return jX[null !== (e = x.getLocaleId()) && void 0 !== e ? e : "zh_CN"];
    case hX.WOLRD_GIS:
      return "zh_CN" !== x.getLocaleId() && WX[x.getLocaleId()]
        ? WX[x.getLocaleId()]
        : {};
    case hX.CUSTOM_GIS:
    default:
      return {};
  }
}
var N2, R2;
((R2 = N2 || (N2 = {}))[(R2.NONE = 0)] = "NONE"),
  (R2[(R2.ONCE = 1)] = "ONCE"),
  (R2[(R2.LOOP = 2)] = "LOOP");
class O2 extends z {
  constructor(t, e) {
    super(t, e),
      Object.defineProperty(this, "lastDrillAdCode", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null,
      }),
      Object.defineProperty(this, "tickMode", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: N2.NONE,
      }),
      Object.defineProperty(this, "tickTime", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "tickId", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "comboTimer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "comboTimeout", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 200,
      }),
      Object.defineProperty(this, "drillEndCallback", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [],
      }),
      Object.defineProperty(this, "drillStartCallback", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [],
      }),
      Object.defineProperty(this, "preWidth", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "preHeight", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "currentSlice", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null,
      }),
      Object.defineProperty(this, "preViewportConfig", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "editingPlot", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {},
      }),
      Object.defineProperty(this, "isInit", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "isInitGis", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "isInitAmap", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "isInitNanhai", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "drillRange", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: [0, 3],
      }),
      Object.defineProperty(this, "propsWatch", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "preProperties", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {},
      }),
      Object.defineProperty(this, "needDelayInit", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "elementDisplayObserver", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null,
      }),
      Object.defineProperty(this, "lastCustomData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "lastRegion", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "needUpgradeViewport", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "asyncFontsTask", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {
          gis: !1,
          nanhai: !1,
        },
      }),
      Object.defineProperty(this, "previousConfig", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "gisContextMapKey", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "interactionOperationEmit", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: _(() => {
          var t;
          if (
            !(null === (t = this.variableContext) || void 0 === t
              ? void 0
              : t.gis)
          )
            return;
          const e = this.getRawViewportConfig();
          if (this.POMNode.operationEmit) {
            const t = new P2({
              executeCallback: () => {
                this.setViewportConfig(e);
              },
              revokeCallback: () => {
                this.setViewportConfig(this.preViewportConfig);
              },
            });
            this.POMNode.operationEmit(t);
          }
          this.preViewportConfig = e;
        }, 200),
      }),
      Object.defineProperty(this, "drill", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: async (t) => {
          if ("-1" === t) this.drillUp();
          else if (rQ(t)) await this.drillUp(ZY);
          else if (t.includes($Y)) {
            const e = t.split($Y)[1];
            this.variableContext.regionData[e] && (await this.drillRegion(e));
          } else {
            const e = await nQ(t, this.variableContext.gis);
            await this.drillDownSingle(e);
          }
        },
      }),
      Object.defineProperty(this, "drillUp", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: async (t) => {
          var e;
          const { baseMapLayer: i } =
            null === (e = this.variableContext.gis) || void 0 === e
              ? void 0
              : e.layerManager;
          await i.drillUp(t, () => {});
        },
      }),
      (this.propsWatch = AZ.createPropsWatch()),
      this.initPropsWatchRule(),
      this.observeElementDisplay();
  }
  render(t) {
    super.render(t);
    const e =
      this.POMNode.width !== this.preWidth ||
      this.POMNode.height !== this.preHeight;
    if (t || !1 !== this.isInit || !e)
      if (t || !1 === this.isInit) {
        let t;
        switch (
          (this.editMode === g.View
            ? (this.gisContextMapKey = `${this.renderer.getScreenId()}-${
                this.POMNode.id
              }`)
            : (this.gisContextMapKey = this.POMNode.id),
          this.upgradeCompatible(),
          this.POMNode.renderType)
        ) {
          case hX.CHINA_GIS:
            t = PX.presets;
            break;
          case hX.WOLRD_GIS:
            t = yQ.presets;
            break;
          case hX.CUSTOM_GIS:
            t = gQ.presets;
        }
        if (
          ((this.POMNode.properties = IX(t, this.POMNode.properties)),
          !UZ(this))
        )
          return void (this.needDelayInit = !0);
        const e = L2.get(this.gisContextMapKey);
        this.editMode === g.View && e ? this.animateInit() : this.createInit(),
          this.POMNode.viz || (this.POMNode.viz = {});
      } else
        this.isInit &&
          (e
            ? ((this.preWidth = this.POMNode.width),
              (this.preHeight = this.POMNode.height))
            : this.update());
  }
  upgradeCompatible() {
    !this.POMNode.properties.viewport &&
      this.POMNode.data.viewportConfig &&
      (this.needUpgradeViewport = !0);
  }
  observeElementDisplay() {
    const t = this.dom;
    (this.elementDisplayObserver = new MutationObserver((t) => {
      t.forEach((t) => {
        var e = t.target;
        e &&
          "block" == e.style.display &&
          this.needDelayInit &&
          (this.render(!0), (this.needDelayInit = !1));
      });
    })),
      this.elementDisplayObserver.observe(t, {
        attributes: !0,
        childList: !1,
        subtree: !1,
        attributeOldValue: !1,
        attributeFilter: ["style"],
      });
  }
  createInit() {
    (this.dom.innerHTML = ""), this.clearError(), this.initState();
    const t = document.createElement("div"),
      e = document.createElement("div");
    (e.style.width = "100%"),
      (e.style.height = "100%"),
      (e.style.willChange = "width,height"),
      (this.variableContext = {
        ...this.variableContext,
        div: e,
        ghostDiv: t,
        tipsPool: {},
        gis: null,
        amapLayer: null,
        nanhaiLayer: null,
        regionData: {},
      }),
      this.dom.append(e),
      this.initGis();
  }
  animateInit() {
    var t;
    (this.currentSlice = this.POMNode.slices[0]),
      (this.preViewportConfig = this.POMNode.data.viewportConfig),
      this.POMNode.slices.forEach((t) => {
        t.editingSpace = "gisSurface";
      });
    const e = L2.get(this.gisContextMapKey);
    (this.variableContext = e),
      this.dom.append(this.variableContext.div),
      null === (t = this.variableContext.gis) ||
        void 0 === t ||
        t.tickSystem.start(),
      this.initHandle();
  }
  initState() {
    var t;
    (this.isInit = !1),
      (this.isInitGis = !1),
      (this.isInitAmap = !1),
      (this.isInitNanhai = !1),
      (this.lastDrillAdCode = null),
      (this.drillEndCallback = []),
      (this.drillStartCallback = []),
      null === (t = this.variableContext.gis) || void 0 === t || t.destroy(),
      (this.variableContext = {
        ...this.variableContext,
        div: null,
        ghostDiv: null,
        tipsPool: {},
        gis: null,
        amapLayer: null,
        nanhaiLayer: null,
        regionData: {},
      }),
      (this.preProperties = u(this.properties)),
      (this.preWidth = this.POMNode.width),
      (this.preHeight = this.POMNode.height),
      (this.currentSlice = this.POMNode.slices[0]),
      (this.preViewportConfig = this.POMNode.data.viewportConfig),
      this.POMNode.slices.forEach((t) => {
        t.editingSpace = "gisSurface";
      });
  }
  getRealDPR() {
    return (
      (window.devicePixelRatio ? window.devicePixelRatio : 1) *
      this.renderer.getScale()[0]
    );
  }
  async initGis() {
    const {
        amap: { enable: e },
        nanhai: { enable: i },
      } = this.properties,
      { div: n } = this.variableContext,
      r = {
        common: {
          visible: !1,
        },
        districtStyle: {
          heightScale: 0,
          bottomStroke: {
            width: 0,
          },
        },
        data: await this.getDataConfig(),
        drill: await this.getDrillConfig(),
        viewClip: this.getViewClipConfig(),
        poi: {
          major: {
            aliasMap: I2(this.POMNode.renderType),
          },
        },
      },
      o = {
        containerDom: n,
        globalVariable:
          this.editMode === g.Edit ||
          window.location.href.includes("showToolbar=true"),
        viewportConfig: this.getViewportConfig(),
        lightConfig: this.getLightConfig(),
        sceneConfig: IX(
          {
            logo: {
              visible: !1,
            },
            background: {
              transparent: !0,
            },
          },
          this.getSceneConfig()
        ),
        baseMapLayer: IX(r, this.getBaseLayerConfig()),
      };
    (this.variableContext.gis = new IW(o)),
      this.variableContext.gis
        .then(() => {
          var n;
          if (((this.isInitGis = !0), this.needUpgradeViewport)) {
            const e =
              null === (n = this.variableContext.gis) || void 0 === n
                ? void 0
                : n.viewportSystem.get();
            (this.POMNode.properties.viewport = {
              centerLng: t(e.center[0], 6),
              centerLat: t(e.center[1], 6),
              zoom: t(e.zoom, 2),
              pitch: t(e.pitch, 0),
              rotation: t(e.rotation, 0),
            }),
              (this.needUpgradeViewport = !1);
          }
          e || i || this.initHandle(),
            i && this.setNanhaiEnable(),
            e && this.setAMapEnable();
        })
        .catch((t) => {
          let e = t.message;
          if ("地图数据加载失败" === e)
            e = S("地图数据加载失败，请确保地图数据源配置正常");
          this.renderGisError(e);
        });
  }
  renderGisError(t) {
    const e = new y(v.RenderError, t);
    this.variableContext &&
      ((this.variableContext.tipsPool[this.POMNode.id] = e), this.renderTips()),
      console.error(t);
  }
  tickOnce() {
    this.editMode !== g.View &&
      this.tickMode === N2.NONE &&
      ((this.tickMode = N2.ONCE),
      (this.tickId = window.requestAnimationFrame(() => {
        if (this.variableContext) {
          const { gis: t } = this.variableContext;
          null == t || t.tickSystem.tick();
        }
        this.tickMode = N2.NONE;
      })));
  }
  tickLoop(t) {
    if (this.editMode !== g.View)
      if (this.tickMode !== N2.LOOP) {
        const e = Date.now(),
          i = () => {
            this.tickTime < 4e3
              ? ((this.tickMode = N2.LOOP),
                (this.tickId = window.requestAnimationFrame(() => {
                  if (this.variableContext) {
                    const { gis: t } = this.variableContext;
                    null == t || t.tickSystem.tick();
                  }
                  const t = Date.now();
                  (this.tickTime = t - e), i();
                })))
              : ((this.tickTime = 0), (this.tickMode = N2.NONE), t && t());
          };
        i();
      } else this.tickTime = 0;
  }
  initHandle(t = !0) {
    var e;
    const { gis: i } = this.variableContext;
    this.asyncFontsTask.gis && this.updateGisFonts(),
      this.asyncFontsTask.nanhai && this.updateNanhaiFonts(),
      this.editMode !== g.View &&
        (null == i || i.tickSystem.pause(), this.tickLoop()),
      this.renderLayer(),
      M(this.preViewportConfig) &&
        (this.preViewportConfig =
          null === (e = this.variableContext.gis) || void 0 === e
            ? void 0
            : e.viewportSystem.get()),
      this.initEventListener(),
      (this.isInit = !0),
      s.call(this, b.Loaded),
      L2.set(this.gisContextMapKey, this.variableContext);
  }
  initEventListener() {
    const { gis: t } = this.variableContext;
    null == t ||
      t.on("resize", (e) => {
        var i;
        e.width &&
          e.height &&
          (this.setViewportConfig(),
          null == t || t.layerManager.baseMapLayer.scaleAdaptation(!1),
          null === (i = this.POMNode) ||
            void 0 === i ||
            i.slices.forEach((t) => {
              t.children
                .filter(
                  (t) =>
                    "@dp/aeolian-package-geography://informationLabel" ===
                    t.renderType
                )
                .forEach((t) => {
                  var e;
                  null === (e = t.layer) ||
                    void 0 === e ||
                    e.updateLayerInteractive();
                });
            }),
          this.tickOnce());
      }),
      null == t ||
        t.layerManager.baseMapLayer.on("click", (e) => {
          var i;
          if (this.comboTimer)
            if (
              (clearTimeout(this.comboTimer),
              (this.comboTimer = setTimeout(() => {
                this.comboTimer = void 0;
              }, this.comboTimeout)),
              e)
            ) {
              let n = e.properties.alias;
              const r =
                !(null == t
                  ? void 0
                  : t.layerManager.baseMapLayer.currentRegion) &&
                Object.values(this.variableContext.regionData).find((t) =>
                  t.child.includes(e.properties.id)
                );
              r && (n = $Y + r.name);
              const o =
                null !== (i = t.layerManager.baseMapLayer.currentLevel) &&
                void 0 !== i
                  ? i
                  : iX.country;
              s.call(this, b.AreaDbClick, {
                region: n,
                currentLevel: o,
                maxLevel: 4,
              });
            } else s.call(this, b.OutSideAreaDbClick, {});
          else
            this.comboTimer = setTimeout(() => {
              var i;
              if (((this.comboTimer = void 0), e)) {
                let n = e.properties.alias;
                const r =
                  !(null == t
                    ? void 0
                    : t.layerManager.baseMapLayer.currentRegion) &&
                  Object.values(this.variableContext.regionData).find((t) =>
                    t.child.includes(e.properties.id)
                  );
                r && (n = $Y + r.name);
                const o =
                  null !== (i = t.layerManager.baseMapLayer.currentLevel) &&
                  void 0 !== i
                    ? i
                    : iX.country;
                s.call(this, b.AreaClick, {
                  region: n,
                  currentLevel: o,
                  maxLevel: 4,
                });
              } else s.call(this, b.OutSideAreaClick, {});
            }, this.comboTimeout);
        }),
      null == t ||
        t.layerManager.baseMapLayer.on("drill", async (t) => {
          this.setNanhaiVisible(t.properties.currentCode),
            this.drillStartCallback.forEach((e) => e(t.properties.currentCode));
        }),
      null == t ||
        t.layerManager.baseMapLayer.on("drillEnd", async (t) => {
          this.storeViewport(),
            this.drillEndCallback.forEach((e) => e(t.properties.currentCode));
        }),
      null == t ||
        t.controlsSystem.controls.addEventListener(
          "start",
          this.interactionOperationEmit
        ),
      this.editMode !== g.View &&
        (null == t ||
          t.on("viewportChange", () => {
            "gisSurface" === this.renderer.page.editingSpace && this.tickOnce();
          }));
  }
  clearEventListener() {
    var t, e, i, n, r, o;
    if (null === (t = this.variableContext) || void 0 === t ? void 0 : t.gis) {
      const t =
        null ===
          (i =
            null === (e = this.variableContext.gis) || void 0 === e
              ? void 0
              : e.layerManager) || void 0 === i
          ? void 0
          : i.baseMapLayer;
      t &&
        (t.off("click"),
        t.off("dblclick"),
        t.off("drill"),
        t.off("drillEnd"),
        t.off("drillUpEnd"),
        t.off("drillDownEnd")),
        null === (n = this.variableContext.gis) ||
          void 0 === n ||
          n.controlsSystem.controls.removeEventListener(
            "start",
            this.interactionOperationEmit
          ),
        null ===
          (o =
            null === (r = this.variableContext) || void 0 === r
              ? void 0
              : r.gis) ||
          void 0 === o ||
          o.off("viewportChange");
    }
  }
  async update() {
    const { gis: t } = this.variableContext;
    t &&
      (this.propsWatch.compare(this.preProperties, this.properties),
      (this.preProperties = u(this.properties)));
  }
  renderTips() {
    if (this.variableContext) {
      const t = this.variableContext.tipsPool;
      if (Object.keys(t).length > 0) {
        const e = Object.values(t),
          i = e.reduce((t, e) => t + e.message, ""),
          n = e[e.length - 1].type;
        super.renderTips(new y(n, i));
      } else this.removeTips();
    }
  }
  getSceneConfig() {
    const { componentBackground: t } = this.properties;
    return {
      dpr: this.getRealDPR(),
      background: {
        transparent: !(null == t ? void 0 : t.hasColor),
        color: t.backgroundColor,
      },
    };
  }
  setSceneConfig() {
    const { gis: t } = this.variableContext,
      e = this.getSceneConfig();
    null == t || t.sceneSystem.set(e);
  }
  getViewportConfig() {
    const { interaction: t } = this.properties,
      {
        sceneChangeEnable: e,
        zoomEnable: i,
        translationEnable: n,
        pitchEnable: r,
        rotationEnable: o,
      } = t,
      a = this.editMode !== g.View;
    let s;
    if (this.needUpgradeViewport)
      s = {
        ...this.POMNode.data.viewportConfig,
        enableZoom: a || i,
        enablePitch: a || r,
        enableRotate: a || o,
        enablePan: a || n,
        lock: !a && !e,
        drillSave: !0,
      };
    else {
      const { viewport: t } = this.properties,
        { centerLng: l, centerLat: u } = t;
      s = {
        ...t,
        center: [l, u],
        enableZoom: a || i,
        enablePitch: a || r,
        enableRotate: a || o,
        enablePan: a || n,
        lock: !a && !e,
        drillSave: !0,
      };
    }
    return s;
  }
  getRawViewportConfig() {
    var e;
    const i =
      null === (e = this.variableContext.gis) || void 0 === e
        ? void 0
        : e.viewportSystem.get();
    return {
      center: [t(i.center[0], 6), t(i.center[1], 6)],
      zoom: t(i.zoom, 2),
      pitch: t(i.pitch, 0),
      rotation: t(i.rotation, 0),
      maxZoom: i.maxZoom,
      minZoom: i.minZoom,
      maxPitch: i.maxPitch,
      minPitch: i.minPitch,
      maxRotation: i.maxRotation,
      minRotation: i.minRotation,
    };
  }
  setViewportConfig(t) {
    if (this.variableContext) {
      const { gis: e } = this.variableContext,
        i = null != t ? t : this.getViewportConfig();
      null == e || e.viewportSystem.setWebGisCameraState(i);
    }
  }
  ayncViewportConfig(t) {
    (this.properties.viewport.centerLng = t.center[0]),
      (this.properties.viewport.centerLat = t.center[1]),
      (this.properties.viewport.zoom = t.zoom),
      (this.properties.viewport.pitch = t.pitch),
      (this.properties.viewport.rotation = t.rotation);
  }
  setLightConfig() {
    const { gis: t } = this.variableContext,
      e = this.getLightConfig();
    null == t || t.lightSystem.set(e);
  }
  getLightConfig() {
    const { light: t } = this.properties;
    return {
      ambient: {
        color: t.ambient.color,
        intensity: t.ambient.intensity,
      },
      directional: {
        color: t.directional.color,
        intensity: t.directional.intensity,
        x: t.directional.x,
        y: t.directional.y,
        z: t.directional.z,
        shadow: {
          enabled: t.shadow.enabled,
          color: t.shadow.color,
        },
      },
    };
  }
  getBaseLayerConfig() {
    const {
        baseMapLayer: t,
        districtOutline: e,
        innerShadow: i,
        extrude: n,
        boundaryStreamer: r,
        provinceOutline: o,
        mapStyle: a,
        common: s,
      } = this.properties,
      { labelEnable: l = !0 } = a,
      u = null == t ? void 0 : t.show,
      c = {
        common: {
          visible: u,
          zoomRange: [s.zoomMin, s.zoomMax],
        },
        districtStyle: {
          enabled: !0,
          stroke: {
            color: a.borderColor,
          },
          fill: {
            color: a.backgroundColor,
            metalness: a.metalness,
            roughness: a.roughness,
            map:
              "mapStyle-image-tab-1" === a.backgroundType
                ? this.replaceStaticTemplatePath(a.backgroundImage)
                : a.backgroundTile,
            normalMap:
              "mapStyle-tile-tab-1" === a.normalType
                ? this.replaceStaticTemplatePath(a.normalImage)
                : a.normalTile,
            normalScale: a.normalScale,
          },
          innerShadow: {
            enabled: i.enable,
            // shadowColor: i.color,
            // shadowBlurScale: i.width,
            shadowColor: 'rgba(252,228,14,1)',
            shadowBlurScale: 0.1,
          },
          boundaryStreamer: {
            enabled: r.enable,
            lineLength: r.length,
            lineWidth: r.width,
            lineColor: r.endColor,
            lineHeadColor: r.headColor,
            lineHeadRatio: 0.2,
            speed: r.speed,
          },
        },
        drill: {},
        poi: {
          major: {
            enabled: l,
            color: a.fontStyle.color,
            fontWeight: a.fontStyle.fontWeight,
            fontSize: a.fontStyle.fontSize,
            aliasMap: I2(this.POMNode.renderType),
            fontFamily: RX(a.fontStyle.fontFamily),
          },
          coverEnable: !a.coverEnable,
        },
      };
    return (
      (c.districtStyle.heightScale = u ? n.height : 0),
      (c.districtStyle.sideConfig = {
        colorConfig: {
          range: [n.topColor, n.bottomColor],
        },
      }),
      e &&
        (c.districtStyle.stroke = {
          ...c.districtStyle.stroke,
          opacity: e.opacity,
          width: e.width,
        }),
      o &&
        (c.subDistrictStyle = {
          stroke: {
            opacity: o.opacity,
            width: o.width,
            color: o.borderColor,
          },
        }),
      c
    );
  }
  async setBaseLayer() {
    const { gis: t } = this.variableContext,
      e = this.getBaseLayerConfig();
    f(e, this.previousConfig) ||
      ((this.previousConfig = e),
      null == t || t.layerManager.baseMapLayer.set(e));
  }
  async getDataConfig() {
    const {
      data: { region: t },
    } = this.properties;
    let e;
    switch (
      (this.buildRegionData(), (this.lastRegion = t), this.POMNode.renderType)
    ) {
      case hX.CHINA_GIS:
        e = {
          district: {
            type: xk.GEOBUF_URL,
            data: aQ("countryborder_208_gc.pbf"),
          },
          subDistrict: {
            type: xk.GEOBUF_URL,
            data: aQ("district_100000_1_gc.pbf"),
          },
          region: this.variableContext.regionData,
          nameMap: UX,
        };
        break;
      case hX.WOLRD_GIS:
        e = {
          district: null,
          subDistrict: {
            type: xk.GEOBUF_URL,
            data: aQ("bd_world_without_antarctica.pbf"),
            simplify: {
              enabled: !0,
              tolerance: 0.1,
            },
          },
          region: this.variableContext.regionData,
        };
        break;
      case hX.CUSTOM_GIS:
        const {
            data: {
              custom: { data: t },
            },
          } = this.properties,
          i = await fetch(this.replaceStaticTemplatePath(t.url)),
          n = await i.json();
        (e = {
          district: null,
          subDistrict: {
            type: "geojson",
            data: n[n.rootId],
            simplify: {
              enabled: !1,
            },
          },
          region: this.variableContext.regionData,
        }),
          (this.lastCustomData = u(t));
    }
    return e;
  }
  getViewClipConfig() {
    const {
      nanhai: { enable: t },
    } = this.properties;
    if (t) {
      const t = cX,
        e = Object.values(this.variableContext.regionData).find((t) =>
          t.child.includes(JY)
        );
      return e && (t[e.adcode] = cX[ZY]), t;
    }
    return null;
  }
  async getDrillConfig() {
    const {
      interaction: { initialLevelName: t },
    } = this.properties;
    let e;
    switch (this.POMNode.renderType) {
      case hX.CHINA_GIS:
        const i = await nQ(t, this.variableContext.gis);
        (e = {
          enabled: !0,
          level: {
            range: this.drillRange,
            adcode: i,
          },
          data: {
            0: {
              type: xk.GEOBUF_URL,
              data: aQ("districtaggregate_province_kld_gc.pbf"),
            },
            1: {
              type: xk.GEOBUF_URL,
              data: aQ("districtaggregate_city_kld_gc.pbf"),
            },
            2: {
              type: xk.GEOBUF_URL,
              data: aQ("districtaggregate_county_kld_gc.pbf"),
            },
          },
          duration: 500,
          preventMouse: !0,
        }),
          (this.lastDrillAdCode = i);
        break;
      case hX.WOLRD_GIS:
        (e = {
          enabled: !1,
          data: null,
          duration: 500,
          preventMouse: !0,
        }),
          (this.lastDrillAdCode = QY);
        break;
      case hX.CUSTOM_GIS:
        (e = {
          enabled: !1,
          data: null,
          duration: 500,
          preventMouse: !0,
        }),
          (this.lastDrillAdCode = "999999");
    }
    return e;
  }
  async modifyCustomData() {
    const { gis: t } = this.variableContext,
      {
        data: {
          custom: { data: e },
        },
      } = this.properties;
    f(e, this.lastCustomData) ||
      (null == t ||
        t.layerManager.baseMapLayer.ee.emit("modifyCustomDataStart"),
      null == t ||
        t.layerManager.baseMapLayer.set({
          data: await this.getDataConfig(),
          drill: await this.getDrillConfig(),
        }),
      await (null == t ? void 0 : t.layerManager.baseMapLayer.release()),
      this.storeViewport(),
      null == t ||
        t.layerManager.baseMapLayer.ee.emit(
          "modifyCustomDataEnd",
          this.lastDrillAdCode
        ),
      (this.lastCustomData = u(e)));
  }
  async updateDefaultData() {
    const {
      interaction: { initialLevelName: t },
    } = this.properties;
    if (this.POMNode.renderType !== hX.CHINA_GIS) return;
    const e = await nQ(t, this.variableContext.gis);
    this.lastDrillAdCode !== e &&
      (e === ZY ? await this.drillUp(ZY) : await this.drillDownSingle(e),
      (this.lastDrillAdCode = e));
  }
  setAMapEnable(t = !0) {
    const {
        amap: e,
        nanhai: { enable: i },
      } = this.properties,
      {
        style: n,
        enable: r,
        content: o,
        custom: { key: a, securityJsCode: s, id: l },
        type: u,
        filter: c,
      } = e,
      { gis: h, div: p } = this.variableContext;
    if ((this.destroyAMap(), r)) {
      const e = new T2({
        id: p,
        key: "amap.default" === u ? "255b6b2933a0084ac1ea75faf6994e47" : a,
        securityJsCode:
          "amap.default" === u ? "22658a511592b5249bf6a69b9911e149" : s,
        style: "amap.default" === u ? n : this.getAMapCustomStyle(l),
        showLabel: !0,
        terrain: o.terrain,
        layers: {
          nebula: {
            visible: o.nebula,
          },
          traffic: {
            visible: o.traffic,
          },
          roadnet: {
            visible: o.roadnet,
          },
          buildings: {
            visible: o.buildings,
          },
        },
        filter: {
          ...c,
          enabled: c.enable,
        },
      });
      (this.variableContext.amapLayer = e),
        e.then(() => {
          null == h || h.registerMap(e),
            o.label ? e.show("label") : e.hide("label"),
            (this.isInitAmap = !0),
            t && (!i || (i && this.isInitNanhai)) && this.initHandle();
        });
    }
  }
  getAMapCustomStyle(t) {
    return `amap://styles/${t}`;
  }
  setAMapContent() {
    const { amap: t } = this.properties,
      { content: e } = t,
      { amapLayer: i } = this.variableContext;
    this.isInitAmap &&
      Object.entries(e).forEach((t) => {
        "terrain" !== t[0] && (!0 === t[1] ? i.show(t[0]) : i.hide(t[0]));
      });
  }
  setAMapFilter() {
    const { amap: t } = this.properties,
      { filter: e } = t,
      { amapLayer: i } = this.variableContext;
    this.isInitAmap &&
      (null == i ||
        i.setFilter({
          ...e,
          enabled: e.enable,
        }));
  }
  updateViewClip(t) {
    const { gis: e } = this.variableContext;
    null == e ||
      e.layerManager.baseMapLayer.set({
        viewClip: t,
      }),
      null == e || e.layerManager.baseMapLayer.scaleAdaptation(!1),
      this.storeViewport();
  }
  setNanhaiEnable(t = !0) {
    const {
        nanhai: e,
        amap: { enable: i },
      } = this.properties,
      {
        enable: n,
        offsetX: r,
        offsetY: o,
        scale: a,
        fill: s,
        background: l,
        position: u,
        stroke: c,
        border: h,
        fontStyle: p,
      } = e,
      { nanhaiLayer: d, gis: f } = this.variableContext;
    if (n) {
      if ((this.updateViewClip(cX), d)) return;
      const e = {
          common: {
            offset: [r, o, 0],
          },
          scale: a,
          position: u,
          data: {
            type: xk.GEOBUF_URL,
            data: aQ("chinasouthseaaggregate_aggregatecssea_kld_gc.pbf"),
          },
          style: {
            fill: {
              color: s,
            },
            background: {
              color: l,
            },
            stroke: {
              color: c.color,
              width: c.width,
            },
            border: {
              color: h.color,
              width: h.width,
            },
          },
          poi: {
            enabled: !0,
            data: {
              type: xk.GEOBUF_URL,
              data: aQ("chinasouthseaaggregate_aggregatecssea_name_kld_gc.pbf"),
            },
            major: {
              enabled: p.enable,
              color: p.color,
              fontSize: p.fontSize,
              fontWeight: p.fontWeight,
              fontFamily: RX(p.fontFamily),
              aliasMap: HX[x.getLocaleId() || "zh_CN"],
            },
          },
        },
        n = new TY(f, e);
      n.then(() => {
        (this.variableContext.nanhaiLayer = n),
          (this.isInitNanhai = !0),
          this.setNanhaiVisible(this.lastDrillAdCode),
          t || this.tickOnce(),
          t && (!i || (i && this.isInitAmap)) && this.initHandle();
      });
    } else {
      if ((this.updateViewClip(null), !d)) return;
      d.remove(), (this.variableContext.nanhaiLayer = null), this.tickOnce();
    }
  }
  setNanhaiVisible(t) {
    const { nanhaiLayer: e } = this.variableContext,
      {
        nanhai: { enable: i },
      } = this.properties;
    if (!i) return;
    if (!e) return;
    const n = Object.values(this.variableContext.regionData).find((t) =>
      t.child.includes(JY)
    );
    t === (null == n ? void 0 : n.adcode) || ZY === t || JY === t
      ? e.set({
          common: {
            visible: !0,
          },
        })
      : e.set({
          common: {
            visible: !1,
          },
        });
  }
  setNanhaiContent() {
    const { nanhai: t } = this.properties,
      {
        offsetX: e,
        offsetY: i,
        scale: n,
        fill: r,
        background: o,
        position: a,
        stroke: s,
        border: l,
        fontStyle: u,
      } = t,
      { nanhaiLayer: c } = this.variableContext;
    if (!c) return;
    const h = {
      common: {
        offset: [e, i, 0],
      },
      scale: n,
      position: a,
      style: {
        fill: {
          color: r,
        },
        background: {
          color: o,
        },
        stroke: {
          color: s.color,
          width: s.width,
        },
        border: {
          color: l.color,
          width: l.width,
        },
      },
      poi: {
        enabled: !0,
        major: {
          enabled: u.enable,
          color: u.color,
          fontSize: u.fontSize,
          fontWeight: u.fontWeight,
          fontFamily: RX(u.fontFamily),
          aliasMap: HX[x.getLocaleId() || "zh_CN"],
        },
      },
    };
    c.set(h);
  }
  setAMapStyle() {
    const { amap: t } = this.properties,
      {
        style: e,
        type: i,
        custom: { id: n },
      } = t,
      { amapLayer: r } = this.variableContext;
    this.isInitAmap &&
      (null == r ||
        r.setMapStyle("amap.default" === i ? e : this.getAMapCustomStyle(n)));
  }
  animate() {
    var t;
    (this.gisContextMapKey = `${this.renderer.getScreenId()}-${
      this.POMNode.id
    }`),
      null === (t = this.currentSlice) ||
        void 0 === t ||
        t.children.forEach((t) => {
          var e, i, n;
          null ===
            (i =
              null === (e = this.renderer.page) || void 0 === e
                ? void 0
                : e.clear) ||
            void 0 === i ||
            i.call(e, t.id),
            null === (n = t.layer) || void 0 === n || n.destroy(),
            (t.layer = void 0);
        }),
      (this.currentSlice = this.POMNode.slices[0]),
      (this.drillEndCallback = []),
      (this.drillStartCallback = []),
      this.update(),
      this.renderLayer();
  }
  renderLayer() {
    const t = this.POMNode.slices[0];
    this.renderer.renderLayer(t, this.variableContext.ghostDiv);
  }
  modifyNodePlots() {
    (this.editingPlot = {
      x: this.POMNode.x,
      y: this.POMNode.y,
    }),
      this.POMNode.slices.forEach((t) => {
        (t.width = this.POMNode.width), (t.height = this.POMNode.height);
      }),
      (this.dom.style.transform = "translate(0,0)");
    const t = this.POMNode.page,
      [e] = t.properties;
    e && (this.dom.style.backgroundColor = e);
  }
  resetNodePlots() {
    const { x: t, y: e } = this.editingPlot;
    (this.dom.style.transform = `translate(${t}px,${e}px)`),
      (this.dom.style.backgroundColor = "transparent");
  }
  enterEdit() {
    return (
      UZ(this) ||
        ((this.dom.style.display = "block"), this.isInit || this.render(!0)),
      this.renderer.elementRequestStage(this),
      this.modifyNodePlots(),
      this.renderer.enterSlice(this.POMNode.slices[0], !0),
      setTimeout(() => {
        this.renderer.editing = this.POMNode;
      }, 0),
      !0
    );
  }
  storeViewport() {
    const { gis: t } = this.variableContext;
    t &&
      ((this.preViewportConfig = this.getRawViewportConfig()),
      this.ayncViewportConfig(this.preViewportConfig));
  }
  quitEdit() {
    UZ(this) || (this.dom.style.display = "none");
    let t = this.POMNode.slices[0].host.parent;
    for (; !t.isSlice; ) t = t.parent;
    this.storeViewport(),
      this.resetNodePlots(),
      this.renderer.elementExitStage(),
      this.renderer.exitSlice(t);
  }
  forwardToPage() {
    UZ(this) || (this.dom.style.display = "none");
    let t = this.POMNode.slices[0].host.parent;
    for (; !t.isSlice || !t.isPage; )
      t.isSlice ? t.isPage || (t = t.host.parent) : (t = t.parent);
    this.storeViewport(),
      this.resetNodePlots(),
      this.renderer.elementExitStage(),
      this.renderer.exitSlice(t),
      (this.renderer.editing = void 0);
  }
  async drillDownSingle(t) {
    var e;
    const { baseMapLayer: i } =
      null === (e = this.variableContext.gis) || void 0 === e
        ? void 0
        : e.layerManager;
    await i.drillDown(t, () => {});
  }
  async drillRegion(t) {
    var e;
    const { baseMapLayer: i } =
      null === (e = this.variableContext.gis) || void 0 === e
        ? void 0
        : e.layerManager;
    await i.drillRegion(t, () => {});
  }
  buildRegionData() {
    const {
      data: { region: t },
    } = this.properties;
    (this.variableContext.regionData = {}),
      t.forEach((t) => {
        let e = t.name;
        const [i, n] = t.position.split(",");
        this.variableContext.regionData[e] = {
          adcode: e,
          name: e,
          position: [Number(i), Number(n)],
          child: t.child,
        };
      });
  }
  updateRegion() {
    var t;
    const {
        data: { region: e },
      } = this.properties,
      { baseMapLayer: i } =
        null === (t = this.variableContext.gis) || void 0 === t
          ? void 0
          : t.layerManager;
    f(e, this.lastRegion) ||
      (this.buildRegionData(),
      (i.state.data.region = {}),
      i.set({
        data: {
          region: this.variableContext.regionData,
        },
      }),
      i.ee.emit("modifyCustomDataStart"),
      i.ee.emit("modifyCustomDataEnd", this.lastDrillAdCode),
      (this.lastRegion = u(e)));
  }
  initPropsWatchRule() {
    this.propsWatch.addWatch([
      this.propsWatch.defaultRule(
        [
          "common",
          "baseMapLayer",
          "districtOutline",
          "extrude",
          "shadow",
          "innerShadow",
          ["mapStyle", "backgroundColor"],
          ["mapStyle", "metalness"],
          ["mapStyle", "roughness"],
          ["mapStyle", "normalScale"],
          ["mapStyle", "borderColor"],
          ["mapStyle", "fontStyle"],
          ["mapStyle", "coverEnable"],
          ["mapStyle", "labelEnable"],
          "provinceOutline",
        ],
        "diffAnyoneDeep",
        () => {
          this.setBaseLayer(), this.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(
        [
          ["mapStyle", "backgroundType"],
          ["mapStyle", "backgroundImage"],
          ["mapStyle", "backgroundTile"],
          ["mapStyle", "normalType"],
          ["mapStyle", "normalImage"],
          ["mapStyle", "normalTile"],
        ],
        "diffAnyoneDeep",
        () => {
          this.setBaseLayer(), this.tickLoop();
        }
      ),
      this.propsWatch.defaultRule(
        ["boundaryStreamer", "enable"],
        "diffDeep",
        (t) => {
          this.setBaseLayer(),
            (null == t ? void 0 : t.boundaryStreamer.enable)
              ? this.tickLoop()
              : this.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(
        [
          ["boundaryStreamer", "headColor"],
          ["boundaryStreamer", "endColor"],
          ["boundaryStreamer", "width"],
          ["boundaryStreamer", "speed"],
          ["boundaryStreamer", "length"],
        ],
        "diffAnyoneDeep",
        () => {
          this.setBaseLayer(), this.tickLoop();
        }
      ),
      this.propsWatch.defaultRule(
        [["data", "custom", "data"]],
        "diffAnyoneDeep",
        async () => {
          await this.modifyCustomData(), this.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(["data", "region"], "diffDeep", () => {
        this.updateRegion();
      }),
      this.propsWatch.defaultRule(
        ["interaction", "initialLevelName"],
        "diffDeep",
        async () => {
          this.updateDefaultData(), this.tickLoop();
        }
      ),
      this.propsWatch.defaultRule("componentBackground", "diffDeep", () => {
        this.setSceneConfig(), this.tickOnce();
      }),
      this.propsWatch.defaultRule("light", "diffDeep", () => {
        this.setLightConfig(), this.tickOnce();
      }),
      this.propsWatch.defaultRule(
        ["interaction", "viewport"],
        "diffAnyoneDeep",
        () => {
          this.setViewportConfig(), this.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(["nanhai", "enable"], "diffDeep", () => {
        this.setNanhaiEnable(!1);
      }),
      this.propsWatch.defaultRule(
        [
          ["nanhai", "position"],
          ["nanhai", "offsetX"],
          ["nanhai", "offsetY"],
          ["nanhai", "scale"],
          ["nanhai", "fill"],
          ["nanhai", "stroke"],
          ["nanhai", "border"],
          ["nanhai", "background"],
          ["nanhai", "fontStyle"],
        ],
        "diffAnyoneDeep",
        () => {
          this.setNanhaiContent(), this.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(
        ["amap", "custom", "key"],
        "diffDeep",
        () => {
          C2(), this.setAMapEnable(!1);
        },
        !0
      ),
      this.propsWatch.defaultRule(
        [
          ["amap", "enable"],
          ["amap", "type"],
          ["amap", "custom", "securityJsCode"],
          ["amap", "content", "terrain"],
        ],
        "diffAnyoneDeep",
        () => {
          this.setAMapEnable(!1);
        },
        !0
      ),
      this.propsWatch.defaultRule(
        [
          ["amap", "style"],
          ["amap", "custom", "id"],
        ],
        "diffAnyoneDeep",
        () => {
          this.setAMapStyle();
        }
      ),
      this.propsWatch.defaultRule(["amap", "content"], "diffDeep", () => {
        this.setAMapContent();
      }),
      this.propsWatch.defaultRule(["amap", "filter"], "diffDeep", () => {
        this.setAMapFilter();
      }),
    ]);
  }
  onFontsUpdated() {
    this.updateGisFonts(), this.updateNanhaiFonts();
  }
  updateGisFonts() {
    const { gis: t } = this.variableContext;
    (this.asyncFontsTask.gis = !0),
      t &&
        this.isInitGis &&
        ((this.asyncFontsTask.gis = !1),
        null == t || t.layerManager.baseMapLayer.initPOI());
  }
  updateNanhaiFonts() {
    const { nanhaiLayer: t } = this.variableContext;
    (this.asyncFontsTask.nanhai = !0),
      t &&
        this.isInitNanhai &&
        ((this.asyncFontsTask.nanhai = !1), t.initPOI());
  }
  toDataURL(t = "image/jpeg", e = 0.92) {
    const { gis: i } = this.variableContext;
    if (i) return null == i ? void 0 : i.renderSystem.toDataURL(t, e);
  }
  destroyAMap() {
    const { amapLayer: t, gis: e } = this.variableContext;
    null == e || e.unregisterMap(t),
      null == t || t.destroy(),
      (this.variableContext.amapLayer = null),
      (this.isInitAmap = !1);
  }
  suspend() {
    this.variableContext.gis && this.variableContext.gis.tickSystem.pause();
  }
  resume() {
    this.variableContext.gis && this.variableContext.gis.tickSystem.start();
  }
  async destroy(t) {
    var e, i, n, r, o;
    this.clearEventListener();
    for (let a = 0; a < this.POMNode.slices.length; a++) {
      const n = this.POMNode.slices[a];
      await (null === (i = (e = this.renderer).destroyLayer) || void 0 === i
        ? void 0
        : i.call(e, n, void 0, t)),
        n.children.forEach((t) => {
          var e, i, n;
          null ===
            (i =
              null === (e = this.renderer.page) || void 0 === e
                ? void 0
                : e.clear) ||
            void 0 === i ||
            i.call(e, t.id),
            null === (n = t.layer) || void 0 === n || n.destroy(),
            (t.layer = void 0);
        });
    }
    this.isInit && t === C.Flip
      ? null === (n = this.variableContext.gis) ||
        void 0 === n ||
        n.tickSystem.pause()
      : (window.cancelAnimationFrame(this.tickId),
        this.destroyAMap(),
        null === (r = this.variableContext.gis) || void 0 === r || r.destroy(),
        (this.variableContext.gis = null),
        L2.delete(this.gisContextMapKey),
        null === (o = this.elementDisplayObserver) ||
          void 0 === o ||
          o.disconnect()),
      super.destroy(t);
  }
}
Object.defineProperty(O2, "panelConfig", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    panelLimit: 1,
    name: "Gis",
  },
}),
  Object.defineProperty(O2, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "单击",
        title_en: "Click",
        value: b.Click,
      },
      {
        title_cn: "双击",
        title_en: "Double Click",
        value: b.DbClick,
      },
      {
        title_cn: "区域单击",
        title_en: "Area Click",
        value: b.AreaClick,
      },
      {
        title_cn: "区域双击",
        title_en: "Area Double Click",
        value: b.AreaDbClick,
      },
      {
        title_cn: "区域外单击",
        title_en: "Outside Area Click",
        value: b.OutSideAreaClick,
      },
      {
        title_cn: "区域外双击",
        title_en: "Outside Area Double Click",
        value: b.OutSideAreaDbClick,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
const F2 = {
    [tX.Bubble]: {
      triggers: [b.BubbleClick, b.ChartBlankClick],
      pattern: {
        type: w.DirectAssign,
        blocks: ["location"],
        eventPath: "RowData.$blockName.$fieldName",
        operators: [A.Equal],
      },
    },
    [tX.LabelScatter]: {
      triggers: [b.BubbleClick, b.ChartBlankClick],
      pattern: {
        type: w.DirectAssign,
        blocks: ["location"],
        eventPath: "RowData.$blockName.$fieldName",
        operators: [A.Equal],
      },
    },
    [tX.Column]: {
      triggers: [b.BarClick, b.ChartBlankClick],
      pattern: {
        type: w.DirectAssign,
        blocks: ["location"],
        eventPath: "RowData.$blockName.$fieldName",
        operators: [A.Equal],
      },
    },
    [tX.DistrictHeatMap]: {
      triggers: [b.AreaClick, b.ChartBlankClick],
      pattern: {
        type: w.DirectAssign,
        blocks: ["province", "city", "district"],
        eventPath: "RowData.$blockName.$fieldName",
        operators: [A.Equal],
      },
    },
    [tX.Isochrone]: {
      triggers: [b.AreaClick, b.ChartBlankClick],
      pattern: {
        type: w.DirectAssign,
        blocks: ["location"],
        eventPath: "RowData.$blockName.$fieldName",
        operators: [A.Equal],
      },
    },
  },
  z2 = (t, e) => ({
    name: t,
    actAs: null != e ? e : t,
  }),
  k2 = (t, e = "") => ({
    title_cn: t,
    title_en: e,
  }),
  B2 = (t, e) => ({
    minVizFields: t,
    maxVizFields: e,
  }),
  G2 = () => ({
    acceptVizFieldType: [T.Dimension],
  }),
  U2 = () => ({
    acceptVizFieldType: [T.Measure],
  }),
  j2 = () => ({
    acceptVizFieldType: [T.Dimension, T.Measure],
  }),
  H2 = (t, e) => ({
    displayChannel: t,
    vizFieldBlock: e,
  }),
  V2 = [
    {
      ...k2("一级区域", "First Level Region"),
      ...z2("province", E.Dimension),
      ...B2(0, 1),
      ...G2(),
    },
    {
      ...k2("二级区域", "Second Level Region"),
      ...z2("city", E.Dimension),
      ...B2(0, 1),
      ...G2(),
    },
    {
      ...k2("三级区域", "Third Level Region"),
      ...z2("district", E.Dimension),
      ...B2(0, 1),
      ...G2(),
    },
    {
      ...k2("主要标注", "MajorLabel"),
      ...z2("majorLabel", E.Dimension),
      ...B2(0, 3),
      ...j2(),
    },
    {
      ...k2("次要标注", "SubLabel"),
      ...z2("subLabel", E.Dimension),
      ...B2(0, 1),
      ...U2(),
    },
  ],
  W2 = [
    {
      ...k2("位置", "Location"),
      ...z2("location", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
  ],
  q2 = [
    {
      ...k2("位置", "Location"),
      ...z2("location", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
    {
      ...k2("值", "Value"),
      ...z2("value", E.Measure),
      ...B2(1, 1),
      ...U2(),
    },
  ],
  Y2 = [
    {
      ...k2("位置", "Location"),
      ...z2("location", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
    {
      ...k2("信息字段", "Information"),
      ...z2("information", E.Dimension),
      ...B2(void 0, void 0),
      ...j2(),
    },
  ],
  X2 = [
    {
      ...k2("位置", "Location"),
      ...z2("location", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
    {
      ...k2("主要标注", "MajorLabel"),
      ...z2("majorLabel", E.Dimension),
      ...B2(0, 1),
      ...j2(),
    },
    {
      ...k2("次要标注", "SubLabel"),
      ...z2("subLabel", E.Dimension),
      ...B2(0, 1),
      ...U2(),
    },
  ],
  Q2 = [
    {
      ...k2("起点位置", "StartLocation"),
      ...z2("startLocation", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
    {
      ...k2("终点位置", "EndLocation"),
      ...z2("endLocation", E.Dimension),
      ...B2(1, 1),
      ...G2(),
    },
  ],
  Z2 = {
    [tX.Bubble]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...j2(),
        },
        size: {
          name: "size",
          title_cn: "尺寸",
          title_en: "Size",
          ...B2(),
          ...j2(),
        },
      },
      [
        ...X2,
        {
          ...k2("额外字段", "Additional Field"),
          ...z2("detail"),
          ...B2(0, void 0),
          ...j2(),
        },
      ]
    ),
    [tX.LabelScatter]: H2(
      {
        color: void 0,
        size: {
          name: "size",
          title_cn: "尺寸",
          title_en: "Size",
          ...B2(),
          ...j2(),
        },
      },
      [
        ...X2,
        {
          ...k2("额外字段", "Additional Field"),
          ...z2("detail"),
          ...B2(0, void 0),
          ...j2(),
        },
      ]
    ),
    [tX.Column]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...j2(),
        },
        size: {
          name: "size",
          title_cn: "高度",
          title_en: "Height",
          ...B2(),
          ...j2(),
        },
      },
      [
        ...X2,
        {
          ...k2("额外字段", "Additional Field"),
          ...z2("detail"),
          ...B2(0, void 0),
          ...j2(),
        },
      ]
    ),
    [tX.InformationLabel]: H2(
      {
        color: void 0,
        size: void 0,
      },
      Y2
    ),
    [tX.FlyLine]: H2(
      {
        color: {
          name: "color",
          title_cn: "终点颜色",
          title_en: "End Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...j2(),
        },
        size: void 0,
      },
      Q2
    ),
    [tX.Path]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...j2(),
        },
        size: {
          name: "size",
          title_cn: "宽度",
          title_en: "Width",
          ...B2(),
          ...j2(),
        },
      },
      W2
    ),
    [tX.DistrictHeatMap]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...U2(),
        },
        size: void 0,
      },
      [
        ...V2,
        {
          ...k2("额外字段", "Additional Field"),
          ...z2("detail"),
          ...B2(0, void 0),
          ...j2(),
        },
      ]
    ),
    [tX.HeatMap]: H2({}, q2),
    [tX.HexagonHeatMap]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...U2(),
        },
        size: {
          name: "size",
          title_cn: "高度",
          title_en: "Height",
          ...B2(),
          ...U2(),
        },
      },
      W2
    ),
    [tX.GridHeatMap]: H2(
      {
        color: {
          name: "color",
          title_cn: "颜色",
          title_en: "Color",
          defaultColorType: D.Continuous,
          ...B2(),
          ...U2(),
        },
        size: {
          name: "size",
          title_cn: "高度",
          title_en: "Height",
          ...B2(),
          ...U2(),
        },
      },
      W2
    ),
    [tX.Isochrone]: H2(
      {
        color: void 0,
        size: void 0,
      },
      [
        ...X2,
        {
          ...k2("额外字段", "Additional Field"),
          ...z2("detail"),
          ...B2(0, void 0),
          ...j2(),
        },
      ]
    ),
  };
function J2(t) {
  const e = t.match(/^(\d+deg),\s*#([0-9A-Fa-f]{6}),\s*#([0-9A-Fa-f]{3})$/);
  return e ? `#${e[2]}` : t;
}
const K2 = (t, e) => {
    const { colors: i, colorLevel: n, colorsLinear: r, customScheme: o } = t;
    let a;
    if (i || o)
      if (i) {
        const t = [],
          e = [];
        i.forEach((i) => {
          t.push(i.title), e.push(J2(i.color));
        }),
          (a = {
            type: "ordinal",
            ordinal: {
              domain: t,
              range: e,
            },
          });
      } else
        o &&
          (a = {
            type: "ordinal",
            ordinal: {
              domain: [],
              range: o.map((t) => J2(t)),
              unknown: "implicit",
            },
          });
    else
      r
        ? (a = n
            ? {
                type: "threshold",
                threshold: {
                  range: r.map((t) => J2("string" == typeof t ? t : t.color)),
                },
              }
            : {
                type: "linear",
                linear: {
                  range: r.map((t) => J2("string" == typeof t ? t : t.color)),
                },
              })
        : (console.error("[vscreen-gis]", "color 解析失败"),
          (a = {
            type: "linear",
            linear: {
              range: ["#041c22", "#40cad8"],
            },
          }));
    return e && (a.default = J2(e)), (a.conditional = t.conditionalConfig), a;
  },
  $2 = (t, e = 0, i = 1) => {
    const { range: n } = t;
    let r;
    return (
      (r = {
        type: "linear",
        linear: {
          range: n.map((t) => t * i),
        },
      }),
      e && (r.default = e),
      r
    );
  };
class t3 extends WZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "currentAdCode", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null,
      }),
      Object.defineProperty(this, "buildRowData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: (t) => {
          if (!t3.analyticDeclaration) return;
          if (M(this.POMNode.viz)) return;
          const e = this.POMNode.viz.analytic,
            i = this.POMNode.viz.vizData,
            { vizFieldBlock: n } = t3.analyticDeclaration,
            r = (n) =>
              new Proxy(
                {},
                {
                  get: (r, o) => {
                    const a = e.vizFieldBlock[n].find((t) => t.name === o);
                    return I(a.id, i)(t[a.id]);
                  },
                }
              ),
            o = (e) =>
              new Proxy(
                {},
                {
                  get: (n, r) => {
                    const o = i.locationMap[e].find((t) => i.aliasMap[t] === r);
                    return I(o, i)(t[o]);
                  },
                }
              );
          if (e.source.type === h.Query) {
            const t = Object.fromEntries(n.map((t) => [t.title_cn, r(t.name)])),
              e = Object.fromEntries(n.map((t) => [t.title_en, r(t.name)])),
              i = Object.fromEntries(n.map((t) => [t.name, r(t.name)]));
            return Object.assign(t, e, i);
          }
          {
            const t = Object.fromEntries(
              Object.keys(i.locationMap).map((t) => [t, o(t)])
            );
            return Object.assign({}, t);
          }
        },
      });
  }
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(MQ.presets, this.POMNode.properties)),
        (this.preVizData = void 0),
        (this.variableContext.drillLevelMap = [
          "countryData",
          "provinceData",
          "cityData",
          "districtData",
        ]),
        (this.variableContext.drillData = {}),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillStartCallback.push(
          this.clearLayerBeforeDrill.bind(this)
        ),
        this.parent.drillEndCallback.push(
          this.releaseLayerAfterDrill.bind(this),
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis = this.parent.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      (this.currentAdCode = this.parent.lastDrillAdCode),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const { gis: t } = this.variableContext,
      e = this.getLayerConfig(),
      i = new oY(
        this.variableContext.gis,
        IX(e, {
          common: {
            zIndex: this.zIndex,
          },
          fields: {
            majorPOIField: "majorPOI",
            minorPOIField: "minorPOI",
            colorField: "color",
            adcodeField: "adcode",
          },
        })
      );
    (this.variableContext.gisLayer = i),
      t.layerManager.baseMapLayer.on("modifyCustomDataStart", () => {
        this.clearLayerBeforeDrill();
      }),
      t.layerManager.baseMapLayer.on("modifyCustomDataEnd", (t) => {
        this.releaseLayerAfterDrill(), this.updateDataAfterDrill(t);
      }),
      (this.preProperties = u(this.properties)),
      this.initHandle();
  }
  initHandle() {
    super.initHandle(), this.initEventListener();
  }
  getFilterPatternBlocksByLevel() {
    var t;
    const { gis: e } = this.variableContext;
    if (e) {
      let i;
      switch (
        null !== (t = e.layerManager.baseMapLayer.currentLevel) && void 0 !== t
          ? t
          : iX.country
      ) {
        case 2:
          i = "district";
          break;
        case 1:
          i = "city";
          break;
        default:
          i = "province";
      }
      return i;
    }
  }
  initEventListener() {
    const { gisLayer: t } = this.variableContext;
    t.on("click", (t) => {
      if (this.comboTimer) {
        if (
          (clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = void 0;
          }, this.comboTimeout)),
          t)
        ) {
          const e = t.properties,
            i = this.buildRowData(e);
          s.call(this, b.AreaDbClick, {
            RowData: i,
          });
        }
      } else
        this.comboTimer = setTimeout(() => {
          if (((this.comboTimer = void 0), t)) {
            const e = t.properties,
              i = this.buildRowData(e);
            let n = !1;
            L(e) || !f(this.selectedItem, e)
              ? ((this.selectedItem = e), (n = !0))
              : (this.selectedItem = null),
              s.call(this, b.AreaClick, {
                RowData: i,
                selected: n,
              });
          } else
            this.selectedItem &&
              ((this.selectedItem = null),
              s.call(this, b.ChartBlankClick, {
                selected: !1,
              }));
        }, this.comboTimeout);
    });
  }
  getLayerConfig() {
    const { color: t, common: e, poi: i } = this.properties;
    let n = i.enable;
    n && this.editMode !== g.View && "show" !== i.trigger && (n = !1);
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          color: {
            default: t.defaultColor,
          },
        },
      },
      poi: {
        ...i,
        enabled: n,
        coverEnable: !i.coverEnable,
        background: {
          ...i.background,
          map: this.replaceStaticTemplatePath(i.background.image),
          borderRadius: [
            i.background.borderRadius.topLeft,
            i.background.borderRadius.topRight,
            i.background.borderRadius.bottomRight,
            i.background.borderRadius.bottomLeft,
          ],
        },
        major: {
          ...i.labelFontStyle,
          enabled: i.labelFontStyle.enable,
          fontFamily: RX(i.labelFontStyle.fontFamily),
        },
        minor: {
          ...i.valueFontStyle,
          enabled: i.valueFontStyle.enable,
          fontFamily: RX(i.valueFontStyle.fontFamily),
        },
      },
      interaction: {
        hover: {
          enabled: this.editMode === g.View && "hover" === i.trigger,
          trigger: "mousemove",
          effect: {
            poi: !0,
          },
        },
        select: {
          enabled: this.editMode === g.View && "click" === i.trigger,
          multi: !1,
          trigger: "click",
          effect: {
            color: "1.3",
            poi: !0,
          },
        },
      },
    };
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const { vizData: e } = this.POMNode.viz;
    (!t && f(this.preVizData, e)) ||
      (this.removeTips(),
      await this.resetData(),
      this.updateData(),
      (this.preVizData = e));
  }
  async resetData() {
    (this.variableContext.drillData = {}), await this.buildDrillData();
  }
  updateData() {
    var t;
    if (M(this.POMNode.viz)) return;
    const {
        poi: { labelFontStyle: e, valueFontStyle: i },
      } = this.properties,
      { drillData: n } = this.variableContext,
      { vizData: r, analytic: o } = this.POMNode.viz,
      {
        color: { defaultColor: a },
      } = this.properties,
      { gis: s, gisLayer: l, drillLevelMap: u } = this.variableContext;
    if (!r || 0 === r.datasets.length)
      return (
        (this.preVizData = void 0),
        l.set({
          data: [],
        }),
        void super.tickOnce()
      );
    try {
      const c =
        null !== (t = s.layerManager.baseMapLayer.currentLevel) && void 0 !== t
          ? t
          : iX.country;
      let h = n[u[c]][this.currentAdCode];
      const p = OX("majorLabel", r, o, 3),
        d = OX("subLabel", r, o, 4),
        f = I(p, r),
        g = I(d, r);
      l.set({
        data: Object.values(null != h ? h : {}),
        poi: {
          major: {
            format: (t) => e.prefix + f(t) + e.suffix,
          },
          minor: {
            format: (t) => i.prefix + g(t) + i.suffix,
          },
        },
        style: {
          fill: {
            color: K2(r.displayConf.color, a),
          },
        },
      }),
        super.tickOnce();
    } catch (c) {
      console.error("[vscreen-gis]", "districtHeatMap data error", c);
    }
  }
  async buildDrillData() {
    var t, e, i, n, r, o, a, s, l, u, c, h, p, d, f, g;
    const { gis: m, drillLevelMap: y, drillData: v } = this.variableContext;
    if (M(this.POMNode.viz)) return;
    const { vizData: b, analytic: x } = this.POMNode.viz;
    if (!b || 0 === b.datasets.length) return;
    const _ =
        null !== (t = m.layerManager.baseMapLayer.currentLevel) && void 0 !== t
          ? t
          : iX.country,
      S = y[_];
    v[S] || (v[S] = {}),
      v[S][this.currentAdCode] || (v[S][this.currentAdCode] = {});
    const C = OX("province", b, x, 0),
      w = OX("city", b, x, 1),
      A = OX("district", b, x, 2),
      E = OX("subLabel", b, x, 4),
      D = FX("color", b),
      T =
        null ===
          (i =
            null === (e = b.displayConf) || void 0 === e ? void 0 : e.color) ||
        void 0 === i
          ? void 0
          : i.conditionalConfig,
      P = N(T),
      L = b.datasets,
      I = Object.keys(zX);
    for (let M = 0; M < L.length; M++) {
      const t = L[M];
      try {
        const e = +(null !== (n = t[E]) && void 0 !== n ? n : ""),
          i = +t[D],
          y = Object.fromEntries(P.map((e) => [e, +t[e]]));
        if (!isNaN(i)) {
          if (_ === iX.country) {
            const n = null !== (r = t[C]) && void 0 !== r ? r : "",
              c = m.layerManager.baseMapLayer.currentRegion;
            let h, p, d;
            switch (this.parent.POMNode.renderType) {
              case hX.CHINA_GIS:
                (h = n ? await ZX(n, m) : ""),
                  (p =
                    !!c &&
                    m.layerManager.baseMapLayer.state.data.region[
                      c
                    ].child.includes(h));
                const r = I.find((t) => n.includes(t));
                if ((!c && r) || (c && p)) {
                  const r = OX("majorLabel", b, x, 3, 0),
                    a = null !== (o = t[r]) && void 0 !== o ? o : "";
                  await this.setDrillData(
                    h,
                    n,
                    i,
                    a,
                    e,
                    t,
                    v[S][this.currentAdCode],
                    y
                  );
                }
                break;
              case hX.WOLRD_GIS:
                if (
                  ((d = m.layerManager.baseMapLayer.subDistrictInfoArr.find(
                    (t) => t.alias === n || t.name === n || t.adcode === n
                  )),
                  (h =
                    null !== (a = null == d ? void 0 : d.adcode) && void 0 !== a
                      ? a
                      : n),
                  (h = rQ(h) ? "CHN" : h),
                  (p =
                    !!c &&
                    m.layerManager.baseMapLayer.state.data.region[
                      c
                    ].child.includes(h)),
                  !c || (c && p))
                ) {
                  const r = OX("majorLabel", b, x, 3, 0),
                    o = null !== (s = t[r]) && void 0 !== s ? s : "";
                  await this.setDrillData(
                    h,
                    n,
                    i,
                    o,
                    e,
                    t,
                    v[S][this.currentAdCode],
                    y
                  );
                }
                break;
              case hX.CUSTOM_GIS:
                if (
                  ((d = m.layerManager.baseMapLayer.subDistrictInfoArr.find(
                    (t) => t.alias === n || t.name === n || t.adcode === n
                  )),
                  (h =
                    null !== (l = null == d ? void 0 : d.adcode) && void 0 !== l
                      ? l
                      : n),
                  (p =
                    !!c &&
                    m.layerManager.baseMapLayer.state.data.region[
                      c
                    ].child.includes(h)),
                  !c || (c && p))
                ) {
                  const r = OX("majorLabel", b, x, 3, 0),
                    o = null !== (u = t[r]) && void 0 !== u ? u : "";
                  await this.setDrillData(
                    h,
                    n,
                    i,
                    o,
                    e,
                    t,
                    v[S][this.currentAdCode],
                    y
                  );
                }
            }
          }
          if (_ === iX.province) {
            const n = null !== (c = t[C]) && void 0 !== c ? c : "",
              r = n ? await ZX(n, m) : "";
            if (this.currentAdCode === r) {
              const n = null !== (h = t[w]) && void 0 !== h ? h : "",
                r = n ? await ZX(n, m) : "",
                o = OX("majorLabel", b, x, 3, 1),
                a = null !== (p = t[o]) && void 0 !== p ? p : "";
              await this.setDrillData(
                r,
                n,
                i,
                a,
                e,
                t,
                v[S][this.currentAdCode],
                y
              );
            }
          }
          if (_ === iX.city) {
            const n = null !== (d = t[w]) && void 0 !== d ? d : "",
              r = n ? await ZX(n, m) : "";
            if (this.currentAdCode === r) {
              const n = null !== (f = t[A]) && void 0 !== f ? f : "",
                r = n ? await ZX(n, m) : "",
                o = OX("majorLabel", b, x, 3, 2),
                a = null !== (g = t[o]) && void 0 !== g ? g : "";
              await this.setDrillData(
                r,
                n,
                i,
                a,
                e,
                t,
                v[S][this.currentAdCode],
                y
              );
            }
          }
        }
      } catch (R) {
        console.error("[vscreen-gis]", "数据解析经纬度失败", t, R);
      }
    }
  }
  async setDrillData(t, e, i, n, r, o, a, s) {
    t &&
      (a[t] ||
        (a[t] = {
          ...o,
          name: e,
          color: 0,
          adcode: t,
          majorPOI: n,
          minorPOI: 0,
          ...Object.fromEntries(Object.keys(s).map((t) => [t, 0])),
        }),
      (a[t].minorPOI += r),
      (a[t].color += i),
      Object.entries(s).forEach(([e, i]) => {
        a[t][e] += i;
      }));
  }
  clearLayerBeforeDrill() {
    const { gisLayer: t } = this.variableContext;
    t && (t.clear(), super.tickOnce());
  }
  releaseLayerAfterDrill() {
    const { gisLayer: t } = this.variableContext;
    t && (t.release(), super.tickOnce());
  }
  async updateDataAfterDrill(t) {
    if ((super.asyncTaskAbort(), M(this.POMNode.viz))) return;
    const { vizData: e } = this.POMNode.viz,
      { color: i } = this.properties,
      {
        drillLevelMap: n,
        gis: r,
        gisLayer: o,
        drillData: a,
      } = this.variableContext,
      s = (function (t) {
        let e;
        return {
          promise: new Promise((i, n) => {
            (e = n), t && t(i, n);
          }),
          abort: () => {
            e("[vscreen-gis] the promise is aborted");
          },
        };
      })(async (e) => {
        var i, s;
        if (M(this.POMNode.viz)) return;
        const { vizData: l } = this.POMNode.viz;
        if (!l || 0 === l.datasets.length)
          return (
            (this.preVizData = void 0),
            o.set({
              data: [],
            }),
            void super.tickOnce()
          );
        this.currentAdCode = t;
        const u =
            null !== (i = r.layerManager.baseMapLayer.currentLevel) &&
            void 0 !== i
              ? i
              : iX.country,
          c = n[u];
        let h =
          null === (s = null == a ? void 0 : a[c]) || void 0 === s
            ? void 0
            : s[this.currentAdCode];
        h || (await this.buildDrillData()),
          (h = a[c][this.currentAdCode]),
          e(Object.values(null != h ? h : {}));
      });
    this.asyncTaskPool.push(s);
    const l = await s.promise;
    o.set({
      data: u(l),
      style: {
        fill: {
          color: K2(e.displayConf.color, i.defaultColor),
        },
      },
    }),
      super.tickOnce();
  }
  renderTips(t) {
    kZ.call(this, t),
      this.variableContext.gisLayer
        ? ((this.preVizData = void 0),
          this.variableContext.gisLayer.clear(),
          this.variableContext.gisLayer.release(),
          super.tickOnce())
        : this.render(!0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          [
            "color",
            ["poi", "orient"],
            ["poi", "trigger"],
            ["poi", "alignment"],
            ["poi", "coverEnable"],
            ["poi", "offsetX"],
            ["poi", "offsetY"],
            ["poi", "labelFontStyle"],
            ["poi", "valueFontStyle"],
            ["poi", "background", "opacity"],
            ["poi", "background", "color"],
            ["poi", "background", "shadow"],
            ["poi", "background", "padding"],
            ["poi", "background", "borderRadius"],
          ],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(), super.tickOnce();
          }
        ),
        this.propsWatch.defaultRule(
          [
            ["poi", "enable"],
            ["poi", "background", "image"],
          ],
          "diffAnyoneDeep",
          (t) => {
            super.setLayerConfig(), super.tickLoop();
          }
        ),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(t3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(t3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.DistrictHeatMap],
  }),
  Object.defineProperty(t3, "componentFilterDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: F2[tX.DistrictHeatMap],
  }),
  Object.defineProperty(t3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "每项区域单击",
        title_en: "Area Click",
        value: b.AreaClick,
      },
      {
        title_cn: "每项区域双击",
        title_en: "Area Double Click",
        value: b.AreaDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class e3 extends WZ {
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(DQ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new GW(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            colorField: "color",
            heightField: "size",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      super.initHandle();
  }
  getLayerConfig() {
    const { style: t, common: e } = this.properties;
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        tessellate: !0,
        padding: (t.padding / 100) * t.size,
        size: t.size,
        fill: {
          color: {
            default: t.color.defaultColor,
          },
        },
      },
    };
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: e },
      } = this.properties,
      { gis: i, gisLayer: n } = this.variableContext,
      { vizData: r, analytic: o } = this.POMNode.viz,
      { style: a } = this.properties;
    if (!t && f(this.preVizData, r)) return;
    if ((this.removeTips(), !r || 0 === r.datasets.length))
      return (
        (this.preVizData = void 0),
        n.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const s = [];
    try {
      const t = await lQ({
        vizData: r,
        analytic: o,
        gis: i,
        hasColorChannel: !0,
        hasSizeChannel: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      s.push(...t);
    } catch (l) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", l);
    }
    (this.preVizData = r),
      n.set({
        data: u(s),
        style: {
          fill: {
            color: K2(r.displayConf.color, a.color.defaultColor),
          },
          height: $2(r.displayConf.size, 0, 3),
        },
      }),
      super.tickOnce();
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(["style"], "diffAnyoneDeep", () => {
          super.setLayerConfig(), super.tickOnce();
        }),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(e3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(e3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.GridHeatMap],
  }),
  Object.defineProperty(e3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class i3 extends WZ {
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(NQ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new AY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            colorField: "value",
            heightField: "value",
            colorWeightField: "value",
            heightWeightField: "value",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      super.initHandle();
  }
  getLayerConfig() {
    const { style: t, common: e } = this.properties;
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        colorWeight: {
          type: "linear",
          linear: {
            domain: null,
            range: [t.intensity, 1],
            clamp: !1,
          },
        },
        heightWeight: {
          type: "linear",
          linear: {
            domain: null,
            range: [t.intensity, 1],
            clamp: !1,
          },
        },
        size: {
          type: "constant",
          constant: 3 * t.radius,
        },
        colorPalette: {
          type: "linear",
          linear: {
            range: [
              t.color.color1,
              t.color.color2,
              t.color.color3,
              t.color.color4,
            ],
            domain: [0.35, 0.55, 0.85, 1],
          },
        },
        height: {
          type: "linear",
          linear: {
            range: [0, 3 * t.height],
          },
        },
      },
    };
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: e },
      } = this.properties,
      { gis: i, gisLayer: n } = this.variableContext,
      { vizData: r, analytic: o } = this.POMNode.viz;
    if (!t && f(this.preVizData, r)) return;
    if ((this.removeTips(), !r || 0 === r.datasets.length))
      return (
        (this.preVizData = void 0),
        void n.set({
          data: [],
        })
      );
    const a = [];
    try {
      const t = await lQ({
        vizData: r,
        analytic: o,
        gis: i,
        useValueQuery: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      a.push(...t);
    } catch (s) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", s);
    }
    (this.preVizData = r),
      n.set({
        data: u(a),
      }),
      setTimeout(() => {
        super.tickOnce();
      }, 0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(["style"], "diffAnyoneDeep", () => {
          super.setLayerConfig(),
            setTimeout(() => {
              super.tickOnce();
            }, 0);
        }),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(i3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(i3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.HeatMap],
  }),
  Object.defineProperty(i3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class n3 extends WZ {
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(kQ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new kW(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            colorField: "color",
            heightField: "size",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      super.initHandle();
  }
  getLayerConfig() {
    const { style: t, common: e } = this.properties;
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        tessellate: !0,
        padding: (t.padding / 100) * t.size,
        size: t.size,
        fill: {
          color: {
            default: t.color.defaultColor,
          },
        },
      },
    };
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: e },
      } = this.properties,
      { gis: i, gisLayer: n } = this.variableContext,
      { vizData: r, analytic: o } = this.POMNode.viz,
      { style: a } = this.properties;
    if (!t && f(this.preVizData, r)) return;
    if ((this.removeTips(), !r || 0 === r.datasets.length))
      return (
        (this.preVizData = void 0),
        n.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const s = [];
    try {
      const t = await lQ({
        vizData: r,
        analytic: o,
        gis: i,
        hasColorChannel: !0,
        hasSizeChannel: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      s.push(...t);
    } catch (l) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", l);
    }
    (this.preVizData = r),
      n.set({
        data: u(s),
        style: {
          fill: {
            color: K2(r.displayConf.color, a.color.defaultColor),
          },
          height: $2(r.displayConf.size, 0, 3),
        },
      }),
      super.tickOnce();
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(["style"], "diffAnyoneDeep", () => {
          super.setLayerConfig(), super.tickOnce();
        }),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(n3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(n3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.HexagonHeatMap],
  }),
  Object.defineProperty(n3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class r3 extends WZ {
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(VQ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new Fq(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            toColorField: "color",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      super.initHandle();
  }
  getLayerConfig() {
    const { lineStyle: t, breathPoint: e, common: i } = this.properties;
    return {
      common: {
        zoomRange: [i.zoomMin, i.zoomMax],
      },
      style: {
        fill: {
          fromColor: {
            type: "constant",
            constant: t.startColor,
          },
        },
        width: t.size,
      },
      animation: {
        speed: t.speed,
      },
      breathPointLayer: {
        common: {
          visible: e.enable,
        },
        speed: e.speed,
        size: 10 * e.size,
      },
    };
  }
  async setData(t = !1) {
    var e, i;
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: n },
      } = this.properties,
      { gis: r, gisLayer: o } = this.variableContext,
      { vizData: a, analytic: s } = this.POMNode.viz;
    if (!t && f(this.preVizData, a)) return;
    if ((this.removeTips(), !a || 0 === a.datasets.length))
      return (
        (this.preVizData = void 0),
        o.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const l = OX("startLocation", a, s, 0),
      c = OX("endLocation", a, s, 1),
      h = FX("color", a),
      p = [],
      d = [],
      g = [],
      m = sQ(r, n),
      y =
        1 === r.layerManager.baseMapLayer.subDistrictInfoArr.length
          ? r.layerManager.baseMapLayer.subDistrictInfoArr[0].name
          : null,
      v =
        null ===
          (i =
            null === (e = a.displayConf) || void 0 === e ? void 0 : e.color) ||
        void 0 === i
          ? void 0
          : i.conditionalConfig;
    if (l && c) {
      const t = a.datasets;
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        try {
          const t = i[l],
            e = i[c],
            o = i[h];
          if (t && e) {
            let a;
            const s = eQ(t);
            if (s.isLngLat) a = s;
            else {
              const e = qX(this.parent.POMNode.renderType, t);
              a = XV.getGeoCoordByAlias(e, r);
            }
            let l;
            const u = eQ(e);
            if (u.isLngLat) l = u;
            else {
              const t = qX(this.parent.POMNode.renderType, e);
              l = XV.getGeoCoordByAlias(t, r);
            }
            if (a && l) {
              if (n || (t !== y && e !== y)) {
                const t = {
                  from: [a.lng, a.lat],
                  to: [l.lng, l.lat],
                  color: o,
                };
                pQ(t, Boolean(v), i, v), p.push(t);
              }
            } else
              m &&
                (d.push({
                  name: t,
                  color: o,
                }),
                g.push({
                  name: e,
                }));
          }
        } catch (b) {
          console.error("[vscreen-gis]", "数据解析经纬度失败", i, b);
        }
      }
      if (AX() && d.length > 0) {
        const [t, e] = await Promise.all([
          $X({
            address: d.map((t) => t.name),
          }),
          $X({
            address: g.map((t) => t.name),
          }),
        ]);
        d.forEach((i, n) => {
          const r = t[n].location,
            o = e[n].location;
          if (r && o) {
            const [t, e] = r.split(","),
              [n, a] = o.split(","),
              s = {
                from: [Number(t), Number(e)],
                to: [Number(n), Number(a)],
                color: i.color,
              };
            pQ(s, Boolean(v), i, v), p.push(s);
          }
        });
      }
    }
    (this.preVizData = a),
      o.set({
        data: u(p),
        style: {
          fill: {
            toColor: K2(a.displayConf.color, "#9EEEFF"),
          },
        },
      }),
      super.tickLoop();
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(
          ["lineStyle", "breathPoint"],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(), super.tickLoop();
          }
        ),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(r3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(r3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.FlyLine],
  }),
  Object.defineProperty(r3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class o3 extends WZ {
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(QQ.presets, this.POMNode.properties)),
        (this.variableContext.startPointLayer = null),
        (this.variableContext.nodePointLayer = null),
        (this.variableContext.endPointLayer = null),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new Xq(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          usePixel: !0,
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            colorField: "color",
            widthField: "size",
          },
        })
      ),
      i = new eY(this.variableContext.gis, this.getStartPointLayerConfig()),
      n = new eY(this.variableContext.gis, this.getNodePointLayerConfig()),
      r = new eY(this.variableContext.gis, this.getEndPointLayerConfig());
    (this.variableContext.gisLayer = e),
      (this.variableContext.startPointLayer = i),
      (this.variableContext.nodePointLayer = n),
      (this.variableContext.endPointLayer = r),
      (this.preProperties = u(this.properties)),
      super.initHandle();
  }
  getLayerConfig() {
    const { icon: t, common: e, speed: i } = this.properties;
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant: this.replaceStaticTemplatePath(t.image),
          },
        },
      },
      animation: {
        speed: i,
      },
    };
  }
  renderTips(t) {
    const {
      startPointLayer: e,
      nodePointLayer: i,
      endPointLayer: n,
    } = this.variableContext;
    kZ.call(this, t),
      this.variableContext.gisLayer
        ? ((this.preVizData = void 0),
          this.variableContext.gisLayer.set({
            data: [],
          }),
          e.set({
            data: [],
          }),
          i.set({
            data: [],
          }),
          n.set({
            data: [],
          }),
          super.tickOnce())
        : this.render(!0);
  }
  async setData(t = !1) {
    var e, i, n;
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: r },
      } = this.properties,
      {
        gis: o,
        gisLayer: a,
        startPointLayer: s,
        nodePointLayer: l,
        endPointLayer: c,
      } = this.variableContext,
      { vizData: h, analytic: p } = this.POMNode.viz;
    if (!t && f(this.preVizData, h)) return;
    if ((this.removeTips(), !h || 0 === h.datasets.length))
      return (
        (this.preVizData = void 0),
        a.set({
          data: [],
        }),
        s.set({
          data: [],
        }),
        l.set({
          data: [],
        }),
        c.set({
          data: [],
        }),
        void super.tickOnce()
      );
    let d = [],
      g = [],
      m = [],
      y = [];
    const v = sQ(o, r),
      b =
        1 === o.layerManager.baseMapLayer.subDistrictInfoArr.length
          ? o.layerManager.baseMapLayer.subDistrictInfoArr[0].name
          : null,
      x = OX("location", h, p, 0),
      _ = FX("color", h),
      S = FX("size", h);
    if (x && _ && S) {
      const t = h.datasets;
      for (let a = 0; a < t.length; a++) {
        const s = t[a];
        try {
          const t = null !== (e = s[x]) && void 0 !== e ? e : "",
            a = iQ(t),
            l = {
              coordinates: [],
              adressList: [],
            };
          if (a) {
            let e = JSON.parse(`[${t}]`);
            if (e.length < 2) continue;
            e.forEach((t, i) => {
              if (Array.isArray(t)) {
                let n = Number(t[0]),
                  r = Number(t[1]);
                l.coordinates.push([n, r]),
                  this.processPointData(i, e.length, n, r, g, m, y);
              }
            });
          } else {
            let e = t.split(",");
            if (e.length < 2) continue;
            l.adressList = e;
            if (
              e.every((t) => {
                const e = qX(this.parent.POMNode.renderType, t);
                return XV.getGeoCoordByAlias(e, o);
              })
            )
              (!r && e.includes(b)) ||
                e.forEach((t, i) => {
                  const n = qX(this.parent.POMNode.renderType, t),
                    r = XV.getGeoCoordByAlias(n, o);
                  if (r) {
                    let t = r.lng,
                      n = r.lat;
                    l.coordinates.push([t, n]),
                      this.processPointData(i, e.length, t, n, g, m, y);
                  }
                });
            else if (AX() && v) {
              (
                await $X({
                  address: e,
                })
              ).forEach((t, i) => {
                const n = t.location;
                if (n) {
                  const [t, r] = n.split(",");
                  let o = Number(t),
                    a = Number(r);
                  void 0 !== o &&
                    (l.coordinates.push([o, a]),
                    this.processPointData(i, e.length, o, a, g, m, y));
                }
              });
            }
          }
          if (l.coordinates.length > 0) {
            cQ(l, !0, s, _), hQ(l, !0, s, S);
            const t =
              null ===
                (n =
                  null === (i = h.displayConf) || void 0 === i
                    ? void 0
                    : i.color) || void 0 === n
                ? void 0
                : n.conditionalConfig;
            pQ(l, Boolean(t), s, t), d.push(l);
          }
        } catch (C) {
          console.error("[vscreen-gis]", "数据解析经纬度失败", s, C);
        }
      }
    }
    (this.preVizData = h),
      a.set({
        data: u(d),
        style: {
          fill: {
            color: K2(h.displayConf.color),
          },
          width: $2(h.displayConf.size),
        },
      }),
      l.set({
        data: u(m),
      }),
      s.set({
        data: u(g),
      }),
      c.set({
        data: u(y),
      }),
      super.tickLoop();
  }
  getStartPointLayerConfig() {
    const { startPoint: t, common: e } = this.properties;
    return {
      common: {
        visible: this.plot.visible ? t.enable : this.plot.visible,
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant: this.replaceStaticTemplatePath(t.image),
          },
          color: {
            type: "constant",
            constant: null,
          },
        },
        size: {
          type: "constant",
          constant: t.size,
        },
        segments: 4,
      },
      animation: {
        opacity: {
          enabled: !1,
        },
        scale: {
          enabled: !1,
        },
      },
    };
  }
  getNodePointLayerConfig() {
    const { nodePoint: t, common: e } = this.properties;
    return {
      common: {
        visible: this.plot.visible ? t.enable : this.plot.visible,
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant: this.replaceStaticTemplatePath(t.image),
          },
          color: {
            type: "constant",
            constant: null,
          },
        },
        size: {
          type: "constant",
          constant: t.size,
        },
        segments: 4,
      },
      animation: {
        opacity: {
          enabled: !1,
        },
        scale: {
          enabled: !1,
        },
      },
    };
  }
  getEndPointLayerConfig() {
    const { endPoint: t, common: e } = this.properties;
    return {
      common: {
        visible: this.plot.visible ? t.enable : this.plot.visible,
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant: this.replaceStaticTemplatePath(t.image),
          },
          color: {
            type: "constant",
            constant: null,
          },
        },
        size: {
          type: "constant",
          constant: t.size,
        },
        segments: 4,
      },
      animation: {
        opacity: {
          enabled: !1,
        },
        scale: {
          enabled: !1,
        },
      },
    };
  }
  setStartPointLayerConfig() {
    const { startPointLayer: t } = this.variableContext,
      e = this.getStartPointLayerConfig();
    t.set(e);
  }
  setNodePointLayerConfig() {
    const { nodePointLayer: t } = this.variableContext,
      e = this.getNodePointLayerConfig();
    t.set(e);
  }
  setEndPointLayerConfig() {
    const { endPointLayer: t } = this.variableContext,
      e = this.getEndPointLayerConfig();
    t.set(e);
  }
  processPointData(t, e, i, n, r, o, a) {
    0 === t
      ? r.push({
          lng: i,
          lat: n,
          value: 0,
        })
      : t === e - 1
      ? a.push({
          lng: i,
          lat: n,
          value: 0,
        })
      : o.push({
          lng: i,
          lat: n,
          value: 0,
        });
  }
  setElementVisibility(t) {
    this.variableContext.gis &&
      (this.variableContext.gisLayer.set({
        common: {
          visible: t,
        },
      }),
      this.variableContext.startPointLayer.set({
        common: {
          visible: t ? this.properties.startPoint.enable : t,
        },
      }),
      this.variableContext.nodePointLayer.set({
        common: {
          visible: t ? this.properties.nodePoint.enable : t,
        },
      }),
      this.variableContext.endPointLayer.set({
        common: {
          visible: t ? this.properties.endPoint.enable : t,
        },
      }),
      t && this.errorTip ? this.renderTips(this.errorTip) : this.removeTips(!1),
      super.tickOnce());
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  initPropsWatchRule() {
    this.propsWatch.addWatch([
      this.propsWatch.defaultRule(
        ["common", "showAllLevelData"],
        "diffDeep",
        () => {
          this.setData(!0);
        },
        !0
      ),
      this.propsWatch.defaultRule(
        [
          ["common", "zoomMin"],
          ["common", "zoomMax"],
        ],
        "diffAnyoneDeep",
        () => {
          super.setLayerConfig(),
            this.setStartPointLayerConfig(),
            this.setNodePointLayerConfig(),
            this.setEndPointLayerConfig(),
            super.tickOnce();
        }
      ),
      this.propsWatch.defaultRule(
        ["icon", "color", "width", "speed"],
        "diffAnyoneDeep",
        () => {
          super.setLayerConfig(), super.tickLoop();
        }
      ),
      this.propsWatch.defaultRule(["startPoint"], "diffAnyoneDeep", () => {
        this.setStartPointLayerConfig(), super.tickLoop();
      }),
      this.propsWatch.defaultRule(["nodePoint"], "diffAnyoneDeep", () => {
        this.setNodePointLayerConfig(), super.tickLoop();
      }),
      this.propsWatch.defaultRule(["endPoint"], "diffAnyoneDeep", () => {
        this.setEndPointLayerConfig(), super.tickLoop();
      }),
    ]);
  }
  destroy() {
    this.variableContext.startPointLayer.remove(),
      this.variableContext.nodePointLayer.remove(),
      this.variableContext.endPointLayer.remove(),
      super.destroy();
  }
}
Object.defineProperty(o3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(o3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.Path],
  }),
  Object.defineProperty(o3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class a3 extends WZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "buildRowData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: (t) => {
          if (!a3.analyticDeclaration) return;
          if (M(this.POMNode.viz)) return;
          const e = this.POMNode.viz.analytic,
            i = this.POMNode.viz.vizData,
            { vizFieldBlock: n } = a3.analyticDeclaration,
            r = (n) =>
              new Proxy(
                {},
                {
                  get: (r, o) => {
                    const a = e.vizFieldBlock[n].find((t) => t.name === o);
                    return I(a.id, i)(t[a.id]);
                  },
                }
              ),
            o = (e) =>
              new Proxy(
                {},
                {
                  get: (n, r) => {
                    const o = i.locationMap[e].find((t) => i.aliasMap[t] === r);
                    return I(o, i)(t[o]);
                  },
                }
              );
          if (e.source.type === h.Query) {
            const t = Object.fromEntries(n.map((t) => [t.title_cn, r(t.name)])),
              e = Object.fromEntries(n.map((t) => [t.title_en, r(t.name)])),
              i = Object.fromEntries(n.map((t) => [t.name, r(t.name)]));
            return Object.assign(t, e, i);
          }
          {
            const t = Object.fromEntries(
              Object.keys(i.locationMap).map((t) => [t, o(t)])
            );
            return Object.assign({}, t);
          }
        },
      });
  }
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(eZ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new eY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            majorPOIField: "majorPOI",
            minorPOIField: "minorPOI",
            colorField: "color",
            sizeField: "size",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      this.initHandle();
  }
  initHandle() {
    super.initHandle(), this.initEventListener();
  }
  initEventListener() {
    const { gisLayer: t } = this.variableContext;
    t.on("click", (t) => {
      if (this.comboTimer) {
        if (
          (clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = void 0;
          }, this.comboTimeout)),
          t)
        ) {
          const e = t.properties,
            i = this.buildRowData(e);
          s.call(this, b.BubbleDbClick, {
            RowData: i,
          });
        }
      } else
        this.comboTimer = setTimeout(() => {
          if (((this.comboTimer = void 0), t)) {
            const e = t.properties,
              i = this.buildRowData(e);
            let n = !1;
            L(e) || !f(this.selectedItem, e)
              ? ((this.selectedItem = e), (n = !0))
              : (this.selectedItem = null),
              s.call(this, b.BubbleClick, {
                RowData: i,
                selected: n,
              });
          } else
            this.selectedItem &&
              ((this.selectedItem = null),
              s.call(this, b.ChartBlankClick, {
                selected: !1,
              }));
        }, this.comboTimeout);
    });
  }
  getLayerConfig() {
    var t;
    const {
      display: e,
      common: i,
      icon: n,
      opacity: r,
      scale: o,
      color: a,
      poi: s,
    } = this.properties;
    let l = s.enable;
    l && this.editMode !== g.View && "show" !== s.trigger && (l = !1);
    return {
      common: {
        zoomRange: [i.zoomMin, i.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant:
              null !== (t = this.replaceStaticTemplatePath(n.image)) &&
              void 0 !== t
                ? t
                : "",
          },
          color: {
            default: a.defaultColor,
          },
        },
        segments: e.useCylinder ? 30 : e.segments,
      },
      animation: {
        opacity: {
          enabled: r.enable,
          min: r.min,
          max: r.max,
          speed: r.speed,
        },
        scale: {
          enabled: o.enable,
          min: o.min,
          max: o.max,
          speed: o.speed,
        },
      },
      poi: {
        ...s,
        enabled: l,
        coverEnable: !s.coverEnable,
        background: {
          ...s.background,
          map: this.replaceStaticTemplatePath(s.background.image),
          borderRadius: [
            s.background.borderRadius.topLeft,
            s.background.borderRadius.topRight,
            s.background.borderRadius.bottomRight,
            s.background.borderRadius.bottomLeft,
          ],
        },
        major: {
          ...s.labelFontStyle,
          enabled: s.labelFontStyle.enable,
          fontFamily: RX(s.labelFontStyle.fontFamily),
        },
        minor: {
          ...s.valueFontStyle,
          enabled: s.valueFontStyle.enable,
          fontFamily: RX(s.valueFontStyle.fontFamily),
        },
      },
      interaction: {
        hover: {
          enabled: this.editMode === g.View && "hover" === s.trigger,
          trigger: "mousemove",
          effect: {
            poi: !0,
          },
        },
        select: {
          enabled: this.editMode === g.View && "click" === s.trigger,
          multi: !1,
          trigger: "click",
          effect: {
            color: "1.3",
            poi: !0,
          },
        },
      },
    };
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: e },
        poi: { labelFontStyle: i, valueFontStyle: n },
      } = this.properties,
      { gis: r, gisLayer: o } = this.variableContext,
      { vizData: a, analytic: s } = this.POMNode.viz,
      { color: l } = this.properties;
    if (!t && f(this.preVizData, a)) return;
    if ((this.removeTips(), !a || 0 === a.datasets.length))
      return (
        (this.preVizData = void 0),
        o.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const c = [];
    try {
      const t = await lQ({
        vizData: a,
        analytic: s,
        gis: r,
        hasColorChannel: !0,
        hasSizeChannel: !0,
        hasPoiChannel: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      c.push(...t);
    } catch (m) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", m);
    }
    this.preVizData = a;
    const h = OX("majorLabel", a, s, 1),
      p = OX("subLabel", a, s, 2),
      d = I(h, a),
      g = I(p, a);
    o.set({
      data: u(c),
      style: {
        fill: {
          color: K2(a.displayConf.color, l.defaultColor),
        },
        size: $2(a.displayConf.size, 0),
      },
      poi: {
        major: {
          format: (t) => i.prefix + d(t) + i.suffix,
        },
        minor: {
          format: (t) => n.prefix + g(t) + n.suffix,
        },
      },
    }),
      super.tickLoop();
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(
          ["poi", "display", "color", "size", "icon", "opacity", "scale"],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(), super.tickLoop();
          }
        ),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(a3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(a3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.Bubble],
  }),
  Object.defineProperty(a3, "componentFilterDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: F2[tX.Bubble],
  }),
  Object.defineProperty(a3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "每项气泡单击",
        title_en: "Bubble Click",
        value: b.BubbleClick,
      },
      {
        title_cn: "每项气泡双击",
        title_en: "Bubble DbClick",
        value: b.BubbleDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class s3 extends WZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "buildRowData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: (t) => {
          if (!s3.analyticDeclaration) return;
          if (M(this.POMNode.viz)) return;
          const e = this.POMNode.viz.analytic,
            i = this.POMNode.viz.vizData,
            { vizFieldBlock: n } = s3.analyticDeclaration,
            r = (n) =>
              new Proxy(
                {},
                {
                  get: (r, o) => {
                    const a = e.vizFieldBlock[n].find((t) => t.name === o);
                    return I(a.id, i)(t[a.id]);
                  },
                }
              ),
            o = (e) =>
              new Proxy(
                {},
                {
                  get: (n, r) => {
                    const o = i.locationMap[e].find((t) => i.aliasMap[t] === r);
                    return I(o, i)(t[o]);
                  },
                }
              );
          if (e.source.type === h.Query) {
            const t = Object.fromEntries(n.map((t) => [t.title_cn, r(t.name)])),
              e = Object.fromEntries(n.map((t) => [t.title_en, r(t.name)])),
              i = Object.fromEntries(n.map((t) => [t.name, r(t.name)]));
            return Object.assign(t, e, i);
          }
          {
            const t = Object.fromEntries(
              Object.keys(i.locationMap).map((t) => [t, o(t)])
            );
            return Object.assign({}, t);
          }
        },
      });
  }
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(aZ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new dY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            majorPOIField: "majorPOI",
            minorPOIField: "minorPOI",
            colorField: "color",
            heightField: "size",
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      this.initHandle();
  }
  initHandle() {
    super.initHandle(), this.initEventListener();
  }
  initEventListener() {
    const { gisLayer: t } = this.variableContext;
    t.on("click", (t) => {
      if (this.comboTimer) {
        if (
          (clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = void 0;
          }, this.comboTimeout)),
          t)
        ) {
          const e = t.properties,
            i = this.buildRowData(e);
          s.call(this, b.BarDbClick, {
            RowData: i,
          });
        }
      } else
        this.comboTimer = setTimeout(() => {
          if (((this.comboTimer = void 0), t)) {
            const e = t.properties,
              i = this.buildRowData(e);
            let n = !1;
            L(e) || !f(this.selectedItem, e)
              ? ((this.selectedItem = e), (n = !0))
              : (this.selectedItem = null),
              s.call(this, b.BarClick, {
                RowData: i,
                selected: n,
              });
          } else
            this.selectedItem &&
              ((this.selectedItem = null),
              s.call(this, b.ChartBlankClick, {
                selected: !1,
              }));
        }, this.comboTimeout);
    });
  }
  getLayerConfig() {
    const { display: t, color: e, common: i, poi: n } = this.properties;
    let r = n.enable;
    r && this.editMode !== g.View && "show" !== n.trigger && (r = !1);
    return {
      common: {
        zoomRange: [i.zoomMin, i.zoomMax],
      },
      style: {
        fill: {
          color: {
            default: e.defaultColor,
          },
        },
        radiusTop: t.radiusTop,
        radiusBottom: t.radiusBottom,
        segments: t.useCylinder ? 32 : t.segments,
      },
      poi: {
        ...n,
        enabled: r,
        coverEnable: !n.coverEnable,
        background: {
          ...n.background,
          map: this.replaceStaticTemplatePath(n.background.image),
          borderRadius: [
            n.background.borderRadius.topLeft,
            n.background.borderRadius.topRight,
            n.background.borderRadius.bottomRight,
            n.background.borderRadius.bottomLeft,
          ],
        },
        major: {
          ...n.labelFontStyle,
          enabled: n.labelFontStyle.enable,
          fontFamily: RX(n.labelFontStyle.fontFamily),
        },
        minor: {
          ...n.valueFontStyle,
          enabled: n.valueFontStyle.enable,
          fontFamily: RX(n.valueFontStyle.fontFamily),
        },
      },
      interaction: {
        hover: {
          enabled: this.editMode === g.View && "hover" === n.trigger,
          trigger: "mousemove",
          effect: {
            poi: !0,
          },
        },
        select: {
          enabled: this.editMode === g.View && "click" === n.trigger,
          multi: !1,
          trigger: "click",
          effect: {
            color: "1.3",
            poi: !0,
          },
        },
      },
    };
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: e },
        poi: { labelFontStyle: i, valueFontStyle: n },
      } = this.properties,
      { gis: r, gisLayer: o } = this.variableContext,
      { vizData: a, analytic: s } = this.POMNode.viz,
      { color: l } = this.properties;
    if (!t && f(this.preVizData, a)) return;
    if ((this.removeTips(), !a || 0 === a.datasets.length))
      return (
        (this.preVizData = void 0),
        o.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const c = [];
    try {
      const t = await lQ({
        vizData: a,
        analytic: s,
        gis: r,
        hasColorChannel: !0,
        hasSizeChannel: !0,
        hasPoiChannel: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      c.push(...t);
    } catch (m) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", m);
    }
    this.preVizData = a;
    const h = OX("majorLabel", a, s, 1),
      p = OX("subLabel", a, s, 2),
      d = I(h, a),
      g = I(p, a);
    o.set({
      data: u(c),
      style: {
        fill: {
          color: K2(a.displayConf.color, l.defaultColor),
        },
        height: $2(a.displayConf.size, 0, 3),
      },
      poi: {
        major: {
          format: (t) => i.prefix + d(t) + i.suffix,
        },
        minor: {
          format: (t) => n.prefix + g(t) + n.suffix,
        },
      },
    }),
      super.tickOnce();
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(["poi"], "diffAnyoneDeep", () => {
          super.setLayerConfig(), super.tickLoop();
        }),
        this.propsWatch.defaultRule(
          ["display", "color"],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(), super.tickOnce();
          }
        ),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(s3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(s3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.Column],
  }),
  Object.defineProperty(s3, "componentFilterDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: F2[tX.Column],
  }),
  Object.defineProperty(s3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "每项柱形单击",
        title_en: "Bar Click",
        value: b.BarClick,
      },
      {
        title_cn: "每项柱形双击",
        title_en: "Bar DbClick",
        value: b.BarDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
class l3 extends qZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "firstLoad", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(this, "prePOMNodePlots", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: {},
      }),
      Object.defineProperty(this, "loadedItemsLength", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      }),
      Object.defineProperty(this, "totalItemsLength", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 0,
      });
  }
  async render(t) {
    var e, i, n;
    if (
      (this.removeTips(),
      null ===
        (n =
          null ===
            (i =
              null === (e = this.POMNode.page) || void 0 === e
                ? void 0
                : e.host) || void 0 === i
            ? void 0
            : i.layer) || void 0 === n
        ? void 0
        : n.variableContext.gis)
    ) {
      if (
        (t &&
          ((this.POMNode.properties = IX(pZ.presets, this.POMNode.properties)),
          (this.variableContext = {
            ...this.variableContext,
            carouselInterval: null,
            markers: new Map(),
            shuffleMarkers: [],
            isFromQuitEdit: !1,
            data: {},
          }),
          (this.parent = this.POMNode.page.host.layer),
          this.parent.drillEndCallback.push(
            this.updateDataAfterDrill.bind(this)
          ),
          (this.firstLoad = !0)),
        this.variableContext.gis ||
          (this.variableContext.gis =
            this.POMNode.page.host.layer.variableContext.gis),
        this.variableContext.gisLayer ||
          ((() => {
            if (document.getElementById("gis-informattionlabel-animation"))
              return;
            const t = document.createElement("style");
            (t.id = "gis-informattionlabel-animation"), (t.type = "text/css");
            const e = document.createTextNode(
              "\n   @keyframes fadeInFromLeft {\n     from {\n       transform: translateX(-100%);\n     }\n\n     to {\n       transform: translateX(0);\n     }\n   }\n   @keyframes fadeInFromRight {\n     from {\n       transform: translateX(100%);\n     }\n\n     to {\n       transform: translateX(0);\n     }\n   }\n   @keyframes fadeInFromTop {\n     from {\n       transform: translateY(-100%);\n     }\n\n     to {\n       transform: translateX(0);\n     }\n   }\n   @keyframes fadeInFromBottom {\n     from {\n       transform: translateY(100%);\n     }\n\n     to {\n       transform: translateX(0);\n     }\n   }\n\n   @keyframes fadeOutToLeft {\n    from {\n      transform: translateX(0);\n    }\n\n    to {\n      transform: translateX(-100%);\n    }\n  }\n  @keyframes fadeOutToRight {\n    from {\n      transform: translateX(0);\n    }\n\n    to {\n      transform: translateX(100%);\n    }\n  }\n  @keyframes fadeOutToTop {\n    from {\n      transform: translateY(0);\n    }\n\n    to {\n      transform: translateY(-100%);\n    }\n  }\n  @keyframes fadeOutToBottom {\n    from {\n      transform: translateY(0);\n    }\n\n    to {\n      transform: translateY(100%);\n    }\n  }\n "
            );
            t.appendChild(e),
              document.getElementsByTagName("head")[0].appendChild(t);
          })(),
          this.initLayer()),
        this.propsWatch.compare(this.preProperties, this.properties),
        this.propsWatch.compare(this.prePOMNodePlots, this.POMNode),
        this.toggleShowLabelByShowLabelCity(),
        this.updateSlicePlots(),
        M(this.POMNode.viz))
      )
        this.editMode !== g.View && this.renderDefaultTips();
      else {
        (await this.setData()) && this.initCarousel();
      }
      this.variableContext.isFromQuitEdit &&
        (this.rerenderMarker(), (this.variableContext.isFromQuitEdit = !1)),
        (this.preProperties = u(this.properties)),
        (this.prePOMNodePlots = {
          width: this.POMNode.width,
          height: this.POMNode.height,
          opacity: this.POMNode.opacity,
          clipOverflow: this.POMNode.clipOverflow,
        }),
        t && this.updateGisLayerVisible();
    }
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new nY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          label: {
            enabled: !0,
            markerType: "css2d",
            element: (t) => this._renderMarker(t),
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties));
  }
  getLayerConfig() {
    const { anchor: t } = this.properties;
    return {
      common: {
        zIndex: this.zIndex,
      },
      label: {
        anchor: {
          position: t.position,
          offset: [t.offset.x, t.offset.y],
        },
      },
    };
  }
  toggleShowLabelByShowLabelCity() {
    const { showLabelCity: t } = this.POMNode.data;
    if (t)
      for (let [e, i] of this.variableContext.markers.entries())
        "0" == i.style.opacity ||
          e.includes(t) ||
          this.toggleIntervalAnimationOut(i),
          e.includes(t) && this.toggleIntervalAnimationIn(i);
  }
  initCarousel() {
    const { carousel: t } = this.properties,
      { enable: e, stay: i } = t;
    if (
      (this.variableContext.carouselInterval &&
        (clearInterval(this.variableContext.carouselInterval),
        (this.variableContext.carouselInterval = null)),
      !e || this.editMode !== g.View)
    )
      return;
    this.variableContext.inOrderStart = 0;
    const n = () => {
      this.variableContext.startTimer &&
        (clearTimeout(this.variableContext.startTimer),
        (this.variableContext.startTimer = null)),
        (this.variableContext.startTimer = setTimeout(() => {
          document.querySelector(".marker-container").childElementCount > 0
            ? (this.carouselAnimation(),
              (this.variableContext.carouselInterval = setInterval(() => {
                this.carouselAnimation();
              }, 1e3 * i)))
            : n();
        }, 500));
    };
    n();
  }
  carouselAnimation() {
    const { carousel: t } = this.properties,
      { type: e, onceNumber: i } = t,
      n = Array.from(this.variableContext.markers.values()),
      r = this.getShuffleMarkers(n);
    n.forEach((t) => {
      "0" != t.style.opacity && this.toggleIntervalAnimationOut(t);
    });
    let o = [];
    e === lX.Random && (o = r), e === lX.InOrder && (o = n);
    const a = [],
      s = this.variableContext.inOrderStart + i,
      l = o.length;
    for (let u = this.variableContext.inOrderStart; u < s; u++)
      if (u < l) a.push(o[u]);
      else {
        const t = u % l;
        if (!(t < this.variableContext.inOrderStart)) break;
        a.push(o[t]);
      }
    a.forEach((t) => {
      this.toggleIntervalAnimationIn(t);
    }),
      (this.variableContext.inOrderStart = s % l);
  }
  getShuffleMarkers(t) {
    if (this.variableContext.shuffleMarkers.length > 0)
      return this.variableContext.shuffleMarkers;
    const e = [...t];
    let i,
      n,
      r = e.length;
    for (; r; )
      (i = Math.floor(Math.random() * r--)),
        (n = e[r]),
        (e[r] = e[i]),
        (e[i] = n);
    return (this.variableContext.shuffleMarkers = e), e;
  }
  updateSlicePlots() {
    const { width: t, height: e } = this.POMNode;
    this.POMNode.slices.forEach((i) => {
      (i.width = t), (i.height = e);
    });
  }
  updateDataAfterDrill() {
    var t;
    const { gis: e, data: i, gisLayer: n } = this.variableContext,
      r =
        null !== (t = e.layerManager.baseMapLayer.currentLevel) && void 0 !== t
          ? t
          : iX.country;
    if (i[r]) {
      this.clearVariableContextMarkers();
      const t = i[r];
      n.set({
        data: u(t),
      }),
        this.updateLayerInteractive();
    } else this.setData(!0);
    this.clearIntervals(), this.initCarousel();
  }
  async setData(t = !1) {
    var e, i;
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: n },
      } = this.properties,
      { vizData: r, analytic: o } = this.POMNode.viz,
      { gis: a, gisLayer: s } = this.variableContext,
      l =
        null !== (e = a.layerManager.baseMapLayer.currentLevel) && void 0 !== e
          ? e
          : iX.country;
    if (!t && f(this.preVizData, r)) return !1;
    if ((this.removeTips(), !r || 0 === r.datasets.length))
      return (
        (this.preVizData = void 0),
        s.set({
          data: [],
        }),
        (this.totalItemsLength = 0),
        super.tickOnce(),
        !1
      );
    const c = OX("location", r, o, 0),
      h = [],
      p = [],
      d = r.datasets,
      g = sQ(a, n),
      m =
        1 === a.layerManager.baseMapLayer.subDistrictInfoArr.length
          ? a.layerManager.baseMapLayer.subDistrictInfoArr[0].name
          : null;
    for (let u = 0; u < d.length; u++) {
      const t = d[u];
      try {
        const e = null !== (i = t[c]) && void 0 !== i ? i : "";
        if (e) {
          let t;
          const i = eQ(e);
          if (i.isLngLat) t = i;
          else {
            const i = qX(this.parent.POMNode.renderType, e);
            t = XV.getGeoCoordByAlias(i, a);
          }
          const r = {
            ext: {
              index: u,
              city: e,
            },
          };
          t
            ? (n || e !== m) && ((r.lng = t.lng), (r.lat = t.lat), h.push(r))
            : g && ((r.name = e), p.push(r));
        }
      } catch (y) {
        console.error("[vscreen-gis]", "数据解析经纬度失败", y);
      }
    }
    if (AX() && p.length > 0) {
      const t = await $X({
        address: p.map((t) => t.name),
      });
      p.forEach((e, i) => {
        const n = t[i].location;
        if (n) {
          const [t, i] = n.split(",");
          (e.lng = Number(t)), (e.lat = Number(i)), h.push(e);
        }
      });
    }
    return (
      (this.preVizData = r),
      this.clearVariableContextMarkers(),
      (this.variableContext.data[l] = h),
      (this.totalItemsLength = h.length),
      s.set({
        data: u(h),
      }),
      this.updateLayerInteractive(),
      super.tickOnce(),
      !0
    );
  }
  rerenderMarker() {
    Array.from(this.variableContext.markers.values()).forEach((t) => {
      const e = this.POMNode.slices[0].duplicate();
      (t.innerHTML = ""), this.renderer.renderLayer(e, t);
    });
  }
  _renderMarker(t) {
    const e = document.createElement("div"),
      i = this.POMNode.slices[0].duplicate(),
      { width: n, height: r, opacity: o, clipOverflow: a } = this.POMNode;
    (e.style.position = "relative"),
      (e.style.width = n + "px"),
      (e.style.height = r + "px"),
      (e.style.opacity = `${null != o ? o : 1}`),
      (e.style.overflow = a ? "hidden" : "visible"),
      (e.dataset.pomNodeId = this.POMNode.id),
      (e.dataset.pomNodeName = this.POMNode.name),
      (e.style.cssText += `\n      width: ${i.width}px;\n      height: ${i.height}px;\n    `),
      this.editMode !== g.View ||
        this.properties.marker.showAll ||
        (e.style.cssText +=
          "\n        opacity: 0;\n        pointer-events: none;\n      "),
      this.variableContext.markers.set(`${t.ext.city}-${t.ext.index}`, e);
    const l = (e) => {
      e.emitPayloads || (e.emitPayloads = {}),
        (e.emitPayloads[this.POMNode.id] = {
          target: this.POMNode,
          slice: i,
          rowDataIndex: t.ext.index,
          viz: this.POMNode.viz,
        });
    };
    return (
      e.removeEventListener(b.Click, l),
      e.addEventListener(b.Click, l),
      e.removeEventListener(b.DbClick, l),
      e.addEventListener(b.DbClick, l),
      this.editMode !== g.View
        ? this.renderer.renderLayer(i, e)
        : (this.renderer.storeItemNodeEventPayloadCache(i.id, {
            target: this.POMNode,
            slice: i,
            rowDataIndex: t.ext.index,
            viz: this.POMNode.viz,
          }),
          this.renderer.renderLayer(i, e).then(() => {
            s.call(this, b.ItemLoaded, {
              slice: i,
              rowDataIndex: t.ext.index,
              viz: this.POMNode.viz,
            }),
              this.loadedItemsLength++,
              this.firstLoad &&
                this.totalItemsLength === this.loadedItemsLength &&
                (super.initHandle(), (this.firstLoad = !1));
          })),
      e
    );
  }
  setMarkerDisplayStyle() {
    var t;
    const { width: e, height: i, opacity: n, clipOverflow: r } = this.POMNode;
    Array.from(
      null === (t = this.variableContext.markers) || void 0 === t
        ? void 0
        : t.values()
    ).forEach((t) => {
      (t.style.width = e + "px"),
        (t.style.height = i + "px"),
        (t.style.opacity = `${null != n ? n : 1}`),
        (t.style.overflow = r ? "hidden" : "visible");
    });
  }
  toggleIntervalAnimationIn(t) {
    const { carousel: e } = this.properties,
      { animationIn: i, durationIn: n } = e,
      { opacity: r } = this.POMNode;
    switch (i) {
      case aX.None:
        t.style.cssText += `\n          opacity: ${r};\n          animation: none;\n        `;
        break;
      case aX.FlyLeft:
        t.style.cssText += `\n          animation: fadeInFromLeft ${n}s;\n          opacity: ${r};\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyRight:
        t.style.cssText += `\n          animation: fadeInFromRight ${n}s;\n          opacity: ${r};\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyTop:
        t.style.cssText += `\n          animation: fadeInFromTop ${n}s;\n          opacity: ${r};\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyBottom:
        t.style.cssText += `\n          animation: fadeInFromBottom ${n}s;\n          opacity: ${r};\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.Gradient:
      default:
        t.style.cssText += `\n          opacity: ${r};\n          transition: all ${n}s linear;\n          animation: none;\n        `;
    }
    this.updateDOMInteractive(t, !0);
  }
  toggleIntervalAnimationOut(t) {
    const { carousel: e } = this.properties,
      { animationOut: i, durationOut: n } = e;
    switch (i) {
      case aX.None:
        t.style.cssText +=
          "\n          opacity: 0;\n          animation: none;\n        ";
        break;
      case aX.FlyLeft:
        t.style.cssText += `\n          animation: fadeOutToLeft ${n}s;\n          opacity: 0;\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyRight:
        t.style.cssText += `\n          animation: fadeOutToRight ${n}s;\n          opacity: 0;\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyTop:
        t.style.cssText += `\n          animation: fadeOutToTop ${n}s;\n          opacity: 0;\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.FlyBottom:
        t.style.cssText += `\n          animation: fadeOutToBottom ${n}s;\n          opacity: 0;\n          transition: all ${n}s linear;\n        `;
        break;
      case aX.Gradient:
      default:
        t.style.cssText += `\n          opacity: 0;\n          transition: all ${n}s linear;\n          animation: none;\n        `;
    }
    this.updateDOMInteractive(t, !1);
  }
  updateLayerInteractive() {
    var t;
    if (
      (null === (t = this.variableContext) || void 0 === t
        ? void 0
        : t.markers) &&
      this.editMode === g.View
    ) {
      Array.from(this.variableContext.markers.values()).forEach((t) => {
        "0" != t.style.opacity && this.updateDOMInteractive(t, !0);
      });
    }
  }
  updateDOMInteractive(t, e) {
    e
      ? ((t.style.cssText += "\n      pointer-events: auto;\n    "),
        (t.parentElement.style.pointerEvents = "auto"))
      : ((t.style.cssText += "\n      pointer-events: none;\n    "),
        (t.parentElement.style.pointerEvents = "none"));
  }
  setElementVisibility(t) {
    GZ.call(this, t), this.updateLayerInteractive();
  }
  enterEdit() {
    const { slices: t } = this.POMNode,
      [e] = t;
    let i = this.POMNode.parent;
    for (; !i.isSlice; ) i = i.parent;
    return (
      (this.variableContext.gisDOM = i.host.layer.dom),
      this.renderer.elementExitStage(),
      i.host.layer.resetNodePlots(),
      i.host.layer.storeViewport(),
      this.renderer.enterSlice(e),
      !0
    );
  }
  quitEdit() {
    let t = this.POMNode.parent;
    for (; !t.isSlice; ) t = t.parent;
    this.renderer.contentWrapper.append(this.variableContext.gisDOM),
      t.host.layer.enterEdit(),
      (this.variableContext.isFromQuitEdit = !0),
      this.render(!1),
      setTimeout(() => {
        super.tickOnce();
      }, 0);
  }
  forwardToPage() {
    let t = this.POMNode.parent;
    for (; !t.isSlice; ) t = t.parent;
    let e = t.host.slices[0].host.parent;
    for (; !e.isSlice || !e.isPage; )
      e.isSlice ? e.isPage || (e = e.host.parent) : (e = e.parent);
    this.renderer.exitSlice(e),
      (this.variableContext.isFromQuitEdit = !0),
      this.render(!1),
      setTimeout(() => {
        super.tickOnce();
      }, 0);
  }
  clearVariableContextMarkers() {
    this.variableContext.markers.clear(),
      (this.variableContext.shuffleMarkers = []);
  }
  clearIntervals() {
    this.variableContext.carouselInterval &&
      (clearInterval(this.variableContext.carouselInterval),
      (this.variableContext.carouselInterval = null)),
      this.variableContext.startTimer &&
        (clearTimeout(this.variableContext.startTimer),
        (this.variableContext.startTimer = null));
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule("anchor", "diffDeep", () => {
          super.setLayerConfig(), super.tickOnce();
        }),
        this.propsWatch.defaultRule(
          ["width", "height", "opacity", "clipOverflow"],
          "diffAnyoneDeep",
          () => {
            this.setMarkerDisplayStyle();
          }
        ),
      ]);
  }
  destroy(t) {
    this.clearIntervals(),
      this.POMNode.slices.forEach((e) => {
        var i, n;
        null === (n = (i = this.renderer).destroyLayer) ||
          void 0 === n ||
          n.call(i, e, void 0, t),
          e.children.forEach((t) => {
            var e, i;
            null ===
              (i =
                null === (e = this.renderer.page) || void 0 === e
                  ? void 0
                  : e.clear) ||
              void 0 === i ||
              i.call(e, t.id);
          });
      }),
      super.destroy(t);
  }
}
Object.defineProperty(l3, "analyticDeclaration", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z2[tX.InformationLabel],
}),
  Object.defineProperty(l3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "单击",
        title_en: "Click",
        value: b.Click,
      },
      {
        title_cn: "双击",
        title_en: "Double Click",
        value: b.DbClick,
      },
      {
        title_cn: "每项单击时",
        title_en: "Item Click",
        value: b.ItemClick,
      },
      {
        title_cn: "每项双击时",
        title_en: "Item Double Click",
        value: b.ItemDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "每项加载前",
        title_en: "Before Item Load",
        value: b.BeforeItemLoad,
      },
      {
        title_cn: "每项加载完成",
        title_en: "Item Loaded",
        value: b.ItemLoaded,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  }),
  Object.defineProperty(l3, "panelConfig", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: {
      panelLimit: 1,
      name: "Panel",
    },
  }),
  Object.defineProperty(l3, "chartConstraintRequest", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: P.GIS_MAP,
  });
class u3 extends WZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "buildRowData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: (t) => {
          if (!u3.analyticDeclaration) return;
          if (M(this.POMNode.viz)) return;
          const e = this.POMNode.viz.analytic,
            i = this.POMNode.viz.vizData,
            { vizFieldBlock: n } = u3.analyticDeclaration,
            r = (n) =>
              new Proxy(
                {},
                {
                  get: (r, o) => {
                    const a = e.vizFieldBlock[n].find((t) => t.name === o);
                    return I(a.id, i)(t[a.id]);
                  },
                }
              ),
            o = (e) =>
              new Proxy(
                {},
                {
                  get: (n, r) => {
                    const o = i.locationMap[e].find((t) => i.aliasMap[t] === r);
                    return I(o, i)(t[o]);
                  },
                }
              );
          if (e.source.type === h.Query) {
            const t = Object.fromEntries(n.map((t) => [t.title_cn, r(t.name)])),
              e = Object.fromEntries(n.map((t) => [t.title_en, r(t.name)])),
              i = Object.fromEntries(n.map((t) => [t.name, r(t.name)]));
            return Object.assign(t, e, i);
          }
          {
            const t = Object.fromEntries(
              Object.keys(i.locationMap).map((t) => [t, o(t)])
            );
            return Object.assign({}, t);
          }
        },
      });
  }
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(yZ.presets, this.POMNode.properties)),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new eY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            sizeField: "size",
            majorPOIField: "majorPOI",
            minorPOIField: "minorPOI",
          },
          animation: {
            opacity: {
              enabled: !1,
            },
            scale: {
              enabled: !1,
            },
          },
        })
      );
    (this.variableContext.gisLayer = e),
      (this.preProperties = u(this.properties)),
      this.initHandle();
  }
  initHandle() {
    super.initHandle(), this.initEventListener();
  }
  initEventListener() {
    const { gisLayer: t } = this.variableContext;
    t.on("click", (t) => {
      if (this.comboTimer) {
        if (
          (clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = void 0;
          }, this.comboTimeout)),
          t)
        ) {
          const e = t.properties,
            i = this.buildRowData(e);
          s.call(this, b.BubbleDbClick, {
            RowData: i,
          });
        }
      } else
        this.comboTimer = setTimeout(() => {
          if (((this.comboTimer = void 0), t)) {
            const e = t.properties,
              i = this.buildRowData(e);
            let n = !1;
            L(e) || !f(this.selectedItem, e)
              ? ((this.selectedItem = e), (n = !0))
              : (this.selectedItem = null),
              s.call(this, b.BubbleClick, {
                RowData: i,
                selected: n,
              });
          } else
            this.selectedItem &&
              ((this.selectedItem = null),
              s.call(this, b.ChartBlankClick, {
                selected: !1,
              }));
        }, this.comboTimeout);
    });
  }
  getLayerConfig() {
    var t;
    const { icon: e, color: i, poi: n, common: r } = this.properties;
    let o = n.enable;
    o && this.editMode !== g.View && "show" !== n.trigger && (o = !1);
    return {
      common: {
        zoomRange: [r.zoomMin, r.zoomMax],
      },
      style: {
        fill: {
          color: {
            type: "constant",
            constant: i.color,
            default: i.color,
          },
          map: {
            type: "constant",
            constant:
              null !== (t = this.replaceStaticTemplatePath(e.image)) &&
              void 0 !== t
                ? t
                : "",
          },
        },
        segments: e.type,
      },
      poi: {
        ...n,
        enabled: o,
        coverEnable: !n.coverEnable,
        background: {
          ...n.background,
          map: this.replaceStaticTemplatePath(n.background.image),
          borderRadius: [
            n.background.borderRadius.topLeft,
            n.background.borderRadius.topRight,
            n.background.borderRadius.bottomRight,
            n.background.borderRadius.bottomLeft,
          ],
        },
        major: {
          ...n.labelFontStyle,
          enabled: n.labelFontStyle.enable,
          fontFamily: RX(n.labelFontStyle.fontFamily),
        },
        minor: {
          ...n.valueFontStyle,
          enabled: n.valueFontStyle.enable,
          fontFamily: RX(n.valueFontStyle.fontFamily),
        },
      },
      interaction: {
        hover: {
          enabled: this.editMode === g.View && "hover" === n.trigger,
          trigger: "mousemove",
          effect: {
            poi: !0,
          },
        },
        select: {
          enabled: this.editMode === g.View && "click" === n.trigger,
          multi: !1,
          trigger: "click",
          effect: {
            color: "1.3",
            poi: !0,
          },
        },
      },
    };
  }
  async setData(t = !1) {
    var e, i, n;
    if (M(this.POMNode.viz)) return;
    const {
        common: { showAllLevelData: r },
        poi: { labelFontStyle: o, valueFontStyle: a },
      } = this.properties,
      { gis: s, gisLayer: l } = this.variableContext,
      { vizData: c, analytic: h } = this.POMNode.viz;
    if (!t && f(this.preVizData, c)) return;
    if ((this.removeTips(), !c || 0 === c.datasets.length))
      return (
        (this.preVizData = void 0),
        l.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const p = OX("location", c, h, 0),
      d = OX("majorLabel", c, h, 1),
      g = OX("subLabel", c, h, 2),
      m = FX("size", c),
      y = [],
      v = [],
      b = c.datasets,
      x = sQ(s, r),
      _ =
        1 === s.layerManager.baseMapLayer.subDistrictInfoArr.length
          ? s.layerManager.baseMapLayer.subDistrictInfoArr[0].name
          : null;
    for (let u = 0; u < b.length; u++) {
      const t = b[u];
      try {
        const o = null !== (e = t[p]) && void 0 !== e ? e : "",
          a = null !== (i = t[d]) && void 0 !== i ? i : "",
          l = +(null !== (n = t[g]) && void 0 !== n ? n : "");
        let u;
        const c = eQ(o);
        if (c.isLngLat) u = c;
        else {
          const t = qX(this.parent.POMNode.renderType, o);
          u = XV.getGeoCoordByAlias(t, s);
        }
        const h = {
          ...t,
          name: o,
          majorPOI: a,
          minorPOI: l,
        };
        hQ(h, !0, t, m),
          u
            ? (r || o !== _) && ((h.lng = u.lng), (h.lat = u.lat), y.push(h))
            : x && ((h.name = o), v.push(h));
      } catch (w) {
        console.error("[vscreen-gis]", "数据解析经纬度失败", t, w);
      }
    }
    if (AX() && v.length > 0) {
      const t = await $X({
        address: v.map((t) => t.name),
      });
      v.forEach((e, i) => {
        const n = t[i].location;
        if (n) {
          const [t, i] = n.split(",");
          (e.lng = Number(t)), (e.lat = Number(i)), y.push(e);
        }
      });
    }
    this.preVizData = c;
    const S = I(d, c),
      C = I(g, c);
    l.set({
      data: u(y),
      style: {
        size: $2(c.displayConf.size, 0),
      },
      poi: {
        major: {
          format: (t) => o.prefix + S(t) + o.suffix,
        },
        minor: {
          format: (t) => a.prefix + C(t) + a.suffix,
        },
      },
    }),
      super.tickLoop();
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          ["common", "showAllLevelData"],
          "diffDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(
          ["poi", "color", "size", "icon"],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(), super.tickLoop();
          }
        ),
      ]);
  }
  destroy() {
    super.destroy();
  }
}
Object.defineProperty(u3, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(u3, "dataBindType", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: "labelScatterQuery",
  }),
  Object.defineProperty(u3, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.LabelScatter],
  }),
  Object.defineProperty(u3, "componentFilterDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: F2[tX.LabelScatter],
  }),
  Object.defineProperty(u3, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "每项气泡单击",
        title_en: "Bubble Click",
        value: b.BubbleClick,
      },
      {
        title_cn: "每项气泡双击",
        title_en: "Bubble DbClick",
        value: b.BubbleDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  });
var c3 = 1,
  h3 = 2,
  p3 = 3,
  d3 = 4,
  f3 = 5,
  g3 = 6378137,
  m3 = 6356752.314,
  y3 = 0.0066943799901413165,
  v3 = 484813681109536e-20,
  b3 = Math.PI / 2,
  x3 = 0.16666666666666666,
  _3 = 0.04722222222222222,
  S3 = 0.022156084656084655,
  M3 = 1e-10,
  C3 = 0.017453292519943295,
  w3 = 57.29577951308232,
  A3 = Math.PI / 4,
  E3 = 2 * Math.PI,
  D3 = 3.14159265359,
  T3 = {
    greenwich: 0,
    lisbon: -9.131906111111,
    paris: 2.337229166667,
    bogota: -74.080916666667,
    madrid: -3.687938888889,
    rome: 12.452333333333,
    bern: 7.439583333333,
    jakarta: 106.807719444444,
    ferro: -17.666666666667,
    brussels: 4.367975,
    stockholm: 18.058277777778,
    athens: 23.7163375,
    oslo: 10.722916666667,
  };
const P3 = {
  ft: {
    to_meter: 0.3048,
  },
  "us-ft": {
    to_meter: 1200 / 3937,
  },
};
var L3 = /[\s_\-\/\(\)]/g;
function I3(t, e) {
  if (t[e]) return t[e];
  for (
    var i, n = Object.keys(t), r = e.toLowerCase().replace(L3, ""), o = -1;
    ++o < n.length;

  )
    if ((i = n[o]).toLowerCase().replace(L3, "") === r) return t[i];
}
function N3(t) {
  var e,
    i,
    n,
    r = {},
    o = t
      .split("+")
      .map(function (t) {
        return t.trim();
      })
      .filter(function (t) {
        return t;
      })
      .reduce(function (t, e) {
        var i = e.split("=");
        return i.push(!0), (t[i[0].toLowerCase()] = i[1]), t;
      }, {}),
    a = {
      proj: "projName",
      datum: "datumCode",
      rf: function (t) {
        r.rf = parseFloat(t);
      },
      lat_0: function (t) {
        r.lat0 = t * C3;
      },
      lat_1: function (t) {
        r.lat1 = t * C3;
      },
      lat_2: function (t) {
        r.lat2 = t * C3;
      },
      lat_ts: function (t) {
        r.lat_ts = t * C3;
      },
      lon_0: function (t) {
        r.long0 = t * C3;
      },
      lon_1: function (t) {
        r.long1 = t * C3;
      },
      lon_2: function (t) {
        r.long2 = t * C3;
      },
      alpha: function (t) {
        r.alpha = parseFloat(t) * C3;
      },
      gamma: function (t) {
        r.rectified_grid_angle = parseFloat(t);
      },
      lonc: function (t) {
        r.longc = t * C3;
      },
      x_0: function (t) {
        r.x0 = parseFloat(t);
      },
      y_0: function (t) {
        r.y0 = parseFloat(t);
      },
      k_0: function (t) {
        r.k0 = parseFloat(t);
      },
      k: function (t) {
        r.k0 = parseFloat(t);
      },
      a: function (t) {
        r.a = parseFloat(t);
      },
      b: function (t) {
        r.b = parseFloat(t);
      },
      r: function (t) {
        r.a = r.b = parseFloat(t);
      },
      r_a: function () {
        r.R_A = !0;
      },
      zone: function (t) {
        r.zone = parseInt(t, 10);
      },
      south: function () {
        r.utmSouth = !0;
      },
      towgs84: function (t) {
        r.datum_params = t.split(",").map(function (t) {
          return parseFloat(t);
        });
      },
      to_meter: function (t) {
        r.to_meter = parseFloat(t);
      },
      units: function (t) {
        r.units = t;
        var e = I3(P3, t);
        e && (r.to_meter = e.to_meter);
      },
      from_greenwich: function (t) {
        r.from_greenwich = t * C3;
      },
      pm: function (t) {
        var e = I3(T3, t);
        r.from_greenwich = (e || parseFloat(t)) * C3;
      },
      nadgrids: function (t) {
        "@null" === t ? (r.datumCode = "none") : (r.nadgrids = t);
      },
      axis: function (t) {
        var e = "ewnsud";
        3 === t.length &&
          -1 !== e.indexOf(t.substr(0, 1)) &&
          -1 !== e.indexOf(t.substr(1, 1)) &&
          -1 !== e.indexOf(t.substr(2, 1)) &&
          (r.axis = t);
      },
      approx: function () {
        r.approx = !0;
      },
    };
  for (e in o)
    (i = o[e]),
      e in a
        ? "function" == typeof (n = a[e])
          ? n(i)
          : (r[n] = i)
        : (r[e] = i);
  return (
    "string" == typeof r.datumCode &&
      "WGS84" !== r.datumCode &&
      (r.datumCode = r.datumCode.toLowerCase()),
    r
  );
}
var R3 = 1,
  O3 = /\s/,
  F3 = /[A-Za-z]/,
  z3 = /[A-Za-z84_]/,
  k3 = /[,\]]/,
  B3 = /[\d\.E\-\+]/;
function G3(t) {
  if ("string" != typeof t) throw new Error("not a string");
  (this.text = t.trim()),
    (this.level = 0),
    (this.place = 0),
    (this.root = null),
    (this.stack = []),
    (this.currentObject = null),
    (this.state = R3);
}
function U3(t, e, i) {
  Array.isArray(e) && (i.unshift(e), (e = null));
  var n = e ? {} : t,
    r = i.reduce(function (t, e) {
      return j3(e, t), t;
    }, n);
  e && (t[e] = r);
}
function j3(t, e) {
  if (Array.isArray(t)) {
    var i = t.shift();
    if (("PARAMETER" === i && (i = t.shift()), 1 === t.length))
      return Array.isArray(t[0])
        ? ((e[i] = {}), void j3(t[0], e[i]))
        : void (e[i] = t[0]);
    if (t.length)
      if ("TOWGS84" !== i) {
        if ("AXIS" === i) return i in e || (e[i] = []), void e[i].push(t);
        var n;
        switch ((Array.isArray(i) || (e[i] = {}), i)) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            return (
              (e[i] = {
                name: t[0].toLowerCase(),
                convert: t[1],
              }),
              void (3 === t.length && j3(t[2], e[i]))
            );
          case "SPHEROID":
          case "ELLIPSOID":
            return (
              (e[i] = {
                name: t[0],
                a: t[1],
                rf: t[2],
              }),
              void (4 === t.length && j3(t[3], e[i]))
            );
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "ENGINEERINGCRS":
          case "ENGCRS":
          case "FITTED_CS":
          case "LOCAL_DATUM":
          case "DATUM":
            return (t[0] = ["name", t[0]]), void U3(e, i, t);
          default:
            for (n = -1; ++n < t.length; )
              if (!Array.isArray(t[n])) return j3(t, e[i]);
            return U3(e, i, t);
        }
      } else e[i] = t;
    else e[i] = !0;
  } else e[t] = !0;
}
(G3.prototype.readCharicter = function () {
  var t = this.text[this.place++];
  if (4 !== this.state)
    for (; O3.test(t); ) {
      if (this.place >= this.text.length) return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case R3:
      return this.neutral(t);
    case 2:
      return this.keyword(t);
    case 4:
      return this.quoted(t);
    case 5:
      return this.afterquote(t);
    case 3:
      return this.number(t);
    case -1:
      return;
  }
}),
  (G3.prototype.afterquote = function (t) {
    if ('"' === t) return (this.word += '"'), void (this.state = 4);
    if (k3.test(t))
      return (this.word = this.word.trim()), void this.afterItem(t);
    throw new Error(
      "havn't handled \"" + t + '" in afterquote yet, index ' + this.place
    );
  }),
  (G3.prototype.afterItem = function (t) {
    return "," === t
      ? (null !== this.word && this.currentObject.push(this.word),
        (this.word = null),
        void (this.state = R3))
      : "]" === t
      ? (this.level--,
        null !== this.word &&
          (this.currentObject.push(this.word), (this.word = null)),
        (this.state = R3),
        (this.currentObject = this.stack.pop()),
        void (this.currentObject || (this.state = -1)))
      : void 0;
  }),
  (G3.prototype.number = function (t) {
    if (!B3.test(t)) {
      if (k3.test(t))
        return (this.word = parseFloat(this.word)), void this.afterItem(t);
      throw new Error(
        "havn't handled \"" + t + '" in number yet, index ' + this.place
      );
    }
    this.word += t;
  }),
  (G3.prototype.quoted = function (t) {
    '"' !== t ? (this.word += t) : (this.state = 5);
  }),
  (G3.prototype.keyword = function (t) {
    if (z3.test(t)) this.word += t;
    else {
      if ("[" === t) {
        var e = [];
        return (
          e.push(this.word),
          this.level++,
          null === this.root ? (this.root = e) : this.currentObject.push(e),
          this.stack.push(this.currentObject),
          (this.currentObject = e),
          void (this.state = R3)
        );
      }
      if (!k3.test(t))
        throw new Error(
          "havn't handled \"" + t + '" in keyword yet, index ' + this.place
        );
      this.afterItem(t);
    }
  }),
  (G3.prototype.neutral = function (t) {
    if (F3.test(t)) return (this.word = t), void (this.state = 2);
    if ('"' === t) return (this.word = ""), void (this.state = 4);
    if (B3.test(t)) return (this.word = t), void (this.state = 3);
    if (!k3.test(t))
      throw new Error(
        "havn't handled \"" + t + '" in neutral yet, index ' + this.place
      );
    this.afterItem(t);
  }),
  (G3.prototype.output = function () {
    for (; this.place < this.text.length; ) this.readCharicter();
    if (-1 === this.state) return this.root;
    throw new Error(
      'unable to parse string "' + this.text + '". State is ' + this.state
    );
  });
var H3,
  V3 = 0.017453292519943295;
function W3(t) {
  return t * V3;
}
function q3(t) {
  var e = new G3(t).output(),
    i = e.shift(),
    n = e.shift();
  e.unshift(["name", n]), e.unshift(["type", i]);
  var r = {};
  return (
    j3(e, r),
    (function (t) {
      if (
        ("GEOGCS" === t.type
          ? (t.projName = "longlat")
          : "LOCAL_CS" === t.type
          ? ((t.projName = "identity"), (t.local = !0))
          : "object" == typeof t.PROJECTION
          ? (t.projName = Object.keys(t.PROJECTION)[0])
          : (t.projName = t.PROJECTION),
        t.AXIS)
      ) {
        for (var e = "", i = 0, n = t.AXIS.length; i < n; ++i) {
          var r = [t.AXIS[i][0].toLowerCase(), t.AXIS[i][1].toLowerCase()];
          -1 !== r[0].indexOf("north") ||
          (("y" === r[0] || "lat" === r[0]) && "north" === r[1])
            ? (e += "n")
            : -1 !== r[0].indexOf("south") ||
              (("y" === r[0] || "lat" === r[0]) && "south" === r[1])
            ? (e += "s")
            : -1 !== r[0].indexOf("east") ||
              (("x" === r[0] || "lon" === r[0]) && "east" === r[1])
            ? (e += "e")
            : (-1 === r[0].indexOf("west") &&
                (("x" !== r[0] && "lon" !== r[0]) || "west" !== r[1])) ||
              (e += "w");
        }
        2 === e.length && (e += "u"), 3 === e.length && (t.axis = e);
      }
      t.UNIT &&
        ((t.units = t.UNIT.name.toLowerCase()),
        "metre" === t.units && (t.units = "meter"),
        t.UNIT.convert &&
          ("GEOGCS" === t.type
            ? t.DATUM &&
              t.DATUM.SPHEROID &&
              (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a)
            : (t.to_meter = t.UNIT.convert)));
      var o = t.GEOGCS;
      function a(e) {
        return e * (t.to_meter || 1);
      }
      "GEOGCS" === t.type && (o = t),
        o &&
          (o.DATUM
            ? (t.datumCode = o.DATUM.name.toLowerCase())
            : (t.datumCode = o.name.toLowerCase()),
          "d_" === t.datumCode.slice(0, 2) &&
            (t.datumCode = t.datumCode.slice(2)),
          ("new_zealand_geodetic_datum_1949" !== t.datumCode &&
            "new_zealand_1949" !== t.datumCode) ||
            (t.datumCode = "nzgd49"),
          ("wgs_1984" !== t.datumCode &&
            "world_geodetic_system_1984" !== t.datumCode) ||
            ("Mercator_Auxiliary_Sphere" === t.PROJECTION && (t.sphere = !0),
            (t.datumCode = "wgs84")),
          "_ferro" === t.datumCode.slice(-6) &&
            (t.datumCode = t.datumCode.slice(0, -6)),
          "_jakarta" === t.datumCode.slice(-8) &&
            (t.datumCode = t.datumCode.slice(0, -8)),
          ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"),
          o.DATUM &&
            o.DATUM.SPHEROID &&
            ((t.ellps = o.DATUM.SPHEROID.name
              .replace("_19", "")
              .replace(/[Cc]larke\_18/, "clrk")),
            "international" === t.ellps.toLowerCase().slice(0, 13) &&
              (t.ellps = "intl"),
            (t.a = o.DATUM.SPHEROID.a),
            (t.rf = parseFloat(o.DATUM.SPHEROID.rf, 10))),
          o.DATUM && o.DATUM.TOWGS84 && (t.datum_params = o.DATUM.TOWGS84),
          ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"),
          ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"),
          (~t.datumCode.indexOf("tm65") ||
            ~t.datumCode.indexOf("geodetic_datum_of_1965")) &&
            (t.datumCode = "ire65"),
          "ch1903+" === t.datumCode && (t.datumCode = "ch1903"),
          ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")),
        t.b && !isFinite(t.b) && (t.b = t.a),
        [
          ["standard_parallel_1", "Standard_Parallel_1"],
          ["standard_parallel_1", "Latitude of 1st standard parallel"],
          ["standard_parallel_2", "Standard_Parallel_2"],
          ["standard_parallel_2", "Latitude of 2nd standard parallel"],
          ["false_easting", "False_Easting"],
          ["false_easting", "False easting"],
          ["false-easting", "Easting at false origin"],
          ["false_northing", "False_Northing"],
          ["false_northing", "False northing"],
          ["false_northing", "Northing at false origin"],
          ["central_meridian", "Central_Meridian"],
          ["central_meridian", "Longitude of natural origin"],
          ["central_meridian", "Longitude of false origin"],
          ["latitude_of_origin", "Latitude_Of_Origin"],
          ["latitude_of_origin", "Central_Parallel"],
          ["latitude_of_origin", "Latitude of natural origin"],
          ["latitude_of_origin", "Latitude of false origin"],
          ["scale_factor", "Scale_Factor"],
          ["k0", "scale_factor"],
          ["latitude_of_center", "Latitude_Of_Center"],
          ["latitude_of_center", "Latitude_of_center"],
          ["lat0", "latitude_of_center", W3],
          ["longitude_of_center", "Longitude_Of_Center"],
          ["longitude_of_center", "Longitude_of_center"],
          ["longc", "longitude_of_center", W3],
          ["x0", "false_easting", a],
          ["y0", "false_northing", a],
          ["long0", "central_meridian", W3],
          ["lat0", "latitude_of_origin", W3],
          ["lat0", "standard_parallel_1", W3],
          ["lat1", "standard_parallel_1", W3],
          ["lat2", "standard_parallel_2", W3],
          ["azimuth", "Azimuth"],
          ["alpha", "azimuth", W3],
          ["srsCode", "name"],
        ].forEach(function (e) {
          return (
            (i = t),
            (r = (n = e)[0]),
            (o = n[1]),
            void (
              !(r in i) &&
              o in i &&
              ((i[r] = i[o]), 3 === n.length && (i[r] = n[2](i[r])))
            )
          );
          var i, n, r, o;
        }),
        t.long0 ||
          !t.longc ||
          ("Albers_Conic_Equal_Area" !== t.projName &&
            "Lambert_Azimuthal_Equal_Area" !== t.projName) ||
          (t.long0 = t.longc),
        t.lat_ts ||
        !t.lat1 ||
        ("Stereographic_South_Pole" !== t.projName &&
          "Polar Stereographic (variant B)" !== t.projName)
          ? !t.lat_ts &&
            t.lat0 &&
            "Polar_Stereographic" === t.projName &&
            ((t.lat_ts = t.lat0), (t.lat0 = W3(t.lat0 > 0 ? 90 : -90)))
          : ((t.lat0 = W3(t.lat1 > 0 ? 90 : -90)), (t.lat_ts = t.lat1));
    })(r),
    r
  );
}
function Y3(t) {
  var e = this;
  if (2 === arguments.length) {
    var i = arguments[1];
    "string" == typeof i
      ? "+" === i.charAt(0)
        ? (Y3[t] = N3(arguments[1]))
        : (Y3[t] = q3(arguments[1]))
      : (Y3[t] = i);
  } else if (1 === arguments.length) {
    if (Array.isArray(t))
      return t.map(function (t) {
        Array.isArray(t) ? Y3.apply(e, t) : Y3(t);
      });
    if ("string" == typeof t) {
      if (t in Y3) return Y3[t];
    } else
      "EPSG" in t
        ? (Y3["EPSG:" + t.EPSG] = t)
        : "ESRI" in t
        ? (Y3["ESRI:" + t.ESRI] = t)
        : "IAU2000" in t && (Y3["IAU2000:" + t.IAU2000] = t);
    return;
  }
}
(H3 = Y3)(
  "EPSG:4326",
  "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"
),
  H3(
    "EPSG:4269",
    "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"
  ),
  H3(
    "EPSG:3857",
    "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"
  ),
  (H3.WGS84 = H3["EPSG:4326"]),
  (H3["EPSG:3785"] = H3["EPSG:3857"]),
  (H3.GOOGLE = H3["EPSG:3857"]),
  (H3["EPSG:900913"] = H3["EPSG:3857"]),
  (H3["EPSG:102113"] = H3["EPSG:3857"]);
var X3 = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS",
];
var Q3 = ["3857", "900913", "3785", "102113"];
function Z3(t) {
  if (
    !(function (t) {
      return "string" == typeof t;
    })(t)
  )
    return t;
  if (
    (function (t) {
      return t in Y3;
    })(t)
  )
    return Y3[t];
  if (
    (function (t) {
      return X3.some(function (e) {
        return t.indexOf(e) > -1;
      });
    })(t)
  ) {
    var e = q3(t);
    if (
      (function (t) {
        var e = I3(t, "authority");
        if (e) {
          var i = I3(e, "epsg");
          return i && Q3.indexOf(i) > -1;
        }
      })(e)
    )
      return Y3["EPSG:3857"];
    var i = (function (t) {
      var e = I3(t, "extension");
      if (e) return I3(e, "proj4");
    })(e);
    return i ? N3(i) : e;
  }
  return (function (t) {
    return "+" === t[0];
  })(t)
    ? N3(t)
    : void 0;
}
function J3(t, e) {
  var i, n;
  if (((t = t || {}), !e)) return t;
  for (n in e) void 0 !== (i = e[n]) && (t[n] = i);
  return t;
}
function K3(t, e, i) {
  var n = t * e;
  return i / Math.sqrt(1 - n * n);
}
function $3(t) {
  return t < 0 ? -1 : 1;
}
function t5(t) {
  return Math.abs(t) <= D3 ? t : t - $3(t) * E3;
}
function e5(t, e, i) {
  var n = t * i,
    r = 0.5 * t;
  return (n = Math.pow((1 - n) / (1 + n), r)), Math.tan(0.5 * (b3 - e)) / n;
}
function i5(t, e) {
  for (var i, n, r = 0.5 * t, o = b3 - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (
      ((i = t * Math.sin(o)),
      (o += n = b3 - 2 * Math.atan(e * Math.pow((1 - i) / (1 + i), r)) - o),
      Math.abs(n) <= 1e-10)
    )
      return o;
  return -9999;
}
function n5(t) {
  return t;
}
var r5 = [
    {
      init: function () {
        var t = this.b / this.a;
        (this.es = 1 - t * t),
          "x0" in this || (this.x0 = 0),
          "y0" in this || (this.y0 = 0),
          (this.e = Math.sqrt(this.es)),
          this.lat_ts
            ? this.sphere
              ? (this.k0 = Math.cos(this.lat_ts))
              : (this.k0 = K3(
                  this.e,
                  Math.sin(this.lat_ts),
                  Math.cos(this.lat_ts)
                ))
            : this.k0 || (this.k ? (this.k0 = this.k) : (this.k0 = 1));
      },
      forward: function (t) {
        var e,
          i,
          n = t.x,
          r = t.y;
        if (r * w3 > 90 && r * w3 < -90 && n * w3 > 180 && n * w3 < -180)
          return null;
        if (Math.abs(Math.abs(r) - b3) <= M3) return null;
        if (this.sphere)
          (e = this.x0 + this.a * this.k0 * t5(n - this.long0)),
            (i = this.y0 + this.a * this.k0 * Math.log(Math.tan(A3 + 0.5 * r)));
        else {
          var o = Math.sin(r),
            a = e5(this.e, r, o);
          (e = this.x0 + this.a * this.k0 * t5(n - this.long0)),
            (i = this.y0 - this.a * this.k0 * Math.log(a));
        }
        return (t.x = e), (t.y = i), t;
      },
      inverse: function (t) {
        var e,
          i,
          n = t.x - this.x0,
          r = t.y - this.y0;
        if (this.sphere)
          i = b3 - 2 * Math.atan(Math.exp(-r / (this.a * this.k0)));
        else {
          var o = Math.exp(-r / (this.a * this.k0));
          if (-9999 === (i = i5(this.e, o))) return null;
        }
        return (
          (e = t5(this.long0 + n / (this.a * this.k0))), (t.x = e), (t.y = i), t
        );
      },
      names: [
        "Mercator",
        "Popular Visualisation Pseudo Mercator",
        "Mercator_1SP",
        "Mercator_Auxiliary_Sphere",
        "merc",
      ],
    },
    {
      init: function () {},
      forward: n5,
      inverse: n5,
      names: ["longlat", "identity"],
    },
  ],
  o5 = {},
  a5 = [];
function s5(t, e) {
  var i = a5.length;
  return (
    !t.names ||
    ((a5[i] = t),
    t.names.forEach(function (t) {
      o5[t.toLowerCase()] = i;
    }),
    this)
  );
}
const l5 = {
  start: function () {
    r5.forEach(s5);
  },
  add: s5,
  get: function (t) {
    if (!t) return !1;
    var e = t.toLowerCase();
    return void 0 !== o5[e] && a5[o5[e]] ? a5[o5[e]] : void 0;
  },
};
var u5 = {
    MERIT: {
      a: 6378137,
      rf: 298.257,
      ellipseName: "MERIT 1983",
    },
    SGS85: {
      a: 6378136,
      rf: 298.257,
      ellipseName: "Soviet Geodetic System 85",
    },
    GRS80: {
      a: 6378137,
      rf: 298.257222101,
      ellipseName: "GRS 1980(IUGG, 1980)",
    },
    IAU76: {
      a: 6378140,
      rf: 298.257,
      ellipseName: "IAU 1976",
    },
    airy: {
      a: 6377563.396,
      b: 6356256.91,
      ellipseName: "Airy 1830",
    },
    APL4: {
      a: 6378137,
      rf: 298.25,
      ellipseName: "Appl. Physics. 1965",
    },
    NWL9D: {
      a: 6378145,
      rf: 298.25,
      ellipseName: "Naval Weapons Lab., 1965",
    },
    mod_airy: {
      a: 6377340.189,
      b: 6356034.446,
      ellipseName: "Modified Airy",
    },
    andrae: {
      a: 6377104.43,
      rf: 300,
      ellipseName: "Andrae 1876 (Den., Iclnd.)",
    },
    aust_SA: {
      a: 6378160,
      rf: 298.25,
      ellipseName: "Australian Natl & S. Amer. 1969",
    },
    GRS67: {
      a: 6378160,
      rf: 298.247167427,
      ellipseName: "GRS 67(IUGG 1967)",
    },
    bessel: {
      a: 6377397.155,
      rf: 299.1528128,
      ellipseName: "Bessel 1841",
    },
    bess_nam: {
      a: 6377483.865,
      rf: 299.1528128,
      ellipseName: "Bessel 1841 (Namibia)",
    },
    clrk66: {
      a: 6378206.4,
      b: 6356583.8,
      ellipseName: "Clarke 1866",
    },
    clrk80: {
      a: 6378249.145,
      rf: 293.4663,
      ellipseName: "Clarke 1880 mod.",
    },
    clrk80ign: {
      a: 6378249.2,
      b: 6356515,
      rf: 293.4660213,
      ellipseName: "Clarke 1880 (IGN)",
    },
    clrk58: {
      a: 6378293.645208759,
      rf: 294.2606763692654,
      ellipseName: "Clarke 1858",
    },
    CPM: {
      a: 6375738.7,
      rf: 334.29,
      ellipseName: "Comm. des Poids et Mesures 1799",
    },
    delmbr: {
      a: 6376428,
      rf: 311.5,
      ellipseName: "Delambre 1810 (Belgium)",
    },
    engelis: {
      a: 6378136.05,
      rf: 298.2566,
      ellipseName: "Engelis 1985",
    },
    evrst30: {
      a: 6377276.345,
      rf: 300.8017,
      ellipseName: "Everest 1830",
    },
    evrst48: {
      a: 6377304.063,
      rf: 300.8017,
      ellipseName: "Everest 1948",
    },
    evrst56: {
      a: 6377301.243,
      rf: 300.8017,
      ellipseName: "Everest 1956",
    },
    evrst69: {
      a: 6377295.664,
      rf: 300.8017,
      ellipseName: "Everest 1969",
    },
    evrstSS: {
      a: 6377298.556,
      rf: 300.8017,
      ellipseName: "Everest (Sabah & Sarawak)",
    },
    fschr60: {
      a: 6378166,
      rf: 298.3,
      ellipseName: "Fischer (Mercury Datum) 1960",
    },
    fschr60m: {
      a: 6378155,
      rf: 298.3,
      ellipseName: "Fischer 1960",
    },
    fschr68: {
      a: 6378150,
      rf: 298.3,
      ellipseName: "Fischer 1968",
    },
    helmert: {
      a: 6378200,
      rf: 298.3,
      ellipseName: "Helmert 1906",
    },
    hough: {
      a: 6378270,
      rf: 297,
      ellipseName: "Hough",
    },
    intl: {
      a: 6378388,
      rf: 297,
      ellipseName: "International 1909 (Hayford)",
    },
    kaula: {
      a: 6378163,
      rf: 298.24,
      ellipseName: "Kaula 1961",
    },
    lerch: {
      a: 6378139,
      rf: 298.257,
      ellipseName: "Lerch 1979",
    },
    mprts: {
      a: 6397300,
      rf: 191,
      ellipseName: "Maupertius 1738",
    },
    new_intl: {
      a: 6378157.5,
      b: 6356772.2,
      ellipseName: "New International 1967",
    },
    plessis: {
      a: 6376523,
      rf: 6355863,
      ellipseName: "Plessis 1817 (France)",
    },
    krass: {
      a: 6378245,
      rf: 298.3,
      ellipseName: "Krassovsky, 1942",
    },
    SEasia: {
      a: 6378155,
      b: 6356773.3205,
      ellipseName: "Southeast Asia",
    },
    walbeck: {
      a: 6376896,
      b: 6355834.8467,
      ellipseName: "Walbeck",
    },
    WGS60: {
      a: 6378165,
      rf: 298.3,
      ellipseName: "WGS 60",
    },
    WGS66: {
      a: 6378145,
      rf: 298.25,
      ellipseName: "WGS 66",
    },
    WGS7: {
      a: 6378135,
      rf: 298.26,
      ellipseName: "WGS 72",
    },
  },
  c5 = (u5.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84",
  });
u5.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)",
};
var h5 = {};
(h5.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84",
}),
  (h5.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss",
  }),
  (h5.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987",
  }),
  (h5.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983",
  }),
  (h5.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927",
  }),
  (h5.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN",
  }),
  (h5.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia",
  }),
  (h5.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel",
  }),
  (h5.militargeographische_institut = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut",
  }),
  (h5.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National",
  }),
  (h5.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965",
  }),
  (h5.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran",
  }),
  (h5.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949",
  }),
  (h5.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830",
  }),
  (h5.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)",
  }),
  (h5.beduaram = {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram",
  }),
  (h5.gunung_segara = {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta",
  }),
  (h5.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972",
  });
var p5 = {};
function d5(t) {
  if (0 === t.length) return null;
  var e = "@" === t[0];
  return (
    e && (t = t.slice(1)),
    "null" === t
      ? {
          name: "null",
          mandatory: !e,
          grid: null,
          isNull: !0,
        }
      : {
          name: t,
          mandatory: !e,
          grid: p5[t] || null,
          isNull: !1,
        }
  );
}
function f5(t) {
  return ((t / 3600) * Math.PI) / 180;
}
function g5(t, e, i) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, i)));
}
function m5(t) {
  return t.map(function (t) {
    return [f5(t.longitudeShift), f5(t.latitudeShift)];
  });
}
function y5(t, e, i) {
  return {
    name: g5(t, e + 8, e + 16).trim(),
    parent: g5(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, i),
    upperLatitude: t.getFloat64(e + 88, i),
    lowerLongitude: t.getFloat64(e + 104, i),
    upperLongitude: t.getFloat64(e + 120, i),
    latitudeInterval: t.getFloat64(e + 136, i),
    longitudeInterval: t.getFloat64(e + 152, i),
    gridNodeCount: t.getInt32(e + 168, i),
  };
}
function v5(t, e, i, n) {
  for (var r = e + 176, o = [], a = 0; a < i.gridNodeCount; a++) {
    var s = {
      latitudeShift: t.getFloat32(r + 16 * a, n),
      longitudeShift: t.getFloat32(r + 16 * a + 4, n),
      latitudeAccuracy: t.getFloat32(r + 16 * a + 8, n),
      longitudeAccuracy: t.getFloat32(r + 16 * a + 12, n),
    };
    o.push(s);
  }
  return o;
}
function b5(t, e) {
  if (!(this instanceof b5)) return new b5(t);
  e =
    e ||
    function (t) {
      if (t) throw t;
    };
  var i = Z3(t);
  if ("object" == typeof i) {
    var n = b5.projections.get(i.projName);
    if (n) {
      if (i.datumCode && "none" !== i.datumCode) {
        var r = I3(h5, i.datumCode);
        r &&
          ((i.datum_params =
            i.datum_params || (r.towgs84 ? r.towgs84.split(",") : null)),
          (i.ellps = r.ellipse),
          (i.datumName = r.datumName ? r.datumName : i.datumCode));
      }
      (i.k0 = i.k0 || 1),
        (i.axis = i.axis || "enu"),
        (i.ellps = i.ellps || "wgs84"),
        (i.lat1 = i.lat1 || i.lat0);
      var o = (function (t, e, i, n, r) {
          if (!t) {
            var o = I3(u5, n);
            o || (o = c5), (t = o.a), (e = o.b), (i = o.rf);
          }
          return (
            i && !e && (e = (1 - 1 / i) * t),
            (0 === i || Math.abs(t - e) < M3) && ((r = !0), (e = t)),
            {
              a: t,
              b: e,
              rf: i,
              sphere: r,
            }
          );
        })(i.a, i.b, i.rf, i.ellps, i.sphere),
        a = (function (t, e, i, n) {
          var r = t * t,
            o = e * e,
            a = (r - o) / r,
            s = 0;
          return (
            n
              ? ((r = (t *= 1 - a * (x3 + a * (_3 + a * S3))) * t), (a = 0))
              : (s = Math.sqrt(a)),
            {
              es: a,
              e: s,
              ep2: (r - o) / o,
            }
          );
        })(o.a, o.b, o.rf, i.R_A),
        s = (function (t) {
          return void 0 === t ? null : t.split(",").map(d5);
        })(i.nadgrids),
        l =
          i.datum ||
          (function (t, e, i, n, r, o, a) {
            var s = {};
            return (
              (s.datum_type = void 0 === t || "none" === t ? f3 : d3),
              e &&
                ((s.datum_params = e.map(parseFloat)),
                (0 === s.datum_params[0] &&
                  0 === s.datum_params[1] &&
                  0 === s.datum_params[2]) ||
                  (s.datum_type = c3),
                s.datum_params.length > 3 &&
                  ((0 === s.datum_params[3] &&
                    0 === s.datum_params[4] &&
                    0 === s.datum_params[5] &&
                    0 === s.datum_params[6]) ||
                    ((s.datum_type = h3),
                    (s.datum_params[3] *= v3),
                    (s.datum_params[4] *= v3),
                    (s.datum_params[5] *= v3),
                    (s.datum_params[6] = s.datum_params[6] / 1e6 + 1)))),
              a && ((s.datum_type = p3), (s.grids = a)),
              (s.a = i),
              (s.b = n),
              (s.es = r),
              (s.ep2 = o),
              s
            );
          })(i.datumCode, i.datum_params, o.a, o.b, a.es, a.ep2, s);
      J3(this, i),
        J3(this, n),
        (this.a = o.a),
        (this.b = o.b),
        (this.rf = o.rf),
        (this.sphere = o.sphere),
        (this.es = a.es),
        (this.e = a.e),
        (this.ep2 = a.ep2),
        (this.datum = l),
        this.init(),
        e(null, this);
    } else e(t);
  } else e(t);
}
function x5(t, e, i) {
  var n,
    r,
    o,
    a,
    s = t.x,
    l = t.y,
    u = t.z ? t.z : 0;
  if (l < -b3 && l > -1.001 * b3) l = -b3;
  else if (l > b3 && l < 1.001 * b3) l = b3;
  else {
    if (l < -b3)
      return {
        x: -1 / 0,
        y: -1 / 0,
        z: t.z,
      };
    if (l > b3)
      return {
        x: 1 / 0,
        y: 1 / 0,
        z: t.z,
      };
  }
  return (
    s > Math.PI && (s -= 2 * Math.PI),
    (r = Math.sin(l)),
    (a = Math.cos(l)),
    (o = r * r),
    {
      x: ((n = i / Math.sqrt(1 - e * o)) + u) * a * Math.cos(s),
      y: (n + u) * a * Math.sin(s),
      z: (n * (1 - e) + u) * r,
    }
  );
}
function _5(t, e, i, n) {
  var r,
    o,
    a,
    s,
    l,
    u,
    c,
    h,
    p,
    d,
    f,
    g,
    m,
    y,
    v,
    b = 1e-12,
    x = t.x,
    _ = t.y,
    S = t.z ? t.z : 0;
  if (
    ((r = Math.sqrt(x * x + _ * _)),
    (o = Math.sqrt(x * x + _ * _ + S * S)),
    r / i < b)
  ) {
    if (((y = 0), o / i < b))
      return (
        b3,
        (v = -n),
        {
          x: t.x,
          y: t.y,
          z: t.z,
        }
      );
  } else y = Math.atan2(_, x);
  (a = S / o),
    (h = (s = r / o) * (1 - e) * (l = 1 / Math.sqrt(1 - e * (2 - e) * s * s))),
    (p = a * l),
    (m = 0);
  do {
    m++,
      (u =
        (e * (c = i / Math.sqrt(1 - e * p * p))) /
        (c + (v = r * h + S * p - c * (1 - e * p * p)))),
      (g =
        (f = a * (l = 1 / Math.sqrt(1 - u * (2 - u) * s * s))) * h -
        (d = s * (1 - u) * l) * p),
      (h = d),
      (p = f);
  } while (g * g > 1e-24 && m < 30);
  return {
    x: y,
    y: Math.atan(f / Math.abs(d)),
    z: v,
  };
}
function S5(t) {
  return t === c3 || t === h3;
}
function M5(t, e, i) {
  if (
    (function (t, e) {
      return (
        t.datum_type === e.datum_type &&
        !(t.a !== e.a || Math.abs(t.es - e.es) > 5e-11) &&
        (t.datum_type === c3
          ? t.datum_params[0] === e.datum_params[0] &&
            t.datum_params[1] === e.datum_params[1] &&
            t.datum_params[2] === e.datum_params[2]
          : t.datum_type !== h3 ||
            (t.datum_params[0] === e.datum_params[0] &&
              t.datum_params[1] === e.datum_params[1] &&
              t.datum_params[2] === e.datum_params[2] &&
              t.datum_params[3] === e.datum_params[3] &&
              t.datum_params[4] === e.datum_params[4] &&
              t.datum_params[5] === e.datum_params[5] &&
              t.datum_params[6] === e.datum_params[6]))
      );
    })(t, e)
  )
    return i;
  if (t.datum_type === f3 || e.datum_type === f3) return i;
  var n = t.a,
    r = t.es;
  if (t.datum_type === p3) {
    if (0 !== C5(t, !1, i)) return;
    (n = g3), (r = y3);
  }
  var o = e.a,
    a = e.b,
    s = e.es;
  if (
    (e.datum_type === p3 && ((o = g3), (a = m3), (s = y3)),
    r === s && n === o && !S5(t.datum_type) && !S5(e.datum_type))
  )
    return i;
  if (
    ((i = x5(i, r, n)),
    S5(t.datum_type) &&
      (i = (function (t, e, i) {
        if (e === c3)
          return {
            x: t.x + i[0],
            y: t.y + i[1],
            z: t.z + i[2],
          };
        if (e === h3) {
          var n = i[0],
            r = i[1],
            o = i[2],
            a = i[3],
            s = i[4],
            l = i[5],
            u = i[6];
          return {
            x: u * (t.x - l * t.y + s * t.z) + n,
            y: u * (l * t.x + t.y - a * t.z) + r,
            z: u * (-s * t.x + a * t.y + t.z) + o,
          };
        }
      })(i, t.datum_type, t.datum_params)),
    S5(e.datum_type) &&
      (i = (function (t, e, i) {
        if (e === c3)
          return {
            x: t.x - i[0],
            y: t.y - i[1],
            z: t.z - i[2],
          };
        if (e === h3) {
          var n = i[0],
            r = i[1],
            o = i[2],
            a = i[3],
            s = i[4],
            l = i[5],
            u = i[6],
            c = (t.x - n) / u,
            h = (t.y - r) / u,
            p = (t.z - o) / u;
          return {
            x: c + l * h - s * p,
            y: -l * c + h + a * p,
            z: s * c - a * h + p,
          };
        }
      })(i, e.datum_type, e.datum_params)),
    (i = _5(i, s, o, a)),
    e.datum_type === p3) &&
    0 !== C5(e, !0, i)
  )
    return;
  return i;
}
function C5(t, e, i) {
  if (null === t.grids || 0 === t.grids.length) return -1;
  var n = {
      x: -i.x,
      y: i.y,
    },
    r = {
      x: Number.NaN,
      y: Number.NaN,
    },
    o = [];
  t: for (var a = 0; a < t.grids.length; a++) {
    var s = t.grids[a];
    if ((o.push(s.name), s.isNull)) {
      r = n;
      break;
    }
    if ((s.mandatory, null !== s.grid))
      for (var l = s.grid.subgrids, u = 0, c = l.length; u < c; u++) {
        var h = l[u],
          p = (Math.abs(h.del[1]) + Math.abs(h.del[0])) / 1e4,
          d = h.ll[0] - p,
          f = h.ll[1] - p,
          g = h.ll[0] + (h.lim[0] - 1) * h.del[0] + p,
          m = h.ll[1] + (h.lim[1] - 1) * h.del[1] + p;
        if (
          !(f > n.y || d > n.x || m < n.y || g < n.x) &&
          ((r = w5(n, e, h)), !isNaN(r.x))
        )
          break t;
      }
    else if (s.mandatory) return s.name, -1;
  }
  return isNaN(r.x) ? -1 : ((i.x = -r.x), (i.y = r.y), 0);
}
function w5(t, e, i) {
  var n = {
    x: Number.NaN,
    y: Number.NaN,
  };
  if (isNaN(t.x)) return n;
  var r = {
    x: t.x,
    y: t.y,
  };
  (r.x -= i.ll[0]), (r.y -= i.ll[1]), (r.x = t5(r.x - Math.PI) + Math.PI);
  var o = A5(r, i);
  if (e) {
    if (isNaN(o.x)) return n;
    (o.x = r.x - o.x), (o.y = r.y - o.y);
    var a,
      s,
      l = 9;
    do {
      if (((s = A5(o, i)), isNaN(s.x))) break;
      (a = {
        x: r.x - (s.x + o.x),
        y: r.y - (s.y + o.y),
      }),
        (o.x += a.x),
        (o.y += a.y);
    } while (l-- && Math.abs(a.x) > 1e-12 && Math.abs(a.y) > 1e-12);
    if (l < 0) return n;
    (n.x = t5(o.x + i.ll[0])), (n.y = o.y + i.ll[1]);
  } else isNaN(o.x) || ((n.x = t.x + o.x), (n.y = t.y + o.y));
  return n;
}
function A5(t, e) {
  var i,
    n = {
      x: t.x / e.del[0],
      y: t.y / e.del[1],
    },
    r = Math.floor(n.x),
    o = Math.floor(n.y),
    a = n.x - 1 * r,
    s = n.y - 1 * o,
    l = {
      x: Number.NaN,
      y: Number.NaN,
    };
  if (r < 0 || r >= e.lim[0]) return l;
  if (o < 0 || o >= e.lim[1]) return l;
  i = o * e.lim[0] + r;
  var u = e.cvs[i][0],
    c = e.cvs[i][1];
  i++;
  var h = e.cvs[i][0],
    p = e.cvs[i][1];
  i += e.lim[0];
  var d = e.cvs[i][0],
    f = e.cvs[i][1];
  i--;
  var g = e.cvs[i][0],
    m = e.cvs[i][1],
    y = a * s,
    v = a * (1 - s),
    b = (1 - a) * (1 - s),
    x = (1 - a) * s;
  return (
    (l.x = b * u + v * h + x * g + y * d),
    (l.y = b * c + v * p + x * m + y * f),
    l
  );
}
function E5(t, e, i) {
  var n,
    r,
    o,
    a = i.x,
    s = i.y,
    l = i.z || 0,
    u = {};
  for (o = 0; o < 3; o++)
    if (!e || 2 !== o || void 0 !== i.z)
      switch (
        (0 === o
          ? ((n = a), (r = -1 !== "ew".indexOf(t.axis[o]) ? "x" : "y"))
          : 1 === o
          ? ((n = s), (r = -1 !== "ns".indexOf(t.axis[o]) ? "y" : "x"))
          : ((n = l), (r = "z")),
        t.axis[o])
      ) {
        case "e":
        case "n":
          u[r] = n;
          break;
        case "w":
        case "s":
          u[r] = -n;
          break;
        case "u":
          void 0 !== i[r] && (u.z = n);
          break;
        case "d":
          void 0 !== i[r] && (u.z = -n);
          break;
        default:
          return null;
      }
  return u;
}
function D5(t) {
  var e = {
    x: t[0],
    y: t[1],
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function T5(t) {
  if ("function" == typeof Number.isFinite) {
    if (Number.isFinite(t)) return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if ("number" != typeof t || t != t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function P5(t, e, i, n) {
  var r,
    o =
      void 0 !==
      (i = Array.isArray(i)
        ? D5(i)
        : {
            x: i.x,
            y: i.y,
            z: i.z,
            m: i.m,
          }).z;
  if (
    ((function (t) {
      T5(t.x), T5(t.y);
    })(i),
    t.datum &&
      e.datum &&
      (function (t, e) {
        return (
          ((t.datum.datum_type === c3 ||
            t.datum.datum_type === h3 ||
            t.datum.datum_type === p3) &&
            "WGS84" !== e.datumCode) ||
          ((e.datum.datum_type === c3 ||
            e.datum.datum_type === h3 ||
            e.datum.datum_type === p3) &&
            "WGS84" !== t.datumCode)
        );
      })(t, e) &&
      ((i = P5(t, (r = new b5("WGS84")), i, n)), (t = r)),
    n && "enu" !== t.axis && (i = E5(t, !1, i)),
    "longlat" === t.projName)
  )
    i = {
      x: i.x * C3,
      y: i.y * C3,
      z: i.z || 0,
    };
  else if (
    (t.to_meter &&
      (i = {
        x: i.x * t.to_meter,
        y: i.y * t.to_meter,
        z: i.z || 0,
      }),
    !(i = t.inverse(i)))
  )
    return;
  if (
    (t.from_greenwich && (i.x += t.from_greenwich),
    (i = M5(t.datum, e.datum, i)))
  )
    return (
      e.from_greenwich &&
        (i = {
          x: i.x - e.from_greenwich,
          y: i.y,
          z: i.z || 0,
        }),
      "longlat" === e.projName
        ? (i = {
            x: i.x * w3,
            y: i.y * w3,
            z: i.z || 0,
          })
        : ((i = e.forward(i)),
          e.to_meter &&
            (i = {
              x: i.x / e.to_meter,
              y: i.y / e.to_meter,
              z: i.z || 0,
            })),
      n && "enu" !== e.axis ? E5(e, !0, i) : (i && !o && delete i.z, i)
    );
}
(b5.projections = l5), b5.projections.start();
var L5 = b5("WGS84");
function I5(t, e, i, n) {
  var r, o, a;
  return Array.isArray(i)
    ? ((r = P5(t, e, i, n) || {
        x: NaN,
        y: NaN,
      }),
      i.length > 2
        ? (void 0 !== t.name && "geocent" === t.name) ||
          (void 0 !== e.name && "geocent" === e.name)
          ? "number" == typeof r.z
            ? [r.x, r.y, r.z].concat(i.splice(3))
            : [r.x, r.y, i[2]].concat(i.splice(3))
          : [r.x, r.y].concat(i.splice(2))
        : [r.x, r.y])
    : ((o = P5(t, e, i, n)),
      2 === (a = Object.keys(i)).length ||
        a.forEach(function (n) {
          if (
            (void 0 !== t.name && "geocent" === t.name) ||
            (void 0 !== e.name && "geocent" === e.name)
          ) {
            if ("x" === n || "y" === n || "z" === n) return;
          } else if ("x" === n || "y" === n) return;
          o[n] = i[n];
        }),
      o);
}
function N5(t) {
  return t instanceof b5 ? t : t.oProj ? t.oProj : b5(t);
}
function R5(t, e, i) {
  t = N5(t);
  var n,
    r = !1;
  return (
    void 0 === e
      ? ((e = t), (t = L5), (r = !0))
      : (void 0 !== e.x || Array.isArray(e)) &&
        ((i = e), (e = t), (t = L5), (r = !0)),
    (e = N5(e)),
    i
      ? I5(t, e, i)
      : ((n = {
          forward: function (i, n) {
            return I5(t, e, i, n);
          },
          inverse: function (i, n) {
            return I5(e, t, i, n);
          },
        }),
        r && (n.oProj = e),
        n)
  );
}
var O5 = 6,
  F5 = "AJSAJS",
  z5 = "AFAFAF",
  k5 = 65,
  B5 = 73,
  G5 = 79,
  U5 = 86,
  j5 = 90;
const H5 = {
  forward: V5,
  inverse: function (t) {
    var e = X5(J5(t.toUpperCase()));
    if (e.lat && e.lon) return [e.lon, e.lat, e.lon, e.lat];
    return [e.left, e.bottom, e.right, e.top];
  },
  toPoint: W5,
};
function V5(t, e) {
  return (
    (e = e || 5),
    (function (t, e) {
      var i = "00000" + t.easting,
        n = "00000" + t.northing;
      return (
        t.zoneNumber +
        t.zoneLetter +
        ((r = t.easting),
        (o = t.northing),
        (a = t.zoneNumber),
        (s = Z5(a)),
        (l = Math.floor(r / 1e5)),
        (u = Math.floor(o / 1e5) % 20),
        (function (t, e, i) {
          var n = i - 1,
            r = F5.charCodeAt(n),
            o = z5.charCodeAt(n),
            a = r + t - 1,
            s = o + e,
            l = !1;
          return (
            a > j5 && ((a = a - j5 + k5 - 1), (l = !0)),
            (a === B5 || (r < B5 && a > B5) || ((a > B5 || r < B5) && l)) &&
              a++,
            (a === G5 || (r < G5 && a > G5) || ((a > G5 || r < G5) && l)) &&
              ++a === B5 &&
              a++,
            a > j5 && (a = a - j5 + k5 - 1),
            s > U5 ? ((s = s - U5 + k5 - 1), (l = !0)) : (l = !1),
            (s === B5 || (o < B5 && s > B5) || ((s > B5 || o < B5) && l)) &&
              s++,
            (s === G5 || (o < G5 && s > G5) || ((s > G5 || o < G5) && l)) &&
              ++s === B5 &&
              s++,
            s > U5 && (s = s - U5 + k5 - 1),
            String.fromCharCode(a) + String.fromCharCode(s)
          );
        })(l, u, s)) +
        i.substr(i.length - 5, e) +
        n.substr(n.length - 5, e)
      );
      var r, o, a, s, l, u;
    })(
      (function (t) {
        var e,
          i,
          n,
          r,
          o,
          a,
          s,
          l,
          u = t.lat,
          c = t.lon,
          h = 6378137,
          p = 0.00669438,
          d = 0.9996,
          f = q5(u),
          g = q5(c);
        (l = Math.floor((c + 180) / 6) + 1), 180 === c && (l = 60);
        u >= 56 && u < 64 && c >= 3 && c < 12 && (l = 32);
        u >= 72 &&
          u < 84 &&
          (c >= 0 && c < 9
            ? (l = 31)
            : c >= 9 && c < 21
            ? (l = 33)
            : c >= 21 && c < 33
            ? (l = 35)
            : c >= 33 && c < 42 && (l = 37));
        (s = q5(6 * (l - 1) - 180 + 3)),
          (e = p / (1 - p)),
          (i = h / Math.sqrt(1 - p * Math.sin(f) * Math.sin(f))),
          (n = Math.tan(f) * Math.tan(f)),
          (r = e * Math.cos(f) * Math.cos(f)),
          (o = Math.cos(f) * (g - s)),
          (a =
            h *
            ((1 - p / 4 - (3 * p * p) / 64 - (5 * p * p * p) / 256) * f -
              ((3 * p) / 8 + (3 * p * p) / 32 + (45 * p * p * p) / 1024) *
                Math.sin(2 * f) +
              ((15 * p * p) / 256 + (45 * p * p * p) / 1024) * Math.sin(4 * f) -
              ((35 * p * p * p) / 3072) * Math.sin(6 * f)));
        var m =
            d *
              i *
              (o +
                ((1 - n + r) * o * o * o) / 6 +
                ((5 - 18 * n + n * n + 72 * r - 58 * e) * o * o * o * o * o) /
                  120) +
            5e5,
          y =
            d *
            (a +
              i *
                Math.tan(f) *
                ((o * o) / 2 +
                  ((5 - n + 9 * r + 4 * r * r) * o * o * o * o) / 24 +
                  ((61 - 58 * n + n * n + 600 * r - 330 * e) *
                    o *
                    o *
                    o *
                    o *
                    o *
                    o) /
                    720));
        u < 0 && (y += 1e7);
        return {
          northing: Math.round(y),
          easting: Math.round(m),
          zoneNumber: l,
          zoneLetter: Q5(u),
        };
      })({
        lat: t[1],
        lon: t[0],
      }),
      e
    )
  );
}
function W5(t) {
  var e = X5(J5(t.toUpperCase()));
  return e.lat && e.lon
    ? [e.lon, e.lat]
    : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function q5(t) {
  return t * (Math.PI / 180);
}
function Y5(t) {
  return (t / Math.PI) * 180;
}
function X5(t) {
  var e = t.northing,
    i = t.easting,
    n = t.zoneLetter,
    r = t.zoneNumber;
  if (r < 0 || r > 60) return null;
  var o,
    a,
    s,
    l,
    u,
    c,
    h,
    p,
    d,
    f = 0.9996,
    g = 6378137,
    m = 0.00669438,
    y = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)),
    v = i - 5e5,
    b = e;
  n < "N" && (b -= 1e7),
    (h = 6 * (r - 1) - 180 + 3),
    (o = 0.006739496752268451),
    (d =
      (p = b / f / 6367449.145945056) +
      ((3 * y) / 2 - (27 * y * y * y) / 32) * Math.sin(2 * p) +
      ((21 * y * y) / 16 - (55 * y * y * y * y) / 32) * Math.sin(4 * p) +
      ((151 * y * y * y) / 96) * Math.sin(6 * p)),
    (a = g / Math.sqrt(1 - m * Math.sin(d) * Math.sin(d))),
    (s = Math.tan(d) * Math.tan(d)),
    (l = o * Math.cos(d) * Math.cos(d)),
    (u = (0.99330562 * g) / Math.pow(1 - m * Math.sin(d) * Math.sin(d), 1.5)),
    (c = v / (a * f));
  var x =
    d -
    ((a * Math.tan(d)) / u) *
      ((c * c) / 2 -
        ((5 + 3 * s + 10 * l - 4 * l * l - 9 * o) * c * c * c * c) / 24 +
        ((61 + 90 * s + 298 * l + 45 * s * s - 1.6983531815716497 - 3 * l * l) *
          c *
          c *
          c *
          c *
          c *
          c) /
          720);
  x = Y5(x);
  var _,
    S =
      (c -
        ((1 + 2 * s + l) * c * c * c) / 6 +
        ((5 - 2 * l + 28 * s - 3 * l * l + 8 * o + 24 * s * s) *
          c *
          c *
          c *
          c *
          c) /
          120) /
      Math.cos(d);
  if (((S = h + Y5(S)), t.accuracy)) {
    var M = X5({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber,
    });
    _ = {
      top: M.lat,
      right: M.lon,
      bottom: x,
      left: S,
    };
  } else
    _ = {
      lat: x,
      lon: S,
    };
  return _;
}
function Q5(t) {
  var e = "Z";
  return (
    84 >= t && t >= 72
      ? (e = "X")
      : 72 > t && t >= 64
      ? (e = "W")
      : 64 > t && t >= 56
      ? (e = "V")
      : 56 > t && t >= 48
      ? (e = "U")
      : 48 > t && t >= 40
      ? (e = "T")
      : 40 > t && t >= 32
      ? (e = "S")
      : 32 > t && t >= 24
      ? (e = "R")
      : 24 > t && t >= 16
      ? (e = "Q")
      : 16 > t && t >= 8
      ? (e = "P")
      : 8 > t && t >= 0
      ? (e = "N")
      : 0 > t && t >= -8
      ? (e = "M")
      : -8 > t && t >= -16
      ? (e = "L")
      : -16 > t && t >= -24
      ? (e = "K")
      : -24 > t && t >= -32
      ? (e = "J")
      : -32 > t && t >= -40
      ? (e = "H")
      : -40 > t && t >= -48
      ? (e = "G")
      : -48 > t && t >= -56
      ? (e = "F")
      : -56 > t && t >= -64
      ? (e = "E")
      : -64 > t && t >= -72
      ? (e = "D")
      : -72 > t && t >= -80 && (e = "C"),
    e
  );
}
function Z5(t) {
  var e = t % O5;
  return 0 === e && (e = O5), e;
}
function J5(t) {
  if (t && 0 === t.length) throw "MGRSPoint coverting from nothing";
  for (
    var e, i = t.length, n = null, r = "", o = 0;
    !/[A-Z]/.test((e = t.charAt(o)));

  ) {
    if (o >= 2) throw "MGRSPoint bad conversion from: " + t;
    (r += e), o++;
  }
  var a = parseInt(r, 10);
  if (0 === o || o + 3 > i) throw "MGRSPoint bad conversion from: " + t;
  var s = t.charAt(o++);
  if (s <= "A" || "B" === s || "Y" === s || s >= "Z" || "I" === s || "O" === s)
    throw "MGRSPoint zone letter " + s + " not handled: " + t;
  n = t.substring(o, (o += 2));
  for (
    var l = Z5(a),
      u = (function (t, e) {
        var i = F5.charCodeAt(e - 1),
          n = 1e5,
          r = !1;
        for (; i !== t.charCodeAt(0); ) {
          if ((++i === B5 && i++, i === G5 && i++, i > j5)) {
            if (r) throw "Bad character: " + t;
            (i = k5), (r = !0);
          }
          n += 1e5;
        }
        return n;
      })(n.charAt(0), l),
      c = (function (t, e) {
        if (t > "V") throw "MGRSPoint given invalid Northing " + t;
        var i = z5.charCodeAt(e - 1),
          n = 0,
          r = !1;
        for (; i !== t.charCodeAt(0); ) {
          if ((++i === B5 && i++, i === G5 && i++, i > U5)) {
            if (r) throw "Bad character: " + t;
            (i = k5), (r = !0);
          }
          n += 1e5;
        }
        return n;
      })(n.charAt(1), l);
    c < K5(s);

  )
    c += 2e6;
  var h = i - o;
  if (h % 2 != 0)
    throw (
      "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" +
      t
    );
  var p,
    d,
    f,
    g = h / 2,
    m = 0,
    y = 0;
  return (
    g > 0 &&
      ((p = 1e5 / Math.pow(10, g)),
      (d = t.substring(o, o + g)),
      (m = parseFloat(d) * p),
      (f = t.substring(o + g)),
      (y = parseFloat(f) * p)),
    {
      easting: m + u,
      northing: y + c,
      zoneLetter: s,
      zoneNumber: a,
      accuracy: p,
    }
  );
}
function K5(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0) return e;
  throw "Invalid zone letter: " + t;
}
function $5(t, e, i) {
  if (!(this instanceof $5)) return new $5(t, e, i);
  if (Array.isArray(t)) (this.x = t[0]), (this.y = t[1]), (this.z = t[2] || 0);
  else if ("object" == typeof t)
    (this.x = t.x), (this.y = t.y), (this.z = t.z || 0);
  else if ("string" == typeof t && void 0 === e) {
    var n = t.split(",");
    (this.x = parseFloat(n[0], 10)),
      (this.y = parseFloat(n[1], 10)),
      (this.z = parseFloat(n[2], 10) || 0);
  } else (this.x = t), (this.y = e), (this.z = i || 0);
}
($5.fromMGRS = function (t) {
  return new $5(W5(t));
}),
  ($5.prototype.toMGRS = function (t) {
    return V5([this.x, this.y], t);
  });
var t4 = 1,
  e4 = 0.25,
  i4 = 0.046875,
  n4 = 0.01953125,
  r4 = 0.01068115234375,
  o4 = 0.75,
  a4 = 0.46875,
  s4 = 0.013020833333333334,
  l4 = 0.007120768229166667,
  u4 = 0.3645833333333333,
  c4 = 0.005696614583333333,
  h4 = 0.3076171875;
function p4(t) {
  var e = [];
  (e[0] = t4 - t * (e4 + t * (i4 + t * (n4 + t * r4)))),
    (e[1] = t * (o4 - t * (i4 + t * (n4 + t * r4))));
  var i = t * t;
  return (
    (e[2] = i * (a4 - t * (s4 + t * l4))),
    (i *= t),
    (e[3] = i * (u4 - t * c4)),
    (e[4] = i * t * h4),
    e
  );
}
function d4(t, e, i, n) {
  return (
    (i *= e),
    (e *= e),
    n[0] * t - i * (n[1] + e * (n[2] + e * (n[3] + e * n[4])))
  );
}
var f4 = 20;
function g4(t, e, i) {
  for (var n = 1 / (1 - e), r = t, o = f4; o; --o) {
    var a = Math.sin(r),
      s = 1 - e * a * a;
    if (
      ((r -= s = (d4(r, a, Math.cos(r), i) - t) * (s * Math.sqrt(s)) * n),
      Math.abs(s) < M3)
    )
      return r;
  }
  return r;
}
const m4 = {
  init: function () {
    (this.x0 = void 0 !== this.x0 ? this.x0 : 0),
      (this.y0 = void 0 !== this.y0 ? this.y0 : 0),
      (this.long0 = void 0 !== this.long0 ? this.long0 : 0),
      (this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0),
      this.es &&
        ((this.en = p4(this.es)),
        (this.ml0 = d4(
          this.lat0,
          Math.sin(this.lat0),
          Math.cos(this.lat0),
          this.en
        )));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r = t.x,
      o = t.y,
      a = t5(r - this.long0),
      s = Math.sin(o),
      l = Math.cos(o);
    if (this.es) {
      var u = l * a,
        c = Math.pow(u, 2),
        h = this.ep2 * Math.pow(l, 2),
        p = Math.pow(h, 2),
        d = Math.abs(l) > M3 ? Math.tan(o) : 0,
        f = Math.pow(d, 2),
        g = Math.pow(f, 2);
      (e = 1 - this.es * Math.pow(s, 2)), (u /= Math.sqrt(e));
      var m = d4(o, s, l, this.en);
      (i =
        this.a *
          (this.k0 *
            u *
            (1 +
              (c / 6) *
                (1 -
                  f +
                  h +
                  (c / 20) *
                    (5 -
                      18 * f +
                      g +
                      14 * h -
                      58 * f * h +
                      (c / 42) * (61 + 179 * g - g * f - 479 * f))))) +
        this.x0),
        (n =
          this.a *
            (this.k0 *
              (m -
                this.ml0 +
                ((s * a * u) / 2) *
                  (1 +
                    (c / 12) *
                      (5 -
                        f +
                        9 * h +
                        4 * p +
                        (c / 30) *
                          (61 +
                            g -
                            58 * f +
                            270 * h -
                            330 * f * h +
                            (c / 56) *
                              (1385 + 543 * g - g * f - 3111 * f)))))) +
          this.y0);
    } else {
      var y = l * Math.sin(a);
      if (Math.abs(Math.abs(y) - 1) < M3) return 93;
      if (
        ((i = 0.5 * this.a * this.k0 * Math.log((1 + y) / (1 - y)) + this.x0),
        (n = (l * Math.cos(a)) / Math.sqrt(1 - Math.pow(y, 2))),
        (y = Math.abs(n)) >= 1)
      ) {
        if (y - 1 > M3) return 93;
        n = 0;
      } else n = Math.acos(n);
      o < 0 && (n = -n), (n = this.a * this.k0 * (n - this.lat0) + this.y0);
    }
    return (t.x = i), (t.y = n), t;
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o = (t.x - this.x0) * (1 / this.a),
      a = (t.y - this.y0) * (1 / this.a);
    if (this.es)
      if (
        ((i = g4((e = this.ml0 + a / this.k0), this.es, this.en)),
        Math.abs(i) < b3)
      ) {
        var s = Math.sin(i),
          l = Math.cos(i),
          u = Math.abs(l) > M3 ? Math.tan(i) : 0,
          c = this.ep2 * Math.pow(l, 2),
          h = Math.pow(c, 2),
          p = Math.pow(u, 2),
          d = Math.pow(p, 2);
        e = 1 - this.es * Math.pow(s, 2);
        var f = (o * Math.sqrt(e)) / this.k0,
          g = Math.pow(f, 2);
        (n =
          i -
          (((e *= u) * g) / (1 - this.es)) *
            0.5 *
            (1 -
              (g / 12) *
                (5 +
                  3 * p -
                  9 * c * p +
                  c -
                  4 * h -
                  (g / 30) *
                    (61 +
                      90 * p -
                      252 * c * p +
                      45 * d +
                      46 * c -
                      (g / 56) *
                        (1385 + 3633 * p + 4095 * d + 1574 * d * p))))),
          (r = t5(
            this.long0 +
              (f *
                (1 -
                  (g / 6) *
                    (1 +
                      2 * p +
                      c -
                      (g / 20) *
                        (5 +
                          28 * p +
                          24 * d +
                          8 * c * p +
                          6 * c -
                          (g / 42) *
                            (61 + 662 * p + 1320 * d + 720 * d * p))))) /
                l
          ));
      } else (n = b3 * $3(a)), (r = 0);
    else {
      var m = Math.exp(o / this.k0),
        y = 0.5 * (m - 1 / m),
        v = this.lat0 + a / this.k0,
        b = Math.cos(v);
      (e = Math.sqrt((1 - Math.pow(b, 2)) / (1 + Math.pow(y, 2)))),
        (n = Math.asin(e)),
        a < 0 && (n = -n),
        (r = 0 === y && 0 === b ? 0 : t5(Math.atan2(y, b) + this.long0));
    }
    return (t.x = r), (t.y = n), t;
  },
  names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"],
};
function y4(t) {
  var e = Math.exp(t);
  return (e = (e - 1 / e) / 2);
}
function v4(t, e) {
  (t = Math.abs(t)), (e = Math.abs(e));
  var i = Math.max(t, e),
    n = Math.min(t, e) / (i || 1);
  return i * Math.sqrt(1 + Math.pow(n, 2));
}
function b4(t) {
  var e = Math.abs(t);
  return (
    (e = (function (t) {
      var e = 1 + t,
        i = e - 1;
      return 0 === i ? t : (t * Math.log(e)) / i;
    })(e * (1 + e / (v4(1, e) + 1)))),
    t < 0 ? -e : e
  );
}
function x4(t, e) {
  for (
    var i, n = 2 * Math.cos(2 * e), r = t.length - 1, o = t[r], a = 0;
    --r >= 0;

  )
    (i = n * o - a + t[r]), (a = o), (o = i);
  return e + i * Math.sin(2 * e);
}
function _4(t, e, i) {
  for (
    var n,
      r,
      o = Math.sin(e),
      a = Math.cos(e),
      s = y4(i),
      l = (function (t) {
        var e = Math.exp(t);
        return (e + 1 / e) / 2;
      })(i),
      u = 2 * a * l,
      c = -2 * o * s,
      h = t.length - 1,
      p = t[h],
      d = 0,
      f = 0,
      g = 0;
    --h >= 0;

  )
    (n = f),
      (r = d),
      (p = u * (f = p) - n - c * (d = g) + t[h]),
      (g = c * f - r + u * d);
  return [(u = o * l) * p - (c = a * s) * g, u * g + c * p];
}
const S4 = {
  init: function () {
    if (!this.approx && (isNaN(this.es) || this.es <= 0))
      throw new Error(
        'Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.'
      );
    this.approx &&
      (m4.init.apply(this),
      (this.forward = m4.forward),
      (this.inverse = m4.inverse)),
      (this.x0 = void 0 !== this.x0 ? this.x0 : 0),
      (this.y0 = void 0 !== this.y0 ? this.y0 : 0),
      (this.long0 = void 0 !== this.long0 ? this.long0 : 0),
      (this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0),
      (this.cgb = []),
      (this.cbg = []),
      (this.utg = []),
      (this.gtu = []);
    var t = this.es / (1 + Math.sqrt(1 - this.es)),
      e = t / (2 - t),
      i = e;
    (this.cgb[0] =
      e *
      (2 +
        e *
          (-2 / 3 +
            e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2)))),
      (this.cbg[0] =
        e *
        (e *
          (2 / 3 +
            e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) -
          2)),
      (i *= e),
      (this.cgb[1] =
        i *
        (7 / 3 +
          e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6))),
      (this.cbg[1] =
        i *
        (5 / 3 +
          e *
            (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945)))))),
      (i *= e),
      (this.cgb[2] =
        i *
        (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835))))),
      (this.cbg[2] =
        i * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835))))),
      (i *= e),
      (this.cgb[3] =
        i * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175)))),
      (this.cbg[3] = i * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4))),
      (i *= e),
      (this.cgb[4] = i * (4174 / 315 + e * (-144838 / 6237))),
      (this.cbg[4] = i * (-734 / 315 + e * (109598 / 31185))),
      (i *= e),
      (this.cgb[5] = i * (601676 / 22275)),
      (this.cbg[5] = i * (444337 / 155925)),
      (i = Math.pow(e, 2)),
      (this.Qn =
        (this.k0 / (1 + e)) * (1 + i * (1 / 4 + i * (1 / 64 + i / 256)))),
      (this.utg[0] =
        e *
        (e *
          (2 / 3 +
            e *
              (-37 / 96 +
                e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) -
          0.5)),
      (this.gtu[0] =
        e *
        (0.5 +
          e *
            (-2 / 3 +
              e *
                (5 / 16 +
                  e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800))))))),
      (this.utg[1] =
        i *
        (-1 / 48 +
          e *
            (-1 / 15 +
              e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720)))))),
      (this.gtu[1] =
        i *
        (13 / 48 +
          e *
            (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) -
              0.6))),
      (i *= e),
      (this.utg[2] =
        i *
        (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720))))),
      (this.gtu[2] =
        i *
        (61 / 240 +
          e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440))))),
      (i *= e),
      (this.utg[3] =
        i * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600)))),
      (this.gtu[3] =
        i * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600)))),
      (i *= e),
      (this.utg[4] = i * (-4583 / 161280 + e * (108847 / 3991680))),
      (this.gtu[4] = i * (34729 / 80640 + e * (-3418889 / 1995840))),
      (i *= e),
      (this.utg[5] = i * (-20648693 / 638668800)),
      (this.gtu[5] = 0.6650675310896665 * i);
    var n = x4(this.cbg, this.lat0);
    this.Zb =
      -this.Qn *
      (n +
        (function (t, e) {
          for (
            var i, n = 2 * Math.cos(e), r = t.length - 1, o = t[r], a = 0;
            --r >= 0;

          )
            (i = n * o - a + t[r]), (a = o), (o = i);
          return Math.sin(e) * i;
        })(this.gtu, 2 * n));
  },
  forward: function (t) {
    var e = t5(t.x - this.long0),
      i = t.y;
    i = x4(this.cbg, i);
    var n = Math.sin(i),
      r = Math.cos(i),
      o = Math.sin(e),
      a = Math.cos(e);
    (i = Math.atan2(n, a * r)),
      (e = Math.atan2(o * r, v4(n, r * a))),
      (e = b4(Math.tan(e)));
    var s,
      l,
      u = _4(this.gtu, 2 * i, 2 * e);
    return (
      (i += u[0]),
      (e += u[1]),
      Math.abs(e) <= 2.623395162778
        ? ((s = this.a * (this.Qn * e) + this.x0),
          (l = this.a * (this.Qn * i + this.Zb) + this.y0))
        : ((s = 1 / 0), (l = 1 / 0)),
      (t.x = s),
      (t.y = l),
      t
    );
  },
  inverse: function (t) {
    var e,
      i,
      n = (t.x - this.x0) * (1 / this.a),
      r = (t.y - this.y0) * (1 / this.a);
    if (
      ((r = (r - this.Zb) / this.Qn),
      (n /= this.Qn),
      Math.abs(n) <= 2.623395162778)
    ) {
      var o = _4(this.utg, 2 * r, 2 * n);
      (r += o[0]), (n += o[1]), (n = Math.atan(y4(n)));
      var a = Math.sin(r),
        s = Math.cos(r),
        l = Math.sin(n),
        u = Math.cos(n);
      (r = Math.atan2(a * u, v4(l, u * s))),
        (e = t5((n = Math.atan2(l, u * s)) + this.long0)),
        (i = x4(this.cgb, r));
    } else (e = 1 / 0), (i = 1 / 0);
    return (t.x = e), (t.y = i), t;
  },
  names: [
    "Extended_Transverse_Mercator",
    "Extended Transverse Mercator",
    "etmerc",
    "Transverse_Mercator",
    "Transverse Mercator",
    "Gauss Kruger",
    "Gauss_Kruger",
    "tmerc",
  ],
};
const M4 = {
  init: function () {
    var t = (function (t, e) {
      if (void 0 === t) {
        if ((t = Math.floor((30 * (t5(e) + Math.PI)) / Math.PI) + 1) < 0)
          return 0;
        if (t > 60) return 60;
      }
      return t;
    })(this.zone, this.long0);
    if (void 0 === t) throw new Error("unknown utm zone");
    (this.lat0 = 0),
      (this.long0 = (6 * Math.abs(t) - 183) * C3),
      (this.x0 = 5e5),
      (this.y0 = this.utmSouth ? 1e7 : 0),
      (this.k0 = 0.9996),
      S4.init.apply(this),
      (this.forward = S4.forward),
      (this.inverse = S4.inverse);
  },
  names: ["Universal Transverse Mercator System", "utm"],
  dependsOn: "etmerc",
};
function C4(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
const w4 = {
  init: function () {
    var t = Math.sin(this.lat0),
      e = Math.cos(this.lat0);
    (e *= e),
      (this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t)),
      (this.C = Math.sqrt(1 + (this.es * e * e) / (1 - this.es))),
      (this.phic0 = Math.asin(t / this.C)),
      (this.ratexp = 0.5 * this.C * this.e),
      (this.K =
        Math.tan(0.5 * this.phic0 + A3) /
        (Math.pow(Math.tan(0.5 * this.lat0 + A3), this.C) *
          C4(this.e * t, this.ratexp)));
  },
  forward: function (t) {
    var e = t.x,
      i = t.y;
    return (
      (t.y =
        2 *
          Math.atan(
            this.K *
              Math.pow(Math.tan(0.5 * i + A3), this.C) *
              C4(this.e * Math.sin(i), this.ratexp)
          ) -
        b3),
      (t.x = this.C * e),
      t
    );
  },
  inverse: function (t) {
    for (
      var e = t.x / this.C,
        i = t.y,
        n = Math.pow(Math.tan(0.5 * i + A3) / this.K, 1 / this.C),
        r = 20;
      r > 0 &&
      ((i = 2 * Math.atan(n * C4(this.e * Math.sin(t.y), -0.5 * this.e)) - b3),
      !(Math.abs(i - t.y) < 1e-14));
      --r
    )
      t.y = i;
    return r ? ((t.x = e), (t.y = i), t) : null;
  },
  names: ["gauss"],
};
const A4 = {
  init: function () {
    w4.init.apply(this),
      this.rc &&
        ((this.sinc0 = Math.sin(this.phic0)),
        (this.cosc0 = Math.cos(this.phic0)),
        (this.R2 = 2 * this.rc),
        this.title || (this.title = "Oblique Stereographic Alternative"));
  },
  forward: function (t) {
    var e, i, n, r;
    return (
      (t.x = t5(t.x - this.long0)),
      w4.forward.apply(this, [t]),
      (e = Math.sin(t.y)),
      (i = Math.cos(t.y)),
      (n = Math.cos(t.x)),
      (r = (this.k0 * this.R2) / (1 + this.sinc0 * e + this.cosc0 * i * n)),
      (t.x = r * i * Math.sin(t.x)),
      (t.y = r * (this.cosc0 * e - this.sinc0 * i * n)),
      (t.x = this.a * t.x + this.x0),
      (t.y = this.a * t.y + this.y0),
      t
    );
  },
  inverse: function (t) {
    var e, i, n, r, o;
    if (
      ((t.x = (t.x - this.x0) / this.a),
      (t.y = (t.y - this.y0) / this.a),
      (t.x /= this.k0),
      (t.y /= this.k0),
      (o = v4(t.x, t.y)))
    ) {
      var a = 2 * Math.atan2(o, this.R2);
      (e = Math.sin(a)),
        (i = Math.cos(a)),
        (r = Math.asin(i * this.sinc0 + (t.y * e * this.cosc0) / o)),
        (n = Math.atan2(t.x * e, o * this.cosc0 * i - t.y * this.sinc0 * e));
    } else (r = this.phic0), (n = 0);
    return (
      (t.x = n),
      (t.y = r),
      w4.inverse.apply(this, [t]),
      (t.x = t5(t.x + this.long0)),
      t
    );
  },
  names: [
    "Stereographic_North_Pole",
    "Oblique_Stereographic",
    "sterea",
    "Oblique Stereographic Alternative",
    "Double_Stereographic",
  ],
};
const E4 = {
  init: function () {
    (this.x0 = this.x0 || 0),
      (this.y0 = this.y0 || 0),
      (this.lat0 = this.lat0 || 0),
      (this.long0 = this.long0 || 0),
      (this.coslat0 = Math.cos(this.lat0)),
      (this.sinlat0 = Math.sin(this.lat0)),
      this.sphere
        ? 1 === this.k0 &&
          !isNaN(this.lat_ts) &&
          Math.abs(this.coslat0) <= M3 &&
          (this.k0 = 0.5 * (1 + $3(this.lat0) * Math.sin(this.lat_ts)))
        : (Math.abs(this.coslat0) <= M3 &&
            (this.lat0 > 0 ? (this.con = 1) : (this.con = -1)),
          (this.cons = Math.sqrt(
            Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)
          )),
          1 === this.k0 &&
            !isNaN(this.lat_ts) &&
            Math.abs(this.coslat0) <= M3 &&
            Math.abs(Math.cos(this.lat_ts)) > M3 &&
            (this.k0 =
              (0.5 *
                this.cons *
                K3(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts))) /
              e5(
                this.e,
                this.con * this.lat_ts,
                this.con * Math.sin(this.lat_ts)
              )),
          (this.ms1 = K3(this.e, this.sinlat0, this.coslat0)),
          (this.X0 =
            2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - b3),
          (this.cosX0 = Math.cos(this.X0)),
          (this.sinX0 = Math.sin(this.X0)));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s = t.x,
      l = t.y,
      u = Math.sin(l),
      c = Math.cos(l),
      h = t5(s - this.long0);
    return Math.abs(Math.abs(s - this.long0) - Math.PI) <= M3 &&
      Math.abs(l + this.lat0) <= M3
      ? ((t.x = NaN), (t.y = NaN), t)
      : this.sphere
      ? ((e =
          (2 * this.k0) /
          (1 + this.sinlat0 * u + this.coslat0 * c * Math.cos(h))),
        (t.x = this.a * e * c * Math.sin(h) + this.x0),
        (t.y =
          this.a * e * (this.coslat0 * u - this.sinlat0 * c * Math.cos(h)) +
          this.y0),
        t)
      : ((i = 2 * Math.atan(this.ssfn_(l, u, this.e)) - b3),
        (r = Math.cos(i)),
        (n = Math.sin(i)),
        Math.abs(this.coslat0) <= M3
          ? ((o = e5(this.e, l * this.con, this.con * u)),
            (a = (2 * this.a * this.k0 * o) / this.cons),
            (t.x = this.x0 + a * Math.sin(s - this.long0)),
            (t.y = this.y0 - this.con * a * Math.cos(s - this.long0)),
            t)
          : (Math.abs(this.sinlat0) < M3
              ? ((e = (2 * this.a * this.k0) / (1 + r * Math.cos(h))),
                (t.y = e * n))
              : ((e =
                  (2 * this.a * this.k0 * this.ms1) /
                  (this.cosX0 *
                    (1 + this.sinX0 * n + this.cosX0 * r * Math.cos(h)))),
                (t.y =
                  e * (this.cosX0 * n - this.sinX0 * r * Math.cos(h)) +
                  this.y0)),
            (t.x = e * r * Math.sin(h) + this.x0),
            t));
  },
  inverse: function (t) {
    var e, i, n, r, o;
    (t.x -= this.x0), (t.y -= this.y0);
    var a = Math.sqrt(t.x * t.x + t.y * t.y);
    if (this.sphere) {
      var s = 2 * Math.atan(a / (2 * this.a * this.k0));
      return (
        (e = this.long0),
        (i = this.lat0),
        a <= M3
          ? ((t.x = e), (t.y = i), t)
          : ((i = Math.asin(
              Math.cos(s) * this.sinlat0 +
                (t.y * Math.sin(s) * this.coslat0) / a
            )),
            (e =
              Math.abs(this.coslat0) < M3
                ? this.lat0 > 0
                  ? t5(this.long0 + Math.atan2(t.x, -1 * t.y))
                  : t5(this.long0 + Math.atan2(t.x, t.y))
                : t5(
                    this.long0 +
                      Math.atan2(
                        t.x * Math.sin(s),
                        a * this.coslat0 * Math.cos(s) -
                          t.y * this.sinlat0 * Math.sin(s)
                      )
                  )),
            (t.x = e),
            (t.y = i),
            t)
      );
    }
    if (Math.abs(this.coslat0) <= M3) {
      if (a <= M3)
        return (i = this.lat0), (e = this.long0), (t.x = e), (t.y = i), t;
      (t.x *= this.con),
        (t.y *= this.con),
        (n = (a * this.cons) / (2 * this.a * this.k0)),
        (i = this.con * i5(this.e, n)),
        (e = this.con * t5(this.con * this.long0 + Math.atan2(t.x, -1 * t.y)));
    } else
      (r = 2 * Math.atan((a * this.cosX0) / (2 * this.a * this.k0 * this.ms1))),
        (e = this.long0),
        a <= M3
          ? (o = this.X0)
          : ((o = Math.asin(
              Math.cos(r) * this.sinX0 + (t.y * Math.sin(r) * this.cosX0) / a
            )),
            (e = t5(
              this.long0 +
                Math.atan2(
                  t.x * Math.sin(r),
                  a * this.cosX0 * Math.cos(r) - t.y * this.sinX0 * Math.sin(r)
                )
            ))),
        (i = -1 * i5(this.e, Math.tan(0.5 * (b3 + o))));
    return (t.x = e), (t.y = i), t;
  },
  names: [
    "stere",
    "Stereographic_South_Pole",
    "Polar Stereographic (variant B)",
    "Polar_Stereographic",
  ],
  ssfn_: function (t, e, i) {
    return (
      (e *= i), Math.tan(0.5 * (b3 + t)) * Math.pow((1 - e) / (1 + e), 0.5 * i)
    );
  },
};
const D4 = {
  init: function () {
    var t = this.lat0;
    this.lambda0 = this.long0;
    var e = Math.sin(t),
      i = this.a,
      n = 1 / this.rf,
      r = 2 * n - Math.pow(n, 2),
      o = (this.e = Math.sqrt(r));
    (this.R = (this.k0 * i * Math.sqrt(1 - r)) / (1 - r * Math.pow(e, 2))),
      (this.alpha = Math.sqrt(1 + (r / (1 - r)) * Math.pow(Math.cos(t), 4))),
      (this.b0 = Math.asin(e / this.alpha));
    var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
      s = Math.log(Math.tan(Math.PI / 4 + t / 2)),
      l = Math.log((1 + o * e) / (1 - o * e));
    this.K = a - this.alpha * s + ((this.alpha * o) / 2) * l;
  },
  forward: function (t) {
    var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
      i =
        (this.e / 2) *
        Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))),
      n = -this.alpha * (e + i) + this.K,
      r = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4),
      o = this.alpha * (t.x - this.lambda0),
      a = Math.atan(
        Math.sin(o) /
          (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(o))
      ),
      s = Math.asin(
        Math.cos(this.b0) * Math.sin(r) -
          Math.sin(this.b0) * Math.cos(r) * Math.cos(o)
      );
    return (
      (t.y =
        (this.R / 2) * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) +
        this.y0),
      (t.x = this.R * a + this.x0),
      t
    );
  },
  inverse: function (t) {
    for (
      var e = t.x - this.x0,
        i = t.y - this.y0,
        n = e / this.R,
        r = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4),
        o = Math.asin(
          Math.cos(this.b0) * Math.sin(r) +
            Math.sin(this.b0) * Math.cos(r) * Math.cos(n)
        ),
        a = Math.atan(
          Math.sin(n) /
            (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(r))
        ),
        s = this.lambda0 + a / this.alpha,
        l = 0,
        u = o,
        c = -1e3,
        h = 0;
      Math.abs(u - c) > 1e-7;

    ) {
      if (++h > 20) return;
      (l =
        (1 / this.alpha) * (Math.log(Math.tan(Math.PI / 4 + o / 2)) - this.K) +
        this.e *
          Math.log(
            Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(u)) / 2)
          )),
        (c = u),
        (u = 2 * Math.atan(Math.exp(l)) - Math.PI / 2);
    }
    return (t.x = s), (t.y = u), t;
  },
  names: ["somerc"],
};
var T4 = 1e-7;
const P4 = {
  init: function () {
    var t,
      e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h,
      p,
      d = 0,
      f = 0,
      g = 0,
      m = 0,
      y = 0,
      v = 0,
      b = 0;
    (this.no_off =
      ((p =
        "object" == typeof (h = this).PROJECTION
          ? Object.keys(h.PROJECTION)[0]
          : h.PROJECTION),
      "no_uoff" in h ||
        "no_off" in h ||
        -1 !==
          [
            "Hotine_Oblique_Mercator",
            "Hotine_Oblique_Mercator_Azimuth_Natural_Origin",
          ].indexOf(p))),
      (this.no_rot = "no_rot" in this);
    var x = !1;
    "alpha" in this && (x = !0);
    var _ = !1;
    if (
      ("rectified_grid_angle" in this && (_ = !0),
      x && (b = this.alpha),
      _ && (d = this.rectified_grid_angle * C3),
      x || _)
    )
      f = this.longc;
    else if (
      ((g = this.long1),
      (y = this.lat1),
      (m = this.long2),
      (v = this.lat2),
      Math.abs(y - v) <= T4 ||
        (t = Math.abs(y)) <= T4 ||
        Math.abs(t - b3) <= T4 ||
        Math.abs(Math.abs(this.lat0) - b3) <= T4 ||
        Math.abs(Math.abs(v) - b3) <= T4)
    )
      throw new Error();
    var S = 1 - this.es;
    (e = Math.sqrt(S)),
      Math.abs(this.lat0) > M3
        ? ((s = Math.sin(this.lat0)),
          (i = Math.cos(this.lat0)),
          (t = 1 - this.es * s * s),
          (this.B = i * i),
          (this.B = Math.sqrt(1 + (this.es * this.B * this.B) / S)),
          (this.A = (this.B * this.k0 * e) / t),
          (r = (n = (this.B * e) / (i * Math.sqrt(t))) * n - 1) <= 0
            ? (r = 0)
            : ((r = Math.sqrt(r)), this.lat0 < 0 && (r = -r)),
          (this.E = r += n),
          (this.E *= Math.pow(e5(this.e, this.lat0, s), this.B)))
        : ((this.B = 1 / e), (this.A = this.k0), (this.E = n = r = 1)),
      x || _
        ? (x
            ? ((c = Math.asin(Math.sin(b) / n)), _ || (d = b))
            : ((c = d), (b = Math.asin(n * Math.sin(c)))),
          (this.lam0 = f - Math.asin(0.5 * (r - 1 / r) * Math.tan(c)) / this.B))
        : ((o = Math.pow(e5(this.e, y, Math.sin(y)), this.B)),
          (a = Math.pow(e5(this.e, v, Math.sin(v)), this.B)),
          (r = this.E / o),
          (l = (a - o) / (a + o)),
          (u = ((u = this.E * this.E) - a * o) / (u + a * o)),
          (t = g - m) < -Math.pi ? (m -= E3) : t > Math.pi && (m += E3),
          (this.lam0 = t5(
            0.5 * (g + m) -
              Math.atan((u * Math.tan(0.5 * this.B * (g - m))) / l) / this.B
          )),
          (c = Math.atan(
            (2 * Math.sin(this.B * t5(g - this.lam0))) / (r - 1 / r)
          )),
          (d = b = Math.asin(n * Math.sin(c)))),
      (this.singam = Math.sin(c)),
      (this.cosgam = Math.cos(c)),
      (this.sinrot = Math.sin(d)),
      (this.cosrot = Math.cos(d)),
      (this.rB = 1 / this.B),
      (this.ArB = this.A * this.rB),
      (this.BrA = 1 / this.ArB),
      this.A,
      this.B,
      this.no_off
        ? (this.u_0 = 0)
        : ((this.u_0 = Math.abs(
            this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(b))
          )),
          this.lat0 < 0 && (this.u_0 = -this.u_0)),
      (r = 0.5 * c),
      (this.v_pole_n = this.ArB * Math.log(Math.tan(A3 - r))),
      (this.v_pole_s = this.ArB * Math.log(Math.tan(A3 + r)));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u = {};
    if (((t.x = t.x - this.lam0), Math.abs(Math.abs(t.y) - b3) > M3)) {
      if (
        ((e =
          0.5 *
          ((o = this.E / Math.pow(e5(this.e, t.y, Math.sin(t.y)), this.B)) -
            (a = 1 / o))),
        (i = 0.5 * (o + a)),
        (r = Math.sin(this.B * t.x)),
        (n = (e * this.singam - r * this.cosgam) / i),
        Math.abs(Math.abs(n) - 1) < M3)
      )
        throw new Error();
      (l = 0.5 * this.ArB * Math.log((1 - n) / (1 + n))),
        (a = Math.cos(this.B * t.x)),
        (s =
          Math.abs(a) < T4
            ? this.A * t.x
            : this.ArB * Math.atan2(e * this.cosgam + r * this.singam, a));
    } else (l = t.y > 0 ? this.v_pole_n : this.v_pole_s), (s = this.ArB * t.y);
    return (
      this.no_rot
        ? ((u.x = s), (u.y = l))
        : ((s -= this.u_0),
          (u.x = l * this.cosrot + s * this.sinrot),
          (u.y = s * this.cosrot - l * this.sinrot)),
      (u.x = this.a * u.x + this.x0),
      (u.y = this.a * u.y + this.y0),
      u
    );
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l = {};
    if (
      ((t.x = (t.x - this.x0) * (1 / this.a)),
      (t.y = (t.y - this.y0) * (1 / this.a)),
      this.no_rot
        ? ((i = t.y), (e = t.x))
        : ((i = t.x * this.cosrot - t.y * this.sinrot),
          (e = t.y * this.cosrot + t.x * this.sinrot + this.u_0)),
      (r = 0.5 * ((n = Math.exp(-this.BrA * i)) - 1 / n)),
      (o = 0.5 * (n + 1 / n)),
      (s = ((a = Math.sin(this.BrA * e)) * this.cosgam + r * this.singam) / o),
      Math.abs(Math.abs(s) - 1) < M3)
    )
      (l.x = 0), (l.y = s < 0 ? -b3 : b3);
    else {
      if (
        ((l.y = this.E / Math.sqrt((1 + s) / (1 - s))),
        (l.y = i5(this.e, Math.pow(l.y, 1 / this.B))),
        l.y === 1 / 0)
      )
        throw new Error();
      l.x =
        -this.rB *
        Math.atan2(r * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
    }
    return (l.x += this.lam0), l;
  },
  names: [
    "Hotine_Oblique_Mercator",
    "Hotine Oblique Mercator",
    "Hotine_Oblique_Mercator_Azimuth_Natural_Origin",
    "Hotine_Oblique_Mercator_Two_Point_Natural_Origin",
    "Hotine_Oblique_Mercator_Azimuth_Center",
    "Oblique_Mercator",
    "omerc",
  ],
};
const L4 = {
  init: function () {
    if (
      (this.lat2 || (this.lat2 = this.lat1),
      this.k0 || (this.k0 = 1),
      (this.x0 = this.x0 || 0),
      (this.y0 = this.y0 || 0),
      !(Math.abs(this.lat1 + this.lat2) < M3))
    ) {
      var t = this.b / this.a;
      this.e = Math.sqrt(1 - t * t);
      var e = Math.sin(this.lat1),
        i = Math.cos(this.lat1),
        n = K3(this.e, e, i),
        r = e5(this.e, this.lat1, e),
        o = Math.sin(this.lat2),
        a = Math.cos(this.lat2),
        s = K3(this.e, o, a),
        l = e5(this.e, this.lat2, o),
        u = e5(this.e, this.lat0, Math.sin(this.lat0));
      Math.abs(this.lat1 - this.lat2) > M3
        ? (this.ns = Math.log(n / s) / Math.log(r / l))
        : (this.ns = e),
        isNaN(this.ns) && (this.ns = e),
        (this.f0 = n / (this.ns * Math.pow(r, this.ns))),
        (this.rh = this.a * this.f0 * Math.pow(u, this.ns)),
        this.title || (this.title = "Lambert Conformal Conic");
    }
  },
  forward: function (t) {
    var e = t.x,
      i = t.y;
    Math.abs(2 * Math.abs(i) - Math.PI) <= M3 && (i = $3(i) * (b3 - 2 * M3));
    var n,
      r,
      o = Math.abs(Math.abs(i) - b3);
    if (o > M3)
      (n = e5(this.e, i, Math.sin(i))),
        (r = this.a * this.f0 * Math.pow(n, this.ns));
    else {
      if ((o = i * this.ns) <= 0) return null;
      r = 0;
    }
    var a = this.ns * t5(e - this.long0);
    return (
      (t.x = this.k0 * (r * Math.sin(a)) + this.x0),
      (t.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0),
      t
    );
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a = (t.x - this.x0) / this.k0,
      s = this.rh - (t.y - this.y0) / this.k0;
    this.ns > 0
      ? ((e = Math.sqrt(a * a + s * s)), (i = 1))
      : ((e = -Math.sqrt(a * a + s * s)), (i = -1));
    var l = 0;
    if ((0 !== e && (l = Math.atan2(i * a, i * s)), 0 !== e || this.ns > 0)) {
      if (
        ((i = 1 / this.ns),
        (n = Math.pow(e / (this.a * this.f0), i)),
        -9999 === (r = i5(this.e, n)))
      )
        return null;
    } else r = -b3;
    return (o = t5(l / this.ns + this.long0)), (t.x = o), (t.y = r), t;
  },
  names: [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)",
  ],
};
const I4 = {
  init: function () {
    (this.a = 6377397.155),
      (this.es = 0.006674372230614),
      (this.e = Math.sqrt(this.es)),
      this.lat0 || (this.lat0 = 0.863937979737193),
      this.long0 || (this.long0 = 0.4334234309119251),
      this.k0 || (this.k0 = 0.9999),
      (this.s45 = 0.785398163397448),
      (this.s90 = 2 * this.s45),
      (this.fi0 = this.lat0),
      (this.e2 = this.es),
      (this.e = Math.sqrt(this.e2)),
      (this.alfa = Math.sqrt(
        1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2)
      )),
      (this.uq = 1.04216856380474),
      (this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa)),
      (this.g = Math.pow(
        (1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)),
        (this.alfa * this.e) / 2
      )),
      (this.k =
        (Math.tan(this.u0 / 2 + this.s45) /
          Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa)) *
        this.g),
      (this.k1 = this.k0),
      (this.n0 =
        (this.a * Math.sqrt(1 - this.e2)) /
        (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2))),
      (this.s0 = 1.37008346281555),
      (this.n = Math.sin(this.s0)),
      (this.ro0 = (this.k1 * this.n0) / Math.tan(this.s0)),
      (this.ad = this.s90 - this.uq);
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l = t.x,
      u = t.y,
      c = t5(l - this.long0);
    return (
      (e = Math.pow(
        (1 + this.e * Math.sin(u)) / (1 - this.e * Math.sin(u)),
        (this.alfa * this.e) / 2
      )),
      (i =
        2 *
        (Math.atan(
          (this.k * Math.pow(Math.tan(u / 2 + this.s45), this.alfa)) / e
        ) -
          this.s45)),
      (n = -c * this.alfa),
      (r = Math.asin(
        Math.cos(this.ad) * Math.sin(i) +
          Math.sin(this.ad) * Math.cos(i) * Math.cos(n)
      )),
      (o = Math.asin((Math.cos(i) * Math.sin(n)) / Math.cos(r))),
      (a = this.n * o),
      (s =
        (this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n)) /
        Math.pow(Math.tan(r / 2 + this.s45), this.n)),
      (t.y = (s * Math.cos(a)) / 1),
      (t.x = (s * Math.sin(a)) / 1),
      this.czech || ((t.y *= -1), (t.x *= -1)),
      t
    );
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l = t.x;
    (t.x = t.y),
      (t.y = l),
      this.czech || ((t.y *= -1), (t.x *= -1)),
      (o = Math.sqrt(t.x * t.x + t.y * t.y)),
      (r = Math.atan2(t.y, t.x) / Math.sin(this.s0)),
      (n =
        2 *
        (Math.atan(
          Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)
        ) -
          this.s45)),
      (e = Math.asin(
        Math.cos(this.ad) * Math.sin(n) -
          Math.sin(this.ad) * Math.cos(n) * Math.cos(r)
      )),
      (i = Math.asin((Math.cos(n) * Math.sin(r)) / Math.cos(e))),
      (t.x = this.long0 - i / this.alfa),
      (a = e),
      (s = 0);
    var u = 0;
    do {
      (t.y =
        2 *
        (Math.atan(
          Math.pow(this.k, -1 / this.alfa) *
            Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) *
            Math.pow(
              (1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)),
              this.e / 2
            )
        ) -
          this.s45)),
        Math.abs(a - t.y) < 1e-10 && (s = 1),
        (a = t.y),
        (u += 1);
    } while (0 === s && u < 15);
    return u >= 15 ? null : t;
  },
  names: ["Krovak", "krovak"],
};
function N4(t, e, i, n, r) {
  return (
    t * r - e * Math.sin(2 * r) + i * Math.sin(4 * r) - n * Math.sin(6 * r)
  );
}
function R4(t) {
  return 1 - 0.25 * t * (1 + (t / 16) * (3 + 1.25 * t));
}
function O4(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function F4(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function z4(t) {
  return t * t * t * (35 / 3072);
}
function k4(t, e, i) {
  var n = e * i;
  return t / Math.sqrt(1 - n * n);
}
function B4(t) {
  return Math.abs(t) < b3 ? t : t - $3(t) * Math.PI;
}
function G4(t, e, i, n, r) {
  var o, a;
  o = t / e;
  for (var s = 0; s < 15; s++)
    if (
      ((o += a =
        (t -
          (e * o -
            i * Math.sin(2 * o) +
            n * Math.sin(4 * o) -
            r * Math.sin(6 * o))) /
        (e -
          2 * i * Math.cos(2 * o) +
          4 * n * Math.cos(4 * o) -
          6 * r * Math.cos(6 * o))),
      Math.abs(a) <= 1e-10)
    )
      return o;
  return NaN;
}
const U4 = {
  init: function () {
    this.sphere ||
      ((this.e0 = R4(this.es)),
      (this.e1 = O4(this.es)),
      (this.e2 = F4(this.es)),
      (this.e3 = z4(this.es)),
      (this.ml0 = this.a * N4(this.e0, this.e1, this.e2, this.e3, this.lat0)));
  },
  forward: function (t) {
    var e,
      i,
      n = t.x,
      r = t.y;
    if (((n = t5(n - this.long0)), this.sphere))
      (e = this.a * Math.asin(Math.cos(r) * Math.sin(n))),
        (i = this.a * (Math.atan2(Math.tan(r), Math.cos(n)) - this.lat0));
    else {
      var o = Math.sin(r),
        a = Math.cos(r),
        s = k4(this.a, this.e, o),
        l = Math.tan(r) * Math.tan(r),
        u = n * Math.cos(r),
        c = u * u,
        h = (this.es * a * a) / (1 - this.es);
      (e = s * u * (1 - c * l * (1 / 6 - ((8 - l + 8 * h) * c) / 120))),
        (i =
          this.a * N4(this.e0, this.e1, this.e2, this.e3, r) -
          this.ml0 +
          ((s * o) / a) * c * (0.5 + ((5 - l + 6 * h) * c) / 24));
    }
    return (t.x = e + this.x0), (t.y = i + this.y0), t;
  },
  inverse: function (t) {
    (t.x -= this.x0), (t.y -= this.y0);
    var e,
      i,
      n = t.x / this.a,
      r = t.y / this.a;
    if (this.sphere) {
      var o = r + this.lat0;
      (e = Math.asin(Math.sin(o) * Math.cos(n))),
        (i = Math.atan2(Math.tan(n), Math.cos(o)));
    } else {
      var a = G4(this.ml0 / this.a + r, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(a) - b3) <= M3)
        return (t.x = this.long0), (t.y = b3), r < 0 && (t.y *= -1), t;
      var s = k4(this.a, this.e, Math.sin(a)),
        l = ((s * s * s) / this.a / this.a) * (1 - this.es),
        u = Math.pow(Math.tan(a), 2),
        c = (n * this.a) / s,
        h = c * c;
      (e =
        a -
        ((s * Math.tan(a)) / l) * c * c * (0.5 - ((1 + 3 * u) * c * c) / 24)),
        (i =
          (c * (1 - h * (u / 3 + ((1 + 3 * u) * u * h) / 15))) / Math.cos(a));
    }
    return (t.x = t5(i + this.long0)), (t.y = B4(e)), t;
  },
  names: ["Cassini", "Cassini_Soldner", "cass"],
};
function j4(t, e) {
  var i;
  return t > 1e-7
    ? (1 - t * t) *
        (e / (1 - (i = t * e) * i) - (0.5 / t) * Math.log((1 - i) / (1 + i)))
    : 2 * e;
}
var H4 = 0.3333333333333333,
  V4 = 0.17222222222222222,
  W4 = 0.10257936507936508,
  q4 = 0.06388888888888888,
  Y4 = 0.0664021164021164,
  X4 = 0.016415012942191543;
const Q4 = {
  init: function () {
    var t,
      e = Math.abs(this.lat0);
    if (
      (Math.abs(e - b3) < M3
        ? (this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE)
        : Math.abs(e) < M3
        ? (this.mode = this.EQUIT)
        : (this.mode = this.OBLIQ),
      this.es > 0)
    )
      switch (
        ((this.qp = j4(this.e, 1)),
        (this.mmf = 0.5 / (1 - this.es)),
        (this.apa = (function (t) {
          var e,
            i = [];
          return (
            (i[0] = t * H4),
            (e = t * t),
            (i[0] += e * V4),
            (i[1] = e * q4),
            (e *= t),
            (i[0] += e * W4),
            (i[1] += e * Y4),
            (i[2] = e * X4),
            i
          );
        })(this.es)),
        this.mode)
      ) {
        case this.N_POLE:
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          (this.rq = Math.sqrt(0.5 * this.qp)),
            (this.dd = 1 / this.rq),
            (this.xmf = 1),
            (this.ymf = 0.5 * this.qp);
          break;
        case this.OBLIQ:
          (this.rq = Math.sqrt(0.5 * this.qp)),
            (t = Math.sin(this.lat0)),
            (this.sinb1 = j4(this.e, t) / this.qp),
            (this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1)),
            (this.dd =
              Math.cos(this.lat0) /
              (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1)),
            (this.ymf = (this.xmf = this.rq) / this.dd),
            (this.xmf *= this.dd);
      }
    else
      this.mode === this.OBLIQ &&
        ((this.sinph0 = Math.sin(this.lat0)),
        (this.cosph0 = Math.cos(this.lat0)));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h = t.x,
      p = t.y;
    if (((h = t5(h - this.long0)), this.sphere)) {
      if (
        ((o = Math.sin(p)),
        (c = Math.cos(p)),
        (n = Math.cos(h)),
        this.mode === this.OBLIQ || this.mode === this.EQUIT)
      ) {
        if (
          (i =
            this.mode === this.EQUIT
              ? 1 + c * n
              : 1 + this.sinph0 * o + this.cosph0 * c * n) <= M3
        )
          return null;
        (e = (i = Math.sqrt(2 / i)) * c * Math.sin(h)),
          (i *=
            this.mode === this.EQUIT
              ? o
              : this.cosph0 * o - this.sinph0 * c * n);
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (
          (this.mode === this.N_POLE && (n = -n), Math.abs(p + this.lat0) < M3)
        )
          return null;
        (i = A3 - 0.5 * p),
          (e =
            (i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i))) *
            Math.sin(h)),
          (i *= n);
      }
    } else {
      switch (
        ((s = 0),
        (l = 0),
        (u = 0),
        (n = Math.cos(h)),
        (r = Math.sin(h)),
        (o = Math.sin(p)),
        (a = j4(this.e, o)),
        (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
          ((s = a / this.qp), (l = Math.sqrt(1 - s * s))),
        this.mode)
      ) {
        case this.OBLIQ:
          u = 1 + this.sinb1 * s + this.cosb1 * l * n;
          break;
        case this.EQUIT:
          u = 1 + l * n;
          break;
        case this.N_POLE:
          (u = b3 + p), (a = this.qp - a);
          break;
        case this.S_POLE:
          (u = p - b3), (a = this.qp + a);
      }
      if (Math.abs(u) < M3) return null;
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          (u = Math.sqrt(2 / u)),
            (i =
              this.mode === this.OBLIQ
                ? this.ymf * u * (this.cosb1 * s - this.sinb1 * l * n)
                : (u = Math.sqrt(2 / (1 + l * n))) * s * this.ymf),
            (e = this.xmf * u * l * r);
          break;
        case this.N_POLE:
        case this.S_POLE:
          a >= 0
            ? ((e = (u = Math.sqrt(a)) * r),
              (i = n * (this.mode === this.S_POLE ? u : -u)))
            : (e = i = 0);
      }
    }
    return (t.x = this.a * e + this.x0), (t.y = this.a * i + this.y0), t;
  },
  inverse: function (t) {
    (t.x -= this.x0), (t.y -= this.y0);
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h = t.x / this.a,
      p = t.y / this.a;
    if (this.sphere) {
      var d,
        f = 0,
        g = 0;
      if ((i = 0.5 * (d = Math.sqrt(h * h + p * p))) > 1) return null;
      switch (
        ((i = 2 * Math.asin(i)),
        (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
          ((g = Math.sin(i)), (f = Math.cos(i))),
        this.mode)
      ) {
        case this.EQUIT:
          (i = Math.abs(d) <= M3 ? 0 : Math.asin((p * g) / d)),
            (h *= g),
            (p = f * d);
          break;
        case this.OBLIQ:
          (i =
            Math.abs(d) <= M3
              ? this.lat0
              : Math.asin(f * this.sinph0 + (p * g * this.cosph0) / d)),
            (h *= g * this.cosph0),
            (p = (f - Math.sin(i) * this.sinph0) * d);
          break;
        case this.N_POLE:
          (p = -p), (i = b3 - i);
          break;
        case this.S_POLE:
          i -= b3;
      }
      e =
        0 !== p || (this.mode !== this.EQUIT && this.mode !== this.OBLIQ)
          ? Math.atan2(h, p)
          : 0;
    } else {
      if (((s = 0), this.mode === this.OBLIQ || this.mode === this.EQUIT)) {
        if (
          ((h /= this.dd), (p *= this.dd), (a = Math.sqrt(h * h + p * p)) < M3)
        )
          return (t.x = this.long0), (t.y = this.lat0), t;
        (r = 2 * Math.asin((0.5 * a) / this.rq)),
          (n = Math.cos(r)),
          (h *= r = Math.sin(r)),
          this.mode === this.OBLIQ
            ? ((s = n * this.sinb1 + (p * r * this.cosb1) / a),
              (o = this.qp * s),
              (p = a * this.cosb1 * n - p * this.sinb1 * r))
            : ((s = (p * r) / a), (o = this.qp * s), (p = a * n));
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if ((this.mode === this.N_POLE && (p = -p), !(o = h * h + p * p)))
          return (t.x = this.long0), (t.y = this.lat0), t;
        (s = 1 - o / this.qp), this.mode === this.S_POLE && (s = -s);
      }
      (e = Math.atan2(h, p)),
        (l = Math.asin(s)),
        (u = this.apa),
        (c = l + l),
        (i =
          l +
          u[0] * Math.sin(c) +
          u[1] * Math.sin(c + c) +
          u[2] * Math.sin(c + c + c));
    }
    return (t.x = t5(this.long0 + e)), (t.y = i), t;
  },
  names: [
    "Lambert Azimuthal Equal Area",
    "Lambert_Azimuthal_Equal_Area",
    "laea",
  ],
  S_POLE: 1,
  N_POLE: 2,
  EQUIT: 3,
  OBLIQ: 4,
};
function Z4(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
const J4 = {
  init: function () {
    Math.abs(this.lat1 + this.lat2) < M3 ||
      ((this.temp = this.b / this.a),
      (this.es = 1 - Math.pow(this.temp, 2)),
      (this.e3 = Math.sqrt(this.es)),
      (this.sin_po = Math.sin(this.lat1)),
      (this.cos_po = Math.cos(this.lat1)),
      (this.t1 = this.sin_po),
      (this.con = this.sin_po),
      (this.ms1 = K3(this.e3, this.sin_po, this.cos_po)),
      (this.qs1 = j4(this.e3, this.sin_po)),
      (this.sin_po = Math.sin(this.lat2)),
      (this.cos_po = Math.cos(this.lat2)),
      (this.t2 = this.sin_po),
      (this.ms2 = K3(this.e3, this.sin_po, this.cos_po)),
      (this.qs2 = j4(this.e3, this.sin_po)),
      (this.sin_po = Math.sin(this.lat0)),
      (this.cos_po = Math.cos(this.lat0)),
      (this.t3 = this.sin_po),
      (this.qs0 = j4(this.e3, this.sin_po)),
      Math.abs(this.lat1 - this.lat2) > M3
        ? (this.ns0 =
            (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1))
        : (this.ns0 = this.con),
      (this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1),
      (this.rh =
        (this.a * Math.sqrt(this.c - this.ns0 * this.qs0)) / this.ns0));
  },
  forward: function (t) {
    var e = t.x,
      i = t.y;
    (this.sin_phi = Math.sin(i)), (this.cos_phi = Math.cos(i));
    var n = j4(this.e3, this.sin_phi),
      r = (this.a * Math.sqrt(this.c - this.ns0 * n)) / this.ns0,
      o = this.ns0 * t5(e - this.long0),
      a = r * Math.sin(o) + this.x0,
      s = this.rh - r * Math.cos(o) + this.y0;
    return (t.x = a), (t.y = s), t;
  },
  inverse: function (t) {
    var e, i, n, r, o, a;
    return (
      (t.x -= this.x0),
      (t.y = this.rh - t.y + this.y0),
      this.ns0 >= 0
        ? ((e = Math.sqrt(t.x * t.x + t.y * t.y)), (n = 1))
        : ((e = -Math.sqrt(t.x * t.x + t.y * t.y)), (n = -1)),
      (r = 0),
      0 !== e && (r = Math.atan2(n * t.x, n * t.y)),
      (n = (e * this.ns0) / this.a),
      this.sphere
        ? (a = Math.asin((this.c - n * n) / (2 * this.ns0)))
        : ((i = (this.c - n * n) / this.ns0), (a = this.phi1z(this.e3, i))),
      (o = t5(r / this.ns0 + this.long0)),
      (t.x = o),
      (t.y = a),
      t
    );
  },
  names: ["Albers_Conic_Equal_Area", "Albers", "aea"],
  phi1z: function (t, e) {
    var i,
      n,
      r,
      o,
      a = Z4(0.5 * e);
    if (t < M3) return a;
    for (var s = t * t, l = 1; l <= 25; l++)
      if (
        ((a += o =
          ((0.5 * (r = 1 - (n = t * (i = Math.sin(a))) * n) * r) /
            Math.cos(a)) *
          (e / (1 - s) - i / r + (0.5 / t) * Math.log((1 - n) / (1 + n)))),
        Math.abs(o) <= 1e-7)
      )
        return a;
    return null;
  },
};
const K4 = {
  init: function () {
    (this.sin_p14 = Math.sin(this.lat0)),
      (this.cos_p14 = Math.cos(this.lat0)),
      (this.infinity_dist = 1e3 * this.a),
      (this.rc = 1);
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l = t.x,
      u = t.y;
    return (
      (n = t5(l - this.long0)),
      (e = Math.sin(u)),
      (i = Math.cos(u)),
      (r = Math.cos(n)),
      1,
      (o = this.sin_p14 * e + this.cos_p14 * i * r) > 0 || Math.abs(o) <= M3
        ? ((a = this.x0 + (1 * this.a * i * Math.sin(n)) / o),
          (s =
            this.y0 +
            (1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * r)) / o))
        : ((a = this.x0 + this.infinity_dist * i * Math.sin(n)),
          (s =
            this.y0 +
            this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * i * r))),
      (t.x = a),
      (t.y = s),
      t
    );
  },
  inverse: function (t) {
    var e, i, n, r, o, a;
    return (
      (t.x = (t.x - this.x0) / this.a),
      (t.y = (t.y - this.y0) / this.a),
      (t.x /= this.k0),
      (t.y /= this.k0),
      (e = Math.sqrt(t.x * t.x + t.y * t.y))
        ? ((r = Math.atan2(e, this.rc)),
          (i = Math.sin(r)),
          (a = Z4(
            (n = Math.cos(r)) * this.sin_p14 + (t.y * i * this.cos_p14) / e
          )),
          (o = Math.atan2(
            t.x * i,
            e * this.cos_p14 * n - t.y * this.sin_p14 * i
          )),
          (o = t5(this.long0 + o)))
        : ((a = this.phic0), (o = 0)),
      (t.x = o),
      (t.y = a),
      t
    );
  },
  names: ["gnom"],
};
const $4 = {
  init: function () {
    this.sphere ||
      (this.k0 = K3(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
  },
  forward: function (t) {
    var e,
      i,
      n = t.x,
      r = t.y,
      o = t5(n - this.long0);
    if (this.sphere)
      (e = this.x0 + this.a * o * Math.cos(this.lat_ts)),
        (i = this.y0 + (this.a * Math.sin(r)) / Math.cos(this.lat_ts));
    else {
      var a = j4(this.e, Math.sin(r));
      (e = this.x0 + this.a * this.k0 * o),
        (i = this.y0 + (this.a * a * 0.5) / this.k0);
    }
    return (t.x = e), (t.y = i), t;
  },
  inverse: function (t) {
    var e, i;
    return (
      (t.x -= this.x0),
      (t.y -= this.y0),
      this.sphere
        ? ((e = t5(this.long0 + t.x / this.a / Math.cos(this.lat_ts))),
          (i = Math.asin((t.y / this.a) * Math.cos(this.lat_ts))))
        : ((i = (function (t, e) {
            var i = 1 - ((1 - t * t) / (2 * t)) * Math.log((1 - t) / (1 + t));
            if (Math.abs(Math.abs(e) - i) < 1e-6) return e < 0 ? -1 * b3 : b3;
            for (var n, r, o, a, s = Math.asin(0.5 * e), l = 0; l < 30; l++)
              if (
                ((r = Math.sin(s)),
                (o = Math.cos(s)),
                (a = t * r),
                (s += n =
                  (Math.pow(1 - a * a, 2) / (2 * o)) *
                  (e / (1 - t * t) -
                    r / (1 - a * a) +
                    (0.5 / t) * Math.log((1 - a) / (1 + a)))),
                Math.abs(n) <= 1e-10)
              )
                return s;
            return NaN;
          })(this.e, (2 * t.y * this.k0) / this.a)),
          (e = t5(this.long0 + t.x / (this.a * this.k0)))),
      (t.x = e),
      (t.y = i),
      t
    );
  },
  names: ["cea"],
};
const t6 = {
  init: function () {
    (this.x0 = this.x0 || 0),
      (this.y0 = this.y0 || 0),
      (this.lat0 = this.lat0 || 0),
      (this.long0 = this.long0 || 0),
      (this.lat_ts = this.lat_ts || 0),
      (this.title = this.title || "Equidistant Cylindrical (Plate Carre)"),
      (this.rc = Math.cos(this.lat_ts));
  },
  forward: function (t) {
    var e = t.x,
      i = t.y,
      n = t5(e - this.long0),
      r = B4(i - this.lat0);
    return (
      (t.x = this.x0 + this.a * n * this.rc), (t.y = this.y0 + this.a * r), t
    );
  },
  inverse: function (t) {
    var e = t.x,
      i = t.y;
    return (
      (t.x = t5(this.long0 + (e - this.x0) / (this.a * this.rc))),
      (t.y = B4(this.lat0 + (i - this.y0) / this.a)),
      t
    );
  },
  names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"],
};
const e6 = {
  init: function () {
    (this.temp = this.b / this.a),
      (this.es = 1 - Math.pow(this.temp, 2)),
      (this.e = Math.sqrt(this.es)),
      (this.e0 = R4(this.es)),
      (this.e1 = O4(this.es)),
      (this.e2 = F4(this.es)),
      (this.e3 = z4(this.es)),
      (this.ml0 = this.a * N4(this.e0, this.e1, this.e2, this.e3, this.lat0));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r = t.x,
      o = t.y,
      a = t5(r - this.long0);
    if (((n = a * Math.sin(o)), this.sphere))
      Math.abs(o) <= M3
        ? ((e = this.a * a), (i = -1 * this.a * this.lat0))
        : ((e = (this.a * Math.sin(n)) / Math.tan(o)),
          (i = this.a * (B4(o - this.lat0) + (1 - Math.cos(n)) / Math.tan(o))));
    else if (Math.abs(o) <= M3) (e = this.a * a), (i = -1 * this.ml0);
    else {
      var s = k4(this.a, this.e, Math.sin(o)) / Math.tan(o);
      (e = s * Math.sin(n)),
        (i =
          this.a * N4(this.e0, this.e1, this.e2, this.e3, o) -
          this.ml0 +
          s * (1 - Math.cos(n)));
    }
    return (t.x = e + this.x0), (t.y = i + this.y0), t;
  },
  inverse: function (t) {
    var e, i, n, r, o, a, s, l, u;
    if (((n = t.x - this.x0), (r = t.y - this.y0), this.sphere))
      if (Math.abs(r + this.a * this.lat0) <= M3)
        (e = t5(n / this.a + this.long0)), (i = 0);
      else {
        var c;
        for (
          a = this.lat0 + r / this.a,
            s = (n * n) / this.a / this.a + a * a,
            l = a,
            o = 20;
          o;
          --o
        )
          if (
            ((l += u =
              (-1 *
                (a * (l * (c = Math.tan(l)) + 1) - l - 0.5 * (l * l + s) * c)) /
              ((l - a) / c - 1)),
            Math.abs(u) <= M3)
          ) {
            i = l;
            break;
          }
        e = t5(
          this.long0 + Math.asin((n * Math.tan(l)) / this.a) / Math.sin(i)
        );
      }
    else if (Math.abs(r + this.ml0) <= M3)
      (i = 0), (e = t5(this.long0 + n / this.a));
    else {
      var h, p, d, f, g;
      for (
        a = (this.ml0 + r) / this.a,
          s = (n * n) / this.a / this.a + a * a,
          l = a,
          o = 20;
        o;
        --o
      )
        if (
          ((g = this.e * Math.sin(l)),
          (h = Math.sqrt(1 - g * g) * Math.tan(l)),
          (p = this.a * N4(this.e0, this.e1, this.e2, this.e3, l)),
          (d =
            this.e0 -
            2 * this.e1 * Math.cos(2 * l) +
            4 * this.e2 * Math.cos(4 * l) -
            6 * this.e3 * Math.cos(6 * l)),
          (l -= u =
            (a * (h * (f = p / this.a) + 1) - f - 0.5 * h * (f * f + s)) /
            ((this.es * Math.sin(2 * l) * (f * f + s - 2 * a * f)) / (4 * h) +
              (a - f) * (h * d - 2 / Math.sin(2 * l)) -
              d)),
          Math.abs(u) <= M3)
        ) {
          i = l;
          break;
        }
      (h = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i)),
        (e = t5(this.long0 + Math.asin((n * h) / this.a) / Math.sin(i)));
    }
    return (t.x = e), (t.y = i), t;
  },
  names: ["Polyconic", "poly"],
};
const i6 = {
  init: function () {
    (this.A = []),
      (this.A[1] = 0.6399175073),
      (this.A[2] = -0.1358797613),
      (this.A[3] = 0.063294409),
      (this.A[4] = -0.02526853),
      (this.A[5] = 0.0117879),
      (this.A[6] = -0.0055161),
      (this.A[7] = 0.0026906),
      (this.A[8] = -0.001333),
      (this.A[9] = 67e-5),
      (this.A[10] = -34e-5),
      (this.B_re = []),
      (this.B_im = []),
      (this.B_re[1] = 0.7557853228),
      (this.B_im[1] = 0),
      (this.B_re[2] = 0.249204646),
      (this.B_im[2] = 0.003371507),
      (this.B_re[3] = -0.001541739),
      (this.B_im[3] = 0.04105856),
      (this.B_re[4] = -0.10162907),
      (this.B_im[4] = 0.01727609),
      (this.B_re[5] = -0.26623489),
      (this.B_im[5] = -0.36249218),
      (this.B_re[6] = -0.6870983),
      (this.B_im[6] = -1.1651967),
      (this.C_re = []),
      (this.C_im = []),
      (this.C_re[1] = 1.3231270439),
      (this.C_im[1] = 0),
      (this.C_re[2] = -0.577245789),
      (this.C_im[2] = -0.007809598),
      (this.C_re[3] = 0.508307513),
      (this.C_im[3] = -0.112208952),
      (this.C_re[4] = -0.15094762),
      (this.C_im[4] = 0.18200602),
      (this.C_re[5] = 1.01418179),
      (this.C_im[5] = 1.64497696),
      (this.C_re[6] = 1.9660549),
      (this.C_im[6] = 2.5127645),
      (this.D = []),
      (this.D[1] = 1.5627014243),
      (this.D[2] = 0.5185406398),
      (this.D[3] = -0.03333098),
      (this.D[4] = -0.1052906),
      (this.D[5] = -0.0368594),
      (this.D[6] = 0.007317),
      (this.D[7] = 0.0122),
      (this.D[8] = 0.00394),
      (this.D[9] = -0.0013);
  },
  forward: function (t) {
    var e,
      i = t.x,
      n = t.y - this.lat0,
      r = i - this.long0,
      o = (n / v3) * 1e-5,
      a = r,
      s = 1,
      l = 0;
    for (e = 1; e <= 10; e++) (s *= o), (l += this.A[e] * s);
    var u,
      c = l,
      h = a,
      p = 1,
      d = 0,
      f = 0,
      g = 0;
    for (e = 1; e <= 6; e++)
      (u = d * c + p * h),
        (p = p * c - d * h),
        (d = u),
        (f = f + this.B_re[e] * p - this.B_im[e] * d),
        (g = g + this.B_im[e] * p + this.B_re[e] * d);
    return (t.x = g * this.a + this.x0), (t.y = f * this.a + this.y0), t;
  },
  inverse: function (t) {
    var e,
      i,
      n = t.x,
      r = t.y,
      o = n - this.x0,
      a = (r - this.y0) / this.a,
      s = o / this.a,
      l = 1,
      u = 0,
      c = 0,
      h = 0;
    for (e = 1; e <= 6; e++)
      (i = u * a + l * s),
        (l = l * a - u * s),
        (u = i),
        (c = c + this.C_re[e] * l - this.C_im[e] * u),
        (h = h + this.C_im[e] * l + this.C_re[e] * u);
    for (var p = 0; p < this.iterations; p++) {
      var d,
        f = c,
        g = h,
        m = a,
        y = s;
      for (e = 2; e <= 6; e++)
        (d = g * c + f * h),
          (f = f * c - g * h),
          (g = d),
          (m += (e - 1) * (this.B_re[e] * f - this.B_im[e] * g)),
          (y += (e - 1) * (this.B_im[e] * f + this.B_re[e] * g));
      (f = 1), (g = 0);
      var v = this.B_re[1],
        b = this.B_im[1];
      for (e = 2; e <= 6; e++)
        (d = g * c + f * h),
          (f = f * c - g * h),
          (g = d),
          (v += e * (this.B_re[e] * f - this.B_im[e] * g)),
          (b += e * (this.B_im[e] * f + this.B_re[e] * g));
      var x = v * v + b * b;
      (c = (m * v + y * b) / x), (h = (y * v - m * b) / x);
    }
    var _ = c,
      S = h,
      M = 1,
      C = 0;
    for (e = 1; e <= 9; e++) (M *= _), (C += this.D[e] * M);
    var w = this.lat0 + C * v3 * 1e5,
      A = this.long0 + S;
    return (t.x = A), (t.y = w), t;
  },
  names: ["New_Zealand_Map_Grid", "nzmg"],
};
const n6 = {
  init: function () {},
  forward: function (t) {
    var e = t.x,
      i = t.y,
      n = t5(e - this.long0),
      r = this.x0 + this.a * n,
      o = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25;
    return (t.x = r), (t.y = o), t;
  },
  inverse: function (t) {
    (t.x -= this.x0), (t.y -= this.y0);
    var e = t5(this.long0 + t.x / this.a),
      i = 2.5 * (Math.atan(Math.exp((0.8 * t.y) / this.a)) - Math.PI / 4);
    return (t.x = e), (t.y = i), t;
  },
  names: ["Miller_Cylindrical", "mill"],
};
const r6 = {
  init: function () {
    this.sphere
      ? ((this.n = 1),
        (this.m = 0),
        (this.es = 0),
        (this.C_y = Math.sqrt((this.m + 1) / this.n)),
        (this.C_x = this.C_y / (this.m + 1)))
      : (this.en = p4(this.es));
  },
  forward: function (t) {
    var e,
      i,
      n = t.x,
      r = t.y;
    if (((n = t5(n - this.long0)), this.sphere)) {
      if (this.m)
        for (var o = this.n * Math.sin(r), a = 20; a; --a) {
          var s = (this.m * r + Math.sin(r) - o) / (this.m + Math.cos(r));
          if (((r -= s), Math.abs(s) < M3)) break;
        }
      else r = 1 !== this.n ? Math.asin(this.n * Math.sin(r)) : r;
      (e = this.a * this.C_x * n * (this.m + Math.cos(r))),
        (i = this.a * this.C_y * r);
    } else {
      var l = Math.sin(r),
        u = Math.cos(r);
      (i = this.a * d4(r, l, u, this.en)),
        (e = (this.a * n * u) / Math.sqrt(1 - this.es * l * l));
    }
    return (t.x = e), (t.y = i), t;
  },
  inverse: function (t) {
    var e, i, n;
    return (
      (t.x -= this.x0),
      (i = t.x / this.a),
      (t.y -= this.y0),
      (e = t.y / this.a),
      this.sphere
        ? ((e /= this.C_y),
          (i /= this.C_x * (this.m + Math.cos(e))),
          this.m
            ? (e = Z4((this.m * e + Math.sin(e)) / this.n))
            : 1 !== this.n && (e = Z4(Math.sin(e) / this.n)),
          (i = t5(i + this.long0)),
          (e = B4(e)))
        : ((e = g4(t.y / this.a, this.es, this.en)),
          (n = Math.abs(e)) < b3
            ? ((n = Math.sin(e)),
              (i = t5(
                this.long0 +
                  (t.x * Math.sqrt(1 - this.es * n * n)) /
                    (this.a * Math.cos(e))
              )))
            : n - M3 < b3 && (i = this.long0)),
      (t.x = i),
      (t.y = e),
      t
    );
  },
  names: ["Sinusoidal", "sinu"],
};
const o6 = {
  init: function () {},
  forward: function (t) {
    for (
      var e = t.x,
        i = t.y,
        n = t5(e - this.long0),
        r = i,
        o = Math.PI * Math.sin(i);
      ;

    ) {
      var a = -(r + Math.sin(r) - o) / (1 + Math.cos(r));
      if (((r += a), Math.abs(a) < M3)) break;
    }
    (r /= 2), Math.PI / 2 - Math.abs(i) < M3 && (n = 0);
    var s = 0.900316316158 * this.a * n * Math.cos(r) + this.x0,
      l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
    return (t.x = s), (t.y = l), t;
  },
  inverse: function (t) {
    var e, i;
    (t.x -= this.x0),
      (t.y -= this.y0),
      (i = t.y / (1.4142135623731 * this.a)),
      Math.abs(i) > 0.999999999999 && (i = 0.999999999999),
      (e = Math.asin(i));
    var n = t5(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
    n < -Math.PI && (n = -Math.PI),
      n > Math.PI && (n = Math.PI),
      (i = (2 * e + Math.sin(2 * e)) / Math.PI),
      Math.abs(i) > 1 && (i = 1);
    var r = Math.asin(i);
    return (t.x = n), (t.y = r), t;
  },
  names: ["Mollweide", "moll"],
};
const a6 = {
  init: function () {
    Math.abs(this.lat1 + this.lat2) < M3 ||
      ((this.lat2 = this.lat2 || this.lat1),
      (this.temp = this.b / this.a),
      (this.es = 1 - Math.pow(this.temp, 2)),
      (this.e = Math.sqrt(this.es)),
      (this.e0 = R4(this.es)),
      (this.e1 = O4(this.es)),
      (this.e2 = F4(this.es)),
      (this.e3 = z4(this.es)),
      (this.sinphi = Math.sin(this.lat1)),
      (this.cosphi = Math.cos(this.lat1)),
      (this.ms1 = K3(this.e, this.sinphi, this.cosphi)),
      (this.ml1 = N4(this.e0, this.e1, this.e2, this.e3, this.lat1)),
      Math.abs(this.lat1 - this.lat2) < M3
        ? (this.ns = this.sinphi)
        : ((this.sinphi = Math.sin(this.lat2)),
          (this.cosphi = Math.cos(this.lat2)),
          (this.ms2 = K3(this.e, this.sinphi, this.cosphi)),
          (this.ml2 = N4(this.e0, this.e1, this.e2, this.e3, this.lat2)),
          (this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1))),
      (this.g = this.ml1 + this.ms1 / this.ns),
      (this.ml0 = N4(this.e0, this.e1, this.e2, this.e3, this.lat0)),
      (this.rh = this.a * (this.g - this.ml0)));
  },
  forward: function (t) {
    var e,
      i = t.x,
      n = t.y;
    if (this.sphere) e = this.a * (this.g - n);
    else {
      var r = N4(this.e0, this.e1, this.e2, this.e3, n);
      e = this.a * (this.g - r);
    }
    var o = this.ns * t5(i - this.long0),
      a = this.x0 + e * Math.sin(o),
      s = this.y0 + this.rh - e * Math.cos(o);
    return (t.x = a), (t.y = s), t;
  },
  inverse: function (t) {
    var e, i, n, r;
    (t.x -= this.x0),
      (t.y = this.rh - t.y + this.y0),
      this.ns >= 0
        ? ((i = Math.sqrt(t.x * t.x + t.y * t.y)), (e = 1))
        : ((i = -Math.sqrt(t.x * t.x + t.y * t.y)), (e = -1));
    var o = 0;
    return (
      0 !== i && (o = Math.atan2(e * t.x, e * t.y)),
      this.sphere
        ? ((r = t5(this.long0 + o / this.ns)),
          (n = B4(this.g - i / this.a)),
          (t.x = r),
          (t.y = n),
          t)
        : ((n = G4(this.g - i / this.a, this.e0, this.e1, this.e2, this.e3)),
          (r = t5(this.long0 + o / this.ns)),
          (t.x = r),
          (t.y = n),
          t)
    );
  },
  names: ["Equidistant_Conic", "eqdc"],
};
const s6 = {
  init: function () {
    this.R = this.a;
  },
  forward: function (t) {
    var e,
      i,
      n = t.x,
      r = t.y,
      o = t5(n - this.long0);
    Math.abs(r) <= M3 && ((e = this.x0 + this.R * o), (i = this.y0));
    var a = Z4(2 * Math.abs(r / Math.PI));
    (Math.abs(o) <= M3 || Math.abs(Math.abs(r) - b3) <= M3) &&
      ((e = this.x0),
      (i =
        r >= 0
          ? this.y0 + Math.PI * this.R * Math.tan(0.5 * a)
          : this.y0 + Math.PI * this.R * -Math.tan(0.5 * a)));
    var s = 0.5 * Math.abs(Math.PI / o - o / Math.PI),
      l = s * s,
      u = Math.sin(a),
      c = Math.cos(a),
      h = c / (u + c - 1),
      p = h * h,
      d = h * (2 / u - 1),
      f = d * d,
      g =
        (Math.PI *
          this.R *
          (s * (h - f) +
            Math.sqrt(l * (h - f) * (h - f) - (f + l) * (p - f)))) /
        (f + l);
    o < 0 && (g = -g), (e = this.x0 + g);
    var m = l + h;
    return (
      (g =
        (Math.PI *
          this.R *
          (d * m - s * Math.sqrt((f + l) * (l + 1) - m * m))) /
        (f + l)),
      (i = r >= 0 ? this.y0 + g : this.y0 - g),
      (t.x = e),
      (t.y = i),
      t
    );
  },
  inverse: function (t) {
    var e, i, n, r, o, a, s, l, u, c, h, p;
    return (
      (t.x -= this.x0),
      (t.y -= this.y0),
      (h = Math.PI * this.R),
      (o = (n = t.x / h) * n + (r = t.y / h) * r),
      (h =
        (3 *
          ((r * r) /
            (l = -2 * (a = -Math.abs(r) * (1 + o)) + 1 + 2 * r * r + o * o) +
            ((2 * (s = a - 2 * r * r + n * n) * s * s) / l / l / l -
              (9 * a * s) / l / l) /
              27)) /
        (u = (a - (s * s) / 3 / l) / l) /
        (c = 2 * Math.sqrt(-u / 3))),
      Math.abs(h) > 1 && (h = h >= 0 ? 1 : -1),
      (p = Math.acos(h) / 3),
      (i =
        t.y >= 0
          ? (-c * Math.cos(p + Math.PI / 3) - s / 3 / l) * Math.PI
          : -(-c * Math.cos(p + Math.PI / 3) - s / 3 / l) * Math.PI),
      (e =
        Math.abs(n) < M3
          ? this.long0
          : t5(
              this.long0 +
                (Math.PI *
                  (o - 1 + Math.sqrt(1 + 2 * (n * n - r * r) + o * o))) /
                  2 /
                  n
            )),
      (t.x = e),
      (t.y = i),
      t
    );
  },
  names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"],
};
const l6 = {
  init: function () {
    (this.sin_p12 = Math.sin(this.lat0)), (this.cos_p12 = Math.cos(this.lat0));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h,
      p,
      d,
      f,
      g,
      m,
      y,
      v,
      b,
      x,
      _,
      S,
      M = t.x,
      C = t.y,
      w = Math.sin(t.y),
      A = Math.cos(t.y),
      E = t5(M - this.long0);
    return this.sphere
      ? Math.abs(this.sin_p12 - 1) <= M3
        ? ((t.x = this.x0 + this.a * (b3 - C) * Math.sin(E)),
          (t.y = this.y0 - this.a * (b3 - C) * Math.cos(E)),
          t)
        : Math.abs(this.sin_p12 + 1) <= M3
        ? ((t.x = this.x0 + this.a * (b3 + C) * Math.sin(E)),
          (t.y = this.y0 + this.a * (b3 + C) * Math.cos(E)),
          t)
        : ((v = this.sin_p12 * w + this.cos_p12 * A * Math.cos(E)),
          (y = (m = Math.acos(v)) ? m / Math.sin(m) : 1),
          (t.x = this.x0 + this.a * y * A * Math.sin(E)),
          (t.y =
            this.y0 +
            this.a * y * (this.cos_p12 * w - this.sin_p12 * A * Math.cos(E))),
          t)
      : ((e = R4(this.es)),
        (i = O4(this.es)),
        (n = F4(this.es)),
        (r = z4(this.es)),
        Math.abs(this.sin_p12 - 1) <= M3
          ? ((o = this.a * N4(e, i, n, r, b3)),
            (a = this.a * N4(e, i, n, r, C)),
            (t.x = this.x0 + (o - a) * Math.sin(E)),
            (t.y = this.y0 - (o - a) * Math.cos(E)),
            t)
          : Math.abs(this.sin_p12 + 1) <= M3
          ? ((o = this.a * N4(e, i, n, r, b3)),
            (a = this.a * N4(e, i, n, r, C)),
            (t.x = this.x0 + (o + a) * Math.sin(E)),
            (t.y = this.y0 + (o + a) * Math.cos(E)),
            t)
          : ((s = w / A),
            (l = k4(this.a, this.e, this.sin_p12)),
            (u = k4(this.a, this.e, w)),
            (c = Math.atan(
              (1 - this.es) * s + (this.es * l * this.sin_p12) / (u * A)
            )),
            (b =
              0 ===
              (h = Math.atan2(
                Math.sin(E),
                this.cos_p12 * Math.tan(c) - this.sin_p12 * Math.cos(E)
              ))
                ? Math.asin(
                    this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)
                  )
                : Math.abs(Math.abs(h) - Math.PI) <= M3
                ? -Math.asin(
                    this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)
                  )
                : Math.asin((Math.sin(E) * Math.cos(c)) / Math.sin(h))),
            (p = (this.e * this.sin_p12) / Math.sqrt(1 - this.es)),
            (m =
              l *
              b *
              (1 -
                ((x = b * b) *
                  (g =
                    (d =
                      (this.e * this.cos_p12 * Math.cos(h)) /
                      Math.sqrt(1 - this.es)) * d) *
                  (1 - g)) /
                  6 +
                ((_ = x * b) / 8) * (f = p * d) * (1 - 2 * g) +
                ((S = _ * b) / 120) *
                  (g * (4 - 7 * g) - 3 * p * p * (1 - 7 * g)) -
                ((S * b) / 48) * f)),
            (t.x = this.x0 + m * Math.sin(h)),
            (t.y = this.y0 + m * Math.cos(h)),
            t));
  },
  inverse: function (t) {
    var e, i, n, r, o, a, s, l, u, c, h, p, d, f, g, m, y, v, b, x, _, S, M;
    if (((t.x -= this.x0), (t.y -= this.y0), this.sphere)) {
      if ((e = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * b3 * this.a) return;
      return (
        (i = e / this.a),
        (n = Math.sin(i)),
        (r = Math.cos(i)),
        (o = this.long0),
        Math.abs(e) <= M3
          ? (a = this.lat0)
          : ((a = Z4(r * this.sin_p12 + (t.y * n * this.cos_p12) / e)),
            (s = Math.abs(this.lat0) - b3),
            (o =
              Math.abs(s) <= M3
                ? this.lat0 >= 0
                  ? t5(this.long0 + Math.atan2(t.x, -t.y))
                  : t5(this.long0 - Math.atan2(-t.x, t.y))
                : t5(
                    this.long0 +
                      Math.atan2(
                        t.x * n,
                        e * this.cos_p12 * r - t.y * this.sin_p12 * n
                      )
                  ))),
        (t.x = o),
        (t.y = a),
        t
      );
    }
    return (
      (l = R4(this.es)),
      (u = O4(this.es)),
      (c = F4(this.es)),
      (h = z4(this.es)),
      Math.abs(this.sin_p12 - 1) <= M3
        ? ((a = G4(
            ((p = this.a * N4(l, u, c, h, b3)) -
              (e = Math.sqrt(t.x * t.x + t.y * t.y))) /
              this.a,
            l,
            u,
            c,
            h
          )),
          (o = t5(this.long0 + Math.atan2(t.x, -1 * t.y))),
          (t.x = o),
          (t.y = a),
          t)
        : Math.abs(this.sin_p12 + 1) <= M3
        ? ((p = this.a * N4(l, u, c, h, b3)),
          (a = G4(
            ((e = Math.sqrt(t.x * t.x + t.y * t.y)) - p) / this.a,
            l,
            u,
            c,
            h
          )),
          (o = t5(this.long0 + Math.atan2(t.x, t.y))),
          (t.x = o),
          (t.y = a),
          t)
        : ((e = Math.sqrt(t.x * t.x + t.y * t.y)),
          (g = Math.atan2(t.x, t.y)),
          (d = k4(this.a, this.e, this.sin_p12)),
          (m = Math.cos(g)),
          (v = (-(y = this.e * this.cos_p12 * m) * y) / (1 - this.es)),
          (b =
            (3 * this.es * (1 - v) * this.sin_p12 * this.cos_p12 * m) /
            (1 - this.es)),
          (S =
            1 -
            (v *
              (_ =
                (x = e / d) -
                (v * (1 + v) * Math.pow(x, 3)) / 6 -
                (b * (1 + 3 * v) * Math.pow(x, 4)) / 24) *
              _) /
              2 -
            (x * _ * _ * _) / 6),
          (f = Math.asin(
            this.sin_p12 * Math.cos(_) + this.cos_p12 * Math.sin(_) * m
          )),
          (o = t5(
            this.long0 + Math.asin((Math.sin(g) * Math.sin(_)) / Math.cos(f))
          )),
          (M = Math.sin(f)),
          (a = Math.atan2(
            (M - this.es * S * this.sin_p12) * Math.tan(f),
            M * (1 - this.es)
          )),
          (t.x = o),
          (t.y = a),
          t)
    );
  },
  names: ["Azimuthal_Equidistant", "aeqd"],
};
const u6 = {
  init: function () {
    (this.sin_p14 = Math.sin(this.lat0)), (this.cos_p14 = Math.cos(this.lat0));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l = t.x,
      u = t.y;
    return (
      (n = t5(l - this.long0)),
      (e = Math.sin(u)),
      (i = Math.cos(u)),
      (r = Math.cos(n)),
      1,
      ((o = this.sin_p14 * e + this.cos_p14 * i * r) > 0 ||
        Math.abs(o) <= M3) &&
        ((a = 1 * this.a * i * Math.sin(n)),
        (s = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * r))),
      (t.x = a),
      (t.y = s),
      t
    );
  },
  inverse: function (t) {
    var e, i, n, r, o, a, s;
    return (
      (t.x -= this.x0),
      (t.y -= this.y0),
      (i = Z4((e = Math.sqrt(t.x * t.x + t.y * t.y)) / this.a)),
      (n = Math.sin(i)),
      (r = Math.cos(i)),
      (a = this.long0),
      Math.abs(e) <= M3
        ? ((s = this.lat0), (t.x = a), (t.y = s), t)
        : ((s = Z4(r * this.sin_p14 + (t.y * n * this.cos_p14) / e)),
          (o = Math.abs(this.lat0) - b3),
          Math.abs(o) <= M3
            ? ((a =
                this.lat0 >= 0
                  ? t5(this.long0 + Math.atan2(t.x, -t.y))
                  : t5(this.long0 - Math.atan2(-t.x, t.y))),
              (t.x = a),
              (t.y = s),
              t)
            : ((a = t5(
                this.long0 +
                  Math.atan2(
                    t.x * n,
                    e * this.cos_p14 * r - t.y * this.sin_p14 * n
                  )
              )),
              (t.x = a),
              (t.y = s),
              t))
    );
  },
  names: ["ortho"],
};
var c6 = 1,
  h6 = 2,
  p6 = 3,
  d6 = 4,
  f6 = 5,
  g6 = 6,
  m6 = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4,
  };
function y6(t, e, i, n) {
  var r;
  return (
    t < M3
      ? ((n.value = m6.AREA_0), (r = 0))
      : ((r = Math.atan2(e, i)),
        Math.abs(r) <= A3
          ? (n.value = m6.AREA_0)
          : r > A3 && r <= b3 + A3
          ? ((n.value = m6.AREA_1), (r -= b3))
          : r > b3 + A3 || r <= -(b3 + A3)
          ? ((n.value = m6.AREA_2), (r = r >= 0 ? r - D3 : r + D3))
          : ((n.value = m6.AREA_3), (r += b3))),
    r
  );
}
function v6(t, e) {
  var i = t + e;
  return i < -D3 ? (i += E3) : i > +D3 && (i -= E3), i;
}
const b6 = {
  init: function () {
    (this.x0 = this.x0 || 0),
      (this.y0 = this.y0 || 0),
      (this.lat0 = this.lat0 || 0),
      (this.long0 = this.long0 || 0),
      (this.lat_ts = this.lat_ts || 0),
      (this.title = this.title || "Quadrilateralized Spherical Cube"),
      this.lat0 >= b3 - A3 / 2
        ? (this.face = f6)
        : this.lat0 <= -(b3 - A3 / 2)
        ? (this.face = g6)
        : Math.abs(this.long0) <= A3
        ? (this.face = c6)
        : Math.abs(this.long0) <= b3 + A3
        ? (this.face = this.long0 > 0 ? h6 : d6)
        : (this.face = p6),
      0 !== this.es &&
        ((this.one_minus_f = 1 - (this.a - this.b) / this.a),
        (this.one_minus_f_squared = this.one_minus_f * this.one_minus_f));
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s = {
        x: 0,
        y: 0,
      },
      l = {
        value: 0,
      };
    if (
      ((t.x -= this.long0),
      (e =
        0 !== this.es
          ? Math.atan(this.one_minus_f_squared * Math.tan(t.y))
          : t.y),
      (i = t.x),
      this.face === f6)
    )
      (r = b3 - e),
        i >= A3 && i <= b3 + A3
          ? ((l.value = m6.AREA_0), (n = i - b3))
          : i > b3 + A3 || i <= -(b3 + A3)
          ? ((l.value = m6.AREA_1), (n = i > 0 ? i - D3 : i + D3))
          : i > -(b3 + A3) && i <= -A3
          ? ((l.value = m6.AREA_2), (n = i + b3))
          : ((l.value = m6.AREA_3), (n = i));
    else if (this.face === g6)
      (r = b3 + e),
        i >= A3 && i <= b3 + A3
          ? ((l.value = m6.AREA_0), (n = -i + b3))
          : i < A3 && i >= -A3
          ? ((l.value = m6.AREA_1), (n = -i))
          : i < -A3 && i >= -(b3 + A3)
          ? ((l.value = m6.AREA_2), (n = -i - b3))
          : ((l.value = m6.AREA_3), (n = i > 0 ? -i + D3 : -i - D3));
    else {
      var u, c, h, p, d, f;
      this.face === h6
        ? (i = v6(i, +b3))
        : this.face === p6
        ? (i = v6(i, +D3))
        : this.face === d6 && (i = v6(i, -b3)),
        (p = Math.sin(e)),
        (d = Math.cos(e)),
        (f = Math.sin(i)),
        (u = d * Math.cos(i)),
        (c = d * f),
        (h = p),
        this.face === c6
          ? (n = y6((r = Math.acos(u)), h, c, l))
          : this.face === h6
          ? (n = y6((r = Math.acos(c)), h, -u, l))
          : this.face === p6
          ? (n = y6((r = Math.acos(-u)), h, -c, l))
          : this.face === d6
          ? (n = y6((r = Math.acos(-c)), h, u, l))
          : ((r = n = 0), (l.value = m6.AREA_0));
    }
    return (
      (a = Math.atan(
        (12 / D3) * (n + Math.acos(Math.sin(n) * Math.cos(A3)) - b3)
      )),
      (o = Math.sqrt(
        (1 - Math.cos(r)) /
          (Math.cos(a) * Math.cos(a)) /
          (1 - Math.cos(Math.atan(1 / Math.cos(n))))
      )),
      l.value === m6.AREA_1
        ? (a += b3)
        : l.value === m6.AREA_2
        ? (a += D3)
        : l.value === m6.AREA_3 && (a += 1.5 * D3),
      (s.x = o * Math.cos(a)),
      (s.y = o * Math.sin(a)),
      (s.x = s.x * this.a + this.x0),
      (s.y = s.y * this.a + this.y0),
      (t.x = s.x),
      (t.y = s.y),
      t
    );
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o,
      a,
      s,
      l,
      u,
      c,
      h,
      p,
      d = {
        lam: 0,
        phi: 0,
      },
      f = {
        value: 0,
      };
    if (
      ((t.x = (t.x - this.x0) / this.a),
      (t.y = (t.y - this.y0) / this.a),
      (i = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y))),
      (e = Math.atan2(t.y, t.x)),
      t.x >= 0 && t.x >= Math.abs(t.y)
        ? (f.value = m6.AREA_0)
        : t.y >= 0 && t.y >= Math.abs(t.x)
        ? ((f.value = m6.AREA_1), (e -= b3))
        : t.x < 0 && -t.x >= Math.abs(t.y)
        ? ((f.value = m6.AREA_2), (e = e < 0 ? e + D3 : e - D3))
        : ((f.value = m6.AREA_3), (e += b3)),
      (u = (D3 / 12) * Math.tan(e)),
      (o = Math.sin(u) / (Math.cos(u) - 1 / Math.sqrt(2))),
      (a = Math.atan(o)),
      (s =
        1 -
        (n = Math.cos(e)) *
          n *
          (r = Math.tan(i)) *
          r *
          (1 - Math.cos(Math.atan(1 / Math.cos(a))))) < -1
        ? (s = -1)
        : s > 1 && (s = 1),
      this.face === f6)
    )
      (l = Math.acos(s)),
        (d.phi = b3 - l),
        f.value === m6.AREA_0
          ? (d.lam = a + b3)
          : f.value === m6.AREA_1
          ? (d.lam = a < 0 ? a + D3 : a - D3)
          : f.value === m6.AREA_2
          ? (d.lam = a - b3)
          : (d.lam = a);
    else if (this.face === g6)
      (l = Math.acos(s)),
        (d.phi = l - b3),
        f.value === m6.AREA_0
          ? (d.lam = -a + b3)
          : f.value === m6.AREA_1
          ? (d.lam = -a)
          : f.value === m6.AREA_2
          ? (d.lam = -a - b3)
          : (d.lam = a < 0 ? -a - D3 : -a + D3);
    else {
      var g, m, y;
      (u = (g = s) * g),
        (m =
          (u += (y = u >= 1 ? 0 : Math.sqrt(1 - u) * Math.sin(a)) * y) >= 1
            ? 0
            : Math.sqrt(1 - u)),
        f.value === m6.AREA_1
          ? ((u = m), (m = -y), (y = u))
          : f.value === m6.AREA_2
          ? ((m = -m), (y = -y))
          : f.value === m6.AREA_3 && ((u = m), (m = y), (y = -u)),
        this.face === h6
          ? ((u = g), (g = -m), (m = u))
          : this.face === p6
          ? ((g = -g), (m = -m))
          : this.face === d6 && ((u = g), (g = m), (m = -u)),
        (d.phi = Math.acos(-y) - b3),
        (d.lam = Math.atan2(m, g)),
        this.face === h6
          ? (d.lam = v6(d.lam, -b3))
          : this.face === p6
          ? (d.lam = v6(d.lam, -D3))
          : this.face === d6 && (d.lam = v6(d.lam, +b3));
    }
    return (
      0 !== this.es &&
        ((c = d.phi < 0 ? 1 : 0),
        (h = Math.tan(d.phi)),
        (p = this.b / Math.sqrt(h * h + this.one_minus_f_squared)),
        (d.phi = Math.atan(
          Math.sqrt(this.a * this.a - p * p) / (this.one_minus_f * p)
        )),
        c && (d.phi = -d.phi)),
      (d.lam += this.long0),
      (t.x = d.lam),
      (t.y = d.phi),
      t
    );
  },
  names: [
    "Quadrilateralized Spherical Cube",
    "Quadrilateralized_Spherical_Cube",
    "qsc",
  ],
};
var x6 = [
    [1, 22199e-21, -715515e-10, 31103e-10],
    [0.9986, -482243e-9, -24897e-9, -13309e-10],
    [0.9954, -83103e-8, -448605e-10, -9.86701e-7],
    [0.99, -0.00135364, -59661e-9, 36777e-10],
    [0.9822, -0.00167442, -449547e-11, -572411e-11],
    [0.973, -0.00214868, -903571e-10, 1.8736e-8],
    [0.96, -0.00305085, -900761e-10, 164917e-11],
    [0.9427, -0.00382792, -653386e-10, -26154e-10],
    [0.9216, -0.00467746, -10457e-8, 481243e-11],
    [0.8962, -0.00536223, -323831e-10, -543432e-11],
    [0.8679, -0.00609363, -113898e-9, 332484e-11],
    [0.835, -0.00698325, -640253e-10, 9.34959e-7],
    [0.7986, -0.00755338, -500009e-10, 9.35324e-7],
    [0.7597, -0.00798324, -35971e-9, -227626e-11],
    [0.7186, -0.00851367, -701149e-10, -86303e-10],
    [0.6732, -0.00986209, -199569e-9, 191974e-10],
    [0.6213, -0.010418, 883923e-10, 624051e-11],
    [0.5722, -0.00906601, 182e-6, 624051e-11],
    [0.5322, -0.00677797, 275608e-9, 624051e-11],
  ],
  _6 = [
    [-520417e-23, 0.0124, 121431e-23, -845284e-16],
    [0.062, 0.0124, -1.26793e-9, 4.22642e-10],
    [0.124, 0.0124, 5.07171e-9, -1.60604e-9],
    [0.186, 0.0123999, -1.90189e-8, 6.00152e-9],
    [0.248, 0.0124002, 7.10039e-8, -2.24e-8],
    [0.31, 0.0123992, -2.64997e-7, 8.35986e-8],
    [0.372, 0.0124029, 9.88983e-7, -3.11994e-7],
    [0.434, 0.0123893, -369093e-11, -4.35621e-7],
    [0.4958, 0.0123198, -102252e-10, -3.45523e-7],
    [0.5571, 0.0121916, -154081e-10, -5.82288e-7],
    [0.6176, 0.0119938, -241424e-10, -5.25327e-7],
    [0.6769, 0.011713, -320223e-10, -5.16405e-7],
    [0.7346, 0.0113541, -397684e-10, -6.09052e-7],
    [0.7903, 0.0109107, -489042e-10, -104739e-11],
    [0.8435, 0.0103431, -64615e-9, -1.40374e-9],
    [0.8936, 0.00969686, -64636e-9, -8547e-9],
    [0.9394, 0.00840947, -192841e-9, -42106e-10],
    [0.9761, 0.00616527, -256e-6, -42106e-10],
    [1, 0.00328947, -319159e-9, -42106e-10],
  ],
  S6 = 0.8487,
  M6 = 1.3523,
  C6 = w3 / 5,
  w6 = 1 / C6,
  A6 = 18,
  E6 = function (t, e) {
    return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
  };
const D6 = {
  init: function () {
    (this.x0 = this.x0 || 0),
      (this.y0 = this.y0 || 0),
      (this.long0 = this.long0 || 0),
      (this.es = 0),
      (this.title = this.title || "Robinson");
  },
  forward: function (t) {
    var e = t5(t.x - this.long0),
      i = Math.abs(t.y),
      n = Math.floor(i * C6);
    n < 0 ? (n = 0) : n >= A6 && (n = 17);
    var r = {
      x: E6(x6[n], (i = w3 * (i - w6 * n))) * e,
      y: E6(_6[n], i),
    };
    return (
      t.y < 0 && (r.y = -r.y),
      (r.x = r.x * this.a * S6 + this.x0),
      (r.y = r.y * this.a * M6 + this.y0),
      r
    );
  },
  inverse: function (t) {
    var e = {
      x: (t.x - this.x0) / (this.a * S6),
      y: Math.abs(t.y - this.y0) / (this.a * M6),
    };
    if (e.y >= 1) (e.x /= x6[18][0]), (e.y = t.y < 0 ? -b3 : b3);
    else {
      var i = Math.floor(e.y * A6);
      for (i < 0 ? (i = 0) : i >= A6 && (i = 17); ; )
        if (_6[i][0] > e.y) --i;
        else {
          if (!(_6[i + 1][0] <= e.y)) break;
          ++i;
        }
      var n = _6[i],
        r = (5 * (e.y - n[0])) / (_6[i + 1][0] - n[0]);
      (r = (function (t, e, i, n) {
        for (var r = e; n; --n) {
          var o = t(r);
          if (((r -= o), Math.abs(o) < i)) break;
        }
        return r;
      })(
        function (t) {
          return (
            (E6(n, t) - e.y) /
            (function (t, e) {
              return t[1] + e * (2 * t[2] + 3 * e * t[3]);
            })(n, t)
          );
        },
        r,
        M3,
        100
      )),
        (e.x /= E6(x6[i], r)),
        (e.y = (5 * i + r) * C3),
        t.y < 0 && (e.y = -e.y);
    }
    return (e.x = t5(e.x + this.long0)), e;
  },
  names: ["Robinson", "robin"],
};
const T6 = {
  init: function () {
    this.name = "geocent";
  },
  forward: function (t) {
    return x5(t, this.es, this.a);
  },
  inverse: function (t) {
    return _5(t, this.es, this.a, this.b);
  },
  names: ["Geocentric", "geocentric", "geocent", "Geocent"],
};
var P6 = 0,
  L6 = 1,
  I6 = 2,
  N6 = 3,
  R6 = {
    h: {
      def: 1e5,
      num: !0,
    },
    azi: {
      def: 0,
      num: !0,
      degrees: !0,
    },
    tilt: {
      def: 0,
      num: !0,
      degrees: !0,
    },
    long0: {
      def: 0,
      num: !0,
    },
    lat0: {
      def: 0,
      num: !0,
    },
  };
const O6 = {
  init: function () {
    if (
      (Object.keys(R6).forEach(
        function (t) {
          if (void 0 === this[t]) this[t] = R6[t].def;
          else {
            if (R6[t].num && isNaN(this[t]))
              throw new Error(
                "Invalid parameter value, must be numeric " +
                  t +
                  " = " +
                  this[t]
              );
            R6[t].num && (this[t] = parseFloat(this[t]));
          }
          R6[t].degrees && (this[t] = this[t] * C3);
        }.bind(this)
      ),
      Math.abs(Math.abs(this.lat0) - b3) < M3
        ? (this.mode = this.lat0 < 0 ? L6 : P6)
        : Math.abs(this.lat0) < M3
        ? (this.mode = I6)
        : ((this.mode = N6),
          (this.sinph0 = Math.sin(this.lat0)),
          (this.cosph0 = Math.cos(this.lat0))),
      (this.pn1 = this.h / this.a),
      this.pn1 <= 0 || this.pn1 > 1e10)
    )
      throw new Error("Invalid height");
    (this.p = 1 + this.pn1),
      (this.rp = 1 / this.p),
      (this.h1 = 1 / this.pn1),
      (this.pfact = (this.p + 1) * this.h1),
      (this.es = 0);
    var t = this.tilt,
      e = this.azi;
    (this.cg = Math.cos(e)),
      (this.sg = Math.sin(e)),
      (this.cw = Math.cos(t)),
      (this.sw = Math.sin(t));
  },
  forward: function (t) {
    t.x -= this.long0;
    var e,
      i,
      n,
      r,
      o = Math.sin(t.y),
      a = Math.cos(t.y),
      s = Math.cos(t.x);
    switch (this.mode) {
      case N6:
        i = this.sinph0 * o + this.cosph0 * a * s;
        break;
      case I6:
        i = a * s;
        break;
      case L6:
        i = -o;
        break;
      case P6:
        i = o;
    }
    switch (
      ((e = (i = this.pn1 / (this.p - i)) * a * Math.sin(t.x)), this.mode)
    ) {
      case N6:
        i *= this.cosph0 * o - this.sinph0 * a * s;
        break;
      case I6:
        i *= o;
        break;
      case P6:
        i *= -a * s;
        break;
      case L6:
        i *= a * s;
    }
    return (
      (r = 1 / ((n = i * this.cg + e * this.sg) * this.sw * this.h1 + this.cw)),
      (e = (e * this.cg - i * this.sg) * this.cw * r),
      (i = n * r),
      (t.x = e * this.a),
      (t.y = i * this.a),
      t
    );
  },
  inverse: function (t) {
    (t.x /= this.a), (t.y /= this.a);
    var e,
      i,
      n,
      r = {
        x: t.x,
        y: t.y,
      };
    (n = 1 / (this.pn1 - t.y * this.sw)),
      (e = this.pn1 * t.x * n),
      (i = this.pn1 * t.y * this.cw * n),
      (t.x = e * this.cg + i * this.sg),
      (t.y = i * this.cg - e * this.sg);
    var o = v4(t.x, t.y);
    if (Math.abs(o) < M3) (r.x = 0), (r.y = t.y);
    else {
      var a, s;
      switch (
        ((s = 1 - o * o * this.pfact),
        (s = (this.p - Math.sqrt(s)) / (this.pn1 / o + o / this.pn1)),
        (a = Math.sqrt(1 - s * s)),
        this.mode)
      ) {
        case N6:
          (r.y = Math.asin(a * this.sinph0 + (t.y * s * this.cosph0) / o)),
            (t.y = (a - this.sinph0 * Math.sin(r.y)) * o),
            (t.x *= s * this.cosph0);
          break;
        case I6:
          (r.y = Math.asin((t.y * s) / o)), (t.y = a * o), (t.x *= s);
          break;
        case P6:
          (r.y = Math.asin(a)), (t.y = -t.y);
          break;
        case L6:
          r.y = -Math.asin(a);
      }
      r.x = Math.atan2(t.x, t.y);
    }
    return (t.x = r.x + this.long0), (t.y = r.y), t;
  },
  names: ["Tilted_Perspective", "tpers"],
};
const F6 = {
  init: function () {
    if (
      ((this.flip_axis = "x" === this.sweep ? 1 : 0),
      (this.h = Number(this.h)),
      (this.radius_g_1 = this.h / this.a),
      this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    )
      throw new Error();
    if (
      ((this.radius_g = 1 + this.radius_g_1),
      (this.C = this.radius_g * this.radius_g - 1),
      0 !== this.es)
    ) {
      var t = 1 - this.es,
        e = 1 / t;
      (this.radius_p = Math.sqrt(t)),
        (this.radius_p2 = t),
        (this.radius_p_inv2 = e),
        (this.shape = "ellipse");
    } else
      (this.radius_p = 1),
        (this.radius_p2 = 1),
        (this.radius_p_inv2 = 1),
        (this.shape = "sphere");
    this.title || (this.title = "Geostationary Satellite View");
  },
  forward: function (t) {
    var e,
      i,
      n,
      r,
      o = t.x,
      a = t.y;
    if (((o -= this.long0), "ellipse" === this.shape)) {
      a = Math.atan(this.radius_p2 * Math.tan(a));
      var s = this.radius_p / v4(this.radius_p * Math.cos(a), Math.sin(a));
      if (
        ((i = s * Math.cos(o) * Math.cos(a)),
        (n = s * Math.sin(o) * Math.cos(a)),
        (r = s * Math.sin(a)),
        (this.radius_g - i) * i - n * n - r * r * this.radius_p_inv2 < 0)
      )
        return (t.x = Number.NaN), (t.y = Number.NaN), t;
      (e = this.radius_g - i),
        this.flip_axis
          ? ((t.x = this.radius_g_1 * Math.atan(n / v4(r, e))),
            (t.y = this.radius_g_1 * Math.atan(r / e)))
          : ((t.x = this.radius_g_1 * Math.atan(n / e)),
            (t.y = this.radius_g_1 * Math.atan(r / v4(n, e))));
    } else
      "sphere" === this.shape &&
        ((e = Math.cos(a)),
        (i = Math.cos(o) * e),
        (n = Math.sin(o) * e),
        (r = Math.sin(a)),
        (e = this.radius_g - i),
        this.flip_axis
          ? ((t.x = this.radius_g_1 * Math.atan(n / v4(r, e))),
            (t.y = this.radius_g_1 * Math.atan(r / e)))
          : ((t.x = this.radius_g_1 * Math.atan(n / e)),
            (t.y = this.radius_g_1 * Math.atan(r / v4(n, e)))));
    return (t.x = t.x * this.a), (t.y = t.y * this.a), t;
  },
  inverse: function (t) {
    var e,
      i,
      n,
      r,
      o = -1,
      a = 0,
      s = 0;
    if (
      ((t.x = t.x / this.a), (t.y = t.y / this.a), "ellipse" === this.shape)
    ) {
      this.flip_axis
        ? ((s = Math.tan(t.y / this.radius_g_1)),
          (a = Math.tan(t.x / this.radius_g_1) * v4(1, s)))
        : ((a = Math.tan(t.x / this.radius_g_1)),
          (s = Math.tan(t.y / this.radius_g_1) * v4(1, a)));
      var l = s / this.radius_p;
      if (
        ((e = a * a + l * l + o * o),
        (n = (i = 2 * this.radius_g * o) * i - 4 * e * this.C) < 0)
      )
        return (t.x = Number.NaN), (t.y = Number.NaN), t;
      (r = (-i - Math.sqrt(n)) / (2 * e)),
        (o = this.radius_g + r * o),
        (a *= r),
        (s *= r),
        (t.x = Math.atan2(a, o)),
        (t.y = Math.atan((s * Math.cos(t.x)) / o)),
        (t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y)));
    } else if ("sphere" === this.shape) {
      if (
        (this.flip_axis
          ? ((s = Math.tan(t.y / this.radius_g_1)),
            (a = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + s * s)))
          : ((a = Math.tan(t.x / this.radius_g_1)),
            (s = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + a * a))),
        (e = a * a + s * s + o * o),
        (n = (i = 2 * this.radius_g * o) * i - 4 * e * this.C) < 0)
      )
        return (t.x = Number.NaN), (t.y = Number.NaN), t;
      (r = (-i - Math.sqrt(n)) / (2 * e)),
        (o = this.radius_g + r * o),
        (a *= r),
        (s *= r),
        (t.x = Math.atan2(a, o)),
        (t.y = Math.atan((s * Math.cos(t.x)) / o));
    }
    return (t.x = t.x + this.long0), t;
  },
  names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"],
};
var z6 = 1.340264,
  k6 = -0.081106,
  B6 = 893e-6,
  G6 = 0.003796,
  U6 = Math.sqrt(3) / 2;
const j6 = {
  init: function () {
    (this.es = 0), (this.long0 = void 0 !== this.long0 ? this.long0 : 0);
  },
  forward: function (t) {
    var e = t5(t.x - this.long0),
      i = t.y,
      n = Math.asin(U6 * Math.sin(i)),
      r = n * n,
      o = r * r * r;
    return (
      (t.x =
        (e * Math.cos(n)) /
        (U6 * (z6 + 3 * k6 * r + o * (7 * B6 + 9 * G6 * r)))),
      (t.y = n * (z6 + k6 * r + o * (B6 + G6 * r))),
      (t.x = this.a * t.x + this.x0),
      (t.y = this.a * t.y + this.y0),
      t
    );
  },
  inverse: function (t) {
    (t.x = (t.x - this.x0) / this.a), (t.y = (t.y - this.y0) / this.a);
    var e,
      i,
      n,
      r,
      o = t.y;
    for (
      r = 0;
      r < 12 &&
      ((o -= n =
        (o * (z6 + k6 * (e = o * o) + (i = e * e * e) * (B6 + G6 * e)) - t.y) /
        (z6 + 3 * k6 * e + i * (7 * B6 + 9 * G6 * e))),
      !(Math.abs(n) < 1e-9));
      ++r
    );
    return (
      (i = (e = o * o) * e * e),
      (t.x =
        (U6 * t.x * (z6 + 3 * k6 * e + i * (7 * B6 + 9 * G6 * e))) /
        Math.cos(o)),
      (t.y = Math.asin(Math.sin(o) / U6)),
      (t.x = t5(t.x + this.long0)),
      t
    );
  },
  names: ["eqearth", "Equal Earth", "Equal_Earth"],
};
var H6;
function V6(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function W6(t, e) {
  let i, n, r;
  const o = t.coordinates;
  switch (t.type) {
    case "Point":
      e(o);
      break;
    case "LineString":
    case "MultiPoint":
      for (i = 0; i < o.length; i++) e(o[i]);
      break;
    case "Polygon":
    case "MultiLineString":
      for (i = 0; i < o.length; i++)
        for (n = 0; n < o[i].length; n++) e(o[i][n]);
      break;
    case "MultiPolygon":
      for (i = 0; i < o.length; i++)
        for (n = 0; n < o[i].length; n++)
          for (r = 0; r < o[i][n].length; r++) e(o[i][n][r]);
  }
}
(R5.defaultDatum = "WGS84"),
  (R5.Proj = b5),
  (R5.WGS84 = new R5.Proj("WGS84")),
  (R5.Point = $5),
  (R5.toPoint = D5),
  (R5.defs = Y3),
  (R5.nadgrid = function (t, e) {
    var i = new DataView(e),
      n = (function (t) {
        var e = t.getInt32(8, !1);
        if (11 === e) return !1;
        e = t.getInt32(8, !0);
        return !0;
      })(i),
      r = (function (t, e) {
        return {
          nFields: t.getInt32(8, e),
          nSubgridFields: t.getInt32(24, e),
          nSubgrids: t.getInt32(40, e),
          shiftType: g5(t, 56, 64).trim(),
          fromSemiMajorAxis: t.getFloat64(120, e),
          fromSemiMinorAxis: t.getFloat64(136, e),
          toSemiMajorAxis: t.getFloat64(152, e),
          toSemiMinorAxis: t.getFloat64(168, e),
        };
      })(i, n),
      o = (function (t, e, i) {
        for (var n = 176, r = [], o = 0; o < e.nSubgrids; o++) {
          var a = y5(t, n, i),
            s = v5(t, n, a, i),
            l = Math.round(
              1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
            ),
            u = Math.round(
              1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
            );
          r.push({
            ll: [f5(a.lowerLongitude), f5(a.lowerLatitude)],
            del: [f5(a.longitudeInterval), f5(a.latitudeInterval)],
            lim: [l, u],
            count: a.gridNodeCount,
            cvs: m5(s),
          }),
            (n += 176 + 16 * a.gridNodeCount);
        }
        return r;
      })(i, r, n),
      a = {
        header: r,
        subgrids: o,
      };
    return (p5[t] = a), a;
  }),
  (R5.transform = P5),
  (R5.mgrs = H5),
  (R5.version = "__VERSION__"),
  (H6 = R5).Proj.projections.add(m4),
  H6.Proj.projections.add(S4),
  H6.Proj.projections.add(M4),
  H6.Proj.projections.add(A4),
  H6.Proj.projections.add(E4),
  H6.Proj.projections.add(D4),
  H6.Proj.projections.add(P4),
  H6.Proj.projections.add(L4),
  H6.Proj.projections.add(I4),
  H6.Proj.projections.add(U4),
  H6.Proj.projections.add(Q4),
  H6.Proj.projections.add(J4),
  H6.Proj.projections.add(K4),
  H6.Proj.projections.add($4),
  H6.Proj.projections.add(t6),
  H6.Proj.projections.add(e6),
  H6.Proj.projections.add(i6),
  H6.Proj.projections.add(n6),
  H6.Proj.projections.add(r6),
  H6.Proj.projections.add(o6),
  H6.Proj.projections.add(a6),
  H6.Proj.projections.add(s6),
  H6.Proj.projections.add(l6),
  H6.Proj.projections.add(u6),
  H6.Proj.projections.add(b6),
  H6.Proj.projections.add(D6),
  H6.Proj.projections.add(T6),
  H6.Proj.projections.add(O6),
  H6.Proj.projections.add(F6),
  H6.Proj.projections.add(j6);
var q6 = {
  geoProjection: function (t, e) {
    const i = JSON.parse(JSON.stringify(t));
    switch (i.type) {
      case "FeatureCollection":
        for (let t = 0; t < i.features.length; t++)
          W6(i.features[t].geometry, e);
        break;
      case "Feature":
        W6(i.geometry, e);
        break;
      case "GeometryCollection":
        for (let t = 0; t < i.geometries.length; t++) W6(i.geometries[t], e);
        break;
      default:
        W6(i, e);
    }
    return i;
  },
};
const Y6 = R5,
  { geoProjection: X6 } = q6,
  Q6 = Math.PI,
  Z6 = 6378245,
  J6 = 0.006693421622965943;
function K6(t, e) {
  e = +e;
  return !((t = +t) > 73.66 && t < 135.05 && e > 3.86 && e < 53.55);
}
function $6(t, e) {
  let i =
    300 +
    (t = +t) +
    2 * (e = +e) +
    0.1 * t * t +
    0.1 * t * e +
    0.1 * Math.sqrt(Math.abs(t));
  return (
    (i += (2 * (20 * Math.sin(6 * t * Q6) + 20 * Math.sin(2 * t * Q6))) / 3),
    (i += (2 * (20 * Math.sin(t * Q6) + 40 * Math.sin((t / 3) * Q6))) / 3),
    (i +=
      (2 * (150 * Math.sin((t / 12) * Q6) + 300 * Math.sin((t / 30) * Q6))) /
      3),
    i
  );
}
function t7(t, e) {
  let i =
    2 * (t = +t) -
    100 +
    3 * (e = +e) +
    0.2 * e * e +
    0.1 * t * e +
    0.2 * Math.sqrt(Math.abs(t));
  return (
    (i += (2 * (20 * Math.sin(6 * t * Q6) + 20 * Math.sin(2 * t * Q6))) / 3),
    (i += (2 * (20 * Math.sin(e * Q6) + 40 * Math.sin((e / 3) * Q6))) / 3),
    (i +=
      (2 * (160 * Math.sin((e / 12) * Q6) + 320 * Math.sin((e * Q6) / 30))) /
      3),
    i
  );
}
function e7(t, e) {
  if (K6((t = +t), (e = +e))) return [t, e];
  {
    let i = t7(t - 105, e - 35),
      n = $6(t - 105, e - 35);
    const r = (e / 180) * Q6;
    let o = Math.sin(r);
    o = 1 - J6 * o * o;
    const a = Math.sqrt(o);
    (i = (180 * i) / (((Z6 * (1 - J6)) / (o * a)) * Q6)),
      (n = (180 * n) / ((Z6 / a) * Math.cos(r) * Q6));
    return [t + n, e + i];
  }
}
function i7(t, e) {
  if (K6((t = +t), (e = +e))) return [t, e];
  {
    let i = t7(t - 105, e - 35),
      n = $6(t - 105, e - 35);
    const r = (e / 180) * Q6;
    let o = Math.sin(r);
    o = 1 - J6 * o * o;
    const a = Math.sqrt(o);
    (i = (180 * i) / (((Z6 * (1 - J6)) / (o * a)) * Q6)),
      (n = (180 * n) / ((Z6 / a) * Math.cos(r) * Q6));
    return [2 * t - (t + n), 2 * e - (e + i)];
  }
}
function n7(t, e, i, n) {
  return Y6(t, e, [i, n]);
}
function r7(t, e, i) {
  const n = i7(e, i);
  return Y6("EPSG:4326", t, n);
}
function o7(t, e, i) {
  return e7(...Y6(t, "EPSG:4326", [e, i]));
}
var a7 = {
    setProj4Defs: function (t, e) {
      e.indexOf("+datum=DefaultProj4") > -1
        ? Y6.defs("DefaultProj4", e)
        : Y6.defs(t, e);
    },
    WGS84toDefaultProj4: e7,
    DefaultProj4toWGS84: i7,
    Proj4toProj4: n7,
    DefaultProj4toProj4: r7,
    Proj4toDefaultProj4: o7,
    coordTranslate: function (t, e, i, n) {
      let r;
      return (
        "dataArray" === n
          ? (r = (function (t, e, i) {
              let n,
                r = [];
              if ("DefaultProj4" == t && "EPSG:4326" == e)
                for (n = 0; n < i.length; n++) {
                  const t = i[n],
                    e = i7(t.lng, t.lat);
                  (t.lng = +e[0].toFixed(6)),
                    (t.lat = +e[1].toFixed(6)),
                    r.push(t);
                }
              else if ("EPSG:4326" == t && "DefaultProj4" == e)
                for (n = 0; n < i.length; n++) {
                  const t = i[n],
                    e = e7(t.lng, t.lat);
                  (t.lng = +e[0].toFixed(6)),
                    (t.lat = +e[1].toFixed(6)),
                    r.push(t);
                }
              else if ("DefaultProj4" == t)
                for (n = 0; n < i.length; n++) {
                  const t = i[n],
                    o = r7(e, t.lng, t.lat);
                  (t.lng = +o[0].toFixed(6)),
                    (t.lat = +o[1].toFixed(6)),
                    r.push(t);
                }
              else if ("DefaultProj4" == e)
                for (n = 0; n < i.length; n++) {
                  const e = i[n],
                    o = o7(t, e.lng, e.lat);
                  (e.lng = +o[0].toFixed(6)),
                    (e.lat = +o[1].toFixed(6)),
                    r.push(e);
                }
              else
                for (n = 0; n < i.length; n++) {
                  const o = i[n],
                    a = n7(t, e, o.lng, o.lat);
                  (o.lng = +a[0].toFixed(6)),
                    (o.lat = +a[1].toFixed(6)),
                    r.push(o);
                }
              return r;
            })(t, e, i))
          : "geojson" === n &&
            (r = (function (t, e, i) {
              let n, r;
              return (
                "DefaultProj4" == t && "EPSG:4326" == e
                  ? ((n = function (t) {
                      const e = i7(t[0], t[1]);
                      (t[0] = +e[0].toFixed(6)), (t[1] = +e[1].toFixed(6));
                    }),
                    (r = X6(i, n)))
                  : "EPSG:4326" == t && "DefaultProj4" == e
                  ? ((n = function (t) {
                      const e = e7(t[0], t[1]);
                      (t[0] = +e[0].toFixed(6)), (t[1] = +e[1].toFixed(6));
                    }),
                    (r = X6(i, n)))
                  : "DefaultProj4" == t
                  ? ((n = function (t) {
                      const i = r7(e, t[0], t[1]);
                      (t[0] = +i[0].toFixed(6)), (t[1] = +i[1].toFixed(6));
                    }),
                    (r = X6(i, n)))
                  : "DefaultProj4" == e
                  ? ((n = function (e) {
                      const i = o7(t, e[0], e[1]);
                      (e[0] = +i[0].toFixed(6)), (e[1] = +i[1].toFixed(6));
                    }),
                    (r = X6(i, n)))
                  : ((n = function (i) {
                      const n = n7(t, e, i[0], i[1]);
                      (i[0] = +n[0].toFixed(6)), (i[1] = +n[1].toFixed(6));
                    }),
                    (r = X6(i, n))),
                r
              );
            })(t, e, i)),
        r
      );
    },
    proj4: Y6,
  },
  s7 = V6(a7);
class l7 extends WZ {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "buildRowData", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: (t) => {
          if (!l7.analyticDeclaration) return;
          if (M(this.POMNode.viz)) return;
          const e = this.POMNode.viz.analytic,
            i = this.POMNode.viz.vizData,
            { vizFieldBlock: n } = l7.analyticDeclaration,
            r = (n) =>
              new Proxy(
                {},
                {
                  get: (r, o) => {
                    const a = e.vizFieldBlock[n].find((t) => t.name === o);
                    return I(a.id, i)(t[a.id]);
                  },
                }
              ),
            o = (e) =>
              new Proxy(
                {},
                {
                  get: (n, r) => {
                    const o = i.locationMap[e].find((t) => i.aliasMap[t] === r);
                    return I(o, i)(t[o]);
                  },
                }
              );
          if (e.source.type === h.Query) {
            const t = Object.fromEntries(n.map((t) => [t.title_cn, r(t.name)])),
              e = Object.fromEntries(n.map((t) => [t.title_en, r(t.name)])),
              i = Object.fromEntries(n.map((t) => [t.name, r(t.name)]));
            return Object.assign(t, e, i);
          }
          {
            const t = Object.fromEntries(
              Object.keys(i.locationMap).map((t) => [t, o(t)])
            );
            return Object.assign({}, t);
          }
        },
      });
  }
  render(t) {
    var e, i, n;
    (null ===
      (n =
        null ===
          (i =
            null === (e = this.POMNode.page) || void 0 === e
              ? void 0
              : e.host) || void 0 === i
          ? void 0
          : i.layer) || void 0 === n
      ? void 0
      : n.variableContext.gis) &&
      (t &&
        ((this.POMNode.properties = IX(MZ.presets, this.POMNode.properties)),
        (this.variableContext.centerPointLayer = null),
        (this.parent = this.POMNode.page.host.layer),
        this.parent.drillEndCallback.push(
          this.updateDataAfterDrill.bind(this)
        )),
      this.variableContext.gis ||
        (this.variableContext.gis =
          this.POMNode.page.host.layer.variableContext.gis),
      this.variableContext.gisLayer ? super.update() : this.initLayer(),
      M(this.POMNode.viz)
        ? this.editMode !== g.View && this.renderDefaultTips()
        : this.setData(),
      t && this.updateGisLayerVisible());
  }
  initLayer() {
    const t = this.getLayerConfig(),
      e = new RY(
        this.variableContext.gis,
        IX(t, {
          common: {
            zIndex: this.zIndex,
          },
          clipMode: YX(this.parent.POMNode.renderType),
          fields: {
            majorPOIField: "majorPOI",
            minorPOIField: "minorPOI",
            colorField: "color",
          },
        })
      ),
      i = new eY(this.variableContext.gis, this.getCenterPointLayerConfig());
    (this.variableContext.gisLayer = e),
      (this.variableContext.centerPointLayer = i),
      (this.preProperties = u(this.properties)),
      this.initHandle();
  }
  initHandle() {
    super.initHandle(), this.initEventListener();
  }
  initEventListener() {
    const { gisLayer: t } = this.variableContext;
    t.on("click", (t) => {
      if (this.comboTimer) {
        if (
          (clearTimeout(this.comboTimer),
          (this.comboTimer = setTimeout(() => {
            this.comboTimer = void 0;
          }, this.comboTimeout)),
          t)
        ) {
          const e = t.properties,
            i = this.buildRowData(e);
          s.call(this, b.AreaDbClick, {
            RowData: i,
          });
        }
      } else
        this.comboTimer = setTimeout(() => {
          if (((this.comboTimer = void 0), t)) {
            const e = t.properties,
              i = this.buildRowData(e);
            let n = !1;
            L(e) || !f(this.selectedItem, e)
              ? ((this.selectedItem = e), (n = !0))
              : (this.selectedItem = null),
              s.call(this, b.AreaClick, {
                RowData: i,
                selected: n,
              });
          } else
            this.selectedItem &&
              ((this.selectedItem = null),
              s.call(this, b.ChartBlankClick, {
                selected: !1,
              }));
        }, this.comboTimeout);
    });
  }
  getLayerConfig() {
    const { style: t, common: e, poi: i } = this.properties;
    let n = i.enable;
    n && this.editMode !== g.View && "show" !== i.trigger && (n = !1);
    return {
      common: {
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          color: t.color,
        },
        stroke: {
          color: t.outline.color,
          width: t.outline.width,
          opacity: t.outline.opacity,
        },
      },
      poi: {
        ...i,
        enabled: n,
        coverEnable: !i.coverEnable,
        background: {
          ...i.background,
          map: this.replaceStaticTemplatePath(i.background.image),
          borderRadius: [
            i.background.borderRadius.topLeft,
            i.background.borderRadius.topRight,
            i.background.borderRadius.bottomRight,
            i.background.borderRadius.bottomLeft,
          ],
        },
        major: {
          ...i.labelFontStyle,
          enabled: i.labelFontStyle.enable,
          fontFamily: RX(i.labelFontStyle.fontFamily),
        },
        minor: {
          ...i.valueFontStyle,
          enabled: i.valueFontStyle.enable,
          fontFamily: RX(i.valueFontStyle.fontFamily),
        },
      },
      interaction: {
        hover: {
          enabled: this.editMode === g.View && "hover" === i.trigger,
          trigger: "mousemove",
          effect: {
            poi: !0,
          },
        },
        select: {
          enabled: this.editMode === g.View && "click" === i.trigger,
          multi: !1,
          trigger: "click",
          effect: {
            color: "1.3",
            poi: !0,
          },
        },
      },
    };
  }
  getCenterPointLayerConfig() {
    const { centerPoint: t, common: e } = this.properties;
    return {
      common: {
        visible: this.plot.visible ? t.enable : this.plot.visible,
        zoomRange: [e.zoomMin, e.zoomMax],
      },
      style: {
        fill: {
          map: {
            type: "constant",
            constant: this.replaceStaticTemplatePath(t.image),
          },
          color: {
            type: "constant",
            constant: null,
          },
        },
        size: {
          type: "constant",
          constant: t.size,
        },
        segments: 4,
      },
      animation: {
        opacity: {
          enabled: !1,
        },
        scale: {
          enabled: !1,
        },
      },
    };
  }
  setCenterPointLayerConfig() {
    const { centerPointLayer: t } = this.variableContext,
      e = this.getCenterPointLayerConfig();
    t.set(e);
  }
  setElementVisibility(t) {
    this.variableContext.gis &&
      (this.variableContext.gisLayer.set({
        common: {
          visible: t,
        },
      }),
      this.variableContext.centerPointLayer.set({
        common: {
          visible: t ? this.properties.centerPoint.enable : t,
        },
      }),
      t && this.errorTip ? this.renderTips(this.errorTip) : this.removeTips(!1),
      super.tickOnce());
  }
  renderTips(t) {
    const { centerPointLayer: e } = this.variableContext;
    kZ.call(this, t),
      this.variableContext.gisLayer
        ? ((this.preVizData = void 0),
          this.variableContext.gisLayer.set({
            data: [],
          }),
          e.set({
            data: [],
          }),
          super.tickOnce())
        : this.render(!0);
  }
  updateDataAfterDrill() {
    this.setData(!0);
  }
  async setData(t = !1) {
    if (M(this.POMNode.viz)) return;
    const {
      common: { showAllLevelData: e },
      feature: { token: i },
      poi: { labelFontStyle: n, valueFontStyle: r },
    } = this.properties;
    if (!i) {
      if (this.editMode !== g.View) {
        const t = new y(v.RenderError, S("请在右侧配置 Mapbox Token"));
        this.renderTips(t);
      }
      return;
    }
    const { gis: o, gisLayer: a, centerPointLayer: s } = this.variableContext,
      { vizData: l, analytic: c } = this.POMNode.viz;
    if (!t && f(this.preVizData, l)) return;
    if ((this.removeTips(), !l || 0 === l.datasets.length))
      return (
        (this.preVizData = void 0),
        a.set({
          data: [],
        }),
        s.set({
          data: [],
        }),
        void super.tickOnce()
      );
    const h = [];
    try {
      const t = await lQ({
        vizData: l,
        analytic: c,
        gis: o,
        hasColorChannel: !1,
        hasSizeChannel: !1,
        hasPoiChannel: !0,
        showAllLevelData: e,
        renderType: this.parent.POMNode.renderType,
      });
      h.push(...t);
    } catch (x) {
      console.error("[vscreen-gis]", "数据解析经纬度失败", x);
    }
    this.preVizData = l;
    const p = OX("majorLabel", l, c, 1),
      d = OX("subLabel", l, c, 2),
      m = I(p, l),
      b = I(d, l);
    if (h.length > 0) {
      const t = [],
        e = [];
      h.forEach((i) => {
        e.push(i), t.push(this.getIsoData(i));
      });
      try {
        const i = await Promise.all(t);
        a.set({
          data: u(i.filter((t) => t)),
          originPoints: u(e),
          poi: {
            major: {
              format: (t) => n.prefix + m(t) + n.suffix,
            },
            minor: {
              format: (t) => r.prefix + b(t) + r.suffix,
            },
          },
        }),
          s.set({
            data: u(e),
          });
      } catch (_) {
        if (this.editMode !== g.View) {
          const t = new y(
            v.RenderError,
            S("Mapbox 服务异常，请检查网络情况及 Token 是否正确")
          );
          this.renderTips(t);
        }
        return;
      }
    } else
      a.set({
        data: [],
      }),
        s.set({
          data: [],
        });
    super.tickOnce();
  }
  async getIsoData(t) {
    const { lng: e, lat: i } = t,
      {
        feature: { token: n, profile: r, minutes: o },
      } = this.properties,
      a = s7.DefaultProj4toWGS84(e, i),
      s = a[0],
      l = a[1],
      c = await fetch(
        `https://api.mapbox.com/isochrone/v1/mapbox/${r}/${s},${l}?contours_minutes=${o}&polygons=true&access_token=${n}`,
        {
          method: "GET",
        }
      ),
      h = await c.json();
    if (h.features) {
      const e = h.features[0].geometry.coordinates[0].map((e) => ({
        lng: e[0],
        lat: e[1],
        ext: u(t),
      }));
      return s7.coordTranslate("EPSG:4326", "DefaultProj4", e, "dataArray");
    }
    return console.error("[vscreen-gis]", "等时圈数据解析失败", t), null;
  }
  initPropsWatchRule() {
    super.initPropsWatchRule(),
      this.propsWatch.addWatch([
        this.propsWatch.defaultRule(
          [["common", "showAllLevelData"], ["feature"]],
          "diffAnyoneDeep",
          () => {
            this.setData(!0);
          },
          !0
        ),
        this.propsWatch.defaultRule(
          [
            ["common", "zoomMin"],
            ["common", "zoomMax"],
          ],
          "diffAnyoneDeep",
          () => {
            super.setLayerConfig(),
              this.setCenterPointLayerConfig(),
              super.tickOnce();
          }
        ),
        this.propsWatch.defaultRule(["poi", "style"], "diffAnyoneDeep", () => {
          super.setLayerConfig(), super.tickLoop();
        }),
        this.propsWatch.defaultRule(["centerPoint"], "diffAnyoneDeep", () => {
          this.setCenterPointLayerConfig(), super.tickLoop();
        }),
      ]);
  }
  destroy() {
    this.variableContext.centerPointLayer.remove(), super.destroy();
  }
}
Object.defineProperty(l7, "chartConstraintRequest", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: P.GIS_MAP,
}),
  Object.defineProperty(l7, "analyticDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Z2[tX.Isochrone],
  }),
  Object.defineProperty(l7, "componentFilterDeclaration", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: F2[tX.Isochrone],
  }),
  Object.defineProperty(l7, "events", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: [
      {
        title_cn: "每项区域单击",
        title_en: "Area Click",
        value: b.AreaClick,
      },
      {
        title_cn: "每项区域双击",
        title_en: "Area Double Click",
        value: b.AreaDbClick,
      },
      {
        title_cn: "数据更新完成",
        title_en: "Data Updated",
        value: b.DataUpdated,
      },
      {
        title_cn: "加载前",
        title_en: "Before Element Load",
        value: b.BeforeLoad,
      },
      {
        title_cn: "加载完成",
        title_en: "Element Loaded",
        value: b.Loaded,
      },
    ],
  }),
  e.enableBoundaryChecking(!1);
const u7 = {
    [tX.CHINA_GIS]: O2,
    [tX.WOLRD_GIS]: O2,
    [tX.CUSTOM_GIS]: O2,
    [tX.FlyLine]: r3,
    [tX.Path]: o3,
    [tX.DistrictHeatMap]: t3,
    [tX.HeatMap]: i3,
    [tX.HexagonHeatMap]: n3,
    [tX.GridHeatMap]: e3,
    [tX.Isochrone]: l7,
    [tX.Column]: s3,
    [tX.Bubble]: a3,
    [tX.Ground]: class extends WZ {
      render(t) {
        var e, i, n;
        (null ===
          (n =
            null ===
              (i =
                null === (e = this.POMNode.page) || void 0 === e
                  ? void 0
                  : e.host) || void 0 === i
              ? void 0
              : i.layer) || void 0 === n
          ? void 0
          : n.variableContext.gis) &&
          (t &&
            ((this.POMNode.properties = IX(
              xX.presets,
              this.POMNode.properties
            )),
            (this.parent = this.POMNode.page.host.layer)),
          this.variableContext.gis ||
            (this.variableContext.gis =
              this.POMNode.page.host.layer.variableContext.gis),
          this.variableContext.gisLayer ? super.update() : this.initLayer(),
          t && this.updateGisLayerVisible());
      }
      initLayer() {
        const t = this.getLayerConfig(),
          e = new sY(
            this.variableContext.gis,
            IX(t, {
              common: {
                zIndex: this.zIndex,
              },
              style: {
                fill: {
                  color: "rgba(255,255,255,0)",
                },
              },
            })
          );
        (this.variableContext.gisLayer = e),
          this.setLayerAnimation(),
          (this.preProperties = u(this.properties)),
          super.tickLoop(),
          super.initHandle();
      }
      getLayerConfig() {
        const { surface: t, common: e } = this.properties;
        return {
          common: {
            zoomRange: [e.zoomMin, e.zoomMax],
            offset: [t.offsetX * KY, t.offsetY * KY, t.offsetZ * KY],
          },
          style: {
            fill: {
              opacity: 0.01 * t.opacity,
              map: this.replaceStaticTemplatePath(t.image),
            },
          },
          width: t.width,
          height: t.height,
        };
      }
      setLayerAnimation() {
        const { rotate: t } = this.properties,
          { gisLayer: e } = this.variableContext;
        e.animation.set({
          speed: 0.001 * t.speed,
        }),
          t.enable ? e.animation.start() : e.animation.pause();
      }
      initPropsWatchRule() {
        super.initPropsWatchRule(),
          this.propsWatch.addWatch([
            this.propsWatch.defaultRule(["surface"], "diffAnyoneDeep", () => {
              super.setLayerConfig(), super.tickLoop();
            }),
            this.propsWatch.defaultRule("rotate", "diffDeep", () => {
              this.setLayerAnimation(), super.tickLoop();
            }),
          ]);
      }
      destroy() {
        super.destroy();
      }
    },
    [tX.Raising]: class extends WZ {
      constructor() {
        super(...arguments),
          Object.defineProperty(this, "spriteImages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: YZ,
          });
      }
      render(t) {
        var e, i, n;
        (null ===
          (n =
            null ===
              (i =
                null === (e = this.POMNode.page) || void 0 === e
                  ? void 0
                  : e.host) || void 0 === i
              ? void 0
              : i.layer) || void 0 === n
          ? void 0
          : n.variableContext.gis) &&
          (t &&
            ((this.POMNode.properties = IX(
              CX.presets,
              this.POMNode.properties
            )),
            (this.parent = this.POMNode.page.host.layer)),
          this.variableContext.gis ||
            (this.variableContext.gis =
              this.POMNode.page.host.layer.variableContext.gis),
          this.variableContext.gisLayer ? super.update() : this.initLayer(),
          t && this.updateGisLayerVisible());
      }
      initLayer() {
        const t = this.getLayerConfig(),
          e = new hY(
            this.variableContext.gis,
            IX(t, {
              common: {
                zIndex: this.zIndex,
              },
            })
          );
        (this.variableContext.gisLayer = e),
          (this.preProperties = u(this.properties)),
          e.animation.start(),
          super.tickLoop(),
          super.initHandle();
      }
      getLayerConfig() {
        const {
          display: t,
          common: e,
          animation: i,
          scope: n,
        } = this.properties;
        return {
          common: {
            zoomRange: [e.zoomMin, e.zoomMax],
          },
          style: {
            fill: {
              maps: this.spriteImages,
            },
          },
          count: t.count,
          flash: 0 === i.flashSpeed ? 0 : 101 - i.flashSpeed,
          size: {
            minWidth: t.width,
            maxWidth: t.width,
            minHeight: t.height,
            maxHeight: t.height,
          },
          scope: {
            width: n.length,
            height: n.width,
            altitude: n.height,
          },
          minSpeed: i.speedMin / 100,
          maxSpeed: i.speedMax / 100,
        };
      }
      initPropsWatchRule() {
        super.initPropsWatchRule(),
          this.propsWatch.addWatch([
            this.propsWatch.defaultRule(
              ["display", "animation", "scope"],
              "diffAnyoneDeep",
              () => {
                super.setLayerConfig(), super.tickLoop();
              }
            ),
          ]);
      }
      destroy() {
        super.destroy();
      }
    },
    [tX.Particle]: class extends WZ {
      render(t) {
        var e, i, n;
        (null ===
          (n =
            null ===
              (i =
                null === (e = this.POMNode.page) || void 0 === e
                  ? void 0
                  : e.host) || void 0 === i
              ? void 0
              : i.layer) || void 0 === n
          ? void 0
          : n.variableContext.gis) &&
          (t &&
            ((this.POMNode.properties = IX(
              SX.presets,
              this.POMNode.properties
            )),
            (this.parent = this.POMNode.page.host.layer)),
          this.variableContext.gis ||
            (this.variableContext.gis =
              this.POMNode.page.host.layer.variableContext.gis),
          this.variableContext.gisLayer || this.initLayer(),
          super.update(),
          t && this.updateGisLayerVisible());
      }
      initLayer() {
        const t = this.getLayerConfig(),
          e = new uY(
            this.variableContext.gis,
            IX(t, {
              common: {
                zIndex: this.zIndex,
              },
            })
          );
        (this.variableContext.gisLayer = e),
          (this.preProperties = u(this.properties)),
          e.animation.start(),
          super.tickLoop(),
          super.initHandle();
      }
      getLayerConfig() {
        var t;
        const {
          display: e,
          common: i,
          animation: n,
          scope: r,
        } = this.properties;
        return {
          common: {
            zoomRange: [i.zoomMin, i.zoomMax],
          },
          style: {
            fill: {
              map:
                null !== (t = this.replaceStaticTemplatePath(e.image)) &&
                void 0 !== t
                  ? t
                  : "",
            },
          },
          size: e.size,
          count: e.count,
          scope: {
            width: r.length,
            height: r.width,
            altitude: r.height,
          },
          minSpeed: n.speedMin / 100,
          maxSpeed: n.speedMax / 100,
        };
      }
      initPropsWatchRule() {
        super.initPropsWatchRule(),
          this.propsWatch.addWatch([
            this.propsWatch.defaultRule(
              ["display", "animation", "scope"],
              "diffAnyoneDeep",
              () => {
                super.setLayerConfig(), super.tickLoop();
              }
            ),
          ]);
      }
      destroy() {
        super.destroy();
      }
    },
    [tX.LabelScatter]: u3,
    [tX.InformationLabel]: l3,
  },
  c7 = {
    [tX.CHINA_GIS]: zY,
    [tX.WOLRD_GIS]: GY,
    [tX.CUSTOM_GIS]: Z,
    [tX.FlyLine]: WY,
    [tX.Path]: qY,
    [tX.DistrictHeatMap]: UY,
    [tX.HeatMap]: HY,
    [tX.HexagonHeatMap]: VY,
    [tX.GridHeatMap]: jY,
    [tX.Isochrone]: gX,
    [tX.Column]: XY,
    [tX.Bubble]: YY,
    [tX.Ground]: W,
    [tX.Raising]: Y,
    [tX.Particle]: q,
    [tX.LabelScatter]: fX,
    [tX.InformationLabel]: dX,
  },
  h7 = CZ;
export { c7 as attributes, h7 as components, u7 as renderers };
